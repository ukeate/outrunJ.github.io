<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>介绍 on outrun的笔记</title>
    <link>https://runout.run/</link>
    <description>Recent content in 介绍 on outrun的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://runout.run/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>苹果</title>
      <link>https://runout.run/posts/apple/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://runout.run/posts/apple/</guid>
      <description>&lt;pre&gt;&lt;code&gt;伊甸的苹果、如今的苹果公司&#xA;其背后主使相同&#xA;其目的相同：创造一个本来不存在的产品，使人放不下&#xA;人放得下才得自在，放不下即达到了其它的目的，使人堕落&#xA;这个主使一直至力于渗透到人们生活中，在方方面面展示自己的标志、粉饰自己名号的形象&#xA;需要警惕&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>科技交互升维</title>
      <link>https://runout.run/posts/tech_dimension/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://runout.run/posts/tech_dimension/</guid>
      <description>&lt;h1 id=&#34;内容形式&#34;&gt;&#xA;  内容形式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ae%b9%e5%bd%a2%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;DOS: 一维，按行做文字输入&#xA;Windows：二维，平台窗口&#xA;Reality：三维，模拟空间&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;展示形式&#34;&gt;&#xA;  展示形式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%95%e7%a4%ba%e5%bd%a2%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;纸带：一维&#xA;显示器：二维&#xA;眼镜：三维&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>信息量</title>
      <link>https://runout.run/posts/information/</link>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://runout.run/posts/information/</guid>
      <description>&lt;h1 id=&#34;随想&#34;&gt;&#xA;  随想&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%8f%e6%83%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;通常把认识到的时空称作4维(时间1+空间3)，即认为可观测到世界的所有信息量都在其中。&#xA;&#xA;但世界的信息量不止于此，它的运作不可能是无故运动木偶般的3D动画，高维是必然存在的，是它在干预这个世界。&#xA;4维世界只是更高维世界驱动下的投影，所谓的现实世界只是可观测到的投影。&#xA;所以人本身就是高维存在的，它显然不是由4维时空驱动的。&#xA;我们从时间的维度观测，一个3维的球穿过2维的平面，它的投影是从无到有再从有到无，放大再缩小的圆。&#xA;那么递推一下，一个高维的“球”到3维的投影是什么样，可能是一个从无到有再从有到无，放大再缩小的球体。&#xA;同时，并不是所有的高维的实体，都会在3维世界产生投影，就像不是所有的3维球体，都要穿过某个2维的平面。&#xA;所以：&#xA;1 世界不是4维的，因为其背后实体是高维的，投影种类繁多不一定是4维可见，如因果、感受。&#xA;1 我们观测到的投影，其背后的实体是复杂的，它透露出的信息是引人深思的。&#xA;2 我们观测不到却能莫名感受到的，其实体也存在，只是它把信息量投影到了”感受“这个维度。&#xA;3 我们毫无体查的并非不存在，无知的边界远大于已知，”眼见为实“的观点是错误的。&#xA;4 不存在偶然现象，所谓的偶然，只是观测到的投影，从无到有出现，又从有到无消失了&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>整理笔记到github</title>
      <link>https://runout.run/posts/note/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://runout.run/posts/note/</guid>
      <description>&lt;h1 id=&#34;记笔记&#34;&gt;&#xA;  记笔记&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%b0%e7%ac%94%e8%ae%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;由于从事软件行业，信息量大，所以养成了记笔记的习惯。&lt;br/&gt;&#xA;笔记可以按自己的格式和思路写自己需要的，也便于查看。网上的东西对自己来说比较杂乱。&lt;br/&gt;&#xA;自学的都记了下来了，工作上的少些。&lt;/p&gt;&#xA;&lt;h1 id=&#34;笔记变更史&#34;&gt;&#xA;  笔记变更史&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%94%e8%ae%b0%e5%8f%98%e6%9b%b4%e5%8f%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;一开始用的是linux论坛上推荐的一个工具，现在名字都忘了。&lt;br/&gt;&#xA;后来一直在用mybase，感觉不错，到现在有5年了。但有几个问题:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;linux下容易打出乱码字符。&lt;/li&gt;&#xA;&lt;li&gt;删除文档容易出bug。&lt;/li&gt;&#xA;&lt;li&gt;格式不太好，版本7后用了html做内容，也会有些问题。&lt;/li&gt;&#xA;&lt;li&gt;是本地数据库，没法在线备份，也不好分享。毕竟东西都放网上比较方便。&lt;/li&gt;&#xA;&lt;li&gt;软件是收费的。（但开发者很良心，修改下软件配置就可以接着用，这个&amp;quot;bug&amp;quot;他们一直不修复）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;一直在考虑有道云笔记，开始时它功能不全，没有用。现在功能不错了，我又不想用了。&lt;br/&gt;&#xA;因为我想自己做一个，容易满足自己的想法和维护。&lt;br/&gt;&#xA;除这些之外gitbook也可以考虑&lt;/p&gt;&#xA;&lt;p&gt;Notion的问题： 数据不能备份，数据不一定安全，不能定制化建站&lt;/p&gt;&#xA;&lt;h1 id=&#34;现在&#34;&gt;&#xA;  现在&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%b0%e5%9c%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;这里是用了hugo和它的book主题，多谢它们的作者。&lt;br/&gt;&#xA;经过一段时间的整理，今天这个笔记可以用了，其它细节用到时再调整。&lt;/p&gt;</description>
    </item>
    <item>
      <title>博客原则</title>
      <link>https://runout.run/posts/first/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://runout.run/posts/first/</guid>
      <description>&lt;h1 id=&#34;博客原则&#34;&gt;&#xA;  博客原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%9a%e5%ae%a2%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;做有意义的分享&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>LinuxProgram</title>
      <link>https://runout.run/docs/tool/linux/linux_program/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://runout.run/docs/tool/linux/linux_program/</guid>
      <description>&lt;h1 id=&#34;系统编程&#34;&gt;&#xA;  系统编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;进程通信&#34;&gt;&#xA;  进程通信&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;对象&#xA;    ipc&#xA;种类&#xA;    消息队列&#xA;    共享内存&#xA;    信号量&#xA;消息队列&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;错误处理&#34;&gt;&#xA;  错误处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;curedump机制, 产生core文件&#xA;命令&#xA;    ulimit&#xA;目录&#xA;    /proc/[pid]/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;fork&#34;&gt;&#xA;  fork&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fork&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    子线程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;epoll&#34;&gt;&#xA;  epoll&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#epoll&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    多路复用io接口，提高大量并发连接中只有少量活跃情况下系统cpu利用率&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;signals&#34;&gt;&#xA;  signals&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#signals&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    unix系统中出错时显示的错误码（通常是拼在最后）&#xA;    http://people.cs.pitt.edu/~alanjawi/cs449/code/shell/UnixSignals.htm&#xA;SIGHUP&#x9;1&#x9;Exit&#x9;Hangup&#xA;SIGINT&#x9;2&#x9;Exit&#x9;Interrupt&#xA;SIGQUIT&#x9;3&#x9;Core&#x9;Quit&#xA;SIGILL&#x9;4&#x9;Core&#x9;Illegal Instruction&#xA;SIGTRAP&#x9;5&#x9;Core&#x9;Trace/Breakpoint Trap&#xA;SIGABRT&#x9;6&#x9;Core&#x9;Abort&#xA;SIGEMT&#x9;7&#x9;Core&#x9;Emulation Trap&#xA;SIGFPE&#x9;8&#x9;Core&#x9;Arithmetic Exception&#xA;SIGKILL&#x9;9&#x9;Exit&#x9;Killed&#xA;SIGBUS&#x9;10&#x9;Core&#x9;Bus Error&#xA;SIGSEGV&#x9;11&#x9;Core&#x9;Segmentation Fault&#xA;SIGSYS&#x9;12&#x9;Core&#x9;Bad System Call&#xA;SIGPIPE&#x9;13&#x9;Exit&#x9;Broken Pipe&#xA;SIGALRM&#x9;14&#x9;Exit&#x9;Alarm Clock&#xA;SIGTERM&#x9;15&#x9;Exit&#x9;Terminated&#xA;SIGUSR1&#x9;16&#x9;Exit&#x9;User Signal 1&#xA;SIGUSR2&#x9;17&#x9;Exit&#x9;User Signal 2&#xA;SIGCHLD&#x9;18&#x9;Ignore&#x9;Child Status&#xA;SIGPWR&#x9;19&#x9;Ignore&#x9;Power Fail/Restart&#xA;SIGWINCH&#x9;20&#x9;Ignore&#x9;Window Size Change&#xA;SIGURG&#x9;21&#x9;Ignore&#x9;Urgent Socket Condition&#xA;SIGPOLL&#x9;22&#x9;Ignore&#x9;Socket I/O Possible&#xA;SIGSTOP&#x9;23&#x9;Stop&#x9;Stopped (signal)&#xA;SIGTSTP&#x9;24&#x9;Stop&#x9;Stopped (user)&#xA;SIGCONT&#x9;25&#x9;Ignore&#x9;Continued&#xA;SIGTTIN&#x9;26&#x9;Stop&#x9;Stopped (tty input)&#xA;SIGTTOU&#x9;27&#x9;Stop&#x9;Stopped (tty output)&#xA;SIGVTALRM&#x9;28&#x9;Exit&#x9;Virtual Timer Expired&#xA;SIGPROF&#x9;29&#x9;Exit&#x9;Profiling Timer Expired&#xA;SIGXCPU&#x9;30&#x9;Core&#x9;CPU time limit exceeded&#xA;SIGXFSZ&#x9;31&#x9;Core&#x9;File size limit exceeded&#xA;SIGWAITING&#x9;32&#x9;Ignore&#x9;All LWPs blocked&#xA;SIGLWP&#x9;33&#x9;Ignore&#x9;Virtual Interprocessor Interrupt for Threads Library&#xA;SIGAIO&#x9;34&#x9;Ignore&#x9;Asynchronous I/O&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pf-kernel&#34;&gt;&#xA;  pf-kernel&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pf-kernel&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    是linux kernel 的fork, pf代表post-factum, 是作者的nickname&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;libev&#34;&gt;&#xA;  libev&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#libev&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;libevent&#xA;    介绍&#xA;        是linux kernel 的fork, pf代表post-factum, 是作者的nickname&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>LinuxScene</title>
      <link>https://runout.run/docs/tool/linux/scene/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://runout.run/docs/tool/linux/scene/</guid>
      <description>&lt;h1 id=&#34;场景&#34;&gt;&#xA;  场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;路由&#34;&gt;&#xA;  路由&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b7%af%e7%94%b1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;查路由表&#xA;    ip ro&#xA;    route -n&#xA;改路由&#xA;    route del -net 192.168.0.0 netmask 255.255.255.0 gw 10.146.81.117&#xA;转发&#xA;    ip ro ad 192.168.0.0/24 via [主机ip]&#xA;    主机配置&#xA;        echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&#xA;        # etc/sysctl.conf&#xA;            net.ipv4.ip_forward = 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;高并发&#34;&gt;&#xA;  高并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;查看当前TCP连接的状态和对应的连接数量：&#xA;    netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;&#xA;        # TIME_WAIT占用端口会影响后继新连接&#xA;初步优化（提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN攻击。）&#xA;    /etc/sysctl.conf&#xA;        net.ipv4.tcp_syncookies = 1&#xA;            # 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；&#xA;        net.ipv4.tcp_tw_reuse = 1&#xA;            # 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；&#xA;        net.ipv4.tcp_tw_recycle = 1&#xA;            # 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；&#xA;        net.ipv4.tcp_fin_timeout = 30&#xA;            # 修改系統默认的 TIMEOUT 时间。&#xA;    sysctl -p       # 生效&#xA;大流量下的优化&#xA;    # 如果你的连接数本身就很多，我们可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力&#xA;    /etc/sysctl.conf&#xA;    net.ipv4.tcp_keepalive_time = 1200&#xA;        # 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。&#xA;    net.ipv4.ip_local_port_range = 10000 65000&#xA;        # 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）&#xA;    net.ipv4.tcp_max_syn_backlog = 8192&#xA;        # 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。&#xA;    net.ipv4.tcp_max_tw_buckets = 6000&#xA;        # 表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默 认为180000，改为6000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。&#xA;其它参数说明&#xA;    net.ipv4.tcp_max_syn_backlog = 65536&#xA;        # 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。&#xA;    net.core.netdev_max_backlog = 32768&#xA;        # 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。&#xA;    net.core.somaxconn = 32768&#xA;        # web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。&#xA;    net.core.wmem_default = 8388608&#xA;    net.core.rmem_default = 8388608&#xA;    net.core.rmem_max = 16777216           #最大socket读buffer,可参考的优化值:873200&#xA;    net.core.wmem_max = 16777216           #最大socket写buffer,可参考的优化值:873200&#xA;    net.ipv4.tcp_timestsmps = 0&#xA;        # 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。&#xA;    net.ipv4.tcp_synack_retries = 2&#xA;        # 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。&#xA;    net.ipv4.tcp_syn_retries = 2&#xA;        # 在内核放弃建立连接之前发送SYN包的数量。&#xA;    #net.ipv4.tcp_tw_len = 1&#xA;    net.ipv4.tcp_tw_reuse = 1&#xA;        # 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。&#xA;    net.ipv4.tcp_wmem = 8192 436600 873200&#xA;        # TCP写buffer,可参考的优化值: 8192 436600 873200&#xA;    net.ipv4.tcp_rmem  = 32768 436600 873200&#xA;        # TCP读buffer,可参考的优化值: 32768 436600 873200&#xA;    net.ipv4.tcp_mem = 94500000 91500000 92700000&#xA;        # net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。&#xA;        # net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。&#xA;        # net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。&#xA;        # 上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864&#xA;    net.ipv4.tcp_max_orphans = 3276800&#xA;        # 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。&#xA;        # 如果超过这个数字，连接将即刻被复位并打印出警告信息。&#xA;        # 这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，&#xA;        # 更应该增加这个值(如果增加了内存之后)。&#xA;    net.ipv4.tcp_fin_timeout = 30&#xA;        #如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。&#xA;&#xA;    sysctl -w fs.file-max=12000000&#xA;    sysctl -w fs.nr_open=11000000&#xA;&#xA;    /etc/security/limits.conf&#xA;        nofile=10000000         # 文件句柄数&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>LinuxTool</title>
      <link>https://runout.run/docs/tool/linux/linux_tool/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://runout.run/docs/tool/linux/linux_tool/</guid>
      <description>&lt;h1 id=&#34;辅助&#34;&gt;&#xA;  辅助&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%85%e5%8a%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;快捷键&#34;&gt;&#xA;  快捷键&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e6%8d%b7%e9%94%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ctrl alt f1/f2/...      # 终端切换&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;帮助&#34;&gt;&#xA;  帮助&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%ae%e5%8a%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;man&#xA;    -f                  # 简要介绍&#xA;    -k                  # 通配搜索&#xA;whatis                  # man -f&#xA;apropos                 # man -k&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;命令行&#34;&gt;&#xA;  命令行&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4%e8%a1%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;clear&#xA;pwd                     # 当前路径&#xA;bash&#xA;    -c                  # 执行命令字符串&#xA;    set -o              # 设置快捷键模式，默认emacs&#xA;&#xA;    快捷键&#xA;        &amp;lt;Tab&amp;gt; bash补全&#xA;        &amp;lt;C-c&amp;gt; 中断&#xA;        &amp;lt;C-d&amp;gt; eof&#xA;        &amp;lt;C-tab&amp;gt; ls&#xA;        &amp;lt;C-l&amp;gt; clean&#xA;        &amp;lt;C-a&amp;gt; 移到行首&#xA;        &amp;lt;C-e&amp;gt; 移到行尾&#xA;        &amp;lt;C-u&amp;gt; 删除到行首&#xA;        &amp;lt;C-k&amp;gt; 删除到行尾&#xA;        &amp;lt;C-p&amp;gt; 上一个命令&#xA;        &amp;lt;C-n&amp;gt; 下一个命令&#xA;        &amp;lt;C-r&amp;gt; 查看历史      # &amp;lt;C-s&amp;gt; 向前查看历史&#xA;        &amp;lt;C-s&amp;gt; 冻结&#xA;        &amp;lt;C-q&amp;gt; 解冻&#xA;        &amp;lt;C-t&amp;gt; 交换字符&#xA;        &amp;lt;C-w&amp;gt; 删word&#xA;        &amp;lt;C-z&amp;gt; 暂停到后台&#xA;        &amp;lt;C-\&amp;gt; 中断&#xA;        &amp;lt;C-/&amp;gt; 撤消&#xA;        &amp;lt;C-_&amp;gt; 删除一行&#xA;        &amp;lt;M-r&amp;gt; 取消历史变更&#xA;    场景&#xA;        禁用&amp;lt;C-s&amp;gt;&amp;lt;C-q&amp;gt;, 以使&amp;lt;C-s&amp;gt;变为向前查看历史&#xA;            stty -ixon -ixoff&#xA;            stty STOP ^w            # 把原&amp;lt;C-s&amp;gt;改成&amp;lt;C-w&amp;gt;&#xA;zsh&#xA;fish&#xA;tmux&#xA;    session&#xA;    window&#xA;    pane&#xA;    ~/.tmux.conf&#xA;&#xA;    快捷键prefix &amp;lt;C-b&amp;gt;&#xA;&#xA;    系统&#xA;        prefix&#xA;            ?        # 帮助&#xA;            :        # 命令模式&#xA;            [        # 复制模式&#xA;        tmux&#xA;            kill-server&#xA;            source a&#xA;    session&#xA;        prefix&#xA;            d        # 脱离&#xA;            D        # 选择脱离&#xA;            r        # 重绘&#xA;            s        # 选择&#xA;            ~        # 信息历史&#xA;&#xA;        tmux&#xA;            ls&#xA;            attach a&#xA;                # 返回session&#xA;                -t name&#xA;            rename-session a&#xA;            switch -t a&#xA;    window&#xA;        prefix&#xA;            c        # 新建&#xA;            &amp;amp;        # 关闭&#xA;            ,        # 命名&#xA;            .        # 编号&#xA;            w        # 选择&#xA;            [0-9]        # 切换&#xA;            n        # 向后切换&#xA;            p        # 向前切换&#xA;            l        # 置换&#xA;            f        # 所有window查找&#xA;    pane&#xA;        prefix&#xA;            &amp;quot;            # 横分&#xA;            %            # 竖分&#xA;            x            # 关闭&#xA;            !            # 移到新window&#xA;            方向          # 切换&#xA;            o            # 切换到下一个&#xA;            &amp;lt;C-o&amp;gt;        # 向下旋转&#xA;            &amp;lt;M-o&amp;gt;        # 向上旋转&#xA;            {            # 向前置换&#xA;            }            # 向后转换&#xA;            &amp;lt;C-方向&amp;gt;      # 调整size&#xA;            &amp;lt;M-方向&amp;gt;      # 5倍调整size&#xA;            空格          # 切换布局&#xA;            &amp;lt;M-[0-5]&amp;gt;    # 选择布局&#xA;            q            # 显示编号&#xA;&#xA;    内置命令&#xA;        source-file a&#xA;screen&#xA;    -ls                 # 查看所有session&#xA;    -r                  # 进入id&#xA;echo&#xA;watch -n 1 -d netstat  -ant         # 监视&#xA;forturn                 # 随机名言&#xA;toilet                  # 彩虹字&#xA;cowsay                  # 牛说&#xA;source                  # 当前shell执行&#xA;figlet                  # 大写字&#xA;sl                      # 火车&#xA;cal 9 1752              # 打印日历&#xA;date +%Y/%m/%d/%H:%M&#xA;bc&#xA;maxima                  # 符号计算&#xA;factor                  # 分解质因数&#xA;expect                  # 为运行的脚本预填表单&#xA;    o-&amp;gt; 结束&#xA;    #!/usr/bin/expect&#xA;&#xA;    spawn ssh outrun@192.168.1.103&#xA;    expect &amp;quot;*password&amp;quot;&#xA;    send &amp;quot;asdf\n&amp;quot;&#xA;    expect eof&#xA;&#xA;    o-&amp;gt; 交互&#xA;    #!/usr/bin/expect -f&#xA;    spawn sudo /usr/local/mysql/bin/mysqld_safe --user=mysql&#xA;    expect &amp;quot;*password:*&amp;quot;&#xA;    send -- &amp;quot;asdf&amp;quot;&#xA;    send -- &amp;quot;\n&amp;quot;&#xA;&#xA;    interact            # interact留下交互, exit退出&#xA;&#xA;    o-&amp;gt; 后台执行        # 不要expect eof&#xA;    if [fork]!=0 exit&#xA;    disconnect&#xA;script/scriptreply      # 终端录制&#xA;    script -t 2&amp;gt;timing.log -a output.log&#xA;    scriptreply timing.log output.log&#xA;jobs                    # 后台作业&#xA;fg                      # 后台作业调度到前台&#xA;bg                      # 继续执行后台作业&#xA;nohup&#xA;    nohup *** &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;文字处理&#34;&gt;&#xA;  文字处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e5%ad%97%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uniq                    # 删除重复列&#xA;cat file1 file2         # 上下拼接&#xA;paste file1 file2       # 左右拼接&#xA;    -d &#39;-&#39;              # 加分隔符&#xA;tac                     # 倒转行显示&#xA;wc                      # 统计行, 单词, 字符&#xA;grep&#xA;    -v grep         # 过滤掉grep&#xA;    常用&#xA;        grep -nr --exclude-dir={.git, res, bin} &#39;a&#39; .&#xA;            # 递归查找&#xA;xargs&#xA;    -d &amp;quot;\t&amp;quot;         # 定义分隔符&#xA;    -t              # -t打印执行的命令&#xA;    -L 1            # 1行执行一次&#xA;    -n 1            # 一次使用1项&#xA;    -I arg1 sh -c &#39;echo arg1; mkdir arg1&#39;       &#xA;        # 执行多命令&#xA;    --max-procs 0   # 并行执行，不限数量&#xA;    常用&#xA;        代码行数&#xA;            find -name &amp;quot;*.go&amp;quot; -or -name &amp;quot;*.py&amp;quot; |xargs grep -v &amp;quot;^$&amp;quot; |wc -l&#xA;        复制最近修改的文件&#xA;            ls -rt | tail -4 | xargs -i cp -r {} ~/sdb/work/ryxWork/架构/&#xA;awk&#xA;    awk &#39;{print $1}&#39;&#xA;    awk &#39;{cmd=&amp;quot;kubectl delete pvc &amp;quot;$1;system(cmd)}&#39;&#xA;        # 按行执行命令&#xA;sed&#xA;    sed -i &#39;1i\new line&#39;&#xA;        # 第一行前插入&#xA;    常用&#xA;        替换文本&#xA;            sed -i &amp;quot;s/a/b/g&amp;quot; `grep -rl &amp;quot;a&amp;quot; ./`&#xA;sort&#xA;    -r                  # reverse&#xA;    -n                  # 显示行号&#xA;more&#xA;less&#xA;iconv&#xA;    -l                  # 列出已知的编码&#xA;    -f gbk -t utf-8 -c orig.txt -o tgt.txt      # 转码&#xA;head -2&#xA;tail -2&#xA;    -f&#xA;paste file1 file2       # 合并两个文件或两栏内容&#xA;    -d &#39;+&#39;              # 分隔符&#xA;nano&#xA;strings                 # 打印可打印字符&#xA;jq . a.json             # 验证json格式&#xA;pv -qL 10               # 文件缓慢显示&#xA;aview                   # 图片文件化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;媒体处理&#34;&gt;&#xA;  媒体处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%aa%92%e4%bd%93%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;convert                 # 转换图片&#xA;    convert a.jpg a.png # 转格式&#xA;&#xA;    -resize 1024x768&#xA;        convert -resize a.jpg a1.jpg&#xA;    -sample 50%x50%     # 缩略图&#xA;    -rotate 270         # 顺时针旋转270度&#xA;    -flip               # 左右翻转&#xA;    -paint 4            # 旋转角度&#xA;&#xA;    -draw               # 加文字&#xA;        convert -fill black -pointsize 60 -font helvetica -draw &#39;text 10,80 &amp;quot;A&amp;quot; ‘  a.jpg  a1.jpg&#xA;            # 用黑色, 60磅, helvetica字体, 在位置10,80 写A&#xA;    -raise 5x5          # 右下增加&#xA;    +raise 5x5          # 左上增加&#xA;    -bordercolor red -border 5x5                # 红色边框&#xA;    -mattecolor black -frame 5x5                # 黑色边框&#xA;&#xA;    -noise 3            # 油画&#xA;    -monochrome         # 噪声&#xA;    -blur 80            # 高斯模糊&#xA;    -flop               # 底片&#xA;    -negate             # 黑白&#xA;    -charcoal 2         # 炭笔&#xA;    -spread 30          # 漩涡&#xA;    -swirl 67           # 凸起&#xA;ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;系统&#34;&gt;&#xA;  系统&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;启动与任务&#34;&gt;&#xA;  启动与任务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%af%e5%8a%a8%e4%b8%8e%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;grub&#xA;    /etc/default/grub       # 设置文件&#xA;    grub2-mkconfig -o /boot/grub2/grub.cfg      # 使设置生效，update-grub 是debian下做的包装&#xA;upstart                     # 状态 waiting, starting, pre-start, spawned, post-start,running,pre-stop, stopping, killed, post-stop&#xA;systemv&#xA;systemd&#xA;systemctl&#xA;    status&#xA;    daemon-reload           # 修改service文件后重载&#xA;    systemctl list-units                        # list known units&#xA;    systemctl list-unit-files                   # 已知的services&#xA;    systemctl list-sockets                      # list socket units ordered by the listening address&#xA;    systemctl enable NAME                       # 设置开机启动, 生成service脚本命令&#xA;    systemctl disable NAME&#xA;    systemctl start NAME&#xA;    systemctl stop NAME&#xA;    systemctl restart NAME&#xA;    systemctl reload NAME&#xA;service&#xA;    service start&#xA;    service restart&#xA;    service stop&#xA;    service status&#xA;    service --status-all&#xA;chkconfig iptables on/off   # 设置服务启动&#xA;    --level 2345 iptables off                   # 查看各level服务状态&#xA;    --list iptables&#xA;at                      # 某时间运行一次&#xA;osmo                    # 计划任务软件&#xA;reap                    # 用于定时删除目录中文件，并打印日志&#xA;    -h                  # 打印帮助信息&#xA;    -t                  # 后台运行, 并设置时间间隔&#xA;    -s                  # single 单次运行&#xA;cron&#xA;    介绍&#xA;        crond服务在systemd中被timer取代&#xA;&#xA;    使用&#xA;        $ service crond start&#xA;        $ service crond stop&#xA;        $ service crond restart&#xA;        $ service crond reload                      # 重载配置&#xA;        $ crontab crontest.cron                     # 添加定时任务。打印的文件在用户根目录下&#xA;        $ crontab -l                                # 列出用户目前的crontab&#xA;        $ crontab -u                                # 设定某个用户的cron服务&#xA;        $ crontab -r                                # 删除某个用户的cron服务&#xA;        $ crontab -e                                # 编辑某个用户的cron服务&#xA;            # crontab -u root -l   查看root的设置&#xA;&#xA;        /etc/crontab                                # 系统配置文件&#xA;        /etc/cron.hourly&#xA;        /etc/cron.daily&#xA;        /etc/cron.weekly&#xA;        /etc/cron.monthly                           # 每小时、天、周、月执行的脚本&#xA;&#xA;        定时格式&#xA;            M H D m d cmd&#xA;                M: 分钟（0-59）每分钟用*或者 */1表示&#xA;                H: 小时（0-23）&#xA;                D: 天（1-31）&#xA;                m: 月（1-12）&#xA;                d: 一星期内的天（0~6，0为星期天）&#xA;                cmd: 如 ~/a.sh&#xA;    例子&#xA;        crontest.cron文件中&#xA;            15,30,45,59 * * * * echo &amp;quot;aa..........&amp;quot; &amp;gt;&amp;gt; aa.txt&#xA;                # 每15分钟执行一次打印&#xA;        0 */2 * * * date                            # 每两个小时&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;日志&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;dmesg                   # 启动日志&#xA;rsyslog                 # 日志管理, syslog的实现, 在systemd中被systemd-journal取代&#xA;mcelog                  # machine check exception log&#xA;journalctl              # 日志查看&#xA;    -x                  # 显示解释&#xA;    -e                  # 显示到底部&#xA;    -u                  # 指定unit名, 如kubelet&#xA;    --no-pager          # 不输出到管道来分页&#xA;    -f                  # 追加显示&#xA;    -q                  # 只显示warn以上信息&#xA;    --user-unit         # 指定用户&#xA;    --since &amp;quot;2018-03-26&amp;quot; &#xA;    --until &amp;quot;2018-03-26 03:00&amp;quot;&#xA;    场景&#xA;        journalctl -f --user-unit onedrive&#xA;        journalctl -xefu kubelet --no-pager&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;电源&#34;&gt;&#xA;  电源&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%b5%e6%ba%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;poweroff                # 立即关机&#xA;shutdown -h now&#xA;    -h                  # 关机&#xA;    -r                  # 重启&#xA;pm-suspend              # 挂起电脑&#xA;halt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;用户&#34;&gt;&#xA;  用户&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%a8%e6%88%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;w                       # 在线用户名, 终端号, 登录时间, 空闲时间, 终端连接所有进程时间, 当前进程时间, 当前命令&#xA;id outrun               # 用户信息&#xA;su&#xA;    常用&#xA;        切换登录&#xA;            sudo -i su outrun&#xA;sudo&#xA;id                      # 用户信息, 所在组&#xA;passwd                  # 修改密码&#xA;useradd outrun          # 创建用户&#xA;    -g outrun           # 指定组&#xA;    -r                  # 是系统用户&#xA;    -d /home/outrun     # 指定登录目录&#xA;    -u 544              # 指定id&#xA;userdel -r user1        # 完全删除用户&#xA;groups user1            # 查看组&#xA;groupadd ftp            # 创建组&#xA;usermod                 # 修改用户状态&#xA;    -a -G root outrun   # 加入组&#xA;    -l newuser user1    # 改名&#xA;    -L user1            # 锁定&#xA;    -U user1            # 解锁&#xA;    -d /home/ftp ftp    # 改登录目录&#xA;        -u 123 outrun       # 修改id&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内核&#34;&gt;&#xA;  内核&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e6%a0%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uname -a                # 查看版本&#xA;modprobe vboxdrv                    # 内核&#xA;lsmod                               # 显示当前系统加载的模块，如systemctl中start了的模块&#xA;dkms&#xA;    status&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;env                     # 查看所有环境变量&#xA;envsubst                # 编译文件中环境变量&#xA;    envsubst &#39;${THREAD_NUM}&#39; &amp;lt; decoder.conf.template &amp;gt; decoder.conf&#xA;getent                  # 查看系统数据库中数据&#xA;    group docker        # 查看docker用户组&#xA;ulimit -s unlimited     # 限制shell启动资源, 不限制堆栈大小&#xA;    -a 显示各种限制&#xA;    -u 10000 最大用户数&#xA;    -n 102400 文件句柄数&#xA;    -d unlimited 数据段长度&#xA;    -m unlimited 内存大小&#xA;    -t unlimited cpu时间&#xA;    -v unlimited 虚拟内存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;系统设备&#34;&gt;&#xA;  系统设备&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e8%ae%be%e5%a4%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;接口查看&#34;&gt;&#xA;  接口查看&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3%e6%9f%a5%e7%9c%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;lspci&#xA;lsusb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;显示器&#34;&gt;&#xA;  显示器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%be%e7%a4%ba%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;xrandr&#xA;    # 多显示器布局&#xA;    -q                         # 列出所有屏幕&#xA;    --verbose                   # 列出所有屏幕详情&#xA;    --output eDP1               # 指定屏幕&#xA;    --off                       # 禁用屏幕&#xA;    --primary                   # 指定主显示器&#xA;    --mode                      # 分辨率&#xA;    --pos                       # 指定屏幕在背景板的位置, 根据各屏幕分辨率、位置算&#xA;    --rotate                    # 旋转屏幕&#xA;        normal&#xA;        left&#xA;        right&#xA;        inverted&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;声卡&#34;&gt;&#xA;  声卡&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a3%b0%e5%8d%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;amixer set Master 100%  # 调节音量&#xA;alsamixer               # 调节声音&#xA;alsactl                 # 设置alsamixer&#xA;    store                      # 保存&#xA;    restore                    # 加载&#xA;aplay -l&#xA;    /etc/asound.conf&#xA;        defaults.pcm.card 1&#xA;        defaults.pcm.device 1&#xA;        defaults.ctl.card 1&#xA;pactl&#xA;    场景&#xA;        默认声卡&#xA;            pactl list short sources&#xA;            pactl list short sinks&#xA;            pactl set-default-source alsa_input.pci-0000_00_1b.0.analog-stereo&#xA;            pactl set-default-sink alsa_output.pci-0000_00_1b.0.analog-stereo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;系统监控&#34;&gt;&#xA;  系统监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;综合监控&#34;&gt;&#xA;  综合监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%bc%e5%90%88%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uptime                  # 当前时间, 运行时间, 用户数, 系统负载&#xA;tload                   # 系统负载图(用字符画)&#xA;top&#xA;    top -d 1 -p pid [,pid ...]&#xA;htop&#xA;    按键&#xA;        h               # 帮助&#xA;atop&#xA;btop&#xA;nmon&#xA;glances&#xA;netdata&#xA;vmstat                  # 获得有关进程、swap、内存、cpu等系统信息&#xA;dstat                   # 定时收集系统信息&#xA;sar                     # 全面的系统活动情况&#xA;    -u 3 5              # 查CPU负载, 3秒一次共5次 &#xA;    -d                  # 磁盘&#xA;    -r                  # 内存&#xA;    -W                  # SWAP&#xA;    -n DEV              # 网络接口&#xA;    -n SOCK             # socket连接信息&#xA;    -n TCP              # TCP连接&#xA;    -b                  # I/O速率&#xA;    -q                  # 平均负载&#xA;lxtask                  # GUI监控CPU、内存&#xA;sysdig&#xA;    sysdig&#xA;        -c&#xA;            topprocs_cpu            # 进程cpu top&#xA;                evt.cpu=0           # 只统计cpu0&#xA;            topprocs_net            # 进程带宽 top&#xA;            topprocs_file           # 进程硬盘i/o top&#xA;            topfiles_bytes          # 文件读写 top&#xA;                proc.name=httpd     # 指定进程名&#xA;            topfiles_time           # 文件时间 top&#xA;            topprocs_errors         # 进程error top&#xA;            topfiles_errors         # 文件error top&#xA;            topscalls_time          # 系统调用时间 top&#xA;            topscalls &amp;quot;evt.failed=true&amp;quot;                 # 系统调用出错 top&#xA;            topconns                # 网络连接 top&#xA;            fdcount_by&#xA;                proc.name &amp;quot;fd.type=file&amp;quot;                # 进程文件描述符&#xA;            fdbytes_by&#xA;                fd.directory &amp;quot;fd.type=file&amp;quot;             # 目录读写 top&#xA;                fd.filename &amp;quot;fd.directory=/tmp/&amp;quot;        # /tmp目录文件 读写top&#xA;                fd.type             # fd type i/o&#xA;            echo_fds &amp;quot;fd.filename=passwd&amp;quot;               # 所有名为passwd文件的i/o&#xA;            stdout&#xA;                proc.name=bash      # 进程标准输出&#xA;            fileslower 1            # 文件i/o 大于1ms&#xA;            spy_users               # 命令执行情况&#xA;&#xA;        -A                          # 只显示可读数据&#xA;        -s 4096                     # 指定 data buffer 字节&#xA;        -r trace.scap               #  指定trace file&#xA;        -pc                         # 详情&#xA;    csysdig                         # 交互式工具&#xA;        -vcontainers                # 容器资源&#xA;        -pc                         # 详情&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;slabtop                 # 内核片缓存信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  CPU&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;powertop                # intel开发，找到高功率进程&#xA;mpstat                  # cpu统计信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;进程&#34;&gt;&#xA;  进程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pidstat -p 434  # 进程使用资源的情况&#xA;    -u 1        # CPU&#xA;    -r 1        # 内存&#xA;    -d 1        # 磁盘&#xA;    -w          # 上下文切换&#xA;ps&#xA;    aux                 # 用在unix style中, BSD格式显示&#xA;    ef                  # 用在system v style中, 标准格式显示&#xA;pstree                  # 进程关系&#xA;pwdx [pid]              # 查看进程工作目录&#xA;    ll /proc/[pid]/cwd&#xA;pmap [pid]              # 进程&#xA;&#xA;kill 1024&#xA;    -9&#xA;        # 3 QUIT 退出(同ctrl + \)&#xA;        # 1 HUP 终端断线&#xA;        # 2 INT 中断(同ctrl + c)&#xA;        # 9 KILL 强制终止&#xA;        # 15 TERM 终止&#xA;        # 18 CONT 继续(与STOP相反, 同fg/bg)&#xA;        # 19 STOP 暂停(同ctrl + z)&#xA;    -l                  # 列出所有信号名称和编号&#xA;    常用&#xA;        删除名字的进程&#xA;            ps -ef|grep -v &amp;quot;grep&amp;quot;|grep aurora/app.js |awk &#39;{print $2}&#39;| xargs kill -9&#xA;pkill Xorg              # kill 所有包含&#xA;killall Xorg            # kill 所有包含&#xA;xkill                   # 运行后 在xwindow点击kill窗口&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;网络&#34;&gt;&#xA;  网络&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;配置-1&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;hostname&#xA;nmtui                   # 设置网卡&#xA;nmcli                       # 设置网络连接&#xA;    sudo nmcli c mod &#39;Wired connection 1&#39; ipv4.never-default false&#xA;        # 解决manual ip不能设置路由的问题&#xA;wpa_supplicant&#xA;iwlist                  # 列出无线网&#xA;iwconfig                # 无线网卡设置&#xA;wifi-menu&#xA;pppoe                   # 宽带&#xA;ifconfig&#xA;    打开, 关闭网卡&#xA;        ifconfig eth0 up&#xA;        ifconfig eth0 down&#xA;    临时修改ip&#xA;        ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up&#xA;            # up表示立即激活&#xA;    临时mac&#xA;        ifconfig enp0s20u6u3 hw ether 00:50:56:c0:00:02&#xA;    虚拟网卡&#xA;        ifconfig wlp7s0:1 ip netmask&#xA;            # 共用一个ip&#xA;netctl                  # 配置网卡服务&#xA;route                   &#xA;    -n                  # 查看路由表 &#xA;    //添加到主机的路由&#xA;    route add –host 192.168.168.110 dev eth0&#xA;    route add –host 192.168.168.119 gw 192.168.168.1&#xA;    //添加到网络的路由&#xA;    route add –net IP netmask MASK eth0&#xA;    route add –net IP netmask MASK gw IP&#xA;    route add –net IP/24 eth1&#xA;    //添加默认网关&#xA;    route add default gw IP&#xA;    //删除路由&#xA;    route del –host 192.168.168.110 dev eth0&#xA;arp -n                  # 显示局域网 ip mac表&#xA;    -s ip mac           # 设置ip mac表&#xA;ip                      # 网卡与ip信息&#xA;    添加路由&#xA;        ip route add 10.146.81.0/24 via 10.146.81.29&#xA;    配置ip段互斥的宿主机转发&#xA;        服务器&#xA;            ip link set up dev tun0&#xA;            sysctl net.ipv4.ip_forward=1&#xA;            /etc/sysctl.d/30-ipforward.conf&#xA;                net.ipv4.ip_forward=1&#xA;                net.ipv6.conf.default.forwarding=1&#xA;                net.ipv6.conf.all.forwarding=1&#xA;        客户端&#xA;            ip addr add 192.168.123.201/24 dev eth0             # 要转发的网段&#xA;            ip link set up dev eth0&#xA;            ip route add default via 192.168.123.100 dev eth0   # 服务器ip&#xA;hostapd                 # 无线热点&#xA;    yum install hostapd&#xA;    vi /etc/hostapd/hostapd.conf&#xA;        wpa_passphrase=asdfasdf&#xA;        ssid=myflowers&#xA;        interface=p3p1&#xA;&#xA;    yum install dhcp&#xA;    vi /etc/dhcp/dhcpd.conf&#xA;        option domain-name-servers 192.168.0.1,8.8.8.8;         # 自己的dns提供商&#xA;        option routers 192.168.0.42;    # 本机ip&#xA;        option domain-name &amp;quot;mydhcp&amp;quot;;&#xA;        option domain-name-servers 192.168.0.1;&#xA;        log-facility local7;&#xA;        subnet 192.168.0.0 netmask 255.255.255.0 {&#xA;            range  192.168.0.160 192.168.0.170;&#xA;            option broadcast-address 192.168.0.255;&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;测试工具&#34;&gt;&#xA;  测试工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ab                      # 压测&#xA;    ab -c 10 -n 100 https://www.baidu.com/&#xA;        # 10并发100次, url结尾要有/&#xA;mtr                     # myTrace, 合并ping与traceroute，默认发送ICMP包, 做持续探测, 避免节点波动的影响&#xA;traceroute              # 做一次探测, 默认UDP包, 发包TTL值逐渐增大&#xA;    -I                  # 使用ICMP包&#xA;ping&#xA;telnet&#xA;nslookup                    # 查域名ip&#xA;dig                     # 域名解析&#xA;nmblookup -A ip             # 查ip域名&#xA;nmap&#xA;    -sP ip/24           # 查看网内所有ip&#xA;    -p1-65535           # 扫描所有端口&#xA;    常用&#xA;        nmap 192.168.100.1/24 -p1-65535&#xA;nc                      # netcat, 功能全面&#xA;    -U a.sock           # 指定socket&#xA;    -v                  # 显示详情&#xA;    -z                  # 只测试连通&#xA;    -u                  # 使用udp&#xA;&#xA;    o-&amp;gt; 测试udp端口&#xA;    nc -vzu 127.0.0.1 1194&#xA;    o-&amp;gt; 文件传输&#xA;    nc -l -p 9999 | tar xf -&#xA;    tar cf - $(find . -name &amp;quot;*&amp;quot;) | nc -v 10.99.11.44 9999&#xA;rinetd                  # TCP端口转发&#xA;    rinetd.conf&#xA;        0.0.0.0 80 192.168.1.2 80    &#xA;    rinetd -c /etc/rinetd.conf&#xA;simplehttp&#xA;    python -m SimpleHTTPServer 8080&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;请求工具&#34;&gt;&#xA;  请求工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%b7%e6%b1%82%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;curl&#xA;    curl -v             # 详细头信息&#xA;    curl -H &amp;quot;Cookie: foo=bar; baz=val&amp;quot;          # 发送cookie&#xA;    curl -X post -k http://localhost:9090/a -H &amp;quot;Content-Type: text/plain&amp;quot; -d &#39;{&amp;quot;name&amp;quot;: &amp;quot;a&amp;quot;}&#39;&#xA;        # post请求&#xA;    curl -O http://104.223.142.166/isu80        # 抓文件&#xA;wget&#xA;    -i filelist.txt         # 下载一个文件中的所有url&#xA;    -x  # 强制创建目录&#xA;    -P  # 目录prefix&#xA;    -r  # 递归下载&#xA;    -l  # 最大递归深度, inf或0代表无限制&#xA;    -k  # 修改链接，指向本地文件&#xA;    -p  # 下载所有用于显示页面的资源, 如图片&#xA;    -L  # 只跟踪relative链接&#xA;    -N  # 只获取比本地新的文件&#xA;    -np # 不追踪父目录&#xA;    -m  # 缩写-N -r -l inf --no-remove-listing&#xA;    --no-remove-listing         # 不删除listing文件&#xA;&#xA;    常用&#xA;        爬网站&#xA;            wget -x -P curSite -r -l 100 -k -L -np http://nodeapi.ucdok.com/api/&#xA;            带cookie&#xA;                wget --post-data=&amp;quot;username=u1&amp;amp;password=asdf&amp;quot; --save-cookies=cookie --keep-session-cookies &amp;quot;http://www.abc.com/logging.php&amp;quot;&#xA;                wget -x -P curSite -r -l 1 -k -L -np --load-cookies=cookie --keep-session-cookies &amp;quot;https://www.abc.com/display/1&amp;quot;&#xA;ssh&#xA;    ssh 10.1.10.2 -L 9901:localhost:5901&#xA;        # 用ssh建tunnel访问内部端口&#xA;    ssh -t -L 5900:localhost:5900 remote_host &#39;x11vnc -localhost -display :0&#39;&#xA;        # 本机执行命令并端口映射&#xA;sshpass&#xA;    sshpass -p asdf ssh root@47.74.230.238&#xA;sshfs -o allow_other root@ip:~ /mnt                 # 挂载远程目录&#xA;scp a.txt root@ip:~&#xA;w3m                     # 命令行浏览器&#xA;vnc                     # 远程桌面&#xA;    Virtual Network Computing&#xA;    相关文章&#xA;        linux 自带远程桌面--VNC服务配置说明&#xA;    安装&#xA;        yum install vnc*&#xA;&#xA;        yum install *vnc-server*&#xA;    启动&#xA;        vncserver :1&#xA;    登录&#xA;        vncviewer        # fedora 下gnome自带的vncviewer名为:Remote Desktop Viewer&#xA;            输入192.168.0.62:1                      # 实际端口号为5901, 如果服务号为2则为5902&#xA;        或者浏览器java-plugin&#xA;            localhost:5801                          # 需要安装java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;监控&#34;&gt;&#xA;  监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;iftop -n                # 流量监控&#xA;ntop                    # 流量监控, web界面&#xA;    # localhost:3000&#xA;    -W 3001&#xA;                        # Loss%丢包率, Snt每秒包数, Last最近一次延迟, Avg平均值, Best最小值, Worst最大值, StDev标准差&#xA;    -u                  # 使用udp包&#xA;    --no-dns            # 不对ip做域名反解析&#xA;    -4                  # 只用ipv4&#xA;    -6                  # 只用ipv6&#xA;    结果&#xA;        1,2,3,4 本地网络&#xA;        5,6 运营商骨干网络&#xA;        7,8,9,10 目标服务器本地网络&#xA;            8 链路负载均衡&#xA;tcpdump&#xA;    -v                          # verbose输出&#xA;    -vvv            # 最详细输出&#xA;    -n                          # 网络地址显示数字&#xA;    -nn                         # ip和端口显示&#xA;    -i                          # 指定网卡&#xA;    -c 100                      # 100条后退出&#xA;    -w file1                    # 保存到文件&#xA;    -r file1 tcp                # 从文件读取，指定tcp协议&#xA;    -G 5 -w /opt/capfile-%Y_%m%d_%H%M_%S        # 滚动日志&#xA;    greater 200                 # 报文字节大于200&#xA;    host 192.168.0.1            # 包含ip&#xA;    port 80                     # 包含端口&#xA;    port !80&#xA;    dst host 192.168.0.1        # 目标ip&#xA;    dst port 80                 # 目标端口&#xA;    src host&#xA;    src port&#xA;    net 192.168.0.1/32          # 包含网段&#xA;    udp/tcp/icmp/igmp/arp       # 指定协议&#xA;    ip                          # ip协议&#xA;    ip proto ospf               # 类型为ospf的ip包&#xA;    ip[9]=6                     # ip包头第10字节为6（tcp协议）&#xA;    ether multicast                             # 二层类型为多播&#xA;    ether src host 00:0c:29:9a:1f:4e            # 二层mac&#xA;    常用&#xA;        tcpdump -i eth0 -vnn \(src host 8.8.8.8 and port 80 \) or \(src host 10.10.10.10 and dst port 443\)&#xA;        tcpdump -n tcp port 8383 -i lo and src host 183.14.132.117&#xA;iotop                   # 实时监视io&#xA;    p                   # 显示pid&#xA;    o                   # 只显示活跃&#xA;iostat                  # 负载情况&#xA;lsof -i:8080            # 列出当前系统打开的文件，必须root运行才准确&#xA;    -i                  # 端口&#xA;    -P                  # 显示端口号而非名称&#xA;    -n                  # 显示ip而非域名&#xA;    -i -n -P            # 查看进程句柄数&#xA;nicstat                 # 网络流量统计&#xA;netstat&#xA;    -a                  # 显示所有&#xA;    -n                  # 显示数字，而不是别名&#xA;    -t                  # 仅显示tcp&#xA;    -u                  # 仅显示udp&#xA;    -p                  # 显示建立链接的程序名&#xA;    -l                  # 仅列出listen的服务&#xA;    -o                  # 显示timer, 如keepalive&#xA;    -antpu              # 端口&#xA;tapestat                # 磁带驱动器信息&#xA;ss                      # 端口，性能高&#xA;    -l                  # listening&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;防火墙&#34;&gt;&#xA;  防火墙&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e7%81%ab%e5%a2%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;getenforce              # 查看selinux状态&#xA;sestatus -v             # 查看selinux状态&#xA;setenforce 0            # 临时关闭selinux&#xA;    1                   # 启用&#xA;ufw                     # ubuntu, 简化防火墙&#xA;iptables [-t 表] -命令 匹配 操作&#xA;    参数&#xA;        -t                  # 要操作的匹配表&#xA;        命令&#xA;            -P                  # 策略, INPUT等&#xA;            -A                  # append, 添加&#xA;            -I 1                # 在第2条前添加&#xA;            -D 1                # delete, 删除&#xA;            -R 1                # 替换&#xA;&#xA;            -L                  # list 显示&#xA;            -n                  # 端口以数字显示&#xA;            -v                  # verbose, 显示更多信息&#xA;            -F                  # flush&#xA;            -X                  # 清除自定chain&#xA;            -Z                  # 清除统计数&#xA;        规则&#xA;            -p                  # 协议&#xA;            -i                  # 指定网卡流入&#xA;            -o                  # 指定网卡流出&#xA;            -s                  # 来源ip, !表示排除&#xA;            -d                  # 目标ip&#xA;            --sport             # 源端口&#xA;            --dport             # 目标端口&#xA;            -m                  # 使用模块, 会根据-p选择模块&#xA;        动作&#xA;            -j                  # 跳转&#xA;                ACCEPT&#xA;    四表(table)&#xA;        raw             # 跟踪&#xA;        mangle          # 标记&#xA;        nat             # 修改ip、port&#xA;        filter          # 过滤, 默认&#xA;    五链(chain)&#xA;        PREROUTING&#xA;        FORWORD         # INPUT前转发到POSTROUTING&#xA;        INPUT&#xA;        OUTPUT&#xA;        POSTROUTING &#xA;    策略(policy)&#xA;        ACCEPT          # 通过&#xA;        REJECT          # 拒绝，返回数据&#xA;            返回数据包&#xA;                ICMP port-unreachable&#xA;                ICMP echo-reply&#xA;                tcp-reset&#xA;            iptables -A  INPUT -p TCP --dport 22 -j REJECT --reject-with ICMP echo-reply&#xA;        DROP            # 丢弃&#xA;        REDIRECT        # 导向端口(PNAT)&#xA;            iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT--to-ports 8081&#xA;        MASQUERADE      # 改写来源ip为本机ip, 可指定目标端口范围&#xA;            iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 21000-31000&#xA;        LOG             # 日志, 记在/var/log&#xA;            iptables -A INPUT -p tcp -j LOG --log-prefix &amp;quot;input packet&amp;quot;&#xA;        ULOG&#xA;        SNAT            # 改写源地址, 只适用POSTROUTING&#xA;            iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 192.168.10.15-192.168.10.160:2100-3200&#xA;        DNAT            # 改写目标地址, 只适用POSTROUTING&#xA;            iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.10.1-192.168.10.10:80-100&#xA;        TOS&#xA;        MIRROR          # 对调源ip与目标ip后返回&#xA;        QUEUE           # 封包入队列待处理，实现功能如：计算联机费用&#xA;        RETURN          # 退出当前规则链, 返回主规则链&#xA;        TTL&#xA;        MARK            # 对包做标记数字&#xA;            iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 22&#xA;    规则(rule)          # 自定义的条件&#xA;    配置文件&#xA;        /etc/sysconfig/iptables&#xA;        /usr/libexec/iptables/iptables.init&#xA;            save&#xA;        rules.v4        # 自定义配置&#xA;            *filter&#xA;            :INPUT ACCEPT [186:19951]&#xA;            :FORWARD ACCEPT [0:0]&#xA;            :OUTPUT ACCEPT [71:11164]&#xA;            -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT&#xA;            -A INPUT -p tcp -m tcp --dport 23 -j ACCEPT&#xA;            -A INPUT -p tcp -m tcp --dport 24 -j ACCEPT&#xA;            COMMIT&#xA;    命令&#xA;        systemctl enable iptables.service&#xA;        service iptables save&#xA;        service iptables restart&#xA;        iptables-restore &amp;lt; rules.v4&#xA;            # 导入配置&#xA;    案例&#xA;        关iptables&#xA;            service iptables stop&#xA;            chkconfig iptables off&#xA;        查看&#xA;            iptables -L -n -v --line-numbers&#xA;        查nat表&#xA;            iptables -t nat -L&#xA;        flush, 生效&#xA;            iptables -F&#xA;        service命令&#xA;            service iptables save&#xA;            service iptables stop&#xA;            service iptables start&#xA;            service iptables restart&#xA;        开机启动&#xA;            /etc/network/if-pre-up.d/iptables&#xA;                iptables-restore &amp;lt; rules.v4&#xA;&#xA;        插入规则&#xA;            iptables -I INPUT 2 -s 202.54.1.2 -j DROP&#xA;        删除规则&#xA;            iptables -D INPUT 4&#xA;        开放所有input/output&#xA;            iptables -P INPUT ACCEPT&#xA;            iptables -P OUTPUT ACCEPT&#xA;        开放input/output tcp 22&#xA;            iptables -A INPUT -p tcp --dport 22 -j ACCEPT&#xA;            iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT&#xA;        vpn转发&#xA;            iptables -t nat -A POSTROUTING -s 192.168.252.0/24 -j SNAT --to-source 10.171.83.146&#xA;        屏蔽私有地址&#xA;            iptables -A INPUT -i eth1 -s 192.168.0.0/24 -j DROP&#xA;            iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP&#xA;        屏蔽ip&#xA;            iptables -A INPUT -s 1.2.3.4 -j DROP&#xA;            iptables -A INPUT -s 192.168.0.0/24 -j DROP&#xA;            iptables -A OUTPUT -d 192.168.1.0/24 -j DROP&#xA;            iptables -A OUTPUT -o eth1 -d 192.168.1.0/24 -j DROP&#xA;        屏蔽端口&#xA;            iptables -A INPUT -p tcp -s 1.2.3.4 --dport 80 -j DROP&#xA;            iptables -A INPUT -i eth1 -p tcp -s 192.168.1.0/24 --dport 80 -j DROP&#xA;        记录并屏蔽&#xA;            iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j LOG --log-prefix &amp;quot;IP_SPOOF A: &amp;quot;&#xA;            iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP&#xA;        mac屏蔽&#xA;            iptables -A INPUT -m mac --mac-source 00:0F:EA:91:04:08 -j DROP&#xA;            # *only accept traffic for TCP port # 8080 from mac 00:0F:EA:91:04:07 * ##&#xA;            iptables -A INPUT -p tcp --destination-port 22 -m mac --mac-source 00:0F:EA:91:04:07 -j ACCEPT&#xA;        屏蔽icmp&#xA;            iptables -A INPUT -p icmp --icmp-type echo-request -j DROP&#xA;            iptables -A INPUT -i eth1 -p icmp --icmp-type echo-request -j DROP&#xA;        开启范围端口&#xA;            iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 7000:7010 -j ACCEPT&#xA;        开启范围ip&#xA;            iptables -A INPUT -p tcp --destination-port 80 -m iprange --src-range 192.168.1.100-192.168.1.200 -j ACCEPT&#xA;        nat&#xA;            iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 123.4.5.100&#xA;                # 改写来自192.168.1.0/24的包, 源ip为123.4.5.100&#xA;            iptables -t nat -A PREROUTING -s 192.168.1.0/24 -i eth1 -j DNAT --to 123.4.5.100&#xA;                # 改写来自192.168.1.0/24的包, 目标ip为123.4.5.100&#xA;            iptables -t nat -A POSTROUTING -s 172.27.0.0/16 -d 10.0.0.1 -p tcp --dport 80 -j SNAT --to-source MASQUERADE&#xA;                # 改写来自172.27.0.0/16去向10.0.0.1:80的tcp包, 源ip为本机ip&#xA;            iptables -t nat -A PREROUTING -d 192.168.1.1 -p tcp --dport 80 -j DNAT --to-destination 10.0.0.1&#xA;                # 改写去向192.168.1.1:80的tcp包, 目标ip为10.0.0.1&#xA;&#xA;firewall&#xA;    systemctl start firewalld&#xA;&#xA;    o-&amp;gt; ftp&#xA;    firewall-cmd --zone=public --add-port=20/tcp --permanent&#xA;    firewall-cmd --zone=public --add-port=21/tcp --permanent&#xA;    firewall-cmd --permanent --add-port=1000-2000/tcp&#xA;    firewall-cmd --complete-reload&#xA;&#xA;    o-&amp;gt; 8080&#xA;    firewall-cmd --query-port=8080/tcp&#xA;        --add-port=8080/tcp --permanent --zone=public&#xA;        --reload&#xA;        --get_active-zones&#xA;        --list-all&#xA;        --set-default-zone=public&#xA;    o-&amp;gt;&#xA;    firewall-cmd --permanent --remove-port=8080/tcp&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储&#34;&gt;&#xA;  存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;硬盘&#34;&gt;&#xA;  硬盘&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a1%ac%e7%9b%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;fdisk -l&#xA;cfdisk&#xA;sfdisk&#xA;parted&#xA;mkfs&#xA;mkswap&#xA;&#xA;testdisk /dev/sdb1&#xA;e2fsck -a /dev/sdb1         # 修复ext2&#xA;ntfsfix -d -b /dev/sdb1     # 修复ntfs坏扇区和脏标记&#xA;fsck /dev/sda1              # 检查并修复&#xA;&#xA;udisks --detach 设备编号     # 移除磁盘&#xA;&#xA;mount  /dev/sdb1 /mnt&#xA;    -o acl                  # 打开acl功能&#xA;    -o loop x.iso           # 挂载文件&#xA;    -o iocharset=utf8       # 指定编码&#xA;    -t vfat                 # 指定类型&#xA;umount&#xA;    -n                      # 执行umount却不写入&#xA;    -l                      # lazy&#xA;    -f                      # force&#xA;&#xA;df -h                       # 已挂载分区列表&#xA;    -T                      # 查看分区类型&#xA;blktrace                    # 磁盘访问情况&#xA;lsblk                       # 查看挂载的分区&#xA;lvs&#xA;    LVM逻辑卷的创建流程如下：&#xA;        将一个磁盘或分区格式化为物理卷：pvcreate /dev/sdb1&#xA;        将物理卷添加到一个卷组中：vgcreate linuxcast-vg /dev/sdb1 /dev/sdb2&#xA;        基于卷组创建一个逻辑卷mylv：lvcreate -L 10G -n mylv  linuxcast-vg&#xA;        格式化逻辑卷：mkfs.ext4 /dev/linuxcast-vg/mylv&#xA;        挂载使用：mount /dev/linuxcast-vg/mylv  /mnt&#xA;    逻辑卷查看命令：&#xA;    pvdisplay&#xA;    pvs&#xA;    vgdisplay&#xA;    vgs&#xA;    lvdisplay&#xA;    lvs&#xA;    删除一个逻辑卷：&#xA;    lvremove /dev/linuxcast-vg/mylv&#xA;    删除一个卷组：&#xA;    vgremove linuxcast-vg&#xA;    删除一个物理卷：&#xA;    pvremove /dev/sda1&#xA;nfsiostat               # nfs驱动器信息&#xA;cifsiostat              # CIFS信息&#xA;growpart                # 磁盘热扩容&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;文件操作&#34;&gt;&#xA;  文件操作&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;fuser                   # 查看文件被谁使用&#xA;    -u                  # 列出使用者用户名&#xA;    -uk                 # 终止文件的所有进程&#xA;    -n tcp 8080         # 列出端口的进程号&#xA;ldd /bin/ls             # 查看可执行文件动态引用模块&#xA;rename &#39;s/\.bak$//&#39; *.bak           # 重命名&#xA;rm -rf&#xA;touch&#xA;    -t 0712250000 file              # 修改文件时间戳(YYMMDDhhmm)&#xA;ls *[0-9]*&#xA;    -t                  # 时间排序&#xA;    -R                  # 递归显示文件&#xA;    -l                  # 详情&#xA;    -S                  # 按大小排列&#xA;    -r                  # reverse&#xA;    -h                  # 自动大小单位&#xA;    -F                  # 加后缀标识类型&#xA;    -Z                  # 显示文selinux状态&#xA;tree&#xA;mkdir&#xA;rmdir&#xA;cd&#xA;    ~&#xA;    -&#xA;cp&#xA;    -r                  # 递归&#xA;    -p                  # 带权限复制&#xA;    -d                  # 保留链接&#xA;    -a                  # -dpr&#xA;mv&#xA;whereis&#xA;which&#xA;find .&#xA;    maxdepth 1&#xA;    -name &amp;quot;*.go&amp;quot;&#xA;    -type f&#xA;    -atime +100         # 100天未使用过的执行文件&#xA;    -mtime -10          # 10天内创建或修改的文件&#xA;    -exec chmod +x      # 对找到的文件执行命令&#xA;    -xdev               # 忽略块设备&#xA;file                    # 探测文件类型&#xA;    file 可执行文件     # 可查看是否静态编译&#xA;ln&#xA;du -d 1 -h&#xA;    -s                  # 只返回汇总情况&#xA;    -k                  # 统一单位&#xA;tar xf&#xA;    cfzv x.tar.gz x     # 压缩&#xA;    xfzv x.tar.gz       # 解压&#xA;    --exclude=/proc&#xA;gzip x                  # 压缩&#xA;    -d x                # 解压&#xA;unzip&#xA;    常用&#xA;        unzip中转码&#xA;            unzip -P “$(echo 中文 | iconv -f utf-8 -t gbk)”&#xA;unzip-beta              # 解压并转码中文&#xA;diff        # 改变以匹配第二个文件&#xA;    diff -y a b&#xA;    diff dir1 dir2&#xA;&#xA;    diff -uN a b &amp;gt; b.patch&#xA;    patch -p0 &amp;lt; b.patch&#xA;    patch -RE -p0 &amp;lt; b.patch&#xA;&#xA;    diff -uNra a b &amp;gt; b.patch&#xA;    cd a&#xA;    patch -p1  &amp;lt; ../b.patch&#xA;    patch -RE -p1 &amp;lt; ../b.patch&#xA;rsync -av --exclude=.git --exclude=logs/* ./* 192.168.0.14:/data/app/ext-marketing/&#xA;vimdiff a b&#xA;&#xA;mucommander             # 跨平台文件管理软件&#xA;shred                   # 文件粉碎&#xA;rclone                  # 云存储同步&#xA;    config              # 配置向导&#xA;    ls [name]:          # 显示文件&#xA;    lsd [name]:         # 显示文件夹&#xA;    copy a [name]:a     # 上传&#xA;    cleanup             # 只保留最新版本&#xA;    sync                # 本地向远程同步&#xA;    mount               # 双向一致同步&#xA;        fusermount -u /path/to/local/mount&#xA;            # umount&#xA;rclone-browser          # rclone GUI&#xA;onedrive&#xA;    onedrive --resync&#xA;    常用命令&#xA;        systemctl --user enable onedrive&#xA;        systemctl --user start onedrive&#xA;        journalctl --user-unit onedrive -f&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;权限&#34;&gt;&#xA;  权限&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;chmod ugo+rwx           # u拥有者, g群组, o其他人, +添加, -删除, r读、w写、x执行&#xA;    chmod a+rwx         # a指所有人&#xA;chattr +i file          # 改变属性&#xA;lsattr file&#xA;chown -R outrun:outrun .&#xA;chgrp -R outrun .&#xA;getfacl                 # 查看一个文件的ACL设置&#xA;setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ...&#xA;    -b                  # 去掉所有acl设置&#xA;    -m u:sudo:rwx   filename    # 配置用户权限&#xA;    -m g:sudo:r-x  filename     # 配置组的权限&#xA;    -x u:user1 filename         # 删除一个ACL设置&#xA;    -d -m g:sudo:rwx            # 指定default&#xA;chcon                   # 修改文件安全上下文&#xA;    -R                  # 递归&#xA;    -t                  # type&#xA;    -u                  # user&#xA;    -r                  # role&#xA;    --reference         # 参照更新&#xA;    chcon -R -t mysqld_db_t /data&#xA;    chcon -R --reference=/var/lib/mysql /data&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;功能软件&#34;&gt;&#xA;  功能软件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%9f%e8%83%bd%e8%bd%af%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;包管理&#34;&gt;&#xA;  包管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8c%85%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;snap&#xA;    list                    # 列已安装&#xA;    info                    # 查看仓库所有版本&#xA;    find                    # 搜索&#xA;    install&#xA;    remove&#xA;    refresh                 # 更新&#xA;        refresh all&#xA;    revert                  # 还原到上个版本&#xA;        --revision          # 指定版本&#xA;    run                     # 运行命令&#xA;    start                   # 运行service&#xA;        --enable            # 开机启动&#xA;    stop                    # 停止service&#xA;    save                    # 存配置快照&#xA;    saved                   # 列出所有快照&#xA;rpm                         # 源 rpm fusion&#xA;    -i 安装&#xA;    -e 卸载&#xA;    -qa 查看安装的包名&#xA;    -ql 包名, 查看安装的文件&#xA;    -qc 包名, 查看软件的配置文件&#xA;pacman&#xA;    命令 pacman&amp;lt;操作&amp;gt; [选项] [目标]&#xA;        操作&#xA;            -Q                      # 查询&#xA;            -S                      # 安装&#xA;            -R                      # 删除&#xA;            -D                      # 数据库&#xA;            -F                      # 文件&#xA;        选项&#xA;        选项-S, -R, -U&#xA;            -s&#xA;        选项-S, -U&#xA;        选项-Q&#xA;            -s                      # 搜索&#xA;            -e                      # 明确指定的&#xA;            -n                      # 本地的&#xA;            -q                      # 静默&#xA;            -i                      # 详情, 两个i显示备份文件和修改状态, 显示依赖&#xA;            -l                      # 列出文件&#xA;            -o                      # 显示拥有此文件的包名&#xA;        选项-R&#xA;            -s                      # 递归&#xA;            -c                      # 级联依赖此包的包&#xA;            -n                      # 不记录备份信息&#xA;        选项-S&#xA;            -s                      # 搜索&#xA;            -y                      # 刷新, 两个y强制升级所有包数据库&#xA;            -q                      # 静默&#xA;            -u                      # 系统升级&#xA;            -c                      # 清理, 一个c清理未安装包, 两个c清理所有cache&#xA;        选项-D&#xA;        选项-F&#xA;        目标&#xA;&#xA;    常用&#xA;        -Qeq | pacman -S -                  # 重新安装所有包&#xA;        -S $(pacman -Qnq)                   # 重新安装所有包&#xA;        -Ss ^ibus-*                         # 通配search&#xA;        -S $(pacman -Ssq fcitx*)            # 通配安装&#xA;        -R $(pacman -Qsq fcitx)             # 通配删除&#xA;        -Rcns plasma                        # 删除plasma&#xA;        -Rns                                # 删依赖并删配置&#xA;        -Scc                                # 清除缓存&#xA;        -Qii zsh                            # 包信息&#xA;        -Ql zsh                             # 查看安装的文件&#xA;        -Qo /bin/zsh                        # 查看文件属于的包&#xA;        -Qdt                                # 查孤儿包 &#xA;&#xA;    源&#xA;        mirrors.163.com&#xA;apt&#xA;    源&#xA;        阿里云mirror: https://developer.aliyun.com/mirror&#xA;        ubuntu&#xA;            sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list &#xA;downgrade                               # 用于给pacman安装过后软件降级&#xA;yum&#xA;    list                                # 列出所有包&#xA;        updates                         # 列可更新的包&#xA;        installed                       # 列已安装&#xA;        extras                          # 已安装但不在yum repository的包&#xA;    search&#xA;    install&#xA;    remove&#xA;    info                                # 包详情&#xA;        updates&#xA;        installed&#xA;        extras&#xA;    provides                            # 包文件&#xA;    whatprovides &#39;bin/isstat&#39;           # 查看命令属性哪个包&#xA;    history&#xA;        list&#xA;        redo 序号                        # 重新做序号&#xA;        undo 序号                        # 恢复历史中执行的动作&#xA;    groups list                         # 查看安装的组&#xA;&#xA;&#xA;    设置代理&#xA;        /etc/yum.conf&#xA;        proxy=http://XXX.XXX.XXX.XXX：XXXX&#xA;        或&#xA;        proxy=FTP://XXX.XXX.XXX.XXX:XXXX&#xA;        proxy_username=你的用户名&#xA;        proxy_password=你的用户名的密码&#xA;    编译用包&#xA;        build-essential                     # yum中基本编译依赖包&#xA;        yum install make cmake apr* autoconf automake curl-devel gcc gcc-c++ zlib-devel openssl openssl-devel pcre-devel gd  kernel keyutils  patch  perl kernel-headers compat* mpfr cpp glibc libgomp libstdc++-devel ppl cloog-ppl keyutils-libs-devel libcom_err-devel libsepol-devel libselinux-devel krb5-devel zlib-devel libXpm* freetype libjpeg* libpng* php-common php-gd ncurses* libtool* libxml2 libxml2-devel patch freetype-devel ncurses-devel libmcrypt libtool flex pkgconfig libevent glib libgnomeui-devel&#xA;dpkg                        # 管理deb包程序&#xA;    -i                      # 安装&#xA;    -r                      # 删除&#xA;pkgfile                     # 查看命令所需的包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;编译&#34;&gt;&#xA;  编译&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%af%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;:() { :|:&amp;amp; };:              # fork bombmake&#xA;make&#xA;    注意&#xA;        缩进只能用tab&#xA;    命令&#xA;        make&#xA;        make install&#xA;        make glide&#xA;    条目里执行shell&#xA;        @echo $(shell $(SHELL_PATH))&#xA;&#xA;    o-&amp;gt;&#xA;    TESTS = test/*.js&#xA;    REPORTER = spec&#xA;    TIMEOUT = 10000&#xA;    MOCHA_OPTS =&#xA;&#xA;    test:&#xA;        @NODE_ENV=test ./node_modules/mocha/bin/mocha \&#xA;            --reporter $(REPORTER) \&#xA;            --timeout $(TIMEOUT) \&#xA;            $(MOCHA_OPTS)&#xA;            $(TESTS)&#xA;&#xA;    test-cov&#xA;        @$(MAKE) test MOCHA_OPTS=&#39;--require blanket&#39; REPORTER=html-cov &amp;gt; coverage.html&#xA;&#xA;    test-all: test test-cov&#xA;&#xA;    .PHONY: test&#xA;&#xA;    o-&amp;gt;&#xA;    TESTS = $(shell ls -S `find test -type f -name &amp;quot;*.js&amp;quot; -print`)&#xA;    TESTTIMEOUT = 5000&#xA;    MOCHA_OPTS =&#xA;    REPORTER = spec&#xA;&#xA;    install:&#xA;        @$PYTHON=`which python2.6` NODE_ENV=test npm install&#xA;&#xA;    test:&#xA;        @NODE_ENV=test ./node_modules/mocha/bin/mocha \&#xA;            --reporter $(REPORTER) \&#xA;            --timeout $(TIMEOUT) \&#xA;            $(MOCHA_OPTS) \&#xA;            $(TESTS)&#xA;&#xA;    test-cov:&#xA;        @$(MAKE) test REPORTER=dot&#xA;        @$(MAKE) test MOCHA_OPTS=&#39;--require blanket&#39; REPORTER=html-cov &amp;gt; coverage.html&#xA;        @$(MAKE) test MOCHA_OPTS=&#39;--require blanket&#39; REPORTER=travis-cov&#xA;&#xA;    reinstall: clean&#xA;        @$(MAKE) install&#xA;&#xA;    clean:&#xA;        @rm -rf ./node_modules&#xA;&#xA;    build:&#xA;        @./bin/combo views .&#xA;&#xA;    .PHONY: test test-cov clean install reinstall&#xA;cmake&#xA;makepkg                 # 创建软件包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;调试&#34;&gt;&#xA;  调试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b0%83%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;perf                    # 性能调优&#xA;strace                  # 跟踪系统调用&#xA;itrace                  # linux系统编程中跟踪进程的库函数调用&#xA;    -S ./hello          # 跟踪所有系统调用&#xA;dtrace                  # 应用程序动态跟踪&#xA;bpftrace                # btrace2.0&#xA;gdb&#xA;SystemTap               # 内核动态探针&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;图形程序&#34;&gt;&#xA;  图形程序&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be%e5%bd%a2%e7%a8%8b%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;桌面&#34;&gt;&#xA;  桌面&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%8c%e9%9d%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;kde&#xA;xfce&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;gnome&#34;&gt;&#xA;  gnome&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gnome&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;启动&#xA;    .xinitrc&#xA;        exec gnome-session&#xA;    startx&#xA;gnome3应用程序列表&#xA;    /usr/share/applications&#xA;取消ctrl+alt+down/up&#xA;    gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-down &amp;quot;[&#39;&#39;]&amp;quot;&#xA;    gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-up &amp;quot;[&#39;&#39;]&amp;quot;&#xA;gnome-shell&#xA;    alt + f2后输入lg&#xA;gnome terminate&#xA;    ctrl + shift + c/v                  # 复制/粘贴&#xA;    ctrl + shift + t/n                  # 打开新标签/新窗口&#xA;    ctrl + w 或 alt + backspace          # 删除最后的word&#xA;    ctrl + shift + w/q                  # 关闭当前term/所有term&#xA;    ctrl + shift + f/g/h                # 搜索/搜索下一个/搜索上一个&#xA;    ctrl + pageUp/pageDown              # 切换标签&#xA;    ctrl + shift + pageUp/pageDown      # 移动标签&#xA;    alt + 1/2/3/..../0                  # 切换到第1/2/3/....../10个标签&#xA;系统快捷键&#xA;    右键快捷键&#xA;        shift + f10&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;i3&#34;&gt;&#xA;  i3&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#i3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;启动&#xA;    .xinitrc&#xA;        exec i3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;awesome&#34;&gt;&#xA;  awesome&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#awesome&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;启动&#xA;    .xinitrc&#xA;        exec /usr/bin/awesome &amp;gt;&amp;gt; ~/.cache/awesome/stdout 2&amp;gt;&amp;gt; ~/.cache/awesome/stderr&#xA;命令&#xA;    awesome&#xA;    awesome-client&#xA;配置&#xA;    配置模板&#xA;        /etc/xdg/awesome/rc.lua&#xA;    .config/awesome/rc.lua&#xA;        Variable definitions            # 可定义布局优先级&#xA;        Menu                            # 右键菜单&#xA;        Wibar                           # 生成screen, 设壁纸&#xA;        Mounse bindings                 # 鼠标键绑定函数&#xA;        Key bindings                    # 快捷键&#xA;        Rules                           # client规则, 如在哪个screen显示&#xA;        Signals                         # client启动信号触发动作&#xA;        自定义&#xA;    API&#xA;        文档地址&#xA;            https://awesomewm.org/apidoc/&#xA;        快捷键简写&#xA;            modkey                      # win键&#xA;            Mod1                        # alt&#xA;        gears                           # 工具组件&#xA;        wibox                           # wibar&#xA;            widget&#xA;            layout&#xA;        beautiful                       # theme&#xA;            init(gears.filesystem.get_configuration_dir() .. &amp;quot;/themes/default/theme.lua&amp;quot;)&#xA;                # 主题&#xA;            useless_gap = 5             # 窗口间隔&#xA;            theme.lua文件&#xA;                theme.wallpaper = &amp;quot;~/.config/awesome/themes/awesome-wallpaper.png&amp;quot;&#xA;                    # 背景&#xA;&#xA;        naughty&#xA;            notify({ preset = naughty.config.presets.critical, title = &amp;quot;Oops, there were errors during startup!&amp;quot;, text = awesome.startup_errors })&#xA;        menubar&#xA;            menu_gen&#xA;        hotkeys_popup&#xA;        awful&#xA;            layout&#xA;            tag({ &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;9&amp;quot; }, s, awful.layout.layouts[1])&#xA;            key({ modkey }, &amp;quot;F12&amp;quot;, function () awful.spawn{ &amp;quot;xlock&amp;quot; } end)&#xA;                # 快捷键&#xA;                awful.key({ &amp;quot;Mod1&amp;quot; }, &amp;quot;Escape&amp;quot;, function () awful.menu.menu_keys.down = { &amp;quot;Down&amp;quot;, &amp;quot;Alt_L&amp;quot; } awful.menu.clients({theme = { width = 250 }}, { keygrabber=true, coords={x=525, y=330} }) end),&#xA;            widget&#xA;            rules&#xA;            spawn(&amp;quot;firefox&amp;quot;, { tag = mouse.screen.selected_tag })&#xA;            util.spawn_with_shell(&amp;quot;~/.config/awesome/autorun.sh&amp;quot;)&#xA;                # 随桌面启动脚本&#xA;    autorun.sh&#xA;        #!/usr/bin/env bash&#xA;&#xA;        # nothing to use&#xA;        function run {&#xA;            if ! pgrep $1 ; then&#xA;                $@&amp;amp;&#xA;            fi&#xA;        }&#xA;&#xA;        if randr | grep -q &#39;eDP1 connected&#39; ; then&#xA;            run xrandr --output VIRTUAL1 --off --output eDP1 --mode 1920x1080 --pos 0x720 --rotate normal --output DP1 --off --output DP2-1 --mode 2560x1080 --pos 3360x720 --rotate normal --output DP2-2 --off --output DP2-3 --off --output HDMI2 --off --output HDMI1 --primary --mode 2560x1440 --pos 1920x0 --rotate left --output DP2 --off&#xA;        fi&#xA;&#xA;        run ibus-daemon -d -x&#xA;        run nm-applet&#xA;插件&#xA;    revelation          # 全局client&#xA;    shifty              # 动态tag&#xA;    naughty             # 通知&#xA;    vicious             # widgets&#xA;    obvious             # widgets&#xA;    bashets             # widgets&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;小程序&#34;&gt;&#xA;  小程序&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%8f%e7%a8%8b%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;cmatrix                 # 终端黑客帝国&#xA;screenfetch&#xA;import                  # 截图&#xA;    import a.png        # 选取区域&#xA;    -pause 3 -frame a.png                       # 截窗口, 延迟3秒(为了选定)&#xA;xgamma -gamma .75       # 调整屏幕色值&#xA;display                 # 显示图片&#xA;    display *.png       # 幻灯片&#xA;    -delay 5            # 5百分之秒切换&#xA;&#xA;    快捷键&#xA;        空格            # 下一张&#xA;        退格            # 上一张&#xA;        h               # 水平翻转&#xA;        v               # 垂直翻转&#xA;        /               # 顺时针翻转90度&#xA;        \               # 逆时针旋转90度&#xA;        &amp;gt;               # 放大&#xA;        &amp;lt;               # 缩小&#xA;        f7              # 模糊&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;任务栏&#34;&gt;&#xA;  任务栏&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%bb%e5%8a%a1%e6%a0%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;nm-applet&#xA;    # 联网&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;输入法&#34;&gt;&#xA;  输入法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%93%e5%85%a5%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;fcitx&#xA;ibus&#xA;ibus-daemon -d -x -r        # ibus后台运行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模拟&#34;&gt;&#xA;  模拟&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e6%8b%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;wine&#xA;winetricks                  # 安装wine的各种依赖&#xA;cabextract                  # microsoft cabinet获取工具&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;资源管理&#34;&gt;&#xA;  资源管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;nautilus&#xA;    快捷键&#xA;        &amp;lt;Ctrl+L&amp;gt;            # 路径编辑&#xA;        &amp;lt;Ctrl+W&amp;gt;            # 关闭tab&#xA;        &amp;lt;Ctrl+Shift+W&amp;gt;      # 关闭所有tab&#xA;        &amp;lt;Ctrl+T&amp;gt;            # 新建tab&#xA;        &amp;lt;F9&amp;gt;                # 侧边栏&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://runout.run/docs/tool/ops/monitor/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://runout.run/docs/tool/ops/monitor/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;监控的方式&#xA;    主动、被动、旁路（舆情）&#xA;监控类型&#xA;    服务端监控、客户端监控&#xA;目标&#xA;    全、块、准&#xA;指标&#xA;    请求量、成功率、耗时    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;统计&#34;&gt;&#xA;  统计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%9f%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;指标&#xA;    访问、访客&#xA;    停留时长&#xA;    跳出率&#xA;    退出率&#xA;    转化率&#xA;    参与度&#xA;显示方式&#xA;    选时间段&#xA;        时序数据表&#xA;        max、min、avg&#xA;埋点&#xA;    通过可视化工具配置，非硬编码&#xA;第三方&#xA;    友盟&#xA;    百度移动&#xA;    魔方&#xA;    App Annie&#xA;    talking data&#xA;    神策数据&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;物理机&#34;&gt;&#xA;  物理机&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%a9%e7%90%86%e6%9c%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;load-average&#34;&gt;&#xA;  Load Average&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#load-average&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    数字n表示n倍&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  cpu&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Usage: 100%&#xA;    system&#xA;    user&#xA;    IO wait&#xA;Saturation: 1.0core&#xA;Max Core Usage: 1.0core&#xA;Interrupts and Context Switches: 10k&#xA;Processes: 10ops&#xA;    create(Forks)&#xA;    Runnable&#xA;    Blocked&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;mem&#34;&gt;&#xA;  mem&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mem&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Physical Memory: RAM(Random-Access Memory)存储器&#xA;    used&#xA;    free&#xA;    buffers&#xA;Virtual Memory&#xA;    介绍&#xA;        映射到RAM或Disk&#xA;    used&#xA;    available&#xA;Swap Space&#xA;    used&#xA;    free&#xA;Swap Activity&#xA;    swap in(read)&#xA;    swap out(write)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;disk&#34;&gt;&#xA;  disk&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#disk&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;space&#xA;    增长趋势&#xA;I/O Activity&#xA;    read(page in)&#xA;    write(page out)&#xA;File Descriptors: 1Milion&#xA;    limit&#xA;    allocated&#xA;I/O Latency: 5ms&#xA;    write&#xA;    read&#xA;I/O Load: 3&#xA;    write&#xA;    read&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;network&#34;&gt;&#xA;  network&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#network&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;traffic: MB/s&#xA;    inbound&#xA;    outbound&#xA;Utillization Hourly: GB&#xA;    sent&#xA;    received&#xA;Local Network Errors: 0ops&#xA;    transmit drop&#xA;    receive drop&#xA;    transmit errors&#xA;TCP Retransmission&#xA;    segments retransmitted: 0ops&#xA;    retransmit ratio: 0%&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;应用监控&#34;&gt;&#xA;  应用监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Prometheus&#xA;    # 监控, go实现&#xA;Grafana&#xA;    # 监控&#xA;Zabbix&#xA;    # 分布式监控&#xA;Nagios&#xA;    # 监控&#xA;Ganglia&#xA;Zenoss&#xA;Open-falcon&#xA;emq&#xA;    # mqtt broker, erlang开发, 管理控制台&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;apm&#34;&gt;&#xA;  APM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#apm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Application Performance Management&#xA;SkyWalking&#xA;CAT&#xA;Jaeger&#xA;Pinpoint&#xA;Zipkin&#xA;Dapper&#xA;    # C#&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;mysql&#34;&gt;&#xA;  Mysql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;总览&#xA;    Services: 38&#xA;    Min MySQL Uptime: 20 hours&#xA;    Max MySQL Uptime: 2.4 years&#xA;    Total Current QPS: 3.4k ops&#xA;    Total InnoDB Buffer Pool Size: 431GiB&#xA;    Top Service Used Connections: 800&#xA;    Top Service Used Connections: 80%&#xA;    Top Service Client Threads Connected: 60%&#xA;    Top Service Active Client Threads: 99%&#xA;    Top Service Threads Cached: 100%&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;单节点&#34;&gt;&#xA;  单节点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e8%8a%82%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;总计 &#xA;    Uptime: 29 weeks&#xA;    Version: 5.7.26&#xA;    Current QPS: 32&#xA;    InnoDB Buffer Pool Size: 3GiB&#xA;    Buffer Pool Size of Total RAM: 10%&#xA;Connections&#xA;    Connections&#xA;        Max Connections&#xA;        Max Used Connections&#xA;        Connections&#xA;    Aborted Connections&#xA;        Aborted Connects(attempts): 0 ops&#xA;        Aborted Clients(timeout): 0 ops&#xA;Client Threads&#xA;    Clients Threads Activity&#xA;        Peak Threads Connected: 22&#xA;        Peak Threads Running: 2&#xA;    Thread Cache&#xA;        Thread Cache Size&#xA;        Threads Cached&#xA;        Threads Created&#xA;Temporary Objects &amp;amp; Slow Queries&#xA;    Temporary Objects&#xA;        Created Tmp Tables: 5&#xA;        Created Tmp Disk Tables: 0.3&#xA;        Created Tmp Files: 0&#xA;    Slow Queries: 0 ops&#xA;Select Types &amp;amp; Sorts&#xA;    Select Types&#xA;        Select Scan: 14 ops&#xA;        Select Range: 4 ops&#xA;    Sorts&#xA;        Sort Rows: 1 ops&#xA;        Sort Scan: 0 ops&#xA;        Sort Range: 0 ops&#xA;Table Locks &amp;amp; Questions&#xA;    Table Locks Immediate: 0.6 ops&#xA;    Table Locks Waited: 0 ops&#xA;Questions: 32&#xA;Network&#xA;    Network Traffic&#xA;        Outbound: 70 KBs&#xA;        Inbound: 15 KBs&#xA;    Newtwork Usage Hourly&#xA;        Sent: 240 MiB&#xA;        Received: 52 MiB&#xA;Memory&#xA;    System Memory: 31 GiB&#xA;    InnoDB Buffer Pool Data: 2 GiB&#xA;    InnoDB Log Buffer Size: 32 MiB&#xA;    Key Buffer Size: 8 MiB&#xA;    Query Cache Size: 1 MiB&#xA;Command, Handlers, Processes&#xA;    Top Command Counters&#xA;        select: 25&#xA;        set option: 4&#xA;        rollback: 0.6&#xA;        commit: 28&#xA;        stmt_prepare: 28&#xA;        stmt_execute: 28&#xA;        stmt_close: 28&#xA;        begin: 28&#xA;        show variables: 0.2&#xA;        alter_table: 0&#xA;        delete: 0.2&#xA;        insert: 3&#xA;        replace: 0&#xA;        update: 40&#xA;    Top Command Counters Hourly: 100k&#xA;    Handlers&#xA;        read_md_next: 800ops&#xA;        write: 150ops&#xA;        read_key: 100ops&#xA;        read_next: 100ops&#xA;        external_lock: 60ops&#xA;        read_first: 13ops&#xA;        update: 2ops&#xA;        delete: 1ops&#xA;        read_prev: 0ops&#xA;        read_md: 0ops&#xA;    Transaction Handlers&#xA;        commit: 25ops&#xA;        rollback: 0.6&#xA;    Process States&#xA;        idle: 20&#xA;        other: 1&#xA;        executing: 1&#xA;        sending data: 1&#xA;        statistics: 0&#xA;        preparing: 0&#xA;        init: 0&#xA;Query Cache&#xA;    Query Cache Memory&#xA;        query cache size: 1 MiB&#xA;        free memory: 1 MiB&#xA;    Query Cache Activity&#xA;        not cached: 25&#xA;        queries in cache: 0&#xA;        prunes: 0&#xA;Files and Tables&#xA;    File Openings: 0.2&#xA;    Open Files: 65k&#xA;Table Openings&#xA;    Open Cache Status&#xA;        Hits: 40ops&#xA;        Misses due to Overflows: 17&#xA;        Misses: 16&#xA;    Open Tables&#xA;        Table Open Cache: 2k&#xA;        Open Tables: 2k&#xA;Table Definition Cache&#xA;    Table Definition Cache Size: 1k&#xA;    Open Table Definitions: 700&#xA;    Opened Table Definitions: 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;node-summary&#34;&gt;&#xA;  Node Summary&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#node-summary&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;总计&#xA;    Node Name&#xA;    Uptime: 1.4 years&#xA;    Load Average: 0.6&#xA;    RAM: 32GiB&#xA;    Memory Available: 63%&#xA;    Virtual Memory: 48GiB&#xA;    Disk Space: 2.3TiB&#xA;    Min Space Available: 26%&#xA;CPU Usage&#xA;    iowait: 28%&#xA;    user: 10%&#xA;    system: 2%&#xA;CPU Saturation and Max Core Usage&#xA;    Normalized CPU Load: 0.8&#xA;    Max Cpu Core Utilization: 30%&#xA;Disk I/O and Swap Activity&#xA;    Disk Writes(page out): 30 MBs&#xA;    Disk Reads(page in): 30 MBs&#xA;    Swap Out(writes): 0&#xA;Network Traffic&#xA;    Outbound: 3MBs&#xA;    Inbound: 330 kBs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;innodb&#34;&gt;&#xA;  InnoDB&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;总计&#xA;    Buffer Pool Size: 16GiB&#xA;    Buffer Pool Size of Total RAM: 52%&#xA;    Total Redo Log Space: 900 MiB&#xA;    Max Log Space Used&#xA;    Max Transaction History Length: 300k&#xA;    Data Bandwidth: 23MBs&#xA;    Fsync Rate: 40ops&#xA;    Row Lock Blocking: 0.02%&#xA;Activity&#xA;    Row Reads: 20k&#xA;    Row Writes: 100&#xA;    Read-Only Transactions: 0&#xA;    Read-Write Transactions: 0&#xA;    Transactions Information(RW): 0&#xA;    Misc Transactions Information: 0&#xA;Storage Summary&#xA;    Tables: 1014&#xA;    Data Buffer Pool Fit: 2%&#xA;    Avg Row Size: 900B&#xA;    Index Size Per Row: 700B&#xA;    Space Allocated: 900GiB&#xA;    Space Used: 900 GiB&#xA;    Data Length: 500 GiB&#xA;    Index Length: 400 GiB&#xA;    Estimated Rows: 600 Mil&#xA;    Indexing Overhead: 80%&#xA;    Free Space Percent: 0.4%&#xA;    Free: 4GiB&#xA;Disk IO&#xA;    总计&#xA;        InnoDB Page Size: 16 KiB&#xA;        Avg Data Read Rq Size: 16 KiB&#xA;        Avg Data Write Rq Size: 20KiB&#xA;        Avg Log Write Rq Size: 4 KiB&#xA;        Data Written Per Fsync: 70 KiB&#xA;        Log Written Per Fsync: 20 KiB&#xA;        Data Read Per Row Read: 27B&#xA;        Data Written Per Row Written: 66 KiB&#xA;        Auto Extend Increment: 64MiB&#xA;        Double Write: ON&#xA;        Fast Shutdown: OFF&#xA;        Open Files: 2k&#xA;        File Use: 100%&#xA;    InnoDB Data I/O&#xA;        Data Reads: 37 ops&#xA;        Data Writes: 25 ops&#xA;    InnoDB Data Bandwidth&#xA;        Data Read: 10 MBs&#xA;        Data Written: 10 MBs&#xA;    InnoDB Log IO&#xA;        Log Written: 40 kBs&#xA;        Log Writes: 4 ops&#xA;    InnoDB FSyncs&#xA;        Data Fsyncs: 7 ops&#xA;        Log Fsyncs: 2 ops&#xA;    InnoDB Pending IO&#xA;        Pending Data Reads: 0&#xA;        Pending Data Writes: 0&#xA;        Pending Log Writes: 0&#xA;    InnoDB Pending Fsyncs: 0&#xA;IO Objects&#xA;    Targets Bandwidth&#xA;    Targets Load&#xA;    Targets Read&#xA;    Targets Read Load&#xA;    Targets Write&#xA;    Targets Write Load&#xA;    Targets Read Latency&#xA;    IO Targtes Write Latency&#xA;    Reads by Page Type&#xA;    Writes by Page Type&#xA;Buffer Pool&#xA;    总计&#xA;        Buffer Pool Size: 2GiB&#xA;        Buffer Pool Size of Total RAM&#xA;        NUMA Interleave&#xA;        Buffer Pool Activity: 215 ops&#xA;        BP Data&#xA;        BP Data Dirty&#xA;        BP Miss Ratio: 0.32%&#xA;        BP Write Buffering: 4&#xA;        Pool Chunk Size: 128 MiB&#xA;        Buffer Pool Instances: 8&#xA;    Buffer Pool Pages&#xA;        data: 120k&#xA;        free: 8k&#xA;        misc: 2k&#xA;    Buffer Pool Data&#xA;        data total: 2GiB&#xA;        Estimated Dirty Data Limit: 1GiB&#xA;        Data Dirty: 5MiB&#xA;    Buffer Pool Page Activity: &#xA;        Pages Read: 40 ops&#xA;        Pages Written: 20 ops&#xA;        Pages Created: 3 ops&#xA;    Buffer Pool Requests&#xA;        read requests: 10k ops&#xA;        wite requests: 200 ops&#xA;    Read-Ahead&#xA;        Pages Fetched by Linear Read Ahead: 3ops&#xA;        Paged Fetched by Read Ahead but Never Accessed: 0.01 ops&#xA;        Paged Fetched by Random Read Ahead: 0ops&#xA;    Buffer Pool LRU Sub-Chain Churn&#xA;Buffer Pool - Replacement Management&#xA;Checkpointing and Flushing&#xA;Logging&#xA;Locking&#xA;Undo Space and Purging&#xA;Page Operations&#xA;Adaptive Hash Index&#xA;Change Buffer&#xA;Contention&#xA;Misc&#xA;Online Operations(MariaDB)&#xA;    Defragmentation&#xA;    Online DDL&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;overview&#34;&gt;&#xA;  Overview&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#overview&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;I/O Thread Running&#xA;SQL Thread Running&#xA;Read Only&#xA;Connections&#xA;    Service Used Connections: 750&#xA;    Service Aborted Connections: 15&#xA;Threads&#xA;    Service Client Threads Connected: 500&#xA;    Service Active Client Threads: 25&#xA;    Service Thread Cached: 55&#xA;Queries &amp;amp; Questions&#xA;    总计&#xA;        Top Service Queries: 9.3k ops&#xA;        Top Service Questions: 3k ops&#xA;        Top InnoDB I/O Data Reads: 99.9%&#xA;        Top InnoDB I/O Data Writes: 100%&#xA;        Top Data Fsyncs: 50%&#xA;    Top Service Queries: 2.5k&#xA;    Top Service Questions: 0.5k&#xA;InnoDB I/O&#xA;    Top Service Data Reads: 2k rps&#xA;    Top Service Data Writes: 1.5k wps&#xA;    Top Service Data Fsyncs: 100 ops&#xA;Temporary Objects&#xA;    Service Temporary Objects: 150&#xA;    Top Service Selects&#xA;Sorts&#xA;    Top Service Sorts: 50k&#xA;Locks&#xA;    Top Service Table Locks: 3 ops&#xA;Network&#xA;    总计&#xA;        Top Service Incoming Network Traffic: 10 MBs&#xA;        Top Service Outgoing Network Traffic: 30 MBs&#xA;    Service Incoming Network Traffic: 2 MBs&#xA;    Service Outgoing Network Traffic: 5 MBs&#xA;Query Cache&#xA;    总计 &#xA;        Top Service Used Query Cache: 99%&#xA;    Service Query Cache Size: 100 MiB&#xA;Files&#xA;    总计&#xA;        Top Percentage of File Openings to Opened Files: 100%&#xA;        Top Percentage of Opened Files to the Limit: 0.25%&#xA;    Service File Openings: 250&#xA;    Service Opened Files: 160&#xA;Table Openings&#xA;    总计&#xA;        Top Open Cache Miss Ratio: 85%&#xA;    Lowest Service Open Cache Hit Ratio: 60%&#xA;Open and Cached Table Definitions&#xA;    总计 &#xA;        Min Service Opened Table Definitions: 0&#xA;        Top Service Opened Table Definitions: 230 ops&#xA;        Top Service Open Table Definitions 1.5k ops&#xA;        Top Open Table Definitions to Definition Cache: 100%&#xA;    Service Table Definition Cache: 1.5 KiB&#xA;    Service Opened Table Definitions: 210 ops&#xA;    Service Open Table Definitions: 1.4k&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;主从复制&#34;&gt;&#xA;  主从复制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Replication Delay:  10&#xA;Binlogs Size:  10GiB&#xA;Binlog Data Written Hourly&#xA;Binlogs Count: 30&#xA;Binlog Cache Use Hourly: 300k&#xA;Relay Log Space: 300MiB&#xA;Relay Log Written Hourly&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;oracle&#34;&gt;&#xA;  Oracle&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#oracle&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;状态: alive&#xA;活动会话(user)&#xA;进程计数&#xA;执行计数、提交计数、回滚计数&#xA;等待时间&#xA;    并发等待: 200ms&#xA;    提交等待: 50ms&#xA;    应用等待: 50ms&#xA;    网络等待: 10ms&#xA;    系统I/O等待: 100ms&#xA;    用户I/O等待: 1s&#xA;    组态等待: 2ms&#xA;    scheduler等待: 500ms&#xA;表空间&#xA;    表空间类型：持久、临时、重做&#xA;    使用率&#xA;    剩余空间: 100GB&#xA;资源利用率&#xA;    branches&#xA;    cmtcallbk&#xA;    dml_locks&#xA;    enqueue_locks&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;postgresql&#34;&gt;&#xA;  PostgreSQL&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#postgresql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;总览&#xA;    services个数&#xA;    Active Connections&#xA;    Total Disk-Page Buffers: 32MiB&#xA;    Total Memory Size for Each Sort: 16MiB&#xA;    Total Shared Buffers: 128GiB&#xA;    Services Autovacuum: 100%&#xA;Connections&#xA;    Top5 Service Connections: 600&#xA;    Top5 Service Active Connections: 5&#xA;    Service Idle Connections&#xA;    Service Active Connections&#xA;Autovacuum&#xA;    Service Value: Yes&#xA;Tuples&#xA;    总计&#xA;        Total: 170M ops&#xA;        Max Fetched: 6M ops&#xA;        Max Returned: 6M ops&#xA;        Max Inserted: 485 ops&#xA;        Max Updated: 560 ops&#xA;        Max Deleted: 371 ops&#xA;    Service Fetched Tuples Rate: 2M ops&#xA;    Service Returned Tuples Rate: 2M ops&#xA;    Service Inserted Tuples Rate: 100 ops&#xA;    Service Updated Tuples Rate: 100 ops&#xA;    Service Deleted Tuples Rate: 50 ops&#xA;Transactions&#xA;    总计&#xA;        Total: 7.5k ops&#xA;        Max Commits: 270 ops&#xA;        Max Rollback: 0.2 ops&#xA;        Max Duration: 55 s&#xA;    Service Commits: 100 ops&#xA;    Service Rollbacks: 0.05 ops&#xA;    Service Duration of Active Transactions: 850 ms&#xA;    Service Duration of Other Transactions: 760 ms&#xA;Temp Files&#xA;    总计&#xA;        Max Number of Temp Files: 17k&#xA;        Max Size of Temp Files: 178GiB&#xA;    Service Numbers: 17k&#xA;    Service Size: 178GiB&#xA;Conflicts &amp;amp; Locks&#xA;    总计&#xA;        Total Locks: 6.5k&#xA;        Total Deadlocks: 0&#xA;        Total Conflicts: 0&#xA;    Service Locks: 100&#xA;    Service Deadlocks: 0&#xA;    Service Conflicts: 0&#xA;Cache Hit&#xA;    总计&#xA;        Min Cache Hit Ratio: 97%&#xA;        Max Cache Hit Ratio: 100%&#xA;    Service Lowest Cache Hit Ratio: 100%&#xA;Canceled Queries&#xA;    Service Canceled Queries: 0&#xA;Blocks Operations&#xA;    总计&#xA;        Total Blocks Operations: 0 ops&#xA;        Max Blocks Writes: 0 ops&#xA;        Max Blocks Reads: 0 ops&#xA;    Servcie Blocks Reads: 0 ops&#xA;    Service Blocks Writes: 0 ops &#xA;Buffers Operations&#xA;    总计&#xA;        Max Allocaetd Bufferes: 38&#xA;    Service Allocated Buffers: 10 ops&#xA;    Service Fsync Calls by a Backend: 0 ops&#xA;    Service Written Directly by a Backend: 5 wps&#xA;    Service Written by the Background Writer: 0 wps&#xA;    Service Written During Checkpoints: 50 wps&#xA;Checkpoint Stats&#xA;    总计&#xA;        Total Written Files to Disk: 140k&#xA;        Total Files Synchronization to Disk: 27&#xA;    Service Files Synchronization to Disk: 0.1 ops&#xA;    Service Written Files to Disk: 400 wps&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Security</title>
      <link>https://runout.run/docs/architect/code/security/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://runout.run/docs/architect/code/security/</guid>
      <description>&lt;h1 id=&#34;服务器&#34;&gt;&#xA;  服务器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;木马&#34;&gt;&#xA;  木马&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%a8%e9%a9%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;自变异木马&#xA;    改变自身hash或将自身大量复制到不同目录, 后台运行，躲避清理&#xA;    自删除&#xA;    伪装成系统程序或绑定系统程序&#xA;检查&#xA;    可疑进程&#xA;    定时任务&#xA;    启动项&#xA;        /etc/init.d或service --status-all&#xA;        systemctl list-unit-files | grep enabled&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;经验&#34;&gt;&#xA;  经验&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%8f%e9%aa%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;libudev.so                      # 自变异，/bin/下生成随机名称命令, 启动后可远程执行命令，在/etc/init.d下创建自启动项，在/etc/crontab中添加定时任务&#xA;    chmod 0000 /lib/libudev.so &amp;amp;&amp;amp; rm -rf /lib/libudev.so &amp;amp;&amp;amp; chattr +i /lib/&#xA;    /etc/init.d下随机名称文件删除, /etc/rc{0,1,2,3,4,5,6,S}.d中的软链删除&#xA;    /etc/crontab/gcc.sh删除&#xA;    sed &#39;/gcc.sh/d&#39; /etc/crontab &amp;amp;&amp;amp; chmod 0000 /etc/crontab &amp;amp;&amp;amp; chattr +i /etc/crontab 删除定时任务&#xA;    重启&#xA;    chattr -i /lib /etc/crontab 恢复可写&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ddos&#34;&gt;&#xA;  DDoS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ddos&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;防范方法&#34;&gt;&#xA;  防范方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e8%8c%83%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;漏洞扫描&#34;&gt;&#xA;  漏洞扫描&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%bc%8f%e6%b4%9e%e6%89%ab%e6%8f%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;DVWA&#xA;    # Damn Vulnerable Web Application，PHP + MySQL模拟Web漏洞&#xA;W3af&#xA;    # Web应用扫描, Python实现&#xA;OpenVAS&#xA;    # 扫描主机漏洞&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;网络隔离&#34;&gt;&#xA;  网络隔离&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c%e9%9a%94%e7%a6%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;内外网分离&#xA;登录跳板机&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;web安全&#34;&gt;&#xA;  Web安全&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;xss&#34;&gt;&#xA;  XSS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xss&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 向网页注入代码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;csrf&#34;&gt;&#xA;  CSRF&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#csrf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Cross-Site Request Forgery, 跨站请求伪造&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sql注入&#34;&gt;&#xA;  SQL注入&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sql%e6%b3%a8%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;hash-dos&#34;&gt;&#xA;  Hash Dos&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hash-dos&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;上传大Json Object, 利用Hash算法的伪随机性，制造Value不同但Hash碰撞的数据，耗尽CPU&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;上传文件脚本&#34;&gt;&#xA;  上传文件脚本&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6%e8%84%9a%e6%9c%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;伪造Content-Type上传静态资源，再URL访问执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;防范方法-1&#34;&gt;&#xA;  防范方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e8%8c%83%e6%96%b9%e6%b3%95-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;验证码&#34;&gt;&#xA;  验证码&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%aa%8c%e8%af%81%e7%a0%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;根据滑动响应时间、拖拽速度、时间、位置、轨迹、重试次数来评估风险&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;信息存储&#34;&gt;&#xA;  信息存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%a1%e6%81%af%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;密码非明文保存，加salt&#xA;身份证号、手机号加&amp;quot;*&amp;quot;&#xA;联系方式显示与否用户自己配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;加密&#34;&gt;&#xA;  加密&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a0%e5%af%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;对称加密&#xA;    DES             # 56位秘钥，已被AES取代&#xA;    3DES            # 做3次DES&#xA;    AES             # 128、192、256位秘钥&#xA;    Blowfish        # 1到448位变长秘钥&#xA;非对称加密&#xA;    RSA             #&#xA;    DSA             # 性能快于RSA，只能数字签名&#xA;    ECDSA           # 螺旋曲线加密算法&#xA;    ECC             # 256位ECC秘钥相当于3072位RSA秘钥&#xA;哈希算法&#xA;    MD5             # 不再安全&#xA;    SHA-1           # 不再安全&#xA;    SHA-256&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;授权认证&#34;&gt;&#xA;  授权、认证&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%88%e6%9d%83%e8%ae%a4%e8%af%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;RBAC、ABAC&#xA;SSO&#xA;OAuth2.0&#xA;OIDC&#xA;    # OpenId Connect，OAuth2上构建的身份认证&#xA;SAML&#xA;    # Security Assertion Markup Language&#xA;    用于SSO，XML格式&#xA;    定义了三个角色：委托人、身份提供者(IDP)、服务提供者(SP)。用户SP做访问控制&#xA;2FA&#xA;    # Two-factor authentication, 双因素认证&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;代码安全&#34;&gt;&#xA;  代码安全&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;java反序列化漏洞&#34;&gt;&#xA;  Java反序列化漏洞&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;用户输入直接反序列化，可利用Apache Commons Collections执行任意代码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据安全&#34;&gt;&#xA;  数据安全&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数据备份&#34;&gt;&#xA;  数据备份&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%a4%87%e4%bb%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;问题定义与排查方法&#34;&gt;&#xA;  问题定义与排查方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e5%ae%9a%e4%b9%89%e4%b8%8e%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;线上故障等级&#xA;&#x9;P0 致命问题&#xA;&#x9;P1 严重问题&#xA;&#x9;P2 一般问题&#xA;&#x9;P3 轻微问题&#xA;线上故障分类&#xA;&#x9;外部依赖类&#xA;&#x9;运营质量类&#xA;&#x9;需求质量类&#xA;&#x9;系统质量类&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;混沌工程&#34;&gt;&#xA;  混沌工程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%b7%e6%b2%8c%e5%b7%a5%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;混沌工程画像&#xA;&#x9;ApplicationData&#xA;&#x9;&#x9;进程Hang、Kill，启动异常，心跳异常，环境错误，包错误或损坏，配置错误、误删、获取超时&#xA;&#x9;Data&#xA;&#x9;&#x9;系统单点，异步阻塞同步，依赖超时，依赖异常，业务线程池满，监控错误，OOM&#xA;&#x9;Runtime&#xA;&#x9;&#x9;负载均衡失效，缓存热点，缓存限流&#xA;&#x9;Middleware&#xA;&#x9;&#x9;数据库热点，数据库宕机，数据同步延迟，数据库主备延迟，数据库连接满，数据库热点&#xA;&#x9;OS&#xA;&#x9;&#x9;CPU抢占，内存抢占，内存错乱，上下文切换&#xA;&#x9;Virtualization&#xA;&#x9;&#x9;服务器宕机、假死，断电，超卖，混部&#xA;&#x9;Storage&#xA;&#x9;&#x9;磁盘满、慢、坏，不可写，不可读&#xA;&#x9;Networking&#xA;&#x9;&#x9;网络抖动、丢包、超时，网卡满，断网&#xA;工具&#xA;&#x9;ChaosBlade&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;java&#34;&gt;&#xA;  Java&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Idea Debugger&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;redis&#34;&gt;&#xA;  Redis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;mysql&#34;&gt;&#xA;  MySQL&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Using intersect&#xA;&#x9;多余查询条件虽然命中索引，但会产生多余的索引查询使SQL变慢，应该使用唯一的单值索引&#xA;force index指定期望的索引&#xA;用count(*)不要count(1)&#xA;use filesort可能会文件排序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;trace&#34;&gt;&#xA;  Trace&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#trace&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Pinpoint记录&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;各开源协议&#34;&gt;&#xA;  各开源协议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%84%e5%bc%80%e6%ba%90%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;GPL&#xA;    介绍&#xA;        GNU General Public License，GNU发布的通用协议，共3个版本，最新为GPLv3，Linux使用此协议&#xA;    特点&#xA;        发布的软件使用GPL的软件, 也要GPL&#xA;LGPL&#xA;    介绍&#xA;        GNU Lesser General Public License，OpenOffice使用此协议&#xA;    特点&#xA;        类库引用可不开源，有代码修改要使用LGPL开源&#xA;AGPL&#xA;    介绍&#xA;        Affero General Public License。类似的协议有CPAL、OSL&#xA;    特点&#xA;        除发布的软件，提供服务的软件，也要AGPL&#xA;BSD&#xA;    介绍&#xA;        Berkly Software Distribution&#xA;    特点&#xA;        可以自由修改，修改可再次闭源发布。只需要BSD许可协议文件，但不能使用原作者名义宣传&#xA;MPL&#xA;    介绍&#xA;        The Mozilla Public License&#xA;    特点&#xA;        可与其它授权的文件混合使用，新增代码可使用其它方式授权或闭源&#xA;        使用MPL的部分，对MPL修改的部分，要MPL&#xA;MIT&#xA;    介绍&#xA;        近1/3的开源 软件使用。如ssh, JQuery, Putty，XWindow&#xA;    特点&#xA;        类似BSD，可使用原作者名义推广&#xA;Apache2.0&#xA;    介绍&#xA;        软件有Android, Apache Web Server, Swift&#xA;    特点&#xA;        类似BSD，被修改的原始文件要著名版权&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Eclipse</title>
      <link>https://runout.run/docs/tool/develop/eclipse/</link>
      <pubDate>Thu, 11 Oct 2018 18:33:08 +0800</pubDate>
      <guid>https://runout.run/docs/tool/develop/eclipse/</guid>
      <description>&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;user library发布&#xA;        项目右键 -&amp;gt; properties -&amp;gt; Deployment Assembly -&amp;gt; add -&amp;gt; javaBuild Path Entries中选择发布包&#xA;tomcat设置发布到外部&#xA;        new server -&amp;gt; 直接finish&#xA;        右键server -&amp;gt; open        &#xA;                修改server location -&amp;gt; use Tomcat installation&#xA;                修改server location -&amp;gt; deploy path为webapps&#xA;                修改TimeOuts -&amp;gt;所有时间为1200&#xA;java版本&#xA;        window -&amp;gt; preferences -&amp;gt; java -&amp;gt; compiler&#xA;        window -&amp;gt; preferences -&amp;gt; java -&amp;gt; installed JREs&#xA;编码&#xA;        general -&amp;gt; workspace&#xA;                Text file encoding&#xA;        general -&amp;gt; content types&#xA;                Text -&amp;gt; java source file &#xA;                        defalt encoding输入UTF-8并点击update&#xA;快捷键&#xA;        general -&amp;gt; editors -&amp;gt; keys&#xA;                content assist                # 代码提示&#xA;                word comletion                # 代码补全&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;market place&#xA;        http://www.eclipse.org/mpc/&#xA;        在线网页&#xA;                http://www.eclipse.org/mpc/archive.php&#xA;        在线安装(luna)&#xA;                http://download.eclipse.org/mpc/releases/1.3.0/&#xA;        yum&#xA;                eclipse-mpc&#xA;subclipse&#xA;        yum&#xA;                eclipse-subclipse&#xA;jdt java8 support&#xA;        help -&amp;gt; market place -&amp;gt; find: java 8&#xA;                java 8 support for eclipse &#xA;        在线安装(kepler)&#xA;                http://download.eclipse.org/eclipse/updates/4.3-P-builds/&#xA;                网站&#xA;                        http://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_For_Kepler&#xA;m2e&#xA;        在线&#xA;                http://download.eclipse.org/technology/m2e/releases &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;mvn项目&#34;&gt;&#xA;  mvn项目&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvn%e9%a1%b9%e7%9b%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;创建web 项目&#xA;        maven project &#xA;                catalog: internal&#xA;                filter:webapp&#xA;                        org.apache.maven.archetypes&#xA;        项目右键 - new -&amp;gt; source folder&#xA;                src/main/java&#xA;                src/main/resources&#xA;                src/test/java&#xA;                src/test/resources&#xA;                        # 可以在navigator中创建, 再:&#xA;                        ## 项目右键 -&amp;gt; buildpath -&amp;gt; configure... -&amp;gt; source -&amp;gt; add folder添加以上4个source folder&#xA;        修改 configure build path -&amp;gt; source 中2个source folder中的output folder&#xA;                src/main/java                target/classes&#xA;                src/main/resources        target/classes&#xA;                src/test/java                target/test-classes&#xA;                src/test/resources        target/test-classes&#xA;        修改 configure build path -&amp;gt; libraries -&amp;gt; jre system library -&amp;gt; edit&#xA;        右键 -&amp;gt; properties -&amp;gt;java compiler -&amp;gt; 1.8&#xA;        &#xA;&#xA;        项目右键 -&amp;gt; run as -&amp;gt; maven install                #下载依赖包&#xA;        右键 -&amp;gt; properties -&amp;gt; project facets -&amp;gt; convert to faceted from&#xA;                选中 dynamic web module&#xA;                选中 java&#xA;                右边选择runtime&#xA;                下面further configuration available&#xA;                        content directory: src/main/webapp&#xA;                        勾选generate web.xml&#xA;        右键 -&amp;gt; properties -&amp;gt; deployment assembly中配置文件发布路径&#xA;                去掉test的目录&#xA;                添加发布包maven dependencies&#xA;方案&#xA;    修改项目名&#xA;            o-&amp;gt; 修改project名&#xA;            o-&amp;gt; 修改包名与test包名&#xA;            o-&amp;gt; 修改配置文件, 类中的常量, (workspace配置文件[maven项目没有这些文件])                # ctrl + h 全局搜索(替换)&#xA;            o-&amp;gt; mvn clean&#xA;            o-&amp;gt; mvn install&#xA;            o-&amp;gt; preferences -&amp;gt; web project settings -&amp;gt; context root中修改项目名称&#xA;    集成spring&#xA;        pom.xml中添加spring依赖&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;myeclipse&#34;&gt;&#xA;  myEclipse&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#myeclipse&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;假错误（problem view中删掉）&#xA;&#xA;目录结构&#xA;        /Common/中存储的是jar包与配置&#xA;                plugins/存放插件&#xA;                features/存放外观&#xA;        /MyEclipse 10/中&#xA;                dropins/配置自定义插件&#xA;&#xA;调整format一行最大字符数        Java — Code Style — Formatter — Active profile — Edit — Line Wrapping — Maximum line width&#xA;修改，自定义alt + / 模板        包括@anthor 等等        Java — Editor — Templates&#xA;修改编码:window --&amp;gt; General --&amp;gt; Workspace&#xA;                Myeclipse --&amp;gt; files and editors&#xA;忽略校验:右键 --&amp;gt; myeclipse --&amp;gt; exclude from validation&#xA;package Explor 中可以go into  和 up 缩小和扩大显示范围&#xA;&#xA;鼠标右键 --&amp;gt;Run As --&amp;gt; Run Configuration --&amp;gt; Arguments --&amp;gt; Program Arguments 设置运行传入的参数 &#xA;&#xA;new 中可以生成测试文件&#xA;&#xA;window --&amp;gt; preferences --&amp;gt; MyEclipse --&amp;gt; validation --&amp;gt; disableAll 取消验证&#xA;&#xA;Package Explorer中什么也不显示（进入了已经关闭的包时） --&amp;gt; navigator --&amp;gt; open project&#xA;                                                                                        或者{workspaces}\.metadata\.plugins\org.eclipse.ui.workbench\workbench.xml文件中&#xA;                                                                                        搜索&amp;lt;input factoryID=&amp;quot;org.eclipse.ui.internal.model.ResourceFactory&amp;quot;，把path的值改为&amp;quot;/&amp;quot;&#xA;        其它原因：window --&amp;gt; reset perspective&#xA;                        Package Explorer 上的倒三角中：deselect working set&#xA;struts2配置myeclipse编写xml文件时的提示&#xA;        ## 约束文件的相对路径：struts-2.3.15.1\src\core\src\main\resources\struts2.0.dtd&#xA;        ## xml文件中声明的url：http://struts.apache.org/dtds/struts-2.0.dtd&#xA;        ## myeclipse中：window        --&amp;gt; Preferences --&amp;gt; MyEclipse --&amp;gt; XML --&amp;gt; XML Catalog --&amp;gt; XML Catalog Entries 选中User Specified Entries --&amp;gt; 点击add&#xA;        ## Location中关联源码路径,Key Type 选择 URI,Key中写xml文件中声明的url &#xA;改变Package Explorer Vier中包的为分层显示方式：&#xA;        Package Explorer 视窗中 --&amp;gt; 点击倒三角 --&amp;gt; Package Presentation --&amp;gt; hierarchical ：&#xA;        &#xA;导入war文件：&#xA;        新建webPorject --&amp;gt; File===》import==》General中选择Archive File --&amp;gt; Form archive file中选择要导入的项目.war -&amp;gt; 导入&#xA;&#xA;ctrl + shift + t 关联源码快捷键&#xA;                                                &#xA;设置字体：eclipse preference--&amp;gt;Colors and Fonts--&amp;gt;basic--&amp;gt;Text Font--&amp;gt;edit&#xA;&#xA;导入dtd/xsd约束文件:window -&amp;gt; preferences -&amp;gt; XmlCatalog -&amp;gt; add&#xA;        dtd直接导入文件就可以了,xsd要在添加时key的选项中补上文件名&#xA;        &#xA;自定义jar包library目录&#xA;        项目 右键:building path -&amp;gt; addLiber-&amp;gt;user liber配置userLibery右键:building path -&amp;gt; addLiber-&amp;gt;user liber配置userLibery&#xA;                只是作了外部的引用,workspace中没有包，但是别人导入时会搜索同名的userLibery自动进行配置&#xA;改javaee版本    &#xA;        1.修改项目中的javaee包&#xA;        2.项目工程目录/settings/org.eclipse.wst.common.project.facet.core.xml/中修改javaee版本&#xA;&#xA;在线安装svn&#xA;        Help -&amp;gt; install from site(Myeclipse2013) -&amp;gt; add -&amp;gt; url=http://subclipse.tigris.org/update_1.6.x&#xA;        不选择 Subclipse -&amp;gt; Subclipse Integration for Mylyn 3.x , 其它全选&#xA;&#xA;在线安装mylyn&#xA;        同上，url(Myeclipse2013):http://download.eclipse.org/mylyn/snapshots/weekly&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;插件-1&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;myeclipse 2013 安装svn&#xA;        help -&amp;gt; Install from Site -&amp;gt;add&#xA;                name : Svn&#xA;                Location : http://subclipse.tigris.org/update_1.6.x&#xA;                        或&#xA;                        http://subclipse.tigris.org/update&#xA;        下一步&#xA;                不要选择Subclipse选项下的Subclipse Integration for Mylyn 3.x(Optional)&#xA;        一直下一步&#xA;&#xA;本地安装svn插件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;快捷键&#34;&gt;&#xA;  快捷键&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e6%8d%b7%e9%94%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;alt /&#xA;ctrl shift f&#xA;    # 代码格式化&#xA;alt enter&#xA;    # 补全提示&#xA;f3&#xA;    # 跳转到声明&#xA;f2 显示类或方法的全限定名&#xA;ctrl + h 多文件搜索        &#xA;alt shift s&#xA;alt shift z :surround with &#xA;ctrl /&#xA;ctrl shift /&#xA;F5 F6 F7&#xA;ctrl alt 上下&#xA;alt 上下&#xA;alt shift x j ：运行&#xA;ctrl 1 显示错误红线的处理方法&#xA;ctrl t 显示继承关系&#xA;ctrl 左右 跳过单词&#xA;ctrl 上下滚屏&#xA;ctrl l 定位&#xA;输入时直接点分号就可以跳到最后&#xA;ctrl alt / 写过内容补全&#xA;字符串最后敲回车可以自动加入 + &#39;\n&#39; &amp;quot;&amp;quot;&#xA;ctrl shift T  openType 查找类关系&#xA;ctrl shift R  查找资源文件&#xA;alt shift A 矩形操作&#xA;alt 左右 返回代码上一层，进入代码下一层&#xA;ctrl o 获得outline&#xA;// TODO 标签&#xA;alt + shift + R 重构中的重命名&#xA;ctrl + shift + o 全局导包&#xA;ctrl + shift + m 局部导包&#xA;ctrl + shift + X  改为大写&#xA;ctrl + shift + g  查看方法被谁调用&#xA;ctrl + shift + h  输入类名，查看类继承关系&#xA;命令补全：syso main        alt + /&#xA;代码抽取:        alt + shift + M&#xA;代码自动生成get set                alt + shift +s&#xA;代码自动生成 — 重写equals hashCode  alt + shift + s&#xA;    &#xA;&#xA;Ctrl+1 快速修复(最经典的快捷键,就不用多说了)&#xA;Ctrl+D: 删除当前行 &#xA;Ctrl+Alt+↓ 复制当前行到下一行(复制增加)&#xA;Ctrl+Alt+↑ 复制当前行到上一行(复制增加)&#xA;Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)&#xA;Alt+↑ 当前行和上面一行交互位置(同上)&#xA;Alt+← 前一个编辑的页面&#xA;Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)&#xA;Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性&#xA;Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)&#xA;Shift+Ctrl+Enter 在当前行插入空行(原理同上条)&#xA;Ctrl+Q 定位到最后编辑的地方&#xA;Ctrl+L 定位在某行 (对于程序超过100的人就有福音了)&#xA;Ctrl+M 最大化当前的Edit或View (再按则反之)&#xA;Ctrl+/ 注释当前行,再按则取消注释&#xA;Ctrl+O 快速显示 OutLine&#xA;Ctrl+T 快速显示当前类的继承结构&#xA;Ctrl+W 关闭当前Editer&#xA;Ctrl+K 参照选中的Word快速定位到下一个&#xA;Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示)&#xA;Ctrl+/(小键盘) 折叠当前类中的所有代码&#xA;Ctrl+×(小键盘) 展开当前类中的所有代码&#xA;Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用&#xA;&#xA;Alt+/来代替)&#xA;Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作)&#xA;Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没&#xA;&#xA;有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了)&#xA;Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查)&#xA;Ctrl+Shift+F4 关闭所有打开的Editer&#xA;Ctrl+Shift+X 把当前选中的文本全部变味小写&#xA;Ctrl+Shift+Y 把当前选中的文本全部变为小写&#xA;Ctrl+Shift+F 格式化当前代码&#xA;Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反&#xA;&#xA;之)&#xA;下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift&#xA;&#xA;开头的了)&#xA;Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力&#xA;&#xA;)&#xA;Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用)&#xA;Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)&#xA;Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候)&#xA;Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能)&#xA;Alt+Shift+I 合并变量(可能这样说有点不妥Inline)&#xA;Alt+Shift+V 移动函数和变量(不怎么常用)&#xA;Alt+Shift+Z 重构的后悔药(Undo)&#xA;编辑&#xA;作用域 功能 快捷键 &#xA;全局 查找并替换 Ctrl+F &#xA;文本编辑器 查找上一个 Ctrl+Shift+K &#xA;文本编辑器 查找下一个 Ctrl+K &#xA;全局 撤销 Ctrl+Z &#xA;全局 复制 Ctrl+C &#xA;全局 恢复上一个选择 Alt+Shift+↓ &#xA;全局 剪切 Ctrl+X &#xA;全局 快速修正 Ctrl1+1 &#xA;全局 内容辅助 Alt+/ &#xA;全局 全部选中 Ctrl+A &#xA;全局 删除 Delete &#xA;全局 上下文信息 Alt+？&#xA;Alt+Shift+?&#xA;Ctrl+Shift+Space &#xA;java编辑器 显示工具提示描述 F2&#xA;java编辑器 选择封装元素 Alt+Shift+↑&#xA;java编辑器 选择上一个元素 Alt+Shift+←&#xA;java编辑器 选择下一个元素 Alt+Shift+→&#xA;文本编辑器 增量查找 Ctrl+J &#xA;文本编辑器 增量逆向查找 Ctrl+Shift+J &#xA;全局 粘贴 Ctrl+V &#xA;全局 重做 Ctrl+Y &#xA;&#xA;查看&#xA;作用域 功能 快捷键 &#xA;全局 放大 Ctrl+= &#xA;全局 缩小 Ctrl+- &#xA;&#xA;窗口&#xA;作用域 功能 快捷键 &#xA;全局 激活编辑器 F12 &#xA;全局 切换编辑器 Ctrl+Shift+W &#xA;全局 上一个编辑器 Ctrl+Shift+F6 &#xA;全局 上一个视图 Ctrl+Shift+F7 &#xA;全局 上一个透视图 Ctrl+Shift+F8 &#xA;全局 下一个编辑器 Ctrl+F6 &#xA;全局 下一个视图 Ctrl+F7 &#xA;全局 下一个透视图 Ctrl+F8 &#xA;文本编辑器 显示标尺上下文菜单 Ctrl+W &#xA;全局 显示视图菜单 Ctrl+F10 &#xA;全局 显示系统菜单 Alt+- &#xA;&#xA;导航&#xA;作用域 功能 快捷键 &#xA;ｊａｖａ编辑器 打开结构 Ctrl+F3 &#xA;全局 打开类型 Ctrl+Shift+T &#xA;全局 打开类型层次结构 F4 &#xA;全局 打开外部ｊａｖａdoc Shift+F2&#xA;全局 打开资源 Ctrl+Shift+R &#xA;全局 后退历史记录 Alt+← &#xA;全局 前进历史记录 Alt+→ &#xA;全局 上一个 Ctrl+, &#xA;全局 下一个 Ctrl+. &#xA;ｊａｖａ编辑器 显示大纲 Ctrl+O &#xA;全局 在层次结构中打开类型 Ctrl+Shift+H &#xA;全局 转至匹配的括号 Ctrl+Shift+P &#xA;全局 转至上一个编辑位置 Ctrl+Q &#xA;ｊａｖａ编辑器 转至上一个成员 Ctrl+Shift+↑ &#xA;ｊａｖａ编辑器 转至下一个成员 Ctrl+Shift+↓ &#xA;文本编辑器 转至行 Ctrl+L &#xA;&#xA;搜索&#xA;作用域 功能 快捷键 &#xA;全局 出现在文件中 Ctrl+Shift+U &#xA;全局 打开搜索对话框 Ctrl+H &#xA;全局 工作区中的声明 Ctrl+G &#xA;全局 工作区中的引用 Ctrl+Shift+G &#xA;&#xA;文本编辑&#xA;作用域 功能 快捷键 &#xA;文本编辑器 改写切换 Insert &#xA;文本编辑器 上滚行 Ctrl+↑ &#xA;文本编辑器 下滚行 Ctrl+↓ &#xA;&#xA;文件&#xA;作用域 功能 快捷键 &#xA;全局 保存 Ctrl+X &#xA;Ctrl+S &#xA;全局 打印 Ctrl+P &#xA;全局 关闭 Ctrl+F4 &#xA;全局 全部保存 Ctrl+Shift+S &#xA;全局 全部关闭 Ctrl+Shift+F4 &#xA;全局 属性 Alt+Enter &#xA;全局 新建 Ctrl+N &#xA;&#xA;项目&#xA;作用域 功能 快捷键 &#xA;全局 全部构建 Ctrl+B &#xA;&#xA;源代码&#xA;作用域 功能 快捷键 &#xA;java编辑器 格式化 Ctrl+Shift+F&#xA;java编辑器 取消注释 Ctrl+\&#xA;java编辑器 注释 Ctrl+/&#xA;java编辑器 添加导入 Ctrl+Shift+M&#xA;java编辑器 组织导入 Ctrl+Shift+O&#xA;java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。&#xA;也可以使用Ctrl+1自动修正。 &#xA;&#xA;运行&#xA;作用域 功能 快捷键 &#xA;全局 单步返回 F7 &#xA;全局 单步跳过 F6 &#xA;全局 单步跳入 F5 &#xA;全局 单步跳入选择 Ctrl+F5 &#xA;全局 调试上次启动 F11 &#xA;全局 继续 F8 &#xA;全局 使用过滤器单步执行 Shift+F5 &#xA;全局 添加/去除断点 Ctrl+Shift+B &#xA;全局 显示 Ctrl+D &#xA;全局 运行上次启动 Ctrl+F11 &#xA;全局 运行至行 Ctrl+R &#xA;全局 执行 Ctrl+U &#xA;&#xA;重构&#xA;作用域 功能 快捷键 &#xA;全局 撤销重构 Alt+Shift+Z &#xA;全局 抽取方法 Alt+Shift+M &#xA;全局 抽取局部变量 Alt+Shift+L &#xA;全局 内联 Alt+Shift+I &#xA;全局 移动 Alt+Shift+V &#xA;全局 重命名 Alt+Shift+R &#xA;全局 重做 Alt+Shift+Y &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jrebel&#34;&gt;&#xA;  jrebel&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jrebel&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        热加载&#xA;使用:&#xA;        myeclipse根目录下配置自定义 插件&#xA;        window -&amp;gt; preferences -&amp;gt; JRebel中关联jar包，设定自动部署时间&#xA;    window -&amp;gt; preferences -&amp;gt; services -&amp;gt; tomcat -&amp;gt; tomcat6(可以配置是否启用jrebel和打印jrebel的日志)-&amp;gt;jdk 加上资源分配参数与tomcat要加载的jar包:&#xA;                        -noverify -javaagent:D:\(修改为自己的目录)\jrebel.jar -Xmx512M -Xms512M -XX:MaxPermSize=1024m&#xA;        项目右键jrebel生成reble.xml,其中配置rebel要管理的项目在tomcat中的路径&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>VIM</title>
      <link>https://runout.run/docs/tool/develop/vim/</link>
      <pubDate>Thu, 11 Oct 2018 18:31:16 +0800</pubDate>
      <guid>https://runout.run/docs/tool/develop/vim/</guid>
      <description>&lt;h1 id=&#34;编译&#34;&gt;&#xA;  编译&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%af%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;--with-features=tiny                # 只包含最基本功能。small, normal, big, huge, :h feature-list查看&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;vim -u NONE -N                      # -u NONE 不加载配置文件和插件，并进入vi兼容模式&#xA;    -u code/essential.vim           # 加载指定配置文件&#xA;    -N set nocompatible             # 不进入vi兼容模式&#xA;    --version                       # 可查看特性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;mode&#34;&gt;&#xA;  mode&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mode&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;普通模式&#xA;插入模式&#xA;可视模式&#xA;    v/V                             # 面向字/面向行 可视模式&#xA;    &amp;lt;C - v&amp;gt;                         # 面向块 可视模式&#xA;    gv                              # 重选上次选区&#xA;    o                               # 切换到选区的开头, 再按切换回尾端　&#xA;替换模式&#xA;    R&#xA;命令行模式(Ex命令)&#xA;    :                               # 可视模式中选定范围，切换到命令行时，自动输入range&#39;&amp;lt;,&#39;&amp;gt;代表选中区&#xA;操作符待决模式                         # operator 与 motion之间的空闲时期&#xA;                                    # 两个字符的operator, 字符间的空闲时期不是该模式，是命名空间，是普通模式的扩充&#xA;                                    # 有了这个模式，能创建自定义映射项来激活或终结操作符待决模式，就可以自定义operator和motion&#xA;选择模式                              # 类似windows中选中&#xA;    &amp;lt;C - g&amp;gt;在可视和选择模式切换&#xA;历史&#xA;    q:                              # 命令历史&#xA;    q/                              # 搜索历史&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;operate&#34;&gt;&#xA;  operate&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#operate&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;思想&#xA;    {operator}{motion}&#xA;    {operator}{text-objects}&#xA;shortcut key&#xA;    ctrl + c                        # 同Esc&#xA;motions&#xA;    .                               # 重复前一次修改, 目标做到一键移动，一键执行。修改是指: 一个normal模式下的按键, 插入内容, &amp;lt;ESC&amp;gt;; 或一组normal模式下按键&#xA;    K                               # 当前单词的:h 手册&#xA;    ga                              # 当前字符的unicode码&#xA;Ex command                          # 可视模式下选中行, : 时前面有&#39;&amp;lt;,&#39;&amp;gt; 表示对选中的行执行操作&#xA;    :h e 或 :help e                 # 查看e的帮助&#xA;        vimtutor 查看教程&#xA;        operator 查看operator&#xA;        map-operator 查看自定义operator&#xA;        omap-info 查看自定义motion&#xA;        digraphs-default&#xA;        digraphs&#xA;        digraphs-table 查看二合字符表&#xA;        ex-cmd-index 查看所有Ex命令&#xA;        vi-differences vim 相对vi的特性&#xA;    :version                        # 查看版本和支持的功能&#xA;    :! command                      # 执行某shell命令(CR返回)&#xA;        !! 执行前一个命令&#xA;        r!command 执行结果插入当前位置&#xA;        w!command 当前文件作为输入执行&#xA;    :cd directory                   # 修改工作目录&#xA;    :sh                             # 跳到shell, 再执行exit返回&#xA;    :map bbc ia                     # 定义命令序列ia的别名为bbc&#xA;    :pwd                            # 显示当前目录&#xA;    :normal A;                      # 执行普通模式命令A;, 添加分号到行尾&#xA;    系统命令&#xA;        :grep t * # 在当前所有文件中匹配t, 自动加-n参数(显示行号)&#xA;        :ls&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;locate-oper&#34;&gt;&#xA;  locate oper&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#locate-oper&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;motion&#xA;    ^/$/0/&amp;lt;home&amp;gt;/g_/h/l/j/k/w/W/e/E/b/B/ge/gE/gg/G/[[/]]/(/)/{/}/nH/M/nL/点鼠标&#xA;        # 移动motion&#xA;        ge同b, 停在单词尾部&#xA;        &amp;lt;home&amp;gt;同0, 到行开始, ^则到本行第一个字符&#xA;        gg同[[，G同]]，10G跳到第10行&#xA;        fx 移动到下一个x, F反向查找, tx 移动到x的前一个字符&#xA;&#xA;        nG 跳到第n行&#xA;    f/F/t/T                         # 行搜索motion         重复查找(以相反方向重复搜索)&#xA;    ;                               # 重复移动上次f/F/t/T的字符&#xA;    ,                               # 撤销上次f/F/t/T移动&#xA;    *                               # 查找当前词&#xA;    nzz/nz-                         # 跳到指定行, 显示在屏幕中间/底部&#xA;        zz 当前屏幕到中间&#xA;    可视模式&#xA;        $                           # 块可视模式中，表示所有行尾&#xA;        i/a                         # 块可视模式中有不同含义&#xA;operator&#xA;    3G                              # 跳到第3行&#xA;    /text　　                        # 查找text，按n健查找下一个，按N健查找前一个。&#xA;    ?text　　                        # 查找text，反向查找，按n健查找下一个，按N健查找前一个。&#xA;    *或#                            # # *相当于/，#相当于?&#xA;        g* 搜索子串&#xA;        gd  同* 但跳到第一个匹配序列&#xA;    %                               # 搜索对应括号&#xA;&#xA;    o-&amp;gt; marks&#xA;    ``                              # 跳回&#xA;        `&amp;quot; 最后编辑的位置&#xA;        `[ 最后修改的开始位置&#xA;        `] 最后修改的结束位置&#xA;        &#39;. `. 跳到上次编辑位置&#xA;    &#39;&#39;                              # 跳回到第一个非空白字符&#xA;    marks                           # 显示系统全部书签&#xA;    ma                              # mark当前光标位置为a，小写字母不同文件标记不同行, 大写字母全局标记，但webstorm中ideaVim不行&#xA;    `a                              # 跳到a的位置&#xA;Ex command&#xA;    :10                             # 跳到第10行, 同10G, 0位于第一行上方&#xA;    :jumps                          # 输出能跳往的位置列表，可跳转多个文件&#xA;    :$                              # 文件结尾&#xA;    :.                              # 当前位置&#xA;    :%                              # 文件中的所有行&#xA;    :&#39;&amp;lt;                             # 选中区开始&#xA;    :&#39;&amp;gt;                             # 选中区结尾&#xA;    :&#39;m                             # 位置标记为m的行&#xA;    :/&amp;lt;html&amp;gt;/,/&amp;lt;\html&amp;gt;/             # 模式匹配范围&#xA;    : 1+1, 5-1                      # 开始向下偏移一行，结尾向上偏移一行&#xA;    :vim[grep] abc test             # 在test文件中grep匹配abc&#xA;shortcut key&#xA;    &amp;lt;c - e&amp;gt;/y                       # 向下/上滚动一行&#xA;    &amp;lt;c - d&amp;gt;/u                       # 向下/上滚动半屏&#xA;    &amp;lt;c - f&amp;gt;/b                       # 向下/上滚动一屏&#xA;    &amp;lt;c - i&amp;gt;/o                       # 到下个/上个跳动过的位置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;edit-oper&#34;&gt;&#xA;  edit oper&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#edit-oper&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;shortcut key&#xA;    &amp;lt;C - r&amp;gt;                         # 撤销的撤销&#xA;    &amp;lt;C - a&amp;gt;/x                       # 数字增加/减少1, 对0开关数字进行八进制操作, 0x进行十进制操作。可以设置nrformats改变&#xA;    插入模式/命令模式&#xA;        &amp;lt;C - h&amp;gt;                     # 删除前一个字符&#xA;        &amp;lt;C - w&amp;gt;                     # 命令模式可用，删除前一个单词&#xA;        &amp;lt;C - u&amp;gt;                     # 命令模式可用，删至行首&#xA;        &amp;lt;C - [&amp;gt;                     # 返回普通模式&#xA;        &amp;lt;C - o&amp;gt;                     # 到插入-普通模式&#xA;        &amp;lt;C - v&amp;gt;                     # 命令模式可用，插入编码对应的字符&#xA;            065                     # 两位的编码&#xA;            u00bf                   # 超过3位的unicode码&#xA;            非数字                   # 直接插入, 如expandtab开启后插入tab&#xA;        &amp;lt;C - k&amp;gt;{char1}{char2}       # 命令模式可用，插入以二合字母表示的字符&#xA;            12&#xA;            &amp;lt;&amp;lt;&#xA;            ?I&#xA;        &amp;lt;C - r&amp;gt;{register}           # 命令模式可用，插入寄存器内容&#xA;    补全&#xA;        &amp;lt;C - n&amp;gt;/p                   # 自动补全下/上&#xA;&#xA;        &amp;lt;C - x&amp;gt; 接着按如下&#xA;            &amp;lt;C - L&amp;gt;                 # 整行补全&#xA;            &amp;lt;C - N&amp;gt;                 # 根据当前文件里关键字补全&#xA;            &amp;lt;C - K&amp;gt;                 # 根据字典补全&#xA;            &amp;lt;C - T&amp;gt;                 # 根据同义词字典补全&#xA;            &amp;lt;C - I&amp;gt;                 # 根据头文件内关键字补全&#xA;            &amp;lt;C - ]&amp;gt;                 # 根据标签补全&#xA;            &amp;lt;C - F&amp;gt;                 # 补全文件名&#xA;            &amp;lt;C - D&amp;gt;                 # 补全宏定义&#xA;            &amp;lt;C - V&amp;gt;                 # 补全vim命令&#xA;            &amp;lt;C - U&amp;gt;                 # 用户自定义补全方式&#xA;            &amp;lt;C - S&amp;gt;                 # 拼写建议&#xA;operator                            # num + operator 来多次操作, 合并命令如A(同$a), 是为了普通模式下一个按键进行插入，这样能够在.命令中重复&#xA;    @:                              # 重复Ex命令&#xA;    &amp;amp;                               # 重复substitute命令&#xA;    x/X                             # 删除当前字符/删除前一个字符， x等于dl，X 等于dh&#xA;    u/U                             # 撤销(Undo)/撤销对整行的操作&#xA;    r/R                             # 替换一个字符/持续替换字符，tab是一个字符&#xA;        gR                          # 一个tab由tabstop个字符才能替换&#xA;        gr&#xA;    y/yy/Y                          # yank 复制/复制一行/同yy&#xA;        :y&#xA;    p/P                             # 粘贴/前面粘贴&#xA;        :p&#xA;    a/A                             # s当前字符后插入&#xA;        A同$a, 行尾插入&#xA;    o/O                             # 向后插入行&#xA;        o同A&amp;lt;CR&amp;gt;&#xA;        O同ko, 向前插入行&#xA;    s/S                             # 替换当前字符/替换当前行&#xA;        s同cl&#xA;        S同^C&#xA;    i/I                             # 当前字符前插入/行首插入&#xA;        I同^i &#xA;    c/cc/C                          # 替换/替换一行/同cc&#xA;        :0,10c 与 :c&#xA;        C同c$&#xA;    d/dd/D                          # 删除/删除一行/删到行尾&#xA;        dd 同 :d&#xA;        10d表示删除10行&#xA;        D同d$&#xA;        :0,10d 与 :d&#xA;    &amp;lt;&amp;lt;/&amp;gt;&amp;gt;&#xA;        可视模式下 &amp;lt;/&amp;gt;&#xA;        命令下 1&amp;gt;&amp;gt;2 表示从1行开始, 作用2行&amp;gt;&amp;gt;, 可以1&amp;gt;&amp;gt;&amp;gt;&amp;gt;2&#xA;        1,2&amp;gt; 表示 1到2行&amp;gt;&amp;gt;, 可以1,2&amp;gt;&amp;gt;&#xA;        &amp;gt;G 缩进当前到最后一行&#xA;    =                               # 自动缩进&#xA;        == 自动缩进当前行&#xA;    !                               # 用外部命令过滤指定行&#xA;        如!j, 自动进入命令模式, 选定了指定行进行!&#xA;        !!当前[count]行&#xA;    J                               # 与下行合并&#xA;    g                               # :[range]global/{pattern}/{command}&#xA;        global命令在[range]指定的文本范围内（缺省为整个文件）查找{pattern}，然后对匹配到的行执行命令{command}，如果希望对没匹配上的行执行命令，则使用global!或vglobal命令。&#xA;        g/^/m 0 倒序文件行&#xA;    g_                              # 到本行最后一个不是blank字符的位置&#xA;    gd                              # 智能跳到当前变量定义的位置&#xA;    gu/gU                           # 转换到小写/大写, 如gUw&#xA;        gugu / guu / gUgU / gUU&#xA;    g~                              # 大写转小写，小写转大写&#xA;        g~g~ / g~~ 转换一行&#xA;    可视模式下&#xA;            U/u                     # 大写/小写&#xA;ex command&#xA;    :1,10 co 20                     # 将1-10行插入到第20行之后。&#xA;        :1,$ co $ 复制整个文件添加到尾部&#xA;    :1, 10 m 20                     # 第1-10行移动到第20行之后&#xA;    :ab attr attribute              # 缩写, 输入模式中输入attr,再输入非字母字符(空格, 点等)，自动补全&#xA;        ab查看所有缩写&#xA;        una/unab attr 取消缩写　&#xA;    :!                              # 执行外部命令&#xA;    :[range]copy{address} /:t /:co  # 复制range到address后, :t 2 表示复制当前行到第2行后&#xA;    :[range]move{address}           # 移动&#xA;    :[range]join                    # 连接&#xA;    :[range]delete[x]               # 删除指定范围内的行到寄存器中&#xA;    :[range]yank[x]                 # 复制&#xA;    :[line]put[x]                   # 指定行后粘贴寄存器中内容&#xA;    :[range]normal{commands}        # 指定范围执行命令&#xA;    :[range]print / p               # 在vim下方回显指定行的内容&#xA;text-object&#xA;    i&amp;quot;&#xA;        &amp;quot; 表示 光标所在&amp;quot;&amp;quot;的内容&#xA;        &#39;&#xA;        `&#xA;        ) 表示 ()的内容&#xA;        ( 同上&#xA;        ]&#xA;        [&#xA;        &amp;gt;&#xA;        &amp;lt;&#xA;        }&#xA;        {&#xA;        B 表示 {}的内容&#xA;        t 表示 tag之间的内容，如&amp;lt;h2&amp;gt;aaaa&amp;lt;/h2&amp;gt;&#xA;        w 表示 光标所在word&#xA;        s 表示 光标所在句子&#xA;        p 表示 段落&#xA;    a&amp;quot;                              # 包括外围，命令同i&#xA;    视图模式下&#xA;        vit                         # 在可视模式下选中标签内容，如&amp;lt;a&amp;gt;xxx&amp;lt;/a&amp;gt;的xxx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;patterns-oper&#34;&gt;&#xA;  patterns oper&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#patterns-oper&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;operator&#xA;    &amp;amp;                               # 重复:s上次执行的命令, 不包含g&#xA;        g&amp;amp; 全局重复:s上次的命令&#xA;    n/N                             # 查找下一个/上一个&#xA;Ex command&#xA;    :[range]substitude/{pattern}/{string}/[flags]&#xA;        :s 用new替换old，替换当前行的第一个匹配&#xA;        前面是正则, 用()分组，后面用\1引用分组&#xA;        :s/old/new/g 作用到整行&#xA;        :%s/old/new/ 作用到每行第一个&#xA;        :10,20 s/^/    /g 作用到10到20行的每一个&#xA;        :%s/old/new/g 作用到全文&#xA;        :s/old/new/gc 每次修改前询问&#xA;&#xA;    :[range]global/{pattern}/[cmd]&#xA;        :g 查找text的行执行命令,如:g/text/s/old/new/g&#xA;        v/text/command 查找到行不执行命令,其它行执行&#xA;    :&amp;amp;                              # 同operator中&amp;amp;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;registers-oper&#34;&gt;&#xA;  registers oper&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#registers-oper&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;register                            # 寄存器&#xA;    :reg                            # 查看所有寄存器 或 :reg 1 查看寄存器1的内容&#xA;    &amp;quot;0p                             # &amp;quot;0&amp;lt;operator&amp;gt; 粘贴寄存器0的内容&#xA;        &amp;quot;0y 复制到寄存器0&#xA;    :pu 0                           # 同上&#xA;        :pu! 0 同 &amp;quot;0P&#xA;    :y a                            # 复制当前行到&amp;quot;a寄存器&#xA;        :5,10y m 复制5到10行到&amp;quot;m寄存器&#xA;    分类&#xA;        &amp;quot;&amp;quot;                          # unamed 缓存最后一次操作内容&#xA;        &amp;quot;0                          # numbered 范围0 - 9 。&amp;quot;0缓存最近一次复制的内容&#xA;            &amp;quot;1到&amp;quot;9缓存最近9次删除的内容, &amp;quot;9向后则丢弃&#xA;            第2次删除时，缓存1转存到缓存2, 新的删除内容存到缓存1&#xA;        &amp;quot;-                          # small delete 缓存行内删除内容&#xA;        &amp;quot;a                          # named 范围a - z 与 A - Z&#xA;        &amp;quot;:                          # read-only&#xA;            如 &amp;quot;: 最近命令 &amp;quot;. 最近插入文本 &amp;quot;% 当前文件名 &amp;quot;# 当前交替文件名&#xA;        &amp;quot;=                          # expression 用于执行表达式命令，只读&#xA;        &amp;quot;*                          # selection and drop&#xA;            如 &amp;quot;* &amp;quot;+ &amp;quot;~ 存取GUI选择文本，可用于与外部交互，要求系统剪切板(clipboard)可用&#xA;        &amp;quot;_                          # black hole 表示不缓存，干净删除&#xA;        &amp;quot;/                          # last search pattern 缓存最近的搜索模式&#xA;shortcut key&#xA;    &amp;lt;C - r&amp;gt;0                        # 插入寄存器缓冲区内容, 原理是vim插入模式模拟打入&#xA;            &amp;lt;C - p&amp;gt;0                # 保持格式不变&#xA;    &amp;lt;C - r&amp;gt;=6 * 35&amp;lt;CR&amp;gt;              # 计算结果&#xA;宏&#xA;    qa ... q                        # 录制宏a，存到寄存器中，可以用&amp;quot;ap粘贴出来&#xA;    @a                              # 运行宏a&#xA;    let @a = &amp;quot;&amp;quot;                     # 用let @a 在.vimrc设置文件中设置宏a&#xA;    内置宏&#xA;        :                           # 上次的Ex命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;file-oper&#34;&gt;&#xA;  file oper&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#file-oper&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;shell&#xA;    $ vim file1 file2..&#xA;    $ vimtutor                      # vim的教程&#xA;&#xA;operator&#xA;    o-&amp;gt; 折叠&#xA;    zf                              # 创建折叠&#xA;        zf% 创建括号折叠&#xA;        zf56G 创建从当前行起到56行代码的折叠&#xA;    zo/zO                           # 展开当前/递归展开当前(folding open, z这个字母看上去比较像折叠的纸)&#xA;    zc/zC                           # 再折叠/递归再折叠(folding close)&#xA;    [z                              # 到折叠的开始处&#xA;    z]                              # 到折叠的结束处&#xA;    zk                              # 向上移动到前一个折叠的结束处&#xA;    zd/zD                           # 删除当前光标下的折叠/嵌套删除折叠&#xA;&#xA;    o-&amp;gt; 文件对比&#xA;    vim -d file1 file2&#xA;    diffsplit file2&#xA;    diffthis&#xA;    diffupdate&#xA;    [c                              # 跳到前一个不同点&#xA;    ]c                              # 跳到后一个不同点&#xA;    dp                              # 合并增加另一个 （diff put）&#xA;    do                              # 合并增加当前 （diff get）&#xA;Ex command&#xA;    :help                           # 显示帮助, 同F1&#xA;        帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回&#xA;        :help tutor 显示vimtutor的教程&#xA;        :help xx 显示某个帮助, 如help CTRL-[&#xA;        :help &#39;number&#39; 显示vim选项的帮助&#xA;        :help &amp;lt;Esc&amp;gt; 显示特殊键的帮助&#xA;        :help -t 显示vim启动参数的帮助&#xA;        :help i_&amp;lt;Esc&amp;gt; 插入模式下Esc的帮助，某个模式下的帮助用 模式_主题的模式&#xA;    :r/nr filename                  # 插入一个文件的内容/插入到第n行&#xA;    :f                              # 显示当前文件状态&#xA;    :.=                             # 打印当前行号&#xA;        := 打印总行号&#xA;    :open file                      # 新窗口打开文件&#xA;    :saveas filename                # 另存为并切换到文件&#xA;    :tabnew                         # 新建标签页&#xA;    :split file/:new                # 屏幕分割&#xA;    :vsplit 纵向打开窗口&#xA;    :q                              # q! 强制退出&#xA;    :w/:write                       # :w filename 写入新文件&#xA;    :x                              # 有改动时保存并退出, 无改动只退出&#xA;    ZZ&#xA;    :e/:edit                        # 重新打开文件, e! 放弃所有修改重新打开文件&#xA;        e filename 当前窗口打开另一个文件&#xA;    :bn/:bp                         # 切换上个/下个文件&#xA;    :saveas &amp;lt;path/to/file&amp;gt;          # 另存为到 &amp;lt;path/to/file&amp;gt;&#xA;    :!command                       # 执行shell命令，如 :!ls&#xA;        :!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。&#xA;        :!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。&#xA;    :suspend                        # 挂起vim，回到shell，命令fg返回vim。&#xA;    :buffers/:ls                    # 缓冲区列表&#xA;    :bprev                          # 上一缓冲区&#xA;    :bnext                          # 下一缓冲区&#xA;&#xA;    o-&amp;gt; 多视窗&#xA;    :vert                           # 横向打开&#xA;    :vsplit                         # 横向打开&#xA;    :split&#xA;    :prev                           # 上一个文件&#xA;    :next                           # 下一个文件&#xA;    :close                          # 最后一个窗口不能使用此命令，可以防止意外退出vim。&#xA;    :only                           # 关闭所有窗口，只保留当前窗口&#xA;&#xA;    o-&amp;gt; 标签窗口                      # 启动 Vim 时用 &amp;quot;vim -p filename ...&amp;quot;&#xA;    :tabe[dit]                      # 打开文件到标签&#xA;    :tabnew                         #  在当前标签页之后打开带空窗口的新标签页。&#xA;    :tabc[lose][!]{count}           #  关闭当前标签页。 {}表示关闭第count个标签&#xA;    :tabo[nly][!]                   # 关闭所有其它的标签页。&#xA;    :tabn[ext] {count}              # 切换到后面的标签页&#xA;    :tabp[revious] {count}          # 切换到前面的标签页&#xA;    :tabr[ewind]                    # 回卷跳转&#xA;    :tabfir[st]                     #  转到第一个标签页。&#xA;    :tabl[ast]                      # 转到最后一个标签页。&#xA;    :tabm[ove] [N]                  # 重排标签页&#xA;        把当前标签页移到第 N 个标签页之后。用 0 使当前标签页成为首个标&#xA;        签页。如果没有 N，当前标签页成为最后一个。&#xA;    :tabs                           # 列出标签页和它们包含的窗口信息。&#xA;        当前窗口显示 &amp;quot;&amp;gt;&amp;quot;。&#xA;        修改过的缓冲区显示 &amp;quot;+&amp;quot;。&#xA;    :tabd[o] {cmd}                  # 对每个标签页执行 {cmd}&#xA;&#xA;shortcut keys&#xA;        ctrl - z                    # 同 :suspend&#xA;        ctrl + g                    # 同 :f&#xA;&#xA;        o-&amp;gt; 多视窗&#xA;        ctrl + w + hljk&#xA;        ctrl + w + w                # 跳到下一个&#xA;        ctrl + w + p                # 跳到前一个&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;settings&#34;&gt;&#xA;  settings&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#settings&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;设置文件&#xA;    /etc/vimrc&#xA;    ~/.vimrc                        # vim的配置文件, 优先于.exrc&#xA;    ~/.exrc                         # vi的配置文件&#xA;命令&#xA;    :set&#xA;        all                         # 打印所有set选项&#xA;        nocompatible                # 不设置vi兼容&#xA;        ruler? 　　                  # 查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看&#xA;        shell    :/usr/bin/sh       # 使用SystemⅤ中的shell来执行vi中以！或  :!开头的shell命令&#xA;        nrformts                    # 设置进制, &amp;lt;c - a&amp;gt; &amp;lt;c - x&amp;gt;时对八进制有用，如07&#xA;&#xA;        encoding=utf-8              # 程序显示编码&#xA;        enc                         # 同上&#xA;        fileencodings=ucs-bom,utf-8,cp936                       # 设置读取文件支持的编码&#xA;        fencs                       # 同上&#xA;        fileencoding=utf-8          # 当前文件编码&#xA;        fenc                        # 同上&#xA;        termencoding=utf-8          # 设置终端编码&#xA;        tenc                        # 同上&#xA;&#xA;        list                        # 显示非打印字符，如tab，空格，行尾等。&#xA;        nolist                      # 取消显示非打印字符, 如果tab无法显示，请确定用 set lcs=tab:&amp;gt;- 命令设置了.vimrc文件&#xA;        number                      # 显示行号&#xA;        nu                          # 同上&#xA;        nonumber                    # 不显示行号&#xA;        nonu                        # 同上&#xA;        reprot=2                    # 用户做2行以上修改时显示统计信息&#xA;        hlsearch                    # 设置查找高亮&#xA;        hls                         # 同上&#xA;        incsearch                   # 查找高亮所有(增量高亮)&#xA;&#xA;        smartindent                 # 括号补全&#xA;        sm                          # 同上&#xA;        ignorecase                  # 查找时忽略大小写&#xA;        ic                          # 同上&#xA;        noignorecase                # 查找时不忽略大小写&#xA;        noic                        # 同上&#xA;        expandtab                   # 存起来的文件, 用space替换tab&#xA;        shiftwidth=4                # 换行时缩进长度&#xA;        sw                          # 同上&#xA;        softtabstop=4               # 插入模式tab长度&#xA;        tabstop=4                   # 识别和显示tab时，转换成space的长度&#xA;&#xA;        autoindent                  # 启用自动缩进&#xA;        ai                          # 同上&#xA;        foldmethod=indent           # 设置折叠&#xA;        fdm                         # 同上&#xA;            indent 缩进折叠&#xA;            syntax 语法高亮折叠&#xA;            expr 表达式定义折叠&#xA;            diff 对没有更改的文本折叠&#xA;            marker 对文中的标志折叠&#xA;    :scriptnames                    # 脚本文件位置，如.vimrc文件、语法文件、plugin&#xA;    :syntax clear                   # 列出已经定义的语法项&#xA;        clear 清除已定义的语法规则&#xA;        case match 大小写敏感，int和Int将视为不同的语法元素&#xA;        case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案&#xA;配置&#xA;    inoremap &amp;lt;C-]&amp;gt; &amp;lt;C-X&amp;gt;&amp;lt;C-]&amp;gt;       # 插入模式下映射&#xA;    nnoremap                        # 在normal模式下映射&#xA;    fileType plugin on              # 激活内置插件, 检测文件类型&#xA;    filetype on                     # 同上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;plugins&#34;&gt;&#xA;  plugins&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#plugins&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;netrw&#xA;    介绍&#xA;        自带插件&#xA;    edit ./                         # 查看目录树&#xA;    Ex                              # 同上&#xA;    Se                              # 下面弹出目录树 好用&#xA;    Ve                              # 左面弹出目录树 好用&#xA;&#xA;    &amp;lt;cr&amp;gt;   netrw 进入目录或读入文件 |netrw-cr|&#xA;    &amp;lt;del&amp;gt;  netrw 试图删除文件/目录 |netrw-del|&#xA;    -    netrw 往上走一层目录 |netrw--|&#xA;    a    在以下三种方式间切换: 正常显示，|netrw-a|&#xA;        隐藏 (不显示匹配 g:netrw_list_hide 的文件) 和&#xA;        显示 (只显示匹配 g:netrw_list_hide 的文件)&#xA;    c    使浏览中的目录成为当前目录 |netrw-c|&#xA;    d    建立目录 |netrw-d|&#xA;    D    netrw 试图删除文件/目录 |netrw-D|&#xA;    i    在瘦、长、宽和树形的各种列表方式间切换 |netrw-i|&#xA;    &amp;lt;c-l&amp;gt;  netrw 刷新目录列表 |netrw-ctrl-l|&#xA;    o    打开新浏览窗口，进入光标所在的目录。使用水平分割。|netrw-o|&#xA;    p    预览文件 |netrw-p|&#xA;    P    在前次使用的窗口里浏览 |netrw-P|&#xA;    r    反转排序顺序 |netrw-r|&#xA;    R    给指定的文件/目录换名 |netrw-R|&#xA;    s    选择排序方式: 按名字、时间或文件大小排序 |netrw-s|&#xA;    S    指定按名字排序的后缀优先级 |netrw-S|&#xA;    t    在新标签页里打开光标所在的文件/目录 |netrw-t|&#xA;    v    打开新浏览窗口，进入光标所在的目录。使用垂直分割。|netrw-v|&#xA;ctags&#xA;    将ec57w32.zip解压，在解压后文件夹中找到ctags.exe，将其复制到C:\ProgramFiles\Vim\vim72下，并编辑_vimrc文件，添加以下内容：&#xA;    set tags=tags;&#xA;    set autochdir&#xA;    打开cmd命令行，切换到你要查看的源代码的根目录处，运行&#xA;    ctags -R&#xA;    将会在此目录处生成一个tags文件。&#xA;    用gvim打开一个代码文件，将光标放到某一函数名上，如下图的UpdateViewByPosNo()，按下&amp;quot;ctrl+]&amp;quot;，光标会自动跳转到定义处。按下&amp;quot;ctrl+T&amp;quot;会跳回到原来的位置。&#xA;    变量、结构体、宏等等，都可以这样做。&#xA;    当你的源文件有更新时，只能重新运行ctags -R命令，来更新tags文件。&#xA;&#xA;    taglist&#xA;        将taglist_45.zip解压，解压后包含一个doc文件夹和一个plugin文件夹，将其中内容分别复制到C:\Program Files\Vim\vim72下的doc及plugin中。&#xA;        在_vimrc文件中加入以下内容：&#xA;        let Tlist_Show_One_File=1&#xA;        let Tlist_Exit_OnlyWindow=1&#xA;        用gvim打开代码文件（已生成过tags文件），:Tlist，TagList窗口即出现在左侧。&#xA;&#xA;visual-star&#xA;Qargs&#xA;nerdTreeToggle&#xA;    介绍&#xA;        目录显示插件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;加分号&#xA;    jA;&#xA;    j.&#xA;批量执行&#xA;    选中多行, :normal .&#xA;批量前缀&#xA;    选中多行, I&#xA;括起文字&#xA;    ci&amp;quot;        # 替换内容&amp;quot;&amp;quot;&#xA;    ca&amp;quot;        # 替换所有&#xA;    di&amp;quot;        # 删除内容&#xA;    cit        # 替换标签&#xA;执行python&#xA;    选中代码, :!python&#xA;缩进全文&#xA;    gg=G&#xA;替换到&amp;quot;&#xA;    cf&amp;quot;&#xA;esc&#xA;    &amp;lt;C-[&amp;gt;&#xA;目录窗口&#xA;    :Sex&#xA;&#xA;&#xA;console输出乱码&#xA;    language messages utf-8&#xA;    set termencoding=utf-8&#xA;设置文件编码&#xA;    set encoding=utf-8&#xA;    set fileencodings=utf-8,chinese,latin-1&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Docker</title>
      <link>https://runout.run/docs/tool/ops/docker/</link>
      <pubDate>Thu, 11 Oct 2018 18:18:21 +0800</pubDate>
      <guid>https://runout.run/docs/tool/ops/docker/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基于linux LXC，可以实现虚拟化&#xA;优点&#xA;    低成本、高利用率、充分灵活、动态调度&#xA;    核心网的最终形态&#xA;目录&#xA;    /var/lib/docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;镜象网站&#xA;    https://hub.docker.com/&#xA;阿里云个人仓库&#xA;    入口: cr.console.aliyun.com&#xA;        docker login -u 934260428@qq.com registry.cn-qingdao.aliyuncs.com&#xA;        docker tag java/device:1.0 registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0&#xA;        docker push registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0&#xA;        docker pull registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0&#xA;/etc/sysconfig/docker&#xA;    # /etc/init.d/docker.conf&#xA;    OPTIONS=&#39;--selinux-enabled --log-driver=journald --insecure-registry 45.55.56.16:5000 --dns 8.8.8.8&#39;&#xA;    DOCKER_CERT_PATH=/etc/docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;常用系统命令&#34;&gt;&#xA;  常用系统命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8%e7%b3%bb%e7%bb%9f%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;systemctl daemon-reload&#xA;systemctl restart docker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;docker&#34;&gt;&#xA;  docker&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;-h&#xA;version&#xA;login&#xA;    docker login -u outrun -p asdf&#xA;search mysql                    # 搜索镜像&#xA;pull centos:7                   # 下载镜像&#xA;    centos:latest&#xA;    outrun11/test:nginx1&#xA;image&#xA;    ls&#xA;    pull&#xA;    rm&#xA;images centos                   # 本地镜象列表&#xA;rmi centos:latest               # 删除镜象&#xA;container&#xA;    run                         # 新建容器&#xA;        --user root&#xA;        --name a&#xA;        --privileged&#xA;        --name                  # 显示名&#xA;        -t                      # 伪tty, -i 交互的&#xA;        -rm=true                # 执行完后删除&#xA;        -v /etc/:/opt/etc/      # 挂载本机/etc到容器/opt/etc, /etc/:/opt/etc/:ro 只读挂载, /etc/ 对外共享/etc&#xA;        -p 1234:80              # 端口映射本机1234端口到容器80&#xA;        --volumes-from etc_share                    # 使用另一个容器对外共享的磁盘&#xA;        -d                      # 后台运行&#xA;        --link redis_server:redis                   # 连接容器的redis命令&#xA;        -w /var/node            # 当前工作目录&#xA;        -e NODE_ENV=&#39;&#39;          # 环境变量&#xA;        --net=bridge            # 网络模式，bridge使用虚拟网桥docker0, host共享主机命名空间, container与已存在的一个容器共享命名空间, none关闭网络功能, overlay&#xA;&#xA;        --name nsqd -p 4150:4150 nsqio/nsq /nsqd&#xA;            # 端口&#xA;        -it centos /bin/bash&#xA;            # 启动容器, 执行bash&#xA;        b15 /bin/echo &#39;hello&#39;&#xA;            # 启动容器&#xA;        -it --rm=true --name=ls-volume -v /etc/:/opt/etc/ centos ls /opt/etc&#xA;            # 创建共享&#xA;        -it -p 1337:1337 --name=etc_share -v /etc/ centos mkdir /etc/my_share &amp;amp;&amp;amp; /bin/sh -c &amp;quot;while true; do echo hello; sleep 1; done&amp;quot;&#xA;            # 持续运行&#xA;        -it --rm=true --volumes-from etc_share --name=ls_etc centos ls /etc&#xA;            # 使用共享&#xA;    exec                        # 已有容器中运行&#xA;        -i&#xA;        -t&#xA;    ls&#xA;    start 026                       # 启动已建立的容器, id可以只输入前几位&#xA;        cp 026e:/docker/file /local/file&#xA;    stop 026&#xA;    restart 026e&#xA;    attach 026                  # 进入容器运行命令行, 可显示日志&#xA;    kill 026e&#xA;    prune&#xA;ps -a                           # 容器列表&#xA;rm                              # 移除容器&#xA;    docker rm docker ps -aq&#xA;        # 移除所有未运行的容器&#xA;    rm -f 026&#xA;&#xA;&#xA;build .                         # 用当前目录Dockerfile创建新镜像&#xA;    -t=&amp;quot;nginx/test&amp;quot;             # target&#xA;    --no-cache                  # 不用cache&#xA;    -f a.dockerfile             # 指定文件&#xA;tag nginx/test:test1 outrun11/test:nginx1&#xA;    # 远程docker基站创建repository, 名字test&#xA;push outrun11/test:nginx1&#xA;    logs beae3392&#xA;&#xA;&#xA;swarm                           # 一个或多个docker组成&#xA;    init&#xA;node                            # swarm节点&#xA;    ls&#xA;service                         # 运行于swarm的服务&#xA;    create&#xA;    ls&#xA;    ps&#xA;    rm&#xA;    inspect                     # 详情&#xA;    scale                       # 加减副本&#xA;    update                      # 变更属性&#xA;    logs                        # 查日志&#xA;system &#xA;    prune                       # 清理所有container, network, image, cache&#xA;network                         # 网卡&#xA;    ls&#xA;    rm&#xA;    prune                       # 删除全部未使用&#xA;    inspect                     # 详情&#xA;    create&#xA;        -d nat                  # 指定驱动&#xA;volume                          # 卷标, 默认挂载到/var/lib/docker/volumes&#xA;    create&#xA;    ls&#xA;    rm&#xA;    prune                       # 删除全部未使用&#xA;    inspect&#xA;stack                           # 单文件定义多服务&#xA;    deploy&#xA;    ls&#xA;    ps&#xA;    rm&#xA;&#xA;常用&#xA;    docker inspect 45370        # 详情&#xA;        --format &amp;quot;{{.State.Pid}}&amp;quot;&#xA;    docker login a.com -u outrun -p asdf&#xA;    docker build -t java/gateway:1.0 .&#xA;    docker push java/gateway:1.0&#xA;    docker images|grep none|awk &#39;{print $3}&#39;|xargs docker rmi -f&#xA;        # 删除none镜像&#xA;    docker image inspect 4de&#xA;    docker system prune -a&#xA;    docker exec -it -u root ef2 /bin/bash&#xA;    docker run --name gateway --rm -d java/gateway:1.0&#xA;    docker run -it ubuntu&#xA;    docker restart ef2&#xA;    docker logs -f -t ef2&#xA;    docker status 45370         # 显示资源占用&#xA;    docker save -o a.tar.gz a&#xA;    docker load &amp;lt; a.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;nsenter&#34;&gt;&#xA;  nsenter&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#nsenter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 指定pid, 不需ssh进入容器运行shell&#xA;docker inspect --format {{.State.Pid}} nginx&#xA;nsenter -t4629 -n&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;场景&#34;&gt;&#xA;  场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;查看镜像内文件&#xA;    docker run -it --entrypoint sh nginx:latest&#xA;查看/var/lib/docker/overlay2/id文件对应container&#xA;    docker ps -q | xargs docker inspect --format &#39;{{.State.Pid}}, {{.Id}}, {{.Name}}, {{.GraphDriver.Data.WorkDir}}&#39; | grep bff250&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;dockerfile&#34;&gt;&#xA;  Dockerfile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dockerfile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;指令&#xA;    FROM nginx                          # 基于镜像&#xA;    MAINTAINER outrun                   # 指定维护者信息&#xA;    EXPOSE 80                           # 内部服务开启的端口&#xA;    ENV NODE_ENV test                   # 环境变量&#xA;    WORKDIR /src                        # 指定工作目录&#xA;    COPY ./bin /data/a                  # 复制外部文件到内部&#xA;    VOLUME [&amp;quot;/data/log&amp;quot;]                # 创建挂载点&#xA;    ENTRYPOINT [&amp;quot;/data/a/a&amp;quot;]            # 启动命令，只有一个&#xA;    CMD [&amp;quot;-config&amp;quot;, &amp;quot;config.toml&amp;quot;]      # docker run 时运行&#xA;    RUN echo &#39;test&#39;                     # build过程中执行的命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;docker-compose&#34;&gt;&#xA;  docker-compose&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-compose&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker-compose&#xA;    -h                              # 帮助&#xA;    -f                              # 指定模板&#xA;    version&#xA;&#xA;    up                              # 所有模板创建容器&#xA;        -d                          # 后台&#xA;    down                            # 删除容器、网络、卷、镜像&#xA;    rm                              # 删除容器&#xA;    create                          # 创建容器&#xA;&#xA;    stop                            # 停止容器&#xA;    start                           # 启动容器&#xA;    restart&#xA;    pause                           # 暂停容器&#xA;    unpause&#xA;    kill                            # 强制停止容器&#xA;    scale                           # 指定容器个数&#xA;&#xA;    ps                              # 列出所有容器&#xA;    logs                            # 查日志&#xA;    port                            # 显示容器映射端口&#xA;    run                             # 容器中执行命令&#xA;    exec&#xA;&#xA;    config                          # 查看配置&#xA;    build                           # (重)构建容器&#xA;    pull                            # 拉依赖镜像&#xA;    push                            # 推送镜像&#xA;配置&#xA;    version: &#39;3&#39;&#xA;    services:&#xA;      dokuwiki:&#xA;        restart: always&#xA;        image: bitnami/dokuwiki:latest&#xA;        ports:&#xA;          - 8004:80&#xA;        environment:&#xA;          - DOKUWIKI_FULL_NAME=outrun&#xA;          - DOKUWIKI_EMAIL=934260428@qq.com&#xA;          - DOKUWIKI_WIKI_NAME=Wiki&#xA;          - DOKUWIKI_USERNAME=outrun&#xA;          - DOKUWIKI_PASSWORD=asdfasdf&#xA;        volumes:&#xA;          - ./data:/bitnami                                         # 本地:镜像&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;仓库&#34;&gt;&#xA;  仓库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%93%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;habor&#34;&gt;&#xA;  habor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#habor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;registry&#34;&gt;&#xA;  registry&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#registry&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;htpasswd  -Bbn outrun asdf &amp;gt; auth/htpasswd&#xA;&#xA;客户端使用&#xA;    /etc/docker/daemon.json&#xA;        {&amp;quot;insecure-registries&amp;quot;:[&amp;quot;127.0.0.1:5000&amp;quot;]}&#xA;    sudo systemctl daemon-reload&#xA;    sudo systemctl restart docker&#xA;&#xA;    docker login 127.0.0.1:5000&#xA;&#xA;    docker tag java/device:1.0 127.0.0.1:5000/java/device:1.0&#xA;    docker push 127.0.0.1:5000/java/device:1.0&#xA;    curl --user outrun:asdf 127.0.0.1:5000/v2/_catalog&#xA;        # v2表示版本 registry:2&#xA;    docker pull 127.0.0.1:5000/java/device:1.0&#xA;常用API&#xA;    curl --user outrun:asdf -X GET  registry:5000/v2/_catalog&#xA;        # 列表&#xA;    curl --user outrun:asdf -X GET  registry:5000/v2/ubuntu/tags/list&#xA;        # tags&#xA;    curl --user outrun:asdf -X GET  registry:5000/v2/ubuntu/manifests/latest&#xA;        # tag&#xA;    curl --user outrun:asdf -X GET -v --silent -H &amp;quot;Accept: application/vnd.docker.distribution.manifest.v2+json&amp;quot; registry:5000/v2/ubuntu/manifests/latest 2&amp;gt;&amp;amp;1 | grep Docker-Content-Digest | awk &#39;{print ($3)}&#39;&#xA;        # digest&#xA;    curl --user outrun:asdf -X DELETE -v --silent -H &amp;quot;Accept: application/vnd.docker.distribution.manifest.v2+json&amp;quot; registry:5000/v2/ubuntu/manifests/sha256:134c7fe821b9d359490cd009ce7ca322453f4f2d018623f849e580a89a685e5d&#xA;        # 删除&#xA;    docker exec -it 4ebff4cdc646 /bin/registry garbage-collect  /etc/docker/registry/config.yml&#xA;        # 删除后, 运行垃圾回收&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;查容器pid&#xA;    docker container top ea1&#xA;    docker inspect -f &#39;{{.State.Pid}}&#39; ea1&#xA;批量删除镜像&#xA;    docker rmi $(docker image ls -a |grep jncloud |awk &#39;{print $3}&#39;)&#xA;进入容器&#xA;    docker exec -it mysql bash&#xA;制作镜像并运行&#xA;    make&#xA;    docker build -t search:v1 .&#xA;    docker images&#xA;    docker run -p 50088:80 -d search:v1&#xA;    docker ps -a&#xA;    docker logs ea1&#xA;    docker rmi bc8&#xA;提交镜像到官方&#xA;    docker -ps -a&#xA;    docker login&#xA;    docker commit d79 outrun11/node_pm2&#xA;        # 把容器提交为镜像&#xA;    docker images node_pm2&#xA;    docker push outrun11/node_pm2&#xA;代理&#xA;    /etc/systemd/system/docker.service.d/http-proxy.conf            # 没有时创建&#xA;        Environment=&amp;quot;HTTP_PROXY=http://127.0.0.1:8123&amp;quot;&#xA;            &amp;quot;HTTPS_PROXY=http://127.0.0.1:8123&amp;quot;&#xA;            &amp;quot;NO_PROXY=192.168.1.1,localhost&amp;quot;&#xA;    systemctl daemon-reload&#xA;换源&#xA;    /etc/docker/daemon.json                                         # 没有时创建&#xA;        {&#xA;          &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://nmp74w3y.mirror.aliyuncs.com&amp;quot;]&#xA;        }&#xA;    systemctl daemon-reload&#xA;    systemctl restart docker&#xA;登录运行容器&#xA;    docker exec -it --user root 8ce /bin/sh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;harbor&#xA;    企业级register镜像服务器&#xA;pipwork&#xA;    shell写的docker网格配置工具&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Kubernetes</title>
      <link>https://runout.run/docs/tool/ops/k8s/</link>
      <pubDate>Thu, 11 Oct 2018 18:18:21 +0800</pubDate>
      <guid>https://runout.run/docs/tool/ops/k8s/</guid>
      <description>&lt;h1 id=&#34;常用&#34;&gt;&#xA;  常用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;查看&#34;&gt;&#xA;  查看&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e7%9c%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;系统日志&#xA;    journalctl -u kubelet | tail&#xA;    kubectl api-resources --verbs=list --namespaced -o name   | xargs -n 1 kubectl get --show-kind --ignore-not-found -nmdw&#xA;日志&#xA;    kubectl logs -f --since=5m --all-containers=true -lapp=[svcName] -o wide&#xA;    kubectl get pod [podName] -o yaml&#xA;    kubectl get pods -nmdw-log -l app=logstash-logstash -w    # 等待启动&#xA;    kubectl describe pods [podName]&#xA;    kubectl rollout status deploy/[deployName]          # 查升级记录&#xA;    kubectl get events -njnc&#xA;        -oyaml&#xA;        --field-selector=type=Normal            # Normal, Warning&#xA;查ns所有资源&#xA;    kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -nairflow&#xA;查节点详情&#xA;    kubectl get nodes -o json&#xA;查扩缩状态&#xA;    kubectl rollout status deploy/[deployName]&#xA;查所有nodeport&#xA;    kubectl get svc --all-namespaces -o go-template=&#39;{{range .items}}{{range.spec.ports}}{{if .nodePort}}{{.nodePort}}{{&amp;quot;\n&amp;quot;}}{{end}}{{end}}{{end}}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;操作&#34;&gt;&#xA;  操作&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;进容器&#xA;    kubectl exec -it [podName]  -- /bin/bash&#xA;    kubectl attach [podName]            # 进入主进程IO&#xA;用busybox运行命令&#xA;    kubectl run -it --image busybox -n [nameSpace] [name] --restart=Never --rm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;监控&#34;&gt;&#xA;  监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;kubectl top node -l app=app1&#xA;kubectl top pod -nmdw --containers&#xA;kubectl describe PodMetrics p1 -njnc-dev&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;编辑&#34;&gt;&#xA;  编辑&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%be%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;kubectl apply -f a.yml&#xA;envsubst &amp;lt; jnc.yml |kubectl apply -f -&#xA;kubectl label ns jnc istio-injection=enabled --overwrite&#xA;kubectl label ns jnc istio-injection-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;亲和性&#34;&gt;&#xA;  亲和性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%b2%e5%92%8c%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;kubectl get nodes --show-labels&#xA;kubectl label nodes node1 deploy=mdw&#xA;kubectl taint nodes node1 key=value:NoSchedule                      # NoSchedule、PreferNoSchedule、NoExecute&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;调试&#34;&gt;&#xA;  调试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b0%83%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;kubectl proxy --port=8080 &amp;amp;&#xA;    # 以非https形式暴露api&#xA;kubectl debug a1 -it --image=yauritux/busybox-curl --share-processes --copy-to=a1-debug&#xA;    # 嫁接&#xA;kubectl run -it --rm test --image=a:0.1.0 --command -- /bin/bash&#xA;    # 改镜像命令&#xA;kubectl run -it --rm  busybox1 --image=yauritux/busybox-curl -- /bin/bash&#xA;    # 同环境busybox&#xA;kubectl cp dir1 ns1/po1:/dir1 -c c1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;清理&#34;&gt;&#xA;  清理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b8%85%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;删除Evicted/OutOfmemory pod&#xA;    kubectl get po -njnc-dev | grep OutOfmemory |awk &#39;{print$1}&#39; | tr &#39;\n&#39; &#39;&#39; | xargs kubectl delete pod -njnc-dev&#xA;强制删除pod&#xA;    kubectl delete po -nmdw --force --grace-period=0&#xA;删除pv/pvc&#xA;    kubectl patch pv mdw-mysql-data -p &#39;{&amp;quot;metadata&amp;quot;:{&amp;quot;finalizers&amp;quot;:null}}&#39;&#xA;重建pv&#xA;    kubectl get pvc p1 -o yaml &amp;gt; a.yml&#xA;    编辑a.yml&#xA;    kubectl apply -f a.yml&#xA;删除node&#xA;    kubectl drain node1&#xA;维护node不可调度与恢复&#xA;    kubectl cordon node1&#xA;    kubectl uncordon node1&#xA;强制删除ns&#xA;    kubectl get ns n1 -o json &amp;gt;tmp.json&#xA;    删除finalizers列表&#xA;    kubectl proxy&#xA;    curl -k -H &amp;quot;Content-Type: application/json&amp;quot; -X PUT --data-binary @tmp.json http://127.0.0.1:8001/api/v1/namespaces/n1/finalize&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;操作-1&#34;&gt;&#xA;  操作&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%93%8d%e4%bd%9c-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;升级镜像&#xA;    kubectl set image deploy/[deployName] [imageName]=[imageName:Version]&#xA;    kubectl edit deploy/[deployName]&#xA;扩容&#xA;    kubectl scale deployment [deployName] --replicas=3&#xA;    kubectl patch deployment [deployName] -p &#39;{&amp;quot;spec&amp;quot;:{&amp;quot;replicas&amp;quot;:3}}&#39;&#xA;重启&#xA;    kubectl rollout restart deploy xxx&#xA;回滚&#xA;    kubectl rollout undo deploy xxx&#xA;打污点&#xA;    kubectl taint nodes node1 key1=a:NoExecute&#xA;        # 添加&#xA;    kubectl taint nodes --all key1-&#xA;        # 删除&#xA;打标签&#xA;    kubectl label nodes node1 a=b&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;容器配置&#34;&gt;&#xA;  容器配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%b9%e5%99%a8%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;HTTPS&#xA;    openssl req -x509 -newkey rsa:4096 -sha256 -nodes -keyout tls.key -out tls.crt -subj &amp;quot;/CN=my-domain.com&amp;quot;&#xA;    kubectl create secret tls my-domain-com-tls --cert=tls.crt --key=tls.key --namespace=allure-docker-service&#xA;    ingress.yml&#xA;        spec:&#xA;            tls:&#xA;            - secretName: my-domain-com-tls&#xA;              hosts:&#xA;                - my-domain.com&#xA;              &#xA;部署.docker/config.json成secret&#xA;    kubectl create secret generic regcred --from-file=.dockerconfigjson=&amp;lt;path/to/.docker/config.json&amp;gt; --type=kubernetes.io/dockerconfigjson&#xA;配置私有仓库&#xA;    kubectl delete secret local&#xA;    kubectl -n iot create secret docker-registry local1 \&#xA;    --docker-server=192.168.99.1:5000 \&#xA;    --docker-username=outrun \&#xA;    --docker-password=asdf \&#xA;    --docker-email=934260428@qq.com&#xA;连阿里云k8s&#xA;    kubectl config set-cluster mrs --server=https://106.14.49.217:6443 --certificate-authority=/home/outrun/scripts/work/mrs-k8s/crt --embed-certs=true&#xA;    kubectl config set-context 297351062922226746-cdf45d630b2284f8ab79bea186c161d9f --cluster=mrs --user=297351062922226746 --namespace=lora-app&#xA;    kubectl config use-context 297351062922226746-cdf45d630b2284f8ab79bea186c161d9f&#xA;    kubectl config set-credentials 297351062922226746  --user=297351062922226746 --client-key=/home/outrun/scripts/work/mrs-k8s/297351062922226746.key.pem --client-certificate=/home/outrun/scripts/work/mrs-k8s/297351062922226746.crt --embed-certs=true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;集群配置&#34;&gt;&#xA;  集群配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e7%be%a4%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;设置当前集群namespace&#xA;    kubectl config set-context $(kubectl config current-context) --namespace=default&#xA;配置DNS解析&#xA;    kubectl edit configmap coredns -n kube-system&#xA;        apiVersion: v1&#xA;        data:&#xA;        Corefile: |&#xA;            .:53 {&#xA;                errors&#xA;                hosts {&#xA;                    192.168.1.107 a.b.com&#xA;                }&#xA;            }&#xA;    kubectl rollout restart deploy coredns -n kube-system&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;文件目录&#34;&gt;&#xA;  文件目录&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;/etc/kubernetes&#xA;/etc/resolve.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;kubeadm&#34;&gt;&#xA;  kubeadm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kubeadm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;kubeadm init&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;kubectl&#34;&gt;&#xA;  kubectl&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kubectl&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局参数&#xA;    --help                  # -h&#xA;    --output=&amp;quot;jsonpath={.data.\.dockerconfigjson}&amp;quot;&#xA;    --output=yaml&#xA;    --context=iot&#xA;    --namespace=iot &#xA;    --all-namespaces=true&#xA;    -n [namespace] &#xA;    --all                           # 如匹配所有deploy文件&#xA;Other Commands&#xA;    api-resources           # 查所有resource&#xA;        namespace/ns&#xA;        endpoints/ep&#xA;        nodes/no&#xA;        configmap/cm  &#xA;        replicationcontrollers/rc&#xA;        deployments/deploy&#xA;        statefulsets/sts&#xA;        service/svc &#xA;        ingresses/ing&#xA;        persistentvolumes/pv&#xA;        persistentvolumeclaims/pvc&#xA;        storageclasses/sc&#xA;        pods/po&#xA;        cronjobs/cj&#xA;        daemonset/ds                    # 每个node运行一个&#xA;        certificatesigningrequests/csr  # csr证书&#xA;    api-versions            # 所有可用的apiVersion&#xA;    config                  # 设置集群&#xA;        config set current-context c1&#xA;    plugin                  # 设置插件&#xA;    version&#xA;Basic Commands:&#xA;    create&#xA;        -f y1.yml&#xA;    expose                          # 修改端口&#xA;        expose deployment/[deployName]&#xA;        --target-port=8080 &#xA;        --type=NodePort&#xA;    run   &#xA;        run [deployName] &#xA;        --image=gcr.io/google-samples/hello-app:1.0&#xA;        --port=8080&#xA;    set                             # 更新配置&#xA;        set image deploy/[deployName] *=image1:1.1&#xA;            # 所有镜像更新为image1:1.1&#xA;    explain                         # 查resource文档&#xA;        pv&#xA;    get&#xA;        -o                          # 格式&#xA;            yaml&#xA;            wide&#xA;            jsonpath=&#39;{.items[0].metadata.name}&#39;&#xA;        -l app=a1                   # select label&#xA;        -c gateway&#xA;        --show-labels&#xA;        --selector app=a1&#xA;        --all-containers=true&#xA;    edit                            # 修改配置&#xA;        edit ingress ingress1&#xA;    delete &#xA;        --force  &#xA;        --grace-period=0&#xA;Deploy Commands:&#xA;    rollout&#xA;        history deploy/deploy1&#xA;        pause deploy/deploy1&#xA;        restart&#xA;        resume deploy/deploy1&#xA;        status &#xA;        undo deploy/deploy1         # 回滚到上一版本&#xA;    scale&#xA;        scale deploy/deploy1&#xA;            --replicas=1&#xA;    autoscale&#xA;        autoscale deploy/deploy1&#xA;            --min=1&#xA;            --max=3&#xA;            --cpu-percent=80&#xA;Cluster Management Commands:&#xA;    certificate&#xA;        approve [csrName]           # 手动签发证书，/etc/kubernetes/ssl/*&#xA;        deny&#xA;    cluster-info                    # 集群信息 &#xA;        dump&#xA;    top                             # cpu 内存负载&#xA;        node&#xA;        pod&#xA;    cordon [nodeName]               # node不可调度&#xA;    uncordon                        # node可调度&#xA;    drain [nodeName]                # 移除node&#xA;    taint                           # node污点&#xA;        taint nodes node1 key1=val1:NoSchedule&#xA;Troubleshooting and Debugging Commands:&#xA;    describe     &#xA;    logs&#xA;    attach                          # 当前终端成为entrypoint&#xA;    exec         &#xA;        -it device-7b8965d85d-xz4qm bash&#xA;        -it device-7b8965d85d-xz4qm --container device -- /bin/bash&#xA;    port-forward                    # 端口映射&#xA;        port-forward [podName] 本地端口:pod端口&#xA;    proxy                           # 映射ApiServer到本地端口&#xA;        --port=8080&#xA;    cp                              # copy容器文件&#xA;        cp [namespaceName]/[podName]:[filePath] .&#xA;    auth         &#xA;        can-i list pods             # judge权限&#xA;        reconcile -f rbac.yaml      # 应用权限配置&#xA;            --dry-run               # 仅测试，列出变更&#xA;            --remove-extra-subjects         # 删除除外subject&#xA;            --remove-extra-permissions      # 删除除外权限&#xA;    debug                           # pod调试模式, alpha版功能，需要--feature-gates=&amp;quot;EphemeralContainers=true&amp;quot;&#xA;        -it pod1 &#xA;        --image=image1              # 排错工具镜像&#xA;        --share-processes           # 共享进程&#xA;        --copy-to=pod1-debug&#xA;Advanced Commands:&#xA;    diff      &#xA;        diff -f a.yml               # dry run 找出将实行的变更&#xA;    apply           # 升级&#xA;        -f y1.yml&#xA;        -k overlays/&#xA;    patch                           # 更新属性&#xA;        patch deploy/deploy1&#xA;        -p &#39;{&amp;quot;spec&amp;quot;:{&amp;quot;unschedulable&amp;quot;:true}}&#39;&#xA;    replace                         # 替换resource&#xA;        replace -f a.yml&#xA;    wait                            # 等待直到满足条件&#xA;        -f a.yml&#xA;        --for=condition=Available&#xA;        --timeout=1h&#xA;    kustomize                       # 多环境部署的overlays补丁&#xA;        kustomize [dir with kustomization.yml]&#xA;Settings Commands:&#xA;    label&#xA;        label pods/pod1 a=b&#xA;        --overwrite                 # 覆盖更新&#xA;        --resource-version=1        # 匹配没修改过的情况&#xA;    annotate&#xA;        annotate pods/pod1 a=&#39;b&#39;&#xA;        --overwrite&#xA;    completion                      # 生成终端命令补全配置&#xA;        completion bash &amp;gt; /etc/bash_completion.d/kubectl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;helm&#34;&gt;&#xA;  Helm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#helm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;目录&#xA;    charts/&#xA;    Chart.yaml&#xA;        apiVersion: v1&#xA;        appVersion: &amp;quot;1.0&amp;quot;&#xA;        description: A Helm chart for Kubernetes&#xA;        name: nginx-test&#xA;        version: 0.1.0&#xA;    requirements.yaml&#xA;    requirements.lock&#xA;    values.yaml&#xA;        replicaCount: 1&#xA;    templates/&#xA;        _helpers.tpl&#xA;        deployment.yaml&#xA;    &#xA;helm命令&#xA;    查看&#xA;        ls/list&#xA;            --all-namespaces&#xA;        get values a1                   # 查看已部署的values变更&#xA;        history  a1                     # 查看历史版本&#xA;        get manifest a1                 # 查看已安装模板&#xA;        template                        # 查看编译后内容&#xA;            --debug&#xA;        search repo a1 &#xA;            --versions&#xA;    安装&#xA;        repo&#xA;            update&#xA;        install [deployName] [packageName|packageFile|packagePath] &#xA;            -f values.yaml&#xA;            --values=values.yaml&#xA;            --set a=b&#xA;        upgrade                         # 热更新部署文件&#xA;            --debug --dry-run           # 只输出编译结果&#xA;            -i                          # 没有时执行install&#xA;            --disable-openapi-validation&#xA;        uninstall&#xA;    插件&#xA;        plugin&#xA;            install --version master https://gitee.com/mirrors_sonatype-nexus-community/helm-nexus-push.git&#xA;            ls&#xA;    运维&#xA;        rollback a1 1                   # 回滚到1版本&#xA;    打包&#xA;        create a1&#xA;        lint --strict a1                # 校验&#xA;        package a1                      # 打包成a1-0.1.0.tgz&#xA;&#xA;相关命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;minikube&#34;&gt;&#xA;  minikube&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#minikube&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker login --username=934260428@qq.com registry.cn-hangzhou.aliyuncs.com&#xA;命令&#xA;    minikube&#xA;        start --vm-driver=virtualbox \&#xA;            --memory=4096 \&#xA;            --cpus=2 \&#xA;            --log_dir=/home/outrun/logs \&#xA;            --insecure-registry=192.168.99.1:5000 \&#xA;            --insecure-registry=registry.cn-qingdao.aliyuncs.com \&#xA;            --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers&#xA;&#xA;            --kubernetes-version v1.17.0&#xA;            --docker-env=HTTP_PROXY=$HTTP_PROXY \&#xA;            --docker-env=HTTPS_PROXY=$HTTPS_PROXY \&#xA;            --docker-env=NO_PROXY=$NO_PROXY \&#xA;            --image-mirror-country=cn \&#xA;            --registry-mirror=https://registry.docker-cn.com \&#xA;            --extra-config=kubelet.MaxPods=5.&#xA;                # registry一定是minikube容器ip, 可用ifconfig查看&#xA;                # --insecure-registry修改需要minikube delete&#xA;        stop&#xA;        delete&#xA;        status &#xA;        docker-env&#xA;        ip      # 得到单机集群ip&#xA;        service  -n iot mosquitto --url&#xA;            # 得到service的nodePort&#xA;&#xA;        ssh&#xA;        dashboard&#xA;        addons&#xA;            list&#xA;            enable heapster&#xA;            enable ingress&#xA;服务&#xA;    kube-system&#xA;        coredns&#xA;        etcd-minikube&#xA;        kube-addon-manager-minikube&#xA;        kube-proxy&#xA;        kube-scheduler-minikube&#xA;        nginx-ingress-controller&#xA;        storage-provisioner&#xA;    kubernetes-dashboard&#xA;        dashboard-metrics-scraper&#xA;        kubernetes-dashboard&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;平台&#34;&gt;&#xA;  平台&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b3%e5%8f%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;HPE Container Platform&#xA;OpenShift&#xA;VMware VSphere&#xA;Minikube&#xA;Rancher&#xA;KubeSphere&#xA;Google Cloud Platform(GCP)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Mongodb</title>
      <link>https://runout.run/docs/db/mongodb/</link>
      <pubDate>Thu, 11 Oct 2018 16:00:15 +0800</pubDate>
      <guid>https://runout.run/docs/db/mongodb/</guid>
      <description>&lt;h1 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    数据结构json(bson)&#xA;    易写入，易修改&#xA;    c++编写&#xA;    分布式&#xA;    介于关系数据库 和 非关系数据库之间&#xA;    查询语句强&#xA;    支持索引&#xA;    bson格式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;注意&#34;&gt;&#xA;  注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    document不能大于4Mb&#xA;    可以非安全模式异步马上成功&#xA;    每个连接用队列存储命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据结构定义&#34;&gt;&#xA;  数据结构定义&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    collection                                        # 表&#xA;            document                                # 记录&#xA;                    field(key, value)                # 字段(field)与值(value)&#xA;    与关系型数据库的区别&#xA;            document中的field不要key俱全或一样&#xA;            find()命令查询&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;bson的数据类型&#34;&gt;&#xA;  bson的数据类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bson%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    ＃bson 是json的扩展&#xA;     # 增加了数据类型&#xA;     # 把json数据转换成二进制码存到文件&#xA;    null&#xA;    boolean&#xA;    undefined&#xA;    数组                                # 如{gps: [20, 56]}&#xA;    32位和64位整数                # shell中不支持&#xA;                                    ## node.js python java等高级语言的驱动中支持&#xA;    64位浮点                        # shell使用的全是这种类型, 如{x:3.14}&#xA;    utf-8                                # 字符串类型&#xA;    ObjectID&#xA;    Date                                # 如{x:new Date()}&#xA;    正则                                # 如{x:/uspcat/i}&#xA;    javascript块代码                # 如{x:function(){}}&#xA;                                    ## 相当于存储过程&#xA;    内嵌文档                        # 如{x: {xx: &amp;quot;a&amp;quot;}}&#xA;    二进制                                # shell中不能使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;objectid&#34;&gt;&#xA;  ObjectId&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#objectid&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    大小&#xA;            12字节&#xA;            显示为24个十六进制字符&#xA;            # 空间换时间的思想&#xA;    细节&#xA;            前4字节是unix时间戳&#xA;            后3字节集群machine hash&#xA;            后2字节pid&#xA;            后3字节inc自增计数器, 在前面都相等时全局自增&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命名&#34;&gt;&#xA;  命名&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e5%90%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    数据库与集合名&#xA;            不能是空字符串&#xA;            特殊字符&#xA;                    &#39; (空格) , $ / \ \0&#xA;            应该全小写&#xA;            小于64字节&#xA;            数据库名不与保留库名相同，如&#xA;                    admin, local, config&#xA;    集合名&#xA;            db-text合法，但不能db.db-text得到，要db.getCollection(&amp;quot;db-text&amp;quot;).text得到&#xA;                    # db-text 会认为是减法&#xA;                    ## 数据库名可以是db-text&#xA;            可以a.b来命名来划分子集合&#xA;                    不能以system.开头命名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;collection&#xA;        增&#xA;                save&#xA;                        # 不存在时插入，存在时更新&#xA;                        # {$ref: &#39;user&#39;, $id: 1} 来保存引用&#xA;                insert&#xA;        删&#xA;                remove(&#39;id&#39;: &#39;bar&#39;)        # 删除一条数据&#xA;                                                                        #remove()删除所有数据&#xA;                drop()                                # 删除persons collection, 不释放文件空间&#xA;                dropIndexes()                        # 删除所有索引&#xA;        改&#xA;                update(finder, updater, options或upser, multi)&#xA;                        # $set&#xA;                        # {age: {$gt: 18}, $isolated : 1} $isolated事务隔离该字段到本语句执行结束, does not work with sharded clusters&#xA;                findAndModify&#xA;        查&#xA;                findOne()&#xA;                find(finder, filter)&#xA;                        # limit(3).skip(10).sort({name: -1, age: 1})&#xA;                        ## sort({$natural: 1}) 固定集合排序&#xA;                        # explain() 返回带统计信息的文档&#xA;                        ## 是否用到索引，耗时，需要扫描多少文件&#xA;                        # hint({}) 强制使用某索引查询&#xA;                        # null可以匹配null, 也可以匹配{$exists: false}        &#xA;                        # 正则可以匹配自身，也可以模式字符串&#xA;                count()                                # document的条数&#xA;                aggregate&#xA;&#xA;db&#xA;        # 默认存在的数据库admin, config, local&#xA;        sources&#xA;                # 从节点中设置的源collection&#xA;        help()&#xA;        persons.help()&#xA;                # 显示某集合的帮助&#xA;        auth(&#39;username&#39;, &#39;pwd&#39;)&#xA;                # 切换用户&#xA;        addUser()&#xA;                # addUser(&#39;admin&#39;, &#39;asdf&#39;)&#xA;                # addUser(&#39;readonly&#39;, &#39;asdf&#39;, true)&#xA;        listCommands()&#xA;        shutdownServer()&#xA;        eval()&#xA;                # 执行&#xA;        stats()                                        &#xA;                # 当前数据库的状态&#xA;                ## 包括名称，collection数，索引数等&#xA;        createCollection()&#xA;                # {&#39;user&#39;, {capped: true, size: 100, max: 10}} &#xA;                ## 创建固定集合, 100字节, 文档数上限为10&#xA;                ## 固定集合插入快，不能删除，无_id, 有尾部游标&#xA;        getCollection(&amp;quot;persons&amp;quot;).text&#xA;                # 同db.persons        &#xA;        dropDatabase()&#xA;                # 删除当前数据库        &#xA;        repairDatabase()&#xA;                # 释放空间&#xA;        serverStatus()&#xA;                # 返回数据库的metrics 数据&#xA;        serverStatus().metrics.cursor&#xA;                # 返回指针信息&#xA;        ensureIndex({x: 1, y: -1}, {name: &#39;xy&#39;})&#xA;                # 建立x的升序, y的降序联合索引&#xA;                # 只使用索引的前部, 即对x的查询可以用该索引&#xA;                # {&amp;quot;gps&amp;quot;: &#39;2d&#39;} {&#39;gps&#39;: &#39;2dsphere&#39;}&#xA;                ## 支持gps写成 [0, 0] {x: 0, y: 0} {latitude: 0, longitude: 0} 格式&#xA;                # 可以索引内嵌文档&#xA;                # {unique: true} 来建立唯一索引&#xA;                # {dropDups: true} 将唯一索引中重复的文档都删掉&#xA;        dropIndexes&#xA;        system&#xA;                indexes&#xA;                        # 保留集合，索引&#xA;                namespaces&#xA;                        # 也包含索引信息&#xA;                js&#xA;                        insert({_id: &#39;fn&#39;, value: function() {}})&#xA;                                # 用db.eval(&#39;fn()&#39;) 执行&#xA;        runCommand()&#xA;                # {&#39;dropIndexes&#39;: &#39;col&#39;, &#39;index&#39;: &#39;ind&#39;}&#xA;                # 可以返回命名执行的状态信息&#xA;                {buildInfo: 1}&#xA;                {collStats: &#39;user&#39;}&#xA;                {distinct: &#39;user&#39;, key: a, query: {b: 0}}&#xA;                {drop: &#39;user&#39;}&#xA;                {dropDatabase: 1}&#xA;                {dropIndexes: &#39;user&#39;, index: &#39;ind&#39;}&#xA;                {getLastError: 1}&#xA;                        # 上次更新的作用信息&#xA;                        {getLastError: 1, w: 3}&#xA;                                # 阻塞复制，有3个节点&#xA;                {isMaster: 1}&#xA;                {findAndModify: &#39;user&#39;, query: {a: 0}, sort: {a: 1}, update: {$set: {a: 1}}}&#xA;                {listCommands: 1}&#xA;                {listDatabases: 1}&#xA;                {ping: 1}&#xA;                {renameCollection: &#39;user&#39;, to: &#39;user1&#39;}&#xA;                {repairDatabase: 1}&#xA;                        # 修复并压缩当前数据库&#xA;                {serverStatus: 1}&#xA;                        # globalLock: 全局写入锁占用了多少时间&#xA;                        # mem: 内存映射了多少数据&#xA;                        # indexCounters: B树磁盘检索(misses)和内存检索(hits)的次数&#xA;                        # backgroundFluhing: 后台做了多少次fsync及用的时间&#xA;                        # opcounters: 每种主要操作的次数&#xA;                        # asserts: 断言的次数&#xA;                {convertToCapped: &#39;user&#39;, size: 100}&#xA;                        # 转为固定集合&#xA;                {fsync: 1, lock: 1}&#xA;                        # 缓冲写入磁盘，并加写入锁。后可以直接复制磁盘数据来备份&#xA;                        # db.$cmd.sys.unlock.findOne() 解锁&#xA;                        # db.currentOp() 查看为空时已解锁&#xA;                {resync: 1}&#xA;                        # 从节点重新同步&#xA;                {collMod: &#39;users&#39;, usePowerOf2Sizes: true}&#xA;                        # 每次增大空间总是2的倍数，适用于常写的集合&#xA;rs&#xA;        isMaster&#xA;        slaveOk&#xA;dcl&#xA;        help                                        # 显示帮助&#xA;        show dbs                                # 显示所有数据库&#xA;        use mydb                                # 选择数据库(默认为test)&#xA;                                                ## 如果没有该数据库，则创建(插入第一条数据时实际创建)&#xA;        db                                        # 显示当前数据库名&#xA;        show collections                        # 查看当前数据库的collections&#xA;        db.eval()                                # 执行shell语法字符串&#xA;&#xA;        用户管理命令&#xA;                use test                                # 选择需要添加用户的数据库&#xA;                db.addUser(&#39;name&#39;,&#39;pwd&#39;)                # 第三个参数代表是否只读 true代表是 ,  false代表否&#xA;                                                        ## db 代表本数据库，也就是test&#xA;                db.system.users.find()                        # 查看用户列表&#xA;                db.auth(&#39;name&#39;,&#39;pwd&#39;)                # 用户认证，反回１代表认证成功&#xA;                db.removeUser(&#39;name&#39;)&#xA;                show users                                # 查看所有用户&#xA;&#xA;                        # 注&#xA;                                权限生效需要mongod　以　-auth参数启动&#xA;                                admin数据库中的user是超级管理员 , 其他数据库中的user只限于本数据库&#xA;&#xA;ttl(time to live)&#xA;        # mongodb每1分钟检查一次数据删除&#xA;        db.log_events.ensureIndex({&amp;quot;createdAt&amp;quot;: 1}, {expireAfterSeconds: 3600 })&#xA;        db.log_events.insert({&#xA;                &amp;quot;createdAt&amp;quot;: new Date(),&#xA;                &amp;quot;logEvent&amp;quot;: 2,&#xA;                &amp;quot;logMessage&amp;quot;: &amp;quot;Success!&amp;quot;&#xA;        })&#xA;                # 插入的这条数据在1小时后删除&#xA;        db.log_events.ensureIndex({&amp;quot;expireAt&amp;quot;: 1}, {expireAfterSeconds: 0})        &#xA;        db.log_events.insert({&#xA;                &amp;quot;expireAt&amp;quot;: new Date(&#39;July 22, 2013 14:00:00&#39;),&#xA;                &amp;quot;logEvent&amp;quot;: 2,&#xA;                &amp;quot;logMessage&amp;quot;: &amp;quot;Success!&amp;quot;&#xA;        })&#xA;                # 插入的这条数据在July 22, 2013 14:00:00删除&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;aggregate&#34;&gt;&#xA;  aggregate&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aggregate&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;mapReduce(&#xA;        function() {emit(this.cust_id, this.amount);},&#xA;                # map&#xA;        function(key, values) {return Array.sum(values)},&#xA;                # reduce&#xA;        {&#xA;                query: {status: &#39;A&#39;},&#xA;                        # query&#xA;                out: &#39;order_totals&#39;&#xA;                        # output&#xA;        } &#xA;)&#xA;&#xA;distinct()&#xA;&#xA;count()&#xA;&#xA;group({&#xA;        key: {a: 1},&#xA;                # $keyf: function(x) {return x.category} 定义分组函数&#xA;        cond: {a: {$lt: 3}}.&#xA;        $reduce: function(cur, result) {result.count += cur.count},&#xA;        initial: {count: 0},&#xA;        finalize: function (prev) {}&#xA;})&#xA;        # 返回的文档 {retval: [], count: 0, keys: 0, ok: 0}&#xA;aggregate([&#xA;        {$redact: {$cond: {&#xA;                if: {$eq: [&#39;$level&#39;, 5]},&#xA;                then: &#39;$$PRUNE&#39;,&#xA;                else: &#39;$$DESCEND&#39;&#xA;        }}}&#xA;        {$match: {status: &#39;A&#39;}},&#xA;        {$geoNear: {...}},&#xA;        {$project: {name: {$toUpper: &#39;$_id&#39;}, _id: 0}},&#xA;        {$unwind: &#39;$sizes&#39;},&#xA;        {$group: {_id: &#39;$state&#39;, totalPop: {$sum: &#39;$pop&#39;}}},&#xA;        {$skip: 10},&#xA;        {$limit: 5},&#xA;        {$sort: {age: -1}},&#xA;        {$out: &#39;authors&#39;}&#xA;])&#xA;&#xA;例子&#xA;    o-&amp;gt; 得到tags数组的长度&#xA;    db.users.aggregate([{&#xA;            $group: {&#xA;                    _id: &#39;$username&#39;,&#xA;                    tags_count: {$first: {$size: &#39;$tags&#39;}}&#xA;            }&#xA;    }])&#xA;    db.users.aggregate([{&#xA;            $project: {&#xA;                    tags_count: {$size: &#39;$tags&#39;}&#xA;            }&#xA;    }])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;expressions&#34;&gt;&#xA;  expressions&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#expressions&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;$and&#xA;$or&#xA;$not&#xA;$setEquals&#xA;$setIntersection&#xA;$setUnion&#xA;$setDefference&#xA;$setIsSubset&#xA;$anyElementTrue&#xA;$allElementsTrue&#xA;$cmp&#xA;$eq&#xA;$gt&#xA;$gte&#xA;$lt&#xA;$lte&#xA;$ne&#xA;$add&#xA;$subtract&#xA;$multiply&#xA;$divide&#xA;$mod&#xA;$concat&#xA;$substr&#xA;$toLower&#xA;$toUpper&#xA;$strcasecmp&#xA;$meta&#xA;$size&#xA;$map&#xA;$let&#xA;$literal&#xA;$dayOfYear&#xA;$dayOfMonth&#xA;$dayOfWeek&#xA;$year&#xA;$month&#xA;$week&#xA;$hour&#xA;$minute&#xA;$second&#xA;$millisecond&#xA;$dateToString&#xA;$cond&#xA;$ifNull&#xA;$sum&#xA;$avg&#xA;$first&#xA;$last&#xA;$max&#xA;$min&#xA;$push&#xA;$addToSet&#xA;$near&#xA;$within&#xA;$box&#xA;$center&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局函数&#xA;        printjson&#xA;        connect(&#39;localhost:27017/mydb&#39;)&#xA;                # 连接另一个服务器&#xA;        runProgram&#xA;对象类型&#xA;        cursor&#xA;                hasNext()&#xA;                        # 立即返回前100个数据与4Mb数据的较小者。取数据时直接读缓存&#xA;                next()&#xA;                forEach&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;复制&#34;&gt;&#xA;  复制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%8d%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;复制&#xA;        mongod --master --oplogSize 100&#xA;        mongod --slave --source localhost:27017&#xA;                # --source指定主节点&#xA;                # --only 指定只复制特定的数据库&#xA;                # --slavedelay 主从复制时的延时&#xA;                # --fastsync 从节点是主节点快照时，加这个选项，同步速度快&#xA;                # --autoresync 重新同步&#xA;                # --oplogSize 主节点oplog的大小&#xA;        db.sources.insert({host: &#39;localhost:27017&#39;})&#xA;                # 从节点设置主节点&#xA;&#xA;副本集&#xA;        #  没有主节点，集群自己选举主节点&#xA;        # 数据太多从节点会自动停止同步&#xA;        mongod --dbpath &#39;/var/local/mongo1&#39; --port 27017 --replSet rs0&#xA;                # 三个实例replSet 名必叫 rs0&#xA;        use admin&#xA;        rs.initiate({&#xA;                _id: &#39;a&#39;,&#xA;                members: [{&#xA;                        _id: 1,&#xA;                        host: &#39;localhost1:27017&#39;&#xA;                }, {&#xA;                        _id: 2,&#xA;                        host: &#39;localhost1:27018&#39;&#xA;                }]&#xA;        })&#xA;                # 其中一台执行初始化&#xA;        rs.add(&#39;localhost:27019&#39;)&#xA;        rs.status()&#xA;        db.getMongo().setSlaveOk()&#xA;        rs.isMaster()&#xA;        rs.conf()&#xA;        db.getReplicationInfo()&#xA;        db.printReplicationInfo()&#xA;        db.printSlaveReplicationInfo()&#xA;        use local        &#xA;        db.addUser(&#39;name&#39;, &#39;pwd&#39;)&#xA;                # 复制认证时用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分片&#34;&gt;&#xA;  分片&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e7%89%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;mongods --port 3000 --configdb localhost:27017&#xA;        # 多个地址用,隔开&#xA;        # 每个片都就是副本集&#xA;mongo localhost:3000/admin&#xA;db.runCommand({addshard: &#39;localhost:27017‘, allowLocal: true})&#xA;        # 在localhost上运行时, 要设allowLocal&#xA;        # &#39;a/localhost:27017&#39; 让mongo知道这个片所在的副本集&#xA;db.runCommand({enablesharding: &#39;db1&#39;})&#xA;db.runCommand({shardcollection: &#39;db1.user&#39;, key: {_id: 1}})&#xA;db.printShardingStatus()&#xA;db.runCommand({removeshard: &#39;localhost:27017&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;shell&#34;&gt;&#xA;  shell&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shell&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;mongo 127.0.0.1:27017/admin&#xA;        # 启动sell , 默认数据库为test&#xA;mongod –port 10000 –fork –logpath= logpath=/data/mongodb/log/mongodb.log -- logappend -- dbpath=/data/mongodb/data/db –config ~/.mongodb.conf &#xA;        # 启动服务 -auth开启身份验证&#xA;        # --rest 开启http管理，其端口号比mongo端口号大1000&#xA;        ## --nohttpinterface关闭http管理&#xA;        # --bindip localhost 设置只能有某ip访问&#xA;        # --noscripting 完全禁止服务端js执行&#xA;        # --repair 启动并修复&#xA;        # 不要发送SIGKILL信号关闭(kill -9), 应发送SIGINT或SIGTERM&#xA;        mongod --remove                                &#xA;                # 结束服务&#xA;        // mongodb.conf&#xA;                port = 5586&#xA;                fork = true&#xA;                logpath = mongodb.log&#xA;mongodump --host 127.0.0.1 --port 27017 --out ./dir/name&#xA;        # 备份数据库&#xA;mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径&#xA;mongorestore --host 127.0.0.1 --port 27017 --directoryperdb ./dir/name&#xA;        # mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径&#xA;        # --drop 是先删除现有的数据&#xA;mongoexport -d tank -c users -o /home/outrun/mongo&#xA;        # 导出整张表&#xA;        ## mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 -f 字段 -q 条件导出 --csv -o 文件名&#xA;        # mongoexport -d tank -c users --csv -f uid,name,sex -o tank/users.csv &#xA;        ## 导出表的部分字段&#xA;        # mongoexport -d tank -c users -q &#39;{uid:{$gt:1}}&#39; -o tank/users.json&#xA;        ## 根据条件导出数据&#xA;mongoimport -d tank -c users --upsert tank/users.dat&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsert --drop 文件名 &#xA;        ## 还原整表导出的非csv文件,  --upsert 表示插入或更新现有数据&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsertFields 字段 --drop 文件名&#xA;        ## 还原部分字段导出的文件, --upsertFields跟upsert一样&#xA;        ## 如 mongoimport -d tank -c users  --upsertFields uid,name,sex  tank/users.dat&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --type 类型 --headerline --upsert --drop 文件名  &#xA;        ## 还原导出的csv文件&#xA;        ## mongoimport -d tank -c users --type csv --headerline --file tank/users.csv&#xA;mongofiles put foo.txt&#xA;        # 使用gridfs&#xA;        list&#xA;        get foo.txt&#xA;        search&#xA;                # 按文件名查找&#xA;        delete foo.txt&#xA;mongostat&#xA;        # 实时输出mongo状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;java-client&#34;&gt;&#xA;  java client&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java-client&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;1.导入mongo-java-drver-2.9.3.jar&#xA;2.api&#xA;        Mongo m = new Mongo(&amp;quot;localhost&amp;quot;, 27017);&#xA;        DB db = m.getDB(&amp;quot;mydb&amp;quot;);&#xA;        boolean auth = db.authenticate(&amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;.toCharArray());&#xA;        System.out.println(&amp;quot;身份认证&amp;quot; + auth);&#xA;        // 获得所有数据库名&#xA;        for (String s : m.getDatabaseNames()) {&#xA;                System.out.println(&amp;quot;db : &amp;quot; + s);&#xA;        }&#xA;        // 删除数据库&#xA;        m.dropDatabase(&amp;quot;my_new_db&amp;quot;);&#xA;        // 获得collection列表&#xA;        Set&amp;lt;String&amp;gt; colls = db.getCollectionNames();&#xA;        for (String s : colls) {&#xA;                System.out.println(&amp;quot;collection : &amp;quot; + s);&#xA;        }&#xA;        // 获得一个collection&#xA;        DBCollection coll = db.getCollection(&amp;quot;testCollection&amp;quot;);&#xA;        // 创建document(包括内嵌文档)&#xA;        DBObject doc = new BasicDBObject().append(&amp;quot;appendField&amp;quot;, &amp;quot;appendField&amp;quot;);&#xA;        doc.put(&amp;quot;name&amp;quot;, &amp;quot;MongoDB&amp;quot;);&#xA;        doc.put(&amp;quot;type&amp;quot;, &amp;quot;database&amp;quot;);&#xA;        doc.put(&amp;quot;count&amp;quot;, 1);&#xA;        DBObject info = new BasicDBObject();&#xA;        info.put(&amp;quot;x&amp;quot;, 203);&#xA;        info.put(&amp;quot;y&amp;quot;, 102);&#xA;        doc.put(&amp;quot;info&amp;quot;, info);&#xA;        // 插入文档&#xA;        coll.insert(doc);&#xA;        // 查询文档&#xA;        DBObject doc2 = coll.findOne();&#xA;        System.out.println(doc2);&#xA;        // 统计文档数&#xA;        long count = coll.getCount();&#xA;        System.out.println(count);&#xA;        // 用游标遍历&#xA;        DBCursor cursor = coll.find();&#xA;        while (cursor.hasNext()) {&#xA;                DBObject object = cursor.next();&#xA;                System.out.println(object);&#xA;        }&#xA;        // 查询&#xA;        DBObject query = new BasicDBObject();&#xA;        query.put(&amp;quot;i&amp;quot;, 71);&#xA;        cursor = coll.find(query);&#xA;        // 条件查询&#xA;        query = new BasicDBObject();&#xA;        query.put(&amp;quot;i&amp;quot;, new BasicDBObject(&amp;quot;$gt&amp;quot;, 50)); // i&amp;gt;50&#xA;        cursor = coll.find(query);&#xA;        // 创建索引&#xA;        coll.createIndex(new BasicDBObject(&amp;quot;i&amp;quot;, 1)); // 1代表升序 , -1是降序&#xA;        // 查询索引&#xA;        List&amp;lt;DBObject&amp;gt; list = coll.getIndexInfo();&#xA;                for (DBObject index : list) {&#xA;                System.out.println(&amp;quot;索引 : &amp;quot; + index);&#xA;        }&#xA;类型&#xA;    // 自动生成的唯一ID&#xA;    ObjectId id = new ObjectId();&#xA;    System.out.println(id);&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Postgre SQL</title>
      <link>https://runout.run/docs/db/postgresql/</link>
      <pubDate>Thu, 11 Oct 2018 15:34:29 +0800</pubDate>
      <guid>https://runout.run/docs/db/postgresql/</guid>
      <description>&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;initdb                          # 初始化数据库&#xA;    --locale en_US.UTF-8 &#xA;    -D &#39;data&#39;&#xA;postgres                        # 启动数据库&#xA;    -D 目录&#xA;    -p 6543&#xA;pg_ctl start                    # 控制数据库: start, stop等&#xA;    -D data &#xA;    -l a.log &#xA;postmaster&#xA;    -D /data&#xA;psql&#xA;    -d db1&#xA;    -h localhost &#xA;    -p 5432&#xA;    -U 用户名&#xA;    -W                          # 强制要求验证密码&#xA;    -f 导入sql命令文件, 或者在末尾加 &amp;lt; a.sql 来导入&#xA;    -L 导出日志文件&#xA;&#xA;    o-&amp;gt;&#xA;    psql -U outrun -f pg.sql db1                    # 导入数据&#xA;pg_dump                         # 导出数据库&#xA;    -f                          # 指定文件&#xA;    -U                          # 用户&#xA;    -E UTF8                     # 编码&#xA;    -h localhost&#xA;    -n public                   # 指定schema&#xA;    -a                          # 只导数据，没有schema&#xA;    -F t                        # 压缩成tar&#xA;&#xA;    o-&amp;gt;&#xA;    pg_dump -U outrun -f pg.sql db1                 # 导出数据, -t tb1 导出表&#xA;pg_restore&#xA;    o-&amp;gt;&#xA;    pg_restore -U outrun -d db1 pg.tar              # 导入压缩的数据&#xA;createdb                        # 创建数据库并指定 owner&#xA;    -hlocalhost -Upostgres -O 用户名 数据库名                        &#xA;dropdb&#xA;    -U user dbname&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;特色sql&#34;&gt;&#xA;  特色sql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e8%89%b2sql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;元命令&#xA;    \?                          # postgre命令&#xA;    \h                          # sql命令&#xA;    \l                          # 列出数据库&#xA;    \q                          # 退出&#xA;    \c 数据库名                 # 切换数据库&#xA;    \d name                     # 查看序列、表、视图、索引&#xA;        \dS+                    # 详情&#xA;    \du                         # 查看角色&#xA;    \dt                         # 查看所有表&#xA;        \dtS+                   # 详情&#xA;    \ds                         # 查看序列&#xA;    \i a.sql                    # 执行sql文件&#xA;    \o a.log                    # 日志文件&#xA;    \password                   # 更换密码&#xA;    \x                          # 开启/关闭竖排显示&#xA;&#xA;    [sql] \gdesc                # 快速显示结果列名和类型&#xA;数据类型&#xA;    serial                      # 4字节，自增序列&#xA;        bigserial               # 8字节&#xA;    text default &#39;&#39;::text&#xA;    bigint default 0            # 8字节&#xA;        smallint                # 2字节&#xA;        int, integer            # 4字节&#xA;        decimal                 # 变长, 声明精度，精确&#xA;        numeric                 # 同上&#xA;        float&#xA;        real                    # 4字节，变精度，不精确&#xA;        double precision        # 8字节，变精度，不精确&#xA;&#xA;    boolean default false&#xA;    text[]                      # text数组&#xA;    date&#xA;    time&#xA;    timestamp with time zone&#xA;    interval&#xA;    &#xA;    bytea                       # 二进制&#xA;&#xA;    money&#xA;    uuid&#xA;约束&#xA;    constraint user_id primary key (id)&#xA;    constraint user_m_id unique(m_id)&#xA;    constraint fk_b_id foreign key (b_id) references tbb(id)&#xA;        MATCH SIMPLE&#xA;        ON UPDATE NO ACTION&#xA;        ON DELETE NO ACTION&#xA;dcl&#xA;    create database db1&#xA;        owner outrun&#xA;    create user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;    create role 用户名 with password &#39;密码&#39; login&#xA;        # 创建用户。role关键词可以省略&#xA;&#xA;    drop database db1&#xA;    drop table tablename;&#xA;&#xA;    alter database abc RENAME TO cba;&#xA;    alter database 数据库名 owner to 用户名&#xA;        # 更改数据库 owner&#xA;    alter table tb &#xA;        add primary key (id)&#xA;        add foreign key(b_id) references tb(id) on update cascade on delete cascade&#xA;        add column c1 text&#xA;        alter column id type int using id::integer&#xA;        rename c1 to c2&#xA;            drop constraint fk_b_id foreign key (b_id) references tbb(id)&#xA;        drop [column] name&#xA;        owner to outrun&#xA;            # 更改表 owner&#xA;    &#xA;    alter role 用户名 with login                     # 添加权限&#xA;        password &#39;asdf&#39;                             # with password &#39;asdf&#39;, 修改密码&#xA;        VALID UNTIL &#39;JUL 7 14:00:00 2012 +8&#39;        # 设置角色有效期&#xA;        login, superuser, createdb, createrole, replication, inherit&#xA;&#xA;    grant all privileges on database 数据库名 to 用户名&#xA;        # 授权数据库权限&#xA;ddl &#xA;    insert into tb(&amp;quot;desc&amp;quot;) values (&#39;a&#39;); &#xA;模糊查询&#xA;    ~                       # 匹配正则，大小写相关&#xA;        除&#39;a$&#39; &#39;^a&#39;的正则都只适合pg_trgm的gin索引&#xA;    ~*                      # 匹配正则，大小写无关&#xA;    !~                      # 不匹配该正则&#xA;    !~*&#xA;    ~ &#39;^a&#39;&#xA;        like &#39;a%&#39;&#xA;    ~ &#39;a$&#39;&#xA;    ~ &#39;ab.c&#39;&#xA;        like &#39;%ab_c%&#39;&#xA;&#xA;o-&amp;gt; 视图 &#xA;CREATE VIEW myview &#xA;AS &#xA;SELECT city, temp_lo, temp_hi, prcp, date, location &#xA;FROM weather, cities &#xA;WHERE city = name;&#xA;&#xA;o-&amp;gt; 建表&#xA;create table dwh_timestamp_meta&#xA;(&#xA;&amp;quot;id&amp;quot; serial NOT NULL,&#xA;&amp;quot;id&amp;quot; serial primary key,&#xA;&amp;quot;c_id&amp;quot; serial references cities(id),&#xA;&amp;quot;mongo_document_name&amp;quot; text default &#39;&#39;::text,&#xA;&amp;quot;last_update_time&amp;quot; bigint default 0,&#xA;&amp;quot;execute_time&amp;quot; timestamp with time zone,&#xA;constraint pk_id primary key(id)&#xA;)&#xA;with (&#xA;oids=false&#xA;);&#xA;&#xA;o-&amp;gt; 序列&#xA;create table a(&#xA;    id bigint primary key&#xA;);&#xA;create sequence a_id_seq&#xA;    start with 1&#xA;    increment by 1&#xA;    no minvalue&#xA;    no maxvalue&#xA;    cache 1;&#xA;alter table a alter column id set default nextval(&#39;a_id_seq&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据字典&#34;&gt;&#xA;  数据字典&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ad%97%e5%85%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;pg_roles                        # 角色信息&#xA;pg_database                     # 数据库信息&#xA;information_schema&#xA;    select column_name from information_schema.columns where table_schema=&#39;public&#39; and table_name=&#39;ad&#39;;&#xA;        # 表的所有列名&#xA;pg_stat_user_tables&#xA;    select relname from pg_stat_user_tables;&#xA;        # 所有表名&#xA;pg_stat_activity                # 活动状态&#xA;    SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE datname=&#39;garbage&#39; AND pid&amp;lt;&amp;gt;pg_backend_pid();&#xA;        # 查看数据库活动连接&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据库目录&#xA;    /usr/lib/systemd/system/postgresql.service&#xA;jdbc&#xA;    driver : org.postgresql.Driver&#xA;    url : jdbc:postgresql://localhost:5432/postgres&#xA;    初始用户名 : postgres&#xA;    初始数据库 : postgres&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储过程&#34;&gt;&#xA;  存储过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;drop function change_type1();&#xA;create or replace function change_type1()&#xA;returns int as&#xA;$body$&#xA;DECLARE&#xA;    r mongo_keys_type%rowtype;&#xA;    begin&#xA;    for r in select * from mongo_keys_type where type=&#39;number&#39;&#xA;    loop&#xA;        EXECUTE &#39;alter table &amp;quot;&#39; || r.&amp;quot;mongo_collection_name&amp;quot; || &#39;&amp;quot; alter &amp;quot;&#39; || r.&amp;quot;key&amp;quot; || &#39;&amp;quot; type decimal&#39;;&#xA;    END LOOP;&#xA;    return 0;&#xA;    end&#xA;$body$&#xA;language &#39;plpgsql&#39;;&#xA;&#xA;select change_type1()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;授权&#xA;    grant all privileges on database &#39;db1&#39; to &#39;outrun&#39;&#xA;    alter role &#39;outrun&#39; createdb&#xA;    alter role &#39;outrun&#39; superuser&#xA;创建用户&#xA;    create user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;    create role &#39;outrun&#39; createdb password &#39;asdf&#39; login&#xA;修改密码&#xA;    alter user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Java响应式编程</title>
      <link>https://runout.run/docs/pl/java/java_reactive/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/java_reactive/</guid>
      <description>&lt;h1 id=&#34;java响应式层级&#34;&gt;&#xA;  Java响应式层级&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e5%93%8d%e5%ba%94%e5%bc%8f%e5%b1%82%e7%ba%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Level 0: Thread &amp;amp; Runnable (Java 1+)&#xA;Level 1: ExecutorService, Callable, Future (Java 5+)&#xA;Level 2: ForkJoinPool (Java 7+)&#xA;Level 3: CompletableFuture (Java 8+)&#xA;Level 4: reactive streams, Flow (Java 9+)&#xA;Level 5: HTTP/2 client (Java 11+)&#xA;Level 6: Reactive libraries (RxJava, Reactor)&#xA;Level 7: Reactive services (Vert.x, Spring, Kafka)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;flow&#34;&gt;&#xA;  Flow&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#flow&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Flow.Publisher&#xA;Flow.Subscriber&#xA;Flow.Subscription&#xA;&#x9;# link publisher和subscriber&#xA;Flow.Processor&#xA;&#x9;# subscriber和publisher的act&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;reactivex&#34;&gt;&#xA;  ReactiveX&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reactivex&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Flux&#xA;Mono&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;rxjava&#34;&gt;&#xA;  RxJava&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rxjava&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;模型&#x9;&#xA;&#x9;Observable&#xA;&#x9;Subscriber&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;reactor&#34;&gt;&#xA;  Reactor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reactor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;vertx&#34;&gt;&#xA;  Vert.x&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#vertx&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;akka&#34;&gt;&#xA;  AKKA&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#akka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://runout.run/docs/middleware/container/nginx/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/container/nginx/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;结构&#xA;    一个主进程(root权限运行)和多个工作进程(普通权限运行)&#xA;优点&#xA;    异步非阻塞&#xA;    非常稳定&#xA;    反向代理&#xA;        后端服务io能力不高，nginx buffer http请求直到完整，再发送到后端。同样buffer响应&#xA;    相对apache&#xA;        轻量&#xA;        apache阻塞&#xA;        占资源低&#xA;        模块化设计&#xA;        社区活跃, bug少&#xA;多进程模型&#xA;    使用epoll&#xA;    多worker处理，业务阻塞时切换调度, 结束阻塞时分配&#xA;模块&#xA;    handler&#xA;    filter&#xA;    upstream&#xA;    load-balance&#xA;功能&#xA;    http&#xA;       可以保持session， 相同的ip分配到同一个服务器上&#xA;       缓存静态页面到内存，建立索引与自动索引&#xA;       反向代理&#xA;       负载均衡&#xA;       模块化&#xA;           过滤器&#xA;               gzipping, byte ranges, chunked responses, SSI-filter&#xA;       支持SSL与TLS SNI&#xA;    imap/pop3代理&#xA;命令&#xA;    nginx -c /etc/nginx/nginx.conf&#xA;    nginx -s quit&#xA;    nginx -s stop&#xA;    nginx -s reload&#xA;            # 重载设置&#xA;            ## service nginx reload&#xA;    nginx -v&#xA;            # 查看版本&#xA;            ## -V&#xA;    nginx -t [-c nginx.conf]&#xA;            # 检查配置文件是否正确&#xA;    nginx -h&#xA;            # 查看帮助&#xA;            ## -?&#xA;&#xA;    pkill -9 nginx&#xA;    kill -HUP `nginx.pid`&#xA;            # 平滑重启。尝试解析配置文件，成功时应用新配置(否则继续使用旧配置)，运行新的工作进程并从容关闭旧工作进程&#xA;            ## 继续为当前连接客户提供服务&#xA;            # 支持 QUIT TERM INT USR1(重新打开日志文件，切割日志时用) USR2(平滑升级可执行程序) WINCH(从容关闭工作进程)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;http://nginx.org/en/docs/dirindex.html&#xA;域&#xA;        main http server location&#xA;&#xA;worker_rlimit_nofile 51200;&#xA;        # worker最大打开文件数的限制, 不设时为系统限制&#xA;pid        /var/run/nginx.pid;&#xA;        # nginx.pid文件中存储当前nginx主进程的pid&#xA;例子&#xA;    user www-data;&#xA;    worker_processes 4;&#xA;    pid /run/nginx.pid;&#xA;&#xA;    events {&#xA;        worker_connections 768;&#xA;        # multi_accept on;&#xA;    }&#xA;&#xA;    http {&#xA;&#xA;        ##&#xA;        # Basic Settings&#xA;        ##&#xA;&#xA;        sendfile on;&#xA;        tcp_nopush on;&#xA;        tcp_nodelay on;&#xA;        keepalive_timeout 65;&#xA;        types_hash_max_size 2048;&#xA;        # server_tokens off;&#xA;&#xA;        server_names_hash_bucket_size 64;&#xA;        # server_name_in_redirect off;&#xA;&#xA;        include /etc/nginx/mime.types;&#xA;        default_type application/octet-stream;&#xA;&#xA;        ##&#xA;        # Logging Settings&#xA;        ##&#xA;&#xA;        access_log /var/log/nginx/access.log;&#xA;        error_log /var/log/nginx/error.log;&#xA;&#xA;        ##&#xA;        # Gzip Settings&#xA;        ##&#xA;        gzip on;&#xA;        gzip_disable &amp;quot;msie6&amp;quot;;&#xA;&#xA;        # gzip_vary on;&#xA;        # gzip_proxied any;&#xA;        # gzip_comp_level 6;&#xA;        # gzip_buffers 16 8k;&#xA;        # gzip_http_version 1.1;&#xA;        # gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;&#xA;&#xA;        ##&#xA;        # nginx-naxsi config&#xA;        ##&#xA;        # Uncomment it if you installed nginx-naxsi&#xA;        ##&#xA;&#xA;        #include /etc/nginx/naxsi_core.rules;&#xA;&#xA;        ##&#xA;        # nginx-passenger config&#xA;        ##&#xA;        # Uncomment it if you installed nginx-passenger&#xA;        ##&#xA;&#xA;        #passenger_root /usr;&#xA;        #passenger_ruby /usr/bin/ruby;&#xA;&#xA;        ##&#xA;        # Virtual Host Configs&#xA;        ##&#xA;        include /etc/nginx/conf.d/*.conf;&#xA;        include /etc/nginx/sites-enabled/*;&#xA;    }&#xA;&#xA;    #mail {&#xA;    #      # See sample authentication script at:&#xA;    #      # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript&#xA;    #&#xA;    #      # auth_http localhost/auth.php;&#xA;    #      # pop3_capabilities &amp;quot;TOP&amp;quot; &amp;quot;USER&amp;quot;;&#xA;    #      # imap_capabilities &amp;quot;IMAP4rev1&amp;quot; &amp;quot;UIDPLUS&amp;quot;;&#xA;    #&#xA;    #      server {&#xA;    #              listen    localhost:110;&#xA;    #              protocol  pop3;&#xA;    #              proxy      on;&#xA;    #      }&#xA;    #&#xA;    #      server {&#xA;    #              listen    localhost:143;&#xA;    #              protocol  imap;&#xA;    #              proxy      on;&#xA;    #      }&#xA;    #}&#xA;&#xA;&#xA;    o-&amp;gt; app.zlycare.com&#xA;    server {&#xA;        listen 80;&#xA;        listen [::]:80;&#xA;&#xA;        server_name app-test.zlycare.com www.app-test.zlycare.com;&#xA;&#xA;        # access log file&#xA;        access_log /home/zlycare/data/app-zlycare-com.log;&#xA;&#xA;        location / {&#xA;                gzip on;&#xA;                default_type text/plain;&#xA;                charset utf-8;&#xA;                root /home/zlycare/app/zlydoc-cloud/public;&#xA;                index index.html;&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; web.zlycare.com&#xA;    server {&#xA;        listen 80;&#xA;        listen [::]:80;&#xA;&#xA;        server_name web-test.zlycare.com www.web-test.zlycare.com;&#xA;&#xA;        # access log file&#xA;        access_log /home/zlycare/data/web.zlycare.log;&#xA;&#xA;        location / {&#xA;            proxy_pass http://127.0.0.1:8082;&#xA;            #proxy_redirect off;&#xA;            proxy_set_header Host $host;&#xA;            proxy_set_header X-Real-IP $remote_addr;&#xA;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; sdk.com&#xA;    server {&#xA;        listen 80;&#xA;&#xA;        server_name 10.162.201.58;&#xA;&#xA;        # access log file&#xA;        access_log /home/zlycare/data/app-zlycare-com.log;&#xA;&#xA;        location / {&#xA;            gzip on;&#xA;            default_type text/plain;&#xA;            charset utf-8;&#xA;            root /opt/sdk/nginx;&#xA;            index index.html;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;代理&#34;&gt;&#xA;  代理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;nginx&#xA;    server{&#xA;        resolver x.x.x.x;&#xA;        listen 82;&#xA;        location / {&#xA;            proxy_pass http://$http_host$request_uri;&#xA;        }&#xA;    }&#xA;&#xA;    不能有hostname, 必须有resolver, 即DNS服务器ip&#xA;    $http_host和$request_uri是nginx系统变量&#xA;用户机器&#xA;    export http_proxy=http://nginx-ip:82&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;反向代理&#34;&gt;&#xA;  反向代理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;upstream backend {&#xA;    hash $consistent_key consistent&#xA;    server 192.168.61.1:9080 weight=1&#xA;    server 192.168.61.1:9090 weight=2&#xA;}&#xA;location / {&#xA;    proxy_pass http://backend&#xA;    set $consistent_key $arg_cat;                       # 从cat参数取值&#xA;    if ($consistent_key = &amp;quot;&amp;quot;) {&#xA;        set $consistent_key $request_uri;&#xA;    }&#xA;}&#xA;&#xA;上游服务器, 权重越高分配越多&#xA;请求/时，代理到backend配置的上游服务器&#xA;负载均衡算法&#xA;    round-robin(轮询)&#xA;    ip-hash&#xA;        ip_hash&#xA;    hash key/hash key consistent        # hash和一致性hash&#xA;        hash $uri&#xA;    least_conn                          # 最小连接数服务器&#xA;    least_time                          # 最小平均响应时间, 商业版&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;php&#34;&gt;&#xA;  php&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#php&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;conf/nginx.conf&#xA;    server{&#xA;        location / {&#xA;            proxy_pass http://127.0;&#xA;            proxy_redirect default;&#xA;            proxy_http_version 1.1;&#xA;            proxy_set_header Upgrade $http_upgrade;&#xA;            proxy_set_header Connection $http_connection;&#xA;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;            proxy_set_header Host $http_host;&#xA;        }&#xA;    }&#xA;&#xA;default.conf&#xA;    server {&#xA;        listen      80;&#xA;        server_name  epinkr.com www.epinkr.com;&#xA;        #server_name  localhost;&#xA;        if ( $host != &#39;www.epinkr.com&#39; )&#xA;        {&#xA;            rewrite ^/(.*)$ http://www.epinkr.com/$1 permanent;&#xA;        }&#xA;        #root    /home/qipin/deploy;&#xA;        index  index.php index.html index.htm;&#xA;&#xA;        #charset koi8-r;&#xA;        #access_log  /var/log/nginx/log/host.access.log  main;&#xA;&#xA;        location = / {&#xA;            root  /home/qipin/deploy;&#xA;        #    index  index.html index.htm;&#xA;            fastcgi_pass  127.0.0.1:9000;&#xA;            fastcgi_index  index.php;&#xA;            fastcgi_param SCRIPT_FILENAME $document_root/index.php;&#xA;            include        fastcgi_params;&#xA;        }&#xA;&#xA;        location / {&#xA;            root  /home/qipin/deploy;&#xA;            index  index.html index.htm;&#xA;        }&#xA;&#xA;        location /photo {&#xA;            root  /home/qipin/data;&#xA;        #    return 402;&#xA;        #    rewrite ^\/yuepin\/(.*) /$1 last;&#xA;        }&#xA;&#xA;        location ~ ^\/(\w+)\/css\/ {&#xA;            root  /home/qipin/deploy;&#xA;            rewrite ^\/(\w+)\/css\/(.*)  /css/$2 last;&#xA;        }&#xA;&#xA;        location ~ ^\/(\w+)\/img\/ {&#xA;            root  /home/qipin/deploy;&#xA;            rewrite ^\/(\w+)\/img\/(.*)  /img/$2 last;&#xA;        }&#xA;&#xA;        location ~ ^\/(\w+)\/js\/ {&#xA;            root  /home/qipin/deploy;&#xA;            rewrite ^\/(\w+)\/js\/(.*)  /js/$2 last;&#xA;        }&#xA;&#xA;        location ~ ^\/user\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/user\/(\w+)  /php/user/user_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/company\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/company\/(\w+)  /php/company/company_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/vendor\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/vendor\/(\w+)  /php/vendor/vendor_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/person\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/person\/(\w+)  /php/person/person_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/get\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/get\/(\w+)  /php/yp_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #  return 402;&#xA;            rewrite ^\/(\w+)$  /php/$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/php\/(\w*\.php)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 403;&#xA;            fastcgi_pass  127.0.0.1:9000;&#xA;            fastcgi_index  index.php;&#xA;            fastcgi_param SCRIPT_FILENAME $document_root/php/$1;&#xA;            include        fastcgi_params;&#xA;        }&#xA;&#xA;        location ~ ^\/php\/(\w+)\/(\w*\.php)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 403;&#xA;        #    try_files $uri =404;&#xA;            fastcgi_pass  127.0.0.1:9000;&#xA;            fastcgi_index  index.php;&#xA;            fastcgi_param SCRIPT_FILENAME $document_root/php/$1/$2;&#xA;            include        fastcgi_params;&#xA;        }&#xA;&#xA;        #location /qipin/ {&#xA;        #    root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;        #    index  index.html;&#xA;        #    rewrite ^\/qipin\/(.*) /$1 last;&#xA;        #}&#xA;&#xA;        #error_page  404              /404.html;&#xA;&#xA;        # redirect server error pages to the static page /50x.html&#xA;        #&#xA;        error_page  500 502 503 504  /50x.html;&#xA;        location = /50x.html {&#xA;            root  /usr/share/nginx/html;&#xA;        }&#xA;&#xA;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80&#xA;        #&#xA;        #location ~ \.php$ {&#xA;        #    proxy_pass  http://127.0.0.1;&#xA;        #}&#xA;&#xA;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000&#xA;        #&#xA;        #location ~ \.php$ {&#xA;        #    root          html;&#xA;        #    fastcgi_pass  127.0.0.1:9000;&#xA;        #    fastcgi_index  index.php;&#xA;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;&#xA;        #    include        fastcgi_params;&#xA;        #}&#xA;&#xA;        # deny access to .htaccess files, if Apache&#39;s document root&#xA;        # concurs with nginx&#39;s one&#xA;        #&#xA;        #location ~ /\.ht {&#xA;        #    deny  all;&#xA;        #}&#xA;    }&#xA;&#xA;ssl.conf&#xA;    #HTTPS server&#xA;    #&#xA;    #server {&#xA;    #    listen      443 ssl;&#xA;    #    server_name  localhost;&#xA;&#xA;    #    ssl_certificate      /etc/nginx/cert.pem;&#xA;    #    ssl_certificate_key  /etc/nginx/cert.key;&#xA;&#xA;    #    ssl_session_cache shared:SSL:1m;&#xA;    #    ssl_session_timeout  5m;&#xA;&#xA;    #    ssl_ciphers  HIGH:!aNULL:!MD5;&#xA;    #    ssl_prefer_server_ciphers  on;&#xA;&#xA;    #    location / {&#xA;    #        root  /usr/share/nginx/html;&#xA;    #        index  index.html index.htm;&#xA;    #    }&#xA;    #}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;HttpLimitReqModul&#xA;    介绍&#xA;        限制单个ip一段时间的连接数&#xA;    http{&#xA;        limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;&#xA;        server {&#xA;            location {&#xA;                limit_req zone=allips burst=5 nodelay;&#xA;            }&#xA;        }&#xA;    }&#xA;HttpLimitConnModul&#xA;    介绍&#xA;        限制单个ip的并发连接数&#xA;HttpLimitZoneModul&#xA;    介绍&#xA;        限制ip连接内存大小&#xA;&#xA;    http {&#xA;        limit_conn_zone $binary_remote_addr zone=namea:10m;&#xA;            # $binary_remote_addr 同一客户端ip地址&#xA;            # 1.1.18前是limit_zone&#xA;        limit_conn_zone $server_name zone=nameb:10m;&#xA;            # $server_name 同一server的名字&#xA;        server {&#xA;            location {&#xA;                limit_conn  namea 20;&#xA;                limit_conn nameb 20;&#xA;                    # 并发连接数&#xA;                limit_rate 100k;&#xA;                    # 下载速度&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Nodejs</title>
      <link>https://runout.run/docs/middleware/container/nodejs/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/container/nodejs/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    commonJS规范&#xA;    javascript书写(v8引擎)&#xA;        js设计之初就可以运行在后端&#xA;        v8&#xA;            成熟的事件驱动模式&#xA;            没有i/o库, 没有历史包袱&#xA;            v8性能好&#xA;    单线程&#xA;        不用在意多线程状态同步(没有死锁, 没有上下文切换)&#xA;        无法利用多核, 错误时应用退出，计算密集时无法调度   # child_process解决&#xA;    事件驱动(event-driven), 回调&#xA;        event loop&#xA;            [while(true)] -&amp;gt; watcher -&amp;gt; handles&#xA;            watcher产生事件后, event loop取到并执行其handle(回调函数)&#xA;            event loop每一周询问多个watcher是否有事件&#xA;            event loop中没有watcher时进程退出&#xA;        http模块就是启动了一个watcher,所以执行后进程不结束&#xA;            其它watcher有 timer, fs, udp/req, process&#xA;        不同操作系统中event driven的实现:&#xA;            windows: IOCP&#xA;            Linux: epoll&#xA;            Mac:kqueue&#xA;    非阻塞io(non-blocking i/o model)&#xA;        io与数据处理分离（所以必须异步）&#xA;        线程池结合event-driven实现&#xA;    异步io&#xA;        go语言有协程(coroutine)而node.js没有，协程可以同步式编程&#xA;            # 有第三方协程模块&#xA;        promise(commonJs的规范, 其实现有whenJs, Q)&#xA;            # 书写难度降低&#xA;        eventProxy      # 朴灵&#xA;        async/step&#xA;commonJS&#xA;    模块&#xA;        var math = require(&#39;math&#39;)  # 缓存优先，核心模块优先。依次找.js, .node, .json&#xA;        exports.add = function(){}&#xA;    二进制&#xA;    Buffer&#xA;    字符集编码&#xA;    I/O流&#xA;    进程环境&#xA;    文件&#xA;    套接字&#xA;    单元测试&#xA;    web网关&#xA;    包管理&#xA;        package.json&#xA;        bin&#xA;        lib&#xA;        doc&#xA;        test&#xA;实现技术&#xA;    libev的windows与linux接口实现&#xA;    c++扩展&#xA;事件循环    # 生产者消费者模型&#xA;    执行一次称为Tick&#xA;    询问观察者(文件、网络等)是否有待处理事件, 有关联回调执行回调&#xA;        # 观察者先idle, 再io, 再check&#xA;        通过请求对象实现，绑定回调、运行参数、执行标志&#xA;层次&#xA;    javascript&#xA;    v8&#xA;    node&#xA;    libuv&#xA;    *nix/ windows                # 分别编译&#xA;应用&#xA;    I/O密集服务&#xA;    cpu密集用c/c++扩展，用子进程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;node --v8-options | grep harmony&#xA;    # 查看支持的es6特性&#xA;npm&#xA;    介绍&#xA;        cnpm是一个alibaba开发维护的，提供私有npm注册服务&#xA;    -v      # 版本&#xA;    install     # 安装，会执行package.json中scripts的勾子命令&#xA;        -g&#xA;    uninstall&#xA;    config&#xA;        list    # 查看项目的默认设置。registry属性指向npm官方资源位置&#xA;        set registry http://192.168.1.20:7001&#xA;            # 设置源&#xA;    test        # package.json中scripts的test&#xA;&#xA;    o-&amp;gt; 搭建cnpm服务器&#xA;        git clone https://github.com/cnpm/cnpmjs.org.git&#xA;        cd cnpmjs.org&#xA;        npm install npm -g&#xA;            # 升级npm的版本&#xA;        npm install&#xA;        创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码&#xA;        config/index.js中注释bindingHost来对外网开放&#xA;        node --harmony_generators dispatch.js&#xA;            # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问&#xA;    o-&amp;gt; 使用私有库&#xA;        npm install ape-algorithm --registry=http://192.168.1.20:7001&#xA;            # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份&#xA;&#xA;    设置&#xA;         ~/.npmrc&#xA;            registry=http://192.168.1.20:7001&#xA;                # 淘宝翻墙库 https://registry.npm.taobao.org/&#xA;n&#xA;node-gyp    # 编译c/c++模块&#xA;nvm&#xA;cnpm&#xA;    介绍&#xA;        cnpm是一个alibaba开发维护的，提供私有npm注册服务&#xA;    安装&#xA;        npm install cnpm&#xA;            # 可以像使用npm一样使用&#xA;        cnpm sync gulp&#xA;            # npm 中发布的包在cnpm中有延时，可以用这个命令来手动同步&#xA;    搭建cnpm服务器&#xA;        git clone https://github.com/cnpm/cnpmjs.org.git&#xA;        cd cnpmjs.org&#xA;        npm install npm -g&#xA;            # 升级npm的版本&#xA;        npm install&#xA;        创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码&#xA;        config/index.js中注释bindingHost来对外网开放&#xA;        node --harmony_generators dispatch.js&#xA;            # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问&#xA;    使用私有库&#xA;        npm install ape-algorithm --registry=http://192.168.1.20:7001&#xA;            # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份&#xA;    项目设置私有库&#xA;        npm config list&#xA;            # 查看项目的默认设置。registry属性指向npm官方资源位置&#xA;        npm config set registry http://192.168.1.20:7001&#xA;    用户设置私有库&#xA;        // ~/.npmrc&#xA;        registry=http://192.168.1.20:7001&#xA;            # 另外，淘宝翻墙库 https://registry.npm.taobao.org/&#xA;调试&#xA;    o-&amp;gt; 代码中插入断点&#xA;        debugger;&#xA;    o-&amp;gt; 以debug模式运行&#xA;        # debug模式运行时, help查看可用命令&#xA;        node debug app.js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;package.json&#xA;    name                # 包名&#xA;    description         # 简介&#xA;    version             # 版本&#xA;    keywords            # 搜索关键词&#xA;    maintainers         # 维护者&#xA;    contributors        # 代码贡献者&#xA;    bugs                # 反馈bug的地址&#xA;    licenses            # 许可证&#xA;    repositories        # 托管代码地址&#xA;    dependencies        # 依赖包&#xA;    homepage            # 该包网站&#xA;    os                  # 操作系统支持列表&#xA;    cpu                 # cpu架构支持列表&#xA;    engine              # 支持的js引擎, 如ejs&#xA;    builtin             # 内建在底层系统的哪些组件上&#xA;    directories         # 目录说明&#xA;    implements          # 实现了commonJS哪些规范&#xA;    scripts             # 脚本命令&#xA;        preinstall&#xA;        install&#xA;        uninstall&#xA;        test&#xA;    author              # 包作者&#xA;    bin                 # 全局安装时，命令安装的位置&#xA;    main                # require()包时入口，默认找index&#xA;    devDependencies     # 开发时需要的依赖&#xA;&#xA;    o-&amp;gt;&#xA;    {&#xA;        &amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;,&#xA;        &amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;,&#xA;        &amp;quot;keywords&amp;quot;: [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;],                     # npm search时用&#xA;        &amp;quot;description&amp;quot;: &amp;quot;A testing package&amp;quot;,&#xA;        &amp;quot;os&amp;quot;: [&amp;quot;linux&amp;quot;, &amp;quot;darwin&amp;quot;],&#xA;        &amp;quot;author&amp;quot;: &amp;quot;outrun&amp;lt;outrun@mail.com&amp;gt;&amp;quot;,&#xA;        &amp;quot;dependencies&amp;quot;: {&#xA;            &amp;quot;express&amp;quot;: &amp;quot;^1.0.0&amp;quot;,&#xA;            &amp;quot;redis&amp;quot;: &amp;quot;&amp;gt;= 0.6.7&amp;quot;&#xA;        },&#xA;        &amp;quot;devDependencies&amp;quot;: {&#xA;            &amp;quot;grunt&amp;quot;: &amp;quot;^0.4.5&amp;quot;&#xA;        },&#xA;        &amp;quot;main&amp;quot;: &amp;quot;index&amp;quot;,&#xA;        &amp;quot;bin&amp;quot;: {&#xA;            &amp;quot;test&amp;quot;: &amp;quot;./bin/test.js&amp;quot;&#xA;        },&#xA;        &amp;quot;scripts&amp;quot;: {&#xA;            &amp;quot;start&amp;quot;: &amp;quot;node server.js&amp;quot;,&#xA;            &amp;quot;test&amp;quot;: &amp;quot;vows test/*.js&amp;quot;,               # &amp;quot;grunt test&amp;quot; &amp;quot;mocha test&amp;quot; &amp;quot;make test&amp;quot; &amp;quot;make test-all&amp;quot;&#xA;            &amp;quot;preinstall&amp;quot;: &amp;quot;./configure&amp;quot;,&#xA;            &amp;quot;install&amp;quot;: &amp;quot;make &amp;amp;&amp;amp; make install&amp;quot;,&#xA;            &amp;quot;uninstall&amp;quot;: &amp;quot;&amp;quot;&#xA;        },&#xA;        &amp;quot;engines&amp;quot;: {&#xA;            &amp;quot;node&amp;quot;: &amp;quot;5.0.0&amp;quot;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;异步api&#34;&gt;&#xA;  异步api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;I/O操作api&#xA;setTimeout() setInterval()&#xA;    定时器插入观察者的红黑树中, tick时迭代定时器，如果超时就形成事件&#xA;        # 如果前一个tick耗时大，定时会拖后&#xA;        # 比较浪费性能&#xA;process.nextTick()&#xA;    回调放入队列，下tick全部执行, 位于idle观察者&#xA;setImmediate()&#xA;    回调放入链表, 每tick执行一个，位于check观察者，晚于idle&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;宿主对象&#34;&gt;&#xA;  宿主对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%bf%e4%b8%bb%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;global      #全局对象&#xA;    root    # 指向自己&#xA;    BLOBAL # 指向自己&#xA;&#xA;    setTimeout()&#xA;    setInterval()&#xA;    clearTimeout()&#xA;    clearInterval()&#xA;process     #当前进程&#xA;    argv    # 获得命令行参数数组&#xA;        title       # node&#xA;        version     # v0.12.2&#xA;    事件&#xA;        process.on(&amp;quot;uncaughtException&amp;quot;,function(e){&#xA;            console.log(&amp;quot;error:&amp;quot;+e);&#xA;        });&#xA;buffer&#xA;    特点&#xA;        node中buffer不属于v8, 使用c++扩展编写。所以可以使用高于1.4g的内存&#xA;        一个元素一字节&#xA;        8kb之内为小对象，slab机制分配内存, 先申请后分配。大于8kb的创建SlowBuffer对象&#xA;        pool的实现方式&#xA;    字符编码类型&#xA;        # 默认编码UTF-8, 一个buffer只能有一个编码&#xA;        ascii&#xA;        utf-8&#xA;        utf-16le/ucs-2&#xA;        base64&#xA;        binary&#xA;        hex&#xA;&#xA;    length&#xA;&#xA;    write()&#xA;        # write(str, [offset], [length], [encoding])&#xA;    toString()&#xA;        # toString([encoding], [start], [end])&#xA;    isEncoding()&#xA;        # 指定编码是否支持转换&#xA;    copy()&#xA;        # 复制自身到另一个buffer的某位置&#xA;        buf.copy(buffer, 0)&#xA;    concat()  #静态方法&#xA;        concat(chunks, size)&#xA;            # chunks中为buffer数组, size为总大小&#xA;    使用&#xA;        new Buffer(100)&#xA;        new Buffer(&#39;a&#39;, &#39;UTF-8&#39;)&#xA;console     #控制台&#xA;    log(&#39;&#39;,obj)&#xA;        console.log(&#39;[%s] listening on http://127.0.0.1:%d&#39;, app.setting.env, port)&#xA;module&#xA;    Module.exports真正的接口，导出的是一个类型&#xA;    exports是Module.exports的包装，导出的是Object类型的对象&#xA;promise     # 0.11.x后加入的全局对象&#xA;    使用&#xA;        # 复制&#xA;        var jadeTemplate = new Promise(function(resolve, reject) {&#xA;        fs.readFile(path.join(__dirname, &#39;views/article.jade&#39;), function(err, data) {&#xA;            if (err) {&#xA;            reject(err.message);&#xA;            } else {&#xA;            resolve(data.toString());&#xA;            }&#xA;        });&#xA;        });&#xA;&#xA;        var localData = new Promise(function(resolve, reject) {&#xA;        fs.readFile(path.join(__dirname, &#39;static/shuffle.json&#39;), function(err, data) {&#xA;            if (err) {&#xA;            reject(err.message);&#xA;            } else {&#xA;            resolve(JSON.parse(data.toString()));&#xA;            }&#xA;        });&#xA;        });&#xA;&#xA;        Promise&#xA;        .all([jadeTemplate, localData])&#xA;        .then(function(value) {&#xA;            console.log(jade.compile(value[0])(value[1]));&#xA;        });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内置lib&#34;&gt;&#xA;  内置lib&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%aelib&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;http&#34;&gt;&#xA;  http&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#http&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    继承自net模块&#xA;    EventEmitter实例&#xA;事件&#xA;    服务端&#xA;        connection&#xA;        request&#xA;        close&#xA;        checkContinue&#xA;            # 发送较大数据时，先发送Expect: 100-continue请求头，此时触发&#xA;        connect&#xA;        upgrade&#xA;            # 要求升级连接协议时&#xA;        clientError&#xA;            # 客户端触发error事件时触发&#xA;    客户端&#xA;        response&#xA;        socket&#xA;            # 建立连接时触发&#xA;        connect&#xA;            # 响应200时触发&#xA;        upgrade&#xA;        continue&#xA;&#xA;globalAgent     # 重用http长连接，实际是个连接池，默认有5个并发&#xA;    sockets&#xA;        # 连接数&#xA;    requests&#xA;        # 处于等待状态的请求数&#xA;&#xA;createServer(onRequest).listen(8888, func);                # 创建服务器并启动&#xA;    request&#xA;        req.setEncoding(&amp;quot;utf8&amp;quot;)&#xA;        var postData = &amp;quot;&amp;quot;;&#xA;        req.addListener(&amp;quot;data&amp;quot;, function(postDataChunk){&#xA;            postData += postDataChunk;&#xA;        });&#xA;        req.addListener(&amp;quot;end&amp;quot;, function(){&#xA;            route(handle, pathname, res, postData);&#xA;        });                                # 拼接post请求数据&#xA;        req.rawBody&#xA;            # post来的原生数据&#xA;        req.destroy()&#xA;            # 放弃请求，停止招收&#xA;&#xA;    response&#xA;        res.setHeader(&#39;WWW-Authenticate&#39;, &#39;Basic realm=\&amp;quot;Tomcat Manager Application\&amp;quot;&#39;)&#xA;        res.writeHead(200, {&amp;quot;Content-Type&amp;quot;: &amp;quot;text/html&amp;quot;});&#xA;            # 调用setHeader多次，调用writeHead后才写入&#xA;        res.write(&amp;quot;&amp;quot;);&#xA;        res.write(file,?&amp;quot;binary&amp;quot;);?&#xA;        res.end();&#xA;request(options, fn)        # 发起客户端请求&#xA;    # options中有 host, hostname, port, localAddress(使用本地的哪个网卡), socketPath(本地套接字文件路径), method, path, headers, auth(被计算成请求头的Authorization部分), agent(并发连接数，默认5)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;https&#34;&gt;&#xA;  https&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#https&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    nodejs&#xA;    申请ca证书&#xA;    访问端口为443&#xA;使用&#xA;    express -e nodejs-https&#xA;    cd nodejs-https &amp;amp;&amp;amp; npm install&#xA;    git --version&#xA;    openssl version -a&#xA;    openssl genrsa -out privatekey.pem 1024&#xA;        # 生成证书文件&#xA;    openssl req -new -key privatekey.pem -out certrequest.csr&#xA;        # 通过私钥生成CSR证书签名&#xA;    openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem&#xA;        # 通过私钥和证书签名生成证书文件&#xA;        ## 这时生成了三个文件: certificate.pem, certrequest.csr, privatekey.pem&#xA;        ### 分别是: 证书文件, CSR证书签名, 私钥&#xA;        ## 由于证书是自己创建的，没有经过第三方机构验证，用户访问时会出现警告提示&#xA;    服务器&#xA;        var https = require(&#39;https&#39;)&#xA;            , fs = require(&#39;fs&#39;);&#xA;        var options = {&#xA;            key: fs.readFileSync(&#39;./privatekey.pem&#39;),&#xA;            cert: fs.readFileSync(&#39;./certificate.pem&#39;)&#xA;        };&#xA;        https.createServer(options, app).listen(3011, function(){&#xA;            console.log(&#39;Https server listening on port: &#39; + 3011);&#xA;        });&#xA;    客户端&#xA;        var options = {&#xA;            hostname: &#39;localhost&#39;,&#xA;            port: 8000,&#xA;            path: &#39;/&#39;,&#xA;            method: &#39;GET&#39;,&#xA;            key: fs.readFileSync(&#39;./keys/client.key&#39;),&#xA;            cert: fs.readFileSync(&#39;./keys/client.crt&#39;),&#xA;            ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]&#xA;                # 设置rejectUnauthorized: false 来忽略ca验证&#xA;        }&#xA;        options.agent = new https.Agent(options)&#xA;&#xA;        var req = https.request(options, function (res) {&#xA;            res.setEncoding(&#39;utf-8&#39;)&#xA;            res.on(&#39;data&#39;, function (d) {&#xA;                console.log(d)&#xA;            })&#xA;        })&#xA;        req.end()&#xA;&#xA;        req.on(&#39;error&#39;, function(e){&#xA;            console.log(e)&#xA;        })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;net&#34;&gt;&#xA;  net&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#net&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    处理tcp请求&#xA;    socket是EventEmitter的Stream实例&#xA;注意&#xA;    默认开启Nagle, 会合并小数据成一个数据包延迟发送&#xA;        socket.setNoDelay(true)关闭Nagle&#xA;    并不是每次write都触发data事件, 关掉Nagle后，可能接收到多个小数据包后触发一次data&#xA;&#xA;服务器事件&#xA;    listening&#xA;    connection&#xA;    close&#xA;    error&#xA;连接事件&#xA;    data&#xA;    end&#xA;    connect&#xA;    drain&#xA;        # 任意一端调用write时触发&#xA;    error&#xA;    close&#xA;    timeout&#xA;&#xA;o-&amp;gt; 基本服务&#xA;# telnet来测试&#xA;var net = require(&#39;net&#39;)&#xA;&#xA;var server = net.createServer(function (socket) {&#xA;    socket.on(&#39;data&#39;, function (data) {&#xA;        socket.write(&#39;a&#39;)&#xA;    })&#xA;&#xA;    socket.on(&#39;end&#39;, function () {&#xA;        console.log(&#39;disconnected.&#39;)&#xA;    })&#xA;&#xA;    socket.write(&#39;welcome&#39;)&#xA;})&#xA;&#xA;server.listen(8124, function () {&#xA;    console.log(&#39;server bound&#39;)&#xA;})&#xA;&#xA;o-&amp;gt; 基本服务2&#xA;var server = net.createServer()&#xA;server.on(&#39;connection&#39;, function (socket) {})&#xA;server.listen(8124)&#xA;&#xA;o-&amp;gt; 监听&#xA;server.listen(&#39;/tmp/echo.sock&#39;)&#xA;    # nc -U /tmp/echo.sock 来测试&#xA;&#xA;o-&amp;gt; 客户端&#xA;var client = net.connect({port: 8124}, function () {&#xA;    console.log(&#39;client connected&#39;)&#xA;    client.write(&#39;a&#39;)&#xA;})&#xA;&#xA;client.on(&#39;data&#39;, function (data) {&#xA;    console.log(data.toString())&#xA;    client.end()&#xA;})&#xA;&#xA;client.on(&#39;end&#39;, function() {&#xA;    console.log(&#39;disconnected.&#39;)&#xA;})&#xA;&#xA;o-&amp;gt; 客户端&#xA;var client = net.connect({path: &#39;/tmp/echo.sock&#39;})&#xA;&#xA;o-&amp;gt; 管道&#xA;var server = net.createServer(function (socket) {&#xA;    socket.write(&#39;a&#39;)&#xA;    socket.pipe(socket)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dgram&#34;&gt;&#xA;  dgram&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dgram&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    处理udp&#xA;    socket是EventEmitter实例&#xA;&#xA;o-&amp;gt; 服务&#xA;var dgram = require(&#39;dgram&#39;)&#xA;&#xA;var server = dgram.createSocket(&#39;udp4&#39;)&#xA;&#xA;server.on(&#39;message&#39;, function (msg, rinfo) {&#xA;    console.log(msg + &#39;from&#39; + rinfo.address + &#39;:&#39; +)&#xA;})&#xA;&#xA;server.on(&#39;listening&#39;, function () {&#xA;    var address = server.address()&#xA;    console.log(&#39;listening &#39; + address.address + &#39;:&#39; + address.port)&#xA;})&#xA;&#xA;server.bind(41234)&#xA;&#xA;o-&amp;gt; 客户端&#xA;var message = new Buffer(&#39;a&#39;)&#xA;var client = dgram.createSocket(&#39;udp4&#39;)&#xA;client.send(message, 0, message.length, 41234, &#39;localhost&#39;, function (err, bytes) {&#xA;    client.close()&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;events&#34;&gt;&#xA;  events&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#events&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    几乎所有对象的父类&#xA;使用&#xA;    var events = require(&#39;events&#39;)&#xA;        , util = require(&#39;util&#39;);&#xA;    function Obj(){events.EventEmitter.cal(this);}&#xA;    util.inherits(Obj, events.EventEmitter);&#xA;        # Obj.prototype.__proto__ = events.EventEmitter.prototype;&#xA;    Obj.prototype.write = function (data) {this.emit(&#39;data&#39;, data);};&#xA;&#xA;    var obj = new Obj();&#xA;    obj.on(&#39;data&#39;, function (data) {console.log(&#39;Received data&#39;, data);})&#xA;        # obj.once&#xA;    obj.write(&#39;hello&#39;);&#xA;&#xA;setMaxListeners(0)&#xA;    # 侦听器过多不警告&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;path&#34;&gt;&#xA;  path&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#path&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;os&#34;&gt;&#xA;  os&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#os&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    totalmem&#xA;    freemem&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;fs&#34;&gt;&#xA;  fs&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;fs.readFile(&amp;quot;tmp/test.png&amp;quot;, &amp;quot;binary&amp;quot;, function(error, file){&#xA;});&#xA;fs.writeFile(&#39;target.png&#39;, &#39;binary&#39;, function(err){&#xA;})&#xA;fs.exists(filePath, function(exists){&#xA;        if(exists){}&#xA;})&#xA;fs.unlink(filePath, function(err){&#xA;})&#xA;fs.renameSync(files.upload.path,?&amp;quot;/tmp/test.png&amp;quot;);                # 写入文件(阻塞)&#xA;&#xA;o-&amp;gt; 流读写&#xA;var reader = fs.createReadStream(&#39;in.txt&#39;)&#xA;        # 第二个参数为设置, highWaterMark: 每次读取的size, encoding: 编码&#xA;var writer = fs.createWriteStream(&#39;out.txt&#39;)&#xA;reader.on(&#39;data&#39;, function (chunk) {&#xA;        writer.write(chunk)&#xA;})&#xA;reader.on(&#39;end&#39;, function() {&#xA;        writer.end()&#xA;})&#xA;&#xA;var reader = fs.createReadStream(&#39;in.txt&#39;)&#xA;var writer = fs.createWriteStream(&#39;out.txt&#39;)&#xA;reader.pipe(writer)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;sys&#34;&gt;&#xA;  sys&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sys&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;process&#34;&gt;&#xA;  process&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#process&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;argv&#xA;    # 启动时参数&#xA;pid&#xA;    # 当前进程的pid&#xA;&#xA;once()&#xA;    once(&#39;SIGINT&#39;, function () {})&#xA;        # ctrl + c&#xA;memoryUsage()&#xA;    # 查看v8内存使用量&#xA;    # 其中rrs是resident set size, 是常驻内存的部分，其他在swap或文件系统中&#xA;kill()&#xA;    # process.kill(pid[, signal])&#xA;on()&#xA;    # 事件触发&#xA;&#xA;o-&amp;gt;&#xA;process.on(&#39;SIGTERM&#39;, function () {&#xA;    console.log(&#39;Got a SIGTERM, exiting...&#39;)&#xA;    process.exit(1)&#xA;})&#xA;&#xA;o-&amp;gt;&#xA;process.on(&#39;uncaughtException&#39;, function () {&#xA;    logger.error(err)&#xA;    process.send({act: &#39;suicide&#39;})&#xA;        # 向主进程发送信号&#xA;    worker.close(function () {&#xA;        process.exit(1)&#xA;    })&#xA;&#xA;    setTimeout(function () {&#xA;        # 长连接断开需要时间较久, 超时自动退出&#xA;        process.exit(1)&#xA;    }, 5000)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;module&#34;&gt;&#xA;  module&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#module&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;exports&#xA;parent&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;stream&#34;&gt;&#xA;  stream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    继承EventEmitter, 处理文件之类的流&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;tls&#34;&gt;&#xA;  tls&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tls&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    建立在tls/ssl上的加密tcp&#xA;    使用openssl来构建证书和测试&#xA;&#xA;o-&amp;gt; 服务器&#xA;var tls = require(&#39;tls&#39;)&#xA;var fs = require(&#39;fs&#39;)&#xA;&#xA;var options = {&#xA;        key: fs.readFileSync(&#39;./keys/server.key&#39;),&#xA;        cert: fs.readFileSync(&#39;./keys/server.crt&#39;),&#xA;        requestCert: true,&#xA;        ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]&#xA;}&#xA;&#xA;var server = tls.createServer(options, function (stream) {&#xA;        console.log(&#39;server connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;)&#xA;        stream.write(&#39;welcome!\n&#39;)&#xA;        stream.setEncoding(&#39;utf8&#39;)&#xA;        stream.pipe(stream)&#xA;})&#xA;server.listen(8000, function () {&#xA;        console.log(&#39;server bound&#39;)&#xA;})&#xA;&#xA;o-&amp;gt; 客户端&#xA;var options = {&#xA;        key: fs.readFileSync(&#39;./keys/client.key&#39;),&#xA;        cert: fs.readFileSync(&#39;./keys/client.crt&#39;),&#xA;        ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]&#xA;}&#xA;&#xA;var stream = tls.connect(8000, options, function () {&#xA;        console.log(&#39;client connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;)&#xA;                # 证书是否通过&#xA;        process.stdin.pipe(stream)&#xA;})&#xA;&#xA;stream.setEncoding(&#39;utf8&#39;)&#xA;stream.on(&#39;data&#39;, function (data) {&#xA;        console.log(data)&#xA;})&#xA;stream.on(&#39;end&#39;, function () {&#xA;        server.close()&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;child_process&#34;&gt;&#xA;  child_process&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#child_process&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    可以创建新的node进程&#xA;spawn(command[, args][a options])&#xA;    # command执行的命令&#xA;    # args参数列表&#xA;    options 环境变量对象, 包括7个属性&#xA;        cwd 子进程当前工作目录&#xA;        env 环境变量键值对&#xA;        stdio 子进程stdio配置&#xA;        customFds 子进程stdio使用的文件标示符&#xA;        detached 进程组的主控制&#xA;        uid 用户进程id&#xA;        进程组id&#xA;&#xA;    var du = child.spawn(&#39;du&#39;, [&#39;-sh&#39;, &#39;/disk1&#39;]);&#xA;    du.stdout.on(&#39;data&#39;, function(data){})&#xA;    du.stderr.on(&#39;data&#39;, function(data){})&#xA;    du.on(&#39;exit&#39;, function(code){})&#xA;exec(&#39;&#39;)&#xA;    # 对spawn的友好封装, 增加了shell命令解析&#xA;    child.exec(&#39;cat *.js | ws&#39;, function(error, stdout, stderr){})&#xA;execFile(command[, args])&#xA;    # 执行可执行文件，不解析args,防止了exec参数注入的风险&#xA;    child.execFile(&#39;/bin/ls&#39;, [&#39;-l&#39;, &#39;.&#39;], function(err, result){})&#xA;fork()&#xA;    # 同spawn, 但建立ipc(进程通信, inter-process communication)&#xA;    var n = child.fork(&#39;./son.js&#39;);&#xA;    n.on(&#39;message&#39;, function(){&#xA;        console.log(&#39;Main listen: &#39;, m);&#xA;    });&#xA;    n.send({hello: &#39;i am parent&#39;});&#xA;    // son.js&#xA;    process.on(&#39;message&#39;, function(m){&#xA;        console.log(&#39;Son listen: &#39;, m);&#xA;    });&#xA;    process.send({hello: &#39;i am child&#39;});&#xA;子进程对象&#xA;    send()&#xA;        # 发送消息和句柄，句柄可以是&#xA;        ## net.Socket, net.Server, net.Native(c++层面的tcp套接字或IPC管道), dgram.Socket, dgram.Native&#xA;    kill()&#xA;        # 向子进程发送SIGTERM信号&#xA;    事件&#xA;        message&#xA;        error&#xA;        exit&#xA;        close&#xA;        disconnect&#xA;&#xA;o-&amp;gt; cpu核数worker&#xA;    o-&amp;gt; master.js&#xA;    var fork = require(&#39;child_process&#39;).fork&#xA;    var cpus = require(&#39;os&#39;).cpus()&#xA;    for (var i = 0; i &amp;lt; cpus.length; i++){&#xA;        fork(&#39;./worker.js&#39;)&#xA;    }&#xA;&#xA;    o-&amp;gt; worker.js&#xA;    var http = require(&#39;http&#39;)&#xA;    http.createServer(function(req, res){...}).listen(Math.round((1+Math.random()) * 1000), &#39;127.0.0.1&#39;)&#xA;&#xA;o-&amp;gt; spawn&#xA;var spawn = require(&#39;child_process&#39;).spawn&#xA;free = spawn(&#39;free&#39;, [&#39;-m&#39;])&#xA;free.stdout.on(&#39;data&#39;, function (data) {})&#xA;free.stderr.on(&#39;data&#39;, function (data) {})&#xA;free.on(&#39;exit&#39;, function (code, signal) {})&#xA;&#xA;o-&amp;gt; fork&#xA;    # 需要至少30ms, 10M启动一个v8实例&#xA;var fork = require(&#39;child_process&#39;).fork&#xA;var cpus = require(&#39;os&#39;).cpus()&#xA;for (var i = 0; i &amp;lt; cpus.length; i++) {&#xA;        fork(&#39;./worker.js&#39;)&#xA;}&#xA;&#xA;o-&amp;gt; 通信&#xA;    # 只有子进程是node进程时才可以通信&#xA;var cp = require(&#39;child_process&#39;)&#xA;var n = cp.fork(__dirname + &#39;/sub.js&#39;)&#xA;&#xA;n.on(&#39;message&#39;, function (m) {&#xA;    console.log(&#39;PARENT got message: &#39;, m)&#xA;})&#xA;n.send({a: 1})&#xA;&#xA;process.on(&#39;message&#39;, function (m) {&#xA;    console.log(&#39;CHILD got message:&#39;, m)&#xA;})&#xA;process.send({b: 2})&#xA;&#xA;o-&amp;gt; 句柄通信&#xA;    # 节省了代理建立socket浪费的文件描述符&#xA;var child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;)&#xA;var server = require(&#39;net&#39;).createServer()&#xA;server.on(&#39;connection&#39;, function (socket) {&#xA;    socket.end(&#39;handled by parent \n&#39;)&#xA;})&#xA;server.listen(1337, function () {&#xA;    child.send(&#39;server&#39;, server)&#xA;})&#xA;// child.js&#xA;process.on(&#39;message&#39;, function (m, server) {&#xA;    if (m === &#39;server&#39;) {&#xA;        server.on(&#39;connection&#39;, function (socket) {&#xA;            socket.end(&#39;handled by child \n&#39;)&#xA;        })&#xA;    }&#xA;})&#xA;&#xA;o-&amp;gt; 句柄负载http&#xA;    # 对描述符是抢占式的&#xA;var cp = require(&#39;child_process&#39;)&#xA;var child1 = cp.fork(&#39;child.js&#39;)&#xA;var child2 = cp.fork(&#39;child.js&#39;)&#xA;&#xA;var server = require(&#39;net&#39;).createServer()&#xA;server.listen(1337, function () {&#xA;    child1.send(&#39;server&#39;, server)&#xA;    child2.send(&#39;server&#39;, server)&#xA;    server.close()&#xA;})&#xA;// child.js&#xA;var http = require(&#39;http&#39;)&#xA;var server = http.createServer(function (req, res) {&#xA;    res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;})&#xA;    res.end(&#39;handled by child, pid is &#39; + process.pid + &#39;\n&#39;)&#xA;})&#xA;process.on(&#39;message&#39;, function (m, tcp) {&#xA;    if (m === &#39;server&#39;) {&#xA;        tcp.on(&#39;connection&#39;, function (socket) {&#xA;            server.emit(&#39;connection&#39;, socket)&#xA;        })&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;cluster&#34;&gt;&#xA;  cluster&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cluster&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    child_process和net模块的组合&#xA;        cluster启动时，内部启动tcp服务器&#xA;        fork()时，将tcp服务器socket文件描述符发给worker, 实现共享端口&#xA;isWorker&#xA;    判断process.env是否值为NODE_UNIQUE_ID&#xA;isMaster&#xA;    判断cluster.isWorker&#xA;事件&#xA;    fork            # fork时&#xA;    online          # 工作进程创建好后&#xA;    listening       # 工作进程调listen()后&#xA;    disconnect      # 主进程和工作进程IPC通道断开后&#xA;    exit            # 所有工作进程退出后&#xA;    setup           # cluster.setupMaster()执行后&#xA;&#xA;o-&amp;gt; cpu核数worker&#xA;var cluster = require(&#39;cluster&#39;)&#xA;cluster.setupMaster({&#xA;    exec: &amp;quot;worker.js&amp;quot;&#xA;})&#xA;&#xA;var cpus = require(&#39;os&#39;).cpus()&#xA;for (var i = 0; i &amp;lt; cpus.length; i++) {&#xA;    cluster.fork()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;domain&#34;&gt;&#xA;  domain&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#domain&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    用于异步异常捕获&#xA;    绑定方式&#xA;        隐式绑定: 把domain上下文中定义的变量，自动绑定到domain对象&#xA;        显式绑定: 把不是domain上下文中定义的变量，以代码的方式绑定到domain对象&#xA;members     # 已加入domain对象的域定时器和事件发射器的数组&#xA;&#xA;create()                # 返回一个domain对象&#xA;run(fn)                 # 在domain上下文中执行一个函数，并隐式绑定所有事件、定时器和低级请求&#xA;add(emitter)            # 显式的增加事件&#xA;remove(emitter)         # 删除事件&#xA;bind(callback)          # 以return为封闭callback函数　&#xA;intercept(callback)     # 同bind, 但返回第一个参数&#xA;enter()                 # 进入一个异步调用的上下文，绑定到domain&#xA;exit()                  # 退出当前的domain, 切换到不同的链的异步调用的上下文中，对应domain.enter()&#xA;dispose()               # 释放一个domain对象，让node进程回收这部分资源&#xA;使用&#xA;    var domain = require(&#39;domain&#39;);&#xA;    function async_error(){&#xA;        setTimeout(function(){&#xA;            var r = Math.random() * 10;&#xA;            console.log(&#39;random num is &#39; + r);&#xA;            if(r &amp;gt; 5)&#xA;                throw new Error(&#39;Error: random num &#39; + r + &#39; &amp;gt; 5&#39;);&#xA;        }, 10);&#xA;    }&#xA;    var d = domain.create();&#xA;    d.on(&#39;error&#39;, function(err){&#xA;        console.log(err);&#xA;    });&#xA;    setInterval(function(){&#xA;        d.run(async_err);&#xA;    }, 1000);&#xA;未绑定不捕获&#xA;    代码&#xA;        var domain = require(&#39;domain&#39;);&#xA;        var EventEmitter = require(&#39;events&#39;).EventEmitter;&#xA;&#xA;        var e = new EventEmitter();&#xA;&#xA;        var timer = setTimeout(function(){&#xA;            e.emit(&#39;data&#39;);&#xA;        }, 10);&#xA;&#xA;        function next(){&#xA;            e.once(&#39;data&#39;, function(){&#xA;                throw new Error(&#39;Receive data error!&#39;);&#xA;            });&#xA;        }&#xA;&#xA;        var d = domain.create();&#xA;        d.on(&#39;error&#39;, function(err){&#xA;            console.log(err);&#xA;        });&#xA;        d.run(next);&#xA;    原因&#xA;        timer和e两个关键对象在初始化时都没有在domain范围内。当next函数中抛出异常时, 没有处于domain的包裹中&#xA;&#xA;    修改&#xA;        ...&#xA;        d.add(e);&#xA;        d.add(timer);&#xA;        d.run(next);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;外部lib&#34;&gt;&#xA;  外部lib&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%96%e9%83%a8lib&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;url&#34;&gt;&#xA;  url&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#url&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;parse()&#xA;    pathname&#xA;&#xA;    url.parse(req.url)&#xA;    url.parse(req.url, true) 会parse出query对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;querystring&#34;&gt;&#xA;  querystring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#querystring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;parse()&#xA;    querystring.parse(url.parse(req.url).query)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;crypto&#34;&gt;&#xA;  crypto&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#crypto&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    加密并生成各种散列&#xA;    利用openssl库来实现，提供openssl中一系列哈希方法，包括hmac, cipher, decipher, 签名和验证等方法的封装&#xA;使用&#xA;    var crypto = require(&#39;crypto&#39;);&#xA;    console.log(crypto.getHashes());                                    # 打印支持的所有hasp算法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;node-gyp&#34;&gt;&#xA;  node-gyp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#node-gyp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;编译C++模块的编译工具&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;util&#34;&gt;&#xA;  util&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#util&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    var util = require(&#39;util&#39;);&#xA;方法&#xA;    inherits(Sub, Base)                # 对象间原型继承，Sub 仅继承Base原型中定义 的函数&#xA;    inspect(obj)                # 任意对象转换为字符串&#xA;    log(string)                        # 带时间戳的log&#xA;    format(&#39;%s:%s&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)                // &#39;a:b c&#39;&#xA;        # format(&#39;%s:%s&#39;, &#39;a&#39;)                // &#39;a:%s&#39;&#xA;        # format(1, 2, 3)                        // &#39;1 2 3&#39;&#xA;    is系列&#xA;        isArray(obj)&#xA;        isRegExp(obj)&#xA;        isDate(obj)&#xA;        isError(obj)&#xA;        isBoolean(obj)&#xA;        isNull(obj)&#xA;        isNullOrUndefined(obj)&#xA;        isNumber(obj)&#xA;        isString(obj)&#xA;        isSymbol(obj)&#xA;        isUndefined(obj)&#xA;        isObject(obj)&#xA;        isFunction(obj)&#xA;        isPrimitive(obj)&#xA;            # 是否基本类型&#xA;        isBuffer(obj)&#xA;        deprecate(foo, &#39;foo() is deprecated, use bar() instead&#39;);&#xA;            # 标记为过时, 调用foo()时显示后面的话&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;zlib&#34;&gt;&#xA;  zlib&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#zlib&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    提供压缩方法，如gzip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;全局属性&#34;&gt;&#xA;  全局属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a8%e5%b1%80%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    并非挂在global下的属性，但可以直接使用&#xA;&#xA;__dirname&#xA;    # 在任何模块内获取当前模块文件的绝对路径&#xA;__filename&#xA;    # 当前在执行的js文件路径&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;异常捕获&#xA;    process.on(&amp;quot;uncaughtException&amp;quot;,function(e){&#xA;        logger.error(&amp;quot;error:&amp;quot;+e);&#xA;    });&#xA;    process.on(&#39;unhandledRejection&#39;, function (err, p) {&#xA;        console.error(err.stack)&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Spring Cloud</title>
      <link>https://runout.run/docs/middleware/distributed/spring_cloud/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/distributed/spring_cloud/</guid>
      <description>&lt;h1 id=&#34;亿级流量&#34;&gt;&#xA;  亿级流量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%bf%e7%ba%a7%e6%b5%81%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;流量接入层&#34;&gt;&#xA;  流量接入层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81%e9%87%8f%e6%8e%a5%e5%85%a5%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;二级域名&#xA;    泛域名&#xA;    A记录&#xA;dns解析&#xA;    udp&#xA;        向网关请求dns解析&#xA;    httpDNS&#xA;        用ip请求http服务, 返回域名解析的ip&#xA;        因为用ip请求，适合app，不适合网页&#xA;lvs + keepalive             # 多lvs时用dns负载&#xA;nginx&#xA;    openresty&#xA;        kong&#xA;动静分离&#xA;    cdn&#xA;        dns动态域名解析&#xA;        cdn分发服务&#xA;            源服务拉取FastDFS&#xA;            CDN节点分发&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;web服务层&#34;&gt;&#xA;  WEB服务层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web%e6%9c%8d%e5%8a%a1%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;webflux&#xA;    不基于重量的servlet标准&#xA;    基于netty&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;eureka&#34;&gt;&#xA;  Eureka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eureka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    @EnableEurekaServer&#xA;    application.properties&#xA;        eureka.client.register-with-eureka=false                # 是否注册自己&#xA;        eureka.client.fetch-registry=false                      # 是否拉取eureka&#xA;        eureka.client.service-url.defaultZone=http://localhost:7900/eureka/         # 设置注册中心的URL&#xA;        eureka.instance.hostname=euk1.com&#xA;        spring.application.name=EurekeServer                    # eureka集群中各节点要同名&#xA;行为&#xA;    register                    # 注册&#xA;    renew                       # 通过心跳, 默认30s。三次失败删除实例&#xA;    fetch registry              # 拉注册的信息&#xA;    cancel                      # 发取消请求，删除实例&#xA;    time lag                    # 同步时间延迟&#xA;    communication mechanism     # 通讯机制，默认jersey和jackson&#xA;功能&#xA;    唯一标识                        # service id&#xA;        主机名:application.name:端口&#xA;    提供RestAPI, 可多终端接入&#xA;问题&#xA;    一致性问题方案&#xA;        Eureka间不同步，client向多个Eureka提交&#xA;        Enreka间同步，Eureka强可用性弱一致性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    spring boot基础上构建，快速构建分布式系统, 全家桶&#xA;    面向云环境架构(云原生)    # 适合在docker和paas部署&#xA;功能&#xA;    配置管理&#xA;    服务发现&#xA;    熔断&#xA;    智能路由&#xA;    微代理&#xA;    控制总线&#xA;    全局锁&#xA;    决策竞选&#xA;    分布式会话&#xA;    集群状态管理&#xA;子项目&#xA;    spring cloud netflix    # 对netflix oss套件整合&#xA;        eureka     # 服务治理(注册、发现)&#xA;        hystrix    # 容错管理&#xA;        ribbon     # 软负载均衡(客户端)&#xA;        feign      # 基于hystrix和ribbon，服务调用组件&#xA;        zuul       # 网关，智能路由、访问过滤&#xA;        archaius   # 外部化配置&#xA;    基础&#xA;        spring cloud starters       # 基础依赖, 高版本取消&#xA;        spring cloud commons&#xA;    服务&#xA;        spring cloud consul         # 封装consul(服务发现与配置, 与docker无缝)&#xA;        spring cloud cluster        # 抽象zookeeper, redis, hazelcast, consul的选举算法和通用状态模式实现接口&#xA;        spring cloud cloudfoundry   # 与pivotal cloudfoundry整合&#xA;        spring cloud aws            # 整合aws&#xA;        spring cloud zookeeper      # 整合zookeeper&#xA;        spring cloud cli            # groovy中快速创建应用&#xA;        spring cloud task           # 任务&#xA;    配置&#xA;        spring cloud config         # 应用配置外部化, 推送客户端配置, 支持git存储&#xA;    消息&#xA;        spring cloud bus            # 消息总线，传播集群状态变化来触发动作，如刷新配置&#xA;        spring cloud stream         # 声明式发送、接收消息&#xA;    监控&#xA;        spring cloud sleuth         # 跟踪&#xA;    安全&#xA;        spring cloud security       # 应用安全控制, zuul代理中OAuth2中继器&#xA;    测试&#xA;        spring cloud contract       # 契约测试, 可用groovy和yaml定义&#xA;版本&#xA;    用命名不用版本号，因为有多子项目版本，易混淆&#xA;    命名用伦敦地铁站用，字母表排序&#xA;缺点&#xA;    难于追查框架问题&#xA;    非二进制通信协议&#xA;    适合中小团队&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;modules&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-common&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-provider-book&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-service-discovery&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-api-gateway&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-consumer-book&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-monitor-dashboard&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-aggregator&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-zipkin-server&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-admin-server&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-config-server&amp;lt;/module&amp;gt;&#xA;    &amp;lt;/modules&amp;gt;&#xA;    &amp;lt;parent&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;relativePath/&amp;gt;&#xA;    &amp;lt;/parent&amp;gt;&#xA;    &amp;lt;dependencyManagement&amp;gt;&#xA;        &amp;lt;dependencies&amp;gt;&#xA;            &amp;lt;dependency&amp;gt;&#xA;                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;&#xA;                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;&#xA;                &amp;lt;version&amp;gt;Edgware.SR3&amp;lt;/version&amp;gt;&#xA;                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&#xA;                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;&#xA;            &amp;lt;/dependency&amp;gt;&#xA;        &amp;lt;/dependencies&amp;gt;&#xA;    &amp;lt;/dependencyManagement&amp;gt;&#xA;    &amp;lt;repositories&amp;gt;&#xA;        &amp;lt;repository&amp;gt;&#xA;            &amp;lt;id&amp;gt;spring-releases&amp;lt;/id&amp;gt;&#xA;            &amp;lt;url&amp;gt;https://repo.spring.io/libs-release&amp;lt;/url&amp;gt;&#xA;        &amp;lt;/repository&amp;gt;&#xA;    &amp;lt;/repositories&amp;gt;&#xA;    &amp;lt;pluginRepositories&amp;gt;&#xA;        &amp;lt;pluginRepository&amp;gt;&#xA;            &amp;lt;id&amp;gt;spring-releases&amp;lt;/id&amp;gt;&#xA;            &amp;lt;url&amp;gt;https://repo.spring.io/libs-release&amp;lt;/url&amp;gt;&#xA;        &amp;lt;/pluginRepository&amp;gt;&#xA;    &amp;lt;/pluginRepositories&amp;gt;&#xA;application.yml&#xA;    spring:&#xA;        profiles: peer1                         # bean的逻辑组&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;组件&#34;&gt;&#xA;  组件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;dependencyManagement&#xA;    spring-cloud-dependencies&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-spring-boot&#34;&gt;&#xA;  spring cloud spring boot&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-spring-boot&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;spring-cloud-eureka&#34;&gt;&#xA;  spring cloud eureka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-eureka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    生产者向eureka注册, 周期发送心跳(默认30s)&#xA;    eureka服务间同步注册信息&#xA;    消费者请求地址，缓存本地&#xA;    eurake接收生产者心跳超时, 设置为down, 推送状态到消费者&#xA;    eurake短期down过多生产者，进入自我保护不再down&#xA;组件&#xA;    spring-cloud-starter-[netflix-]eureka-server&#xA;&#xA;application.yml&#xA;    eureka:&#xA;        instance:&#xA;            hostname: localhost                 # 实例主机名&#xA;        client:&#xA;            registerWithEureka: false           # 当前服务不注册&#xA;            fetchRegistry: false                # 不获取注册信息&#xA;            serviceUrl:                         # server地址&#xA;                defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/&#xA;bootstrap.yml                                   # 基础配置, 待拉取config&#xA;&#xA;注解&#xA;    @EnableEurekaServer                         # 修饰Application类&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-ribbon&#34;&gt;&#xA;  spring cloud ribbon&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-ribbon&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    ribbon:&#xA;        eureka:&#xA;            enabled: false                      # 禁止从eureka获得注册列表&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-hystrix&#34;&gt;&#xA;  spring cloud hystrix&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-hystrix&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 单个服务监控&#xA;hystrix dashboard&#xA;    路径&#xA;        /hystrix&#xA;        /hystrix.stream                         # 至少请求一次接口，才有数据&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-turbine&#34;&gt;&#xA;  spring cloud turbine&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-turbine&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 多服务监控&#xA;application.yml&#xA;    turbine:&#xA;        aggregator:&#xA;            clusterConfig: default                                  # 此监控器名&#xA;        appConfig: erp-consumer-metadb, erp-consumer                # 目标服务名&#xA;        clusterNameExpression: new String(&amp;quot;default&amp;quot;)                # 名称匹配表达式&#xA;路径&#xA;    /turbine.stream&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-feign&#34;&gt;&#xA;  spring cloud feign&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-feign&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    feign:&#xA;        hystrix:&#xA;            enabled: true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-zuul&#34;&gt;&#xA;  spring cloud zuul&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-zuul&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 默认会用ribbon负载均衡&#xA;application.yml&#xA;    zuul:&#xA;        prefix: /v1&#xA;        routes:&#xA;            hiapi:&#xA;                path: /hiapi/**&#xA;                serviceId: erp-consumer-metadb&#xA;                # url: http://localhost:8762  # 这样写不会做负载均衡&#xA;                # serviceId: hiapi-v1&#xA;&#xA;    ## 手动url负载均衡&#xA;    # ribbon: &#xA;    #   eureka:&#xA;    #     enabled: false&#xA;    # hiapi-v1:&#xA;    #   ribbon:&#xA;    #     listOfServers: http://localhost:8762,http://localhost:8763&#xA;案例&#xA;    过滤&#xA;        import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;&#xA;        @Component&#xA;        public class MyFilter extends ZuulFilter {&#xA;&#xA;            private static Logger log = LoggerFactory.getLogger(MyFilter.class);&#xA;&#xA;            @Override&#xA;            public String filterType() {&#xA;                return PRE_TYPE;&#xA;            }&#xA;&#xA;            @Override&#xA;            public int filterOrder() {&#xA;                return 0;&#xA;            }&#xA;&#xA;            @Override&#xA;            public boolean shouldFilter() {&#xA;                return true;&#xA;            }&#xA;&#xA;            @Override&#xA;            public Object run() {&#xA;                RequestContext ctx = RequestContext.getCurrentContext();&#xA;                HttpServletRequest request = ctx.getRequest();&#xA;                log.info(String.format(&amp;quot;%s &amp;gt;&amp;gt;&amp;gt; %s&amp;quot;, request.getMethod(), request.getRequestURL().toString()));&#xA;                Object accessToken = request.getParameter(&amp;quot;token&amp;quot;);&#xA;                if (accessToken == null) {&#xA;                    log.warn(&amp;quot;token is empty&amp;quot;);&#xA;        //&#xA;        //            ctx.setSendZuulResponse(false);&#xA;        //            ctx.setResponseStatusCode(401);&#xA;        //            try {&#xA;        //                ctx.getResponse().getWriter().write(&amp;quot;token is empty&amp;quot;);&#xA;        //            }catch (Exception e){&#xA;        //&#xA;        //            }&#xA;                    return null;&#xA;                }&#xA;                log.info(&amp;quot;ok&amp;quot;);&#xA;                return null;&#xA;            }&#xA;        }&#xA;    熔断&#xA;        @Component&#xA;        public class MyFallbackProvider implements ZuulFallbackProvider {&#xA;            @Override&#xA;            public String getRoute() {&#xA;                return &amp;quot;*&amp;quot;;&#xA;            }&#xA;&#xA;            @Override&#xA;            public ClientHttpResponse fallbackResponse() {&#xA;                return new ClientHttpResponse() {&#xA;                    @Override&#xA;                    public HttpStatus getStatusCode() throws IOException {&#xA;                        return HttpStatus.OK;&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public int getRawStatusCode() throws IOException {&#xA;                        return 200;&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public String getStatusText() throws IOException {&#xA;                        return &amp;quot;OK&amp;quot;;&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public void close() {&#xA;&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public InputStream getBody() throws IOException {&#xA;                        return new ByteArrayInputStream(&amp;quot;error, I&#39;m the fallback&amp;quot;.getBytes());&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public HttpHeaders getHeaders() {&#xA;                        HttpHeaders headers = new HttpHeaders();&#xA;                        headers.setContentType(MediaType.APPLICATION_JSON);&#xA;                        return headers;&#xA;                    }&#xA;                };&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-config&#34;&gt;&#xA;  spring cloud config&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-config&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;config-server&#xA;    application.yml&#xA;        server:&#xA;            port: 9012&#xA;        spring:&#xA;            application:&#xA;                name: erp-config-server&#xA;            cloud:&#xA;                config:&#xA;                server:&#xA;                    native:&#xA;                        search-locations: classpath:/shared             # 读取路径&#xA;            profiles:&#xA;                active: native                                          # 本地读取&#xA;    shared/config-client-dev.yml                                        # 文件名为 [客户端服务名]-[profile变量]&#xA;        server:&#xA;            port: 9013&#xA;        foo: foo version 1&#xA;    地址&#xA;        localhost:9012/config-client/dev                                # 查看分发给服务的配置&#xA;config-client&#xA;    spring:&#xA;        application:&#xA;            name: erp-config-client&#xA;        cloud:&#xA;            config:&#xA;                uri: http://localhost:9012&#xA;                fail-fast: true&#xA;        profiles:&#xA;            active: dev&#xA;注解&#xA;    @RefreshScope                           # 热更新&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-bus&#34;&gt;&#xA;  spring cloud bus&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-bus&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    spring:&#xA;        rabbitmq:&#xA;            host: localhost&#xA;            port: 5672&#xA;            username: outrun&#xA;            password: asdf&#xA;            publisher-confirms: true&#xA;            virtual-host: /&#xA;    management:&#xA;        security:&#xA;            enabled: false&#xA;路径&#xA;    POST /bus/refresh                       # 从新拉配置, 其它服务也触发同步&#xA;        ?destination=appName:*.*            # 指定刷新服务名下实例&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-stream&#34;&gt;&#xA;  spring cloud stream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-stream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;spring-cloud-sleuth&#34;&gt;&#xA;  spring cloud sleuth&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-sleuth&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    zipkin:&#xA;        base-url: http://localhost:9014&#xA;    sleuth:&#xA;        sampler:&#xA;            percentage: 1.0&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Bootstrap</title>
      <link>https://runout.run/docs/middleware/library_frontend/bootstrap/</link>
      <pubDate>Thu, 11 Oct 2018 09:39:11 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/bootstrap/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;在jquery基础上的组件框架&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;移动&#34;&gt;&#xA;  移动&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a7%bb%e5%8a%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;css&#34;&gt;&#xA;  css&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#css&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局&#xA;        container&#xA;                # div, 唯一包裹容器&#xA;        container-fluid&#xA;                # 占全部视口&#xA;栅格&#xA;        # 必须放在row内&#xA;        col-xs-1&#xA;                # 适用于大于等于分界点的屏幕&#xA;                ## 大于12的最后那个col另起一行排列&#xA;                # xs &amp;lt; 768px 宽度, container 最大宽度: 自动&#xA;                # sm &amp;gt;= 768px, 750px&#xA;                # md &amp;gt;= 992px, 970px&#xA;                # lg &amp;gt;= 1200px, 1170px&#xA;        &#xA;        col-md-offset-4&#xA;                # 向右偏移4&#xA;        col-md-pull-9&#xA;                # 向后推9, 改变元素的顺序&#xA;        col-md-push-3&#xA;        &#xA;        o-&amp;gt; mixin&#xA;        make-row&#xA;                如 .wrapper {.make-row();}&#xA;        make-xs-column&#xA;        make-sm-column-offset&#xA;        make-sm-column-push&#xA;        make-sm-column-pull&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;样式&#34;&gt;&#xA;  样式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b7%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;muted&#xA;        # 文本颜色&#xA;        text-warning&#xA;        text-error&#xA;        text-info&#xA;        text-success&#xA;text-left&#xA;        # 文本左对齐&#xA;        text-center&#xA;        text-right&#xA;        text-justify&#xA;        text-nowrap&#xA;        text-lowercase&#xA;        text-uppercase&#xA;        text-capitalize&#xA;&#xA;bg-primary&#xA;        # p&#xA;        bg-success&#xA;        bg-info&#xA;        bg-warning&#xA;        bg-danger&#xA;&#xA;success&#xA;        # 状态类&#xA;        # table行颜色, control-group div&#xA;        error&#xA;        danger&#xA;        warning&#xA;        info&#xA;        active&#xA;has-warning&#xA;        # div元素&#xA;        # 适用class: control-label, form-control, help-block&#xA;        has-error&#xA;        has-success&#xA;has-feedback&#xA;        # div, &#xA;&#xA;pull-right&#xA;        # 任意元素向右浮动&#xA;        pull-left&#xA;navbar-right&#xA;        # 导航条中向右浮动&#xA;        navbar-left&#xA;clearfix&#xA;        # 清除浮动&#xA;&#xA;initialism&#xA;        # 缩略语样式, abbr标签&#xA;small&#xA;        # small标签的样式&#xA;lead&#xA;        # p标签，突出显示&#xA;blockquote-reverse&#xA;        # blockquote标签使用, 内容右对齐&#xA;&#xA;disabled&#xA;        # btn, input, 只disable样式&#xA;        o-&amp;gt; 适用的class&#xA;        radio&#xA;        radio-inline&#xA;        checkbox&#xA;        checkbox-inline&#xA;        o-&amp;gt; 适用的标签&#xA;        fieldset&#xA;&#xA;inline&#xA;        # 行内ul, checkbox&#xA;&#xA;center-block&#xA;        # 任意元素, 水平居中&#xA;&#xA;show&#xA;        # 任意元素显示&#xA;        hidden&#xA;&#xA;.sr-only&#xA;        # 任意元素, 辅助技术支持的文本, 隐藏当前元素&#xA;        sr-only-focusable&#xA;                # 元素有焦点时显示出来&#xA;&#xA;visible-xs-block&#xA;        # 只对xs屏幕可见&#xA;        visible-xs-inline&#xA;        visible-xs-inline-block&#xA;hidden-xs&#xA;        # 对xs屏隐藏&#xA;visible-print-block&#xA;        # 对打印机可见&#xA;        visible-print-inline&#xA;        visible-print-inline-block&#xA;hidden-print&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;table&#34;&gt;&#xA;  table&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#table&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;table&#xA;        # table样式&#xA;table-responsive&#xA;        # div元素，包裹table样式后，创建响应式表格，带有滚动条&#xA;table-striped&#xA;        # 斑马纹样式&#xA;table-bordered&#xA;        # 边框圆角&#xA;table-hover&#xA;        # 行悬停样式&#xA;table-condensed&#xA;        # 内补减半使更紧凑&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;form&#34;&gt;&#xA;  form&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#form&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;form-search&#xA;        # form标签中添加，其中有input&#xA;        search-query&#xA;                # search中的input的样式&#xA;form-actions&#xA;        # div元素, 内部按钮自动缩进&#xA;form-inline&#xA;        # 行内表单&#xA;form-actions&#xA;        # div元素，按钮列表，和表单其它元素对齐&#xA;form-horizontal&#xA;        # 元素右对齐左浮动的表单&#xA;form-group&#xA;        # form中的div元素&#xA;        form-control&#xA;                # input, textarea, select&#xA;                o-&amp;gt; 支持的input类型&#xA;                text&#xA;                password&#xA;                datetime&#xA;                datetime-local&#xA;                date&#xA;                month&#xA;                time&#xA;                week&#xA;                number&#xA;                email&#xA;                url        &#xA;                search&#xA;                tel        &#xA;                color    &#xA;        form-control-static&#xA;                # p标签，用来代input显示文本  &#xA;        control-group&#xA;                control-label&#xA;                controls&#xA;        input-group&#xA;                input-group-addon&#xA;                        # span&#xA;                form-control&#xA;                        # 同外&#xA;        glyphicon-ok&#xA;                # input元素或input-group的div元素后的span, 添加input内的图标&#xA;                # 联合使用 class: glyphicon, form-control-feedback; &#xA;                ## 属性 aria-hidden=&amp;quot;true&amp;quot;&#xA;                glyphicon-warning-sign&#xA;                glyphicon-remove&#xA;                &#xA;checkbox&#xA;        # div, label&#xA;radio&#xA;        # div, label&#xA;checkbox-inline&#xA;        # div&#xA;radio-inline&#xA;        # div&#xA;&#xA;controls&#xA;        # div元素，为input增加合适的间距, 浮动它们缩减空白，再清除浮动&#xA;        controls-row&#xA;                # 排一行，增加合适间距&#xA;&#xA;input-mini&#xA;        input-small&#xA;        input-medium&#xA;        input-large&#xA;        input-xlarge&#xA;        input-xxlarge&#xA;input-sm&#xA;        # input, select, 高度&#xA;        input-lg&#xA;form-group-sm&#xA;        # class为form-group的div, 高度&#xA;        form-group-lg&#xA;        &#xA;input-prepend&#xA;        # 前缀input, 可与input-append组合&#xA;        add-on&#xA;                # span标签&#xA;        btn&#xA;        span2&#xA;                # input标签&#xA;input-append&#xA;&#xA;input-block-level&#xA;        # 块级input&#xA;uneditable-input&#xA;        # span元素模拟不可编辑input&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;小件&#34;&gt;&#xA;  小件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%8f%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;btn&#xA;        # a, button, input&#xA;btn-group&#xA;        # div标签 按钮下拉菜单&#xA;        dropdown-toggle&#xA;                # 要赋加自定义属性data-toggle=&amp;quot;dropdown&amp;quot;来关联执行js&#xA;        dropdown-menu&#xA;                # ul标签&#xA;btn-primary&#xA;        # 按钮样式&#xA;        btn-info&#xA;        btn-success&#xA;        btn-warning&#xA;        btn-danger&#xA;        btn-inverse&#xA;        btn-link&#xA;        btn-default&#xA;btn-lg&#xA;        btn-sm&#xA;        btn-xs&#xA;btn-block&#xA;        # 块级按钮&#xA;&#xA;span1&#xA;        # input元素, select元素&#xA;        span2&#xA;        span3&#xA;        span4&#xA;        span5&#xA;help-inline&#xA;        # span元素，帮助文本&#xA;help-block&#xA;        # span元素, 块显示帮助&#xA;&#xA;img-rounded&#xA;        # img, 图片样式&#xA;        img-circle&#xA;        img-polaroid&#xA;img-responsive&#xA;        # img, 图片响应式&#xA;&#xA;caret&#xA;        # span标签, 下箭头&#xA;close&#xA;        # button, 关闭图&#xA;&#xA;&#xA;list-unstyled&#xA;        # 无样式列表&#xA;dl-horizontal&#xA;        # dl列表水平描述&#xA;pre-scrollable&#xA;        # pre标签内容滚动&#xA;text-overflow&#xA;        # 截断改写数据, 可能会垂直显示&#xA;text-hide&#xA;        # h1, 将元素的文本内容替换为背景图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;导航&#34;&gt;&#xA;  导航&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%bc%e8%88%aa&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;div role=&amp;quot;navigation&amp;quot;&#xA;        # 如果作为导航条, 父元素加属性，或者用nav标签&#xA;        &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot;&#xA;                # nav-pills 改成胶囊样式&#xA;                # nav-stacked 改成垂直&#xA;                # nav-justified 自适应宽度&#xA;                &amp;lt;li role=&amp;quot;presentation&amp;quot; class=&amp;quot;active&amp;quot;&#xA;                        # disabled&#xA;                &amp;lt;li role=&amp;quot;presentation&amp;quot; class=&amp;quot;dropdown&amp;quot;&#xA;                        &amp;lt;a class=&amp;quot;dropdown-toggle&amp;quot; role=&amp;quot;button&amp;quot; &#xA;                                data-toggle=&amp;quot;dropdown&amp;quot;&#xA;                                aria-haspopup=&amp;quot;true&amp;quot; aria-expanded=&amp;quot;false&amp;quot; &#xA;                        &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot;&#xA;&#xA;&amp;lt;nav class=&amp;quot;navbar navbar-default&amp;quot;&#xA;        # 添加navbar-fixed-top可以冻结到顶部&#xA;        ## 设置body{padding-top: 70px;}来使内容不被遮盖&#xA;        ## navbar-fixed-bottom, 同样要设置padding-bottom&#xA;        ## navbar-static-top 向下滚动就消失&#xA;        # navbar-inverse 反色&#xA;        &amp;lt;div class=&amp;quot;container-fluid&amp;quot;&#xA;                &amp;lt;div class=&amp;quot;navbar-header&amp;quot;&#xA;                        &amp;lt;a class=&amp;quot;navbar-brand&amp;quot;&#xA;                                &amp;lt;img alt=&amp;quot;Brand&amp;quot;&#xA;                                        # 图标&#xA;                        &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;navbar-toggle collapsed&amp;quot;&#xA;                                data-toggle=&amp;quot;collapse&amp;quot; &#xA;                                data-target=&amp;quot;#bs&amp;quot;&#xA;                                aria-expanded=&amp;quot;false&amp;quot;&#xA;                                &amp;lt;span class=&amp;quot;icon-bar&amp;quot;&#xA;                                        # 放隐藏菜单的&#xA;                                &amp;lt;span class=&amp;quot;icon-bar&amp;quot;&#xA;                                &amp;lt;span class=&amp;quot;icon-bar&amp;quot;&#xA;                        &amp;lt;a class=&amp;quot;navbar-brand&amp;quot;&#xA;                &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default navbar-btn&amp;quot;&#xA;                        # navbar-btn可以上按钮垂直居中&#xA;                &amp;lt;p class=&amp;quot;navbar-text&amp;quot;&#xA;                &amp;lt;div class=&amp;quot;collapse navbar-collapse&amp;quot; id=&amp;quot;bs&amp;quot;&#xA;                        &amp;lt;ul class=&amp;quot;nav navbar-nav&amp;quot;&#xA;                                &amp;lt;li&amp;gt;&amp;lt;a&#xA;                        &amp;lt;form class=&amp;quot;navbar-form navbar-left&amp;quot; role=&amp;quot;search&amp;quot;&#xA;                                # navbar-form自动垂直对齐，折叠&#xA;                                # navbar-left 让正确对齐，由pull-left mixin而来&#xA;                                &amp;lt;div class=&amp;quot;form-group&amp;quot;&#xA;                                        &amp;lt;input class=&amp;quot;form-control&amp;quot;&#xA;                                &amp;lt;button class=&amp;quot;btn btn-default&amp;quot;&#xA;                        &amp;lt;ul class=&amp;quot;nav navbar-nav navbar-right&amp;quot;&#xA;                        &amp;lt;p class=&amp;quot;navbar-text navbar-right&amp;quot;&#xA;                                # 不支持多个navbar-right&#xA;                                &amp;lt;a class=&amp;quot;navbar-link&amp;quot;&#xA;&#xA;&amp;lt;ol class=&amp;quot;breadcrumb&amp;quot;&#xA;        # 面包屑&#xA;        &amp;lt;li&#xA;        &amp;lt;li class=&amp;quot;active&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;图标&#34;&gt;&#xA;  图标&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be%e6%a0%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;icon-white&#xA;        # 反色为白色&#xA;fa-dashboard&#xA;        # 配合fa使用                &#xA;        fa-fw&#xA;                # 小左箭头&#xA;fa-lg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;默认渲染&#34;&gt;&#xA;  默认渲染&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%bb%98%e8%ae%a4%e6%b8%b2%e6%9f%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt; ... &amp;lt;h6&amp;gt;&#xA;&amp;lt;small&amp;gt;&#xA;&amp;lt;p&amp;gt;&#xA;&amp;lt;mark&amp;gt;&#xA;&amp;lt;del&amp;gt;&#xA;&amp;lt;s&amp;gt;&#xA;&amp;lt;ins&amp;gt;&#xA;&amp;lt;u&amp;gt;&#xA;&amp;lt;small&amp;gt;&#xA;&amp;lt;strong&amp;gt;&#xA;&amp;lt;em&amp;gt;&#xA;&amp;lt;abbr&amp;gt;&#xA;&amp;lt;address&amp;gt;&#xA;&amp;lt;blockquote&amp;gt;&#xA;        &amp;lt;p&amp;gt;&#xA;        &amp;lt;footer&amp;gt;&#xA;                &amp;lt;cite&amp;gt;&#xA;&amp;lt;ul&amp;gt;&#xA;        &amp;lt;li&amp;gt;&#xA;&amp;lt;ol&amp;gt;&#xA;        &amp;lt;li&amp;gt;&#xA;&amp;lt;dl&amp;gt;&#xA;        &amp;lt;dt&amp;gt;&#xA;        &amp;lt;dd&amp;gt;&#xA;&amp;lt;code&amp;gt;&#xA;&amp;lt;kbd&amp;gt;&#xA;&amp;lt;pre&amp;gt;&#xA;&amp;lt;var&amp;gt;&#xA;&amp;lt;samp&amp;gt;&#xA;        # 程序输出&#xA;属性&#xA;        aria-label&#xA;                # input元素, 替代label&#xA;        aria-labelledby&#xA;        title&#xA;                # 辅助功能阅读&#xA;        aria-describedby&#xA;                # input 辅助阅读&#xA;        disabled&#xA;        readonly&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;less&#34;&gt;&#xA;  less&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#less&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;@baseFontSize&#xA;        @font-size-base&#xA;        # 全局font-size基准，计算出所有页面元素的margin, padding, line-height, 改变bootstrap默认样式&#xA;@baseLineHeight&#xA;        @line-height-base&#xA;        # 同上, line-height基准&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;table-responsive&amp;quot;&amp;gt;&#xA;        &amp;lt;table class=&amp;quot;table table-striped table-bordered table-hover&amp;quot;&amp;gt;&#xA;                # table table-condensed 紧凑型表格&#xA;                &amp;lt;thead&amp;gt;&#xA;                        &amp;lt;tr&amp;gt;&#xA;                                &amp;lt;th&amp;gt;标题&#xA;                &amp;lt;tbody&amp;gt;&#xA;                        &amp;lt;tr class=&amp;quot;active&amp;quot;&amp;gt;&#xA;                                # success info warning danger&#xA;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;scrollspy&#xA;    介绍&#xA;            监测滚动到目前页面锚点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;bootInit&#xA;    介绍&#xA;            检测bootstrap标签语法，不支持扩展插件&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Threejs</title>
      <link>https://runout.run/docs/middleware/library_frontend/threejs/</link>
      <pubDate>Thu, 11 Oct 2018 07:58:16 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/threejs/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;协调程序加载项的类库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;var preload = new createjs.LoadQueue(false, &amp;quot;assets/&amp;quot;);&#xA;var plugin= {&#xA;        getPreloadHandlers: function(){&#xA;                return{&#xA;                        types: [&amp;quot;image&amp;quot;],&#xA;                        callback: function(src){&#xA;                                var id = src.toLowerCase().split(&amp;quot;/&amp;quot;).pop().split(&amp;quot;.&amp;quot;)[0];&#xA;                                var img = document.getElementById(id);&#xA;                                return {tag: img};&#xA;                        }&#xA;                }&#xA;        }&#xA;}&#xA;preload.installPlugin(plugin);&#xA;preload.loadManifest([&#xA;        &amp;quot;Autumn.png&amp;quot;,&#xA;        &amp;quot;BlueBird.png&amp;quot;,&#xA;        &amp;quot;Nepal.jpg&amp;quot;,&#xA;        &amp;quot;Texas.jpg&amp;quot;&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;涉及dom&#34;&gt;&#xA;  涉及dom&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%89%e5%8f%8adom&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;        window.innerWidth&#xA;        window.innerHeight&#xA;事件&#xA;        window.addEventListener(&#39;resize&#39;, onWindowResize, false);&#xA;                function onWindowResize(){&#xA;                        camera.aspect = window.innerWidth / window.innerHeight;&#xA;                        camera.updateProjectionMatrix();&#xA;                        renderer.setSize(window.innerWidth, window.innerHeight);&#xA;                        controls.handleResize();&#xA;                }&#xA;三大组件&#xA;    场景(scene)&#xA;            var scene = new THREE.Scene();&#xA;    相机(camera)&#xA;            var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);                                        # 透视相机&#xA;    渲染器(renderer)&#xA;            var renderer = new THREE.WebGLRenderer();&#xA;            renderer.setSize(window.innerWidth, window.innerHeight);&#xA;            document.body.appendChild(renderer.domElement);                        # domElement 是画布&#xA;            render( scene, camera, renderTarget, forceClear )                        ＃ renderTarget默认是前面设置的renderer  size, forceClear自动清除(设置为false也会清除)&#xA;版本&#xA;    THREE.VERSION&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;renderer&#34;&gt;&#xA;  renderer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#renderer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);                # 透视摄像机&#xA;    camera.position.x = 0;&#xA;    camera.position.y = 0;&#xA;    camera.position.z = 600;                                                                # 相机位置&#xA;    camera.up.x = 0;&#xA;    camera.up.y = 1;&#xA;    camera.up.z = 0;                                                                        # 相机&amp;quot;上&amp;quot;的方向&#xA;    camera.lookAt({x:0, y:0, z:0});                                                                # 视野中心坐标&#xA;    camera.setViewOffset(fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight)&#xA;            # 相机的有效显示部分&#xA;&#xA;WebGLRenderer &#xA;    renderer = new THREE.WebGLRenderer({ antialias: false});&#xA;                    # 抗锯齿为false。true时显示更清晰，更耗cpu&#xA;            renderer.setClearColorHex( 0x000000, 1);&#xA;            renderer.setSize(window.innerWidth, window.innerHeight);&#xA;                    # 设置渲染器的宽度和高度&#xA;            renderer.autoClear = false;&#xA;            renderer.sortObjects = false;&#xA;            &#xA;            renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);&#xA;                    # 设置一个渲染目标&#xA;            renderTarget.minFilter = THREE.LinearFilter;&#xA;            renderTarget.magFilter = THREE.NearestFilter;&#xA;            postBloom = new BloomEffect(renderer, renderTarget, window.innerWidth, window.innerHeight, 4);&#xA;&#xA;            renderer.shadowMapEnabled = true;&#xA;                    # 开启显示阴影&#xA;                    ## 要显示阴影，还要设置物体castShadow = true; receiveShadow = true;&#xA;                    ## shadowMap是一张记录每个像素用于比较遮挡关系的texture&#xA;            renderer.shadowMapSoft = true;&#xA;                    # 可以使阴影更加平滑，产生更少的锯齿&#xA;            renderer.shadowCameraNear = 3;&#xA;            renderer.shadowCameraFar = camera.far;&#xA;            renderer.shadowCameraFov = 50;&#xA;                    # 表示摄像机近平面、远平面、角度的值。在摄像机范围内的物体产生阴影&#xA;            renderer.shadowMapBias = 0.0039;&#xA;            renderer.shadowMapDarkness = 0.5;&#xA;                    # 表示阴影的透明度, 0是完全透明&#xA;            renderer.shadowMapWidth = 512;&#xA;            renderer.shadowMapHeight = 512;&#xA;                    # 指定阴影渲染面的大小&#xA;                    ## 根据shadermap原理，阴影需要先绘制在一个缓冲区中，再根据缓冲区计算阴影。这就是缓冲区的大小。&#xA;&#xA;            container = document.createElement(&#39;div&#39;);&#xA;            document.body.appendChild(container);&#xA;            container.appendChild(renderer.domElement);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;camera&#34;&gt;&#xA;  camera&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#camera&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    camera = new THREE.Camera(60, 1, 1, 6500);&#xA;    camera.position.z = -85;&#xA;    camera.position.y = 40;&#xA;    camera.aspect = window.innerWidth / window.innerHeight;&#xA;&#xA;    cameraTarget = new THREE.Object3D();&#xA;            # 相机目标&#xA;    cameraTarget.position.y = 10;&#xA;    cameraTarget.position.z = 6000;&#xA;    camera.target = cameraTarget;&#xA;&#xA;    camera.updateProjectionMatrix();&#xA;PerspectiveCamera&#xA;    THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);                # 透视摄像机&#xA;    camera.position.x = 0;&#xA;    camera.position.y = 0;&#xA;    camera.position.z = 600;                                                                # 相机位置&#xA;    camera.up.x = 0;&#xA;    camera.up.y = 1;&#xA;    camera.up.z = 0;                                                                        # 相机&amp;quot;上&amp;quot;的方向&#xA;    camera.lookAt({x:0, y:0, z:0});                                                                # 视野中心坐标&#xA;    camera.setViewOffset(fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight)&#xA;            # 相机的有效显示部分&#xA;OrthographicCamera&#xA;    OrthographicCamera(left, right, top, bottom, near, far)&#xA;            # 左右上下远近&#xA;controls&#xA;    contorls = new THREE.FirstPersonControls(camera);&#xA;    contorls.movementSpeed = 20;                                        # 移动速度&#xA;    controls.lookSpeed = 0.05;                                                # 转头速度&#xA;    controls.lookVertical = true;                                                # 是否允许抬头或低头&#xA;PathControls        # 路径相机&#xA;    controls = new THREE.PathControls(camera);&#xA;    controls.createDebugPath = true;&#xA;            # 是否显示轨道&#xA;            ## scene.add(controls.debugPath)来添加显示&#xA;    controls.waypoints = [[-500, 0, 0], [0, 200, 0], [500, 0, 0]];&#xA;            # 路径的转折点，非转折点用插值来计算&#xA;    controls.duration = 28;&#xA;            # 轨道的一头到另一头的运动时间(ms), 默认是10 * 1000&#xA;    controls.useConstantSpeed =true;&#xA;            # 设置为匀速运行&#xA;    controls.lookSpeed = 0.06;&#xA;            # 转头速度, 默认是0.005。数越大，转头越快&#xA;            ##页面显示帧数越快, 转头越快&#xA;    controls.lookVertical = true;&#xA;            # 是否可以上下转头&#xA;    controls.lookHorizontal = true;&#xA;            # 是否可以左右转头&#xA;    controls.verticalAngleMap = {srcRange: [0, 2 * Math.PI], dstRange:[1.1, 3.8]};&#xA;    controls.horizontalAngleMap = {srcRange: [0, 2 * Math.PI], dstRange: [0.3, Math.PI - 0.3]};&#xA;    controls.lon = 180;&#xA;&#xA;    controls.init();&#xA;    scene.add( controls.animationParent );&#xA;            # 用THREE.js提供的Animation类来插值改变相机位置和方向&#xA;            ## pathControls类中有initAnimationPath函数将动作转换为关键帧，存到了parentAnimation属性中&#xA;            ### THREE.AnimationHandler中的add函数，把scene中的parentAnimation中的关键帧动作键入THREE.JS的动画引擎中。动画引擎会自动在关键帧之间插值，来决定关键帧中物体(如相机)的位置、大小、缩放等。&#xA;&#xA;    function  render(){&#xA;            controls.update(delta);&#xA;            THREE.AnimationHandler.update(delta);&#xA;                    ### 让动画引擎动起来&#xA;    }&#xA;TrackballControls   # 轨迹球相机&#xA;    介绍&#xA;            追踪相机, 轨迹球相机&#xA;    作用&#xA;            控制相机，左键旋转，右键平移，滚轮缩放&#xA;    api&#xA;            THREE.TrackballControls = function (object, domElement)&#xA;                    # object一般是传入相机这个变量&#xA;                    # domElement为在哪个div中监听鼠标事件, 默认为document&#xA;&#xA;    controls = new THREE.TrackballControls(camera);&#xA;            # 传入相机作为参数来控制相机&#xA;    controls.rotateSpeed = 5.0;&#xA;            # 旋转的速度&#xA;    controls.zoomSpeed = 5;&#xA;            # 缩放的速度&#xA;    controls.panSpeed = 2;&#xA;            # 平移的速度&#xA;    controls.noZoom = false;&#xA;            # 不允许放大&#xA;    controls.noPan = false;&#xA;            # 不允许右键摇镜头&#xA;    controls.staticMoving = false;&#xA;            #  是否静态移动, false时移动镜头会有弹性&#xA;    controls.dynamicDampingFactor = 0.3;&#xA;            # 阻力系数&#xA;            ## 旋转时慢慢停下来是这个系数起作用&#xA;&#xA;    function animate(){&#xA;            requestAnimationFrame(animate);&#xA;            controls.update();&#xA;                    # 完成更新相机属性的工作&#xA;            rederer.render(scene, camera);&#xA;            stats.update();&#xA;    }&#xA;FlyControls     # 飞行相机&#xA;FirstPersonControls     # 第一人称相机&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;scene&#34;&gt;&#xA;  scene&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#scene&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    scene = new THREE.Scene();  # 场景&#xA;            scene.add(meshCube);&#xA;            scene.add(light);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;light&#34;&gt;&#xA;  light&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#light&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    // light.position.x = x;&#xA;    light.position.set(0, 0, 300).normalize();;        &#xA;            # 坐标, 向量化为1&#xA;&#xA;    scene.add(light);                        &#xA;PointLight  # 点光源&#xA;    var light = new THREE.PointLight(0x00FF00);&#xA;DirectionalLight    # 方向光&#xA;    var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125);&#xA;            # 0.125是颜色的密度, 和透明度差不多, 这里表示很淡很淡的白色&#xA;    scene.add(dirLight)&#xA;AmbientLight    # 环境光&#xA;    scene.add(new THREE.AmbientLight(0x111111));&#xA;SpotLight   # 聚光灯&#xA;    light = new THREE.SpotLight(0xffffff, 1.25);&#xA;        light.target.position.set(0, 0, 0);&#xA;        light.castShadow = true;&#xA;                # 显现阴影，默认不显现&#xA;                ## 显现阴影还要对renderer进行设置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;object&#34;&gt;&#xA;  object&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#object&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;mesh&#34;&gt;&#xA;  mesh&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mesh&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    var mesh = THREE.Mesh(geometry, material);                                                                # mesh模型&#xA;            mesh.position.x= x;&#xA;            mesh.rotation.x = rx;&#xA;            scene.add(meshCube);&#xA;    方法&#xA;            mesh1.addChild(mesh2)&#xA;                    # mesh2加入mesh1, 组成一个Mesh&#xA;            &#xA;    api&#xA;            mesh.scale.multiplyScalar(0.35)&#xA;                    # 让x y z方向缩放系数到原模型的0.35倍&#xA;line&#xA;    THREE.Line( geometry, material, THREE.LinePieces );                                                ＃ 线&#xA;            scene.add(line);&#xA;    例子&#xA;            var line_material = new THREE.LineBasicMaterial({color: 0x303030}),&#xA;            geometry = new THREE.Geometry(),&#xA;            floor = -75, step = 25;&#xA;            for( var i = 0; i &amp;lt;= 40; i++){&#xA;                    geometry.vertices.push(new THREE.Vector3(-500, floor, i * step - 500));&#xA;                    geometry.vertices.push(new THREE.Vector3(500, floor, i * step - 500));&#xA;&#xA;                    geometry.vertices.push(new THREE.Vector3(i * step - 500, floor,- 500));&#xA;                    geometry.vertices.push(new THREE.Vector3(i * step - 500, floor, 500));&#xA;            }&#xA;            var line = new THREE.Line(geometry, line_material, THREE.LinePieces);&#xA;            scene.add(line);&#xA;MorphAnimMesh&#xA;    介绍&#xA;            动画网格模型&#xA;            包含几个动画帧(一极动画模型)，通过播放帧来看动画。&#xA;            可以设置帧数，播放到哪一帧，顺播还是倒播。&#xA;    THREE.MorphAnimMesh = function (geometry, material){&#xA;            THREE.Mesh.call(this, geometry, material);&#xA;                    # 调用基类构造函数&#xA;            this.duration = 1000;&#xA;                    # 完成所有帧的时间(milliseconds)&#xA;            this.mirroredLoop = false;&#xA;                    # 表示镜像循环(是否循环播放)&#xA;            this.time = 0;&#xA;                    # 当前播放时间&#xA;            this.lastKeyframe = 0;&#xA;                    # 上一帧&#xA;            this.currentKeyframe = 0;&#xA;                    # 当前播放的帧&#xA;            this.direction = 1;&#xA;                    # 表示从前向后播放, -1是从后向前&#xA;            this.directionBackwards = false;&#xA;                    # 是否倒播&#xA;            this.setFrameRange(0, this.geometry.morphTargets.length - 1);&#xA;                    # 设置最小帧和最大帧&#xA;                    ## 这里开始帧是0, 结束帧是 总帧数 - 1&#xA;    }&#xA;    方法&#xA;            THREE.MorphAnimMesh.prototype.setDirectionForward = function(){&#xA;                    this.direction = 1;&#xA;                            # 1是前进, -1是后退&#xA;                    this.directionBackwords = false;&#xA;                            # false表示前进&#xA;            }&#xA;                    # 计算下一帧是哪一帧时，根据上面两个变量计算&#xA;            THREE.MorphAnimMesh.prototype.setDirectionBackward&#xA;            THREE.MorphAnimMesh.prototype.setAnimationLabel = function(label, start, end){&#xA;                    if( !this.geometry.animations) this.geometry.animation = {};&#xA;                    this.geometry.animations[label] = {start: start, end: end};&#xA;            }&#xA;                    # 设置帧分组标签(为了给每组设置不同的播放速度)&#xA;            THREE.MorphAnimMesh.playAnimation(&#39;A&#39;, 33)&#xA;                    # 播放标签为&#39;A&#39;的组动画，帧数(fps)为33帧/秒&#xA;            THREE.MorphAnimMesh.prototype.updateAnimation = function(delta&#xA;                    # delta表示实际浏览器每次刷新的间隔时间&#xA;                    # 作用: 主要更新lastKeyframe&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;mesh组件&#34;&gt;&#xA;  mesh组件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mesh%e7%bb%84%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;geometry&#34;&gt;&#xA;  geometry&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#geometry&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        geometry表示形状&#xA;THREE.Geometry();&#xA;        # 空几何体&#xA;        geometry.vertices.push(p1);&#xA;        # p1是一个点&#xA;        geometry.vertices.push(p2);&#xA;        geometry.colors.push( color1, color2 );&#xA;&#xA;属性&#xA;        vertices&#xA;                # 顶点数组&#xA;        colors&#xA;        morphColors&#xA;                # 加载json模型后存储颜色的地方&#xA;        faces        &#xA;                # 面数组&#xA;                color&#xA;        faceVertexUvs&#xA;                # 面法线数组&#xA;                方法&#xA;                        set                # 设置纹理坐标&#xA;                                faceVertexUvs[0][2][0].set(0, 0)&#xA;                                faceVertexUvs[0][2][1].set(0, 0)&#xA;                                faceVertexUvs[0][2][2].set(0, 0)&#xA;                                faceVertexUvs[0][2][3].set(0, 0)&#xA;                                        # 设置第2个面(顶面)的纹理坐标全部为0，这样就去掉了这个面的纹理坐标&#xA;                                        # 第一维表示第几种纹理，第二维表示第几个面，第三维表示第几个顶点的纹理坐标&#xA;BufferGeometry&#xA;    一般编程中&#xA;            物体的形状可以用一个类Geometry来表示&#xA;            物体顶点内容如果放到缓冲区中，可以new分配连续的内存&#xA;            物体和内存是分离的&#xA;    Tree.js中&#xA;            物体和内存统一起来，形成了THREE.BufferGeometry&#xA;            THREE.BufferGeometry = Buffer + THREE.Geometry&#xA;            BufferGeometry是自由度最高的geometry类型&#xA;                    自由指定每个顶点的位置、颜色、法线(影响光照)&#xA;                    Buffer就是将顶点位置数组、顶点颜色数组等放在一个缓冲区中，加快加载与运行速度。&#xA;                            Buffer的这些缓冲区存储在BufferGeometry的属性attributes集合对象里面&#xA;                                    # attributes初始化时为空 this.attributes = {};&#xA;    api&#xA;            var geometry = new THREE.BufferGeometry();&#xA;                    # THREE.BufferGeometry = function()&#xA;IcosahedronGeometry&#xA;    二十面体&#xA;&#xA;    radius = 200&#xA;    geometry = new THREE.IcosahedronGeometry(radius, 1);&#xA;    faceIndices = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];&#xA;    for(var i = 0; i &amp;lt; geometry.faces.length; i++){&#xA;            f = geometry.faces[i];&#xA;                    # 得到第i个面&#xA;            n = (f instanceof THREE.Face3) ? 3 : 4;&#xA;                    # 判断每个面由几个点组成&#xA;                    # 每个点可以由f.a, f.b, f.c, f.d得到&#xA;            for(var j = 0; j &amp;lt; n; j++){&#xA;                    vertexIndex = f[faceIndices[j]];&#xA;                            # 得到点在geometry中的索引&#xA;                    p = geometry.vertices[vertexIndex];&#xA;                            # 得到点&#xA;                    f.vertexColors[j] = color;&#xA;                            # 给面的顶点赋值&#xA;                            ## 顶点默认颜色为白色&#xA;            }&#xA;    }&#xA;SphereGeometry&#xA;    var geometry = new THREE.SphereGeometry(70, 32, 16);&#xA;            # 70是半径, 32和16表示横向和纵向球体由多少线分割&#xA;BoxGeometry&#xA;    介绍&#xA;            原来的CubeGeometry&#xA;    长立方体&#xA;            THREE.CubeGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments)&#xA;                    # 参数分别表示x y z轴长度和分别在x y z轴上被分成了几份&#xA;CylinderGeometry&#xA;    圆柱体&#xA;            THREE.CylinderGeometry(100, 150, 400);&#xA;PlaneGeometry   # 平面&#xA;TextGeometry&#xA;    介绍&#xA;            可以从字体文件中生成字体几何体&#xA;&#xA;    THREE.TextGeometry = function(text, parameters)&#xA;            # text是要显示的文字&#xA;            # parameters包括&#xA;            ## size: &amp;lt;float&amp;gt; 字体大小, 如80号是小字体&#xA;            ## height: &amp;lt;float&amp;gt; 厚度&#xA;            ## curveSegments: &amp;lt;int&amp;gt; 一条曲线上点的数目, 越多越精细&#xA;            ## font: &amp;lt;string&amp;gt; 使用字体的名称&#xA;            ## weight: &amp;lt;string&amp;gt; `取值normal或bold, 如果字体中没有bold, 整个程序会崩溃&#xA;            ## style: &amp;lt;string&amp;gt; 取值normal或italics(斜体), 没有italics也会崩溃&#xA;&#xA;    使用&#xA;            在typeface上转换自己的字体&#xA;                    http://typeface.neocracy.org/fonts.html&#xA;                    # 要求字体的签名是TrueType或OpenType&#xA;                    # 在Convert Font页面选择要转换的字,可以加快转换,也减少生成js文件的大小&#xA;            var text3d = new THREE.TextGeometry(&#39;要显示的字&#39;, {&#xA;                    size: 120,&#xA;                    height: 30,&#xA;                    curveSegments: 3,&#xA;                    font: &#39;simhei&#39;,&#xA;                    face: &#39;simhei&#39;,&#xA;                    weight: &#39;normal&#39;&#xA;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;material&#34;&gt;&#xA;  material&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#material&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    THREE.LineBasicMaterial( parameters );                                                        # 线材质&#xA;        参数&#xA;                Color：线条的颜色，用16进制来表示，默认的颜色是白色。&#xA;                Linewidth：线条的宽度，默认时候1个单位宽度。&#xA;                Linecap：线条两端的外观，默认是圆角端点，当线条较粗的时候才看得出效果，如果线条很细，那么你几乎看不出效果了。&#xA;                Linejoin：两个线条的连接点处的外观，默认是“round”，表示圆角。&#xA;                VertexColors：定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值。（如果关于插值不是很明白，可以QQ问我，QQ在前言中你一定能够找到，嘿嘿，虽然没有明确写出）。&#xA;                Fog：定义材质的颜色是否受全局雾效的影响。&#xA;                    uniforms: 传入着色器中的固定变量, 如&#xA;                            {&#xA;                                    scale: {type: &#39;v2&#39;, value: new THREE.Vector2()}&#xA;                            }&#xA;    THREE.MeshBasicMaterial({color: 0x00ff00});                                                        # mesh材质&#xA;MeshBasicMaterial&#xA;    介绍&#xA;            是three.js中最基本的材质&#xA;    功能&#xA;            将mesh渲染成线框模式或平面模式&#xA;                    # 平面模式指表面渲染比较平整&#xA;    api&#xA;            new THREE.MeshBasicMaterial({&#xA;                    color: 0xffaa00, &#xA;                    transparent: true, &#xA;                            # 标志为true时颜色A分量(alpha)才起作用&#xA;                    blending: THREE.AdditiveBlending&#xA;                            # 混合方式, 对应OpenGL ES中不同混合方式。表示怎么与背景结合&#xA;                            ## OpenGL中有一个颜色缓冲区，存放每次渲染的颜色(目标颜色)，新颜色(源颜色)可以与它混合，形成最新的颜色。&#xA;                            ## 可以是THREE.NoBlending = 0&#xA;                            ### 不混合。直接用新颜色覆盖以前的颜色&#xA;                            ## THREE.NormalBlending = 1&#xA;                            ### 将源颜色与目标颜色通过透明度正常混合&#xA;                            ## THREE.AdditiveBlending = 2&#xA;                            ### 加法混合&#xA;                            ## THREE.SubtractiveBlending = 3&#xA;                            ### 减法混合&#xA;                            ## THREE.MultiplyBlending = 4&#xA;                            ### 乘法混合&#xA;                            ## THREE.CustomBlending = 5&#xA;                            ### 自定义混合&#xA;            });&#xA;            new THREE.MeshBasicMaterial({&#xA;                    color: 0xffaa00, &#xA;                    wireframe: true&#xA;            });&#xA;            new THREE.MeshBasicMaterial({&#xA;                    map: texture, &#xA;                    transparent: true&#xA;            });&#xA;&#xA;MeshNormalMaterial&#xA;    只支持以THREE.FlatShading模式来渲染Mesh, 不支持将Mesh渲染为线框模式&#xA;&#xA;MeshLambertMaterial&#xA;    在灰暗或不光滑的表面产生的均匀散射而形成的材质类型。向各个方向均反射光线。如白纸&#xA;&#xA;    new THREE.MeshLambertMaterial({&#xA;            color: 0xff6600,                                # 材质的颜色&#xA;            ambient: 0xff2200,                                # 受环境光情况&#xA;            envMap: textureCube,                                # 环境纹理，会将环境纹理映射到材质身上&#xA;            combine: THREE.MixOperation,                # 与环境材质之间的混合方式&#xA;            reflectivity: 0.3                                        # 对反射光的反射系数&#xA;    })&#xA;    new THREE.MeshLambertMaterial({map:texture, transparent: true})&#xA;            # 带透明的兰伯特材质, 可以看到球体另一边的颜色&#xA;    new THREE.MeshLambertMaterial({color: 0xdddddd, shading: THREE.FlatShading})&#xA;            # 灰色，非平滑&#xA;    new THREE.MeshLambertMaterial({color: 0xdddddd, shading: THREE.SmoothShading})&#xA;            # 灰色，平滑&#xA;    new THREE.MeshLambertMaterial({color: 0x666666, emissive: 0xff0000, ambient: 0x000000, shading: THREE.SmoothShading})&#xA;            # emissive表示自发光&#xA;&#xA;MeshPhongMaterial&#xA;    有明显高光区，适用于湿滑的，表面具有光泽的物体。如: 玻璃，水滴等&#xA;    特点&#xA;            会产生高光(球某一点在光线下特别亮)&#xA;    THREE.MeshPhongMaterial({ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.FloatShading})&#xA;&#xA;    THREE.MeshPhongMaterial({ambient:0x030303, color:0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading, map: texture, transparent: true})&#xA;&#xA;    THREE.MeshPhongMaterial({color: 0x000000, specular: 0x666666, emissive: 0xff0000, ambient: 0x000000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.9, transparent: true})&#xA;MeshDepthMaterial&#xA;    支持一些尝试测试的效果&#xA;MeshFaceMaterial&#xA;    面材质，它是一个材质数组。&#xA;    有且仅有一个成员数组materials, 用来存放一组材质。&#xA;            这组材质会被geometry的不同面所使用，来做到同一个物体不同面使用不同材质的效果。&#xA;            每一个面使用什么材质由geometry中的索引决定&#xA;ShaderMaterial&#xA;    使用&#xA;            material = new THREE.ShaderMaterial({&#xA;                    uniforms: uniforms,&#xA;                            # 一致变量数组，传递到两个着色器中使用&#xA;                    vertexShader: document.getElementById(&#39;vertexShader&#39;).textContent,&#xA;                            # 顶点着色器的代码&#xA;                    fragmentShader: document.getElementById(&#39;fragmentShader&#39;).textContent&#xA;                            # 片元着色器代码&#xA;            });&#xA;            uniforms = {&#xA;                    time: {type: &#39;f&#39;, value: 1.0},&#xA;                            # 表示时间， f 代表浮点型&#xA;                    resolution: {type: &#39;v2&#39;, value: new THREE.Vector2() }&#xA;                            # 表示浏览器窗口的宽度和高度，v2代表二维向量&#xA;            }                # 该一致变量在绘制过程中不会改变，在顶点shader与片元shader之间用相同名字来共享&#xA;                            ## 一致变量在不同图元中会改变&#xA;            uniforms.resolution.value.x = window.innerWidth&#xA;            uniforms.time.value += 0.005&#xA;                            # 通过value改变uniforms中变量的值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;texture&#34;&gt;&#xA;  texture&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#texture&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;例子&#xA;        var geometry = new THREE.PlaneGeometry( 500, 300, 1, 1 );&#xA;        geometry.vertices[0].uv = new THREE.Vector2(0,0);&#xA;        geometry.vertices[1].uv = new THREE.Vector2(2,0);&#xA;        geometry.vertices[2].uv = new THREE.Vector2(2,2);&#xA;        geometry.vertices[3].uv = new THREE.Vector2(0,2);&#xA;                                        # 平面有4个纹理坐标。由顶点的成员nv表示，nv是一个二维向量，对应到纹理坐标&#xA;&#xA;        var texture = THREE.ImageUtils.loadTexture(&amp;quot;textures/a.jpg&amp;quot;,null,function(t){});&#xA;        var material = new THREE.MeshBasicMaterial({map:texture});&#xA;&#xA;        var mesh = new THREE.Mesh( geometry,material );&#xA;        scene.add( mesh );&#xA;&#xA;例子2(canvas)&#xA;        var geometry = new THREE.CubeGeometry(150, 150, 150);&#xA;        texture = new THREE.Texture(canvas);&#xA;                                        # 默认情况下，纹理被均匀地分配到四边形的各个顶点上。&#xA;        var material = new THREE.MeshBasicMaterial({map: texture});&#xA;        texture.needsUpdate = true;&#xA;                                        # 如果canvas中有动画的话，要设置纹理更新。而且每requestAnimationFrame渲染一帧动画，都要对texture.needsUpdate设置一遍true。如果不更新，显示黑色正方体。&#xA;                                        ## 黑色正方体原因: js异步运行,canvas绘制时钟需要时间, three.js已经开始渲染图形了，这时候canvas没有绘制完成，就显示材质本身的颜色。&#xA;        mesh = new THREE.Mesh(geometry, material);&#xA;        scene.add(mesh);&#xA;Mapping&#xA;    UVMapping&#xA;Filter&#xA;    LinearFilter&#xA;Wrapping&#xA;    RepeatWrapping&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;color&#34;&gt;&#xA;  Color&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#color&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;THREE.Color()&#xA;THREE.Color( 0x444444 );       &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;vector3&#34;&gt;&#xA;  Vector3&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#vector3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;THREE.Vecotor3(4,8,9);                                                                        &#xA;THREE.Vector3();&#xA;point1.set(4,8,9);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;quaternion&#34;&gt;&#xA;  Quaternion&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#quaternion&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍　&#xA;        四元组&#xA;api&#xA;        THREE.Quaternion = function(x, y, z, w){&#xA;                this._x = x || 0;&#xA;                this._y = y || 0;&#xA;                this._z = z || 0;&#xA;                this._w = (w !== undefined) ? w : 1;&#xA;        }&#xA;        setFromAxisAngle: function(axis, angle)&#xA;                # Quaternion的静态方法&#xA;                ## axis是向量，表示轴, angle表示弧度&#xA;                ## 返回一个四元组&#xA;        setFromEuler: function(euler, update)&#xA;                # 欧拉角转为四元组&#xA;        setFromRotationMatrix: function(m)&#xA;                # 把矩阵转为欧拉角&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;fog&#34;&gt;&#xA;  fog&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fog&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;scene.fog = new THREE.Fog(0x999999, 0.1, 8000);&#xA;THREE.Fog = function(hex, near, far)&#xA;    # hex为颜色, near是雾开始的地方, far是雾结束的地方&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;object3d&#34;&gt;&#xA;  Object3D&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#object3d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;new THREE.Object3D();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;ray&#34;&gt;&#xA;  Ray&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ray&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        一条射线&#xA;&#xA;ray = new THREE.Ray(camera.position);&#xA;        # 传入起点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;particle&#34;&gt;&#xA;  particle&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#particle&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;particleSystem = new THREE.ParticleSystem(particles, material);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;utils&#34;&gt;&#xA;  utils&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#utils&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;ImageUtils&#xA;    loadTextureCube([&amp;quot;&amp;quot;, &amp;quot;&amp;quot;]);&#xA;ShaderUtils&#xA;    var shader = lib[&amp;quot;cube&amp;quot;]&#xA;UniformsUtils&#xA;    clone(shader.uniforms)&#xA;GeometryUtils&#xA;    merge = function(geometry1, object2/* mesh | geometry */){ ... }&#xA;        # geometry1是合成后的对象，第二个是要合并的对象，如果是mesh，就取mesh中的geometry对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;filter&#34;&gt;&#xA;  filter&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#filter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;LinearFilter&#xA;NearestFilter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;effect&#34;&gt;&#xA;  effect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#effect&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;BloomEffect&#xA;    postBloom = new BloomEffect(renderer, renderTarget, window.innerWidth, window.innerHeight, 4);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;helper&#34;&gt;&#xA;  helper&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#helper&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 辅助对象一键打开或关闭&#xA;        # 将所有辅助对象放到helps数组中&#xA;    var help = [];&#xA;    helps.push(helper);&#xA;    helps.push(faceNormalsHelper);&#xA;    helps.push(vertexNormalsHelper);&#xA;&#xA;    window.addEventListener(&#39;keydown&#39;, onKeyDown, false);&#xA;&#xA;    function setVisible(visible){&#xA;            for(var i = 0; i &amp;lt; helps.length; i++){&#xA;                    helps[i].visible = visible;&#xA;            }&#xA;    }&#xA;&#xA;    function onKeyDown(event){&#xA;            switch(event.keyCode){&#xA;                    case 65: /*A*/&#xA;                            setVisible(false);&#xA;                            break;&#xA;                    case 83: /*S*/&#xA;                            setVisible(true);&#xA;                            break;&#xA;            }&#xA;    }&#xA;GridHelper&#xA;    介绍&#xA;            网格辅助类, 绘制网格和网格线颜色&#xA;&#xA;    api&#xA;            THREE.GridHelper = function(size, step)&#xA;                    # size定义网格正方形边长, step是间隔距离&#xA;    使用&#xA;            var helper = new THREE.GridHelper(200, 10);&#xA;            helper.setColors(0x0000ff, 0x808080);&#xA;                    # 第一个是x y z轴颜色, 第二个是其它线条颜色&#xA;            helper.position.y = -150;&#xA;            scene.add(helper);&#xA;BoxHelper&#xA;    介绍&#xA;            长方体包围盒, 椭圆包围盒, 包围物体用于检查碰撞或辅助设计中表示选中&#xA;&#xA;    使用&#xA;            var boxHelper = new THREE.BoxHelper(mesh);&#xA;            scene.add(boxHelper);&#xA;FaceNormalsHelper&#xA;    介绍&#xA;            辅助画法线&#xA;&#xA;    api&#xA;            FaceNormalsHelper(object, size, hex, linewidth)&#xA;&#xA;    使用&#xA;            var faceNormalsHelper = new THREE.FaceNormalsHelper(mesh, 10)&#xA;VertexNormalsHelper&#xA;    介绍&#xA;            辅助画顶点法线&#xA;WireframeHelper&#xA;    介绍&#xA;            将模型转换为线框图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;物件&#34;&gt;&#xA;  物件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%a9%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Mirror&#xA;    介绍&#xA;            模拟一个镜子, 放在那, 就反射它前面的景物&#xA;            原理是一个平面, 上面的材质不断变化&#xA;&#xA;    o-&amp;gt; api&#xA;    THREE.Mirror = function(renderer, camera options)&#xA;            renderer是渲染器&#xA;            camera最好是透视相机&#xA;            options&#xA;                    textureWidth&#xA;                    textureHeight&#xA;                    clipBias&#xA;                    color&#xA;                    debugMode&#xA;    o-&amp;gt; 使用&#xA;    var planeGeo = new THREE.PlanneGeometry(100.1, 100.1);&#xA;            # 定义平面&#xA;    groundMirror = new THREE.Mirror(&#xA;            # 定义镜面&#xA;            renderer,&#xA;            camera,&#xA;            {clipBias: 0.003,&#xA;            textureWidth: WIDTH,&#xA;            textureHeight: HEIGHT,&#xA;                    # 表示内存中生成纹理的大小, 最好和屏幕一样大, 否则有mosaic&#xA;            debugMode: true}&#xA;                    # 开启调试模式会有辅助线&#xA;    );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;animationhandler&#34;&gt;&#xA;  AnimationHandler&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#animationhandler&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        主要负责动画的插值和播放&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;shader&#34;&gt;&#xA;  shader&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shader&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;EffectComposer&#xA;    介绍&#xA;            用于渲染复杂效果, 例如将一个场景作为纹理传入, 例如用着色器将场景某部分模糊或发光处理&#xA;            原理是将画面在一个临时缓冲区先画出来,再将大量效果组合. 一般是用着色器来实现&#xA;&#xA;    使用&#xA;            composer = new THREE.EffectComposer(render);&#xA;                    # 可以是WEBGLRenderer或CanvasRenderer&#xA;                    ## 第二个参数是renderTarget(渲染目标), 没有时默认生成一个&#xA;                    ### renderTarget是gpu的内部对象,用来暂存绘制结果&#xA;            composer.addPass(new THREE.RenderPass(scene, camera));&#xA;                    # 第一个效果通常是RenderPass, 它将渲染结果放入效果链中&#xA;                    ## 将结果渲染到gpu的一个帧缓冲区(临时内存)&#xA;                    ## pass中有enable成员变量, 只有为true时该pass才起作用&#xA;            var effect = new THREE.ShaderPass(THREE.DotScreenShader);&#xA;                    # DotScreenShader是examples/js/shaders中的一个&#xA;                    ## 它定义了一些一致变量, 每个帧循环操作它们来控制渲染效果&#xA;            effect.uniforms[&#39;scale&#39;].value = 4;&#xA;            composer.addPass(effect);&#xA;            var effect = new THREE.ShaderPass(THREE.RGBShiftShader);&#xA;            effect.uniforms[&#39;amount&#39;].value = 0.0015;&#xA;            effect.renderToScreen = true;&#xA;            composer.addPass(effect);&#xA;                    # 通过addPass加效果到效果链passes中&#xA;                    ## 添加顺序重要,后一个效果会作用于前一个效果&#xA;            composer.render()&#xA;                    # 用它替换render.render(scene, camera)&#xA;                    ## 遍历所有通道, 可以传入参数delta, 表示帧与帧之间渡过的时间&#xA;    api&#xA;        方法&#xA;                insertPass(pass, index)&#xA;                        # 将某一个通道插入指定的位置&#xA;                &#xA;        对象&#xA;                WebGLRenderTarget(width, height, options)&#xA;                        # width是缓冲区的宽度, height是缓冲区的高度, options是参数&#xA;                RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha)&#xA;                        # overrideMaterial表示一种材质, 它会覆盖先前设置的材质&#xA;                        # clearColor表示每一次帧缓冲绘制前的底色. 用于清除上一次绘制结果&#xA;                        # clearAlpha是0或1, 表示清除透明色&#xA;                        ## this.enabled属性表示是否启用该pass&#xA;                        方法&#xA;                                render(renderer, writeBuffer, readBuffer, delta)&#xA;                DotScreenShader&#xA;                        # 点阵屏效果, 就是报纸中点阵的印刷效果&#xA;                RGBShiftShader&#xA;                        # 变化颜色分量RGBA, 如A点的R值不显示, 而取B点的R值&#xA;                        ## angle表示偏移角度&#xA;                        ## amount表示AB的长度. 由于纹理坐标为0到1, 所以0.005会有很多像素&#xA;                BloomPass(n)&#xA;                        # 像素点膨胀模糊, 像墨水渗出&#xA;                        # n 是模糊的程度&#xA;                FilmPass(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale)&#xA;                        # 依赖FilmShader.js. 整个场景灰白, 或像lcd荧光屏在屏幕上看到线条等屏幕效果&#xA;                        ## noiseIntensity 表示杂点的密度, 值越大杂点越多&#xA;                        ## scanlinesIntensity 是扫描线的密度, 值越大扫描线透明度越小&#xA;                        ## scanlinesCount 扫描线的数量&#xA;                        ## grayscale 如果true表示黑白显示&#xA;                        var effectFilm = new THREE.FilmPass(0.35, 0.75, 2048, false);&#xA;                        effectFilm.renderToScreen = true;&#xA;                        composer.addPass(effectFilm);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;projector&#34;&gt;&#xA;  projector&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#projector&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        包含各种矩阵&#xA;        提供重要且简单的函数，进行二维和三维之间的转换&#xA;&#xA;函数&#xA;        this.unprojectVector = function(vector, camera)&#xA;                # 归一化空间中的点&#xA;                ## 归一化是将(-1, -1, -1)到(1, 1, 1)中的某个点还原成三维中的某个点&#xA;                # vector是需要归一化的那个点，要归一化成(-1, -1)到(1, 1)空间的点&#xA;                ## z 是没有意义的，通常设置为1&#xA;                # camera是当前相机，有了相机才能计算当前投影。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;扩展&#34;&gt;&#xA;  扩展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%a9%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;性能&#34;&gt;&#xA;  性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;statsjs&#34;&gt;&#xA;  stats.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#statsjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;官网&#xA;        https://github.com/mrdoob/stats.js &#xA;视图                        # 点击切换&#xA;        fps                # 上一秒的帧数&#xA;        ms                # 一帧的毫秒数&#xA;使用&#xA;        引入stats.js文件&#xA;        init中&#xA;                var stats = new Stats();&#xA;                stats.setMode(1); // 0: fps, 1: ms&#xA;                // 将stats的界面对应左上角&#xA;                stats.domElement.style.position = &#39;absolute&#39;;&#xA;                stats.domElement.style.left = &#39;0px&#39;;&#xA;                stats.domElement.style.top = &#39;0px&#39;;&#xA;                document.body.appendChild( stats.domElement );&#xA;        treeStart中&#xA;                setInterval( function () {&#xA;                    stats.begin();&#xA;                    // 你的每一帧的代码&#xA;                    stats.end();&#xA;                }, 1000 / 60 );&#xA;        &#xA;        或&#xA;        init中&#xA;                stats = new Stats();&#xA;                stats.domElement.style.position = &#39;absolute&#39;;&#xA;                stats.domElement.style.left = &#39;0px&#39;;&#xA;                stats.domElement.style.top = &#39;0px&#39;;&#xA;        animation中&#xA;                stats.update();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;动画引擎&#34;&gt;&#xA;  动画引擎&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e7%94%bb%e5%bc%95%e6%93%8e&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;tweenjs&#34;&gt;&#xA;  tween.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tweenjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;官网&#xA;        https://github.com/sole&#xA;介绍&#xA;        开源的缓动类&#xA;使用&#xA;        引入tween.js&#xA;        &#xA;        initObject之后调用&#xA;                function initTween()&#xA;                {&#xA;                    new TWEEN.Tween( mesh.position)&#xA;                            .to( { x: -400 }, 3000 ).repeat( Infinity ).start();&#xA;                }&#xA;        animation中&#xA;                requestAnimationFrame(animation);&#xA;                    TWEEN.update();&#xA;使用2(雾的far的缓动)&#xA;        scene.tween = new TWEEN.Tween(scene.fog, false)&#xA;                # 对scene.fog的属性进行操作&#xA;                .to({far: 1500}, 6000)&#xA;                        # 在6秒种内将scene.fog.far变为1500&#xA;                .easing(TWEEN.Easing.Sinusoidal.EaseOut)&#xA;                .delay(6000)&#xA;                        # 缓动在调用start()后，等待6秒执行&#xA;                .onComplete(function(){&#xA;                        # 缓动执行完成后(far= 1500后)的回调函数&#xA;                }).start();&#xA;        &#xA;        scene.tweenBack = new TWEEN.Tween(scene.fog, false)&#xA;                .delay(2000)&#xA;                .to({far: 15000}, 10000)&#xA;                .easing(TWEEN.Easing.Sinusoidal.EaseOut);&#xA;&#xA;        scene.tween.chain(scene.tweenBack);&#xA;&#xA;使用3(相机的左右[-500, 500]摇动)&#xA;                # 缓动链&#xA;        camera.tween = new TWEEN.Tween(camera.position, false)&#xA;                .to({x: 500}, 6000)&#xA;                .easing(TWEEN.Easing.Sinusoidal.EaseInOut)&#xA;                .start();&#xA;&#xA;        camera.tweenBack = new TWEEN.Tween(camera.position, false)&#xA;                .easing(TWEEN.Easing.Sinusoidal.EaseInOut)&#xA;                .to({x: -500}, 6000)&#xA;&#xA;        camera.tween.chain(camera.tweenBack);&#xA;        camera.tweenBack.chain(camera.tween);&#xA;                # 两个动画彼此加入了自己的缓动链中，两个动画可以交替执行&#xA;TWEEN.Easing&#xA;    TWEEN.Easing.Sinusoidal.EaseOut&#xA;            # Sinusoidal是正弦曲线的缓动&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;loader&#34;&gt;&#xA;  Loader&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#loader&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;VTKLoader&#xA;    var loader = new THREE.VTKLoader();&#xA;    loader.addEventListener(&#39;load&#39;, function(event){&#xA;            var geometry = event.content;&#xA;            var mesh = new THREE.Mesh(geometry, material);&#xA;            mesh.position.setY( - 0.09);&#xA;            scene.add(mesh);&#xA;    });&#xA;    loader.load(&amp;quot;models/vtk/bunny.vtk&amp;quot;);&#xA;JSONLoader&#xA;    THREE.JSONLoader.prototype.load = functiono(url, callback, texturePath)&#xA;        # url是json文件的地址&#xA;        # callback在异步加载完后执行&#xA;        # texturePath 纹理路径，没有这个参数时，在当前路径下寻找默认纹理。&#xA;BinaryLoader&#xA;    使用&#xA;            var loader = new THREE.BinaryLoader(true);&#xA;            document.body.appendChild(loader.statusDomElement);&#xA;                    # 实时显示加载进度&#xA;&#xA;    THREE.BinaryLoader = function(showStatus){&#xA;            THREE.Loader.call(this, showStatus);&#xA;                    # showStatus表示是否显示进度条&#xA;    }&#xA;    THREE.BinaryLoader.prototype.load = function(url, callback, texturePath, binaryPath)&#xA;            # url是js文件的路径&#xA;            # callback 当url中数据加载完成后调用。callback中接收geometry作为参数&#xA;            # texturePath 纹理路径，不指定默认放在url同文件夹下，或无纹理。&#xA;            # binaryPath 二进制文件的路径，不指定时，根据url地址中的文件来加载。&#xA;&#xA;ColladaLoader&#xA;UTF8Loader&#xA;    介绍&#xA;            导入 google WebGL-Loader格式的高压缩文件&#xA;SceneLoader&#xA;    介绍&#xA;            导入各物体、变换层级、材质、纹理、相机、光源的统一js文件，其中有其它js的url引用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;controls&#34;&gt;&#xA;  Controls&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#controls&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;见Camara&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;detector&#34;&gt;&#xA;  Detector&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#detector&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;if(! Detector.webgl) Detector.addGetWebGLMessage();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;convert_obj_three.py&#xA;    介绍&#xA;            转换obj文件为three.js二进制文件&#xA;&#xA;    python convert_boj_three.py -i alien2.obj -o alien2_bin.js -t binary&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;着色器&#34;&gt;&#xA;  着色器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9d%80%e8%89%b2%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        一种二进制码，在绘制场景之前做一些事。操作在显卡中进行&#xA;        对每一个顶点或者片元执行一次着色器，这个操作并行执行&#xA;        浏览器底层只支持着色器&#xA;        three.js底层是着色器实现的，所以着色器能实现一些three.js无法实现的功能，并能提高three.js的性能&#xA;优势与性能&#xA;        1. 处理大量数据能力。顶点着色器为每一个顶点确定位置，片元着色器为每个片元确定颜色，数据量非常庞大&#xA;                # 一个3d游戏中，一帧几十万个三角形。显示器分辨率1280x1024, 有1310720个像素，每一帧由片元着色器处理。&#xA;                ## 每个顶点位置与每个片元颜色几乎同时计算完成&#xA;webgl着色器分类&#xA;        # 无论在opengl, openes, dx中，都分为顶点着色器和片元着色器&#xA;        顶点着色器&#xA;                对顶点进行操作，如&#xA;                                改变顶点的位置和大小&#xA;        片元着色器&#xA;                定义屏幕中各点的颜色&#xA;                顶点之间的颜色也被一起处理了(插值)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;顶点着色器&#34;&gt;&#xA;  顶点着色器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a1%b6%e7%82%b9%e7%9d%80%e8%89%b2%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        接收三维点坐标，处理为二维坐标并输出&#xA;        THREE.ShaderMaterial用来定义着色器，着色器材质用着色器程序去控制几何体的顶点和颜色&#xA;内置变量&#xA;        gl_Position&#xA;three.js注入变量&#xA;        postion&#xA;                # gl_Position = vec4(position, 1.0);&#xA;        uv&#xA;使用&#xA;        &amp;lt;script id=&amp;quot;vertexShader&amp;quot; type=&amp;quot;x-shader/x-vertex&amp;quot;&amp;gt;&#xA;                # type只是通用标记为顶点着色器, 不起作用&#xA;                void main(){&#xA;                        # 类似c语言, 着色器有一个main函数&#xA;                        ## 每个顶点在计算时，都会执行main函数&#xA;                        gl_Position = vec4(position, 1.0);&#xA;                                # 将计算顶点最终位置的结果放在gl_Position中&#xA;                                ## 这个位置被称为设备归一化坐标&#xA;                                ## gl_Position是默认变量，不必声明就可用，gl_Position一定要赋值&#xA;                                ## 顶点着色器最主要作用就是给gl_Position赋值&#xA;                                # 作用:&#xA;                                ## gl_Position 是相机投影之后的坐标&#xA;                                ## 顶点的位置传给position, 通过我们变换, 再赋值给gl_Position&#xA;                                ## position中的值来源如mesh.vertices.push(new THREE.Vector3(x, -y, 0))&#xA;                }&#xA;        &amp;lt;/script&amp;gt;&#xA;例子&#xA;    void main(){&#xA;            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);&#xA;    }                # projectionMatrix是投影矩阵，modelViewMatrix是模型视图矩阵&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;片元着色器&#34;&gt;&#xA;  片元着色器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%87%e5%85%83%e7%9d%80%e8%89%b2%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        一个片元对应一个像素，对其输出一个颜色值。&#xA;                # 将顶点着色器输出的二维点坐标转化为待处理的像素并传递给片元着色器的过程，称为图元光栅化&#xA;        颜色会受到光照, 阴影等影响, 所以片元着色器大多处理这些物理效果&#xA;&#xA;内置变量&#xA;        gl_FragColor&#xA;                #  输出的一个像素的颜色, vec4类型, 红 绿 蓝 透明&#xA;        gl_FragCoord&#xA;                #只读变量,保存了片元相对窗口的坐标位置&#xA;                ## x, y, z, 1/w   其中z表示片元深度, z越大越深&#xA;&#xA;输入&#xA;        varying0, varying1, .... , varyingn&#xA;                #用户自定义的易变变量&#xA;        uniforms&#xA;                # 一致变量. 在js, 顶点着色器, 片元着色器中传递数据, 一次渲染中数据不变&#xA;        临时变量&#xA;&#xA;        gl_Position&#xA;                # 当前片段(像素)的位置&#xA;        gl_FrontFacing&#xA;                # 表示每个顶点的大小&#xA;        gl_PointSize&#xA;                # 当前片段来自三角形的正面还是背面. 该变量只是为了节省性能&#xA;        采样器&#xA;&#xA;使用&#xA;        &amp;lt;script id=&amp;quot;fragmentShader&amp;quot; type=&amp;quot;x-shader/x-fragment&amp;quot;&amp;gt;&#xA;                void main(){&#xA;                        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#xA;                                ＃ 表示片元颜色，是RGBA&#xA;                }&#xA;        &amp;lt;/script&amp;gt;&#xA;例子&#xA;    uniform vec2 resolution;&#xA;    uniform float time;&#xA;    float a = 1.0, b = 1.0, c = 1.0;&#xA;    float t;&#xA;    void main (){&#xA;            t = time;&#xA;            a = abs(sin(t));&#xA;            b = abs(cos(t));&#xA;            c = abs(sin(t) * cos(t));&#xA;            gl_FragColor = vec4(vec3(a, b, c), 1.0);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;变量&#34;&gt;&#xA;  变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;变量分类&#xA;        attributes(属性变量)                        # 保存顶点独有数据，如顶点的位置&#xA;                attributes vec3 pos;&#xA;        uniform(一致变量)                                # 一帧渲染过程中保持不变，如光照方向&#xA;                uniform vec3 a;&#xA;        varying(易变变量)                                # 比较容易变化的变量，用来在顶点着色器与片元着色器之间传递数据&#xA;                varying vec3 a;&#xA;类型&#xA;        vec2&#xA;                # 二维变量&#xA;        vec3&#xA;                # 三维变量&#xA;        vec4&#xA;        mat4&#xA;        sampler2D&#xA;        float&#xA;传递关系&#xA;        attribute        -&amp;gt;        顶点着色器        -&amp;gt;        varying        -&amp;gt;        图元光栅化        -&amp;gt;        varying        -&amp;gt;        片元着色器        -&amp;gt;        gl_FragColor&#xA;        uniform        -&amp;gt;        顶点着色器        -&amp;gt;        gl_Position        -&amp;gt;        图元光栅化        -&amp;gt;        gl_Position        -&amp;gt;        片元着色器        -&amp;gt;        gl_FragColor&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;思路&#34;&gt;&#xA;  思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;animate动画&#34;&gt;&#xA;  animate动画&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#animate%e5%8a%a8%e7%94%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;window.requestAnimationFrame(callback)&#xA;        # 返回id, 传给window.cancelAnimationFrame()取消该次动画&#xA;        ## 原理&#xA;        ### 传递浏览器回调函数，浏览器调用它更新画面。&#xA;        #### 与setInterval()不同之处在于自动控制了时间。对方法调用进行了优化。页面失去选中时动画自动暂停。&#xA;        ### 回调函数中　调用了requestAnimation(callback)来循环调用&#xA;        ### 通常执行callback函数来开始动画&#xA;        # 最原始的是window.setTimout()或者window.setInterval()来更新元素的位置&#xA;        ## 更新频率要达到每秒60次&#xA;animation&#xA;    function threeStart() {&#xA;                initThree();&#xA;                initCamera();&#xA;                initScene();&#xA;                initLight();&#xA;                initObject();&#xA;                animation();&#xA;&#xA;            }&#xA;    function animation() {&#xA;                //rend＋                                                                                                                                                                                                                erer.clear();&#xA;                camera.position.x = camera.position.x + 1;&#xA;                renderer.render(scene, camera);&#xA;                requestAnimationFrame(animation);&#xA;            }&#xA;    或&#xA;    function animation()&#xA;                {&#xA;                    mesh.position.x-=1;&#xA;                    renderer.render(scene, camera);&#xA;                    requestAnimationFrame(animation);&#xA;                }&#xA;render&#xA;    function animate(){&#xA;            for(var i = 0; i &amp;lt; apps.length; ++i){&#xA;                    apps[i].animate();&#xA;            }&#xA;            requestAnimationFrame(animate);&#xA;    }&#xA;    function App(...){&#xA;            this.animate = function(){&#xA;                    render();&#xA;                    stats.update();&#xA;            }&#xA;            function render(){&#xA;                    camera.position.x += (mouseX - camera.position.x) * 0.05;&#xA;                    camera.position.y += (-mouseY - camera.position.y) * 0.05;&#xA;                            # 相机位置随鼠标移动&#xA;                            ## mouseX, mouseY为自定义的全局变量&#xA;                    camera.lookAt(scene.postion);&#xA;                    renderer.render(scene, camera);&#xA;            }&#xA;    }&#xA;render计算&#xA;    var mouseX = 0, mouseY = 0;&#xA;    document.addEventListener(&#39;mousemove&#39;, onDocumentMouseMove, false);&#xA;    function onDocumentMouseMove(event){&#xA;            mouseX = (event.clientX - windowHalfX);&#xA;            mouseY = (event.clientY - windowHalfY);&#xA;    }&#xA;相机旋转&#xA;    围绕y轴, 半径1000的圆作圆周运动。&#xA;            var timer = 0.0001 * Date.now();&#xA;                    # 用当前时间作弧度&#xA;            camera.position.x = Math.cos(timer) * 1000;&#xA;            camera.position.z = Math.sin(timer) * 1000;&#xA;            camera.lookAt(scene.position);&#xA;自发光变化&#xA;    material.emissive.setHSV(0.54, 1, 0.7 * (0.5 + 0.5 * Math.sin(35 * timer)));&#xA;引擎&#xA;    组成&#xA;            定义与初始化相机&#xA;            定义与初始化场景&#xA;            定义与初始化光&#xA;            定义与初始化渲染器&#xA;            定义与初始化性能监视器&#xA;            定义鼠标事件, 窗口缩放事件&#xA;                    ele.addEventListener(&#39;mousedown&#39;, ...)&#xA;                    ele.addEventListener(&#39;mouseup&#39;, ...)&#xA;                    ele.addEventListener(&#39;mousemove&#39;, ...)&#xA;                    window.addEventListener(&#39;resize&#39;, ...)&#xA;            播放音乐&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;&#xA;  结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;定义App类&#xA;    App类将相机，视图，灯光等场景代码封装，为了场景的代码的重用&#xA;            # 场景重新new&#xA;    例子1, 视口app&#xA;            function App( containerId, fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight )&#xA;对象池&#xA;    介绍&#xA;            用过的对象保存起来，下次需要时重复使用。&#xA;            减少频繁创建对象所造成的内存开销和cpu开销&#xA;    自定义ObjectPool.js&#xA;            function ObjectPool(){&#xA;                    this.pool = new Array();&#xA;                    this.avail = new Array();&#xA;                            # 可用在pool中的索引，pool中对象不在使用，待再利用时放入avail中&#xA;            }&#xA;            ObjectPool.prototype.createObject = function(){&#xA;                    return new Object();&#xA;            }&#xA;                    #  创建一个多态的对象(如一个豆径)，需要重载,&#xA;            ObjectPool.prototype.returnObject = function(poolId){&#xA;                    this.avail.push(poolId);&#xA;            }&#xA;                    # 标记为可再利用&#xA;            ObjectPool.prototype.getObject = function(){&#xA;                    if(this.avail.length ==0){&#xA;                            var o = this.createObject();&#xA;                            o.poolId = this.pool.length;&#xA;                            this.pool.push(o);&#xA;                            this.avail.push(o.poolId);&#xA;                    }&#xA;                    var poolId = this.avail.pop();&#xA;                    return this.pool[poolId];&#xA;            }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;控制&#34;&gt;&#xA;  控制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;resize&#xA;    window.addEventListener( &#39;resize&#39;, onWindowResize, false );&#xA;&#xA;    function onWindowResize( event ) {&#xA;            SCREEN_WIDTH = window.innerWidth;&#xA;            SCREEN_HEIGHT = window.innerHeight;&#xA;&#xA;            renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );&#xA;            camera.aspect = 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT;&#xA;            camera.updateProjectionMatrix();&#xA;                    # 产生透视投影矩阵&#xA;    }&#xA;鼠标射线&#xA;    mouse = new THREE.Vector3(0, 0, 1);&#xA;    projector = new THREE.Projector();&#xA;    ray = new THREE.Ray(camera.position);&#xA;&#xA;    function onDocumentMouseMove(event){&#xA;            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;&#xA;            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;&#xA;                    # 取得鼠标的位置，并将其转换为-1到1之间(归一化)&#xA;            ray.direction = projector.unprojectVector(mouse.clone(), camera);&#xA;                    # 得到当前鼠标指向二维的点在程序三维中的位置&#xA;            ray.direction.subSelf(camera.position).normalize();&#xA;                    # 鼠标所在的点送去相机所在的点，得到相机指向鼠标所在点的向量并规范化&#xA;            intersects = ray.intersectObject(plane);&#xA;                    # 计算射线与模型的相交点数组&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;场景&#34;&gt;&#xA;  场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;天空盒&#xA;    两种实现&#xA;            立方体内部贴纹理&#xA;            椭球内部贴纹理&#xA;    立方体天空盒&#xA;            var r = &#39;textures/cube/Bridge2&#39;;&#xA;            var urls = [r + &#39;posx.jpg&#39;, r + &#39;negx.jpg&#39;, r + &#39;posy.jpg&#39;, r + &#39;negy.jpg&#39;, r + &#39;posz.jpg&#39;, r + &#39;negz.jpg&#39;];&#xA;            var textureCube = THREE.ImageUtils.loadTextureCube(urls);&#xA;            textureCube.format = THREE.RGBFormat;&#xA;                    # 设置图片格式，此格式不需要透明度。节约内存又加快渲染速度&#xA;            var shader = THREE.ShaderLib[&#39;cube&#39;];&#xA;                    # ShaderLib与three.js引擎的一个数组, 其中的cube存放的是立方体贴图的shader&#xA;            shader.uniforms[&#39;tCube&#39;].value = textureCube;&#xA;                    # 纹理给shader着色器&#xA;            var material = new THREE.ShaderMaterial({&#xA;                    fragmentShader: shader.fragmentShader,&#xA;                    vertexShader: shader.vertexShader,&#xA;                    uniforms: shader.uniforms,&#xA;                    depthWrite: false,&#xA;                    side: THREE.BackSide&#xA;            });        # 用ShaderMaterial材质包装shader&#xA;            mesh = new THREE.Mesh(new THREE.CubeGeometry(100, 100, 100), 22, material);&#xA;            sceneCube.add(mesh);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;性能-1&#34;&gt;&#xA;  性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;概要&#xA;        3d设计的精髓在于性能优化&#xA;        使用连续内存(如数组)将加速程序运行，不连续内存将增加读取时寻址的时间。&#xA;使用&#xA;    $(document).ready(&#xA;            function(){&#xA;                    var container = document.getElementById(&amp;quot;container&amp;quot;);&#xA;                    var app = new MineCraftApp();&#xA;                    app.init({container: container});&#xA;                            # container属性 表示最后渲染结果外层的div&#xA;                    app.run();&#xA;            }&#xA;    );&#xA;App&#xA;    介绍&#xA;            封装了three.js的一些基本操作, 如&#xA;                    创建渲染场景&#xA;                    创建相机&#xA;                    控制画布缩放&#xA;                    鼠标输入&#xA;            对three.js进行了面向对象的封装，可以面向对象编程&#xA;    函数&#xA;            prototype.init(param)&#xA;                    # 初始化&#xA;                    ## 参数是一个键值对对象&#xA;                    ## 一个WebGLRenderer渲染器&#xA;                    ## 一个场景 THREE.Scene()&#xA;                    ## 一个透视投影 THREE.PerspectiveCamera&#xA;                    ## 一个投影器 THREE.Projector()&#xA;                    ## 一些鼠标键盘的操作&#xA;            prototype.run = function(){&#xA;                    # 是渲染循环，会不断被调用&#xA;                    ## 调用每一个Sim.Object的update&#xA;                    this.update();&#xA;                    this.renderer.render(this.scene, this.camera);&#xA;                    var that = this;&#xA;                    requestAnimationFrame(function(){that.run(); });&#xA;                            # run的帧循环&#xA;            }&#xA;                    &#xA;            prototype.addObject&#xA;                    # 将Sim.Object对象加入场景中&#xA;            prototype.removeObject&#xA;                    # 将Sim.Object对象从场景移出&#xA;&#xA;    属性&#xA;            renderer&#xA;            scene&#xA;            camera&#xA;            objects&#xA;                    # 场景中的所有可视对象&#xA;Publisher&#xA;    介绍&#xA;            一个事件驱动模型&#xA;            Sim.Publisher用于&#xA;                    记录事件&#xA;                    发送事件&#xA;                    处理事件&#xA;            当事件发生时，它遍历注册的回调列表，调用每一个注册的函数&#xA;    函数&#xA;            prototype.subscribe = function(message, subscriber, callback)&#xA;                    # 发起订阅&#xA;                    ## message表示事件名&#xA;                    ## 放callback函数的类&#xA;                    ## 事件发生时的执行回调函数&#xA;            prototype.unsubscribe = function(message, subscriber, callback)&#xA;                    # 取消订阅, 删除MessageTypes数组中事件名对就的链表中的一节点&#xA;                    ## message值为null, false, undefined时表示删除整个链表(不删除事件)&#xA;            prototype.publish = function(message)&#xA;                    # 触发事件&#xA;    属性&#xA;            MessageTypes&#xA;                    # 事件与其处理函数的集合&#xA;                    ## 形如 messageType[&#39;remove&#39;] = [subscriber, callback] -&amp;gt; [subscriber, callback]&#xA;                    ### &#39;remove&#39;是事件名, subscriber是订阅者, callback是订阅者该事件的回调方法&#xA;                    ### -&amp;gt; 是链表的意思&#xA;Object&#xA;    介绍&#xA;            sim.js所有封装类的基类, 派生于Sim.Publisher&#xA;            可以表示大多数对象(自定义的对象派生于它)&#xA;    方法&#xA;            prototype.setPosition&#xA;                    # 设置object3D对象的位置&#xA;            prototype.setScale&#xA;            prototype.setVisible&#xA;            prototype.update&#xA;                    # 更新该对象和它的children&#xA;                    ## 在每一次渲染循环时调用,用来产生自己的动画&#xA;            prototype.addChild&#xA;                    # 添加子对象, 如汽车添加轮子&#xA;            prototype.removeChild&#xA;    属性&#xA;            object3D&#xA;                    # 用于保存three.js中的Object3D对象&#xA;            children&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;框架&#34;&gt;&#xA;  框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;sim&#34;&gt;&#xA;  sim&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sim&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    封装three.js大量重复工作&#xA;            如设置渲染器，循环重绘，向场景添加Mesh等&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;physijs&#34;&gt;&#xA;  physi.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#physijs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        基于three.js上构建的物理引擎&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;voxeljs&#34;&gt;&#xA;  voxel.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#voxeljs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        像素方块游戏开发(minecraft)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;例子来自webgl中文网&#34;&gt;&#xA;  例子(来自webgl中文网)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%8b%e5%ad%90%e6%9d%a5%e8%87%aawebgl%e4%b8%ad%e6%96%87%e7%bd%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;16万个三角形&#34;&gt;&#xA;  16万个三角形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#16%e4%b8%87%e4%b8%aa%e4%b8%89%e8%a7%92%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;定义&#xA;        o-&amp;gt; triangles = 160000&#xA;        o-&amp;gt; 每个三角形有３个顶点, 一个顶点三个float表示，共triangles * 3 * 3个float&#xA;                # 用数组存放&#xA;        o-&amp;gt; 每个顶点一个法向量，一个三角形３个法向量&#xA;&#xA;赋值&#xA;        o-&amp;gt; 所有三角形顶点应该在一个以原点为中心的正方体内&#xA;        o-&amp;gt; 三角形的位置在正方体内随机分布&#xA;实现&#xA;        var geometry = new THREE.BufferGeometry();&#xA;        geometry.attributes = {&#xA;                        index:{&#xA;                                itemSize: 1,&#xA;                                array: new Uint16Array(triangles * 3),&#xA;                                numItems: triangles * 3&#xA;                        },&#xA;                                # 索引&#xA;                                ## 每一个数组元素的聚会范围是[0, 65535],如果顶点数超过65535,必须通过geometry的offset成员来进一步设置偏移量。&#xA;                                ### 65535是16位整型&#xA;                        position: {&#xA;                                itemSize: 3,&#xA;                                array: new Float32Array(triangles * 3 * 3),&#xA;                                numItems: triangles * 3 * 3&#xA;                        },&#xA;                                # 位置&#xA;                        normal:{&#xA;                                itemSize: 3,&#xA;                                array: new Float32Array(triangle * 3 * 3),&#xA;                                numItems: triangles * 3 * 3&#xA;                        },&#xA;                                # 法线&#xA;                        color: {&#xA;                                itemSize: 3,&#xA;                                        # 一项目(元)由几个字节组成&#xA;                                array: new Float32Array(triangles * 3 * 3),&#xA;                                        # 实际存项目的内存数组&#xA;                                numItems: triangles * 3 * 3&#xA;                                        # 有多少个项目&#xA;                        }&#xA;                                # 颜色&#xA;                }&#xA;                        # Uint16Array分配指定个数的16位无符号整数，寝值为0&#xA;                        ##  如果内存紧张，无法分配时则引发异常&#xA;                        ## api uint16Array = new Uint16Array(length);&#xA;                        ### uint16Array = new Uint16Array(array);&#xA;                        # 位置，用Vector3来表示，共有triangles * 3个Vector3&#xA;                        ## 每个Vector3有x, y, z三个分量组成, 所以顶点需要triangles * 3 * 3个浮点数表示。&#xA;                        # 法线, 一个点对应一个法线, 由x, y, z三个float组成，所以需要triangles    * 3 * 3个float&#xA;                        # 颜色, 每个顶点一种颜色，颜色由R, G, B组成，所以需要triangles * 3 * 3个float&#xA;                var n = 800, n2 = n/2;&#xA;                        # n是正方体的边长&#xA;                # 为三角形顶点赋随机值，后计算每个顶点的法向量&#xA;                ## positions数组每隔9个是一个三角形&#xA;                ## normals数组每隔9个是一个三角形&#xA;                # 随机生成颜色，赋给顶点&#xA;                ## colors数组每隔9个是一个三角形&#xA;&#xA;                # 给geometry设置索引和偏移量&#xA;                ## 索引对应到点，所以有triangles * 3个&#xA;                ### 索引从0开始&#xA;&#xA;                # 将BufferGeometry和材质组成mesh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;人物粒子&#34;&gt;&#xA;  人物粒子&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ba%e7%89%a9%e7%b2%92%e5%ad%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;生成粒子&#xA;        var vertices = geometry.vertices;&#xA;        var mesh = new THREE.ParticleSystem(geometry, new THREE.ParticleBasicMaterial({size: 3, color: c}));&#xA;        mesh.scale.x = mesh.scale.y = mesh.scale.z = scale;&#xA;        mesh.position.x = mesh.position.y = mesh.position.z = position;&#xA;渲染&#xA;        render()&#xA;        mesh.geometry.verticesNeedUpdate = true;&#xA;                # 如果不刷新，渲染出来的顶点位置不会改变&#xA;        renderer.clear();&#xA;        composer.render(0.01);&#xA;                # composer为THREE.EffectComposer, 效果组合器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;多视口&#34;&gt;&#xA;  多视口&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e8%a7%86%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;viewport&#xA;注意&#xA;        视口的坐标为归一化的坐标。左上角是(0, 0), 右下角是(1, 1)&#xA;阴影贴图&#xA;    canvas画阴影&#xA;    阴影纹理&#xA;            var shadowTexture= new THREE.Texture(canvas);&#xA;            shadowTexture.needsUpdate = true;&#xA;                    # 表示纹理是新纹理，在绘制的时候，需要更新到材质上&#xA;            var shadowMaterial = new THREE.MeshBasicMaterial({map:shadowTexture});&#xA;平面和线框同时显示&#xA;    材质wireframe属性只有true和false,所以要创建2个不同材质的相同物体&#xA;&#xA;    THREE.SceneUtils.createMultiMaterialObject(geometry, materials)&#xA;            # 传递一个几何体和材质数组，几何体每一个材质组合成一个Mesh, 将Mesh加入组group对象中，返回组对象。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;杰克与豆径&#34;&gt;&#xA;  杰克与豆径&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%b0%e5%85%8b%e4%b8%8e%e8%b1%86%e5%be%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;主要内容&#xA;        天空盒&#xA;        生长效果&#xA;                树叶的生长&#xA;                树干变形&#xA;                音乐渲染控制生长&#xA;        对象池&#xA;设计&#xA;        鼠标操作&#xA;        植物模型&#xA;                plant&#xA;                        豆干，豆径(leaf3.js)，豆叶(leaf5.js)&#xA;                        豆径豆叶的材质&#xA;        植物生长&#xA;        阴天、晴天&#xA;                天空材质&#xA;&#xA;        相机动画&#xA;音乐&#xA;    &amp;lt;audio id=&amp;quot;audio&amp;quot; preload=&amp;quot;auto&amp;quot; loop&amp;gt;&#xA;                    # 预加载音乐并循环播放&#xA;            &amp;lt;source src=&amp;quot;a.mp3&amp;quot; type=&amp;quot;audio/mpeg&amp;quot;&amp;gt;&#xA;    &amp;lt;/audio&amp;gt;&#xA;&#xA;    &amp;lt;script&amp;gt;&#xA;            audio = document.getElementById(&#39;audio&#39;);&#xA;            audio.play();&#xA;    &amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;流动立方体&#34;&gt;&#xA;  流动立方体&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81%e5%8a%a8%e7%ab%8b%e6%96%b9%e4%bd%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;设计&#xA;        从相机到鼠标发射射线, 与射线相交的点，就是选中物体的某个点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;我的世界&#34;&gt;&#xA;  我的世界&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%88%91%e7%9a%84%e4%b8%96%e7%95%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;MineCraftApp = function(){&#xA;        Sim.App.call(this);&#xA;}&#xA;MineCraftApp.prototype = new Sim.App();&#xA;&#xA;MineCraftApp.prototype.init = function(param){&#xA;        Sim.App.prototype.init.call(this, param);&#xA;                # 调用父类的init函数，在父类中初始化相机, 场景等类&#xA;        # 性能监视器&#xA;        # 天空盒&#xA;        # 相机控制类&#xA;        # 场景中的一个个小物体&#xA;}&#xA;$(document).ready(&#xA;        function(){&#xA;                var container = document.getElementById(&amp;quot;container&amp;quot;);&#xA;                var app = new MineCraftApp();&#xA;                app.init({container: container});&#xA;                        # container属性 表示最后渲染结果外层的div&#xA;                app.run();&#xA;        }&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;汽车换装&#34;&gt;&#xA;  汽车换装&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b1%bd%e8%bd%a6%e6%8d%a2%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;设计&#xA;        汽车类&#xA;                更换s汽车模型&#xA;                更换汽车各部分颜色&#xA;        两个相机&#xA;        两个场景&#xA;        三种光源&#xA;        天空盒&#xA;        渲染器&#xA;        效率监听器&#xA;        初始化各种材质&#xA;汽车类&#xA;        veyron: {&#xA;                name: &#39;布加迪威龙&#39;,&#xA;                url: &#39;obj/veyron/VeyronNoUv_bin.js&#39;,&#xA;                author: &#39;布加迪威龙&#39;,&#xA;                init_rotation: [0, 0, 0],&#xA;                scale: 5.5,&#xA;                init_materials: 4,&#xA;                body_materials: [2],&#xA;                object: null,&#xA;                buttons: null,&#xA;                materials: null&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分形&#34;&gt;&#xA;  分形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uniforms = {&#xA;        scale: {type: &#39;v2&#39;, value: new THREE.Vector2()},&#xA;        c: {type: &#39;v2&#39;, value: new THREE.Vector2()}&#xA;}&#xA;material = new THREE.ShaderMaterial({&#xA;        uniforms: uniforms,&#xA;        vertexShader: document.getElementById(&#39;vertexShader&#39;).textContent,&#xA;        fragmentShader: document.getElementById(&#39;fragmentShader&#39;).textContent&#xA;});&#xA;mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.0), material);&#xA;        # 用 2 * 2 的平面来覆盖浏览器窗口&#xA;function onWidowResize(event){&#xA;        renderer.setSize(window.innerWidth, window.innerHeight);&#xA;        uniforms.scale.value.x = window.innerWidth / 2;&#xA;        uniforms.scale.value.y = window.innerHeight;&#xA;}&#xA;&#xA;o-&amp;gt; 片元着色器中代码 &#xA;uniform vec2 c;&#xA;uniform vec2 scale;&#xA;void main(void){&#xA;        float R = (gl_FragCoord.x - scale.x) / scale.y;&#xA;        float I = (gl_FragCoord.y - scale.x) / scale.y;&#xA;        float R2 = R * R, I2 = I * I;&#xA;        int mm;&#xA;        for(int m =0; m &amp;lt; 255; m++){&#xA;                I = (R + R) * I + c.y; R = R2 - I2 + c.x; R2 = R * R; I2 = I * I; mm = m;&#xA;                if(abs((I2) / (I + R)) &amp;gt; 10.) break;&#xA;        }&#xA;        if(mm == 254) gl_FragColor = vec4(0., 0., 0., 1.);&#xA;        else{&#xA;                float a = float(mm);&#xA;                a = mod(a, 15.) / 5.;&#xA;                gl_FragColor = vec4(max(0., abs(a - 1.5) - .5)),&#xA;                        max(0., 1. - abs(a - 1.)),&#xA;                        max(0., 1. - abs(a - 2.)),&#xA;                        1.);&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;镜像分形&#34;&gt;&#xA;  镜像分形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%95%9c%e5%83%8f%e5%88%86%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        镜面反射场景&#xA;&#xA;var mirrorMesh = new THREE.Mesh(planeGeo, groundMirror.material);&#xA;        # groundMirror.material是THREE.Mirror中定义的材质. 会在每次update(或者render)过程中变化&#xA;        ## groundMirror.updateTextureMatrix()&#xA;        ## groundMirror.render() 要在update或render前重新渲染镜子的纹理.&#xA;        ### 多面镜子时, 如上一个个更新会有干扰, 要用下面代码更新&#xA;        ### groundMirror.renderWithMirror(verticalMirror);&#xA;        ### verticalMirror.renderWithMirror(groundMirror);&#xA;mirrorMesh.add(groundMirror);&#xA;mirrorMesh.rotateX(-Math.PI / 2);&#xA;scene.add(mirrorMesh);&#xA;&#xA;THREE.ShaderLib[&#39;mirror&#39;] = {&#xA;        uniforms: {&#xA;                mirrorColor: {&#xA;                        type: &#39;c&#39;,&#xA;                        value: new THREE.Color(0x7F7F7F)&#xA;                },&#xA;                mirrorSampler: {type: &#39;t&#39;, value: null},&#xA;                textureMatrix: {type: &#39;m4&#39;, value: new THREE.Matrix4()}&#xA;        },&#xA;        vertexShader: [&#xA;                &#39;uniform mat4 textureMatrix;&#39;,&#xA;                &#39;varying vec4 mirrorCoord;&#39;,&#xA;                &#39;void main() {&#39;,&#xA;                        &#39;vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);&#39;,&#xA;                        &#39;vec4 worldPosition = modelMatrix * vec4(position, 1.0);&#39;,&#xA;                        &#39;mirrorCoord = textureMatrix * worldPosition;&#39;,&#xA;                        &#39;gl_Position = projectionMatrix * mvPosition;&#39;,&#xA;                &#39;}&#39;&#xA;        ].join(&#39;&#39;\n),&#xA;        fragmentShader: [&#xA;                &#39;uniform vec3 mirrorColor;&#39;,&#xA;                &#39;uniform sampler2D mirrorSampler;&#39;,&#xA;                &#39;varying vec4 mirrorCoord;&#39;,&#xA;                &#39;float blendOverlay(float base, float blend){&#39;,&#xA;                        &#39;return (base &amp;lt; 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)));&#39;,&#xA;                &#39;}&#39;,&#xA;                &#39;void main(){&#39;,&#xA;                        &#39;vec4 color = texture2DProj(mirrorSampler, mirrorCoord);&#39;,&#xA;                        &#39;color = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, mirrorColor.b), 1.0);&#39;,&#xA;                        &#39;gl_FragColor = color;&#39;,&#xA;                &#39;}&#39;&#xA;        ].join(&#39;\n&#39;)&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;文字&#34;&gt;&#xA;  文字&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e5%ad%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    原理: 每个要显示的文字生成mesh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;小地图&#34;&gt;&#xA;  小地图&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%8f%e5%9c%b0%e5%9b%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        实现方式1, 在天空直接用正投影相机&#xA;                # 实现简单,但渲染效果差,占很多cpu时间(重新绘制一次整个场景)&#xA;        实现方式2, 用正投影相机, 但用画大地图的数据来绘制&#xA;                # 小地图渲染用很少时间, 因为复杂模型都用小方块或图片代替了&#xA;&#xA;o-&amp;gt; 实现&#xA;        camera.lookAt(scene.position);&#xA;        camera2.lookA(scene.position);&#xA;&#xA;        renderer2 = new THREE.CanvasRenderer();&#xA;                # 两个WebGLRenderer位置重叠时,会渲染不正常(其中一个全黑)&#xA;        renderer2.setSize(200, 150);&#xA;&#xA;        renderer.render(scene, camera);&#xA;        renderer2.render(scene, camera2);&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Angular</title>
      <link>https://runout.run/docs/middleware/library_frontend/angular/</link>
      <pubDate>Thu, 11 Oct 2018 07:47:51 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/angular/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;google发布&#xA;提倡SPA(Single Page Apps), 运行快，一次加载&#xA;mvvm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;前端mvc&#xA;双向数据绑定&#xA;指令和语义化标签&#xA;模块化工具&#xA;依赖注入&#xA;html模板&#xA;常用工具封装，如$http $cookies $location&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;directive&#34;&gt;&#xA;  directive&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#directive&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内置&#xA;    ng-app                      # 声明app名, 在最外层&#xA;    ng-submit                   # &amp;lt;form ng-submit=&amp;quot;submit()&amp;quot;&amp;gt;&#xA;    ng-controller&#xA;    ng-repeat                   # $index返回当前引用的元素序号，$first, $middle, $last 返回布尔值&#xA;    ng-model                    # 绑定当前元素的值&#xA;    ng-click&#xA;        ng-eventhandler=&amp;quot;expression&amp;quot;类的指令可以在所有浏览器中有相同的行为，angular将会屏蔽差异性&#xA;        不会在全局命名空间中进行操作，指定的表达式只能访问元素控制器作用域范围内的函数和数据&#xA;    ng-bind&#xA;    ng-change&#xA;    &amp;lt;form ng-submit=&amp;quot;aaFunc()&amp;quot;&amp;gt; # 会阻止浏览器默认的提交操作&#xA;    ng-dblclick&#xA;    ng-show&#xA;    ng-hide&#xA;    ng-class                    # 可以是类名字符串，空格分隔，可以是类名数组，可以是类名到布尔值的映射&#xA;        ng-class=&amp;quot;{true: &#39;active&#39;, false: &#39;inactive&#39;}[isActive]&amp;quot;&#xA;        ng-class=&amp;quot;{&#39;selected&#39;: isSelected, &#39;car&#39;: isCar}&amp;quot;&#xA;    ng-style                    # templete中写css不好维护&#xA;    ng-src=&amp;quot;/images/cats/{{favoriteCat}}&amp;quot;       # src，href属性中简单使用templete,由于浏览器优先并行加载图片和其它内容,angular没有机会拦截到数据绑定请求，所以无法运行&#xA;    ng-href&#xA;    ng-options&#xA;        &amp;lt;select ng-model=&amp;quot;x&amp;quot; ng-options=&amp;quot;(m.a + &#39; - &#39; + m.b) group by m.c for (key, m) in opts&amp;quot;&amp;gt;&#xA;自定义&#xA;    angular.module(&#39;CAT.TryDrt&#39;, [])&#xA;    .directive(&#39;hello&#39;, function(){&#xA;        return {&#xA;            restrict: &#39;E&#39;,                          # E: element, A:attribute, C:class, M: comment&#xA;            template: &#39;&amp;lt;div&amp;gt;Hello world&amp;lt;/div&amp;gt;&#39;,     # 标签内容&#xA;            replace: true                           # 表示替换原标签&#xA;        }&#xA;    });&#xA;&#xA;    &amp;lt;hello&amp;gt;&amp;lt;/hello&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;controller&#34;&gt;&#xA;  controller&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#controller&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    通过ng-controller&#xA;    router中绑定到动态加载的dom模板片段上&#xA;作用&#xA;    初始化页面状态&#xA;    通过$scope对象暴露数据模型给视图&#xA;    监视模型变化，并采取相应动作&#xA;嵌套&#xA;    原理是$scope的继承&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;templete&#34;&gt;&#xA;  templete&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#templete&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用范围&#xA;    页面中&#xA;    value、class、style属性&#xA;表达式                      # 自定义的解释器而非eval执行&#xA;    + - * / %&#xA;    == != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;=&#xA;    &amp;amp;&amp;amp; || !&#xA;    \^ &amp;amp; |&#xA;    $scope中暴露的函数&#xA;            # 但不是视图的职责，也不利于测试&#xA;    {} []&#xA;filter&#xA;    使用&#xA;        expression | filterName : parameter1 : parameter2 : ...&#xA;        可以多次过滤, 11.2 | currency | number:0 会显示$11&#xA;&#xA;    currency                # 数字过滤成美元&#xA;    date&#xA;    number&#xA;    uppercase&#xA;&#xA;    自定义&#xA;        homeModule.filter(&#39;titleCase&#39;, function(){&#xA;            var titleCaseFilter = function (input){&#xA;                var words = input.split(&#39; &#39;);&#xA;                for(var i = 0; i &amp;lt; words.length; i++){&#xA;                    words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1);&#xA;                }&#xA;                return words.join(&#39; &#39;);&#xA;            };&#xA;            return titleCaseFilter;&#xA;        })&#xA;&#xA;        {{pageHeading | titleCase}}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;module&#34;&gt;&#xA;  module&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#module&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;api&#xA;    angular&#xA;        module(&#39;todoApp&#39;, [])       # 数组中传入依赖的外部模块名&#xA;        controller(&#39;TodoListController&#39;, function(){&#xA;            var todoList = this;&#xA;            todoList.todos = [{a:&#39;a1&#39;},{a:&#39;a2&#39;}];&#xA;            todoList.addTode = function(){}&#xA;        });&#xA;        value()&#xA;        service()&#xA;        config()&#xA;        factory(&#39;globalInterceptor&#39;, GlobalInterceptor)&#xA;        run()&#xA;        angular.ent($(&#39;.container&#39;)).scope().fetchDept()    # 得到element的scope&#xA;&#xA;    o-&amp;gt; 例子&#xA;    angular.module(&#39;project&#39;, [&#39;ngRoute&#39;, &#39;firebase&#39;])&#xA;    .value(&#39;fbURL&#39;, &#39;https://ng-projects-list.firebaseio.com/&#39;)&#xA;    .service(&#39;fbRef&#39;, function(fbURL){return new Firebase(fbURL)&#xA;    })&#xA;    .service(&#39;fbAuth&#39;, function...)&#xA;    .config(function($routeProvider){&#xA;        var resolveProjects = {&#xA;            projects: function(Projects){&#xA;                return ...&#xA;            }&#xA;        };&#xA;    })&#xA;&#xA;    o-&amp;gt;&#xA;    xxxModule.config(function ($routeProvider) {&#xA;        $routeProvider&#xA;        .when(&#39;url&#39;, {controller: aController, templateUrl: &#39;/path/to/template&#39;})&#xA;        .when(..)&#xA;        .otherwise(..);&#xA;    })&#xA;&#xA;    o-&amp;gt;&#xA;    someModule.config(function($routeProvider){&#xA;        $routeProvider.&#xA;            when(&#39;url&#39;, {controller: aController, templateUrl: &#39;/path/to/template&#39;}).&#xA;            when(...) ...&#xA;            otherwise(...)&#xA;    })&#xA;&#xA;第三方module&#xA;    ngCookies&#xA;    ngAnimate&#xA;    &#39;ngWebSocket&#39;&#xA;    angularJwt&#xA;    ngclipboard&#xA;    react.name&#xA;    &#39;flow&#39;&#xA;        # 文件上传&#xA;    &#39;flowchart&#39;&#xA;        # 流程图&#xA;    ngTouch&#xA;    &#39;angular-carousel&#39;&#xA;        # 图片轮换, 可移动端&#xA;&#xA;    FBAngular.name&#xA;        # 全屏&#xA;    ngMaterial&#xA;        # 响应式布局&#xA;    ngMdIcons&#xA;        # 图标&#xA;    angularSocialshare&#xA;        # 社交分享&#xA;    &#39;pascalprecht.translate&#39;&#xA;        # 国际化&#xA;    &#39;mdColorPicker&#39;&#xA;        # 颜色选择器&#xA;    &#39;ngMaterialDateRangePicker&#39;&#xA;        # 日期选择器&#xA;    mdPickers&#xA;        # 日期选择器&#xA;    ngSanitize&#xA;        # html过滤&#xA;    vAccordion&#xA;        # 折叠菜单&#xA;    &#39;dndLists&#39;&#xA;        # 拖拽&#xA;    mdDataTable&#xA;        # 表格&#xA;    fixedTableHeader&#xA;        # 表头固定&#xA;    &#39;material.components.expansionPanels&#39;&#xA;        # 可扩展panel&#xA;    &#39;mdSteppers&#39;&#xA;        # 步骤图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内置&#xA;    $rootScope          # 全局作用域&#xA;    $scope&#xA;    $scope.$watch&#xA;        监控属性或函数&#xA;        $watch(watchFn, watchAction, deepWatch)&#xA;            # angular的表达式(如$scope.xxx)或字符串，函数或表达式，布尔。返回一个函数，用来注销watcher&#xA;            # watch中的函数会翻倍执行，来检测模型中的变更已经被完整地进行了传播。会把所有被监控的属性都复制一份，再与当前值比较，看是否发生了变化。&#xA;            ## 最多运行10次，如果10次中watchFn的值都发生变化，则可能有循环依赖。&#xA;            ## Object.observe()会优化这一点，在支持此函数的地方自动使用它。&#xA;        $watch($scope.totalCart, calculate)&#xA;            # totalCart是函数&#xA;        $watch(&#39;items&#39;, calculate)&#xA;            # items是$scope.items数组&#xA;        $watch(function(){&#xA;            for($scope.items)&#xA;            $scope.bill.totalCartNum = total;&#xA;        })&#xA;        # 如果监控多个属性可以&#xA;        ## 监控这些属性连接起来的表达式&#xA;        ## deepWatch这些属性的数组&#xA;    $scope.$apply&#xA;        # 在所有绑定关系都获得刷新，所有变化都反映到了视图上时懒惰调用，angular定时提醒这个服务&#xA;        # 自主修改dom后，只是在$apply中注册并不调用，如果想马上得到angular双向绑定后的结果，要手动调用$apply&#xA;        # 触发完digest循环后执行回调&#xA;        $scope.$apply(function () {})&#xA;    $scope.$digest&#xA;        # 只是触发digest循环&#xA;        $scope.$digest()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;服务&#34;&gt;&#xA;  服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内置&#xA;    $location&#xA;    $log&#xA;    $http&#xA;    $route&#xA;    $routeProvider&#xA;    $urlRouterProvider&#xA;    $stateProvider&#xA;    $locationProvider&#xA;    $timeout&#xA;    $parse&#xA;        var submitHandler = $parse(attrs.ngSubmit)(scope);&#xA;        submitHandler();&#xA;    $q                  # node q, 并发控制&#xA;    $injector           # get注入的模块&#xA;创建服务&#xA;    provider&#xA;        # 创建可配置的服务&#xA;    factory&#xA;        # 创建不可配置的服务&#xA;    service&#xA;        # 创建不可配置的服务，比较简单&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;浏览器插件&#34;&gt;&#xA;  浏览器插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8f%e8%a7%88%e5%99%a8%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Batarang&#xA;    # 调试&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Jquery</title>
      <link>https://runout.run/docs/middleware/library_frontend/jquery/</link>
      <pubDate>Thu, 11 Oct 2018 07:34:03 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/jquery/</guid>
      <description>&lt;h1 id=&#34;对象命名方式&#34;&gt;&#xA;  对象命名方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%91%bd%e5%90%8d%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;var $a = $(&amp;quot;#inputID&amp;quot;);        &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;选择器选择多个时形成数组&#34;&gt;&#xA;  选择器（选择多个时形成数组）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%89%e6%8b%a9%e5%99%a8%e9%80%89%e6%8b%a9%e5%a4%9a%e4%b8%aa%e6%97%b6%e5%bd%a2%e6%88%90%e6%95%b0%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;基本选择器&#xA;    $(&amp;quot;#inputID&amp;quot;);                # id选择&#xA;    $(&amp;quot;input&amp;quot;); // 标签名,默认获取第一个                # 标签名选择&#xA;        $(&amp;quot;.className&amp;quot;); // 按样式名定位                # 样式名选择&#xA;        $(&amp;quot;#div1ID,.myClass,p&amp;quot;);                # 选择多个&#xA;        $(&amp;quot;*&amp;quot;);                        # 所有元素&#xA;层级选择器&#xA;    $(&amp;quot;form input&amp;quot;)                        # form所有后代元素中input元素的个数&#xA;    $(&amp;quot;form&amp;gt;input&amp;quot;)                        # form子元素中input元素个数，不包括下层元素&#xA;    $(&amp;quot;form+input&amp;quot;)                        # form同级并且下面的第一个input元素&#xA;    $(&amp;quot;form~input&amp;quot;)                        # form同级并且下面的所有input元素&#xA;子元素选择器                # 只选择一个&#xA;    $(&amp;quot;ul li:first&amp;quot;)                # ul中第一个子元素li&#xA;    $(&amp;quot;ul li:last&amp;quot;)                        # ul中最后一个子元素li&#xA;    $(&amp;quot;input:not(:checked)&amp;quot;)                        # input标签中所有未选中的元素&#xA;    $(&amp;quot;table tr:even&amp;quot;)                # 表格的奇数行（索引号为偶数）&#xA;    $(&amp;quot;table tr:odd&amp;quot;)                # 表格的偶数行（索引号为奇数）&#xA;    $(&amp;quot;table tr:eq(1)&amp;quot;)                # table中索引号等于1的行&#xA;    $(&amp;quot;table tr:gt(0)&amp;quot;)                # table中索引号大于0的行（不包括0）&#xA;    $(&amp;quot;table tr:lt(2)&amp;quot;)                # table中索引号小于2的行（不包括2）&#xA;    $(&amp;quot;:header&amp;quot;)                        # 匹配如 h1, h2, h3之类的标题元素&#xA;内容选择器&#xA;    $(&amp;quot;div:contains(&#39;Join&#39;)&amp;quot;)                # div 标签的html()中包含&#39;Join&#39;字符串的元素&#xA;    $(&amp;quot;p:empty&amp;quot;)                        # p 标签的html()的内容为空的元素&#xA;    $(&amp;quot;div:has(p)&amp;quot;)                        # div标签中包含p标签的该div标签&#xA;    $(&amp;quot;p:parent&amp;quot;);                        # 非空的p标签元素，即p为父元素&#xA;可见性选择器&#xA;    $(&amp;quot;tr:hidden&amp;quot;)                        # 查找隐藏的tr元素，如&amp;lt;tr style=&amp;quot;display:none&amp;quot;&amp;gt;&#xA;                                                                                                    &amp;lt;td&amp;gt;Value 1&amp;lt;/td&amp;gt;&#xA;                                                                                            &amp;lt;/tr&amp;gt;&#xA;    $(&amp;quot;tr:visible&amp;quot;)                        # 查找可见的tr元素&#xA;属性选择器&#xA;    $(&amp;quot;div[id]&amp;quot;)                        # 含有id属性的div元素&#xA;    $(&amp;quot;input[name=&#39;newsletter&#39;]&amp;quot;)                        # 所有name属性是newsletter的input元素&#xA;    $(&amp;quot;input[name!=&#39;newsletter&#39;]&amp;quot;)                        # 所有name属性不是newsletter的input元素&#xA;    $(&amp;quot;input[name^=&#39;news&#39;]&amp;quot;)                                # name以&#39;news&#39;开始的input元素&#xA;    $(&amp;quot;input[name$=&#39;leter&#39;]&amp;quot;)                                # name 以&#39;letter&#39;结尾的input元素&#xA;    $(&amp;quot;input[name*=&#39;news&#39;]&amp;quot;)                                # name包含&#39;news&#39;的input元素&#xA;    $(&amp;quot;input[id][name$=&#39;leter&#39;]&amp;quot;)                        # 含有id属性，并且它的name属性是以&amp;quot;letter&amp;quot;结尾的input 元素&#xA;子元素选择器&#xA;    $(&amp;quot;ul li:first-child&amp;quot;);                        # 匹配多个ul中的第一个子li元素的li元素集合&#xA;    $(&amp;quot;ul li:last-child&amp;quot;);                                # 匹配多个ul中的最后一个子li元素的li元素集合&#xA;    $(&amp;quot;ul li:nth-child(1)&amp;quot;);                        # 匹配多个ul中的第一个子li元素的li元素集合,注意：标记从1开始(eq 从0开始)&#xA;    $(&amp;quot;ul li:only-child&amp;quot;);                                # 匹配多个ul中的只有一个li元素的li元素集合&#xA;表单选择器&#xA;    $(&amp;quot;:input&amp;quot;);        # 所有input元素，包括select textarea button等&#xA;    $(&amp;quot;:text&amp;quot;);        # 所有文本框&#xA;    $(&amp;quot;:password&amp;quot;);    # 密码框&#xA;    $(&amp;quot;:radio&amp;quot;);        # 单选框&#xA;    $(&amp;quot;:checkbox&amp;quot;);    # 复选框&#xA;    $(&amp;quot;:submit&amp;quot;);      # 提交按钮&#xA;    $(&amp;quot;:image&amp;quot;);        # 有提交功能的图片&#xA;    $(&amp;quot;:reset&amp;quot;);        # 重置按钮&#xA;    $(&amp;quot;:button&amp;quot;);      # 按钮，包括&amp;lt;button&amp;gt;&amp;lt;/button&amp;gt;&#xA;    $(&amp;quot;:file&amp;quot;);        # 文件域&#xA;    $(&amp;quot;:input:hidden&amp;quot;);    # 隐藏域&#xA;表单对象属性&#xA;    $(&amp;quot;:input:enabled&amp;quot;);        # 所有可用的input元素&#xA;    $(&amp;quot;:input:disabled&amp;quot;)        # 所有不可用的input元素&#xA;    $(&amp;quot;:checkbox:checked&amp;quot;);    # 所有已选中的checkbox(有checked属性的)元素    $(&amp;quot;:checkbox:not(:checked)&amp;quot;);  未选中的checkbox&#xA;    $(&amp;quot;:select option:selected&amp;quot;);      # 所有已选中的option元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;基础函数&#34;&gt;&#xA;  基础函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;对象访问&#xA;    size()          # 同length,返回元素个数&#xA;    length          # 同size(),返回元素个数&#xA;    get(index)      # 取得一个匹配的元素,从0开始&#xA;    each(function(){});                        # 遍历调用该方法的元素数组中的元素，其中的this代表循环中的每一个元素&#xA;    &#xA;属性&#xA;    val()                              # value属性的值，或option元素之间的值&#xA;    val(&amp;quot;&amp;quot;)                        # 设置value的值&#xA;    var([&amp;quot;Multiple2&amp;quot;, &amp;quot;Multiple3&amp;quot;]);        # 设置select 下option的值&#xA;    html()                                # 相当于innerHTML ,同样不支持xml&#xA;    attr(&amp;quot;&amp;quot;)                        # 查找属性&#xA;    attr(&amp;quot;checked&amp;quot;,&amp;quot;checked&amp;quot;)                # 设置checked属性的值为&amp;quot;checked&amp;quot;&#xA;    removeAttr(&amp;quot;align&amp;quot;);                # 删除属性&#xA;    样式类（css）&#xA;        addClass(&amp;quot;myClass&amp;quot;);          # 添加 css 样式&#xA;        removeClass(&amp;quot;myClass&amp;quot;);        # 删除样式&#xA;        toggleClass(&amp;quot;myClass&amp;quot;);        # 切换样式，有变无，无变有&#xA;        hasClass(&amp;quot;myClass&amp;quot;)            # 返回是否有样式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;筛选&#34;&gt;&#xA;  筛选&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ad%9b%e9%80%89&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;过滤&#xA;        eq(index)                                                # 从0开始的第index元素&#xA;        is(expr)                                                # 判断元素中是否有符合expr的元素（如&amp;quot;form&amp;quot;），有则返回true,无则返回false&#xA;        first()                                                        # 第一个元素&#xA;        last()                                                        # 最后一个元素&#xA;        filter(expr)                                        # 筛选出符合表达式的集合&#xA;        has(expr)                                                # 保留符合expr的元素，去掉不符合的&#xA;        not(expr)                                                # 删除符合expr的元素，与has相反&#xA;查找&#xA;    find(&amp;quot;&amp;quot;);                      # 搜索所有与指定表达式匹配的后代元素&#xA;    children()                      # 取得所有直接子元素，不包含后代&#xA;    next()                          # 下一个同级兄弟&#xA;    prev();                        # 上一个同级兄弟&#xA;    parent(&amp;quot;&amp;quot;)                      # 含着所有匹配元素的唯一父元素 ,可以用选择器筛选&#xA;    parents(&amp;quot;p&amp;quot;)                    # $(&amp;quot;span&amp;quot;).parents(&amp;quot;p&amp;quot;) 每个span的所有是p元素的祖先元素&#xA;    nextAll()                      # 之后所有同级兄弟&#xA;    prevAll()                      # 之前所有同级兄弟&#xA;    siblings()                      # 上下的所有同级兄弟&#xA;对象处理&#xA;    replaceWith()                  # $(&amp;quot;p&amp;quot;).replaceWith(&amp;quot;&amp;lt;b&amp;gt;Paragraph. &amp;lt;/b&amp;gt;&amp;quot;); 替换p节点为自制的粗体节点&#xA;    remove()                        # 自己删除自己&#xA;    clone()                        # 复制自己  clone(true) 会复制行为&#xA;    内部插入&#xA;        append(content)            # 元素内部之后添加元素，相当于appendChild()&#xA;        prepend(content)            # 元素内部之前添加元素&#xA;    外部插入&#xA;        after(content)              # 元素同级之后插入&#xA;        before(content)            # 元素同级之前插入&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;事件函数&#34;&gt;&#xA;  事件函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e4%bb%b6%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;change(fn)              # $(&amp;quot;select&amp;quot;).change(function(){})  dom 中的onchange事件，元素内容变化时触发&#xA;submit(fn)              # $(&amp;quot;form&amp;quot;).submit(function(){})  选中表单提交时触发，多用于简单检测输入&#xA;                # 该事件函数中写return false;代表不提交表单&#xA;focus(fn)              # $(&amp;quot;:text&amp;quot;).focus();      将光标定位到input text表单中&#xA;select(fn)              # 选中  如 $(function(){  $(&amp;quot;:text&amp;quot;).select(); $(&amp;quot;:text&amp;quot;).focus(); })  页面加载时定位光标到input text文本域，并选中其中的文字        &#xA;mouseover(fn)           &#xA;mouseout(fn)&#xA;mousemove(function(e){})          # 鼠标移动时执行 ie 中已经定义参数，不用传递，直接用event，event.clientX,event.clientY分别得到鼠标的x,y坐标&#xA;keyup(fn)                  # ie 中 event.keyCode得到按键编码(firefox 中传递参数e,e.which得到按键编码)&#xA;ready(fn)              # $(document).ready(fn) 相当于window.load()事件，但可以写多个&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;css函数&#34;&gt;&#xA;  css函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#css%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);                # 设置style属性&#xA;    addClass(&amp;quot;myClass&amp;quot;)                                # 添加css样式&#xA;removeClass(&amp;quot;myClass&amp;quot;)              # 删除样式&#xA;toggleClass(&amp;quot;myClass&amp;quot;)              # 切换样式，有则删除，无则添加&#xA;hasClass(&amp;quot;myClass&amp;quot;)                # 是否有样式，返回true或false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;效果函数&#34;&gt;&#xA;  效果函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%88%e6%9e%9c%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;slideUp(speed,fn)      # 向上滑动,如$(&amp;quot;div&amp;quot;).slideUp(200);&#xA;slideToggle(speed,fn)  # 滑上滑下切换,如$(&amp;quot;div&amp;quot;).slideToggle(200);&#xA;&#xA;show(speed,fn)          # 元素从无到有动画显示出来&#xA;hide(speed,fn)          # 元素从有到无隐藏起来&#xA;toggle(speed,fn)        # 有则无，无则有隐藏、显示元素&#xA;fadeIn(speed,fn)        # 淡入显示图片&#xA;fadeOut(speed,fn)      # 淡出隐藏图片&#xA;animate(styles,speed,easing,callback)                # 自定义动画。只有数字值可创建动画（比如 &amp;quot;margin:30px&amp;quot;）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具函数&#34;&gt;&#xA;  工具函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;$.trim(str)            # 去除str字符串开头和结尾的空白&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;其它函数&#34;&gt;&#xA;  其它函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b6%e5%ae%83%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;serialize()            # 序列表单内容为字符串  ajax提交表单时可以        var sendData = $(&amp;quot;form&amp;quot;).serialize();  给sendData赋值传递表单信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;特殊使用&#34;&gt;&#xA;  特殊使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e6%ae%8a%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;$(document)    # 得到document区  ，可以定义事件，如$(document).mousemove(fn);&#xA;                $(document).ready(fn); 相当于$(fn)&#xA;$(fn)          # 相当于window.load ,在页面加载时执行，可以写多个，（而window.load只能一个生效，后面的会覆盖前面的）&#xA;$(&amp;quot;&amp;lt;div id=&#39;2013&#39;&amp;gt;ss&amp;lt;/idv&amp;gt;&amp;quot;);      # 创建一个元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;与dom之间的转换&#34;&gt;&#xA;  与dom之间的转换&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8edom%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    var $input = $(inputElemenet); // 注意，没有双引号&#xA;    var inputElement = $input.get(0); // jquery相当于存储了dom对象的数组 &#xA;      var inputElement = $input[0];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;ajax&#34;&gt;&#xA;  ajax&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ajax&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;load(url)                      # $(&amp;quot;span&amp;quot;).css(&amp;quot;color&amp;quot;,&amp;quot;red&amp;quot;).load(url)        无参以get方式提交，返回的值直接作为&amp;lt;span&amp;gt;标签内的文本节点值&#xA;load(url,sendData);            # 有参以post的方式提交&#xA;                                ## var sendData = {&amp;quot;username&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;password&amp;quot;:&amp;quot;psw&amp;quot;};  sendData的内容用json的语法写&#xA;load(url,sendData,function(backData,textStatus,ajax){});          # 加上处理返回值的函数,服务器返回数据时调用此函数&#xA;                                                                  ##  其中backData是返回的字符串,textStatus是响应头状态码的值对应的信息（success代表200）,ajax是ajax引擎对象&#xA;                                                                  ##  &amp;lt;span&amp;gt;标签的文本节点的值仍会被改变&#xA;                                                                  ##  可以只写一个参数：backData，参数的名字可以任意更改&#xA;$.get(url,sendData,function(backData,textStatus,ajax){});          # 用get方式提交ajax模拟的表单&#xA;$.post(url,sendData,function(backData,textStatus,ajax){});          # 用post方式提交ajax模拟的表单 响应头 content-type = &amp;quot;application/x-www-form-urlencoded&amp;quot; 会自动设置好&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;jquery提供&#xA;    fixedtableheader&#xA;    tablesort&#xA;    tools&#xA;    ui&#xA;    hashchange&#xA;        控制浏览器的前进后退到一个页面中(不必刷新)&#xA;    easing&#xA;        jquery的动画扩展, 比如动画执行的速度曲线&#xA;代码&#xA;    icanhaz&#xA;    mustache&#xA;功能&#xA;    fileupload&#xA;    treeview&#xA;        文件&#xA;                jquery.treeview.js                        # treeview插件简化板&#xA;                jquery.treeview.edit.js                # 可编辑的菜单&#xA;                jquery.treeview.css                        # treeview可选使用的样式&#xA;                &#xA;        使用&#xA;                $(&amp;quot;#root&amp;quot;).treeview({                        # $(&amp;quot;#root&amp;quot;)是顶层ul元素&#xA;                        /* 展开还是收起, 默认为false 展开*/&#xA;                        collapsed: true,&#xA;                        /* 唯一的, 当前菜单打开的时候其他菜单收缩*/&#xA;                        unique: true,&#xA;                        /*动态加载菜单（接收json数据）*/&#xA;                        url: &amp;quot;source.do&amp;quot;&#xA;                });&#xA;                        # 动态加载菜单时接收的数据格式为&#xA;                                [&#xA;                                {&#xA;                                &amp;quot;text&amp;quot;: &amp;quot;1. Pre Lunch (120 min)&amp;quot;,&#xA;                                &amp;quot;expanded&amp;quot;: true,&#xA;                                &amp;quot;classes&amp;quot;: &amp;quot;important&amp;quot;,&#xA;                                &amp;quot;children&amp;quot;:&#xA;                                [&#xA;                                {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;1.1 The State of the Powerdome (30 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;1.2 The Future of jQuery (30 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;1.2 jQuery UI - A step to richnessy (60 min)&amp;quot;&#xA;                                }&#xA;                                ]&#xA;                                },&#xA;                                {&#xA;                                &amp;quot;text&amp;quot;: &amp;quot;2. Lunch  (60 min)&amp;quot;&#xA;                                },&#xA;                                {&#xA;                                &amp;quot;text&amp;quot;: &amp;quot;3. After Lunch  (120+ min)&amp;quot;,&#xA;                                &amp;quot;children&amp;quot;:&#xA;                                [&#xA;                                {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.1 jQuery Calendar Success Story (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.2 jQuery and Ruby Web Frameworks (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.3 Hey, I Can Do That! (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.4 Taconite and Form (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.5 Server-side JavaScript with jQuery and AOLserver (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.6 The Onion: How to add features without adding features (20 min)&amp;quot;,&#xA;                                        &amp;quot;id&amp;quot;: &amp;quot;36&amp;quot;,&#xA;                                        &amp;quot;hasChildren&amp;quot;: true&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.7 Visualizations with JavaScript and Canvas (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.8 ActiveDOM (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.8 Growing jQuery (20 min)&amp;quot;&#xA;                                }&#xA;                                ]&#xA;                                }&#xA;                                ]&#xA;                                        # &amp;quot;expanded&amp;quot;: true 代表这个结点下的child是展开的。&#xA;                                        # 返回的json字符串中的双引号必须是双引号。&#xA;                                        ## 初次请求时传递数据 root=source,点击节点申请数据时传递id值，如3.6中有id为36，且hasChildren:true,点击后传递36，我们再据此返回相应json数据。&#xA;                        &#xA;                &#xA;                引入css文件，根据其中的样式对页面进行设置&#xA;    validate&#xA;        使用&#xA;                验证写在&amp;lt;head&amp;gt;中时，要写在页面加载中（$(function{})）                # 否则读取&amp;lt;head&amp;gt;时，页面还没有加载，没有表单&#xA;                验证完成触发事件&#xA;                        失败事件：errorPlacement:function(error,element){}                        # error是错误消息，element是求救消息的js对象 &#xA;                        成功事件：success:function(label){}                        # label是显示消息的js对象&#xA;                远程验证：发送ajax请求到指定url                # 自动传递验证名与验证值，ie中get请求调用浏览器缓存，所以用户回退字符时不提交。所以用post方式发送请求&#xA;                                                                        ## 返回&amp;quot;true&amp;quot;表示成功，&amp;quot;false&amp;quot;表示失败&#xA;                        remote:{&#xA;                                url:&amp;quot;/outrun/servlet/JqueryValidateServlet&amp;quot;,&#xA;                                type:&amp;quot;post&amp;quot;&#xA;                        }&#xA;                简单例子：&#xA;                        $(&amp;quot;form&amp;quot;).validate({&#xA;                                debug:true,&#xA;                                rules:{&#xA;                                        name:{&#xA;                                                required:true,&#xA;                                                rangelength:[6,12]&#xA;                                        },&#xA;                                },&#xA;                                messages:{&#xA;                                        name:{&#xA;                                                required:&amp;quot;用户名必填&amp;quot;,&#xA;                                                rangelength:$.format(&amp;quot;用户名长度必须在{0}-{1}之间&amp;quot;)&#xA;                                        },&#xA;                                }&#xA;                        });&#xA;&#xA;        兼容：&#xA;                不同validate验证框架要求不同的jquery版本&#xA;                validate1.5.2配jquery1.3&#xA;                &#xA;        经验&#xA;                默认情况是丢失焦点验证,如果验证失败则 在失败的文本框每次输入数据都会触发onkeyup&#xA;                        设置        onkeyup:false&#xA;                        &#xA;        样式&#xA;                默认是class=&amp;quot;error&amp;quot;的样式，可以在页面中自定义.error{}样式取代，但是这样除了出错信息的样式修改外，用户输入信息的样式也会修改&#xA;                错误信息是以添加&amp;lt;label&amp;gt;标签的形式显示的，所以可以添加&amp;lt;label&amp;gt;标签的样式，如form label{}&#xA;    acccordion  下拉菜单&#xA;    autocomplete    自动补全(用索引库)&#xA;    password Vlidation 密码强度&#xA;    prettdate 日期插件&#xA;    message 消息框&#xA;报表&#xA;    highcharts&#xA;    jscharts&#xA;    am charts&#xA;        对象与属性&#xA;            对象                # 静态创建&#xA;                AmCharts.AmSerialChart()                 序列图&#xA;                        属性&#xA;                                dataProvider        数据&#xA;                                        # 接收json数据&#xA;                                categoryAxis        横坐标&#xA;                                        属性&#xA;                                                labelRotation          横坐标显示名角度&#xA;                                                gridPosition                网格的起始位置,&amp;quot;start&amp;quot;表示开始处&#xA;                                                dashLength                值为数字，网格中垂直线虚线程度 ，0代表实线&#xA;                                categoryField        横坐标显示名(dataProvider数据中的字段名)&#xA;                                depth3D        3D图形深度&#xA;                                angle                3D图形角度(左上俯角)&#xA;                                creditsPosition        未购买之前的商标位置，如&amp;quot;top-right&amp;quot;表示右上。&#xA;                        方法&#xA;                                write(&amp;quot;chartdiv&amp;quot;)                # 要绘图div的id属性值&#xA;                AmCharts.AmPieChart()                饼图&#xA;                AmCharts.AmSerialChart()         雷达图&#xA;                AmCharts.AmXYChart()                离散图&#xA;                AmCharts.AmLegend()                图例&#xA;                AmCharts.ValueAxis()                纵坐标&#xA;                        # 通过 AmCharts对象中图对象的addValueAxis()方法给图添加本属性&#xA;                        属性&#xA;                                title                        纵坐标标题&#xA;                                dashLength                值为数字，网格中水平线虚线程度 ，0代表实线&#xA;                AmCharts.AmGraph()                图形&#xA;                        # 通过 AmCharts对象中图对象的addGraph()方法给图添加本属性&#xA;                        属性&#xA;                                colorField                值为dataProvider提供数据中的字段名，表示数据在报表中的颜色&#xA;                                valueField                值为dataProvider提供数据中的字段名，表示占有数值的多少&#xA;                                balloonText                鼠标悬停时气球中的内容，用[[value]], [[description]], [[percents]], [[open]], [[category]] 等标记来引用数据&#xA;                                                        也可以用html标签，如： &amp;quot;&amp;lt;span style=&#39;font-size:14px&#39;&amp;gt;[[category]]: &amp;lt;b&amp;gt;[[value]]&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt;&amp;quot;&#xA;                                lineAlpha                0或1，代表数据图形是否有边界&#xA;                                fillAlpha                代表数据图形是否透明，0为透明&#xA;                                &#xA;                        AmSerialChart中AGraph的属性&#xA;                                type                        数据图形的形状，如&amp;quot;column&amp;quot;代表方块柱状图&#xA;                AmCharts.ChartCursor()                光标&#xA;                        # 通过 AmCharts对象中图对象的addChartCursor()方法给图添加本属性&#xA;                        属性&#xA;                                cursorAlpha                0或1，是否显示鼠标跟随线&#xA;                                zoomable                true或false 是否可以用鼠标选中来放大&#xA;                                categoryBalloonEnabled                        true或false 是否跟随鼠标显示横坐标种类名&#xA;            方法2                # 动态创建&#xA;                AmCharts.makeChart(&amp;quot;&amp;quot; , json);&#xA;                        参数1 : 要产生图形的div的id&#xA;                        参数2 : json格式的产生条件&#xA;                                type : 图形类型，如&amp;quot;pie&amp;quot;&#xA;                                dataProvider : 图形数据&#xA;                                titleField : 需要显示的种类名对应在dataProvider中的字段名&#xA;                                valueField : 需要显示的权重对应在dataProvider中的字段名&#xA;                                legend : json数据，图例的产生条件&#xA;                                        align : 对齐条件，如&amp;quot;center&amp;quot;&#xA;                                        markerType : 图例的形状，如&amp;quot;circle&amp;quot;&#xA;        使用1&#xA;                var chart;&#xA;                var chartData = [ {&#xA;                        &amp;quot;country&amp;quot; : &amp;quot;USA&amp;quot;,&#xA;                        &amp;quot;visits&amp;quot; : 4025,&#xA;                        &amp;quot;color&amp;quot; : &amp;quot;#FF0F00&amp;quot;&#xA;                }, {&#xA;                        &amp;quot;country&amp;quot; : &amp;quot;China&amp;quot;,&#xA;                        &amp;quot;visits&amp;quot; : 1882,&#xA;                        &amp;quot;color&amp;quot; : &amp;quot;#FF6600&amp;quot;&#xA;                } ];&#xA;&#xA;                AmCharts.ready(function() {&#xA;                                        // SERIAL CHART&#xA;                                        chart = new AmCharts.AmSerialChart();&#xA;                                        chart.dataProvider = chartData;&#xA;                                        chart.categoryField = &amp;quot;country&amp;quot;;&#xA;                                        // the following two lines makes chart 3D&#xA;                                        chart.depth3D = 20;&#xA;                                        chart.angle = 30;&#xA;&#xA;                                        // AXES&#xA;                                        // category&#xA;                                        var categoryAxis = chart.categoryAxis;&#xA;                                        categoryAxis.labelRotation = 0;&#xA;                                        categoryAxis.gridPosition = &amp;quot;start&amp;quot;;&#xA;&#xA;                                        // value&#xA;                                        var valueAxis = new AmCharts.ValueAxis();&#xA;                                        valueAxis.title = &amp;quot;Visitors&amp;quot;;&#xA;                                        chart.addValueAxis(valueAxis);&#xA;&#xA;                                        // GRAPH&#xA;                                        var graph = new AmCharts.AmGraph();&#xA;                                        graph.valueField = &amp;quot;visits&amp;quot;;&#xA;                                        graph.colorField = &amp;quot;color&amp;quot;;&#xA;                                        graph.balloonText = &amp;quot;&amp;lt;span style=&#39;font-size:14px&#39;&amp;gt;[[category]]: &amp;lt;b&amp;gt;[[value]]&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt;&amp;quot;;&#xA;                                        graph.type = &amp;quot;column&amp;quot;;&#xA;                                        graph.lineAlpha = 0;&#xA;                                        graph.fillAlphas = 1;&#xA;                                        chart.addGraph(graph);&#xA;&#xA;                                        // CURSOR&#xA;                                        var chartCursor = new AmCharts.ChartCursor();&#xA;                                        chartCursor.cursorAlpha = 0;&#xA;                                        chartCursor.zoomable = false;&#xA;                                        chartCursor.categoryBalloonEnabled = false;&#xA;                                        chart.addChartCursor(chartCursor);&#xA;&#xA;                                        chart.creditsPosition = &amp;quot;top-right&amp;quot;;&#xA;&#xA;                                        // WRITE&#xA;                                        chart.write(&amp;quot;chartdiv&amp;quot;);&#xA;                                });&#xA;        使用2&#xA;                AmCharts.makeChart(&amp;quot;chartdiv&amp;quot;, {&#xA;                        type: &amp;quot;pie&amp;quot;,&#xA;                        dataProvider: [{&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Czech Republic&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 156.9&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Ireland&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 131.1&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Germany&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 115.8&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Australia&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 109.9&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Austria&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 108.3&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;UK&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 65&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Belgium&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 50&#xA;                        }],&#xA;                        titleField: &amp;quot;country&amp;quot;,&#xA;                        valueField: &amp;quot;litres&amp;quot;,&#xA;                        balloonText: &amp;quot;[[title]]&amp;lt;br&amp;gt;&amp;lt;span style=&#39;font-size:14px&#39;&amp;gt;&amp;lt;b&amp;gt;[[value]]&amp;lt;/b&amp;gt; ([[percents]]%)&amp;lt;/span&amp;gt;&amp;quot;,&#xA;                        legend: {&#xA;                            align: &amp;quot;center&amp;quot;,&#xA;                            markerType: &amp;quot;circle&amp;quot;&#xA;                        }&#xA;&#xA;                    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;习惯&#34;&gt;&#xA;  习惯&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b9%a0%e6%83%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;命名方式规律&#xA;        jquery.插件名.功能名.js&#xA;        &#xA;存储&#xA;        网站js/下        分子文件夹存放不同插件的文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;自定义&#34;&gt;&#xA;  自定义&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;函数&#xA;        jQuery.extend(object);          # 直接调用&#xA;        jQuery.fn.extend(object);      # 对象调用 $.extend($.fn,{})或$fn.extend({})&#xA;例子&#xA;        $.extend({&#xA;                max : function(a, b) {&#xA;                        return a &amp;gt; b ? a : b;&#xA;                },&#xA;                min : function(a, b) {&#xA;                        return a &amp;lt; b ? a : b;&#xA;                }&#xA;        });&#xA;        $.fn.extend({&#xA;                max1 : function(a, b) {&#xA;                        return a &amp;gt; b ? a : b;&#xA;                }&#xA;        });&#xA;        $.extend($.fn, {&#xA;                min1 : function(a, b) {&#xA;                        return a &amp;lt; b ? a : b;&#xA;                }&#xA;        })&#xA;        alert($.max(1, 2));&#xA;        alert($(&amp;quot;html&amp;quot;).max1(2, 1));&#xA;        alert($(&amp;quot;html&amp;quot;).min1(1, 2));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;问题&#34;&gt;&#xA;  问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;页面中引用jquery&#xA;        只能用&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;的形式，而不能用&amp;lt;script/&amp;gt;的形式&#xA;        引用的src必须写相对路径&#xA;        引用的&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;代码必须写在使用之前&#xA;        webroot/web-inf/不能用相对路径访问webRoot/下的文件，所以不能包含jquery文件。所以要用${pageContext.request.contextPath}/来访问&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jquery-mobile&#34;&gt;&#xA;  jquery mobile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jquery-mobile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>React</title>
      <link>https://runout.run/docs/middleware/library_frontend/react/</link>
      <pubDate>Thu, 11 Oct 2018 07:32:08 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/react/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;facebook推出的用于build user interfaces 的类库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; webpack&#xA;# webpack.config.js&#xA;var webpack = require(&#39;webpack&#39;)&#xA;module.exports = {&#xA;        devtool: &#39;inline-source-map&#39;,&#xA;        entry: [&#39;webpack/hot/dev-server&#39;, __dirname + &#39;/app/main.js&#39;],&#xA;        output: {&#xA;                path: __dirname + &#39;/build&#39;,&#xA;                filename: &#39;bundle.js&#39;&#xA;        },&#xA;        module: {&#xA;                loaders: [&#xA;                        {&#xA;                                test: /\.(js|jsx)$/,&#xA;                                exclude: /node_modules/,&#xA;                                loader: &#39;babel-loader&#39;,&#xA;                        }&#xA;                ]&#xA;        },&#xA;        plugins: [&#xA;                new webpack.HotModuleReplacementPlugin(),&#xA;                new webpack.DefinePlugin({&#xA;                        &#39;process.env&#39;: {&#xA;                                NODE_ENV: JSON.stringify(&#39;production&#39;)&#xA;                        }&#xA;                })&#xA;        ],&#xA;        devServer: {&#xA;                contentBase: __dirname + &#39;/build&#39;,&#xA;                historyApiFallback: true,&#xA;                inline: true,&#xA;                port: 3031,&#xA;        }&#xA;}&#xA;&#xA;# index.html&#xA;&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;script src=&amp;quot;bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&#xA;&#xA;o-&amp;gt; browser&#xA;# index.html&#xA;&amp;lt;script src=&amp;quot;build/react.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;build/react-dom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;browser.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;        &amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;        &amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt;&#xA;                ReactDOM.render(&#xA;                        &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&#xA;                        document.getElementById(&#39;example&#39;)&#xA;                )&#xA;        &amp;lt;/script&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ReactDOM&#xA;        render&#xA;                render(&#xA;                        &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&#xA;                        document.getElementById(&#39;example&#39;)&#xA;                )&#xA;React&#xA;        # createClass&#xA;        createClass({&#xA;                getInitialState () {return {liked: false}},&#xA;                handleClick(event) {&#xA;                        this.setState({liked: !this.state.liked})&#xA;                },&#xA;                getDefaultProps () {&#xA;                        # 设定属性默认值&#xA;                        return {title: &#39;Hello&#39;}&#xA;                },&#xA;                propTypes: {&#xA;                        # 限定属性的类型&#xA;                        title: React.PropTypes.string,isRequired&#xA;                },&#xA;                render () {return &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;}&#xA;        })&#xA;        # createElement&#xA;        createElement(&#39;h1&#39;, {title: &#39;a&#39;}, &#39;b&#39;)&#xA;        # Component&#xA;        class List extends React.Component{&#xA;                constructor() {super()}&#xA;                render() {return ()}&#xA;        }&#xA;        &#xA;this&#xA;        # 代表当前标签&#xA;        props&#xA;                # 属性&#xA;                children&#xA;                        # 代表所有子节点的text&#xA;                        # 没有子节点, 是undefined, 有一个子节点, 是Object, 多个子节点是array&#xA;                        # React.Children来处理children&#xA;        refs&#xA;                # 获取dom&#xA;        state&#xA;jsx&#xA;    介绍&#xA;            &amp;lt; 开头解析为html, { 开头解析为js&#xA;    例子&#xA;    # Profile.jsx&#xA;    import React from &#39;react&#39;;&#xA;    export default Class Profile extends React.Component {&#xA;            constructor (props) {&#xA;                    super(props)&#xA;                    this.state = {&#xA;                            list: [1,2,3],&#xA;                            activeIndex: -1&#xA;                    }&#xA;            },&#xA;            activate (index) {&#xA;                    this.setState({activeIndex: index})&#xA;            },&#xA;            render () {&#xA;                    const {list, activeIndex} = this.state&#xA;                    const lis = list.map((item, index) =&amp;gt; {&#xA;                            const cls = index === activeIndex ? &#39;active&#39; : &#39;&#39;&#xA;                            return (&#xA;                                    &amp;lt;li key={index} className={cls} onClick={() =&amp;gt; this.activate(index)}&amp;gt;&amp;lt;/li&amp;gt;&#xA;                            )&#xA;                    })&#xA;                    return (&amp;lt;ul&amp;gt;{lis}&amp;lt;/ul&amp;gt;)&#xA;            }&#xA;    }&#xA;&#xA;&#xA;    o-&amp;gt;&#xA;    &amp;lt;div&amp;gt;&#xA;    {/*注释*/}&#xA;    {&#xA;            names.map((name) =&amp;gt; {return &amp;lt;div&amp;gt;{name}&amp;lt;/div&amp;gt;})&#xA;    }&#xA;    &amp;lt;/div&amp;gt;&#xA;&#xA;    o-&amp;gt; ref&#xA;    &amp;lt;input ref=&amp;quot;domNam&amp;quot;&amp;gt;&#xA;&#xA;    o-&amp;gt; 事件&#xA;    &amp;lt;p onClick={this.handleClick}&amp;gt;&#xA;&#xA;    o-&amp;gt; 属性&#xA;    &amp;lt;Profile {...props} name=&#39;a&#39;&amp;gt;&#xA;            # 后面的覆盖前面的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;react-big-calendar&#xA;    日历&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;JSXTransformer&#xA;        # 浏览器中引入，编译jsx&#xA;https://babeljs.io/repl/&#xA;        # 在线编译jsx&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>产品规划</title>
      <link>https://runout.run/docs/architect/method/product_plan/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/architect/method/product_plan/</guid>
      <description>&lt;h1 id=&#34;云服务&#34;&gt;&#xA;  云服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;本质&#xA;    批发转零售&#xA;    帮助别人成功而成功&#xA;    产品型转服务型&#xA;优势&#xA;    轻，方便&#xA;    全&#xA;    可计算&#xA;现象&#xA;    外包被淘汰&#xA;行业&#xA;    OS of business&#xA;功能&#xA;    产品功能，样板&#xA;    开发体验，文档&#xA;    组件收费，容量收费，节省的成本收费&#xA;    数据直接做决策&#xA;    分类&#xA;        service&#xA;            # 基础服务&#xA;        plugins&#xA;            # 基础服务组合&#xA;        app&#xA;            # plugins组合&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;产业互联网&#34;&gt;&#xA;  产业互联网&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%a7%e4%b8%9a%e4%ba%92%e8%81%94%e7%bd%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;供应链&#34;&gt;&#xA;  供应链&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%9b%e5%ba%94%e9%93%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;为什么&#xA;    大厂核心&#xA;        各节点(库存)周转&#xA;是什么&#xA;    资源 -&amp;gt; 渠道 -&amp;gt; 用户&#xA;        反馈用户真实需求&#xA;        上游关注制造业&#xA;        下游关注erp&#xA;    批量(精), 个性化(敏)&#xA;&#xA;    物流, 资金流(现金流), 信息流&#xA;    库存管理&#xA;        应对变化(保质期)&#xA;        求零库存&#xA;    供应商&#xA;        评级&#xA;        物流, 成本&#xA;        难点&#xA;            打通&#xA;怎么样&#xA;    成本、利用率&#xA;    可靠性, 反应力, 柔性(补错)&#xA;    感知、预测&#xA;    赋能&#xA;    重点&#xA;        按时制造&#xA;    难点&#xA;        协调(协议)&#xA;步骤&#xA;    单品上下游延伸&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;人工智能&#34;&gt;&#xA;  人工智能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;优化、预测&#xA;    拟合函数, 高阶微积分, 梯度下降&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;元宇宙&#34;&gt;&#xA;  元宇宙&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%83%e5%ae%87%e5%ae%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;传媒营销&#34;&gt;&#xA;  传媒营销&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%a0%e5%aa%92%e8%90%a5%e9%94%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;媒体&#34;&gt;&#xA;  媒体&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%aa%92%e4%bd%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;场景控制&#xA;    3CAD&#xA;        character&#xA;        camera&#xA;        control&#xA;        art direction&#xA;特效&#xA;    会场散射光束（博物馆）&#xA;    雾中焦点的竖光（saber的剑）&#xA;    画线的光点（最终幻想）&#xA;    密集的星星，远近缩放，光圈(tree.js官网）&#xA;    水滴带动整个屏幕的亮度(fate stay night)&#xA;    蓝色光影交错（fate stay night）&#xA;    秒针声强调时间(fate stay night)&#xA;    单帧卡动画渲染气氛(fsn)&#xA;    黑白画面到彩色画面(madlife 集锦[dream on])&#xA;    黑白画面彩色涟漪(冰果)&#xA;    地面的雾影(fsn)&#xA;    音乐重节拍时出现隐形单位/人(fsn)&#xA;    转动的星空光点线加云(fsn结尾)&#xA;    沙的立体塑型(秦时明月)&#xA;    红辣椒的分镜&#xA;网站效果&#xA;    图片向下拉，上面模糊小，下面清晰大，有一种震撼感&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>人员</title>
      <link>https://runout.run/docs/architect/manage/organize/people/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/architect/manage/organize/people/</guid>
      <description>&lt;h1 id=&#34;人-事-团队&#34;&gt;&#xA;  人, 事, 团队&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ba-%e4%ba%8b-%e5%9b%a2%e9%98%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;人&#xA;    业内口碑&#xA;    成分&#xA;        技能，素质，精神&#xA;    行动&#xA;        感性，理性，惯性&#xA;    发展&#xA;        上限&#xA;        下限&#xA;    成本&#xA;        低成本召回&#xA;事&#xA;    知原理&#xA;    是什么，为什么，怎么样，拆解&#xA;    事与团队&#xA;        事造就团队，好团队不一定出好成果&#xA;团队&#xA;    存在合理性&#xA;        有目标，成员能力认可，成员感性认可&#xA;        小精英团队，才能解决问题&#xA;    分配事&#xA;        因特质分配，如稳定，峰值，沟通&#xA;    成果评价&#xA;        产出判断&#xA;        分配利益和荣耀&#xA;        时间和代码量评价不了程序员的工作, 可以匿名互评(口碑)&#xA;    团队提升&#xA;        培训无意义，自觉成长&#xA;    成员&#xA;        项目经理&#xA;        设计&#xA;        开发&#xA;            测试人员&#xA;        运维&#xA;        系统工程师&#xA;            设计、实现产品&#xA;        数据分析师&#xA;        技术总监&#xA;        架构师&#xA;            权衡, 出方案&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;职工&#34;&gt;&#xA;  职工&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8c%e5%b7%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;态度&#xA;    把握分寸&#xA;    靠谱(事事有交代)&#xA;    负责(顾全局)&#xA;    主动&#xA;    超出预期&#xA;    负责态度, 提高团队效率，而非自己效率   # 严肃判断&#xA;沟通&#xA;    及早沟通、同步&#xA;    文档 &amp;gt; 邮件 &amp;gt; im &amp;gt; 电话&#xA;        # 即时性相反&#xA;    留响应时间, 同组 -&amp;gt; 跨组 -&amp;gt; 跨部门 -&amp;gt; 跨公司&#xA;    明确通知人时, 邮件, im特殊指定&#xA;文档&#xA;    周报&#xA;    文档简单有计划，为节省向别人解释的时间&#xA;    建设性意见(提选择题)&#xA;    只交“产品”: 背景清晰, 扼要, 完整, 引入独有经验&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工程师&#34;&gt;&#xA;  工程师&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e7%a8%8b%e5%b8%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;本质&#xA;    解决问题&#xA;普遍问题&#xA;    技能: 工具使用(写工具), 表面学习, 笨办法, 不会读文档, 只会知识迁移&#xA;    设计: 不知经典设计, 不知设计哲学, 不知目的, 无法反应需求, 没有品位, 读不懂设计&#xA;    知识更新: 学不动, 基础差(用二手资料), 无认知体系(认为都是新东西), 重复学习无用知识&#xA;    沟通: 不专业(不用专业名词), 不主动, 不沟通对方, 不抓重点, 思路不连贯, 阅历不足(不会写文档), 不问为什么&#xA;能力&#xA;    特点&#xA;        知识、经验、技能、协作         # (1+天赋)x知识x工程习惯&#xA;        犯错(多做多错)&#xA;    方法&#xA;        抽象                        # 设计就是从升维中拆分和简化&#xA;        沉淀                        # 没有沉淀的学习不好回顾修改, 像没有测试的代码&#xA;        品位&#xA;    优点，缺点                      # 找潜质, 并非此长彼短，是两个维度,有一定抑制作用&#xA;        创造力，纪律&#xA;        勤奋，聪明&#xA;        稳定，峰值&#xA;        深度，速度&#xA;        细节，大局&#xA;开发&#xA;    考虑工作的复用性&#xA;    加入项目，需要可对所有代码修改&#xA;    善用工具&#xA;    自己的事主动跟进&#xA;owner&#xA;    自我负责, 自我驱动, 持续改进&#xA;    能部署, 能手工排查问题，手工修复数据, 开发调试工具, 数据修复工具&#xA;    模块职责单一, 明白当前负责和极限性能&#xA;    能降级, 知道下游调用和降级影响。了解上游依赖和上游降级影响&#xA;    配好log、监控、告警, 告警及时响应&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;架构师&#34;&gt;&#xA;  架构师&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%b6%e6%9e%84%e5%b8%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;场景/用例/问题 -&amp;gt; 方案/方案权衡 -&amp;gt; 落地路径&#xA;分级&#xA;    初级&#xA;        代码&#xA;            命名：精确性、简单性、一致性、区别性、业务性&#xA;            逻辑: 缩进、换行&#xA;            代码体积: 行、方法、类&#xA;        抽象能力&#xA;        边界&#xA;    中级&#xA;        流量、并发等&#xA;    高级&#xA;        理解业务核心价值、业务实现方式&#xA;        业务技术支撑方式&#xA;        业务趋势&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;创始人&#34;&gt;&#xA;  创始人&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%a7%8b%e4%ba%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;心态: 平常心&#xA;职责: 找到善于解决问题的人，做好善于定义问题的人&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;艺术家&#34;&gt;&#xA;  艺术家&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%89%ba%e6%9c%af%e5%ae%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;岗位&#34;&gt;&#xA;  岗位&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b2%97%e4%bd%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;项目经理(pm, project manager)&#xA;技术经理(tm, technical manager)&#xA;产品设计经理(pdm, product design manager)&#xA;运营经理(pom)&#xA;测试经理(qam)&#xA;客服经理(csm, customer success manager)&#xA;开发组长(tl, team leader)&#xA;架构师(pa)&#xA;开发工程师(de, development engineer)&#xA;数据库管理员(dba, database administrator)&#xA;系统管理员(sa)&#xA;界面设计师(ui, user interface)&#xA;用户体验设计师(ue, user experience)&#xA;产品运营师(po, product operator)&#xA;产品设计师(pd, product designer)&#xA;测试工程师(qa, quality assurance)&#xA;配置管理员(pcm)&#xA;发布员(pb)&#xA;软件过程专员(sqa, software quality assurance)&#xA;运维工程师(sre, site reliability engineer)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;招聘&#34;&gt;&#xA;  招聘&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8b%9b%e8%81%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;双向选择&#xA;精确率&amp;amp;召回率&#xA;方面&#xA;    沟通&#xA;    喜欢技术，逻辑能力, 编码能力, 设计能力&#xA;    基本概念, 边界考虑充足, 进阶答案, 衍生问题的解决&#xA;    是否有自己思考，对自己负责&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>代码规划</title>
      <link>https://runout.run/docs/architect/method/code_plan/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/architect/method/code_plan/</guid>
      <description>&lt;h1 id=&#34;阻塞&#34;&gt;&#xA;  阻塞&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%bb%e5%a1%9e&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;阻塞(bio)指cpu等待io&#xA;非阻塞(nio)指调用io后立即返回，但要轮询事件状态&#xA;    # 非阻塞指对cpu不阻塞，但业务线程阻塞&#xA;轮询(单线程)&#xA;    read&#xA;        定时重复调用来检查&#xA;    select&#xA;        前后read, 中间select轮询检查文件描述符的事件状态&#xA;        采用1024长度数组存储状态，只能同时检查1024个文件描述符&#xA;    poll&#xA;        前后read, 中间poll&#xA;        用链表代替数组, 也避免了不必要的检查&#xA;    epoll   # linux&#xA;        前后read, 中间epoll&#xA;        epoll检查不到事件，休眠epoll线程直到事件将它唤醒&#xA;    kqueue  # freeBSD中，类似epoll&#xA;    aio     # async io, linux, 业务线程不阻塞&#xA;        通过回调(信号)传递数据，不必像epoll线程(业务线程)阻塞等待&#xA;        仅linux下有, 只O_DIRECT方式读取，不能利用系统缓存&#xA;    IOCP    # windows aio&#xA;模拟aio(io线程池)&#xA;    业务线程的io操作, 起io线程, io线程完成通信到业务线程触发回调&#xA;    库&#xA;        glibc(有bug)&#xA;        libeio&#xA;        node.js的libuv封装&#xA;            linux下自实现&#xA;            windows下IOCP&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;事件&#34;&gt;&#xA;  事件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;实现&#xA;    回调&#xA;    队列存事件, 单进程检测事件是否回调&#xA;库&#xA;    libevent&#xA;    libev       # bug比libevent少&#xA;工具&#xA;    epoll(select, poll)&#xA;    libev(libevent)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发并行&#34;&gt;&#xA;  并发并行&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91%e5%b9%b6%e8%a1%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;并发&#xA;    多任务共享时间段, 类比: 任务队列&#xA;    为什么并发&#xA;        多任务能力&#xA;        非阻塞&#xA;并行&#xA;    多任务同时处理, 类比: 多核处理器&#xA;    为什么并行&#xA;        提高执行效率&#xA;    分类&#xA;        任务并行化&#xA;        数据并行化&#xA;    cpu交替任务           # EDSAC串行任务&#xA;        协作式         # 可能独占，Windows3.1, Mac OS 9&#xA;        抢占式         # 任务管理器强制中断，Windows95, Mac OS 9以后版本, Unix, Linux&#xA;    竞态条件&#xA;        三条件&#xA;            两个处理共享变量&#xA;            一个修改中&#xA;            另一个介入&#xA;        没有共享&#xA;            Multics(1969年)进程共享内存        # Multics基于PL/I和汇编编写&#xA;            UNICS(1970年)进程不共享内存&#xA;            UNIX10年后，线程共享进程内存&#xA;            actor模型(1973年), 不共享内存，传递消息，异步       # Erlang, Scala&#xA;        共享内存但不修改                    # haskell所有变量，c++ const变量, scala val变量, java immutable(private属性没有setter)&#xA;        不介入修改&#xA;            线程协作式                     # ruby的Fibre, python/js的generator&#xA;            不便介入标志&#xA;                锁(有线程不检查锁，还是可以进入)               # 1965年提出，1974年改良为monitor。加解锁时，要求对锁的检查和修改同时执行&#xA;                    死锁问题&#xA;                    无法组合锁，组合要加新锁&#xA;                事务内存                   # 临时创建版本对其修改，更新失败重新执行&#xA;                    硬件事务内存(1986年硬件安装lisp的LM-2)     # 1986年cpu MIPS基于RISC简化指令成功，LM-2商业失败&#xA;                    软件事务内存(1995年论文), 2005年微软concurrent haskell论文&#xA;                        2004年IBM X10, 2006年Sun Fortress, 2007年Clojure, 2010年微软终止.NET软件事务内存&#xA;    并行代码&#xA;        编译代码顺序不确定，或执行顺序不确定&#xA;        看一句代码的内部实现, 在其中执行了行为&#xA;            go func () { x = make([]int, 10) }()&#xA;            x[9] = 1&#xA;    业务并行解耦条件(满足幺半群性质)&#xA;        封闭性     # 业务运算结果是业务&#xA;        结合律     # 业务a、b的结果后与c执行，等同b、c的结果与a执行&#xA;        单位元     # 恒等业务a与其它业务b执行，得b, 如reduce的初值&#xA;系统应用&#xA;    并发能力&#xA;    吞吐量(并行)&#xA;        I/O多路复用(epoll)&#xA;        cpu&amp;quot;多路复用&amp;quot;(进程、线程)&#xA;        cpu机制(多发射、流水线、超标量、超线程)&#xA;    进程线程应用&#xA;        cpu对任务的M:N处理&#xA;        进程切换处理任务&#xA;        线程(通信，并行)&#xA;实现(异步, 并发，并行)&#xA;    写法&#xA;        回调(监听器), 链式(promise)，同步(async)&#xA;    事件处理器&#xA;        调度方式: 单线程循环&#xA;    协程&#xA;        为什么用户实现协程&#xA;            POSIX线程模型累赘&#xA;                进程/线程 切换开销大&#xA;                空间资源占用大&#xA;            os调度对go模型不合理&#xA;                go gc需要内存处理一致状态(所有线程停止), os调度时，因gc时间不确定，期间大量线程停止工作&#xA;                    # go调度器知道什么时候内存处于一致性状态(只需正在核上运行线程)&#xA;        本质&#xA;            用户态，寄存器+栈, 让出(协作而非抢占)&#xA;        调度方式(线程模型)&#xA;            N:1     # N个用户空间线程运行在1个内核空间线程&#xA;                上下文切换快&#xA;                无法利用多核&#xA;            1:1&#xA;                # POSIX(pthread), java&#xA;                利用多核&#xA;                上下文切换慢，每次调度都在用户态和内核态间切换&#xA;            M:N&#xA;                任意内核模型管理任意goroutine&#xA;                调度复杂性大&#xA;        go&#xA;            M(machine)代表内核线程&#xA;            G(goroutine)有自己的栈，程序计数器，调度信息(如正阻塞的channel)&#xA;            P(processor)调度上下文, $GOMAXPROCS设置数量&#xA;            P中有G队列(runqueue, 队尾添加新G)&#xA;                当前运行一个G, 到调度点时，队列弹出另一个G&#xA;                P周期检查全局G队列防止其中G饿死&#xA;                P运行完，全局G队列拉取G&#xA;                P运行完，全局G队列空，从其它P拉取一半G&#xA;            P运行在M, M阻塞时P移到其它M, 阻塞M中保留阻塞的G&#xA;            调度器创建足够多M跑P&#xA;                阻塞M中G的syscall返回, M尝试偷一个P&#xA;                没得到P时, 它的G加入全局G队列, M进线池睡眠&#xA;&#xA;概念&#xA;    过度竞争&#xA;        过多线程尝试同时使用一个共享资源&#xA;    同步  # 直接相互制约&#xA;        实现&#xA;            同步原语(如通道、锁)作用时，会刷处理器缓存到内存并提交，保证可见性&#xA;    互斥  # 间接相互制约&#xA;        竞态条件(race condition)&#xA;        临界区 # 只能一线程访问的代码，如lock了的代码&#xA;        监控模式    # 互斥锁, 函数, 变量 组合出临界区的模式, 使用了代理人(broker)(指锁)&#xA;    异步&#xA;        # 与同步相对。多线程是实现异步的一种手段&#xA;    可见性&#xA;        线程总可见到最后修改的数据, 脏读是反例&#xA;    原子性&#xA;        查看和修改同时发生&#xA;    乱序执行&#xA;        # java 中标记volatile的变量可以不乱序执行, 现多用原子变量&#xA;        编译器或JVM的静态优化可以打乱代码执行顺序(java)&#xA;        硬件可以通过乱序执行来优化性&#xA;    死锁  # 多线程竞争资源而互相等待&#xA;        条件&#xA;            互斥      # 资源排他&#xA;            不剥夺    # 资源不被外力剥夺&#xA;            请求和保持条件     # 线程已保持一个资源，请求新资源。请求被阻塞而自己资源保持&#xA;            循环等待    # 阻塞线程形成环&#xA;        方案&#xA;            锁按顺序获得  # a,b,c锁，要得c手中要有a, b&#xA;                # 使用锁的地方比较零散时，遵守此顺序变得不实际&#xA;                # 可以用对象散列值作全局顺序减小死锁机率&#xA;            阻塞加时限&#xA;            # 外星方法中可能包含另一把锁，要避免在持锁时调用外星方法&#xA;    活锁  # 多线程尝试绕开死锁而过分同步反复冲突&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;多线程&#34;&gt;&#xA;  多线程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e7%ba%bf%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;线程池&#xA;    作用&#xA;        重复利用, 降低资源消耗&#xA;        提高响应速度，不等线程创建&#xA;        可管理，线程是稀缺资源，统一分配，调优和监控，提高系统稳定性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;锁&#34;&gt;&#xA;  锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;锁&#xA;    公平锁                             # FIFO取锁&#xA;    非公平锁                           # 每次直接占有&#xA;    互斥锁(mutex)                      # 访问前加锁，访问后解锁&#xA;        悲观锁                         # 假设最坏，等所有线程释放成功&#xA;            读加锁&#xA;        乐观锁                         # 假设最好，有冲突时重试&#xA;            读不加锁，写时判断数据版本是否修改，再重试&#xA;    读写锁(rwlock)                     # 竞争不激烈比互斥锁慢&#xA;        读锁(共享锁)&#xA;        写锁(互斥锁)&#xA;        状态&#xA;            读加锁状态&#xA;                可多个线程占用&#xA;                处理器缓存提交，数据可见&#xA;                阻塞写线程              # 导致写线程抢占不到资源，所以有写线程时，阻塞后进入的读线程&#xA;            写加锁状态&#xA;                一次只有一个线程占用&#xA;                阻塞所有线程&#xA;            不加锁状态&#xA;    自旋锁 spinlock&#xA;        互斥锁改，自己进入循环等待状态(忙等)             # 适合锁持有时间较短&#xA;    RCU锁 Read-Copy Update&#xA;        读写锁改，一个写线程，读线程无限制&#xA;            实现垃圾回收器&#xA;            写线程copy副本修改，向垃圾回收器注册callback以执行真正的修改&#xA;            垃圾回收器收到信号，所有读线程结束，执行callback&#xA;    可重入锁                            # 互斥锁改，允许同一线程多次获得写锁&#xA;    管程(monitor)&#xA;    临界区(critical section)&#xA;    内置锁、显示锁                       # 指java的synchronized与Reentrantlock&#xA;信号量&#xA;    进程, 线程间通知状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cas&#34;&gt;&#xA;  CAS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# compare and swap，无锁算法(lock free), 非阻塞(non-blocking), 构成基本的乐观锁&#xA;# cpu实现的指令&#xA;3个操作数&#xA;    # V的值为A时，原子更新成B，否则无操作。返回V的值&#xA;    需要读写的内存位置V&#xA;    进行比较的值A&#xA;    拟写入的新值B&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数式&#34;&gt;&#xA;  函数式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    消除可变状态&#xA;概念&#xA;    命令式语言中，求值顺序与源码的语句顺序紧密相关(有可能乱序执行)&#xA;    函数式程序并不描述&amp;quot;如何求值以得到结果&amp;quot;，而是描述&amp;quot;结果应当是什么样的&amp;quot;。函数式编程中，如何安排求值顺序相对自由&#xA;    引用透明性&#xA;        # 任何调用函数的地方，都可以用函数运行结果来替换函数调用，而不会产生副作用&#xA;    数据流式编程(dataflow programming)&#xA;        # (+ (+ 1 2) (+ 3 4))就是一个数据流，所有函数都可以用时执行&#xA;        future模型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分离标识与状态&#34;&gt;&#xA;  分离标识与状态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e7%a6%bb%e6%a0%87%e8%af%86%e4%b8%8e%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    Clojure, 指令式编程和函数式编程混搭&#xA;&#xA;clojure四种并发模型&#xA;    vars (thread-local)&#xA;    atoms原子变量&#xA;    agent代理&#xA;    refs引用 与 ATM软件事务内存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;actor模型&#34;&gt;&#xA;  actor模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#actor%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    作为actor自己修改自己的数据，对外提供消息，处理对外消息&#xA;    共享内存模型和分布式内存模型，适合解决地理分布型问题，强大的容错性&#xA;    基于消息传递，侧重通道两端实体&#xA;    每个actor有一个mailbox, mailbox中转消息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;csp&#34;&gt;&#xA;  csp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#csp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    通信顺序进程(communicating sequential processes)&#xA;    基于消息传递，侧重信息通道&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据级并行&#34;&gt;&#xA;  数据级并行&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%ba%a7%e5%b9%b6%e8%a1%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 不可变数据, 观测不可变、实现不可变&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;lambda架构&#34;&gt;&#xA;  lambda架构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lambda%e6%9e%b6%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    综合MapReduce和流式处理的特点，处理大数据问题的架构&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;状态保持&#34;&gt;&#xA;  状态保持&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8a%b6%e6%80%81%e4%bf%9d%e6%8c%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;cookie&#xA;    分域名, 客户端保存服务器定义数据, 请求时发送&#xA;session&#xA;    服务器id数据，id下发到客户端&#xA;    共享&#xA;        # 同时多方案，动态切换 zookeeper切换环境变量与重启&#xA;        # java中filter重写request getSession&#xA;        webSphere或JBoss可配置session复制或共享&#xA;            # 不好扩展和移植&#xA;        加密存cookie&#xA;        服务&#xA;            redis&#xA;            memorycache&#xA;            gemfire     # 12306&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;认证&#34;&gt;&#xA;  认证&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a4%e8%af%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;单点登录&#xA;    sessionID存cookie, cookie禁用存头域&#xA;token&#xA;    类型&#xA;        access token&#xA;            # 标识唯一用户&#xA;            user_id&#xA;            issue_time&#xA;                # token发放时间，单位秒&#xA;            ttl&#xA;                # 有效时间，uint16,单位分钟&#xA;            mask&#xA;                # int128, 按bit分组用户，用于批量封禁或其它功能&#xA;        refresh token&#xA;            # 用来换access token，与access token同时发放&#xA;            # 过期时间更长&#xA;    实现&#xA;        redis存储&#xA;        token不要太长&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;常见问题&#34;&gt;&#xA;  常见问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;csrf&#34;&gt;&#xA;  CSRF&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#csrf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    跨域请求伪造(cross-site request forgery)&#xA;    client登录A, 本地生成cookie&#xA;    client登录B, B给执行js，带参数请求站点A&#xA;解决&#xA;    token验证     # 加入自定义头域&#xA;    验证Referer头域&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;xss&#34;&gt;&#xA;  XSS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xss&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    跨站脚本攻击(cross-site scripting, 易和css混淆，所以写成XSS), 渲染页面时脚本未转义&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;xsf&#34;&gt;&#xA;  XSF&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xsf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    跨站flash攻击(cross-site flash), actionScript加载第三方flash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sql注入&#34;&gt;&#xA;  sql注入&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sql%e6%b3%a8%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    拼装sql，参数插入sql逻辑&#xA;解决&#xA;    sql预编译&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;1n查询&#34;&gt;&#xA;  1+N查询&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1n%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    先查出外键id集合, 再逐条id查关联表。orm易出的问题&#xA;解决&#xA;    用 id IN (1,2,3)&#xA;    commit前自动合并sql&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;业务场景&#34;&gt;&#xA;  业务场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%9a%e5%8a%a1%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;关注信箱&#34;&gt;&#xA;  关注/信箱&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b3%e6%b3%a8%e4%bf%a1%e7%ae%b1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;要求&#xA;    user人数10w, 活跃1w。&#xA;    大部分user关注1k人, 一部分大v被关注100w人。&#xA;    每人每天发100条博文&#xA;    user新博文数量提醒，消息标记已读&#xA;表&#xA;    user&#xA;    user_followers&#xA;    user_followed&#xA;    user_posts(u_id, created_ts)&#xA;    user_messages(u_id, p_id, is_read)&#xA;        # 10w * 100条数据 / 天&#xA;定时任务拉取&#xA;    user_followed拉u_id, user_posts表按时段拉id, 更新user_messages&#xA;    优点&#xA;        平均, 少次, 增量。&#xA;    缺点&#xA;        及时性中&#xA;        每次对所有用户操作&#xA;    数据&#xA;        10w*1k*100条数据 / 天&#xA;发布时推送&#xA;    有p_id, user_followers, 更新user_messages&#xA;    优点&#xA;        及时性高&#xA;    缺点&#xA;        计算集中, 可能高峰&#xA;    数据&#xA;        最高 100w*100条数据 / 次&#xA;        10w*100次 / 天&#xA;messages处理&#xA;    存部分messages&#xA;        不活跃user不存message&#xA;            在登录状态，定时拉取&#xA;                优点&#xA;                    减少message&#xA;                缺点&#xA;                    计算集中&#xA;                数据&#xA;                    1k * N(N&amp;lt;100)条 / 次&#xA;                    1w * 1k * 100条数据 / 天&#xA;    messages结构变化&#xA;        u_id: [{p_id: uint, is_read: bool}]         #  条数稳定为10w&#xA;        用mongodb或redis&#xA;消息队列?&#xA;    服务端存message状态，不能mq&#xA;    如果客户端存状态，这就是个简单的mq问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;轻应用架构&#34;&gt;&#xA;  轻应用架构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bd%bb%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;node.js + mongodb&#xA;mysql&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据&#34;&gt;&#xA;  数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数据迁移&#34;&gt;&#xA;  数据迁移&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e8%bf%81%e7%a7%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;去掉约束&#xA;排序（中断继续）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据存储&#34;&gt;&#xA;  数据存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;缓存&#xA;    queue + map&#xA;        # queue存储、限量, map查询，指向queue中元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;缓存&#34;&gt;&#xA;  缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;queue + map&#xA;    # queue存储、限量, map查询，指向queue中元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;实时并发&#34;&gt;&#xA;  实时并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e6%97%b6%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;异步方案&#34;&gt;&#xA;  异步方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;node.js + mongodb&#xA;tornado + celery + rabbitmq + 优先级&#xA;quartz&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;消息&#34;&gt;&#xA;  消息&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%88%e6%81%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;功能&#xA;    好友&#xA;    单聊, 群聊&#xA;    语音, 视频&#xA;    im      # 浏览器聊天(tcp, 不https)&#xA;协议&#xA;    XMPP        # 基于xml&#xA;    MQTT        # 简单，但自己实现好友、群组&#xA;    SIP         # 复杂&#xA;    私有协议     # 工作量大，扩展性差&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;go高并发实时消息推送&#34;&gt;&#xA;  go高并发实时消息推送&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go%e9%ab%98%e5%b9%b6%e5%8f%91%e5%ae%9e%e6%97%b6%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;问题&#xA;    长连接             # 支持多种协议(http、tcp)&#xA;        server push&#xA;        HTTP long polling(keep-alive)&#xA;        基于TCP自定义&#xA;        心跳侦测&#xA;    高并发             #&amp;gt;= 10,000,000&#xA;        C1000K&#xA;    多种发送方式&#xA;        单播: 点对点聊天&#xA;        多播: 定点推送&#xA;        广播: 全网推送&#xA;    持久/非持久&#xA;    准实时         # 200ms ~ 2s&#xA;        gc卡顿是大问题&#xA;    客户端多样性&#xA;    同帐号多端接入&#xA;    网络变化&#xA;        电信、联通切换&#xA;        wifi, 4g, 3g&#xA;        断线、重连、断线、重连&#xA;系统架构&#xA;    组件&#xA;        room&#xA;            # 接入客户端&#xA;            分布式全对称&#xA;            一个client一个goroutine&#xA;            每个server一个channel存消息队列&#xA;            book记录user与server映射&#xA;            统一http server收消息并将消息路由到room和server&#xA;            manager掌控room的服务：内部单播、多播、广播&#xA;            admin负责room进程管理&#xA;        center&#xA;            # 运营人员从后台接入&#xA;            提供操纵接口给应用服务器调用&#xA;            restful&#xA;            长时操作，有任务概念来管理&#xA;            提供统计接口&#xA;        register&#xA;            # room和center注册&#xA;            key-value的map，value是struct&#xA;            记录用户连到哪个room&#xA;            记录在线时长等信息&#xA;            hash算法定位register进程&#xA;            不直接用redis是为了添加业务逻辑&#xA;        saver&#xA;            # room和center调用&#xA;            # 使用redis&#xA;            分布式全对称&#xA;            提供存储接口&#xA;            采用encoding/gob编码格式的rpc&#xA;        idgenerator&#xA;            # saver和center调用&#xA;            全局消息id生成器, int64&#xA;            分布式，每个进程负责一块id区域&#xA;            后台goroutine每隔一秒写一次磁盘，记录当前id&#xA;            启动时跳过一段id，防止一秒内未写入磁盘的id重复生成&#xA;    存储&#xA;        redis&#xA;            存核心数据&#xA;            db_users: zset, 存各产品用户集合&#xA;            db_slots: list, 存用户离线消息队列&#xA;            db_buckets: dict, 存消息id -&amp;gt; 消息体&#xA;数据&#xA;    16机器，标配24硬件线程, 64g内存&#xA;    linux kernel 2.6.32 x86_64&#xA;    单机80万并发连接&#xA;        load 0.2 ~ 0.4 cpu&#xA;        总使用率7%~10%&#xA;        内存占用20g&#xA;    目前接入1280万在线用户&#xA;    2分钟一次gc, 停顿2秒，tip上提供了并行gc&#xA;    15亿个心跳包/天&#xA;    持续运行一个月无异常&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;直播&#34;&gt;&#xA;  直播&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b4%e6%92%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;《关于直播，所有的技术细节都在这里了》&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;游戏&#34;&gt;&#xA;  游戏&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b8%b8%e6%88%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;进程&#xA;    gateway进程组&#xA;        # 对外api&#xA;    function进程组&#xA;        # 注册玩家全局信息&#xA;    session进程组&#xA;        # 玩家状态&#xA;    dbserver进程组&#xA;        # 数据&#xA;    多word进程组&#xA;        # 不同地图的信息、逻辑&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>演说</title>
      <link>https://runout.run/docs/basic/speach/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/basic/speach/</guid>
      <description>&lt;h1 id=&#34;要素&#34;&gt;&#xA;  要素&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a6%81%e7%b4%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;环境的设计&#xA;&#x9;安全&#xA;&#x9;规模小&#xA;改变被动传输为主动接受&#xA;&#x9;交互、提问与思考&#xA;&#x9;团队、竞争、奖励&#xA;控制场面&#xA;&#x9;引导&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>身体</title>
      <link>https://runout.run/docs/basic/body/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/basic/body/</guid>
      <description>&lt;h1 id=&#34;造型期&#34;&gt;&#xA;  造型期&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%a0%e5%9e%8b%e6%9c%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;体态&#xA;    高低肩&#xA;    骨盆前倾&#xA;体能&#xA;    心肺&#xA;    变速有氧：4、6、8各2min， 30min以上&#xA;力量&#xA;核心训练&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;健身计划&#34;&gt;&#xA;  健身计划&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%81%a5%e8%ba%ab%e8%ae%a1%e5%88%92&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;目标&#xA;指导&#xA;    FITT&#xA;        Frequency: 一周3-5次&#xA;        Intensity:&#xA;            有氧&#xA;                心率: 123-142&#xA;            无氧&#xA;                动作&#xA;                间歇&#xA;                个数&#xA;                重量&#xA;        Time:&#xA;            60min力量 + 30min有氧&#xA;        Type:&#xA;            热身&#xA;            抗阻力训练&#xA;            拉伸&#xA;阶段&#xA;    适应期(1-2月)&#xA;        心肺功能: 功率&#xA;        核心力量&#xA;            保护腰：呼吸 + 静态&#xA;            内脂&#xA;        力量训练&#xA;            动作规范&#xA;            蹲、推、拉、举、旋转&#xA;    进阶期(2-3月)&#xA;        消耗 &amp;gt; 摄入&#xA;        七大肌肉群：胸、肩、背、腹、腿、臀、手臂&#xA;            三分化、四分化&#xA;        爆发力&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>运维规划</title>
      <link>https://runout.run/docs/architect/method/ops_plan/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/architect/method/ops_plan/</guid>
      <description>&lt;h1 id=&#34;指标&#34;&gt;&#xA;  指标&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e6%a0%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;标准&#xA;    ITIL(IT Infrastructure Library)&#xA;    ITSM(IT System Management)&#xA;目标&#xA;    安全性&#xA;        账号管理&#xA;        漏洞修复&#xA;        安全审计&#xA;    可用性&#xA;        服务监控&#xA;        架构优化&#xA;        冗余备份&#xA;        预案演练&#xA;        故障响应&#xA;    运维成本&#xA;        成本核算&#xA;        服务选型&#xA;        成本优化&#xA;    运维效率&#xA;        研发工作流支持&#xA;        服务支持平台建设&#xA;        运维自动化平台建设&#xA;工作方式&#xA;    邮件申请开通 LDAP, VPN, 测试, 线上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;监控&#34;&gt;&#xA;  监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>工程</title>
      <link>https://runout.run/docs/architect/project/ddd/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      <guid>https://runout.run/docs/architect/project/ddd/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;&#x9;Domain-driven Design&#xA;    针对传统软件开发流程（分析-设计-编码）各阶段业务割裂问题，一开始定义好领域&#xA;目标&#xA;    维护概念完整性(纯洁)，避免语义泄露和腐化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;概念&#34;&gt;&#xA;  概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;领域（Domain）&#xA;界限上下文（Bounded Context）&#xA;领域模型（Domain Model）&#xA;领域通用语言&#xA;分层架构&#xA;    展示层、应用层、领域层、基础设施层&#xA;最佳实践&#xA;    关联尽量少、尽量单项、尽量降低整体复杂度&#xA;    实体（Entity）&#xA;        领域中的唯一标识，属性尽量少&#xA;    值对象（Value Object）&#xA;        没有唯一标识，属性值不变&#xA;    领域服务（Domain Service）&#xA;        协调多个领域对象，只有方法没有状态&#xA;        应用层服务、领域层服务、基础层服务&#xA;    聚合、聚合根（Aggregate, Aggregate Root）&#xA;        聚合定义了一组有内聚关系的对象集合，聚合根是对聚合引用的唯一元素&#xA;        修改聚合必须在事务级别&#xA;        70%的聚合只有一个实体, 30%有2到3个实体。&#xA;        只有一个实体时，实体就是聚合根。多实体时思考哪个对象有独立存在的意义，且可与外部直接交互&#xA;    工厂（Factory）&#xA;        工厂模式&#xA;    仓储（Repository）&#xA;        持久化到DB，管理对象&#xA;        只对聚合设计仓储&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;建模&#34;&gt;&#xA;  建模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;原则&#34;&gt;&#xA;  原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;简单、容易、清晰&#xA;使用不动点&#xA;领域专注&#xA;聚合内强一致，跨聚合最终一致&#xA;内部概念完整一致(unification)&#xA;&#x9;术语不变、不矛盾、不重叠&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据模型do&#34;&gt;&#xA;  数据模型（DO）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8bdo&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;失血&#xA;&#x9;DO和DAO无业务逻辑，纯数据&#xA;贫血&#xA;&#x9;持久化逻辑在DAO中&#xA;充血&#xA;&#x9;service很薄，持久化的逻辑在DO中，无DAO或与DO双向依赖&#xA;肿胀&#xA;&#x9;无service，全部逻辑放DO&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分析设计&#34;&gt;&#xA;  分析设计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90%e8%ae%be%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分析模型&#34;&gt;&#xA;  分析模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 业务领域分析, 不考虑代码&#xA;问题&#xA;&#x9;含意不完整，不可图形或文字表达，错误假设&#xA;&#x9;会深入某细节&#xA;&#x9;忽略某细节直到设计或实现, 如持久化、性能&#xA;目标&#xA;&#x9;领域模型&#xA;&#x9;架构设计&#xA;事件风暴                    # 是开发建模，不是用户需求故事&#xA;&#x9;准备&#xA;&#x9;&#x9;功能确认: 近期milestone&#xA;&#x9;&#x9;找正确的人: 领域专家, 前后端，架构师&#xA;&#x9;&#x9;引导者: 准备资料, 排程, 时间, 2/3时间预警&#xA;&#x9;事件风暴&#xA;&#x9;&#x9;领域事件: 用户可感知状态&#xA;&#x9;&#x9;分支小组 -&amp;gt; 个人发散 -&amp;gt; 小组一致 -&amp;gt; 整体一致        # 不能一致表示准备不足&#xA;&#x9;&#x9;逻辑顺序 -&amp;gt; 最终流程&#xA;&#x9;命令风暴                # 为什么, 分色&#xA;&#x9;&#x9;事件触发原因、方式&#xA;&#x9;&#x9;用户角色&#xA;&#x9;&#x9;读模型: 用户前置需求&#xA;&#x9;&#x9;写模型: 动词&#xA;&#x9;&#x9;描述&#xA;&#x9;聚合&#xA;&#x9;&#x9;取名, 分职责&#xA;&#x9;持续探索&#xA;领域模型一开始就结合编码设计    # 设计围绕模型, 模型受设计反馈改善&#xA;&#x9;开发时意识到模型变更, 会保持完整性&#xA;&#x9;每个开发在修改前需要了解模型&#xA;&#x9;面向对象更易于建模, 过程化易于流程，如数学&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;重构&#34;&gt;&#xA;  重构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8d%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;要求&#xA;&#x9;设计灵活&#xA;&#x9;使用经过验证的构造&#xA;目标&#xA;&#x9;领域理解更深、更清晰&#xA;&#x9;&#x9;深刻(incisive)、深层(deep)的模型&#xA;&#x9;技术的动机的代码转换&#xA;实现&#xA;&#x9;小幅可控&#xA;&#x9;基于测试&#xA;&#x9;突破&#xA;&#x9;&#x9;新的概念或抽象&#xA;&#x9;&#x9;隐含的概念被凸显&#xA;&#x9;&#x9;&#x9;倾听领域语言&#xA;&#x9;&#x9;&#x9;过分复杂是因为关键点被替代&#xA;&#x9;&#x9;&#x9;领域文献        # 深层视图&#xA;&#x9;&#x9;&#x9;约束            # 表达不变量&#xA;&#x9;&#x9;&#x9;过程(process)   # 面向对象中的面向过程, 多个过程时用策略&#xA;&#x9;&#x9;&#x9;规约            # 测试对象返回布尔值, 重构成对象而非写在application&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;战略建模&#34;&gt;&#xA;  战略建模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%88%98%e7%95%a5%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 形成上下文映射图&#xA;问题空间&#xA;&#x9;领域                                            # 与公司组织关联&#xA;&#x9;&#x9;子域                                        # 最好对应一个限界上下文&#xA;&#x9;&#x9;&#x9;核心域(core domain)                     # 项目动机, 公司核心竞争力, 尽量小, 最高优先级&#xA;&#x9;&#x9;&#x9;通用子域(generic subdomain)             # 作用于整个系统的支撑子域&#xA;&#x9;&#x9;&#x9;支撑子域                                # 重要非核心&#xA;&#x9;集成&#xA;&#x9;&#x9;合作关系(partnership)                       # 同时成功失败&#xA;&#x9;&#x9;共享内核(shared kernel)                     # 小型内核, 持续集成功能&#xA;&#x9;&#x9;客户/供应(customer-supplier development)    # 上下游&#xA;&#x9;&#x9;遵从(conformist)                            # 下游遵从上游&#xA;&#x9;&#x9;防腐层(anticorruption layer)                # 翻译转换领域服务&#xA;&#x9;&#x9;开放主机服务(open host service)             # 公开协议，子系统访问&#xA;&#x9;&#x9;发布语言(published language)                # dsl, 通常与开放主机服务一起&#xA;&#x9;&#x9;分隔(separate way)                          # 声明无关联&#xA;&#x9;&#x9;大泥球(big ball of mud)                     # 已有纠缠的系统，隔离出来&#xA;解决方案空间&#xA;&#x9;通用语言&#xA;&#x9;&#x9;一个限界上下文一个通用语言&#xA;&#x9;&#x9;清晰(概念无二义性), 简洁                    # 如卖家和买家都叫用户，就是不清晰。如用type标记用户是卖家或买家，就是不简洁。所以直接用两个对象&#xA;&#x9;限界上下文                  # 条件的集合&#xA;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;确保术语含义明确&#xA;&#x9;&#x9;&#x9;切分规模, 易于保持领域纯洁&#xA;&#x9;&#x9;&#x9;设定进化框架而非模块，包含模块&#xA;&#x9;&#x9;考虑因素&#xA;&#x9;&#x9;&#x9;团队组织结构&#xA;&#x9;&#x9;&#x9;应用特定部分惯例、物理表现&#xA;&#x9;&#x9;挑战&#xA;&#x9;&#x9;&#x9;团队开发碎片化      # 写重复的代码，由于不知道或怕改错&#xA;&#x9;&#x9;&#x9;持续集成&#xA;&#x9;&#x9;&#x9;&#x9;早合并&#xA;&#x9;&#x9;&#x9;&#x9;自动构建测试    # 检测不一致&#xA;&#x9;&#x9;模块&#xA;&#x9;&#x9;&#x9;作用&#xA;&#x9;&#x9;&#x9;&#x9;降低模型规模复杂度&#xA;&#x9;&#x9;&#x9;&#x9;代码高内聚低耦合&#xA;&#x9;&#x9;&#x9;设计&#xA;&#x9;&#x9;&#x9;&#x9;通信性内聚(communicational cohesion)&#xA;&#x9;&#x9;&#x9;&#x9;功能性内聚(functional cohesion)&#xA;&#x9;&#x9;&#x9;&#x9;每模块统一接口&#xA;&#x9;&#x9;&#x9;&#x9;名称反映深层理解&#xA;&#x9;&#x9;&#x9;&#x9;灵活性，进化性&#xA;&#x9;上下文映射                  # 领域间集成关系&#xA;&#x9;&#x9;模式&#xA;&#x9;&#x9;&#x9;共享内核(shared kernel)                 # 为减少重复, 共享领域子集，多方测试&#xA;&#x9;&#x9;&#x9;客户-供应商(customer-supplier)          # 做反馈的需求, 需求测试, 自动化验收&#xA;&#x9;&#x9;&#x9;顺从者                                  # 供应商不做需求, 客户用适配器对接组件&#xA;&#x9;&#x9;&#x9;防腐层(anticorruption layer)            # 双向领域模型转换器, 保持内部模型纯洁&#xA;&#x9;&#x9;&#x9;&#x9;从前&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;原始数据(api, db)无模型无语义的处理&#xA;&#x9;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;对外多门面(facade)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;每个门面一个适配器(adapter)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;适配器间用转换器(translator)&#xA;&#x9;&#x9;&#x9;隔离通道(separate way)&#xA;&#x9;&#x9;&#x9;开放主机服务(open host service)         # 实现开放服务协议&#xA;&#x9;&#x9;&#x9;提炼                                    # 多次重构后还很大&#xA;&#x9;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;分离基本概念和普通概念, 提炼核心域和子域&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;子域&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;使用第三方服务&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;外包&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;修改已有模型&#xA;&#x9;六边形架构&#xA;&#x9;&#x9;领域模型简洁自治&#xA;&#x9;&#x9;对外适配器防腐, 保护限界上下文              # 如面向接口&#xA;&#x9;&#x9;&#x9;消息, 内存, 数据库&#xA;&#x9;&#x9;&#x9;soap, rest&#xA;&#x9;CQRS(command query responsibility segregationg)             # 修改只记事件(日志), 查询时计算&#xA;&#x9;&#x9;查询方式&#xA;&#x9;&#x9;&#x9;单数据库/读写分离，查询时计算事件&#xA;&#x9;&#x9;&#x9;读写分离, 读库异步计算事件保存冗余, 读库负载均衡&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;战术建模&#34;&gt;&#xA;  战术建模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%88%98%e6%9c%af%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 组成限界上下文&#xA;领域&#xA;&#x9;实体(entity)                # 标识和延续性, 有id, 持续变化。&#xA;&#x9;值对象(value object)        # 无id, 只有属性, 最好不可变(可共享)。尽量建模值对象。可包含实体引用或值对象。&#xA;&#x9;生命周期&#xA;&#x9;&#x9;聚合(aggregate)         # 定义对象所有权和边界&#xA;&#x9;&#x9;&#x9;简化&#xA;&#x9;&#x9;&#x9;&#x9;关联            # 可导航到的关联&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;1对1        # 对象引用&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;1对n        # 包含集合&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;n对n        # 删除关联，关系加约束或转换 &#xA;&#x9;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;&#x9;一致性&#xA;&#x9;&#x9;&#x9;&#x9;强化不变量&#xA;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;聚合根(root)    # 聚合根间是最终一致性&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;是个实体,有id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;外部访问的唯一对象&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;向外传递副本&#xA;&#x9;&#x9;工厂(factory)           # 在领域中没有定义, 但程序需要&#xA;&#x9;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;&#x9;并非对象创建对象&#xA;&#x9;&#x9;&#x9;&#x9;对象创建存在自有知识&#xA;&#x9;&#x9;&#x9;&#x9;创建过程原子性&#xA;&#x9;&#x9;&#x9;&#x9;对已有持久化对象重建并修复&#xA;&#x9;&#x9;&#x9;问题&#xA;&#x9;&#x9;&#x9;&#x9;外部访问根内对象，需关联不必要的根实体&#xA;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;不用工厂&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;构造不复杂&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;不涉及其它对象&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;客户希望用策略创建&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;类是具体类型, 无层级&#xA;&#x9;&#x9;&#x9;&#x9;聚合根提供方法&#xA;&#x9;&#x9;&#x9;&#x9;单独工厂        # 违反了封装原则, 但保持了简单&#xA;&#x9;&#x9;资源库(repository)      # 内存假象&#xA;&#x9;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;&#x9;不关联根获取对象引用&#xA;&#x9;&#x9;&#x9;&#x9;不暴露细节, 会减少领域专注&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;防止代码扩散&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;减少变更修改&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;维护聚合封装性&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;容易的基础设施被滥用, 产生除聚合根外导航&#xA;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;封装所有获取对象逻辑&#xA;&#x9;&#x9;&#x9;&#x9;基础设施, 全局可访问&#xA;&#x9;&#x9;&#x9;&#x9;不同对象不同策略访问、存储      # 领域与基础设施解耦&#xA;&#x9;&#x9;&#x9;&#x9;接口是领域模型, 实现像基础设施&#xA;&#x9;&#x9;&#x9;&#x9;参数筛选或规约(specification)筛选(筛选器)&#xA;entity&#xA;&#x9;介绍&#xA;&#x9;&#x9;entity即状态&#xA;&#x9;&#x9;应用开发即处理entity的表现&#xA;&#x9;主从&#xA;&#x9;&#x9;主存储(可变)                    # 关键是选择主存储&#xA;&#x9;&#x9;&#x9;多派生一致性好保障&#xA;&#x9;&#x9;&#x9;派生表达业务的难易成度&#xA;&#x9;&#x9;只读派生(representation, 不可变)&#xA;&#x9;&#x9;&#x9;多份存储, 一致性&#xA;&#x9;&#x9;&#x9;派生, 合并, 转化&#xA;&#x9;类型&#xA;&#x9;&#x9;东西(可变)                      # 单据叠加成东西, 东西叠加成东西&#xA;&#x9;&#x9;单据(可变)                      # 事件叠加成单据&#xA;&#x9;&#x9;事件(event, 不可变)&#xA;&#x9;&#x9;命令(command, 不可变)&#xA;&#x9;&#x9;视图(view model, 不可变)&#xA;&#x9;&#x9;子集(subset, 不可变)&#xA;&#x9;&#x9;视图(aggregation, 不可变)&#xA;&#x9;&#x9;表单(可变)                      # 是主存储&#xA;&#x9;物理介质&#xA;&#x9;&#x9;OLTP(mysql)                     # 点查询&#xA;&#x9;&#x9;OLAP(clickHouse)                # 范围查询&#xA;&#x9;&#x9;queue(kafka)                    # 顺序读, 低延迟&#xA;&#x9;&#x9;业务服务                        # 业务逻辑, 像虚拟的表&#xA;&#x9;分组entity主存储(BC, bounded context)&#xA;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;分解&#xA;&#x9;&#x9;&#x9;&#x9;管理复杂度&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;系统&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;组织部门&#xA;&#x9;&#x9;&#x9;&#x9;实现内部一致性&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;概念, 数据&#xA;&#x9;&#x9;&#x9;对主存储进行受控的修改&#xA;&#x9;&#x9;边界entity                          # 用于集成，不一定是主存储&#xA;&#x9;&#x9;&#x9;形式&#xA;&#x9;&#x9;&#x9;&#x9;授权、binlog、工作流、视图数据、租户作为其它租户user&#xA;&#x9;&#x9;&#x9;&#x9;东西、单据、event&#xA;&#x9;&#x9;&#x9;介质&#xA;&#x9;&#x9;&#x9;&#x9;queue, 带权限db, rpc虚拟表&#xA;&#x9;&#x9;&#x9;触发&#xA;&#x9;&#x9;&#x9;&#x9;queue, ui, api&#xA;&#x9;&#x9;&#x9;&#x9;触发由worker托管, 输入是queue或rpc socket&#xA;&#x9;&#x9;粒度&#xA;&#x9;&#x9;&#x9;分entity&#xA;&#x9;&#x9;&#x9;分步骤&#xA;&#x9;&#x9;&#x9;分entity字段&#xA;&#x9;&#x9;&#x9;原则&#xA;&#x9;&#x9;&#x9;&#x9;BC尽可能少而大&#xA;&#x9;&#x9;关系&#xA;&#x9;&#x9;&#x9;时间错开&#xA;&#x9;&#x9;&#x9;&#x9;外键关系                    # BC挂载到BC, 如后台系统与计费系统的定价, 运营人员与服务系统的配置, 流程节点系统对流程的依赖&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rpc, 数据库, 数据复制&#xA;&#x9;&#x9;&#x9;&#x9;报表关系&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;时效性高&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;一般做复制              # 所以边界entity是数据变更event&#xA;&#x9;&#x9;&#x9;&#x9;触发关系                    # fire and forget&#xA;&#x9;&#x9;&#x9;&#x9;交棒关系&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;下游给上游command/event, 上游触发&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;上游实现降级            # 下游不可用时，安慰语&#xA;&#x9;&#x9;&#x9;时间同时&#xA;&#x9;&#x9;&#x9;&#x9;accountable/responsible关系                 # 负责人与实现人&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;原则&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;accountable尽量小&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;只调度&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;与responsible的边界entity是rpc虚拟表, 请求command, 返回event&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;补偿实现一致                    # 如超卖&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;responsible提供自己界面         # accountable不控制&#xA;&#x9;&#x9;&#x9;&#x9;抢资源关系&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;锁服务&#xA;服务(service)                   # 无法划分对象的动作, 无状态。按功能分组, 多对象的连接点&#xA;&#x9;可在application, domain, infrastructure&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;最终一致性建模&#34;&gt;&#xA;  最终一致性建模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;in-memory&#34;&gt;&#xA;  In-Memory&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#in-memory&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;聚合根在内存，同步最新状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事件溯源event-sourcing&#34;&gt;&#xA;  事件溯源（Event Sourcing）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e4%bb%b6%e6%ba%af%e6%ba%90event-sourcing&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;&#x9;没有CRUD，只有Append Event。数据不可变&#xA;&#x9;对象最新状态通过事件溯源获得&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;actor&#34;&gt;&#xA;  Actor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#actor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;通过Mailbox取代调用，保证消息线性处理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;edaevent-driven-architecture&#34;&gt;&#xA;  EDA(Event-driven Architecture)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#edaevent-driven-architecture&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;节点只处理逻辑，节点间Event通信&#xA;是最终一致性的架构&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cqrs&#34;&gt;&#xA;  CQRS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cqrs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;&#x9;Command Query Responsibility Seperation&#xA;&#x9;CQ接口分离、代码分离，分别设计&#xA;概念&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;项目结构&#34;&gt;&#xA;  项目结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;用户接口(user interface)&#xA;应用(application)                   # 尽可能小。数据验证，事务。故事, 表达出操作的事情&#xA;    application service&#xA;    unit work&#xA;    presentation model&#xA;领域(domain)                        # 专注领域。准确定义业务对象&#xA;    aggregate, entity, value object&#xA;    domain service, domain event&#xA;基础设施(infrastructure)            # 辅助层&#xA;    repository&#xA;    global support&#xA;项目文件&#xA;    [ui]&#xA;        mall                            # 商城api&#xA;    [saleDomain]&#xA;        [application]&#xA;            mall.application            # 分模块，讲述故事&#xA;                CartService&#xA;                    GetCart()&#xA;                BuyService&#xA;                    Buy()&#xA;            mall.application.domainEventSubscribers         # 订阅domain事件&#xA;        [domain]&#xA;            mall.domain                 # 不大而全，要求刚好满足需求&#xA;                cartModule&#xA;                    entity&#xA;                        CartItem&#xA;                    aggregate&#xA;                        Cart&#xA;                valueObject&#xA;                    Product&#xA;                    SellingPriceCart&#xA;                IDomainServices&#xA;                IRemoteServices         # 访问远程资源接口&#xA;                    IUserService&#xA;                    ISellingPriceService&#xA;                IRepositories           # 仓储接口&#xA;                    ICartRepository&#xA;            mall.domain.events          # 领域事件, 用于实现最终一致性&#xA;            mall.domainService          # 操作domain的无状态方法&#xA;                ConfirmUserCartExistedDomainService&#xA;    [sellingPriceDomain]                # 与saleDomain合作关系, sale请求sellingPrice定价&#xA;        [appication]&#xA;            mall.application.SellingPrice&#xA;                dto&#xA;                    CalculatedCartDTO&#xA;                mapper&#xA;                    ValueObjectToDTO&#xA;        [domain]&#xA;    [infrastructure]&#xA;        mall.infrastructure             # 通用类库&#xA;            domainCore                  # mail.domain base方法&#xA;                AggregateRoot&#xA;                    Cart&#xA;                Entity&#xA;                    CartItem&#xA;                ValueObject&#xA;                    Product&#xA;                IUnitOfWork             # 仓储事务&#xA;            domainEventCore&#xA;                DomainEvent&#xA;                DomainEventBus&#xA;                DomainEventSubscriber&#xA;                IDomainEvent&#xA;                IDomainEventSubscriber&#xA;        mall.infrastructure.repositories                # 仓储&#xA;            CartSqlServerRepository&#xA;        mall.infrastructure.translators                 # 防腐层, 访问远程资源实现&#xA;            user&#xA;                UserAdapter             # 请求原始结果&#xA;                UserService&#xA;                UserTranslator          # 转换原始结果&#xA;模块结构&#xA;&#x9;api: controller&#xA;&#x9;biz: 特异业务&#xA;&#x9;&#x9;manager&#xA;&#x9;&#x9;converter&#xA;&#x9;core: 公用业务&#xA;&#x9;&#x9;model&#xA;&#x9;&#x9;&#x9;entity&#xA;&#x9;&#x9;&#x9;bo&#xA;&#x9;&#x9;service&#xA;&#x9;&#x9;&#x9;repository&#xA;&#x9;common&#xA;&#x9;&#x9;dal&#xA;&#x9;&#x9;&#x9;dataobject&#xA;&#x9;&#x9;&#x9;&#x9;do&#xA;&#x9;&#x9;&#x9;dao&#xA;&#x9;&#x9;&#x9;mapper&#xA;&#x9;&#x9;service&#xA;&#x9;&#x9;&#x9;facade&#xA;&#x9;&#x9;&#x9;&#x9;dto: facade和controller用&#xA;&#x9;&#x9;&#x9;&#x9;service: 服务间api&#xA;&#x9;&#x9;&#x9;&#x9;validate&#xA;&#x9;&#x9;&#x9;integration&#xA;&#x9;&#x9;&#x9;&#x9;service&#xA;&#x9;&#x9;shared&#xA;&#x9;&#x9;&#x9;dto: 项目内部公用&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>咨询规划</title>
      <link>https://runout.run/docs/architect/method/advice_plan/</link>
      <pubDate>Wed, 10 Oct 2018 16:49:27 +0800</pubDate>
      <guid>https://runout.run/docs/architect/method/advice_plan/</guid>
      <description>&lt;h1 id=&#34;presentation&#34;&gt;&#xA;  Presentation&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#presentation&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;指导思想: 成于结构，臻于对话&#xA;PPT画页&#xA;    画的是冰山一角&#xA;    类似手持卡片&#xA;    类似左右脑: 逻辑+展示&#xA;具体内容&#xA;    思维导图&#xA;        维度筛选，MECE不重不漏&#xA;    空姐现象&#xA;        共知的事情特色讲，去掉已知部分&#xA;    卖钻讲孔&#xA;    电梯法则&#xA;        告知全局，步骤清晰，回顾小结&#xA;    递进逻辑：信息，分析，方法&#xA;目录&#xA;    首页效应&#xA;    目录，章节页，总结页&#xA;视觉&#xA;    图形代替文字: 缩小了看一看&#xA;    标题附主题语: 有兴趣有信息量&#xA;讲&#xA;    替画重点（提示语如: 请注意，提问）&#xA;    细讲：页只写观点，串联起来讲，只有30%内容重合&#xA;    心态&#xA;        注意力放在观众那边&#xA;        沟通合作而非防御&#xA;        房间有更聪明的人&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数字化转型&#34;&gt;&#xA;  数字化转型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e5%ad%97%e5%8c%96%e8%bd%ac%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;什么是数字化，有什么用&#xA;    发展&#xA;        信息化: 烟囱式，信息/数据孤岛，管理/运营孤岛&#xA;        互联网化&#xA;            互联互通: 0边际成本互联互通，云计算-&amp;gt;雾计算&#xA;        大数据化&#xA;            数据互联: 互联一切-&amp;gt;一切互联，跨界应用&#xA;            数据资源: 核心要素/资产，第一权利&#xA;        数智化&#xA;            人工智能：大数据-&amp;gt;大知识, 人类设计-&amp;gt;自动学习，替代与超越&#xA;                计算智能-&amp;gt;感知智能-&amp;gt;认知智能&#xA;            三位一体：(互联网+大数据+人工智能)+ Any&#xA;        数字孪生、元宇宙&#xA;    互联网+&#xA;        信息传递边际成本趋向于0&#xA;        连接机制革命&#xA;            任意两个资源(人或物)0边际成本互联互通: 信息0边际成本&#xA;            传播机制: 线性、金字塔式-&amp;gt;非线性、网状、几何级、病毒式&#xA;    带来什么&#xA;        数字科技三位一体：(互联网+大数据+人工智能)+&#xA;        边际革命：0边际成本效应，边际成本递减，边际收益递增&#xA;        数智：可知、可达、可控、可预测，程度剧变、实现边际成本剧变&#xA;        量变-&amp;gt;质变（工具革命-&amp;gt;革命的工具）&#xA;            局部改善-&amp;gt;全面优化-&amp;gt;全面重构&#xA;            技术应用-&amp;gt;业务优化-&amp;gt;全面变革&#xA;        农业时代，工业时代，数字时代，造物时代&#xA;为什么数字化转型&#xA;    企业处境&#xA;        各行各业先后&#xA;            总量短缺-&amp;gt;结构过剩，卖方市场-&amp;gt;买方市场，存量经济的争夺内卷加剧&#xA;            成熟稳定期-&amp;gt;跃迁剧变期&#xA;        各行各业被迫转型：不断重新分工、重新分利&#xA;            产业链 重构/(替代+重构)&#xA;    战略问题&#xA;        不是未来做什么，是做什么有未来&#xA;        提高打鱼技术但鱼没有了&#xA;        不要战术勤奋战略懒惰, 战术成功战略失败&#xA;        不是选择题是必答题&#xA;什么是企业/产业数字化&#xA;    IBA+经济&#xA;        电子商贸，流通    &#xA;        不是虚拟经济，是实体经济的全新形态&#xA;    IBA+交易&#xA;        渠道体系革命&#xA;            线上渠道为主，主导线上线下一体化&#xA;        终端(触点)为王&#xA;            与用户空间时间距离不断缩短&#xA;            一切皆终端，终端多样化-&amp;gt;场景碎片化(场景嵌入)-&amp;gt;新旧场景兴衰&#xA;            泛在智能交互，泛在智能感应(不断向生产环节渗透)&#xA;        交易边际成本大幅下降, 交易可能性边界急剧膨胀，资源配置能力与利用效率极大提高&#xA;            产业链重构：M2B2C, M2C, P2P&#xA;            野蛮营销-&amp;gt;精准营销-&amp;gt;智能匹配&#xA;        产品变渠道，产品渠道一体化&#xA;            智能产品-&amp;gt;触点+服务与生态体系&#xA;            产品成为持续服务的载体&#xA;            制造业服务业化&#xA;        智能化，机器体系对人的脑力及体力的强助力、替代、超越&#xA;            精细化、高度集成化&#xA;            去人化、极致自动化&#xA;            柔性化，按需生产、柔性制造能力&#xA;    IBA+生产&#xA;        业务跨界与跃迁：供应链资源，数据资源，新“物种”(产品)&#xA;        低碳、低能耗、低消耗: 自然资源稀缺性下降&#xA;    IBA+交易+生产&#xA;        交易生产一体化&#xA;            由需到供，按需生产，按需服务，按需研发，按需投资，0库存&#xA;            非标-&amp;gt;标准化-&amp;gt;去标准化(个性化生产)&#xA;            卖产品-&amp;gt;卖生产服务，制造业服务业化&#xA;            延展到整个国民经济生态体系，有计划的市场经济&#xA;        数据驱动，智能决策&#xA;        平台化+极致专业化分工&#xA;        企业(管理与产权)形态、雇佣形态的演变&#xA;            管控型-&amp;gt;交易型/平台型&#xA;            企业人员规模缩小，企业边界模糊&#xA;            企业、资本与劳动者关系演变&#xA;数字化转型&#xA;    数字经济质跃工业经济&#xA;        数字经济系统&#xA;            经济环境: 人类经济活动(分工协作)的基础条件(信息不对称性，资源稀缺性)发生剧变&#xA;            经济活动: 交易和生产的边际成本大幅下降，经济活动的效率大幅上升，经济活动的可能性边界急剧膨胀&#xA;        从根本上超越工业经济&#xA;    数字化经济含义&#xA;        交易、生产：0边际成本&#xA;        边际革命：人类逐步进入0边际成本时代&#xA;        边际成本递减-&amp;gt;0边际成本-&amp;gt;边际成本为负&#xA;        结果变成原因，逼近转型升级&#xA;    数字化转型升级&#xA;        以数字科技为应用手段，持续推进业务变革、组织变革&#xA;        经济的数字化转型升级: 以数字科技应用为手段，推进经济模式、经济形态持续转型升级&#xA;        企业数字化转型升级：以数字科技应用为手段，推进企业营销模式、服务模式、管理模式、生产模式、决策模式、商业模式、产权模式等持续转型升级&#xA;    鸿沟：科技&amp;lt;-&amp;gt;业务&#xA;        可能性(无限)-&amp;gt;现实性(有限)&#xA;        科技-&amp;gt;技术应用(产品/模式/制度创新变革)-&amp;gt;业务问题-&amp;gt;科技应用创新不足是制约转型升级、创新发展的关键瓶颈&#xA;        问题导向，需求拉动&#xA;            科技应用价值问题：经济效益是检验科技领先的唯一标准&#xA;            科技应用方向问题：0到0的创新比0到1的创新更关键&#xA;            科技应用的路径问题：并非都是&amp;quot;富家子&amp;quot;&amp;quot;优等生&amp;quot;&#xA;    转型是什么&#xA;        三个层次&#xA;            新赛道(局部): 新技术、新产品、新兴产业链&#xA;            新形态(普遍): 新业态、新模式、新型产业链&#xA;            新经济(全面): 新生态、新格局&#xA;        企业：全面转型或K型经济&#xA;    可行方法&#xA;        你是谁：业务现状&#xA;        你想变成谁&#xA;            动因与目标(短期、长期)&#xA;            问题导向与需求分析&#xA;        你能变成谁&#xA;            基础条件与既有资源&#xA;            信息化数字化的基础&#xA;        你如何变成谁&#xA;            (周而复始)设计-&amp;gt;建设-&amp;gt;运营(业务+系统)-&amp;gt;跟踪与评估&#xA;    得客户资源者得天下&#xA;        流量-&amp;gt;留量&#xA;        客户资源：客户数据+客户关系+客户渠道&#xA;        以更低边际成本掌控更大的客户资源&#xA;        谁掌握完备的客户资源&#xA;        如何掌握完备的客户资源&#xA;    未来已临&#xA;        划时代的技术都是试金石&#xA;        与时代赛跑&#xA;实施&#xA;    本质&#xA;        数字驱动的用户中心观, 不是业务中心观&#xA;        增长三角：规模、分工、效率&#xA;    思维: 大数据、区块链&#xA;    用户价值: &#xA;        一个框架: 价值创造，用户挖掘，用户数据，个性化服务，差异化用户保留&#xA;        一个目标: 每个用户&amp;quot;精耕细作&amp;quot;&#xA;        一个重点: 数字化全链路管理，全场景营销, 全渠道服务&#xA;    价值网络: 一个核心&#xA;    商业模式&#xA;        Costco&amp;quot;复利高墙&amp;quot;&#xA;            差异化价值、服务对象、盈利模式+核心能力&#xA;            数字化会员：精准预测，精准选品，自有品牌&#xA;    供应链&#xA;        问题：牛鞭效应，不确定效应&#xA;        解决：基于数据观察趋势，不预测趋势&#xA;    增长飞轮&#xA;        数字化加速技术分层分化, 技术模块化&#xA;        运营卓越: 上游核心技术，下游用户亲密&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数智化转型&#34;&gt;&#xA;  数智化转型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%99%ba%e5%8c%96%e8%bd%ac%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;技术：人工智能，区块链，云计算，大数据，边缘计算&#xA;管理：科学管理-&amp;gt;人本管理-&amp;gt;精益管理-&amp;gt;价值共生&#xA;重塑思维&#xA;战略转型方向&#xA;管理变革&#xA;商业模式&#xA;重塑领导力&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数字化营销&#34;&gt;&#xA;  数字化营销&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e5%ad%97%e5%8c%96%e8%90%a5%e9%94%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;4P: 产品、价格、渠道、推广&#xA;4C： 消费者(Consumer)、成本(Cost)、便利(Convenience)、沟通(Communication)&#xA;4R: 关联(Relevance), 反应(Reacton), 关系(Relationship), 报酬(Reward)&#xA;Marketing Jungle: 及时性、社会性、精准性、方便性&#xA;CIDR&#xA;    Contact: 全渠道(全场景): 在商，在家，在途&#xA;    Identify: 二维码，小程序，人脸，Beacon&#xA;    Data: 数据标签(分级分群)&#xA;    Reaction&#xA;大数据营销&#xA;    3V: 数量(Volume)、速率(Velocity)、多样(Variety)&#xA;    维度&#xA;        身份象征: 年龄、身高、性别、居住地&#xA;        生活风格: 朝九晚五、泡吧达人、工作狂&#xA;        消费行为: 购买时间、购买方式、促销敏感&#xA;        社交行为：意见领袖、意见跟随者&#xA;        商品偏好：咖啡达人、面包达人&#xA;        RFM: 最近消费、消费频率、消费金额&#xA;    升级：金字塔(二八原则)&#xA;    挽留&#xA;    精准营销：相关分析、逻辑回归分析、购物栏分析、标签群体聚类分析&#xA;    私域&#xA;        进(获客)&#xA;            线下：自然来客、地推&#xA;            会员裂变&#xA;            大数据：探针法、数据交换法、WiFi法&#xA;            产品为王&#xA;            线上引流：SEO, SEM/关键字投放, ASO, CPS(按销售付费), DSP(跨平台), Banner, 嵌入代码/挂件，微信/社交/短视频&#xA;        活(激活)&#xA;            不删: 电子会员、交互平台、创造场景&#xA;            关卡：产生兴趣、激发欲望、消除顾虑(七天免费)、立刻行动&#xA;        粘(粘性)&#xA;            RFM分群&#xA;                R: 最近一次消费&#xA;                F: 消费频次&#xA;                M: 消费金额&#xA;            增加粘性: 次数带动，品类带动，场景带动&#xA;        值(客户价值)&#xA;            CLV=贡献价值 - (取得成本+维系成本)&#xA;        荐(裂变)&#xA;            原因: 创造价值 获客&#xA;            方法&#xA;                分享, 红包，IP,亲子，团购, 朋友&#xA;移动营销&#xA;    优势：实时在线、高效传递、多媒体负载、瞬间反应&#xA;    特色4I: 个性化(I)、互动(Interactive)、分众识别(Individual Identification)、实时信息(Instant Message)&#xA;    设备：二维码、App、小程序、穿戴技术&#xA;        MAC Address: 基地台，路径&#xA;        Beason: 室内&#xA;        DSP: 标签种植&#xA;            限制：隐私侵犯、推送用APP未打开、设备更换&#xA;    七个瞬间&#xA;        场景: 时间地点，和谁一起，当前感觉，需要什么; 和上次一样&#xA;        位置距离: 地理定位，地理围栏，地理征地&#xA;        时间&#xA;            实用性产品(效率): 早上&#xA;            享乐型产品(心情): 下午&#xA;        天气&#xA;            影响心情&#xA;            预防性框架&#xA;        轨迹&#xA;        社会: 和谁一起&#xA;        拥挤度&#xA;社交媒体&#xA;    pay media, earned media, owned media&#xA;    社群&#xA;        粉丝: 目的&#xA;        企业：目的&#xA;        方式&#xA;            找兴趣, 嬴关注&#xA;            造品牌, 聚粉丝&#xA;    场景思维&#xA;        围绕产品&#xA;        围绕时间&#xA;        围绕特定事件&#xA;    内容营销&#xA;        步骤&#xA;            任务规划：对象、目的、场景&#xA;                阶段性目标：粉丝数、活跃度、互动数、观看数、展示数、流量数据&#xA;            内容创意：起承转合, story board&#xA;                标题、价值(有趣、有利)、为什么转发(显示一手信息、表达立场、自娱娱人)&#xA;                确定渠道: 对象，内容类型，流量机制&#xA;            评估学习&#xA;        内容策略&#xA;            热点性内容&#xA;            即时性内容&#xA;            生活故事内容&#xA;            方案或学习性(生活小贴士)&#xA;            连载性内容&#xA;            促销性内容&#xA;    全流程整合&#xA;        交易平台: 微商、微店(企业内店、第三方平台)、微商城&#xA;        分润机制: 入会条件、会员等级、推荐提成、等级折扣&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;企业管理&#34;&gt;&#xA;  企业管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%81%e4%b8%9a%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;战略&#xA;    目标：使命，愿景&#xA;    分层&#xA;        企业层面战略&#xA;        业务单元层面战略（竞争战略）&#xA;        职能层面战略&#xA;    管理&#xA;        战略分析阶段&#xA;        战略选择阶段&#xA;        战略评价阶段&#xA;        战略实施阶段&#xA;        战略控制阶段&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;优化咨询&#34;&gt;&#xA;  优化咨询&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8c%96%e5%92%a8%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;问题&#xA;    客户反馈&#xA;        单体应用&#xA;            模块耦合程度&#xA;            微服务划分与边界&#xA;        单节点数据库&#xA;            查询崩溃&#xA;        IoT控制&#xA;            命令超时失败, 响应慢&#xA;            出错业务处理&#xA;    发现问题&#xA;        现有代码逻辑梳理&#xA;        通过链路追踪，找性能瓶颈&#xA;        SQL平台建设，发现数据库性能问题，优化SQL&#xA;        服务器节点监控，应用监控，数据库监控&#xA;解决问题&#xA;    代码&#xA;        纯代码优化：N+1调用，事务问题&#xA;        逻辑优化：订单失败，复杂业务流程优化&#xA;        发布流程优化CI/CD&#xA;        中间件优化：优雅停机，灰度方案节点打标，全链路日志&#xA;        性能优化：业务并行处理，业务异步处理&#xA;    数据库&#xA;        不合理调用治理：批量更新，大事务，&#xA;        慢SQL治理&#xA;        数据库备份：主从优化，定时备份&#xA;        配置调优&#xA;    架构&#xA;        高可用：服务发现，分布式&#xA;        业务缓存优化，减少数据库调用：热点数据，对象缓存，多级缓存&#xA;        分布式任务平台：分片执行&#xA;        任务中心：批量平台&#xA;稳定性&#xA;    告警平台&#xA;        异常告警(空指针，接口调用成功率)&#xA;        监控告警(服务器使用率)&#xA;        业务告警(下单失败)&#xA;    限流熔断&#xA;        网关限流，业务限流，接口限流，外部调用限流&#xA;        业务平滑处理&#xA;运营工具&#xA;    业务数据多维分析&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>服务治理</title>
      <link>https://runout.run/docs/architect/method/architect/</link>
      <pubDate>Wed, 10 Oct 2018 16:49:27 +0800</pubDate>
      <guid>https://runout.run/docs/architect/method/architect/</guid>
      <description>&lt;h1 id=&#34;原则&#34;&gt;&#xA;  原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;高并发&#xA;高可用&#xA;高可靠&#xA;    SLA(service level agreement)制定(吞吐量、响应时间、可用性、降级方案)&#xA;    容量规划(流量、容量)&#xA;    监控报警(机器负载、响应时间、可用率)&#xA;        tracing&#xA;    应急预案(容灾、降级、限流、隔离、切流量、可回滚)&#xA;成本&#xA;经济学原理&#xA;    比较优势&#xA;        服务器类型&#xA;    分工协作&#xA;        组合&#xA;    货币解耦&#xA;        MQ&#xA;    规模效益&#xA;        集群&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;高可用&#34;&gt;&#xA;  高可用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e5%8f%af%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;负载均衡&#34;&gt;&#xA;  负载均衡&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;流量切换     # 某服务器挂了&#xA;    DNS切换&#xA;    httpDNS         # app配置，绕过运营商localDNS&#xA;    lvs/haproxy     # 切换故障的nginx&#xA;    nginx           # 切换故障应用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;限流&#34;&gt;&#xA;  限流&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%99%90%e6%b5%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;思路&#xA;    恶意请求流量只访问cache&#xA;    穿透到应用的流量用nginx limit&#xA;    恶意ip nginx deny&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;降级&#34;&gt;&#xA;  降级&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%99%8d%e7%ba%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;开关集中化管理, 推送开关配置&#xA;开关前置      # nginx层做开关&#xA;可降级读服务   # 只读本地缓存、只读分布式缓存、只读默认数据&#xA;业务降级      # 部分业务异步，处理高优先级，分配流量保障系统可用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;隔离&#34;&gt;&#xA;  隔离&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%94%e7%a6%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;线程隔离&#xA;进程隔离&#xA;集群隔离&#xA;机房隔离&#xA;读写隔离&#xA;动静隔离&#xA;爬虫隔离&#xA;热点隔离&#xA;资源隔离&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;回滚&#34;&gt;&#xA;  回滚&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%9e%e6%bb%9a&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;事务&#xA;代码库&#xA;部署版本&#xA;数据版本&#xA;静态资源版本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;超时与重试&#34;&gt;&#xA;  超时与重试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b6%85%e6%97%b6%e4%b8%8e%e9%87%8d%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;压测与预案&#34;&gt;&#xA;  压测与预案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%8b%e6%b5%8b%e4%b8%8e%e9%a2%84%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;线下、线上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;高并发&#34;&gt;&#xA;  高并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;缓存&#34;&gt;&#xA;  缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;客户端&#xA;    浏览器缓存   # Pragma, Expires, Cache-control&#xA;    ajax&#xA;    app缓存     # 大促时更新静态资源, 地图&#xA;客户端网络      # 代理服务器缓存&#xA;广域网&#xA;    代理服务器(如CDN)&#xA;        推送 或 拉取(回源)&#xA;    镜像服务器&#xA;    P2P&#xA;源站&#xA;    接入层缓存   # 如页面缓存，用redis&#xA;        url重写&#xA;        一致性哈希&#xA;        proxy_cache         # 内存/SSD缓存内容&#xA;        proxy_cache_lock    # 一段时间的回源合并成一个&#xA;        shared_dict         # lua, 重启缓存不丢失&#xA;    应用层缓存           # 如搜索，建议物品等&#xA;        堆内缓存&#xA;        堆外缓存        # local redis cache&#xA;    分布式缓存(接入层后)&#xA;        redis集群     # 异步化写入, lua-resty-lock(非阻塞锁)&#xA;    对象缓存    # db和应用间的查询结果集&#xA;    静态化, 伪静态化&#xA;    服务器操作系统缓存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;连接池线程池&#34;&gt;&#xA;  连接池线程池&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9e%e6%8e%a5%e6%b1%a0%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;异步化&#34;&gt;&#xA;  异步化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;队列&#34;&gt;&#xA;  队列&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%9f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;作用&#xA;    服务解耦&#xA;    异步处理&#xA;    流量削峰/缓冲     # 如促销期&#xA;问题&#xA;    丢失/失败     # 持久化，日志，报警, 数据校对修正(worker扫库)&#xA;    重复          # 业务上防重&#xA;例子&#xA;    redis扣库存-&amp;gt;记录日志-&amp;gt;同步worker-&amp;gt;DB&#xA;消息总线可扩展     # x扩展不行，y扩展用专用总线(降低了灵活性), z扩展根据客户&#xA;减少拥挤          # 消息划分价值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;扩容&#34;&gt;&#xA;  扩容&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%a9%e5%ae%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;无状态     # 应用无状态，配置有状态&#xA;    尽可能浏览器端维护会话&#xA;    分布式缓存放状态&#xA;拆分  # 加法组合，乘法功能&#xA;      # 项目死于1到10，或10到100，因为解耦不够，无法重构&#xA;    业务拆分&#xA;    功能细分&#xA;    读写      # 读缓存，写分库分表，聚合数据&#xA;    AOP      # 如CDN&#xA;    模块      # 代码特征，如基础模块分库分表，数据库连接池&#xA;数据异构&#xA;    例子&#xA;        聚合数据表(一般KV存储)   # 数据闭环(不依赖其它服务)&#xA;        历史归档&#xA;    并发化&#xA;选择工具&#xA;    数据库     # rdb, nosql, hadoop&#xA;    防火墙     # 墙需要的东西&#xA;    日志       # 采集分析&#xA;    用同品牌设备&#xA;    慎用第三方&#xA;容错&#xA;    隔离               # 不同步调用，限制异步调用(数量和超时)，能迅速发现故障&#xA;    不单点             # 一切都出故障&#xA;    不系统串联&#xA;    功能支持启用禁用    # 实现wire on/wire off框架&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;服务方法&#34;&gt;&#xA;  服务方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;成本分析&#34;&gt;&#xA;  成本分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# autonomy.design&#xA;表现&#xA;    一个需求拉很多人，代码写进来就删不掉了&#xA;    通用功能要么多种实现，要么参数过多&#xA;    线上问题难定位，本地做不了有意义的测试，反馈周期特别长&#xA;本质&#xA;    减少沟通&#xA;        autonomy(自治): 减少沟通，功能可以删掉&#xA;            问题: 产品从整体效果出发，开发从实现出发&#xA;            依赖倒置&#xA;                UI插槽, 服务集成&#xA;                实现(服务)&#xA;                    编译时: 模板、函数替换&#xA;                    运行时: 组合对象、组合函数&#xA;                实现(UI)&#xA;                    编译时: 页面模板替换, 显式组合与隐式组合&#xA;                    运行时: Vue插槽&#xA;        feedback(反馈): 故障定位，测试反馈，发版反馈，用户反馈无响应&#xA;            控制边界&#xA;                进程&#xA;                    跨进程调用监控: 基础设施完善&#xA;                    OS强制配额、安全性: 基础设施好&#xA;                    内存隔离&#xA;                函数&#xA;                    caller/callee索引: 同步调用栈、异步调用链、组件树&#xA;                    问题: 日志多，负责模糊&#xA;                插件&#xA;            控制变更&#xA;                多进程&#xA;                    多进程部署&#xA;                多租户&#xA;                多变种&#xA;                    配置中心下发开关&#xA;        consistency(一致性): 工具复用&#xA;            用户可见的一致性: UI/UE设计，前端落地&#xA;            autonomy: 上层业务推动&#xA;                问题: 依赖修改要慎重&#xA;            feedback: QA, KPI&#xA;拆分&#xA;    组合关系&#xA;        加法&#xA;        乘法&#xA;        一致性复用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;扩展方式&#34;&gt;&#xA;  扩展方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%a9%e5%b1%95%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;服务化发展&#xA;    进程内服务&#xA;    单机远程服务&#xA;    集群手动注册服务(nginx负载多实例)&#xA;    自动注册和发现服务(zookeeper)&#xA;    服务分组/隔离/路由&#xA;    服务治理(限流/黑白名单)&#xA;AKF扩展立方&#xA;    x轴 横向复制                 # 复制服务或db, 瓶颈：内存缓存、特有数据&#xA;    y轴 面向功能、服务、资源拆分   # 微服务&#xA;        动词拆分                 # 登录、搜索、推荐等&#xA;        名词拆分                 # 目录、库存、账户等&#xA;    z轴 拆相近东西               # 数据分片(大小客户、地区、新旧等)&#xA;横向扩展    # 复制服务或数据分散负载，纵向扩展是升级设备&#xA;    使用经济型系统&#xA;    扩展数据中心      # 三实时站点备份: a(0.5b, 0.5c), b(0.5a, 0.5c), c(0.5a,0.5b), 尽量分散&#xA;    使用云&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;微服务&#34;&gt;&#xA;  微服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%be%ae%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;单体应用问题&#xA;    复杂: 模块多, 边界模糊, 依赖关系不清晰, 代码质量不统一&#xA;    技术债务: 不坏不修&#xA;    部署频率低: 迭代要部署整个应用，部署时间长，风险高。修复问题慢, 易出错&#xA;    可靠性差: 某bug导致整个应用崩溃&#xA;    扩展性差&#xA;    阻碍技术更新&#xA;特征&#xA;    服务组件化&#xA;    按业务组织团队&#xA;    负责的态度, 不再是交付给维护者&#xA;    粗粒度通信, http(二进制协议)或消息总线&#xA;    去中心化治理&#xA;    去中心化管理数据&#xA;    基础设施自动化&#xA;    容错设计&#xA;    演进式设计&#xA;原则&#xA;    单一职责&#xA;    自洽&#xA;    轻量级通信&#xA;    服务粒度: 边界(DDD中的界限上下文)&#xA;持续发布&#xA;    工具链，自动化&#xA;    契约&#xA;    架构守护&#xA;    灰度替换&#xA;*aaS&#xA;    SaaS(software as a service)&#xA;    PaaS(platform as a service)&#xA;    aPaaS(application PaaS)         # 简单配置产生任意需求的application&#xA;    saPaaS(specific aPaaS)          # 领域定制的aPaaS&#xA;    GaPaaS(generator of aPaaS)      # 脚手架，产生定制的aPaaS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;云原生&#34;&gt;&#xA;  云原生&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e5%8e%9f%e7%94%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    cloud navtive, Pivotal 2013年提出&#xA;12-Factor&#xA;    1 基准代码(code base)&#xA;        一份代码，多份部署&#xA;    2 依赖(dependences)&#xA;        显式声明依赖&#xA;    3 配置(config)&#xA;        配置存储于环境变量中&#xA;        环境变量粒度足够小，相对独立&#xA;    4 后端服务(backing services)&#xA;        后端服务作为附加资源, 与第三方服务不区别对待&#xA;    5 分离构建、发布、运行(build, release, run)&#xA;        构建: 代码转化到可执行包&#xA;        发布: 可执行包结合配置&#xA;        运行: 选定发布版本，按计划启动&#xA;    6 进程(process)&#xA;        多个无状态进程运行&#xA;    7 端口(port binding)&#xA;        网络服务通过端口绑定提供服务&#xA;        完全自我加载不依赖网络服务器&#xA;    8 并发(concurrency)&#xA;        进程作为一等公民&#xA;        通过进程模型扩展并发&#xA;    9 易处理(disposability)&#xA;        进程快速启动、优雅终止可最大化健壮性&#xA;        追求最小启动时间, 收到SIGTERM优雅终止，突然死亡时保持健壮&#xA;    10 环境等价(dev/prod parity)&#xA;        开发环境等价线上环境&#xA;    11 日志(logs)&#xA;        日志作为事件流&#xA;        应用本身使用stdout事件流，不考虑存储输出流，不管理日志&#xA;    12 管理进程(admin processes)&#xA;        管理进程不常驻, 一次性运行&#xA;        使用同样环境、代码版本、配置、依赖隔离, 避免同步问题&#xA;        提供REPL shell使一次性脚本变简单&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;service-mesh&#34;&gt;&#xA;  Service Mesh&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#service-mesh&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;处于 TCP/IP 之上的抽象层&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;serverless&#34;&gt;&#xA;  Serverless&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#serverless&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;只写业务代码，不关心服务器运行状态&#xA;BaaS&#xA;    # Backend as a Service&#xA;FaaS&#xA;    # Functions as a Service&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>知识图谱</title>
      <link>https://runout.run/docs/architect/strategy/ai/map/</link>
      <pubDate>Wed, 10 Oct 2018 16:49:27 +0800</pubDate>
      <guid>https://runout.run/docs/architect/strategy/ai/map/</guid>
      <description>&lt;h1 id=&#34;与深度学习区别&#34;&gt;&#xA;  与深度学习区别&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;深度学习是显性模型，知识图谱是隐性模型&#xA;场景：人脸识别；语音助手&#xA;目前进展: 在一些任务上已超过人类；知识量超过人类，推理不如人类&#xA;任务范围：面向具体任务，难以迁移；广泛适用于不同任务&#xA;可解释性：较难解释；可解释性强&#xA;数据量：海量训练数据；海量知识数据&#xA;未来趋势：深度融合&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;历史&#34;&gt;&#xA;  历史&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%86%e5%8f%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;2010年: 微软构建Satori、Probase&#xA;2012年: 谷歌X实验室识别&amp;quot;猫&amp;quot;, 发布Google Knowledge Graph&#xA;2013年：百度布局&#xA;2015年：阿里布局&#xA;2016年：亚马逊布局&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;视觉思维&#xA;关联&#xA;推理&#xA;结构识别&#xA;降维&#xA;概念图&#xA;网络模型&#xA;潜在领域寻迹&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;领域&#34;&gt;&#xA;  领域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%86%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;宇宙图谱&#xA;    绘图学&#xA;    陆地地图&#xA;    天体图&#xA;    生物图谱&#xA;轨迹&#xA;    旅行商&#xA;    虚拟世界搜索&#xA;    信息觅食，过程建模&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;应用&#34;&gt;&#xA;  应用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内容理解&#xA;    篇章理解&#xA;    推荐场景&#xA;        路径推荐&#xA;        知识融入推荐&#xA;        广告&#xA;    召回排序&#xA;    智能营销&#xA;        画像&#xA;            用户画像&#xA;            产品画像&#xA;            场景画像&#xA;        库&#xA;            概念库&#xA;            语义本体库&#xA;            规则库&#xA;        建模分析&#xA;            分词、词性标注、命名实体识别&#xA;            句法分析、语义表示、概念发现&#xA;            用户打标、场景打标、产品打标&#xA;            语义匹配、指代消解、主题模型&#xA;搜索理解&#xA;    语义搜索&#xA;    演化分析&#xA;    场景化搜索&#xA;    路径召回&#xA;    对话理解&#xA;商家&#xA;    智能化商家运营&#xA;    商业大脑&#xA;        商业分析&#xA;可解释性&#xA;    图谱路径推荐理由&#xA;    知识融入生成推荐理由&#xA;实体卡片&#xA;    资源聚合&#xA;    内容分发&#xA;    产业链图谱&#xA;    用户画像&#xA;    高管画像&#xA;    价格图谱&#xA;    债券风险预警&#xA;    中小企业风控图谱&#xA;    营销获客图谱&#xA;    产品与工艺创新研发&#xA;    安全质量&#xA;    供应链&#xA;    社会关系图谱&#xA;    交易关系图谱&#xA;    网络图谱&#xA;    时空关系图谱&#xA;任务自动化&#xA;    维度：可发现、可移接、可推理&#xA;    自动化：自动数据结构化、流程自动化、业务服务化、服务开放化&#xA;推理&#xA;    本体推理&#xA;        概念补全&#xA;        商品品类上下位发现&#xA;        同质类目/属性项/属性值识别，新类目发现&#xA;        实体识别与分类&#xA;    关系抽取&#xA;        实体对齐&#xA;        实体链接&#xA;        商品分类、增量商品分类、商品标题&#xA;    常识推理&#xA;        关系推理与链接预测&#xA;        规则学习&#xA;        百科知识发现&#xA;        商品对齐&#xA;        可比价同款规则挖掘&#xA;    知识问答&#xA;        知识增强学习&#xA;        知识融入语言预训练&#xA;        人货匹配&#xA;网络安全&#xA;    专家系统-&amp;gt;感知智能-&amp;gt;认识智能-&amp;gt;决策智能&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;流程&#34;&gt;&#xA;  流程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据爬取&#xA;    数据爬取平台&#xA;    知识获取&#xA;        实体识别&#xA;        概念、关系、属性抽取&#xA;        标签挖掘&#xA;        情感分析&#xA;        知识融合：概念层融合，数据层融合&#xA;        知识建模: 概念上下位关系生成、概念属性识别、规则建模、事件建模、时空建模&#xA;    多元异构数据&#xA;        非结构化文档&#xA;        半结构化数据&#xA;        结构化知识&#xA;    抽取模块&#xA;        基于规则&#xA;        基于模板   &#xA;        基于模型&#xA;            经典模型: PCNN、BiLSTM&#xA;            预训练模型: BERT、摩天&#xA;    预/后处理&#xA;        先验知识库: 规则库、领域词表、模板库、黑白名单&#xA;        数据集构建：人工标注、远程标注、数据集管理&#xA;知识融合&#xA;    Schema对齐(异构转同构)&#xA;    数据清洗&#xA;    实体对齐(去重，消岐)&#xA;    属性择优&#xA;知识关联&#xA;    规则推理&#xA;    建边模型&#xA;存储检索&#xA;    图引擎&#xA;        图存储引擎&#xA;        图学习引擎&#xA;        图查询引擎&#xA;    优化&#xA;        KV库&#xA;        索引库&#xA;        控制和数据分离&#xA;        Schema压缩&#xA;知识计算&#xA;    知识补全&#xA;    知识推理&#xA;    知识统计与图挖掘&#xA;知识图谱金字塔&#xA;    文本(text)-&amp;gt;标签(label、tag)-&amp;gt;表格(table)-&amp;gt;图(graph)-&amp;gt;模式(schema)-&amp;gt;本体(ontology)-&amp;gt;规则(rule)&#xA;技术&#xA;    计算：Spark&#xA;    中间存储：HIVE&#xA;    检索：ES&#xA;监控体系&#xA;    知识管理系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;框架&#34;&gt;&#xA;  框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Spark&#xA;HIVE&#xA;ES&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;CiteSpace&#xA;Jigsaw&#xA;Carrot&#xA;iOpener&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>支撑-原理</title>
      <link>https://runout.run/docs/basic/computer/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:25:12 +0800</pubDate>
      <guid>https://runout.run/docs/basic/computer/principle/</guid>
      <description>&lt;h1 id=&#34;主机&#34;&gt;&#xA;  主机&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e6%9c%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  cpu&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    单cpu串行工作，前任务完成，后任务才开始                             # 串行不适合图形处理(多点，线，面要同时乘投影矩阵)&#xA;    cpu把大量空间和电量分配给控制器和缓存，不能集成太多计算单元&#xA;    cpu内存通过cpu总线连接, cpu总线与pci总线通过主桥(北桥)连接&#xA;        gpu在pci总线上&#xA;        控制逻辑在cpu中运行, 生成渲染数据, 到内存, 再到显存显卡计算。&#xA;        内存到显存数据传输最花费时间。&#xA;原理&#xA;    处理单元(processing unit)&#xA;        算术逻辑单元(arithmetic logic unit)&#xA;        处理寄存器(processor register)&#xA;    控制单元(control unit)&#xA;        指令寄存器(instruction register)&#xA;        程序计数器(program counter)&#xA;    指令集架构(ISA, instruction set architecture)                   # 机器码易兼容, 软件易编程, 易升级cpu&#xA;        精简指令集RISC(reduced instruction set computing)&#xA;        复杂指令集CISC(complex instruction set computer)&#xA;    时钟频率(clock speed)&#xA;    生产&#xA;        生产线散热决定生存率，决定cpu型号&#xA;    多级缓存&#xA;        L1, L2, L3, L4&#xA;    虚拟化&#xA;        虚拟机监视器(VMM, virtual machine monitors)&#xA;分类&#xA;    指令流的重数分类&#xA;        SI(single instruction stream)单指令流&#xA;        MI(multiple instruction stream)多指令流&#xA;    操作数流的重数分类&#xA;        SD(single data stream)单数据流&#xA;        MD(multiple data stream)多数据流&#xA;    SISD 串行计算机&#xA;    SIMD 阵列机(多处理单元)&#xA;    MISD 很少&#xA;    MIMD&#xA;        多处理机&#xA;        多计算机&#xA;硬件并行&#xA;    位级(bit-level): 32位, 64位计算机&#xA;    指令级(instruction-level)              # 处理器内部并行度很高&#xA;        流水线&#xA;            指令分步骤(指令流), 每步专门部件处理&#xA;            多指令流并行, 部件不空闲等待单指令流结束&#xA;            六级流水线步骤&#xA;                取指(FI), 译码(DI), 计算操作数地址(CO), 取操作数(FO), 执行指令(EI), 写操作数(WO)&#xA;        多发射(超标量)&#xA;            一时钟周期处理多指令&#xA;        超线程&#xA;            模拟多个逻辑线程&#xA;        乱序执行&#xA;        猜测执行&#xA;    数据级&#xA;        向量体系结构、图形处理器&#xA;        单指令多数据(SIMD)架构&#xA;    线程级                                 # 紧耦合硬件模型中开发数据级或任务级并行，线程间有交互&#xA;    请求级                                 # OS或程序耦合任务间并行&#xA;程序并行&#xA;    数据级(DLP, data-level parallel)&#xA;    任务级(TLP, task-level parallel)       # 多处理器, 超线程, 虽只有4个核，但可用核返回8&#xA;        内存&#xA;            共享内存模型&#xA;            分布式内存模型&#xA;        进程: 独有内存&#xA;        线程: 共享进程内存(地址空间、文件描述符)&#xA;            一个进程下的轻量进程&#xA;            POSIX线程api是对已有unix进程模型扩展, 与进程多方面类似&#xA;                自己的信号掩码&#xA;                cpu affinity(倾向在某cpu尽量长时间运行)&#xA;                cgroups&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;进程调度&#34;&gt;&#xA;  进程调度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;等级&#xA;    高级调度(High-Level Scheduling)&#xA;        作业调度, 后备作业调入内存运行&#xA;    低级调度(Low-Level Scheduling)&#xA;        进程调度, 就绪队列中某进程获得cpu&#xA;    中级调度(Intermediate-Level Scheduling)&#xA;        虚拟存储器引入, 内外存对换区进行进程对换&#xA;&#xA;方式&#xA;    非剥夺方式&#xA;        处理机分配给某进程后一直运行下去,直到阻塞时,才分配处理机到另一个进程&#xA;    剥夺方式&#xA;        进程运行时,系统基于某种原则,剥夺分配给它的处理机.&#xA;        采用算法&#xA;            先进先出算法&#xA;                批处理系统用. 总把处理机分配给最先进队的进程, 将一直执行下去,直到阻塞&#xA;            短进程优先(SCBF  Shortest CPU Burst First)&#xA;                批处理系统用. 从就绪队列中选出下一个cpu执行期最短的进程,分配处理机&#xA;            轮转法&#xA;                分时系统中,都采用时间片轮转法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gpu&#34;&gt;&#xA;  gpu&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    gpu控制单元少, 计算单元多&#xA;    显卡在pci总线上&#xA;原理&#xA;    数据级并行&#xA;        单条指令并行应用于数据集(SIMD)&#xA;    CUDA(compute unified device architecutre)                       # nvidia推出的通用并行计算架构&#xA;        多网格(grid)组织，每网格多(512-1536)线程块&#xA;        线程块线程相同指令地址, 通过共享存储器(shared memory)和栅栏(barrier)块内通信&#xA;            不同块不通信，粗粒度并行&#xA;            同块通信，细粒度并行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    虚拟内存(virtual memory)&#xA;    页表(page table)&#xA;        控制寄存器(control register)&#xA;            CR3保存页目录表内存基地址&#xA;        4级页表(PML4)&#xA;        转换检测缓冲区(TLB, translation lookaside buffer)&#xA;dma&#xA;    # direct memory access 不依赖cpu的内存存取&#xA;栈&#xA;    申请方式: 系统自动分配&#xA;    申请响应: 栈剩余空间小于申请空间, 报overflow&#xA;    申请大小限制: 栈是向低地址扩展的连续内存，线顶地址和最大容量是系统编译时预设的，windows下为2M(或1M), 申请超过剩余空间报overflow&#xA;    申请效率: 系统分配，速度快&#xA;    存储内容: 函数调用时，函数调用语句的下一条指令的地址进栈，然后是参数(C中由右向左), 然后是局部变量。调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向开始保存的函数下一指令，继续运行&#xA;    数据结构: 满足后进先出的数据结构&#xA;堆&#xA;    申请方式: 程序手动申请&#xA;    申请响应: os有记录空闲内存地址的链表，申请时遍历链表，寻找第一个空间大于申请空间的堆结点，该结点从空闲结点删除，节点分配给程序。自动将多余部分重新放入空闲链表&#xA;    申请大小限制：堆是向高地址扩展的不连续内存，系统用链表存储空闲内存地址。受限于有效虚拟内存&#xA;    申请效率: 慢，容易产生内存碎片&#xA;    存储内容: 堆头部一个字节存放堆的大小。内容由程序员安排&#xA;    数据结构: 满足优先队列的数据结构(第1个元素有最高优先权)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;网络&#34;&gt;&#xA;  网络&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ABR(area border router)：区域边界路由器&#xA;子网隔离&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;状态&#34;&gt;&#xA;  状态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;cookie&#34;&gt;&#xA;  cookie&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cookie&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    cookie的弊端&#xA;        数据在客户端可以被修改，所以不能存重要数据&#xA;        cookie中字段太多会影响传输效率&#xA;请求头&#xA;    set-cookie&#xA;        # 规定cookie的格式为name = value&#xA;响应&#xA;    path&#xA;        # cookie发送的相对路径&#xA;    expires和maxAge&#xA;        # expires是UTC时间, maxAge是cookie多久后过期&#xA;        ## 不设置这两个时产生的是session cookie, 它是transient的，用户关闭浏览器时清除。一般用来保存session_id&#xA;    secure&#xA;        # true时, cookie在HTTP中是无效的, 在HTTPS中才有效&#xA;    httpOnly&#xA;        # 通知浏览器不允许脚本操作document.cookie。一般都应设置为true, 可以避免被xss攻击拿到cookie&#xA;签名( 信息摘要算法)&#xA;    原user=&#39;alsotang&#39;&#xA;    现user=sha1(&#39;my_secret&#39; + &#39;alsotang&#39;) === &#39;xxxx...xxx&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;session&#34;&gt;&#xA;  session&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#session&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    session通过cookie中存放session_id来实现&#xA;    可以存放在&#xA;        1. 内存&#xA;        2. cookie本身&#xA;            # 不用担心集群的状态共享问题，安全性可以遵照最佳实践来，也是有保证的，最大的弊端在于增大了数据量传输。有受到回放攻击的危险&#xA;        3. redis或memcached等缓存&#xA;            # 常用&#xA;        4. 数据库中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;osi分层&#34;&gt;&#xA;  OSI分层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#osi%e5%88%86%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;物理层&#xA;数据链路层&#xA;网络层&#xA;传输层&#xA;会话层&#xA;表示层&#xA;应用层&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数据链路层&#34;&gt;&#xA;  数据链路层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;分层&#xA;    数据链路层分为两层&#xA;        llc上层子层                # Logical Link Control 逻辑链路控制。&#xA;        mac下层子层                # Media Access Control 介质访问控制层&#xA;&#xA;帧(frame)传输&#xA;    网络驱动程序成型帧,  网卡发送到网线上，到达目的机器，以网络驱动程序解析&#xA;协议&#xA;    以太网&#xA;    令牌环&#xA;    HDLC&#xA;    帧中继&#xA;    ISDN&#xA;    ATM&#xA;    IEEE 802.11&#xA;    FDDI&#xA;    PPP&#xA;mac&#xA;    Media Access Control&#xA;        mac帧结构&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runout.run/docs/architecture/mac.jpg&#34; alt=&#34;&amp;quot;&amp;quot;&#34; /&gt;&#xA;单位&#xA;字节&#xA;帧类型/长度（TYPE/LEN）：&#xA;该字段的值大于1500时，表示上层数据使用的协议类型。例如0x0806表示ARP请求或应答，0x0800表示IP协议。&#xA;该字段的值小于1500时表示以太网数据的长度，上层携带LLC-PDU。&#xA;帧校验FCS：&#xA;以太网采用32位CRC冗余校验。&#xA;llc&#xA;Logical Link Control&#xA;llc-pdu结构&#xA;&lt;img src=&#34;https://runout.run/docs/architecture/llc1.jpg&#34; alt=&#34;&amp;quot;&amp;quot;&#34; /&gt;&#xA;&lt;img src=&#34;https://runout.run/docs/architecture/llc2.jpg&#34; alt=&#34;&amp;quot;&amp;quot;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>媒体</title>
      <link>https://runout.run/docs/architect/strategy/meta/media/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      <guid>https://runout.run/docs/architect/strategy/meta/media/</guid>
      <description>&lt;h1 id=&#34;原理&#34;&gt;&#xA;  原理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;硬件&#34;&gt;&#xA;  硬件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a1%ac%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;CRT cathode ray tube 阴极射线管显示器&#xA;    随机扫描方式&#xA;    光栅扫描方式&#xA;    DPU distributed processing unit 分散处理单元&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;标准&#34;&gt;&#xA;  标准&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%87%e5%87%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Core Graphics System&#xA;    CGI(computer graphics interface)&#xA;        # 与设备无关的方法，方便的直接控制图形设备&#xA;    CGM(computer graphics metafile)&#xA;        # 设备无关的主义定义图形文件格式&#xA;    GKS(graphics kernal system)&#xA;        # 应用程序与图形输入输出设备之间的功能接口&#xA;    PHIGS(programmer&#39;s hierarchical interactive graphics system)&#xA;        # 为3d设计的工具库&#xA;    GL(graphics library)&#xA;        # 广泛应用的标准图形程序库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;算法&#34;&gt;&#xA;  算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基元的显示&#xA;    直线扫描转换&#xA;        DDA&#xA;        中点画线法&#xA;        Bresenham画线&#xA;    圆的扫描转换&#xA;        中点画圆&#xA;        Bresenham&#xA;    区域填充&#xA;        种子填充&#xA;        多边形扫描转换&#xA;图形变换&#xA;    二维图形变换&#xA;    二维视见变换&#xA;    三维图形变换&#xA;    投影&#xA;        平行正交&#xA;        平行斜交&#xA;        透视投影&#xA;    裁剪&#xA;        直线段裁剪算法&#xA;            Cohen-Sutherland算法&#xA;            中点分割算法&#xA;            梁友栋-Barsky算法&#xA;        多边形裁剪Sutherland-Hodgman算法&#xA;        三维图形裁剪&#xA;            梁友栋-Barsky算法&#xA;曲线和曲面&#xA;    概念&#xA;        插值&#xA;        逼近&#xA;        参数连续性&#xA;        几何连续性&#xA;        光顺(smoothness)&#xA;    Hermite插值曲线多项式 Coons曲面&#xA;    Bezier曲线和曲面&#xA;    B样条曲线和曲面&#xA;图形运算&#xA;    交点计算&#xA;    多边形表面交线计算&#xA;    平面中的凸壳算法&#xA;        Graham扫描&#xA;        Jarvis行进&#xA;    包含与重叠&#xA;        凸多边形&#xA;    多边形的三角剖分&#xA;形体的表示&#xA;    概念&#xA;        图形信息&#xA;            几何信息&#xA;            拓扑信息&#xA;        非图形信息&#xA;            颜色&#xA;            亮度&#xA;            质量&#xA;            体积&#xA;    二维&#xA;        边界&#xA;            拆线逼近曲线&#xA;                选点&#xA;                    共线性&#xA;                    三点转角阈值&#xA;                带树法&#xA;        图形的四叉树表示法&#xA;    三维&#xA;        几何元素&#xA;            点&#xA;            边&#xA;            环(有序有向边)&#xA;            面&#xA;            体&#xA;            体素&#xA;                一组单元实体: 长方体、圆柱体、圆锥体、球体&#xA;                扫描体&#xA;                代数半空间定义的形体&#xA;        线框图&#xA;            顶点表、边表、面表&#xA;            边界表示法&#xA;        实体&#xA;            CSG(constructive solid geometry), 指任意复杂形体都可用的体素组合&#xA;            特征表示&#xA;            Brep表示&#xA;        八叉树(四叉树的推广)&#xA;    分形&#xA;        规则分形&#xA;            # 严格自相似性的分形&#xA;        Von Koch算法&#xA;        Julia集和Mandelbrot集&#xA;消除隐藏线和隐藏面&#xA;    线面比较法消除隐藏线&#xA;    浮动水平线消除曲面隐藏线&#xA;    深度排序算法(优先级算法)&#xA;        画家算法(深度优先级表法)&#xA;        z一缓冲算法(深度缓冲算法)&#xA;    扫描线算法消除隐藏面&#xA;    区域分割算法消除隐藏面&#xA;    BSP(binary space partitioning)树算法判别物体可见性&#xA;    八叉树算法消除隐藏面&#xA;    光线投射算法找到可见面&#xA;        # 对包含曲面(特别球面的场景效率高)&#xA;真实感&#xA;    漫反射及光源照明&#xA;        照明效应&#xA;            漫射照明&#xA;            具体光源照明的照射效应、透射效应&#xA;                漫反射、镜面反射&#xA;        环境光&#xA;        漫反射&#xA;        镜面反射与Phong模型&#xA;        光的衰减&#xA;    多边形网的明暗处理&#xA;        常数明暗法&#xA;        亮度插值明暗法(Gouraund着色)&#xA;        法向量插值明暗法(Phong着色)&#xA;    阴影&#xA;    纹理(texture)&#xA;    整体光&#xA;        透射光亮度模拟&#xA;        Whitted光照模型(以Phong为基础)&#xA;    光线跟踪&#xA;        # 适用光滑表面&#xA;        包围盒&#xA;        空间分割成网格单元&#xA;    辐射度方法&#xA;        # 描述封闭环境中的能量交换&#xA;        # 可模拟彩色渗透现象&#xA;    色彩模型&#xA;        颜色&#xA;            色彩(Hue)&#xA;            色饱和度(Saturation)&#xA;            明度(Brightness)&#xA;        CIE(国际照明委员会)色度图(红绿蓝)&#xA;        混合系统&#xA;            面向硬件&#xA;                RGB 红绿蓝加色系统&#xA;                CMY 青、品红、黄着色系统&#xA;                    彩色印刷、胶卷等非发光显示体中采用&#xA;            面向用户&#xA;                HSV(Hue, saturation, value)&#xA;                    # 六棱锥模型&#xA;                    # 可与RGB空间互相转化&#xA;                    HLS(Hue, lightness, saturation)双六棱锥模型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;2d&#34;&gt;&#xA;  2d&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分形&#34;&gt;&#xA;  分形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    Fractal&#xA;    具有自相似性质的多个形状&#xA;        大的部分由小的部分组成，小的部分像大的部分&#xA;        用递归算法模拟&#xA;Mandelbrot Set&#xA;    介绍&#xA;        分形领域最著名的科学家 本华.曼德博&#xA;        曼德博集合常常由 z^2 + c定义&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;3d&#34;&gt;&#xA;  3d&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;术语&#34;&gt;&#xA;  术语&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%af%e8%af%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;顶点(vertexs): &#xA;图元(primitives, entity, 图素, 实体): 顶点组合为图元&#xA;片元(fragments, 片段): 图元裁剪、颜色、纹理、坐标转换等后合成片元&#xA;像素(pixels)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;硬件-1&#34;&gt;&#xA;  硬件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a1%ac%e4%bb%b6-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;cpu与gpu&#xA;    特点&#xA;        cpu串行运算，电量分配给控制器和缓存，没有太多计算单元&#xA;        97, 98年 nvidia 出品 nvidia系列显卡，并行计算。gpu控制单元少，计算单元多&#xA;    构造&#xA;        cpu通过cpu总线连接内存，cpu总线和pci总线通过主桥(北桥)连接，pci总线连接显卡&#xA;        webgl中大量控制逻辑用js编写cpu执行，交给gpu渲染。要渲染的数据从内存传入显存，再由显卡计算&#xA;            最耗时的是内存到显存之前的数据传输&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;模型&#34;&gt;&#xA;  模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;mesh模型&#xA;    无数三角形面组成的物体（可帖上纹理）。&#xA;概念&#xA;    3d模型由顶点(vertex)组成，顶点连成三角形或四边形，再组成复杂的立体模型&#xA;    网格模型&#xA;加载过程&#xA;    ajax下载文件&#xA;    解析成Mesh模型&#xA;    显示在场景中&#xA;三角形&#xA;    # 渲染效率最高&#xA;    顶点&#xA;        Vertex&#xA;    正反面&#xA;        顶点顺时针排列为正面&#xA;    法线&#xA;        Normal&#xA;        正面指向，垂直于面的矢量&#xA;        作用&#xA;            法线与入射光角度越小，该点光线越强&#xA;    顶点法线&#xA;        Vertex Normal&#xA;        过顶点的矢量&#xA;        作用&#xA;            高洛德着色(Gouraud Shading) 中计算光照和纹理效果。&#xA;            生成平滑的棱时，令顶点法线和相邻多平面法线保持等角&#xA;            生成棱时顶点法线为点所在平面的法线(可多个), 这样在面连接处形成突出的边缘。&#xA;google 3d模型库&#xA;    sketchup.google.com/3dwarehouse/&#xA;vtk&#xA;    vtk DataFile Version 3.0                # 4.0已经出来，3.0广泛使用&#xA;    vtk output                                # 一般不改变&#xA;    ASCII                                        # 使用标准ASCII码， 也可以写binary&#xA;    DATASET POLYDATA                        # 表示多边形面集，面由点组成&#xA;                                            ## POLYDATA是数据类型, 可以是STRUCTED_POINTS, STRUCTURED_GRID, UNSTRUCTURED_GRID, POLYDATA, FIELD等。POLYDATA表示三角形或四边形数据。&#xA;    POINTS 35947 float                        # 表示该模型由35947个点组成，坐标分量是浮点型&#xA;                                            ## 这行的后面是35947 * 3个float型数字。每三个数字表示一个点&#xA;    POLYGONS 69451 277804                # POLYGONS是关键字, 69451表示模型有69451个多边形&#xA;                                            ## 后面行的 3 21216 21215 20399中3表示每个多边形三个顶点。每一行是一个多边形面。21216 21215 20399表示在POINTS 35947 float段中的索引。&#xA;                                            ## 277804表示整个POLYGONS占据的数组的长度，计算公式是69451 * 4 = 277804, 乘数4是3 21216 21215 20399这组元素的长度。用于计算存储空间&#xA;    CELL_DATA 69451                        # 表示面的个数，和POLYGONS上定义的面个数一致。&#xA;    POINT_DATA 35947                        # 表示点的个数, 和POINTS中定义的点个数一致。&#xA;贴图&#xA;    立方体环境贴图(Cubic Environment Mapping)&#xA;        # 简称立方体贴图&#xA;        介绍&#xA;            一个纹理包含了包围物体场景的图像数据。x, y, z轴正负方向各一张图片，首尾相连。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;计算&#34;&gt;&#xA;  计算&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;旋转的三种工具&#xA;    矩阵&#xA;        用来与点相乘，改变点的位置&#xA;    欧拉角&#xA;        三个轴的旋转角度(Yaw[z], Pitch[y], Roll[x])来表示几何体的旋转&#xA;        欧拉角很容易转换为矩阵。使用欧拉角更形象一些&#xA;    四元组&#xA;四元组&#xA;    介绍&#xA;        表示任何一个方向上的轴，和围绕这个轴旋转的弧度&#xA;        可方便地与欧拉角和矩阵之间通过公式转换&#xA;三维投影&#xA;    三维空间中的点变为二维屏幕上的点是投影运算&#xA;        # 二维空间变到三维空间是反投影运算&#xA;        ## 如鼠标从二维到三维的反投影&#xA;三维布尔运算&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;渲染&#34;&gt;&#xA;  渲染&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b8%b2%e6%9f%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;flash&#xA;3d max&#xA;blender&#xA;ps&#xA;unity3d&#xA;wirefusion&#xA;maya&#xA;rhino&#xA;illustrator&#xA;gimp&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>程序语言原理</title>
      <link>https://runout.run/docs/pl/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      <guid>https://runout.run/docs/pl/principle/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;注意&#xA;    比较语言，共通处(抽象的元知识)是要点&#xA;    在历史上判断设计者意图     # 利于了解知道的根基&#xA;    不同规则，只在特点语言中合理      # 如0在ruby为真&#xA;历史&#xA;    EDSAC           # 1949，纸带&#xA;    FORTRAN         # 1954, 中缀表达式, 运算符优先级、结合性&#xA;    FORTH           # 1958, 没有语法，后缀表达式，语法树&#xA;    LISP            # 1958, 括号，前缀表达式，语法树&#xA;语法&#xA;    引入优先级和左右结合&#xA;    规则不冲突是困难的&#xA;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;    # c++的语法缺陷, &amp;gt;&amp;gt;是位运算，必须加空格&#xA;结构化     # 60年代&#xA;    if          # 汇编是判断再向后跳代码, if使可读性好&#xA;    while       # 可读了反复执行的if&#xA;    for         # 可读了数值渐增的while&#xA;    foreach     # 可读了集合遍历&#xA;函数&#xA;    作用&#xA;        便于理解    # 组织划分部门&#xA;        便于再利用   # 再利用无代码成本&#xA;    用了跳转命令和返回命令      # 从记录函数前后地址到函数记录返回地址&#xA;    栈记录多级调用             # 解决多级调用返回地址被覆盖问题&#xA;    递归                     # 处理嵌套数据结构时，代码的嵌套结构&#xA;错误处理&#xA;    历史&#xA;        UNIVACI         # 1950, 溢出时中断(interrupt)跳转到000&#xA;        COBOL           # 1959, 两种类型错误，用两关键字处理&#xA;        PL/I            # 1964&#xA;            先定义出错处理代码。编程时引入on语句goto到处理代码, 不检查返回值&#xA;            可定义新错误类型, 可用signal condition主动出错&#xA;        john goodenough # 1975，论文&#xA;            程序员可能忘处理异常、在不正确位置处理、处理不正确类型异常&#xA;            应该声明可能抛出的异常、将可能出错结构括起来的语句结构&#xA;        CLU             # 1975, begin ... end 后 except 错误类型, 再写错误处理语句&#xA;        C++             # 1983, 1984-1989多次讨论，try{}catch{}, throw抛异常(没用raise和signal, 因为它们已经使用了)&#xA;        Windows NT 3.1  # 1993, 使用finally&#xA;        Java            # 1995, 引入finally&#xA;        D               # 2001, 作用域守护取代finally, 写在初始化语句后面scope(exit) unlock(m)&#xA;    方式&#xA;        返回值           # 遗漏错误，可读性下降&#xA;        异常处理         # 函数多出口&#xA;            必执行代码        # 成对操作无遗漏，不使用goto执行同段代码&#xA;                finally      # java, ruby, python&#xA;                析构函数      # c++, RAII(资源获取即初始化, resource acquisition is initialization)&#xA;    何时使用异常          # 有不同的规则。缺少参数，js不抛异常。数据越界，js返回undefined, ruby返回nil&#xA;        出错立刻抛异常     # 错误优先(fail first), 早发现问题&#xA;    异常传递              # 一层层函数向上传递，都无处理时程序异常退出&#xA;        上层函数不了解下层异常细节&#xA;        不了解下层调用不能捕获全部异常     # java用检查型异常解决, 但很麻烦&#xA;取名&#xA;    编号到取名       # 对照表实现, 变量名或函数名&#xA;    实现&#xA;        整个程序共用一个对照表     # perl无声明变量, 全局作用域、全局变量&#xA;                                # 1994 javascript&#xA;            解决冲突&#xA;                更长变量名&#xA;                作用域&#xA;        动态作用域               # 1991 perl4 local变量&#xA;                                # 1958 lisp&#xA;            之前存变量原值，之后用原值覆盖变量&#xA;            中间函数调用时，变量不是原值, 要看调用前所有代码   # 全局污染&#xA;        静态作用域               # 1975 scheme，调用时建专用对照表(属于调用而非函数)，查找变量更优先。&#xA;            # 又叫字面作用域(lexical scope), 因为和字面范围一致&#xA;                                # 1991 perl5 my变量&#xA;                                # 1991 python&#xA;                                # 1994 javascript val变量&#xA;                                # 1995 ruby&#xA;        python&#xA;            内置作用域           # 语言提供，如js的全局对象作用域&#xA;            全局作用域           # 当前文件字面&#xA;            局部作用域           # 函数&#xA;        赋值即定义&#xA;            嵌套函数直接找全局作用域，不字面上找外部函数作用域        # 2.0问题, 2001年2.1修复&#xA;            不能改变外部变量                                    # 2006年3.0 nonlocal声明为外部变量&#xA;类型&#xA;    比特列标记类型，解释成不同数据&#xA;    整数&#xA;        excess-3(加三码)       # UNIVACI, 4位表示0到9&#xA;        二进制                 # 1983, 任天堂计算机8位表示整数。目前32位和64位表示整数&#xA;            八进制(3位切分), 十六进制(4位切分)&#xA;    实数&#xA;        单独记小数点左移位数        # 定点数，不好实现和计算。&#xA;            银行用加三码和定点数&#xA;        前位段表示数，后位段表示小数点位置       # 浮点数，也可表示大整数&#xA;            IEEE 754        # 有误差&#xA;                第一位符号&#xA;                中8位是指数(-127-128), 负向左移正向右移，-127代表0, 128代表无限大&#xA;                后23位是尾数，从左到右代表1/2, 1/4, 1/8...&#xA;        二-十进制码          # 用二进制表示十进制，加三码是一种，无误差&#xA;    发展&#xA;        变量名表示类型         # FORTRAN, I-N开头表示整数，其它表示浮点数&#xA;        声明类型&#xA;        隐式类型转换           # 整数+浮点数，FORTRAN出错，c都转换为浮点数, 整数除法舍弃小数&#xA;            ML(1973年)中, 整数除法用x div y, 小数除法用 x / y&#xA;            python3.0(2008年)中, 不带舍去除法用 x / y, 带舍去除法用 x // y&#xA;    用户定义类型           # c中的结构体, c++中函数成为类型，用户实现的类型称为类&#xA;        类型即功能             # 访问控制(公开、非公开)&#xA;        接口                  # 不包含实现细节的类型&#xA;        异常成为类型           # CLU和Java&#xA;        类型实现所有功能        # 未实现。类型一致，功能就成立，没有bug&#xA;            类型不能表达的：数据处理时间，处理用内存，是否可以在线程中操作等&#xA;    总称型(部分可变类型)    # 类型为参数创建类型，c++的模板，java的泛型，haskell的类型构造器&#xA;    动态类型               # 类型信息和数值看作整体, 静态类型把变量名、内存地址、内存里的内容类型作为整体&#xA;        内存中同等类型对待，其中再细分类型&#xA;        灵活，运行时确定类型，但不能执行前编译检查bug&#xA;    类型推导               # 最早OCaml和Haskell这类ML语言擅长，现Scala等语言也越来越多&#xA;        目标是证明程序没有bug&#xA;容器&#xA;    语言中用语不共通           # haskell列表是链表，不可变，元组是放不同类型的列表&#xA;    数组、链表&#xA;    字典(散列、关联数组)       # 字典散列或树实现&#xA;    树&#xA;字符串&#xA;    字符集和字符编码           # 有的认为就按效率特异化编码，有的认为应标准化&#xA;        摩斯码                # 长短组合&#xA;        博多码                # 5位一字符，先通知字符种类&#xA;        EDSAC                # 5位一字符，shift切换，内容和博多码不同。用5孔纸带&#xA;        ASCII                # 7位&#xA;            EBCDIC           # IBM，8位&#xA;        ISO-xxx              # 区域化&#xA;            魔术注释符        # 告诉语言处理器编码，特殊记号事先写明&#xA;        unicode              # 统一&#xA;    字符串&#xA;        c语言一字符8位，定义字符为ASCII或EBCDIC。字符串不知长度，nul字符终止，没nul时可能内存中越界读取&#xA;        pascal一字符8位，带长度&#xA;        java一字符16位, 定义字符为unicode&#xA;        python2 ASCII码环境下，字符当作ASCII码，可以自动转换成unicode&#xA;        python3中&amp;quot;&amp;quot;是unicode码, b&amp;quot;&amp;quot;是字节列串，要显示转换类型，否则报错&#xA;        ruby一字符8位，追加编码信息&#xA;面向对象                      # 不同语言中面向对象意义不同&#xA;                             # goto因强大让人困惑，退出历史。面向对象、Trait也有这因素&#xA;    两种立场&#xA;        c++, 类是用户自定义类型，Simula语言的继承机制是关键&#xA;        smalltalk, 类让人痛苦，不要继承，不同状态对象传消息来通信&#xA;    历史              # ALGOL产生model思想(1958年), Simula , Smalltalk, C++, Java&#xA;        类在大部分语言中不是不可或缺的&#xA;        Java: 类是部件，将其组装就是程序设计&#xA;    归集方法和建模的发展              # 围绕实现多实例问题&#xA;        强关联元素分组存放，便于理解&#xA;        module                      # 关联函数集中, 1978年Modula-2引入, python, ruby叫模块，java, perl叫包&#xA;            初始化散列, 再作为参数传入包中函数，函数修改散列&#xA;            包提供初始化函数, 返回散列, 该函数成为构造函数(java叫工厂方法)。但使用包函数都要传入散列&#xA;            bless函数(perl)绑定包和散列产生blessed hash对象，它的方法对应包方法, curry了散列做参数&#xA;            包的初始化函数自己绑定, 返回blessed hash对象&#xA;        变量和函数放入散列            # js对象&#xA;            函数放入散列                                # 函数成为一等公民(first class citizen)，可赋值给变量。FORTRAN66中字符串还不是一等公民&#xA;                                                       # first-class function的思想来自Scheme语言&#xA;            函数中通过this隐式获取自身做散列              # perl中显示获得散列&#xA;            创建构造函数，返回以上散列。但返回的散列上都定义了新的函数&#xA;            把函数单独放置在包或对象, 使用时很麻烦&#xA;            引入原型概念,对象变量查找作用域在原型链中扩展    # 这里是委托方式的原型，也可以在实例化时通过负责来实现。原型变更的处理，不同语言有差异&#xA;                                                        # prototype-based的思想来自Self语言&#xA;            定义new f()运算, 函数f的原型是以上散列，多个new的新对象共享了散列的函数&#xA;                新对象原型指向函数f的原型&#xA;                以新对象为this,执行f&#xA;        闭包(closure)                # 维持内部作用域状态的函数, 作用域呈封闭状态&#xA;        类&#xA;            分类/分组                 # 1965年ALGOL提出&#xA;            用户定义类型              # 1979年c++, 参考Simula&#xA;                最初c语言结构体&#xA;                声明和定义类方法       # Smalltalk方法调用是传送消息，调未定义方法是否出错由该类决定&#xA;                作用                  # 成为一种模具&#xA;                    生成器            # module和散列只有该作用&#xA;                    可行操作的功能说明(类型、泛型)&#xA;                    代码再利用的单位(继承)&#xA;        继承&#xA;            实现策略&#xA;                父类实现一般化, 子类是父类的专门化&#xA;                共享部分提取           # 子类不是父类的一种, 函数思想考虑问题&#xA;                差异实现               # 覆盖变更部分，为了再利用使实现更轻松，不倾向使用&#xA;            问题&#xA;                多层级问题&#xA;                    向上不好找方法定义&#xA;                    修改方法时，向下影响子类    # 如动态作用域问题&#xA;                里氏替换原则               # 1987年提出，对父类成立的条件，一定对子类成立。为了维护父子关系间的一致性，继承是is-a关系&#xA;                    实际编程中，子类功能增加常打破里氏替换原则，无论是在开始设计上避免还是在开发中放弃继承都很麻烦&#xA;            多重继承                      # 东西常常不属于一个分类,java禁止多重继承&#xA;                问题&#xA;                    多父类成员名冲突&#xA;                        委托(delegation)  # 聚合(aggregation)，咨询(consultation), 不用多重继承，把原父类对象作为子类成员,后发展出依赖注入&#xA;                        接口多重继承       # Java引入，php5(2004年)引入&#xA;                        按顺序搜索&#xA;                            深度优先               # python2.1, 菱形继承中，第一层父类的值会覆盖第二层右边父类的值&#xA;                            C3线性化               # 1996年提出，python2.3, perl6默认, 对类编号，子类先于父类检查, 优先检查先书写的类&#xA;                            混入式处理(mix-in)     # 扁平成新类, 该类不能创建实例，python XxxMixIn类， ruby类单一继承，模块混入&#xA;                            Trait                 # 2002年Trait论文，Squeak最早引入, scala, perl6的Roll, php5.4, ruby2.0的mix method&#xA;                                类作用：创建实例(要求全面, 大的类),再利用单元(小的类)冲突&#xA;                                把再利用单元特别化&#xA;                                    ruby模块混入名称冲突时, 使用最后的模块, Trait会报错    # Smalltalk的Squeak处理器可取方法别名，可指定不参与冲突&#xA;                                    scala声明创建实例需要的方法, 另一Trait声明提供的方法，组合匹配后可创建实例&#xA;                                    对Trait改写定义新的Trait(继承), Trait组合成新Trait&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;原理&#34;&gt;&#xA;  原理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;gc&#xA;    # garbage collector&#xA;    为什么gc&#xA;        减少编程工作量&#xA;        减少内存泄露&#xA;        安全性&#xA;    定位&#xA;        引用计数器(reference counting, java1.1废弃)   # 给每个对象设置计数器，有引用+1, 失效-1&#xA;            不能解决循环引用问题  # A, B互相引用不回收&#xA;            计数器修改开销大&#xA;        根搜索算法(使用)   # 从GC Roots对象起点，向下搜索，路径成为Reference Chain, 不可达对象不可用&#xA;            GC Roots包括&#xA;                虚拟机栈(栈帧中本地变量表)中的引用对象&#xA;                方法区域中的类静态引用对象&#xA;                方法区域中常量引用对象&#xA;                本地方法栈JNI(native方法)引用的对象&#xA;    回收算法&#xA;        标记-清除(mark-sweep)   # DVM(Dalvik Virtual Machine, 安卓用)使用的算法&#xA;            # 效率不高，清除后产生大量不连续空间&#xA;            标记所有要回收的对象&#xA;            清除标记对象&#xA;        复制(copying)&#xA;            # 实现简单，效率高。内存利用率不高&#xA;            # 用于新生代，两块比例8:1&#xA;            内存分成相等两块，使用其中一块&#xA;            回收时，存活对象复制到另一块，这块整个清理掉&#xA;        标记-整理(mark-compact)&#xA;            # 适合老年代&#xA;            把存活对象往内存一端移动&#xA;            回收边界外内存&#xA;        分代收集(generational collection)&#xA;            新生代用复制算法&#xA;            老年代用标记-整理算法&#xA;    4种引用类型回收   # java强引用、软引用、弱引用、虚引用&#xA;    方法区回收&#xA;        废弃的常量   # 看引用计数&#xA;        无用的类&#xA;            实例都已经回收&#xA;            加载该类的ClassLoader已回收&#xA;            该类的class对象没有被引用，无法反射该类的方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;异步编程&#34;&gt;&#xA;  异步编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;事件  # 高阶函数的优势&#xA;    解耦业务逻辑&#xA;问题&#xA;    异常处理    # 不能同步catch&#xA;    回调嵌套过深&#xA;    单线程模型中，业务处理阻塞全局&#xA;    异步转同步&#xA;实现&#xA;    事件发布订阅&#xA;        回调函数事件化(钩子机制)&#xA;    cps: continuation-passing style&#xA;        在函数式编程中, 多传一个参数k明确控制continuation&#xA;    promise/deferred        # promise/A, promise/B, promise/D模型&#xA;        # promise在外部暴露接口(可变部分), deferred在内部维护状态(不可变部分)&#xA;        状态&#xA;            未完成，完成，失败&#xA;            方向只能未完成-&amp;gt;完成, 未完成-&amp;gt;失败&#xA;            状态转化不能更改&#xA;        api&#xA;            then()&#xA;            done()&#xA;            all()     # 所有成功成功，一失败失败&#xA;            any()&#xA;    流程控制库&#xA;        尾触发     # 传next()函数&#xA;        async库(node.js)&#xA;            series()        # 串行&#xA;            parallel()      # 并行&#xA;            waterfall()     # 串行传结果&#xA;            auto()          # 计算依赖顺序执行&#xA;        bagpipe库(node.js)   # 限制并发, 任务可排队或拒绝, 超时控制&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;编译&#34;&gt;&#xA;  编译&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%af%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 流程&#xA;    词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成，表格管理，错误处理&#xA;    语义分析 -&amp;gt; 类型检查/推导 -&amp;gt; 代码优化 -&amp;gt; 机器码生成&#xA;            # 中间数据结构, 比如AST&#xA;    预处理，连接程序，装入程序，调试程序&#xA;&#xA;# 文法&#xA;    G = (Vn, Vt, S, P)&#xA;            # 终极符号, 非终级符号, 一个特殊非终级符号，产生式&#xA;    类型&#xA;            短语(0), 对应图灵机(TM)&#xA;            上下文相关(1), 对应线性有界自动机(LBA)&#xA;            上下文无关(2), 对应下推自动机(PDA)&#xA;            线性文法、正则文法、正规文法，对应有限自动机(FA)&#xA;                    # 无法控制自返数&#xA;# 状态机(FA)&#xA;    确定状态机(DFA)&#xA;    非确定状态机(NFA)&#xA;            # 同状态可多种转移&#xA;    DFA与NFA互相转换&#xA;# 词法分析&#xA;    状态转换矩阵法&#xA;# 语法分析&#xA;    # 源代码读入、解析成语法树&#xA;    自顶向下&#xA;            # 最左推导建立语法树&#xA;            # first集，follow集，predict集&#xA;            不回溯方法&#xA;            递归下降&#xA;            LL(1)&#xA;                    # 从左输入符号、产生左推导、每次读一个字符。LL(k)特例&#xA;    自底向上&#xA;            # 从左读, 从右向前归约&#xA;            简单优先关系&#xA;                    # 运算符优先关系矩阵&#xA;            LR(k)&#xA;                    # 从左输入，最右推导&#xA;                    LR(0)&#xA;                            # 只看栈顶状态，有分析动作冲突&#xA;                    SLR(1)&#xA;                            # LR(0)加向前看展望符，不能分析所有文法&#xA;                    LR(1)&#xA;                            # LR(0)的每个推导加一个向前搜索符，状态太多&#xA;                    LALR(1)&#xA;                            # LR(1)中同向前搜索符的状态合并&#xA;# 语义分析&#xA;    抽象语法树&#xA;    符号表&#xA;            # 动态规划记录变量的综合信息&#xA;    局部化处理&#xA;            # 压栈变量作用域&#xA;# 中间代码生成&#xA;    后缀式(逆波兰式)&#xA;    三地址&#xA;            # 操作符两变量地址，结果地址&#xA;    四元式操作符&#xA;            # 地址加，赋值，过程调用，类型转换，算术、逻辑、关系运算的存储&#xA;    语法制导&#xA;            # 中间代码产生式后拼上语义程序，在语法分析中遇到动作马上处理&#xA;    类型检查&#xA;    下标变量&#xA;            # 如数组下标，同上全用四元式表示&#xA;# 中间代码优化&#xA;    常量表达式&#xA;            a = 1, b = 2, c = a + b, 则只记c = 3&#xA;    公共表达式&#xA;            a = b * c, d = b * c, 则只记a&#xA;    循环不变式外提&#xA;            while k &amp;lt; 0 do b * c, 则b * c外提只计算一次&#xA;    基本块&#xA;            # 一块语句要么全执行，要么全不执行&#xA;    消减运算强度&#xA;            如加法代替乘法&#xA;    复写传播&#xA;            a = b, 后a, b不再变值，用a替代b&#xA;    无用代码消除&#xA;    数学优化（恒等变换）&#xA;            如a + 0 = a, a * 1 = a, a ^ 2 = a * a, a / 1 = a, 0 / a = 0&#xA;    窥孔优化&#xA;            对目标代码中短指令序列局部改进，如删除重复，控制流优化，代数化简，使用特殊指令等&#xA;    全局优化&#xA;            对整个程序控制流和数据分析再优化，如常量表达式全局优化&#xA;# 运行时时空管理&#xA;    内存划分&#xA;            存储&#xA;                    引用的库的代码&#xA;                    目标代码&#xA;                    静态变量&#xA;                    栈区&#xA;                            # 函数调用，中断现场&#xA;                    堆区&#xA;            存储策略&#xA;                    静态分配&#xA;                            #编译时分配固定存储单元&#xA;                    动态分配&#xA;                            栈&#xA;                            堆&#xA;            活动记录&#xA;                    保存局部变量，中间结果，临时变量，过程调用，控制信息等&#xA;                    专用寄存器&#xA;                    调用链&#xA;                            # 保存下一个调用的起始地址&#xA;                    动态链&#xA;                            # 保存前一个调用的起始地址&#xA;            访问环境&#xA;                    # 记录闭包起始地址&#xA;                    display表&#xA;                            # 过程需要的所有非局部数据所在的过程活动记录的起始地址&#xA;                    全局display表&#xA;                    静态链&#xA;                            # 指向外层过程的活动记录的地址地址&#xA;# 目标代码生成&#xA;    生成的语言&#xA;            机器语言&#xA;            可重定位的机器语言&#xA;                    # 由连接器装配后生成机器语言&#xA;                    # 多数用这种，如c语言&#xA;            汇编语言&#xA;    指令选择&#xA;    虚拟机&#xA;    寄存器分配&#xA;    四元式翻译&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>企业级系统</title>
      <link>https://runout.run/docs/tool/product/enterprise_system/</link>
      <pubDate>Wed, 10 Oct 2018 14:51:24 +0800</pubDate>
      <guid>https://runout.run/docs/tool/product/enterprise_system/</guid>
      <description>&lt;h1 id=&#34;erp&#34;&gt;&#xA;  ERP&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#erp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Enterprise Resources Planning, 企业资源计划&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cms&#34;&gt;&#xA;  CMS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cms&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Content Management System&#xA;grav&#xA;    # 开源cms&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;wordpress&#34;&gt;&#xA;  wordpress&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#wordpress&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# php&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dedecms&#34;&gt;&#xA;  dedecms&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dedecms&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 织梦cms, SEO优化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;帝国cms&#34;&gt;&#xA;  帝国cms&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%9d%e5%9b%bdcms&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# SEO优化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;phpcms&#34;&gt;&#xA;  phpcms&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#phpcms&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;phpwind&#34;&gt;&#xA;  phpwind&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#phpwind&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 开源, 社区管理系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;drupal&#34;&gt;&#xA;  drupal&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#drupal&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 开源, cms&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;工作流&#34;&gt;&#xA;  工作流&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e4%bd%9c%e6%b5%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;activiti&#xA;    # 5,6已暂停维护，7叫作Activiti Cloud BPM&#xA;flowable&#xA;    # activiti继任&#xA;YAML&#xA;    # 工作流&#xA;bossa&#xA;    # 工作流引擎&#xA;azkaban&#xA;    # 开源oa&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jbpm&#34;&gt;&#xA;  JBPM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jbpm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 常识&#xA;    适用对象：业务逻辑不复杂，业务流程会变化&#xA;        # s2sh适合业务逻辑复杂，但是业务流程不会变化的项目&#xA;    jbpm封装hibernate&#xA;    包含对象&#xA;        模型&#xA;        实例（由活动组成，包括活动、箭头等）&#xA;        任务（需要人办理的活动）&#xA;&#xA;&#xA;# 使用&#xA;    myeclipse添加jbpm xml画图插件&#xA;        MyEclipse -&amp;gt; MyEclipse Configuration Center -&amp;gt; Software -&amp;gt; Browse Software(add site) -&amp;gt; add from archive file找到jbpm-gpd-site.zip,取名为jbpm4.4 -&amp;gt; Browse Software(Personal Sites -&amp;gt; jbpm4.4下8个选项)右键add to Profile -&amp;gt; 右下角apply changes -&amp;gt; 重启myeclipse -&amp;gt; 新建文件中找到新建jbpm xml文件&#xA;        画图&#xA;            test.jpdl.xml文件用jbpm工具打开&#xA;            打开Properties视图&#xA;    配置&#xA;        jbpm.hibernate.cfg.xml                # mysql方言要配置InnoDB的方言（因为jbpm建表时对表指定了type=InnoDB约束）&#xA;        配置hibernate的5个映射文件（导入的jbpm.jar包中有）&#xA;            &amp;lt;mapping resource=&amp;quot;jbpm.repository.hbm.xml&amp;quot; /&amp;gt;&#xA;            &amp;lt;mapping resource=&amp;quot;jbpm.execution.hbm.xml&amp;quot; /&amp;gt;&#xA;            &amp;lt;mapping resource=&amp;quot;jbpm.history.hbm.xml&amp;quot; /&amp;gt;&#xA;            &amp;lt;mapping resource=&amp;quot;jbpm.task.hbm.xml&amp;quot; /&amp;gt;&#xA;            &amp;lt;mapping resource=&amp;quot;jbpm.identity.hbm.xml&amp;quot; /&amp;gt;&#xA;        jbpm.cfg.xml:&#xA;&#xA;    api&#xA;        hibernate的api:org.hibernate.cfg.Configuration()&#xA;            .configure(&amp;quot;jbpm.hibernate.cfg.xml&amp;quot;).buildSessionFactory();进行hibernate配置文件加载测试&#xA;        delete_deployment       # 有实例时不能删除&#xA;                                # 级联删除时出现constraintViolationException的原因：&#xA;                                ## jbpm4.4下载包中/install/src/db/create/下有创建jbpm各个数据库时用到的sql文件&#xA;                                ##　如果是mysql数据库，其中表有type=InnoDB约束。该约束的方言类为hibernate-core.jar包下/org.hibernate.dialect.MySQLInnoDBDialect的类文件&#xA;                                ## ，在hibernate的配置文件中配置该方言就可以解决问题&#xA;# 表结构&#xA;    表&#xA;        模型&#xA;            jbpm4_deployment&#xA;            jbpm4_lob&#xA;            jbpm4_deployprop&#xA;        实例&#xA;            jbpm4_execution&#xA;            jbpm4_hist_procinst&#xA;            jbpm4_task&#xA;            jbpm4_hist_task&#xA;        活动&#xA;            jbpm4_hist_actinst&#xA;        变量&#xA;            jbpm4_variable&#xA;&#xA;    id关联&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;规则引擎brms&#34;&gt;&#xA;  规则引擎(BRMS)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%84%e5%88%99%e5%bc%95%e6%93%8ebrms&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    组成&#xA;        知识库(Knowledge base)&#xA;        既定事实(Fact base)&#xA;        推理机(Rule Engine)&#xA;&#xA;Drools&#xA;    # JBoss开发, 基于RETE算法&#xA;OpenRules&#xA;OpenLexicon&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;mes&#34;&gt;&#xA;  MES&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mes&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Manufacturing Execution System&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;itsm&#34;&gt;&#xA;  ITSM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#itsm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# IT service management&#xA;sap&#xA;salesforce&#xA;servicenow&#xA;workday&#xA;    # hr平台&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;gis&#34;&gt;&#xA;  GIS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ide&#xA;    skylive&#xA;    arcGIS&#xA;    mapInfo&#xA;    mapGIS&#xA;    superMap&#xA;webglobe&#xA;arcpy&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;mes-1&#34;&gt;&#xA;  MES&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mes-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# manufacturing execution system, 制造生产过程执行系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;wms&#34;&gt;&#xA;  WMS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#wms&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# warehouse management system, 仓库管理系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;oms&#34;&gt;&#xA;  OMS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#oms&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 订单管理系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;tms&#34;&gt;&#xA;  TMS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tms&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 物流管理系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;cmp&#34;&gt;&#xA;  CMP&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cmp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# campaign management platform, 营销活动管理平台&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;商城&#34;&gt;&#xA;  商城&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%95%86%e5%9f%8e&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;nopCommerce&#xA;    # .net开源电商&#xA;ecshop&#xA;    # 开源, 商城系统, 微信商城&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hrp&#34;&gt;&#xA;  HRP&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hrp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Hospital Resource Planning, 医院资源规划&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>前端</title>
      <link>https://runout.run/docs/architect/project/frontend/</link>
      <pubDate>Wed, 10 Oct 2018 14:51:24 +0800</pubDate>
      <guid>https://runout.run/docs/architect/project/frontend/</guid>
      <description>&lt;h1 id=&#34;组件化layout&#34;&gt;&#xA;  组件化Layout&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e4%bb%b6%e5%8c%96layout&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;layout service&#xA;&#x9;# 缓存layout到redis&#xA;&#x9;crud layout功能&#xA;layout对象&#xA;&#x9;index&#xA;&#x9;&#x9;# 缩略信息&#xA;&#x9;plugins&#xA;&#x9;&#x9;components&#xA;&#x9;&#x9;&#x9;table&#xA;&#x9;&#x9;layout&#xA;&#x9;&#x9;&#x9;# 组合方式&#xA;&#x9;&#x9;&#x9;水平，垂直，tab&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>项目规划</title>
      <link>https://runout.run/docs/architect/method/project_plan/</link>
      <pubDate>Wed, 10 Oct 2018 14:51:24 +0800</pubDate>
      <guid>https://runout.run/docs/architect/method/project_plan/</guid>
      <description>&lt;h1 id=&#34;平台服务&#34;&gt;&#xA;  平台服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b3%e5%8f%b0%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;apaas&#34;&gt;&#xA;  aPaaS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#apaas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# platform as a service，介于IaaS和SaaS中间&#xA;将软件研发的平台做为服务，以SaaS的模式交付&#xA;组件化支撑和驱动&#xA;    # 组件的发展决定paas广度，组件的聚合决定paas深度&#xA;    # 对内固守组件边界，对外暴露标准接口&#xA;分层&#xA;    平台组件&#xA;    基础业务    # 不可见，影响全局，通用业务逻辑，对性能很敏感&#xA;    业务&#xA;组件&#xA;    设计&#xA;        # 自描述的，这样就在设计和开发上解耦&#xA;        确定边界&#xA;        定义标准接口&#xA;        确定核心功能&#xA;        规范异常处理&#xA;    开发&#xA;        # 像开发dsl一样,来评判核心逻辑和接口，抽象度高&#xA;        技术评审&#xA;        定义接口&#xA;            # 面向接口开发，也称为BDD&#xA;            dubbo、grpc等&#xA;            restful&#xA;        接口设计&#xA;            标准化&#xA;            说明&#xA;            服务路由&#xA;            版本管理&#xA;            授权管理&#xA;核心理念&#xA;    # 体现在 服务、工具、模型、规范&#xA;    开放 而非 封闭&#xA;    合作 而非 限制&#xA;    共享 而非 替代&#xA;重点关注&#xA;    基础业务&#xA;        组织架构和用户组&#xA;        审批流&#xA;        权限&#xA;    通用模型&#xA;        透明分布式缓存模型&#xA;        分布式存储模型&#xA;        分布式事务模型&#xA;    效率工具&#xA;        数据迁移工具&#xA;        缓存配置工具&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;saas&#34;&gt;&#xA;  SaaS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#saas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;aws线上云&#xA;微服务 + gRPC + k8s + Istio&#xA;Golang + TypeScript + Python&#xA;TiDB&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;行为分析&#34;&gt;&#xA;  行为分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%8c%e4%b8%ba%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;埋点&#34;&gt;&#xA;  埋点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%8b%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;架构&#xA;    数据采集&#xA;        客户端采集&#xA;        服务器采集&#xA;        业务系统&#xA;        第三方渠道&#xA;    数据治理&#xA;        ETL&#xA;        实时ID mapping&#xA;        元数据管理&#xA;        数据质量管理: 数据校验, 实时导入监控，异常报警，debug数据查询，用户关联校验，数据质量看板&#xA;    数据仓库&#xA;        数据模型：Event, User, Item内容&#xA;        实时导入系统&#xA;        存储引擎、查询引擎&#xA;    数据智能&#xA;        特征工程&#xA;        特征选择&#xA;        模型训练: 深度学习, 自然语言处理，时序预测，GBDT/LR, AutoML&#xA;        模型可视化&#xA;        在线服务&#xA;工具&#xA;    采集: SDK(JS, Android, iOS, 小程序，服务端，全埋点), ID Mapping, 归因链路&#xA;    实施工具: 事件管理，变量管理，命名工具，埋点SLA配置, 预警配置，session管理，生命周期管理，tag管理，测试工具，ABTest工具&#xA;    分析工具: 事件分析，漏斗分析，分布分析，留存分析，数据看板，热图分析，归因分析，自定义SQL查询, API管理，广告和活动效果监测&#xA;实现方式&#xA;    代码埋点&#xA;    全埋点、可视化全埋点（圈选）&#xA;规范&#xA;    结构与命名清晰&#xA;    方便历史版本对比&#xA;    每个埋点数据质量负责到人（开发、测试、数据负责人）&#xA;    数据统一管理&#xA;    尽量用工具自动化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;企业中台&#34;&gt;&#xA;  企业中台&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%81%e4%b8%9a%e4%b8%ad%e5%8f%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据&#xA;  租户&#xA;  用户&#xA;micro service&#xA;  每个service监控&#xA;  每个service不单点&#xA;  单功能拆分，边界明确&#xA;  service间只依赖sdk(好莱坞法则)，通过服务总线发现&#xA;  servcie无状态接入&#xA;  分类&#xA;    内部服务 internal&#xA;      # 内外服务用互相转化&#xA;      文件上传&#xA;      图像处理&#xA;      数据挖掘&#xA;      报表&#xA;    外部服务 external&#xA;      # 流控、质量监控、多链路备用、降级方案&#xA;      邮件&#xA;      短信&#xA;      推送&#xA;      cti&#xA;      企业信息校验&#xA;    业务服务 transaction&#xA;      审批流&#xA;      工作流&#xA;      登录&#xA;      海&#xA;    核心服务 core&#xA;      租户id服务&#xA;      检索服务&#xA;      报表服务&#xA;      监控服务&#xA;      k8s&#xA;      服务总线&#xA;    支持服务 supportive&#xA;      文档&#xA;      测试环境&#xA;      沙盒同步&#xA;    插件服务 plugin&#xA;    集成服务 integration&#xA;    事务服务&#xA;      finance&#xA;      CPQ&#xA;      ERP&#xA;    saas基础&#xA;      计费&#xA;      用户管理&#xA;    联动&#xA;      导入企业数据&#xA;      调用aws或aliyun，提供webhook&#xA;  服务的sdk&#xA;    多语言sdk&#xA;    降级&#xA;    ha&#xA;    apm&#xA;  服务监控&#xA;    # 用于发现问题、追查事故、评估缩容或扩容、评估降级&#xA;    日志&#xA;    接口&#xA;      # 调用服务提供的监控接口&#xA;    系统&#xA;      # 容器提供&#xA;    apm&#xA;      # 客户端采样&#xA;    可达性&#xA;      # 由通用监控完成&#xA;  工程&#xA;    打包docker镜像&#xA;  服务升级&#xA;    灰度发布与AB test&#xA;    提供api版本接口供客户端查询&#xA;  服务总线&#xA;    管理服务状态、位置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;本地生活&#34;&gt;&#xA;  本地生活&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%ac%e5%9c%b0%e7%94%9f%e6%b4%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/outrunJ/logseq/blob/main/jncloud/pages/%E5%AE%9E%E4%BD%93%E8%A7%86%E5%9B%BE.md&#34;&gt;服务与功能&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Haskell</title>
      <link>https://runout.run/docs/pl/haskell/</link>
      <pubDate>Tue, 09 Oct 2018 16:54:16 +0800</pubDate>
      <guid>https://runout.run/docs/pl/haskell/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;源于ML&#xA;标准化的、纯函数式编程语言&#xA;非限定性语义和强静态类型&#xA;作为其他语言设计新功能时的样板，如Python的lambda标记语句&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;检索函数用http://www.Haskell.org/hoogle&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;单词&#34;&gt;&#xA;  单词&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e8%af%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;polymorphism&#xA;    # 多态&#xA;monomorphic&#xA;    # 单态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;风格&#34;&gt;&#xA;  风格&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a3%8e%e6%a0%bc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;point free style&#xA;    sum&#39; xs = foldl (+) 0 xs&#xA;    sum&#39; = foldl (+) 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;注意&#34;&gt;&#xA;  注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用缩进代替括号，但也可用括号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;文件扩展名&#34;&gt;&#xA;  文件扩展名&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e6%89%a9%e5%b1%95%e5%90%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 文件中不用let定义变量, &#xA;# 变量赋值两次会报错, 这意味着代码顺序不重要&#xA;hs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内置变量&#34;&gt;&#xA;  内置变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;pi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模块&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:m Data.Char Data.Map&#xA;    # 加载模块&#xA;    chr&#xA;        # chr :: Int -&amp;gt; Char&#xA;    ord&#xA;        # ord :: Char -&amp;gt; Int&#xA;    toUpper&#xA;    toLower&#xA;import Data.Char&#xA;    # 导入到全局命名空间&#xA;    import Data.List (nub, sort)&#xA;    import Data.List hiding (nub)&#xA;    import qualified Data.Map as M&#xA;        # 这样其中命名冲突的filter, null函数，只能用Data.Map.filter或M.filter方式调用&#xA;可用模块&#xA;    prelude&#xA;        # 默认载入的模块&#xA;    Data&#xA;        Char&#xA;        List&#xA;        Map&#xA;        Set&#xA;自定义模块&#xA;module Geometry.Sphere&#xA;(sphereVolume&#xA;, sphereArea&#xA;, Shape(..)&#xA;    # 导出类型和其所有构造子&#xA;) where&#xA;sphereVolum :: Float -&amp;gt; Float&#xA;sphereVolum radius = (4.0 / 3.0) * pi * (radius ^ 3)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令函数&#34;&gt;&#xA;  命令函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:load&#xA;    # 加载模块&#xA;    :load a.hs&#xA;:l&#xA;:cd&#xA;    # 切换工作目录&#xA;    :cd c:\a&#xA;:reload&#xA;    # 重载所有模块&#xA;:r&#xA;:type&#xA;    :type &#39;H&#39;&#xA;:t&#xA;:info&#xA;    # 查看一个typeclass有哪些instance和subclass&#xA;    # 类型的信息、函数的类型声明&#xA;:k&#xA;    # 查看kind&#xA;    :k Int&#xA;        # Int :: *&#xA;    :k Maybe&#xA;        # Maybe :: * -&amp;gt; *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;操作符&#34;&gt;&#xA;  操作符&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;%&#xA;    # 分号&#xA;&amp;amp;&amp;amp;&#xA;||&#xA;++    &#xA;    # 字符串拼接&#xA;/=&#xA;    # 不等&#xA;do&#xA;    # 动作的combine, do 是&amp;gt;&amp;gt;=的语法糖, 用来连接一系列动作&#xA;&amp;lt;-&#xA;    # name &amp;lt;- getLine, 存到变量&#xA;    # 除了程序的最后一行用来作返回值，其它语句都可以用 &amp;lt;-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;表达式&#34;&gt;&#xA;  表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 表达式可以随处安放&#xA;if x &amp;lt; 0 then&#xA;    -1&#xA;else if x &amp;gt; 0 then&#xA;    1&#xA;else&#xA;    0&#xA;&#xA;case x of&#xA;    0 -&amp;gt; 1&#xA;    1 -&amp;gt; 5&#xA;    _ -&amp;gt; (-1)&#xA;&#xA;let a = 1&#xA;    # 局部绑定, in可省略则定义到全局&#xA;    twice_a = 2 * a&#xA;in (a + twice_a, a - twice_a)&#xA;    &#xA;let boot x  y z = x * y + z in boot 3 4 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;io-action&#34;&gt;&#xA;  I/O action&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#io-action&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 在main中 I/O action才被执行&#xA;# return () 语句产生I/O action, do接着执行&#xA;# 执行后会打印结果，结果为()时不打印&#xA;main = do&#xA;    _ &amp;lt;- putStrLn &amp;quot;a&amp;quot;&#xA;    name &amp;lt;- getLine&#xA;    putStrLn (name)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;类型表示&#34;&gt;&#xA;  类型表示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b%e8%a1%a8%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Eq a =&amp;gt; a -&amp;gt; a -&amp;gt; Bool&#xA;    # =&amp;gt; 前面是类型约束, 后面表示传入两个同类型参数，返回Bool类型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;变量&#34;&gt;&#xA;  变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;let pi = 3.14&#xA;    # 变量不可变，但可重复定义&#xA;(-1)&#xA;    # 负数一般加小括号&#xA;  let r = 25 :: Double&#xA;    # 默认猜测是Integer&#xA;    # monomorphish restriction(单一同态限定)原理，可以指定polymorphic(多态)&#xA;    ## let r = 25 :: Num a =&amp;gt; a&#xA;True, False&#xA;    # 类型为 Bool&#xA;&amp;quot;abc&amp;quot;&#xA;    # 类型为[char], 与&#39;a&#39;:&#39;b&#39;:&#39;c&#39;:[]&#xA;    a = &amp;quot;aaa&amp;quot; :: String&#xA;        # 得到一个String, 与[char]同样使用&#xA;LT, GT, EQ&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 函数名与参数，参数与参数之间有空格隔开&#xA;# 函数比运算符先结合&#xA;let area r = pi * r ^ 2&#xA;    # 定义函数, &#xA;area 2&#xA;area (-2)&#xA;let area2 r = area r&#xA;let first (x, y) = x&#xA;    # 接收元组&#xA;uppercase, lowercase :: String -&amp;gt; String&#xA;    # 指定函数类型&#xA;分段定义&#xA;    # 编译成case语句&#xA;    f 0 = 1&#xA;    f 1 = 5&#xA;    f _ = -1&#xA;函数合成调用&#xA;    square (f 1)&#xA;    (square . f) 1&#xA;(\xs -&amp;gt; length xs &amp;gt; 15)&#xA;    # lambda表达式&#xA;    # lambda可以用模式匹配，但使用不了多个模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;列表&#34;&gt;&#xA;  列表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%97%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 列表，类型必须相同。&#xA;# 列表都由[]追加得到，逗号是语法糖&#xA;let n = [1, 2]&#xA;[1..20]&#xA;    # range浮点数不精确&#xA;take 20 [1,2..]&#xA;[2,4..20]&#xA;[&#39;a&#39;..&#39;z&#39;]&#xA;0:n&#xA;    # 得到追加列表[0, 1, 2]， 头部追加叫作consing, cons是constructor&#xA;    # -1:0:n&#xA;[[1], [2]]&#xA;n !! 1&#xA;    # 取元素&#xA;l1 &amp;gt; l2&#xA;    # 元素依次比较&#xA;[x*2 | x &amp;lt;- [1..10], x*2 &amp;gt;= 12]&#xA;    # list comprehension&#xA;    boomBangs xs = [if x &amp;lt; 10 then &amp;quot;BOOM!&amp;quot; else &amp;quot;BANG!&amp;quot; | x &amp;lt;-xs, odd x]&#xA;    [x*y | x &amp;lt;-[1,2], y &amp;lt;-[3,4]]&#xA;        # 聚合得[3,4,6,8]&#xA;    length&#39; xs = sum [1 | _ &amp;lt;- xs]&#xA;&#xA;    xxs = [[1,2], [3,4]]&#xA;    [[x | x &amp;lt;- xs, even x] | xs &amp;lt;- xxs]&#xA;&#xA;    [(a,b,c) | c &amp;lt;- [1..10], b &amp;lt;- [1..c], a &amp;lt;- [1..b], a^2 + b^2 = c ^2]&#xA;&#xA;    [a + b | (a,b) &amp;lt;- xs]&#xA;        # list comprehension中的模式匹配&#xA;模式匹配&#xA;    x:xs&#xA;    x:y:z:xs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;元组&#34;&gt;&#xA;  元组&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%83%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 类型可不同，不能单元素。2元组叫pairs, 3元组叫triples, n元组叫n-tuple&#xA;# 元组不可变&#xA;# 元组的类型由长度和其中的类型决定, (&amp;quot;a&amp;quot;, 1)与(1, &amp;quot;a&amp;quot;)是不同的类型，所以[(&amp;quot;a&amp;quot;, 1), (2, &amp;quot;b&amp;quot;)]是错误的&#xA;(True, 1)&#xA;((1,2), True)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;monad&#34;&gt;&#xA;  monad&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#monad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; do&#xA;doGuessing num = do&#xA;    putStrLn &amp;quot;Enter your guess:&amp;quot;&#xA;    guess &amp;lt;- getLine&#xA;    if (read guess) &amp;lt; num&#xA;    then do putStrLn &amp;quot;Too low&amp;quot;&#xA;        doGuessing num&#xA;    else if (read guess) &amp;gt; num&#xA;    then do putStrLn &amp;quot;Too high&amp;quot;&#xA;        doGuessing num&#xA;    else putStrLn &amp;quot;You Win&amp;quot;&#xA;        # 只有一个动作时，可省略do&#xA;&#xA;o-&amp;gt; do&#xA;doGuessing num = do&#xA;    putStrLn &amp;quot;Enter your guess:&amp;quot;&#xA;    guess &amp;lt;- getLine&#xA;    case compare (read guess) num of&#xA;        LT -&amp;gt; do putStrLn &amp;quot;Too low&amp;quot;&#xA;        GT -&amp;gt; do putStrLn &amp;quot;Too high&amp;quot;&#xA;        EQ -&amp;gt; putStrLn &amp;quot;You Win&amp;quot;&#xA;&#xA;o-&amp;gt; functor applicative monad&#xA;class Functor f where&#xA;fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;class Functor f =&amp;gt; Applicative f where&#xA;pure :: a -&amp;gt; f a&#xA;() :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;class Applicative m =&amp;gt; Monad m where&#xA;return :: a -&amp;gt; m a&#xA;(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&#xA;(&amp;gt;&amp;gt;) :: m a -&amp;gt; m b -&amp;gt; m b&#xA;x &amp;gt;&amp;gt; y = x &amp;gt;&amp;gt;= \_ -&amp;gt; y&#xA;fail :: String -&amp;gt; m a&#xA;fail msg = error msg&#xA;instance Functor Maybe where&#xA;fmap func (Just x) = Just (func x)&#xA;fmap func Nothing  = Nothing&#xA;instance Applicative Maybe where&#xA;pure = Just&#xA;Nothing  _ = Nothing&#xA;(Just func)  something = fmap func something&#xA;instance Monad Maybe where&#xA;return = Just&#xA;Nothing &amp;gt;&amp;gt;= func = Nothing&#xA;Just x &amp;gt;&amp;gt;= func  = func x&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内置函数&#34;&gt;&#xA;  内置函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;prelude&#xA;    $&#xA;        # 函数调用符，优先级最低。而空格是最高优先级&#xA;        # $右结合。而空格左结合&#xA;        # 等价于在右而写一对括号&#xA;    .&#xA;        # f . g = \x -&amp;gt; f (g x)&#xA;        # 函数组合&#xA;    main&#xA;        # main :: IO ()&#xA;        main = do&#xA;    signum&#xA;        # 根据数字返回 -1, 0, 1&#xA;    not&#xA;    id&#xA;        # identity&#xA;    unlines&#xA;        unlines [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&#xA;            # 成为 &amp;quot;a\nb\n&amp;quot;&#xA;    unwords&#xA;        unwords [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&#xA;            # 成为 &amp;quot;a b&amp;quot;&#xA;    show&#xA;        # 接受各种类型，转换为String, 再转义打印&#xA;    read&#xA;        read &amp;quot;5&amp;quot; :: Int&#xA;        read &amp;quot;5&amp;quot; - 2&#xA;        read &amp;quot;[1,2,3]&amp;quot; ++ [4]&#xA;    reads&#xA;        # 读取失败返回[]而不报错&#xA;    negate&#xA;        # 取反数字&#xA;    abs&#xA;        # 绝对值&#xA;    length&#xA;        # 列表的长度, [a] -&amp;gt; Int , a在这里是一个type variable, 以小写字母开头(具体类型都大写开头)。&#xA;    map&#xA;    compare&#xA;        # 返回 LT, GT, EQ其中一个&#xA;    min&#xA;    max&#xA;    compare&#xA;        # 返回LT, GT, EQ&#xA;        &amp;quot;Abc&amp;quot; `compare` &amp;quot;Zyx&amp;quot;&#xA;    mod&#xA;        # 取模&#xA;    odd&#xA;        # 奇数&#xA;    even&#xA;        # 偶数&#xA;    succ&#xA;        # 取Enum的后继&#xA;    pred&#xA;        # 取Enum的前置&#xA;    minBound&#xA;        # 取Bound下限&#xA;    maxBound&#xA;    substract&#xA;        # 减&#xA;&#xA;    head&#xA;    tail&#xA;        # 除第一个&#xA;    last&#xA;    init&#xA;        # 除最后一个&#xA;&#xA;    null&#xA;        # 检查list是否空&#xA;    reverse&#xA;        # list反转&#xA;    take&#xA;        take 1 [1,2,3]&#xA;    takeWhile&#xA;        # 取list值，直到某条件&#xA;    drop&#xA;        drop 1 [1,2,3]&#xA;    maximum&#xA;        # list中最大元素&#xA;    minimun&#xA;        # list中最小元素&#xA;    sum&#xA;        # list和&#xA;    product&#xA;        # list积&#xA;    elem&#xA;        # 判断元素是否在list中&#xA;        4 `elem` [3,4,5]&#xA;    cycle&#xA;        take 7 (cycle [1,2,3])&#xA;            # [1,2,3,1,2,3,1]&#xA;    repeat&#xA;        repeat 5&#xA;    replicate&#xA;        replicate 3 10&#xA;            # [10, 10, 10]&#xA;&#xA;    fst (1, 2)&#xA;        # 只适合2元组&#xA;    snd (1, 2)&#xA;        # 只适合2元组&#xA;    zip&#xA;        # zip3, zip4 ... zip7&#xA;        zip [1,2,3] [4,5,6]&#xA;            # [(1,4), (2,5), (3,6)]&#xA;    zipWith&#xA;        # zipWith1 ... zipWith7&#xA;        zipWith (\x y -&amp;gt; x + y) [1,2] [3,4]&#xA;            # [4,6]&#xA;    fromIntegral&#xA;        # 返回更通用的数字类型&#xA;    error &amp;quot;&amp;quot;&#xA;        # 抛错&#xA;    flip&#xA;        # 翻转两个参数调用&#xA;    map&#xA;    filter&#xA;    foldl&#xA;        foldl (\acc x -&amp;gt; acc + x) 0 xs&#xA;    foldr&#xA;        foldr (\x acc -&amp;gt; f x : acc) [] xs&#xA;    foldl1&#xA;        # 以第一个元素为初始值，空list报错&#xA;    foldr1&#xA;    foldl&#39;&#xA;        # foldl的strict版&#xA;    foldr&#39;&#xA;    scanl&#xA;        # 返回累加过程的list&#xA;    scanr&#xA;    scanl1&#xA;    scanr1&#xA;    o-&amp;gt; I/O action&#xA;        # 只有在main中执行&#xA;        # 类型为 IO a&#xA;        putStrLn&#xA;            # 只接受String，不转义打印，加换行符&#xA;            # putStrLn :: String -&amp;gt; IO () , 表示接收String, 是IO动作, 结果类型是()。表示是一个&amp;quot;IO monad&amp;quot;动作&#xA;        putStr&#xA;            # 由putChar递归定义，边界条件是空字符串&#xA;        putChar&#xA;        print&#xA;            # 打印Show typeclass的值&#xA;        getLine&#xA;            # 控制台读一行&#xA;            # getLine :: IO String&#xA;            name &amp;lt;- getLine&#xA;        getChar&#xA;        sequence&#xA;        # 顺序执行I/O action&#xA;        mapM&#xA;            mapM print [1,2,3]&#xA;                # 对list元素执行sequence f&#xA;        mapM_&#xA;            # 同mapM，不打印[(),()]&#xA;        getContents&#xA;            # 读直到 eof (ctrl + d)&#xA;        interact&#xA;            # 用函数处理输入，返回到输出&#xA;Data.List&#xA;    # 每个元素存在thunk中&#xA;    \&#xA;        # 差集&#xA;        [1..3] \\ [2]&#xA;            # [1,3]&#xA;        &amp;quot;Im a big baby&amp;quot; \\ &amp;quot;big&amp;quot;&#xA;            # &amp;quot;Im a baby&amp;quot;&#xA;    union&#xA;    intersection&#xA;    insert&#xA;        # 插入一个元素到可排序list相对位置&#xA;    nub&#xA;        # 去重复元素,常用Set转换取代,提高很多效率&#xA;    map&#xA;        # 导出到了prelude&#xA;    filter&#xA;        # 导出到了prelude&#xA;    intersperse&#xA;        intersperse &#39;.&#39; &amp;quot;abc&amp;quot;&#xA;            # &amp;quot;a.b.c&amp;quot;&#xA;    intercalate&#xA;        # 同intersperse, 但插入list&#xA;    transpose&#xA;        # 二元list列为行&#xA;    foldl&#39;&#xA;        # fold的严格版，直接计算出中间值，而非用惰性&amp;quot;承诺&amp;quot;塞满堆栈&#xA;    foldl1&#39;&#xA;    concat&#xA;        # 移除一级嵌套&#xA;    concatMap&#xA;        # 先map再concat&#xA;        concatMap (replicate 2) [1..3]&#xA;            # [1,1,2,2,3,3]&#xA;    and&#xA;        # list中全true返回true&#xA;        and $ map (&amp;gt;4) [5,6,7,8]&#xA;    or&#xA;    any&#xA;    iterate&#xA;        # 无限迭代值到函数，结果形成list&#xA;        take 10 $ iterate (*2) 1&#xA;    splitAt&#xA;        # 断开list, 返回二元组&#xA;        splitAt 3 &amp;quot;abcdef&amp;quot;&#xA;            # (&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;)&#xA;    takeWhile&#xA;        # 取元素，直到不符合条件&#xA;    dropWhile&#xA;    span&#xA;        # 同takeWhile, 不过返回分割list的二元组&#xA;    break&#xA;        # 同span, 但在条件首次为true时断开&#xA;    sort&#xA;        # list元素要求Ord类型，排序list&#xA;    group&#xA;        # 合并相邻并相等的list元素&#xA;    inits&#xA;        # init递归调用自身&#xA;        inits &amp;quot;abc&amp;quot;&#xA;            # [&amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;ab&amp;quot;, &amp;quot;abc&amp;quot;]&#xA;    tails&#xA;        # tail递归调用自身&#xA;        tails &amp;quot;abc&amp;quot;&#xA;            # [&amp;quot;abc&amp;quot;, &amp;quot;bc&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;&amp;quot;]&#xA;    isInfixOf&#xA;        # list中搜索子list, 有则返回true&#xA;        &amp;quot;cat&amp;quot; `isInfixOf` &amp;quot;im a cat&amp;quot;&#xA;    isPrefixOf&#xA;        # 是否以某list开头&#xA;    isSuffixOf&#xA;        # 是否以某list结尾&#xA;    elem&#xA;        # 是否包含某元素&#xA;    notElem&#xA;    partition&#xA;        # 条件划分list为二元组&#xA;        partition (`elem` [&#39;A&#39;..&#39;Z&#39;]) &amp;quot;AbCD&amp;quot;&#xA;            # (&amp;quot;ACD&amp;quot;, &amp;quot;b&amp;quot;)&#xA;    find&#xA;        # 条件查找list, 返回第一个符合元素的Maybe值&#xA;    elemIndex&#xA;        # 返回elem第一个元素的索引的Maybe值&#xA;    elemIndices&#xA;        # 返回所有匹配索引的list&#xA;    findIndex&#xA;    findIndices&#xA;    lines&#xA;        # 字符串分行到list&#xA;    unlines&#xA;    words&#xA;        # 字符串分词到list&#xA;    unwords&#xA;    delete&#xA;        # 删除list中第一个匹配元素&#xA;        delete &#39;h&#39; &amp;quot;hha&amp;quot;&#xA;            # &amp;quot;ha&amp;quot;&#xA;    replace&#xA;    lookup&#xA;        # 用a查找[(&#39;a&#39;, &#39;b&#39;)]中的b&#xA;    genericLength&#xA;        # 换Int类型为Num类型&#xA;    genericTake&#xA;    genericDrop&#xA;    genericSplitAt&#xA;    genericIndex&#xA;    genericReplicate&#xA;&#xA;    nubBy&#xA;        # 传递函数判断相等性，取代==&#xA;    deleteBy&#xA;    unionBy&#xA;    intersectBy&#xA;    groupBy&#xA;    sortBy&#xA;    insertBy&#xA;    maximumBy&#xA;    minimumBy&#xA;Data.Monoid&#xA;    Monoid&#xA;    Product&#xA;    Sum&#xA;    Any&#xA;    All&#xA;Data.Foldable&#xA;    foldr&#xA;    foldl&#xA;    foldr1&#xA;    foldl1&#xA;Data.Function&#xA;    on&#xA;        ((==) `on` (&amp;gt; 0))&#xA;            # 判断相等性，等价于 (\x y -&amp;gt; (x &amp;gt; 0) == (y &amp;gt; 0))&#xA;        (compare `on` length)&#xA;            # 判断大小&#xA;Data.Char&#xA;    isControl&#xA;        # 是否控制字符&#xA;    isSpace&#xA;        # 包括空格, tab, 换行等&#xA;    isLower&#xA;    isUpper&#xA;    isAlpha&#xA;        # 是否字母&#xA;    isAlphaNum&#xA;        # 字母或数字&#xA;    isPrint&#xA;        # 可打印&#xA;    isDigit&#xA;    isOctDigit&#xA;    isHexDigit&#xA;    isLetter&#xA;        # 同isAlpha&#xA;    isMark&#xA;        # unicode注音字符&#xA;    isNumber&#xA;    isPunctuation&#xA;        # 是否标点符号&#xA;    isSymbol&#xA;        # 货币符号&#xA;    isSeperater&#xA;        # unicode空格或分隔符&#xA;    isAscii&#xA;        # unicode 前128位&#xA;    isLatin1&#xA;        # unicode 前256位&#xA;    isAsciiUpper&#xA;    isAsciiLower&#xA;    GeneralCategory&#xA;        # 得到字符的分类，一共31类, 属于Eq类型&#xA;        generalCategory &#39; &#39;&#xA;            # Space&#xA;    toUpper&#xA;    toLower&#xA;    toTitle&#xA;    digitToInt&#xA;        # 数字，大小写字母list 转成 int list&#xA;    intToDigit&#xA;    ord&#xA;    char&#xA;Data.Map&#xA;    # 用avl树实现&#xA;    fromList&#xA;        # 重复键会忽略，要求key有相等性和排序性&#xA;    fromListWith&#xA;        # 重复键给函数处理&#xA;    toList&#xA;    empty&#xA;        # 返回空map&#xA;    insert&#xA;        insert 3 10 map&#xA;    insertWith&#xA;        # 已包含键时函数处理&#xA;    null&#xA;        # 检查map是否空&#xA;    size&#xA;        # 返回map的大小&#xA;    singleton&#xA;        singleton 3, 9&#xA;            # fromList [(3,9)]&#xA;    lookup&#xA;    member&#xA;        # key 是否在map中&#xA;    map&#xA;    filter&#xA;    keys&#xA;    elems&#xA;Data.Set&#xA;    # 要求元素可排序，自动排序、唯一&#xA;    # 用avl树实现&#xA;    fromList&#xA;    intersection&#xA;    difference&#xA;        # 存在于第一集合而不在第二集合的元素&#xA;    union&#xA;    null&#xA;    size&#xA;    member&#xA;    empty&#xA;    singleton&#xA;    insert&#xA;    delete&#xA;    isSubsetOf    &#xA;        # 子集&#xA;        fromList [1,2] isSubsetOf fromList [1,2]&#xA;    isProperSubsetOf&#xA;        # 真子集&#xA;    filter&#xA;    map&#xA;Data.ByteString&#xA;    # strict bytestring&#xA;    # Empty相当于[], cons相当于:&#xA;Data.ByteString.Lazy&#xA;    # 每个元素存在chunk中，每个chunk 64k，每个chunk相当于一个strict bytestring&#xA;    # cons在chunk不满的时候会新建chunk, cons&#39;是strick版的cons, 会填充chunk&#xA;    pack&#xA;        # pack :: [Word8] -&amp;gt; ByteString&#xA;        pack [80,81]&#xA;    unpack&#xA;    fromChunks&#xA;        # 转换strick bytestring 到lazy&#xA;    toChunks&#xA;        # lazy转strick&#xA;Data.Ratio&#xA;Control.Applicative&#xA;    Applicative&#xA;        class (Functor f) =&amp;gt; Applicative f where&#xA;            pure :: a -&amp;gt; fa&#xA;            (&amp;lt;*&amp;gt;) :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;            f &amp;lt;$&amp;gt; x = fmap f x&#xA;    ZipList&#xA;        ZipList3&#xA;        ZipList7&#xA;    getZipList&#xA;    liftA2&#xA;        liftA2 f x y = f &amp;lt;$&amp;gt; x &amp;lt;*&amp;gt; y &#xA;    sequenceA&#xA;Control.Monad&#xA;    when&#xA;        # Bool true时，返回后面的I/O action, 否则return ()&#xA;    forever&#xA;        # 不断执行后面的I/O action&#xA;        forever $ do&#xA;            putStr &amp;quot;a&amp;quot;&#xA;    forM&#xA;        # 同mapM, 但两个参数顺序相反&#xA;    liftM&#xA;        # monad中的fmap&#xA;    liftM2 liftM3 liftM4 liftM5&#xA;    `ap`&#xA;        # monad中的&amp;lt;*&amp;gt;&#xA;    join&#xA;        join :: (Monad m) =&amp;gt; m (m a) -&amp;gt; m a&#xA;        join mm = do&#xA;            m &amp;lt;- mm&#xA;            m&#xA;    filterM&#xA;    foldM&#xA;Control.Monad.State&#xA;    State&#xA;        newtype State s a = State {runState :: s -&amp;gt; (a, s)}&#xA;    get&#xA;    put&#xA;Control.Monad.Error&#xA;System.IO&#xA;    openFile&#xA;        # openFile :: FilePath -&amp;gt; IOMode -&amp;gt; IO Handle&#xA;        # data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode&#xA;        do&#xA;        handle = openFile &amp;quot;a.txt&amp;quot; ReadMode&#xA;        contents &amp;lt;- hGetContents handle&#xA;        putStr contents&#xA;        hClose handle&#xA;    withFile&#xA;        # withFile :: FilePath -&amp;gt; IOMode -&amp;gt; (Handle -&amp;gt; IO a) -&amp;gt; IO a&#xA;        # 处理完关掉&#xA;        withFile &amp;quot;a.txt&amp;quot; ReadMode (\handle -&amp;gt; do&#xA;            contents &amp;lt;- hGetContents handle&#xA;            putStr contents)&#xA;    readFile&#xA;        # readFile :: FilePath -&amp;gt; IO String&#xA;        do&#xA;        contents &amp;lt;- readFile &amp;quot;a.txt&amp;quot;&#xA;        putStr contents&#xA;    wirteFile&#xA;        # writeFile :: FilePath -&amp;gt; String -&amp;gt; IO ()&#xA;        do&#xA;        writeFile &amp;quot;a.txt&amp;quot; contents&#xA;    appendFile&#xA;    hSetBuffering&#xA;        # 读binary file时的buffer，默认是系统值&#xA;        # data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)&#xA;        hSetBuffering handle $ BlockBuffering (Just 2048)&#xA;    hFlush&#xA;        # 写入时自动Flush&#xA;    openTempFile&#xA;        (tempName, tempHandle) &amp;lt;- openTempFile &amp;quot;.&amp;quot; &amp;quot;temp&amp;quot;&#xA;    hGetContents&#xA;    hClose&#xA;    hGetLine&#xA;    hPusStr&#xA;    hPutStrLn&#xA;    hGetChar&#xA;System.IO.Error&#xA;    catch&#xA;        # catch :: IO a -&amp;gt; (IOError -&amp;gt; IO a) -&amp;gt; IO a&#xA;        toTry `catch` handler&#xA;        handler e&#xA;            | isDoesNotExistError e = &#xA;                case ioeGetFileName e of Just path -&amp;gt; putStrLn $ &amp;quot;a&amp;quot; ++ path&#xA;                    Nothing -&amp;gt; putStrLn &amp;quot;b&amp;quot;&#xA;            | otherwise = ioError e&#xA;    isDoesNotExistError&#xA;    isAlreadyExistsError&#xA;    isFullError&#xA;    isEOFError&#xA;    isIllegalOperation&#xA;    isPermissionError&#xA;    isUserError&#xA;    ioeGetFileName&#xA;        # ioeGetFileName :: IOError -&amp;gt; Maybe FilePath&#xA;    ioError&#xA;        # 丢出接到的error&#xA;System.Directory&#xA;    removeFile&#xA;        removeFile &amp;quot;a.txt&amp;quot;&#xA;    renameFile&#xA;        renameFile tempName &amp;quot;a.txt&amp;quot;&#xA;    copyFile&#xA;    doesFileExist&#xA;System.Environment&#xA;    getArgs&#xA;    getProgName&#xA;System.Random&#xA;    mkStdGen&#xA;        # mkStdGen :: Int -&amp;gt; StdGen&#xA;    getStdGen&#xA;        # IO类型, 得到系统启动时的global generator&#xA;    newStdGen&#xA;        # 把现有的random generator分成两个新的generators, 其中一个指定成新的，返回另一个&#xA;    random&#xA;        # random :: (RandomGen g, Random a) = g -&amp;gt; (a, g)&#xA;        random (mkStdGen 100) :: (Int, StdGen)&#xA;    randoms&#xA;        take 5 $ randoms (mkStdGen 11) :: [Int]&#xA;    randomR&#xA;        # 区间random&#xA;        randomR (1,6) (mkStdGen 2)&#xA;    randomRs&#xA;        take 10 $ randomRs (&#39;a&#39;, &#39;z&#39;) (mkStdGen 3) :: [Char]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数-1&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 模式匹配&#xA;    # case的语法糖&#xA;    # 对构造子匹配，如 8 &#39;a&#39; : []&#xA;factorial :: (Integral a) =&amp;gt; a -&amp;gt; a&#xA;factorial 0 = 1&#xA;factorial n = n * factorial (n - 1)&#xA;&#xA;addVectors :: (Num a) =&amp;gt; (a, a) -&amp;gt; (a, a) -&amp;gt; (a, a)&#xA;addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)&#xA;&#xA;first :: (a, b, c) -&amp;gt; a&#xA;first (x, _, _) = x&#xA;&#xA;tell :: (Show a) =&amp;gt; [a] -&amp;gt; String&#xA;tell [] = &amp;quot;&amp;quot;&#xA;tell [x: []] = &amp;quot;&amp;quot;&#xA;tell [x:y:[]] = &amp;quot;&amp;quot;&#xA;tell [x:y:_] = &amp;quot;too long, the first is &amp;quot; ++ show x ++ &amp;quot; and the second is &amp;quot; ++ show y&#xA;&#xA;length&#39; :: (Num b) =&amp;gt; [a] -&amp;gt; b&#xA;length&#39; [] = 0&#xA;length&#39; (_:xs) = 1 + length&#39; xs&#xA;&#xA;capital :: String -&amp;gt; String&#xA;capital &amp;quot;&amp;quot; = &amp;quot;&amp;quot;&#xA;capital all@(x:xs) = &amp;quot;The first letter of &amp;quot; ++ all ++ &amp;quot; is &amp;quot; ++ [x]&#xA;    # @是as模式&#xA;&#xA;o-&amp;gt; guard&#xA;bmiTell :: (RealFloat a) =&amp;gt; a -&amp;gt; String&#xA;bmiTell weight height&#xA;    | bmi &amp;lt;= skinny = &amp;quot;You&#39;re underweight&amp;quot;&#xA;    | bmi &amp;lt;= normal = &amp;quot;You&#39;re supposedly normal&amp;quot;&#xA;    | bmi &amp;lt;= fat = &amp;quot;You&#39;re fat&amp;quot;&#xA;    | otherwise = &amp;quot;You&#39;re a whale&amp;quot;&#xA;    where bmi = weight / height ^ 2&#xA;    (skinny, normal, fat) = (18.5, 25.0, 30.0)&#xA;        # where是语法结构，不是表达式&#xA;calcBmis :: (RealFloat a) =&amp;gt; [(a, a)] -&amp;gt; [a]&#xA;calcBmis xs = [bmi w h | (w, h) &amp;lt;- xs, let bmi = w / h ^ 2]&#xA;&#xA;myCompare :: (Ord a) =&amp;gt; a -&amp;gt; a -&amp;gt; Ordering&#xA;a `myCompare` b&#xA;    | a &amp;gt; b = GT&#xA;    | a == b = EQ&#xA;    | otherwise = LT&#xA;&#xA;o-&amp;gt; quicksort&#xA;quicksort :: (Ord a) =&amp;gt; [a] -&amp;gt; [a]&#xA;quicksort [] = []&#xA;quicksort (x:xs) = &#xA;    let smallerSorted = quicksort (filter (&amp;lt;=x) xs)&#xA;        biggerSorted = quicksort [a | a &amp;lt;- xs, a &amp;gt; x]&#xA;    in smallerSorted ++ [x] ++ biggerSorted&#xA;&#xA;o-&amp;gt; curry&#xA;compareWithHundred :: (Num a, ord a) =&amp;gt; a -&amp;gt; Ordering&#xA;compareWithHundred = compare 100&#xA;&#xA;divideByTen :: (Floating a) =&amp;gt; a -&amp;gt; a&#xA;divideByTen = (/10)&#xA;    # 中缀函数用括号来不完全调用&#xA;    # 但(-4)表示负4, (substract 4)来表示减4函数&#xA;&#xA;o-&amp;gt; 高阶函数&#xA;applyTwice :: (a -&amp;gt; a) -&amp;gt; a -&amp;gt; a&#xA;applyTwice f x = f (f x)&#xA;&#xA;o-&amp;gt; lambda&#xA;addThree :: (Num a) =&amp;gt; a -&amp;gt; a -&amp;gt; a -&amp;gt; a&#xA;addThree = \x -&amp;gt; \y -&amp;gt; \z -&amp;gt; x + y + z&#xA;&#xA;o-&amp;gt; $ 做数据函数&#xA;map ($ 3) [(4+), (10*), (^2), sqrt]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;类型&#xA;    Int&#xA;        # 有界整数&#xA;    Integer&#xA;        # 无界整数&#xA;    Float&#xA;        # 单精度浮点数&#xA;    Double&#xA;    Bool&#xA;    Char&#xA;    Maybe&#xA;    []&#xA;    ()&#xA;    a&#xA;        # type variables&#xA;类型约束&#xA;    Eq&#xA;    # 可判断相等性的类型，可用 == 或 /= 判断&#xA;        # 只除函数&#xA;    Ord&#xA;        #可比较大小的类型, 必定是Eq&#xA;        # 只除函数&#xA;    Ordering&#xA;        # 只有GT, EQ, LT&#xA;    Show&#xA;        # 可用字符串表示的类型&#xA;        # 只除函数&#xA;    Read&#xA;        # 与Show相反&#xA;    Enum&#xA;        # 连续的类型，有后继子(successer)和前置子(predecesor), 分别通过succ函数和pred函数得到&#xA;        # 可以[1..2]构造list&#xA;        # 包含 (), Bool, Char, Ordering, Int, Integer, Float, Double&#xA;    Bounded&#xA;        # 有上限和下限&#xA;        # 如果Tuple中都属于Bounded, 那么这个Tuple属于Bounded&#xA;    Num&#xA;        # 数字特征&#xA;    Integral&#xA;        # 整数&#xA;    Floating&#xA;        # 浮点，包含Float和Double&#xA;构造类型&#xA;    data Bool = False | True deriving (Ord)&#xA;        # Bool是构造的类型, False为值构造子，值可以用:t查看其类型&#xA;        # 值构造子可以用于模式匹配&#xA;        # 这里值构造子是没有参数的，叫作nullary&#xA;        # False在True前，所以比较时True比False大&#xA;    data Point = Point Float Float deriving (Show)&#xA;        # 值构造子可以与类型同名&#xA;    data Shape = Circle Point Float | Rectangle  Point Point deriving (Show)&#xA;        # 派生自Show, 就可show值成字符串&#xA;    data Person = Person {firstName :: String&#xA;        , lastName :: String&#xA;        } deriving (Show)&#xA;            # Record Syntax, 同 Person String String,  但自动生成同名的取值函数，show显示也改变&#xA;        let p = Person {firstName=&amp;quot;aa&amp;quot;, lastName=&amp;quot;bb&amp;quot;}&#xA;    &#xA;        tellPerson :: Person -&amp;gt; String&#xA;        tellPerson (Person {firstName = a, lastName = b}) = a ++ b&#xA;    newtype CharList = CharList {getCharList :: [Char]} deriving {Eq, Show}&#xA;        # newtype将现有类型包成新类型，只能定义单一值构造子，且其只能有一个字段。并将包裹和解开的成本都去掉&#xA;类型构造子&#xA;    # data声明中不能加类型约束&#xA;    data Maybe a = Nothing | Just a&#xA;    data Car a b = Car { company :: a&#xA;        , year :: b&#xA;        } deriving (Show)&#xA;    tellCar :: (Show a) =&amp;gt; Car String a -&amp;gt; String&#xA;类型别名&#xA;    type String = [Char]&#xA;    type AssocList k v = [(k,v)]&#xA;        # 别名类型构造子&#xA;    type IntMap = Map Int&#xA;        # 不全调用得到不全类型构造子, 同 type intMap v = Map Int v&#xA;infixr&#xA;    infixr 5 :-:&#xA;        # 定义中缀构造子, 5是优先级, :-:是符号&#xA;        # 默认left-associative&#xA;&#xA;    infixr 5 .++&#xA;    (.++) :: List a -&amp;gt; List a -&amp;gt; List a&#xA;    Empty .++ ys = ys&#xA;    (x :-: xs) .++ ys = x :-: (xs .++ ys)&#xA;recursive data structures&#xA;    data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)&#xA;typeclass&#xA;    class Eq a where&#xA;        (==) :: a -&amp;gt; a -&amp;gt; Bool&#xA;        (/=) :: a -&amp;gt; a -&amp;gt; Bool&#xA;        x == y = not (x /= y)&#xA;        x /= y = not (x == y)&#xA;            # 只需要instance一个定义就好，这个定义叫minimal complete definition&#xA;    data TrafficLight = Red | Yellow | Green&#xA;    instance Eq TrafficLight where&#xA;        Red == Red = True&#xA;        Green == Green = True&#xA;        Yellow == Yellow = True&#xA;        _ == _ = False&#xA;    instance Show TrafficLight where&#xA;        show Red = &amp;quot;Red light&amp;quot;&#xA;        show Yellow = &amp;quot;Yellow light&amp;quot;&#xA;        show Green = &amp;quot;Green light&amp;quot;&#xA;&#xA;    class (Eq a) =&amp;gt; Num a where&#xA;        # Num 是 Eq  的 subclass, 要是Num必是Eq&#xA;&#xA;    instance (Eq m) =&amp;gt; Eq (Maybe m) where&#xA;        Just x == Just y = x == y&#xA;        Nothing == Nothing = True&#xA;        _ == _ = False&#xA;            &#xA;o-&amp;gt; Either&#xA;data Either a b = Left a | Right a deriving (Eq, Ord, Read, Show)&#xA;&#xA;o-&amp;gt; Tree&#xA;data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)&#xA;&#xA;o-&amp;gt; YesNo&#xA;class YesNo a where&#xA;    yesno :: a -&amp;gt; Bool&#xA;instance YesNo Int where&#xA;    yesno 0 = False&#xA;    yesno _ = True&#xA;&#xA;o-&amp;gt; Functor&#xA;class Functor f where&#xA;    # map over&#xA;    fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;instance Functor Maybe where&#xA;    # 接收构造子而非类型&#xA;    fmap f (Just x) = Just (f x)&#xA;    fmap f Nothing = Nothing&#xA;instance Functor (Either a) where&#xA;    # parital apply Either, Either a 是个类型构造子&#xA;    fmap f (Right x) = Right (f x)&#xA;    fmap f (Left x) = Left x&#xA;instance Functor ((-&amp;gt;) r) where&#xA;    # 对函数的functor&#xA;    fmap f g = (\x -&amp;gt; f (g x))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ghci&#xA;    set prompt &amp;quot;ghci&amp;gt; &amp;quot;&#xA;        # 设置显示的提示符&#xA;ghc&#xA;    ghc --make a.hs&#xA;runhaskell&#xA;ghc-pkg list&#xA;    # 列出已安装的软件包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;玄学&#34;&gt;&#xA;  玄学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%84%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;&#xA;:{&#xA;data X = X&#xA;a :: Int -&amp;gt; Int&#xA;a x = x + 3&#xA;:}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Html</title>
      <link>https://runout.run/docs/pl/markup_language/html/</link>
      <pubDate>Tue, 09 Oct 2018 16:42:05 +0800</pubDate>
      <guid>https://runout.run/docs/pl/markup_language/html/</guid>
      <description>&lt;h1 id=&#34;事件&#34;&gt;&#xA;  事件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;blur&#xA;change&#xA;click&#xA;dblclick&#xA;focus&#xA;keydown&#xA;keypress&#xA;keyup&#xA;load&#xA;mousedown&#xA;mousemove&#xA;mouseout&#xA;mouseover&#xA;mouseup&#xA;reset&#xA;select&#xA;submit&#xA;unload&#xA;&#xA;Abort&#xA;    # 中断图片下载时激发&#xA;AfterPrint&#xA;    # 打印文档后激发&#xA;AfterUpdate&#xA;    # 传送完数据&#xA;BeforeCopy&#xA;    # 复制到剪贴板前&#xA;BeforeCut&#xA;    # 剪切到剪贴板前&#xA;BeforeEditFocus&#xA;BeforePaste&#xA;BeforePrint&#xA;BeforeUnload&#xA;BeforeUpdate&#xA;Bounce&#xA;CellChange&#xA;CtextMenu&#xA;Copy&#xA;Cut&#xA;DataAvailable&#xA;DatasetChanged&#xA;DatasetComplete&#xA;Drag&#xA;DragDrop&#xA;DragEnd&#xA;DragEnter&#xA;DragLeave&#xA;DragOver&#xA;DragStart&#xA;Drop&#xA;Error&#xA;ErrorUpdate&#xA;FilterChange&#xA;Finish&#xA;Help&#xA;LoseCapture&#xA;Move&#xA;Paste&#xA;&#xA;PropertyChange&#xA;ReadyStateChange&#xA;Resize&#xA;RowEnter&#xA;RowExit&#xA;RowsDelete&#xA;RowsInserted&#xA;Scroll&#xA;SelectStart&#xA;Start&#xA;Stop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;标签&#34;&gt;&#xA;  标签&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%87%e7%ad%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;var&amp;gt;               # 标识常量&#xA;&amp;lt;samp&amp;gt;              # 标识输出内容的样式&#xA;&amp;lt;pre&amp;gt;               # 代码块&#xA;&amp;lt;code&amp;gt;              # 一段代码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;属性&#34;&gt;&#xA;  属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局属性&#xA;    # 配置所有元素共有行为&#xA;    accesskey&#xA;        # 快捷键&#xA;        ## 需要按alt + 指定的键&#xA;    class&#xA;    contenteditable&#xA;        # 内容是否可修改, 如p标签&#xA;    contextmenu&#xA;        # 定义右键菜单，未实现&#xA;    dir&#xA;        # 文字对齐方式&#xA;    draggable&#xA;    dropzone&#xA;    hidden&#xA;    id&#xA;    lang&#xA;    spellcheck&#xA;    style&#xA;    tabindex&#xA;        # tab键切换元素的顺序&#xA;    title&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;浏览器特性&#34;&gt;&#xA;  浏览器特性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8f%e8%a7%88%e5%99%a8%e7%89%b9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;视频播放 &#xA;    支持vaapi, chrome 加上--enable-vaapi参数可以开启硬件加速解码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;标签&#xA;    &amp;lt;input&amp;gt;表单&#xA;        单选框&#xA;        &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; checked value=&amp;quot;1&amp;quot;&amp;gt;&#xA;        &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; value=&amp;quot;1&amp;quot;&amp;gt;&#xA;        下拉框&#xA;        &amp;lt;select id=&amp;quot;mySelect&amp;quot; size=10 multiple&amp;gt;    # 长度等于10 ，多选&#xA;            &amp;lt;option selected=&amp;quot;selected&amp;quot;&amp;gt;Apple&amp;lt;/option&amp;gt;&#xA;            &amp;lt;option&amp;gt;Orange&amp;lt;/option&amp;gt;&#xA;        &amp;lt;/select&amp;gt;&#xA;        勾选框&#xA;        &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;&amp;quot; /&amp;gt;&#xA;        按钮&#xA;        &amp;lt;input type=&amp;quot;button&amp;quot;/&amp;gt;&#xA;        &amp;lt;button&amp;gt;                # &amp;lt;button&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;搜索&amp;lt;/button&amp;gt;        button之间可以加图片&#xA;        &#xA;    &amp;lt;table&amp;gt;表格&#xA;        &amp;lt;caption&amp;gt; # 标题&#xA;        &amp;lt;thead&amp;gt;&#xA;            &amp;lt;th&amp;gt;&#xA;                &amp;lt;td&amp;gt;&amp;lt;td&amp;gt;&#xA;            &amp;lt;/th&amp;gt;&#xA;        &amp;lt;tbody&amp;gt;&#xA;            &amp;lt;tr&amp;gt;&#xA;                &amp;lt;td&amp;gt;&amp;lt;td&amp;gt;&#xA;            &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tfoot&amp;gt;&#xA;            属性&#xA;                &amp;lt;tr style=&amp;quot;display: none;&amp;quot;&amp;gt;                # 设置属性为隐藏&#xA;&#xA;    &amp;lt;form&amp;gt;表单&#xA;        enctype属性&#xA;            application/x-www-form-urlencoded(默认)                # 在发送编码所有字符（空格转换为 &amp;quot;+&amp;quot; 加号，特殊符号转换为 ASCII HEX 值）&#xA;            multipart/form-data                                                        # 不对字符进行编码，在上传文件时使用&#xA;            text/plain                                                                        # 空格转换为+，但是不对特殊字符进行编码&#xA;            &#xA;    &amp;lt;hr&amp;gt;分割线&#xA;&#xA;    字体&#xA;        &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;  ...  &amp;lt;h6&amp;gt;&amp;lt;h6&amp;gt;标题标签对&#xA;        &#xA;        &amp;lt;b&amp;gt;粗体&amp;lt;/b&amp;gt;&amp;lt;i&amp;gt;斜体&amp;lt;/i&amp;gt;&amp;lt;u&amp;gt;下划线&amp;lt;/u&amp;gt;&amp;lt;tt&amp;gt;打字机风格&amp;lt;/tt&amp;gt;&amp;lt;cite&amp;gt;引用&amp;lt;/cite&amp;gt;&amp;lt;em&amp;gt;强调（斜体粗体）&amp;lt;/em&amp;gt;&amp;lt;strong&amp;gt;重要（黑体加粗体）&amp;lt;/strong&amp;gt;&#xA;        &#xA;        &amp;lt;sub&amp;gt;下标&amp;lt;/sub&amp;gt;&amp;lt;sup&amp;gt;上标&amp;lt;/sup&amp;gt;&#xA;        &#xA;        &amp;lt;font size =-7到+7  coler = 颜色&amp;gt;&amp;lt;/font&amp;gt;&#xA;&#xA;    &amp;lt;img src=&amp;quot;&amp;quot;/&amp;gt;图片&#xA;        属性&#xA;            alt                # 规定图像的替代文本&#xA;            border&#xA;            width&#xA;            height&#xA;&#xA;    &amp;lt;span&amp;gt;与 &amp;lt;div&amp;gt;&#xA;        &amp;lt;span&amp;gt; 在CSS定义中属于一个行内元素,在行内定义一个区域，也就是一行内可以被 &amp;lt;span&amp;gt; 划分成好几个区域&#xA;        ，从而实现某种特定效果。 &amp;lt;span&amp;gt; 本身没有任何属性。&#xA;        &amp;lt;div&amp;gt; 在CSS定义中属于一个块级元素 &amp;lt;div&amp;gt; 可以包含段落、标题、表格甚至其它部分。&#xA;        这使DIV便于建立不同集成的类，如章节、摘要或备注。在页面效果上，使用 &amp;lt;div&amp;gt; 会自动换行，使用 &amp;lt;span&amp;gt; 就会保持同行。&#xA;        &#xA;        &amp;lt;span&amp;gt;没有内边距&#xA;        &#xA;    &amp;lt;label&amp;gt;标签&#xA;        标记通常以下面两种方式中的一种来和表单控件相联系：将表单控件作为标记标签的内容，这样的就是隐式形式&#xA;        ，或者为 &amp;lt;label&amp;gt; 标签下的 for 属性命名一个目标表单 id，这样就是显式形式。&#xA;&#xA;        例如，在 XHTML 中：&#xA;            显式的联系：&#xA;            &amp;lt;label for=&amp;quot;SSN&amp;quot;&amp;gt;Social Security Number:&amp;lt;/label&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;SocSecNum&amp;quot; id=&amp;quot;SSn&amp;quot; /&amp;gt;&#xA;            &#xA;            隐式的联系：&#xA;            &amp;lt;label&amp;gt;Date of Birth: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;DofB&amp;quot; /&amp;gt;&amp;lt;/label&amp;gt;&#xA;&#xA;    &amp;lt;head&amp;gt;标签&#xA;        &amp;lt;base&amp;gt; 标签为页面上的所有链接规定默认地址或默认目标。&#xA;        &amp;lt;meta http-equiv=&amp;quot;pragma&amp;quot; content=&amp;quot;no-cache&amp;quot;&amp;gt;        定义响应信息头&#xA;        &amp;lt;meta name=&amp;quot;keywrods&amp;quot; content=&amp;quot;keyword1,keyword2&amp;quot;&amp;gt;        关键字&#xA;        ＜meta name=&amp;quot;description&amp;quot; content=&amp;quot;This page is about the meaning of science, education,culture.&amp;quot;＞        网站主要内容&#xA;        ＜meta name=&amp;quot;robots&amp;quot; content=&amp;quot;none&amp;quot;＞        机器人索引 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 &#xA;        ＜meta name=&amp;quot;author&amp;quot; content=&amp;quot;outrun&amp;quot;＞                作者&#xA;        &#xA;    &amp;lt;marquee behavior = &amp;quot;alternate&amp;quot;&amp;gt;  文字行为                # alternate为来回滚动&#xA;        &amp;lt;font size = 30 color = &amp;quot;red&amp;quot;&amp;gt;www.it315.org&amp;lt;/font&amp;gt;&amp;lt;/marquee&amp;gt;&#xA;        &amp;lt;marquee behavior = &amp;quot;slide&amp;quot; &amp;quot;scroll&amp;quot; &amp;quot;alternate&amp;quot; direction=&amp;quot;up&amp;quot;&amp;quot;down&amp;quot;&amp;quot;left&amp;quot;&amp;quot;right&amp;quot;&amp;gt;你好&amp;lt;/marquee&amp;gt;&#xA;        &#xA;    &amp;lt;nobr&amp;gt; 标签之间的文字在浏览器中不换行显示&#xA;        &amp;lt;NOBR&amp;gt;这里是一行不该换行的文本 . . .&#xA;        这是文本行的结尾。&amp;lt;/NOBR&amp;gt;&#xA;&#xA;    &amp;lt;pre&amp;gt;&amp;lt;/pre&amp;gt;        标签之间的文字在浏览器中换行显示&#xA;        &#xA;    &amp;lt;blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;缩进&#xA;&#xA;    条目标签&#xA;        &amp;lt;dl&amp;gt;&#xA;            &amp;lt;dt&amp;gt;&#xA;                &amp;lt;dd&amp;gt;&#xA;                &amp;lt;/dd&amp;gt;&#xA;            &amp;lt;/dt&amp;gt;&#xA;        &amp;lt;/dl&amp;gt;显示条目&#xA;&#xA;        &amp;lt;ol&amp;gt;&#xA;            &amp;lt;li&amp;gt;&#xA;            &amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ol&amp;gt;数字标签列表&#xA;&#xA;        &amp;lt;ul&amp;gt;&#xA;            &amp;lt;li&amp;gt;&#xA;            &amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;圆点标签列表&#xA;        &#xA;    &amp;lt;a&amp;gt;标签&#xA;        发送邮件&#xA;        &amp;lt;a href = &amp;quot;mailto:admin@it315.org?subject=咨询&amp;quot;&amp;gt;我要留言&amp;lt;/a&amp;gt;&#xA;                如：mailto:zxx@it315.org?cc=dreamdu@sina.com&amp;amp;subject=Feedback&amp;amp;body=how%20are%20you  # subject body cc 等用url参数拼接的方式拼接&#xA;                        %20代表空格 &#xA;                        subject= 是标题&#xA;                        body= 是邮件内容&#xA;                        CC=是抄送  &#xA;                        BCC=是暗送&#xA;&#xA;        新窗口&#xA;                &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot;/&amp;gt;&amp;lt;/a&amp;gt;打开新窗口&#xA;        属性&#xA;        &amp;lt;a name =&amp;quot;mark1&amp;quot;/&amp;gt;&#xA;        &amp;lt;a href=&amp;quot;text.html#mark1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;定位&#xA;        &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;打开自己&#xA;        &amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;打开目录&#xA;&#xA;    &amp;lt;map&amp;gt;&amp;lt;/map&amp;gt;定义热点映射4&#xA;        &amp;lt;area&amp;gt;&amp;lt;/area&amp;gt;来说明 属性shape形状，coords坐标，href或nohref，target赖志明浏览器的哪个窗口或帧中显示&#xA;        &amp;lt;img&amp;gt;标签中增加名为usemap的属性来指定图像被用做图像地图，其设置值为图像热点名称 如&amp;lt;img src=&amp;quot;&amp;quot; usemap=&amp;quot;#mymap&amp;quot;&amp;gt;&#xA;        &amp;lt;img src=&amp;quot;logo.gir&amp;quot; border=0 usemap=&amp;quot;#mymap&amp;quot;&amp;gt;&#xA;        &amp;lt;map name=mymap&amp;gt;&#xA;        &amp;lt;area shape=&amp;quot;rect&amp;quot; coords=&amp;quot;0,0,50,50&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;  左上和右下坐标 shape的属性值 rect poly circle&#xA;        &amp;lt;/map&amp;gt;&#xA;&#xA;    &amp;lt;embed&amp;gt;&amp;lt;/embed&amp;gt;标签 添加swf类型flash元素&#xA;        scale=&amp;quot;noscale&amp;quot;                # 没有比例缩放&#xA;        wmode=&amp;quot;transparent&amp;quot;                # 背景透明&#xA;&#xA;样式&#xA;    小图标&#xA;        &amp;lt;link rel=&amp;quot;Shortcut Icon&amp;quot; href=&amp;quot;../imgs/favicon48.ico&amp;quot;&amp;gt;  # 网页小图标&#xA;        &amp;lt;link rel=&amp;quot;Bookmark&amp;quot; href=&amp;quot;../imgs/favicon48.ico&amp;quot;&amp;gt;                        # 收藏夹小图标&#xA;        &#xA;行为&#xA;    url标准&#xA;        基准url + 相对 url = 完整url&#xA;            http://www.it315.org/index.html#section2%E5%AE%9A%E4%BD%8D%E5%88%B0section2&#xA;                &#xA;        url中空格必须转换为+&#xA;        url中用字符的当前字符集编码在内存中的十六进制格式表示，并在每个字节前加上%&#xA;        如果确信特殊字符不会引起冲突，也可以直接传递给服务器，如汉字。也可以一部分编码，一部分不编码，如中&amp;amp;国 就是 中%26国&#xA;&#xA;&#xA;    文件下载&#xA;        超链接post提交&#xA;            &amp;lt;form action=&amp;quot;${pageContext.request.contextPath }/downloadFile&amp;quot;        method=&amp;quot;post&amp;quot; enctype=&amp;quot;application/x-www-form-urlencoded&amp;quot;&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;uuidFileName&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;&#xA;                &amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;download(&#39;${fileName}&#39;)&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&#xA;            &amp;lt;/form&amp;gt;                &#xA;            &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&#xA;                function download(fileName) {&#xA;                    $(&amp;quot;:hidden&amp;quot;).val(fileName);&#xA;                    document.forms[0].submit();&#xA;                }&#xA;            &amp;lt;/script&amp;gt;&#xA;    根目录&#xA;        &amp;lt;head&amp;gt;&#xA;        &amp;lt;base href=&amp;quot;http://www.w3school.com.cn/i/&amp;quot; target=&amp;quot;_blank&amp;quot; /&amp;gt;                # href必选, target可选&#xA;                                                                                        ## js中的相对目录也起作用&#xA;        &amp;lt;/head&amp;gt;&#xA;    frameset&#xA;        frameset的例子&#xA;            &amp;lt;frameset rows=&amp;quot;70,*&amp;quot; cols=&amp;quot;*&amp;quot; frameborder=&amp;quot;no&amp;quot; border=&amp;quot;0&amp;quot; framespacing=&amp;quot;0&amp;quot;&amp;gt;&#xA;            &amp;lt;frame src=&amp;quot;head.html&amp;quot; name=&amp;quot;topFrame&amp;quot; scrolling=&amp;quot;No&amp;quot; noresize=&amp;quot;noresize&amp;quot; id=&amp;quot;topFrame&amp;quot; /&amp;gt;&#xA;            &amp;lt;frameset cols=&amp;quot;193,*&amp;quot; frameborder=&amp;quot;no&amp;quot; border=&amp;quot;0&amp;quot; framespacing=&amp;quot;0&amp;quot;&amp;gt;&#xA;                &amp;lt;frame src=&amp;quot;left.html&amp;quot; scrolling=&amp;quot;No&amp;quot; noresize=&amp;quot;noresize&amp;quot; id=&amp;quot;leftFrame&amp;quot; /&amp;gt;&#xA;                &amp;lt;frame src=&amp;quot;main.html&amp;quot; name=&amp;quot;mainFrame&amp;quot; id=&amp;quot;mainFrame&amp;quot; /&amp;gt;&#xA;            &amp;lt;/frameset&amp;gt;&#xA;            &amp;lt;/frameset&amp;gt;&#xA;            &#xA;            # 在head.html 中的标签中添加链接&#xA;            ## &amp;lt;a href=&amp;quot;/a.html&amp;quot; target=&amp;quot;mainFrame&amp;quot;&amp;gt;Frame main.html&amp;lt;/a&amp;gt;&#xA;            ## 就可以使name 为 mainFrame的&amp;lt;frame&amp;gt;窗体刷新&#xA;            &#xA;            # 在src属性后面添加#name，可以跳转到指定名子的框架&#xA;            ## &amp;lt;frame src=&amp;quot;/example/html/link.html#C10&amp;quot;&amp;gt;跳转到link.html页面的：&amp;lt;a name=&amp;quot;C10&amp;quot;&amp;gt;&amp;lt;h2&amp;gt;Chapter 10&amp;lt;/h2&amp;gt;&amp;lt;/a&amp;gt;位置&#xA;            ## 也可以在a标签中设置跳转&amp;lt;a href=&amp;quot;/example/html/link.html#C10&amp;quot; target=&amp;quot;showframe&amp;quot;&amp;gt;带有锚的链接&amp;lt;/a&amp;gt;&#xA;&#xA;        内联框架：iframe 的例子&#xA;            &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&#xA;            function changeUrl(vPageName){&#xA;            var vIfr=document.getElementById(&amp;quot;ifrObj&amp;quot;);&#xA;            vIfr.src=vPageName+&amp;quot;.asp&amp;quot;;&#xA;            }&#xA;            &amp;lt;/script&amp;gt;&#xA;            &amp;lt;iframe id=&amp;quot;ifrObj&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&#xA;            &amp;lt;a href=&amp;quot;javascript:changeUrl(&#39;2&#39;)&amp;quot;&amp;gt;a&amp;lt;/a&amp;gt;&#xA;            &amp;lt;a href=&amp;quot;javascript:changeUrl(&#39;3&#39;)&amp;quot;&amp;gt;b&amp;lt;/a&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;svg&#34;&gt;&#xA;  svg&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#svg&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    scalable vector graphics, 可缩放矢量图形&#xA;    使用xml格式定义图像&#xA;    由w3c定制&#xA;例子&#xA;    &amp;lt;svg xmlns=&amp;quot;http://www.w3.org/2000/svg&amp;quot; version=&amp;quot;1.1&amp;quot;&amp;gt;&#xA;        &amp;lt;rect width=&amp;quot;300&amp;quot; height=&amp;quot;100&amp;quot; style=&amp;quot;fill:rgb(0, 0, 255); stroke-width:1; stroke:rgb(0, 0, 0)&amp;quot;&amp;gt;&amp;lt;/rect&amp;gt;&#xA;            # 矩形&#xA;    &amp;lt;/svg&amp;gt;&#xA;滤镜&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Css</title>
      <link>https://runout.run/docs/pl/markup_language/css/</link>
      <pubDate>Tue, 09 Oct 2018 16:27:24 +0800</pubDate>
      <guid>https://runout.run/docs/pl/markup_language/css/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# cascading style sheet&#xA;层级匹配&#xA;    不同级&#xA;        1. style属性&#xA;        2. style标签&#xA;        3. link标签&#xA;        4. 浏览器中用户自定义样式表&#xA;        5. 浏览器默认样式             # 浏览器对每个元素定义了默认的样式表&#xA;    !important&#xA;        color: black !important&#xA;    同级                            # 评估得出最特殊的样式, 评分相同时，使用最后的&#xA;        1. id值的数目&#xA;        2. 其它属性和伪类的数目&#xA;        3. 元素名和伪元素的数目&#xA;继承&#xA;    部分元素继承父元素样式&#xA;        外观继承&#xA;        布局不继承&#xA;    inherit                         # 指明使用父元素样式&#xA;        border: inherit    &#xA;三种引入方式&#xA;    内联式&#xA;        &amp;lt;div style=&amp;quot;color:#000;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;    嵌入式&#xA;        &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;&#xA;            div {color:#000;}&#xA;        &amp;lt;/style&amp;gt;&#xA;    引用式&#xA;        &amp;lt;link href=&amp;quot;css.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt;&#xA;        @&#xA;            @charset &amp;quot;UTF-8&amp;quot;        # 默认UTF-8, 在import前&#xA;            @import &amp;quot;styles.css&amp;quot;    # 静态引用, 效率比&amp;lt;link&amp;gt;标签慢&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;单位&#34;&gt;&#xA;  单位&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e4%bd%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;颜色&#xA;    名称, 如silver, gray&#xA;    0xffffff&#xA;    rgb(112, 128, 144)&#xA;    rgb(112, 128, 114, 0.4)&#xA;    hsl(120, 100%, 22%)         # 色相(hue), 饱和度(saturation), 明度(lightness)&#xA;    hsl(120, 100%, 22%, 0.4)&#xA;长度&#xA;    绝对单位                      # 只有在打印和设计文档时才用绝对单位&#xA;        cm&#xA;        pt                      # 磅&#xA;        in                      # 英寸&#xA;        mm&#xA;        pc                      # pica 等于12磅&#xA;    相对长度&#xA;        em                      # 元素字号&#xA;        ex                      # 元素字体的&#39;x高度&#39;，字体基线到中线的距离，一般与x的高度相当，大致等于0.5em&#xA;        rem                     # 根元素(html元素)字号&#xA;        px                      # css像素，假定了设备的分辨率为96dpi, 是1英寸的1/96(windows系统标准像素密度, 其它平台浏览器自己转换), css在定义中px是相对单位，但浏览器实现中全是绝对单位&#xA;        %                       # 不是所有元素都可以用, 不同属性中%定义不同，如font-size挂钩继承的font-size值, width挂钩元素包含块的宽度&#xA;    算式                        # css3 未得到广泛支持&#xA;        width: calc(80% - 20px);&#xA;角度&#xA;    deg                         # 度, 0 - 360&#xA;    grad                        # 百分度 0 - 400&#xA;    rad                         # 弧度 0 - 6.28&#xA;    turn                        # 圆周 1 turn = 360 deg&#xA;时间&#xA;    s&#xA;    ms&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;选择器&#34;&gt;&#xA;  选择器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%89%e6%8b%a9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;*                               # 所有元素&#xA;&amp;lt;type&amp;gt;                          # 标签&#xA;.&amp;lt;class&amp;gt;                        # 样式&#xA;#&amp;lt;id&amp;gt;                           # id&#xA;[attr]                          # 属性, 如[title] {}&#xA;[attr=&amp;quot;val&amp;quot;]&#xA;[attr^=&amp;quot;val&amp;quot;]                   # 以val开头&#xA;[attr$=&amp;quot;val&amp;quot;]&#xA;[attr*=&amp;quot;val&amp;quot;]                   # 包含val&#xA;[attr~=&amp;quot;val&amp;quot;]                   # 属性多值有val, 空格隔开&#xA;    [class~=&amp;quot;class2&amp;quot;] {}&#xA;[attr|=&amp;quot;val&amp;quot;]                   # 属性多值有val, - 隔开&#xA;    [lang |=&amp;quot;en&amp;quot;] &#xA;&amp;lt;selector&amp;gt;, &amp;lt;selector&amp;gt;          # 同时匹配&#xA;&amp;lt;selector&amp;gt; &amp;lt;selector&amp;gt;           # 后代&#xA;&amp;lt;selector&amp;gt; &amp;gt; &amp;lt;selector&amp;gt;         # 直接后代&#xA;&amp;lt;selector&amp;gt; + &amp;lt;selector&amp;gt;         # p 之后的第一个兄弟a&#xA;&amp;lt;selector&amp;gt; ~ &amp;lt;selector&amp;gt;         # p 之后所有兄弟a&#xA;&#xA;o-&amp;gt; 伪元素                       # 直接使用匹配所有&#xA;::first-line                    # 块级元素文本首行&#xA;::first-letter                  # 块级元素文本首字母&#xA;:before                         # 之前插入内容&#xA;    {content: &#39;a&#39;}&#xA;:after                          # 之后插入内容&#xA;&#xA;o-&amp;gt; 伪类                         # 直接使用匹配所有&#xA;:root                           # 文档根元素, 总是返回html元素&#xA;:first-child                    # 第一子元素&#xA;    p &amp;gt; span: first-child , p 下面第一个span元素&#xA;:last-child&#xA;:only-child                     # 只有一个子元素的该元素&#xA;:only-of-type                   # 同上但指定类型，直接使用时会匹配更多，因为很多某类型的唯一元素&#xA;:nth-child(n)                   # body &amp;gt; :nth-child(2)&#xA;:nth-last-child(n)&#xA;:nth-of-type(n)&#xA;:nth-last-of-type(n)&#xA;&#xA;o-&amp;gt; UI  伪类&#xA;:enabled                        # 已启用的元素&#xA;:disabled                       # 禁用的元素&#xA;:checked                        # 选中的单选或复选按钮&#xA;:default                        # 默认的元素, 如 &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;, 常和outline属性一起使用&#xA;:valid                          # 输入验证有效的元素&#xA;:invalid&#xA;:in-range                       # 范围内的input元素, 未广泛支持&#xA;:out-of-range&#xA;:required                       # 允许使用required属性的input元素&#xA;:optional                       # 非required&#xA;&#xA;o-&amp;gt; 动态伪类&#xA;:link                           # 未访问的a元素&#xA;:visited                        # 已访问过的a元素&#xA;:hover&#xA;:active                         # 当前激活的元素(鼠标按下)&#xA;:focus                          # 获得焦点的元素&#xA;:not(&amp;lt;selector&amp;gt;)                # a:not([href*=&amp;quot;apress&amp;quot;])&#xA;:empty                          # 无子元素的元素&#xA;:lang(&amp;lt;language&amp;gt;)               # lang属性为指定值&#xA;    :lang(en) 匹配 &amp;lt;a lang=&amp;quot;en-us&amp;quot;&amp;gt;&#xA;:target                         # url hash(片段标识符) 定向id所在的元素&#xA;&#xA;例子&#xA;    o-&amp;gt;&#xA;    span.class2 {}&#xA;&#xA;    o-&amp;gt;&#xA;    body &amp;gt; * &amp;gt; span, tr &amp;gt; th {}&#xA;&#xA;    o-&amp;gt; 计数器&#xA;    body {counter-reset: paracount;}&#xA;    p:before {&#xA;        content: counter(paracount) &amp;quot; &amp;quot;;&#xA;        counter-increment: paracount;&#xA;            # counter-increment: paracount 2; 可以增加2&#xA;    }&#xA;&#xA;    o-&amp;gt;&#xA;    :checked + span&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;属性&#34;&gt;&#xA;  属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;布局&#34;&gt;&#xA;  布局&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%83%e5%b1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;position                        # 默认static, top等属性不起作用&#xA;    static&#xA;    absolute&#xA;    fixed                       # fixed滚动固定&#xA;    relative&#xA;left&#xA;right&#xA;top&#xA;bottom&#xA;&#xA;z-index&#xA;columns                         # 列数和列宽的简写属性&#xA;column-count                    # 多列布局的列数&#xA;    column-fill                 # 列间内容分布方式&#xA;    column-gap                  # 列间隔&#xA;    column-rule                 # 列间规则的简写属性&#xA;    column-rule-color&#xA;    column-rule-style&#xA;    column-rule-width&#xA;    column-span                 # 元素跨列数&#xA;    column-width&#xA;flex-align                      # 弹性盒子布局, 未实现&#xA;    flex-direction&#xA;    flex-order&#xA;    flex-pack&#xA;    -webkit-box-align           # 内容高度小于容器高度时&#xA;        # start(顶边放置), end(底边放置), center(中间放置), baseline, stretch(拉伸元素)&#xA;        -webkit-box-flex        # 元素可伸缩性&#xA;        -webkit-box-pack        # 元素伸缩到最大尺寸(max-width)时怎么做&#xA;            # start(左边放置), end(右边放置), center(中间放置), justify(平均分配到各个元素间)&#xA;        -webkit-box-direction   # 内部盒子排列顺序&#xA;例子&#xA;    o-&amp;gt; 多列布局&#xA;    column-count: 3;&#xA;    column-fill: balance;&#xA;    column-rule: medium solid black;&#xA;    column-gap: 1.5em;&#xA;    column-width: 10em;&#xA;&#xA;    o-&amp;gt; 弹性盒&#xA;    #container {&#xA;        display: -webkit-box;&#xA;        -webkit-box-direction: reverse;&#xA;        -webkit-box-align: end;&#xA;        -webkit-box-pack: justify;&#xA;    }&#xA;    #first {-webkit-box-flex: 3;}&#xA;    #second {-webkit-box-flex: 1;}&#xA;&#xA;    o-&amp;gt; css表格&#xA;    #table {display: table;}&#xA;    div.row {display: table-row;}&#xA;    p {display: table-cell;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;盒模型&#34;&gt;&#xA;  盒模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%92%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;box-sizing                      # 尺寸样式(如width, height)应用到哪部分&#xA;    # content-box, padding-box, border-box, margin-box&#xA;display&#xA;    inline                      # 显示为文本行中的字&#xA;        inline时，忽略width, height, margin属性&#xA;    block                       # 显示为段落, 在垂直方向有所区别&#xA;    inline-block                # 显示为文本行, 整体作为inline, 但内部作为block, 这样认width, height, margin属性&#xA;    list-item                   # 显示为列表项&#xA;    run-in                      # 类型取决于周围元素&#xA;        包含display:block元素，就是block&#xA;        兄弟都是block时，为inline&#xA;        其它都为block&#xA;    compact                     # 为块或标记盒(类list-item), 一般不支持&#xA;    flexbox                     # 弹性盒布局用&#xA;        -webkit-box&#xA;    table                       # 表格布局用&#xA;        inline-table&#xA;        table-caption           # 类似caption&#xA;        table-row-group         # 类似tbody&#xA;        table-header-group      # 类似thead&#xA;        table-footer-group      # 类似tfoot&#xA;        table-row               # 类似tr&#xA;        table-column-group      # 类似colgroup&#xA;        table-column            # 类似col&#xA;        table-cell              # 类似td&#xA;    ruby                        # ruby注释的文本布局用&#xA;        ruby-base&#xA;        ruby-text&#xA;        ruby-base-group&#xA;        ruby-text-group&#xA;    none                        # 元素不可见，不占空间&#xA;float                           # 元素左边界或右边界移动到包含块或另一个浮动盒的边界。其余inline部分流式环绕&#xA;    left, right, none&#xA;clear                           # 左右边界不能挨着另外浮动元素&#xA;    left, right, both, none&#xA;padding&#xA;    padding-bottom&#xA;    padding-left&#xA;    padding-right&#xA;    padding-top&#xA;margin&#xA;    margin-bottom&#xA;    margin-left&#xA;    margin-right&#xA;    margin-top&#xA;height                          # 长度或百分比&#xA;width&#xA;    max-height&#xA;    max-width&#xA;    min-height&#xA;    min-width&#xA;overflow&#xA;    auto                        # 同scroll, 但自动加滚动条&#xA;    hidden                      # 剪掉&#xA;    on-content                  # 移除内容, 已废弃&#xA;    on-display                  # 隐藏内容, 已废弃&#xA;    scroll, visible             # 溢出&#xA;overflow-x&#xA;overflow-y&#xA;&#xA;visibility                      # 元素可见性&#xA;    collapse                    # 不可见，不占据空间, 只能用在表相关内容，如tr, td&#xA;    hidden                      # 不可见，占据空间&#xA;    visible&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;边框&#34;&gt;&#xA;  边框&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%b9%e6%a1%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;border                          # border: 30px dashed #000&#xA;border-width                    # 可以是长度值, 百分比, thin, medium, thick &#xA;    border-width: 15px 5px 15px 5px&#xA;border-style&#xA;    none 默认&#xA;    dashed 破折线&#xA;    dotted 圆点&#xA;    double 双线&#xA;    groove 槽线&#xA;    inset 内嵌效果&#xA;    outset 外凸效果&#xA;    ridge 脊线&#xA;    solid 实线&#xA;&#xA;    border-style: solid dotted dashed double 定义了上、右、下、左的样式&#xA;    border-style: none的时候，边框其它属性无意义&#xA;border-color&#xA;    blue rgb(25%, 35%, 45%) #909090 red;&#xA;border-image                    # 不广泛支持&#xA;    border-image-outset&#xA;    border-image-repeat&#xA;        stretch 拉伸&#xA;        repeat 平铺&#xA;        round 不截断下拉伸&#xA;        space不截断下图片间保留间距平铺&#xA;    border-image-slice&#xA;    border-image-source&#xA;    border-image-width&#xA;&#xA;    o-&amp;gt;&#xA;    -webkit-border-image, -moz-border-image, -o-border-image&#xA;    border-image: url(a.png) 30 / 50px round repeat; 九宫格切分长度都为30, 宽度为50, 横round, 竖repeat&#xA;border-left&#xA;    border-left-style&#xA;    border-left-color&#xA;    border-left-width&#xA;border-right&#xA;    border-right-color&#xA;    border-right-style&#xA;    border-right-width&#xA;border-top&#xA;    border-top-style&#xA;    border-top-color&#xA;border-top-width&#xA;border-top-left-radius&#xA;    border-top-left-radius: 20px 15px; x半径20, y半径15&#xA;border-top-right-radius&#xA;border-bottom&#xA;    border-bottom-style&#xA;    border-bottom-width&#xA;    border-bottom-color&#xA;    border-bottom-left-radius&#xA;    border-bottom-right-radius&#xA;border-radius&#xA;    border-radius: 20px / 15px;&#xA;    border-radius: 50% 20px 25% 5em / 25% 15px 40px 55%&#xA;&#xA;box-shadow&#xA;    box-shadow: hoffset voffset blur spread color inset&#xA;    水平偏移量, 正向右，负向左。垂直偏移量，正向下，负向上。模糊值。阴影延伸半径，正向各方向延伸，负缩小。颜色。内嵌阴影&#xA;    可设置多组阴影，用, 隔开&#xA;outline                         # 轮廓不属于页面，不影响布局, &amp;lt;颜色&amp;gt; &amp;lt;样式&amp;gt; &amp;lt;宽度&amp;gt;&#xA;    outline-color&#xA;    outline-offset              # 距元素边框边缘的偏移量&#xA;    outline-style               # 同border-style&#xA;    outline-width               # 同border-width&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;背景&#34;&gt;&#xA;  背景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%83%8c%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 不继承&#xA;background                      # background: &amp;lt;background-color&amp;gt; &amp;lt;background-position&amp;gt; &amp;lt;background-size&amp;gt; &amp;lt;background-repeat&amp;gt; &amp;lt;background-origin&amp;gt; &amp;lt;background--clip&amp;gt; &amp;lt;background-attachment&amp;gt; &amp;lt;background-image&amp;gt;&#xA;background-attachment           # 背景附着方式&#xA;    fixed 固定到视窗上, 不随文字滚动&#xA;    local 随文字滚动&#xA;    scroll 固定到元素上(使用浏览器的滚动条), 不随文字滚动&#xA;background-color                # 原点在border外边缘&#xA;    函数&#xA;        linear-gradient(transparent, rgba(0, 0, 0, 0.1) 20%, rgba(0, 0, 0, 0.5) 65%, rgba(0, 0, 0, 0.66))&#xA;            # 线性渐变 &#xA;background-image                # 原点在padding外边缘，也就是border内边缘&#xA;    background-image: url(&amp;quot;bg.jpg&amp;quot;)&#xA;background-position             # 起始位置, 可以是长度, top, left, right ,bottom, center, 第一个值控制垂直位置, 第二个值控制水平位置&#xA;    0px 0px                     # 左上偏移0, 0    &#xA;    right ？                    # 位置在右边显示&#xA;    left ？                     # 位置在左连显示(默认)&#xA;    ？ bottom&#xA;    center center               # 位置在中间显示、内容从中间开始显示(默认)&#xA;    ? top                       # 内容从上开始显示&#xA;background-repeat&#xA;    no-repeat&#xA;    repeat 水平和垂直同时平铺&#xA;    repeat-x 水平平铺&#xA;    repeat-y &#xA;    space 水平或垂直平铺, 统一间距,不截断, round 水平或垂直拉伸, 不截断&#xA;background-size                 # 可以长度值或百分比&#xA;    contain 等比缩放, 宽高适应匹配, 不超出容器&#xA;    cover 等比缩放, 宽高最大适应匹配, 可超出容器&#xA;    auto 本身尺寸显示&#xA;background-origin               # 定位显示原点&#xA;    border-box 边框盒子内 &#xA;    padding-box 内边距盒子内&#xA;    content-box 内容盒子内&#xA;background-clip                 # 裁剪, 属性同上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;色彩&#34;&gt;&#xA;  色彩&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%89%b2%e5%bd%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;opacity&#xA;color                           # 前景颜色&#xA;    rgba(255, 255, 255, 0.7)&#xA;user-select                     # 用户不可选择&#xA;filter                          # 滤镜效果, ie8 或之前使用&#xA;    filter:alpha(opacity=50)，同opacity: .5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;文本&#34;&gt;&#xA;  文本&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e6%9c%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;text-decoration                 # node时 a标签没有下划线&#xA;text-indent                     # 首行缩进&#xA;text-align&#xA;    start 语言的起始边界，可能是右&#xA;    end, left, right, center, justify&#xA;text-justify                    # text-align: justify时来指定规则&#xA;    auto&#xA;    none 禁用文本对齐&#xA;    inter-word 空白在单词之间&#xA;    inter-ideograph 中日韩&#xA;    inter-cluster 泰&#xA;    distribute, kashida 草体&#xA;text-transform                  # 转换大小写&#xA;    none, capitalize, uppercase, lowercase&#xA;text-decoration                 # 文本装饰&#xA;    none, underlinenone, overline, line-through, blink&#xA;text-shadow                     # 文本阴影, &amp;lt;h-shadow&amp;gt; &amp;lt;v-shadow&amp;gt; &amp;lt;blur&amp;gt; &amp;lt;color&amp;gt;, 水平偏移, 垂直偏移, 模糊程度, 颜色&#xA;direction                       # 文本对齐&#xA;    ltr, rtl&#xA;word-spacing                    # 词间距&#xA;letter-spacing # 字母间距&#xA;white-space&#xA;    normal 空白被压缩，文本行自动换行&#xA;    nowrap 空白压缩，文本行不换行&#xA;    pre 空白不压缩, 换行符换行&#xA;    pre-line 空白压缩，自动换行或换行符换行&#xA;    pre-wrap 空白不压缩, 自动换行或换行符换行&#xA;line-height                     # 行高, 百分比，长度&#xA;word-wrap                       # 行超距单词截断&#xA;    normal 溢出&#xA;    break-word&#xA;@font-face                      # 指定web字体, woff得到最广泛支持, 在@font-face中定义，font-family中使用&#xA;    @font-face {&#xA;        font-family: &#39;MyFont&#39;;&#xA;        font-style: normal;&#xA;        font-weight: normal;&#xA;        src: url(&#39;http://a/MyFont.woff&#39;)&#xA;    }&#xA;font                            # &amp;lt;font-style&amp;gt; &amp;lt;font-variant&amp;gt; &amp;lt;font-weight&amp;gt; &amp;lt;font-size&amp;gt; &amp;lt;font-family&amp;gt;&#xA;    简写属性&#xA;        font-family             # serif, sans-serif, monospace, cursive, fantasy&#xA;            font-family: MyFont, cursive&#xA;        font-style              # normal, italic, oblique&#xA;font-variant                    # normal, small-caps&#xA;    font-weight                 # bold, bolder, lighter&#xA;    font-size&#xA;        xx-small 浏览器决定的大小&#xA;        x-small, small, medium, large, x-large, xx-large&#xA;        smaller 相对父元素字体的大小&#xA;        larger, &amp;lt;length&amp;gt;, &amp;lt;%&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;列表样式&#34;&gt;&#xA;  列表样式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%97%e8%a1%a8%e6%a0%b7%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;list-style                      # &amp;lt;list-style-type&amp;gt; &amp;lt;list-style-position&amp;gt; &amp;lt;list-style-image&amp;gt;&#xA;    list-style-type             # 列表项前标记&#xA;        none, box, check, circle, diamond, disc, dash, square, decimal, binary, lower-alpha, upper-alpha&#xA;    list-style-image            # 图片作为列表标记&#xA;    list-style-position         # 相对于内容框的位置&#xA;        inside 内容框内部&#xA;        outside 外部&#xA;vertical-align                  # 垂直对齐（文字不行）&#xA;&#xA;cursor&#xA;    auto ：标准光标&#xA;    default ：标准箭头&#xA;    hand ：手形光标&#xA;    wait ：等待光标&#xA;    text ：I形光标&#xA;    vertical-text ：水平I形光标&#xA;    no-drop ：不可拖动光标&#xA;    not-allowed ：无效光标&#xA;    help ：?帮助光标&#xA;    all-scroll ：三角方向标&#xA;    move ：移动标&#xA;    crosshair ：十字标 &#xA;    pointer&#xA;    e-resize n-resize nw-resize w-resize s-resize se-resize sw-resize ne-resize&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;表格样式&#34;&gt;&#xA;  表格样式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e6%a0%bc%e6%a0%b7%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;border-collapse                 # 相邻单元格边框样式&#xA;    separate 默认，重复画框&#xA;    collapse 合并边框&#xA;border-spacing                  # 相邻单元格边框距离&#xA;table-layout                    # 单元格行列的算法规则&#xA;    auto&#xA;    fixed 由表格自身样式和每列width属性决定布局[无则设等间距]，由第一行决定列宽，以下行内容自动换行&#xA;caption-side                    # 表格标题的位置&#xA;    top, bottom&#xA;empty-cells                     # 是否显示表格中空单元格&#xA;    hide&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;计数器&#34;&gt;&#xA;  计数器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e6%95%b0%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;counter-reset                   # 用于有序列表&#xA;counter-increment&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;动画&#34;&gt;&#xA;  动画&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e7%94%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    本质是增强过渡&#xA;@keyframes&#xA;    指定一个以上关键帧&#xA;    只在过程中有效，动画结束后即使仍hover, 也返回初始状态&#xA;animation&#xA;    动画，动画完后回到初始状态。想停留在结束状态用过渡。&#xA;    可以用在初始布局中&#xA;    通过keyframe显式控制， 可重用&#xA;    &amp;lt;animation-name&amp;gt; &amp;lt;animation-duration&amp;gt; &amp;lt;animation-timing-function&amp;gt; &amp;lt;animation-delay&amp;gt; &amp;lt;animation-iteration-count&amp;gt;&#xA;        只是模拟属性值改变来实现动画，动画结束后属性无变化&#xA;        可以应用到页面的初始布局中去，而transform只能应用在动作上&#xA;&#xA;    animation-delay             # 延迟，可以指定多个值，对应transition-property中的多个属性&#xA;    animation-direction         # 重复播放时播放方向&#xA;        normal 每次向前播放&#xA;        alternate 先向前，再反向，相当于animation-iteration-count: 2&#xA;    animation-duration          # 持续时间, 可多值&#xA;    animation-iteration-count   # 循环次数&#xA;        infinite                # 无休止交替播放&#xA;    animation-name              # 关键帧集合名称，可多个&#xA;    animation-play-state        # 动画状态, js中ele.style.webkitAnimationPlayState = &#39;paused&#39;&#xA;        paused                  # 停止&#xA;        playing                 # 开始播放&#xA;    animation-timing-function   # 关键帧时间插值函数&#xA;        normal                  # 每次重复向前播放&#xA;        alternate               # 先向前播放，再反向播放，相当于animation-iteration-count: 2&#xA;transform                       # 变换，动画结束后属性有变化&#xA;    -moz-transform: rotate(-45deg) scaleX(1.2)              # 逆时针旋转45度, 延x轴缩放到1.2倍&#xA;    函数&#xA;        translate               # 水平、垂直或两个方向 平衡。长度，百分比&#xA;        translateX&#xA;        translateY&#xA;        scale                   # 数&#xA;        scaleX&#xA;        scaleY&#xA;        rotate                  # 角度&#xA;        skew                    # 倾斜, 角度&#xA;        skewX&#xA;        skewY&#xA;        matrix                  # 6个参数。自定义变换, 由于z缩放未被实现，后两个参数省略&#xA;    transform-origin            # 变换的起点，默认是元素中心点&#xA;        transform-origin right top;&#xA;        长度，百分比，left center right, top center, bottom&#xA;&#xA;transition                      # &amp;lt;transition-property&amp;gt; &amp;lt;transition-duration&amp;gt; &amp;lt;transition-timing-function&amp;gt; &amp;lt;transition-delay&amp;gt;, 可以作为初始状态，也可以过渡&#xA;    transition-delay            # 开始之间延迟时间, ms&#xA;    transition-duration         # 持续时间, ms&#xA;    transition-property         # 应用过渡的多个属性&#xA;    transition-timing-function              # 时间函数&#xA;        ease 默认&#xA;        linear&#xA;        ease-in&#xA;        ease-out&#xA;        ease-in-out&#xA;        cubic-bezier 指定自定义曲线&#xA;&#xA;    o-&amp;gt;&#xA;    -webkit-&#xA;    transition: .2s background-cololr&#xA;    transition: .2s all&#xA;示例&#xA;    o-&amp;gt; 过渡&#xA;    #banana {&#xA;        font-size: large;&#xA;        border: medium solid black;&#xA;        -webkit-transition-delay: 10ms;&#xA;        -webkit-transition-duration: 250ms;&#xA;            # 反向过渡&#xA;    }&#xA;    #banana:hover {&#xA;        font-size: x-large;&#xA;        border: medium solid white&#xA;        background-color: green;&#xA;        color: white;&#xA;        padding: 4px;&#xA;        -webkit-transition-delay: 100ms;&#xA;        -webkit-transition-property: background-color, color, &#xA;            padding, font-size, border;&#xA;        -webkit-transition-duration: 500ms;&#xA;        -webkit-transition-timing-function: linear;&#xA;    }&#xA;&#xA;    o-&amp;gt; 动画&#xA;    #banana:hover {&#xA;        -webkit-animation-delay: 100ms;&#xA;        -webkit-animation-duration: 500ms;&#xA;        -webkit-animation-iteration-count: infinite;&#xA;        -webkit-animation-timing-function: linear;&#xA;        -webkit-animation-name: &#39;GrowShrink&#39;;&#xA;        -webkit-animation-direction: alternate;&#xA;    }&#xA;    @-webkit-keyframes GrowShrink {&#xA;        from {&#xA;            # 可以用0%替代&#xA;            font-size: xx-small;&#xA;            background-color: red;&#xA;        }&#xA;        50% {&#xA;            # 定义了变化的速率，可以用0%, 100%代替from和to子句&#xA;            background-color: yellow;&#xA;            padding: 1px;&#xA;        }&#xA;        to {&#xA;            # 可以用100%替代&#xA;            font-size: x-large;&#xA;            border: medium solid white;&#xA;            background-color: green;&#xA;            color: white;&#xA;            padding: 4px;&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; 变换&#xA;    #banana {&#xA;        -moz-transform: rotate(-45deg) scale(1.2);&#xA;        -moz-transform-origin: right top;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;典型问题&#34;&gt;&#xA;  典型问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b8%e5%9e%8b%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;垂直居中&#xA;    line-height&#xA;        .content {&#xA;            height: 100px;&#xA;            line-height: 100px;&#xA;        }&#xA;    vertical-align&#xA;        .wrapper {display: table;}&#xA;        .cell {&#xA;            display: table-cell;&#xA;            vertical-align: middle;&#xA;        }&#xA;    position&#xA;        .wrapper {position: relative}&#xA;        .content {&#xA;            left: 50%;&#xA;            top: 50%;&#xA;            transform: translate(-50%, -50%)&#xA;        }&#xA;    position&#xA;        .content {&#xA;            position: absolute;&#xA;            top: 0;&#xA;            bottom: 0;&#xA;            left: 0;&#xA;            right: 0;&#xA;            margin: auto;&#xA;        }&#xA;    float填充一半&#xA;        .floater {&#xA;            float: left;&#xA;            height: 50%;&#xA;            margin-bottom: -120px;&#xA;        }&#xA;        .content {&#xA;            clear: both;&#xA;            height: 240px;&#xA;            position: relative;&#xA;        }&#xA;图标切分&#xA;    background-image: url(/base/icons.png);&#xA;    background-repeat: no-repeat;&#xA;    background-position: -910px -74px;&#xA;内部元素自动高度&#xA;    .parent {&#xA;        overflow: hidden;&#xA;    }&#xA;    .parent .children {&#xA;        overflow: hidden;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;stylus&#xA;    # css扩展语言, 创建富有表现力的css, 比less更强大, 类似jquery的css引擎, 支持node.js&#xA;compass&#xA;    # 编译到css，是sass的toolkit, 是用ruby开发的&#xA;blueprint&#xA;    # css框架&#xA;sass&#xA;    # css扩展语言&#xA;caniuse.com&#xA;    # 在线浏览器兼容性测试&#xA;modernizr.com&#xA;    # 测试特性支持是否到位&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;less&#34;&gt;&#xA;  less&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#less&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    less于css如jquery于js&#xA;安装使用&#xA;    npm install -g less&#xA;命令&#xA;    lessc styles.less &amp;gt; styles.css                # 编译&#xA;                                # -x 压缩  --clean-css 更复杂的压缩&#xA;语法&#xA;模板&#xA;    {% %}&#xA;变量&#xA;    @color: #4D926F;&#xA;    #header{&#xA;        color: @color&#xA;    }&#xA;    h2{&#xA;        color: @color&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Elixir</title>
      <link>https://runout.run/docs/pl/elixir/</link>
      <pubDate>Tue, 09 Oct 2018 16:24:04 +0800</pubDate>
      <guid>https://runout.run/docs/pl/elixir/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;跑在erlang虚拟机上&#xA;与erlang相同，actor称作进程, 是比线程更轻量的概念&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 元组&#xA;{:foo, &amp;quot;this&amp;quot;, 42}&#xA;        # 三元组&#xA;&#xA;o-&amp;gt; actor&#xA;defmodule Talker do&#xA;def loop do&#xA;    receive do&#xA;    {:greet, name, age} -&amp;gt; IO.puts(&amp;quot;Hello #{name}&amp;quot;)&#xA;    {:shutdown} -&amp;gt; exit(:normal)&#xA;    end&#xA;    loop&#xA;end&#xA;end&#xA;&#xA;pid = spawn(&amp;amp;Talker.loop/0)&#xA;send(pid, {:greet, &amp;quot;Huey&amp;quot;, 16})&#xA;sleep(1000)&#xA;&#xA;Process.flag(:trap_exit, true)&#xA;pid = spawn_link(&amp;amp;Takler.loop/0)&#xA;send(pid, {:shutdown})&#xA;receive do&#xA;{:EXIT, ^pid, reason} -&amp;gt; IO.puts(&amp;quot;Talker has exited (#{reason})&amp;quot;)&#xA;end&#xA;&#xA;o-&amp;gt; 有状态的actor&#xA;        # 递归&#xA;defmodule Counter do&#xA;def start(count) do&#xA;    spawn(__MODULE__, :loop, [count])&#xA;            # 伪变量__MODULE__, 是当前模块的名字&#xA;end&#xA;def next(counter) do&#xA;    send(counter, {:next})&#xA;end&#xA;def loop(count) do&#xA;    receive do&#xA;    {:next} -&amp;gt;&#xA;        IO.puts(&amp;quot;Current count: #{count}&amp;quot;)&#xA;        loop(count + 1)&#xA;    end&#xA;end&#xA;end&#xA;counter = spawn(Counter, :loop, [1])&#xA;send(counter, {:next})&#xA;&#xA;counter = Countre.start(42)&#xA;Counter.next(counter)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Go</title>
      <link>https://runout.run/docs/pl/go/</link>
      <pubDate>Tue, 09 Oct 2018 16:10:44 +0800</pubDate>
      <guid>https://runout.run/docs/pl/go/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    易工程化&#xA;        简单性而不方便性，避免工程复杂性乘法增长            # 某部分变复杂，增加其他部分的复杂性(功能、选项、配置)&#xA;            没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储&#xA;        类型系统，无类型风格&#xA;        自然方式工作&#xA;            不显式初始化和隐式构造函数&#xA;            集合直接持有元素&#xA;        标准库避免配置和解释     # 自带电池&#xA;        项目结构简单&#xA;        编译检查代码格式&#xA;    csp(communicating sequential process)并发，变长栈运行轻量线程&#xA;    编译为本地机器码        # 像c一样，所以又叫类c语言&#xA;        编译快&#xA;            引用包名在头&#xA;            包依赖有向无环，可独立和并行编译&#xA;            目标文件包含依赖包信息&#xA;    强静态类型&#xA;    有gc&#xA;    变长栈，最小2kb, 最大1GB&#xA;    大厂支持&#xA;历史&#xA;    2007年设计，受影响于Alef(CSP系列), Oberon-2(ALGOL60, Modula-2系列), C&#xA;        # 目的解决google许多复杂性激增的软件系统&#xA;    2009年发布, 作者是Robert Griesemer, Rob Pike, Ken Thompson&#xA;    2012年1.0&#xA;并发编程特点&#xA;    语言层面关键字&#xA;    例程&#xA;        流程控制: csp       # channel为一等公民&#xA;        通信方式: promise-future, channel, event&#xA;    高效调度模型(调度器，资源占用小)&#xA;        O(1)的调度&#xA;        一进程可支撑上百万例程,5kib/goroutine的开销,&#xA;            变长栈存goroutine&#xA;编译&#xA;    CGO_ENABLED=0&#xA;        # 静态链接，不跨平台&#xA;    初始化&#xA;        包级别初始化在main前&#xA;        局部变量在函数执行时&#xA;配置&#xA;    GOROOT                  # go安装目录&#xA;    GOPATH                  # 包目录, 默认要有go的bin目录&#xA;    GOBIN                   # 当前bin目录&#xA;    GO15VENDOREXPERIMENT    # 依赖目录&#xA;    GOOS                    # 指定操作系统, 如android, linux, darwin, windows&#xA;    GOARCH                  # 处理器架构，如amd64, 386, arm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;go&#xA;    help&#xA;        importpath          # 说明 指定代码托管网站版本协议&#xA;        gopath              # vendor怎么使用&#xA;        list                # go list 说明&#xA;    version&#xA;    env                     # 打印go环境信息&#xA;    run                     # 编译并运行&#xA;        -race               # 检查运行中的竞态冲突并报告&#xA;    build                   # 库被舍弃，main包编译成二进制执行文件, 会检测mod&#xA;        go build gopl.io&#xA;        go build x.go&#xA;        -race&#xA;        -i                  # 编译到指定位置&#xA;    install                 # 编译安装, 会检测mod&#xA;    clean                   # 清理build产生的文件&#xA;        -c                  # 清理.test文件&#xA;        -i                  # 清理生成的可执行文件&#xA;        -r                  # 包括依赖包的结果文件&#xA;    doc&#xA;        命令&#xA;            go doc go/build&#xA;        包&#xA;            go doc html/template&#xA;        包成员&#xA;            go doc time.Since&#xA;        方法&#xA;            go doc http.ListenAndServe&#xA;    fmt                     # 代码格式化&#xA;&#xA;    get                     # 下载依赖, 默认目录是GOPATH下的pkg。下载后自动install&#xA;        go get gopl.io/...  # ...通配&#xA;        get gopl.io@2       # 指定mod版本号&#xA;        -u                  # 更新到mod最新版本&#xA;        -v                  # 查看进度&#xA;    list                    # 列出指定代码包的信息&#xA;        go list ...         # ...通配&#xA;        go list ...xml...&#xA;        -json hash          # 输出json格式完整信息&#xA;        -f                  # 使用go模板&#xA;    fix                     # 升级旧代码成新版本代码&#xA;    vet                     # 检查静态错误&#xA;&#xA;    test&#xA;        # go test -cover -args -config config_it.toml -test.run &amp;quot;TestA&amp;quot;&#xA;        # 执行当前目录下所有_test.go结尾的文件&#xA;        -race&#xA;&#xA;        -file               # 可省略，测试单个文件, 如go test test_a.go a.go a.pb.go&#xA;                            ## 测试单个文件需要引入原文件&#xA;        -args               # 运行时参数&#xA;        -run TestFoo        # 正则表达式匹配方法，NONE表示不匹配。如&amp;quot;^TestFoo&amp;quot;, &amp;quot;F|F1&amp;quot;&#xA;        -test.run &amp;quot;TestCreate&amp;quot;                      # 同上&#xA;        -v                  # 每个测试用例的名称和时间&#xA;        -bench=&amp;quot;.*&amp;quot;         # 正则匹配benchmark测试函数&#xA;        -benchmem           # 显示benchmark测试时内存分配&#xA;        --cpuprofile=cpu.prof                       # 生成cpu分析文件，使用多个标记时(如cpu, mem), 一个类别会覆盖另一个。性能剖析启用时, go test不丢弃其临时可执行文件&#xA;        --blockprofile=block.out                    # 生成阻塞分析文件&#xA;        --memprofile=mem.prof                       # 生成内存分析文件&#xA;        -c                  # 生成可执行的二进制文件，名为x.test，它用来生成状态图&#xA;        -cover              # 显示覆盖语句汇总信息&#xA;        -coverprofile=c.out # 生成日志文件c.out，记录语句覆盖信息&#xA;        -covermode=count    # 语句覆盖信息不用bool而用count累加&#xA;&#xA;    tool&#xA;        cover               # 测试覆盖率工具使用方法&#xA;            go tool cover -html=c.out               # html分析c.out&#xA;        pprof               # 交互式访问概要文件&#xA;            go tool pprof module1.test cpu.prof                   # 性能测试状态图, 参数是可执行文件和剖析日志&#xA;            -test           # 文本格式&#xA;            -nodecount=10   # 限制输出10行&#xA;            -web            # 渲染有向图web显示&#xA;        fix                 # 同go fix&#xA;        vet                 # 同go vet&#xA;        cgo                 # 生成能够调用c语言代码的go源码文件&#xA;        compile&#xA;            -help           # 可传给编译器的参数&#xA;    mod&#xA;        init packageName1   # 生成go.mod&#xA;        download            # 下载mod&#xA;        tidy                # 下载缺少，删除多余&#xA;        edit                # 编辑go.mod&#xA;        graph               # 打印依赖图&#xA;        vendor              # 复制依赖到vendor&#xA;        verify              # 验证mod&#xA;        why                 # 打印依赖原因&#xA;godoc                       # 提供html页面&#xA;    -http=:6060             # 运行本地帮助网站&#xA;    -analysis=type          # 提供静态分析结果&#xA;        -analysis=pointer&#xA;gofmt&#xA;golint                          # 检查风格&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;常用&#34;&gt;&#xA;  常用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;go mod 配置&#xA;    环境变量&#xA;        GO111MODULE&#xA;            off                     # 总关闭&#xA;            on                      # 总开启&#xA;            auto                    # 默认，有go.mod开启&#xA;    路径&#xA;        $GOPATH/pkg/mod             # 保存多版本依赖, 被多项目引用&#xA;        go.mod                      # 被go命令维护, 融入了go命令的各个模块&#xA;        go.sum                      # 记录lock&#xA;    依赖加载顺序&#xA;        最新release tag&#xA;        最新commit&#xA;    命令&#xA;        go mod vendor&#xA;代理&#xA;    go env -w GOPROXY=https://goproxy.cn,direct&#xA;包升级&#xA;    go list -m -u all               # 检查可以升级的package&#xA;    go get -u need-upgrade-package  # 升级&#xA;性能测试&#xA;    go test -bench=.  --cpuprofile=cpu.prof --memprofile=mem.prof -config ../conf/config_lc.toml -test.run TestCreateType&#xA;覆盖率&#xA;    go test -cover -args -config config.toml -test.run &amp;quot;TestCreate&amp;quot;&#xA;性能分析&#xA;    go tool pprof service.test cpu.prof&#xA;    go-torch -b cpu.prof&#xA;包管理&#xA;    go list -m -u all&#xA;        # 列可升级包&#xA;    go list -u need-upgrade-package&#xA;        # 升级可升级包&#xA;    go get -u&#xA;        # 升级所有依赖&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;glide&#34;&gt;&#xA;  glide&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#glide&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    包管理&#xA;目录&#xA;    glide.yaml&#xA;    glide.lock&#xA;    main.go&#xA;    subpackages&#xA;    vendor&#xA;命令&#xA;    glide&#xA;        init&#xA;            # 扫描代码目录，创建glide.yaml文件，记录所有依赖&#xA;            删除glide.yaml中自己项目本身&#xA;        get&#xA;            # 安装并更新glide.yaml&#xA;            --all-dependencies -s -v github.com/go-redis/redis#5.0.0&#xA;                # --all-dependencies会更新subpackages&#xA;        update&#xA;            # 下载和更新glide.yaml中的所有依赖，放到vendor下&#xA;            # 递归更新&#xA;        install&#xA;            # 依据glide.lock与glide.yaml文件安装特定版本&#xA;            # glide.lock与glide.yaml不同步时，发出警告&#xA;        up&#xA;            # 更新依赖树，重建glide.lock文件&#xA;        name&#xA;            # 查看glide.yaml中依赖名称&#xA;        list&#xA;            # 依赖列表&#xA;        help&#xA;        --version&#xA;glide.yaml&#xA;    package: .&#xA;    import:&#xA;    - package: github.com/go-redis/redis&#xA;    version: 5.0.0&#xA;    repo:git@github.com:go-redis/redis&#xA;常见问题&#xA;    o-&amp;gt; cannot detect vcs&#xA;        glide.lock或vendor依赖旧版本&#xA;            清理glide.lock和vendor, 检查glide.yaml旧版本&#xA;        glide.yaml子目录处理不完善&#xA;            subpackages:&#xA;            - cloudsql&#xA;        glide mirror找不到包&#xA;            glide mirror set a a --vcs git&#xA;                # 改~/.glide/mirrors.yaml文件&#xA;    o-&amp;gt; does not appear to be a git repository&#xA;        加速服务没有项目&#xA;    o-&amp;gt; glide up依赖不是最新&#xA;        ~/.glide/cache中缓存了旧版本&#xA;    o-&amp;gt; cannot find package &amp;quot;.&amp;quot; in&#xA;        glide对非git协议自有域名处理歧义，子目录分析不准确&#xA;            清理缓存&#xA;                ~/.glide/cache/src/包名&#xA;                ~/.glide/cache/info/包名&#xA;            glide.yaml添加repo重定向及subpackages&#xA;                package: github.com/grpc-ecosystem/grpc-gateway&#xA;                repo: git@github.com:grpc-ecosystem/grpc-gateway.git&#xA;                subpackages:&#xA;                - internal&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;govendor&#34;&gt;&#xA;  govendor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#govendor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    包管理&#xA;使用&#xA;    go get -u -v github.com/kardianos/govendor&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;godev&#34;&gt;&#xA;  godev&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#godev&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gv&#34;&gt;&#xA;  gv&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gv&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gvt&#34;&gt;&#xA;  gvt&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gvt&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gvm&#34;&gt;&#xA;  gvm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 版本管理&#xA;命令&#xA;    gvm&#xA;        install go1.5&#xA;        use go1.5&#xA;        list&#xA;        listall&#xA;        implode&#xA;            # 删除所有go版本和gvm本身&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gore&#34;&gt;&#xA;  gore&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gore&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# repl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;go-torch&#34;&gt;&#xA;  go-torch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-torch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 性能火焰图&#xA;go-torch -b cpu.prof&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gf&#34;&gt;&#xA;  gf&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;-v/version&#xA;-h/help&#xA;init&#xA;build&#xA;gen         # 生成模块&#xA;    gen dao&#xA;run&#xA;swagger&#xA;pack&#xA;get&#xA;docker&#xA;mod&#xA;update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;包                              # 路径引用，命名空间&#xA;    不能循环依赖&#xA;    main包                      # 入口包, 产生可执行文件，也可当库导入&#xA;        main()                  # 入口函数&#xA;    包名最好匹配目录名          # 导入路径的最后一段&#xA;    import&#xA;        逐行import或import(多行)&#xA;        import 别名 包路径&#xA;        import &amp;quot;gopkg.in/yaml.v2&amp;quot; 忽略.v2, 包名为yaml&#xA;        import _ &amp;quot;image/png&amp;quot; 空导入&#xA;        可导入相对目录，以.或..开头&#xA;    var和const&#xA;        逐行或var(多行), const(多行)&#xA;    包文件函数&#xA;        init                    # 文件在编译前排序，按依赖顺序和文件名，也是init的调用顺序。init不能调用和引用&#xA;    包依赖排序依次初始化&#xA;    工作空间&#xA;        src&#xA;        bin                     # 编译后的执行文件&#xA;        pkg                     # 编译后的包, 重复使用加快编译&#xA;    vendor目录放本地依赖&#xA;    文档注释影响编译&#xA;        // +build linux darwin                  # linux和darwin才编译&#xA;        // +build ignore                        # 任何时候都不编译&#xA;    内部包                      # 路径有internal的包, 只能被父目录导入&#xA;        net/http/internal/chunked&#xA;注释&#xA;    //或/**/&#xA;    package前写文档注释，可出现在任何文件中，但一个包约定一个&#xA;    doc.go约定为包的扩展文档注释&#xA;命名&#xA;    字母或下划线开头，区分大小写, 不能用关键字&#xA;    关键字: break, default, func, interface, select, case, defer, go, map, struct, chan, else&#xA;        goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return, var&#xA;    首字母大小写决定可见性，大写表示其是导出的&#xA;    go倾向短名称, 驼峰式命名, 缩写全大写或小写&#xA;操作符&#xA;    优先级:&#xA;        * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^    # 可加=, 如*=&#xA;        + - | ^             # 可加=, 如*=&#xA;        == != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;=     # 基本类型都可比较&#xA;        &amp;amp;&amp;amp;&#xA;        ||&#xA;        + -                 # 一元取正负&#xA;    %                       # 只能整数，符号与被除数一致&#xA;    /                       # 整数除，去小数部分。溢出高位丢弃&#xA;    &amp;amp; | ^ &amp;amp;^                # 按位独立&#xA;        &amp;amp;^                  # and not(位清空)右边1清左边为0&#xA;        &amp;amp;                   # and&#xA;        |                   # or&#xA;        ^                   # xor, 前缀表示取反或按位取补(逐位取反)&#xA;    &amp;lt;&amp;lt; &amp;gt;&amp;gt;                   # 注意，有符号数右移按符号位填补空位&#xA;声明定义&#xA;    不能有无用的声明变量&#xA;    var s string            # 未初始化值默认零值，类型和表达式可省一个&#xA;    var s string = &amp;quot;&amp;quot;       # 不推荐&#xA;    var s = &amp;quot;&amp;quot;              # 不推荐&#xA;    s := &amp;quot;&amp;quot;                 # 短变量声明&#xA;&#xA;    var i,j int             # 自动引申变量类型&#xA;    i, j := 0, 1&#xA;    i, j := true, &amp;quot;a&amp;quot;       # 类型可不一致&#xA;    i, err := 0, e          # err声明过(只检测本词法块，外层不算)，声明i, 赋值err。:=要求至少一个声明&#xA;&#xA;    const                   # 编译时计算&#xA;        枚举&#xA;            type Weekday int&#xA;            const (&#xA;                Sunday Weekday = iota               # 值为0&#xA;                Monday&#xA;                ...&#xA;            )&#xA;            const (&#xA;                i T1 = 1 &amp;lt;&amp;lt; iota                    # 值为1, 下值为 1&amp;lt;&amp;lt;1&#xA;                ...&#xA;            )&#xA;        无类型常量&#xA;            只有常量可以无类型&#xA;            无类型常量存大数精度高于基本类型, 算术精度高于机器精度, 至少256位&#xA;            可用于更多表达式，无需转换类型&#xA;            分类&#xA;                布尔: true&#xA;                整数: 0&#xA;                文字符号: &#39;\u0000&#39;&#xA;                浮点数: 0.0&#xA;                复数: 0i&#xA;                字符串: &amp;quot;&amp;quot;&#xA;            const (&#xA;                _ = 1 &amp;lt;&amp;lt; (10 * iota)             # 下值为 1&amp;lt;&amp;lt;(10*1)&#xA;                ...&#xA;            )&#xA;&#xA;&#xA;    type                    # 类型声明&#xA;        type A int          # 底层共类型, 可赋值性，可比较性。可重写String方法让fmt打印时个性化&#xA;        a = A(i)            # 可赋值就可类型转换&#xA;    func&#xA;    变量生命周期&#xA;        包级别是整个程序执行时间&#xA;        局部变量声明时创建，直到不可访问&#xA;    堆栈&#xA;        逃逸变量(函数外保存地址)在堆，局部变量在栈                   # 与变量创建方式无关(new与否), 逃逸需要一次额外内存分配。&#xA;赋值&#xA;    x = 1&#xA;    *p = 1&#xA;    p.name = &amp;quot;&amp;quot;&#xA;    m[key] = 1&#xA;&#xA;    +=&#xA;    i++和i--                # 只能自成一行, 且不能++i, --i&#xA;    _                       # 忽略变量&#xA;    a, b = b, a             # 多重赋值&#xA;&#xA;    v, err = f()&#xA;    v, ok = m[key]          # map查询&#xA;    v, ok = x.(T)           # 类型断言&#xA;    v, ok = &amp;lt;-ch            # 通道接收&#xA;    可赋值性：类型精准匹配，nil赋值任何接口变量或引用变量, 常量更易隐式转换赋值&#xA;        ==和!= 比较，两边要求是可赋值的&#xA;指针                         # 不能运算&#xA;    &amp;amp;获取地址&#xA;    *获取指针&#xA;语句&#xA;    变长参数&#xA;        f(s...)&#xA;    for&#xA;        for i, j := 0, 1; i &amp;lt; n; i++ {}&#xA;        for i &amp;lt; n {}&#xA;        for {}&#xA;        for index, value := range slice1{}&#xA;        for key, value := range map1 {}&#xA;        for range s{}&#xA;    if&#xA;        if i &amp;lt; n {} else if i &amp;lt; m {} else {}&#xA;        if err := f(); err != nil {}&#xA;    switch&#xA;        switch {                # 无标签(tagless), 相当于switch true,&#xA;        case x &amp;gt; 0:             # fallthrough可贯穿, 可用控制流标签&#xA;        }&#xA;        switch i := 0 {}        # switch true&#xA;        switch i++ { }          # switch true&#xA;        switch f() {}           # switch true&#xA;&#xA;        switch i {&#xA;        case 0:&#xA;        case 1:&#xA;        default:                # default可在任何地方&#xA;        }&#xA;&#xA;        switch t.(type) {                   # 类型匹配, 无匹配类型会panic, 不能用fallthrough&#xA;        case nil:&#xA;        case int, uint;&#xA;        case bool:&#xA;        case string:&#xA;        default:&#xA;        }&#xA;        switch x := x.(type) {}&#xA;    select                                  # channel用select, 值用switch。一直等待直到匹配(default会直接匹配)。多情况匹配随机选择。不能用fallthrough&#xA;        select {&#xA;        case &amp;lt;-ch1:&#xA;        case x := &amp;lt;-ch2:&#xA;        case ch3 &amp;lt;- y:&#xA;        default:&#xA;        }&#xA;&#xA;        o-&amp;gt; 超时&#xA;        select {&#xA;        case &amp;lt;-time.After(10*time.Second):&#xA;        case &amp;lt;-ch:&#xA;        }&#xA;&#xA;        o-&amp;gt; 自发自接&#xA;        for i := 0; i &amp;lt; 10; i++{&#xA;            select {&#xA;            case x := &amp;lt;-ch:&#xA;            case ch &amp;lt;- i:&#xA;            }&#xA;        }&#xA;&#xA;        o-&amp;gt; 标签&#xA;        c := make(chan struct{},2)&#xA;        label1:&#xA;        for {&#xA;            select {&#xA;            case c&amp;lt;- struct{}{}:&#xA;                fmt.Println(1)&#xA;            case &amp;lt;-c:&#xA;                fmt.Println(2)&#xA;                break                       # 无标签break跳出当前select块&#xA;                    # break label&#xA;                    # goto label2&#xA;                    # return&#xA;            default:&#xA;                fmt.Println(3)&#xA;            }&#xA;        }&#xA;        label2:&#xA;        ...&#xA;    控制流标签&#xA;        break, continue, goto   # 可标签化, 如break Label1&#xA;作用域&#xA;    词法块：语法块(block)(大括号), 隐式块(未在大括号中的声明, 如if中)&#xA;        全局块                   # 内置&#xA;        包级别                   # 函数外的声明&#xA;        文件级别                  # 导入的包&#xA;        局部&#xA;    控制流标签作用域是外层函数&#xA;    覆盖&#xA;        x := 1&#xA;        for {&#xA;            x := x+1&#xA;            if .. {&#xA;                x := x+1        # 这里值的x是最外层x&#xA;            }&#xA;        }&#xA;    if声明的变量(隐式词法块)，else中可见&#xA;        if v, err := f(); err != nil {      # else中处理非err逻辑&#xA;            return err&#xA;        } else {&#xA;            v.close()&#xA;        }&#xA;    包中声明作用域无顺序，可递归    # 常量、变量不可以引用自己&#xA; 函数&#xA;    字面量&#xA;        var func()                   # 声明&#xA;        func f(i int) int {}&#xA;        func f(i, j int) (int, error){}&#xA;        func f() (r int){}&#xA;        func f(vals ...int) {}       # 变长函数, 只放最后, vals是slice&#xA;            f(vals...)&#xA;    一等公民&#xA;    函数签名，即函数类型，包括形参列表和返回列表, 命名不影响&#xA;    未定义时为nil, 不可比较&#xA;    值传递, 不能指定默认值&#xA;    函数返回多值, 可return, 可做传入参数&#xA;    返回值有命名，可祼返回(不在return后写参数)&#xA;    错误&#xA;        v, ok := f()                  # 错误只一种情况&#xA;        v, err := f()                 # 错误信息会串联，避免首字母大写和换行&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;    匿名函数用字面量定义，包含外层词法环境(闭包)&#xA;        递归要先声明，再赋值定义&#xA;        重定义变量&#xA;        for _, dir := range dirs() {&#xA;            dir := dir                      # for块作用域变量共享位置，重定义dir每次一个位置&#xA;            dirs = append(dirs, func(){     # 匿名函数引用外层变量，却不一定同步执行&#xA;                os.RemoveAll(dir)&#xA;            })&#xA;        }&#xA;方法&#xA;    字面量&#xA;        func (t T) f(){}                    # t值传递, 方法名唯一, 方法名不能用字段名&#xA;        func (t *T) f(){}                   # t引用传递&#xA;&#xA;        type Path []Point                   # 别名赋方法(不能是指针和接口), 可覆盖原类型方法&#xA;        func (p *Path)f(){}&#xA;    方法可在任何类型(除指针和接口), 如函数&#xA;    变量与变量指针都可直接调方法，编译器隐式取地址或取指针&#xA;        P{1}.f()                            # 编译器不报错但运行出错, f()声明成引用传递, 但P{1}.时, 内存地址还未分配, 即还没有*P, 就无法调f()&#xA;    有引用传递方法时，避免值传递方法，会产生多例&#xA;    值为nil时可调方法&#xA;    方法可赋值&#xA;        f := t.f&#xA;        f(t.f)&#xA;    组合&#xA;        结构体匿名成员方法可如属性般直接调用&#xA;        匿名成员是引用时，多结构体可组合同一成员对象&#xA;        多匿名成员方法冲突时，调用时编译报错&#xA;        可给未命名结构体加方法&#xA;            t = struct{&#xA;                sync.Mutex&#xA;                v int&#xA;            }&#xA;            t.Lock(); t.v++; t.Unlock()&#xA;接口&#xA;    字面量&#xA;        type I interface {&#xA;            f()&#xA;        }&#xA;        type I2 interface {                  # 接口组合&#xA;            I&#xA;        }&#xA;&#xA;        v := t.(T)                           # 断言，失败panic&#xA;        v, ok := t.(T)                       # 失败不panic, ok=false&#xA;    隐式实现，方法匹配即可(接口即约定)           # 鸭子&#xA;    指针方法匹配接口，对接口赋值时要传指针&#xA;    interface{}为空接口类型，可赋值任何类型&#xA;    实现&#xA;        除了接口的定义类型，还包含动态类型(Type) + 动态值(Value)               # 编译时不知道，生成代码在运行时动态分发&#xA;            零值，是动态类型和动态值都是nil&#xA;                动态类型是nil, 指的是它为接口本身类型&#xA;                i = nil会设置接口为零值&#xA;            ==和!=比较&#xA;                动态值都为nil相等&#xA;                动态类型和动态值都相等，才相等&#xA;                    i = new(T); i != nil&#xA;                动态类型一致，动态值不可比较(如slice), 则panic                # 非平凡&#xA;                格式化输出%T拿到动态类型&#xA;    断言&#xA;        变定义类型, 动态类型和动态值不变&#xA;        空接口断言总失败&#xA;        断言成接口，使用公共功能&#xA;            v := t.(I)&#xA;            v.Common()&#xA;    风格&#xA;        强调功能相似性                         # 子类型多态(subtype polymorphism)&#xA;        联合再断言区分                         # 可识别联合(discriminated union), 特设多态(ad hoc polymorhpism)&#xA;            switch t.(type) {}&#xA;关键字&#xA;    defer fn                                 # 后进先出, return或panic后调用&#xA;        defer func(i){...}(1)&#xA;        return、出参赋值、defer顺序            # 先赋值，再defer，再return&#xA;            func f() (i int) {&#xA;                defer func(){&#xA;                    i++&#xA;                }&#xA;                return 0          # 相当于 i=0; i++; return&#xA;            }&#xA;    go fn&#xA;    异常&#xA;        panic()&#xA;            日志包括值(interface{}), 调用栈&#xA;                用interface{}自定义异常类型&#xA;                runtime.Stack()查看栈，利用defer函数在栈清理前调用, 所以栈存在&#xA;            终止当前goroutine, 外层goroutine不捕获&#xA;            按函数调用栈依次中止函数并调defer, 最上层后程序异常退出&#xA;            panic之后定义的defer不执行(声明不提前)&#xA;        recover()&#xA;            中止panic&#xA;            在defer中(panic时只调defer)捕获panic对象，没有时为nil&#xA;            捕获panic对象后, 捕获函数正常返回。要上抛就再手动panic()&#xA;        o-&amp;gt;&#xA;        func Try(fn func(), handler func(interface{})) {&#xA;            defer func() {&#xA;                if err := recover(); err != nil {&#xA;                    handler(err)&#xA;                }&#xA;            }()&#xA;            fn()&#xA;        }&#xA;&#xA;        func main() {／&#xA;            Try(func() {&#xA;                panic(&amp;quot;a&amp;quot;)&#xA;            }, func(e interface{}) {&#xA;                print(e)&#xA;            })&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内置&#34;&gt;&#xA;  内置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;零值                              # 保障变量良好定义，没有未初始化变量&#xA;    数字0, 布尔false, 字符串&amp;quot;&amp;quot;&#xA;    接口和引用类型(slice, 指针, map, channel, 函数)nil&#xA;    复合类型其所有元素或成员零值&#xA;常量&#xA;    true&#xA;    false&#xA;    iota&#xA;    nil&#xA;        比较&#xA;            var s []int         # 未初始化比较, ==nil&#xA;            s = []int(nil)      # 强转, ==nil&#xA;            s = []int{}         # 初始化比较, !=nil&#xA;基本类型&#xA;    字面量&#xA;        06                      # 8进制&#xA;        0x0a                    # 16进制&#xA;        .1或1.                   # 小数点前后可省略&#xA;        2.2e10                  # 科学计数法&#xA;        1 + 2i                  # 复数&#xA;        字符串&#xA;            &amp;quot;\\&amp;quot;                # 转义&#xA;            &amp;quot;\r&amp;quot;                # 光标退到行首&#xA;            &amp;quot;\b&amp;quot;                # 光标退一字符&#xA;            &amp;quot;\x1a&amp;quot;              # 16进制表示位数据, 必2位，无法识别成unicode&#xA;            &amp;quot;\212&amp;quot;              # 8进制表示位数据, 必3位, 无法识别成unicode&#xA;            &amp;quot;\u1234&amp;quot;            # unicode, 16进制数字, 共4x4=16位&#xA;            &amp;quot;\u12345678&amp;quot;        # unicode, 16进制数字, 共4x8=32位&#xA;            ``                  # 原生字符串, 回车被删除(换行符保留)&#xA;    注意&#xA;        会自动截断，如int i=127; i+1=-128; i*i=1&#xA;    int                         # 平台原生整数大小，或该平台运算效率最高值, 多是int32&#xA;    int8                        # -128-127&#xA;    int16&#xA;    int32&#xA;    int64&#xA;    uint                        # 平台决定大小。无符号极少用于表示非负值，往往用于位运算或特定算术运算符，如位集，解析二进制，散列，加密&#xA;    uint8                       # 0-255&#xA;    uint16&#xA;    uint32&#xA;    uint64&#xA;    uintptr                     # 存放指针，大小不明确，底层编程&#xA;    float32                     # 运算会迅速累积误差, 正整数范围有限&#xA;    float64&#xA;    complex64                   # float32构成&#xA;    complex128                  # float64构成&#xA;        var x complex128 = complex(1,2)&#xA;        x := 1 + 2i&#xA;    bool&#xA;    byte                        # uint8别名, 强调是原始数据&#xA;    rune                        # int32别名, unicode码点(UTF-8), 下标取字符(非字节)&#xA;    string                      # 认为是UTF-8编码的unicode, 不合理字节替换成方块(\uFFFD)。不可变(安全截取、共用), 下标取字节，越界宕机异常&#xA;        和数组和slice一样操作&#xA;        []byte和string元素操作一致，只类型不同&#xA;        互换&#xA;            []byte, []rune, string                  # 转换产生副本&#xA;    error&#xA;聚合类型&#xA;    数组&#xA;        字面量&#xA;            var q [3]int&#xA;            q := [3]int{1,2,3}&#xA;            q := [...]int{1,2,3}                        # 长度由元素个数决定&#xA;            q := [...]int{0: 1, 3:2}                    # 指定索引元素值&#xA;        数组是值传递&#xA;        数组元素不可包含自己&#xA;        默认元素为零值&#xA;        不同长度不同类型，不能赋值&#xA;        如果元素可比较，数组就可比较     # 深度比较&#xA;            q1 &amp;lt; q2                   # 字符串比较按字节字典排序&#xA;    slice&#xA;        字面量&#xA;            q := []int{1,2,3}                           # 这里创建了slice, 指向了隐式创建的数组&#xA;            q[0:1]                                      # 左闭右开&#xA;            q[:1]; q[1:]; q[:]&#xA;        轻量级数据结构，用来访问数组的部分&#xA;        零值是nil, 行为和slice一样，不用特殊判断&#xA;        slice后标访问越界时，会自动扩展，越界超过数组长度+1时，会panic&#xA;            append(arr[:i], arr[i+1:]...)删除元素, i为最后元素时, i+1不越界&#xA;        不可比较, 只有写函数实现。只能和nil比较&#xA;            因为slice的元素不是直接的&#xA;                有可能包含它自身&#xA;                同slice不同时间会拥有不同元素&#xA;                    如果slice可比较来做map键, map只对key做浅拷贝, slice需要深度比较, 所以要求slice元素不变&#xA;        三元素                         # 有自己的属性，不是纯引用类型，是聚合类型&#xA;            指针: 指向slice在数组上起始位置&#xA;            长度: slice长度&#xA;            容量: 指针到数组结尾元素个数&#xA;    map                                # key可nil, 取不存在key时, 得到value类型的零值。随机无序遍历&#xA;        字面量&#xA;            m := map[string]int{&#xA;                &amp;quot;a&amp;quot;:1,&#xA;            }&#xA;            a[&amp;quot;b&amp;quot;]=2&#xA;        不能获得地址，如&amp;amp;m[&amp;quot;a&amp;quot;]          # 因为map增长时，已有元素可能重新散列&#xA;        迭代顺序随机                     # key用维护排序, 散列算法健壮&#xA;        零值是nil, 向nil map设置元素会panic&#xA;        map[key1]没有时，获得零值&#xA;            v, ok := m[&amp;quot;a&amp;quot;]             # 判断有无key&#xA;        不可比较，只能和nil比较&#xA;        key要求可比较，可以数组,不可以slice,可以自己映射成可比较类型&#xA;            q := [2]int{}&#xA;            m := map[[2]int]int{}&#xA;            m[q] = 1&#xA;    结构体&#xA;        字面量&#xA;            type T struct {                             # 结构体,&#xA;                Name string `json:&amp;quot;name0,omitempty&amp;quot;`    # 成员标签定义, opmitempty在零值时忽略&#xA;                I1, I2 int&#xA;            }&#xA;&#xA;            t := &amp;amp;T{&amp;quot;a&amp;quot;}                                # 顺序易出错, 用于明显的小结构。未指定成员为零值&#xA;            t := &amp;amp;T{&#xA;                Name: &amp;quot;a&amp;quot;,&#xA;            }&#xA;            (*t).Name = &amp;quot;a&amp;quot;&#xA;            t.Name = &amp;quot;a&amp;quot;                                # .可以用于指针&#xA;&#xA;            struct{}                                    # 空结构体，没有长度，无信息。&#xA;&#xA;            type T1 struct{                             # 匿名成员&#xA;                T&#xA;                T2&#xA;                *T3&#xA;                Name1 string&#xA;            }&#xA;            t1 := T1{&#xA;                T: {&#xA;                    Name: &amp;quot;a&amp;quot;&#xA;                }&#xA;            }&#xA;&#xA;        首字母大写可导出&#xA;        属性类型不可自己，但可自己指针&#xA;        结构体零值由成员零值组成            # 希望结构体方法中处理零值成一个自然的值，如sync.Mutex&#xA;        成员可比较，结构体实例可比较, 可作map key&#xA;        匿名成员(组合)&#xA;            点号访问可跨入(语法糖)，访问匿名成员属性和方法&#xA;                t1.Name; t1.T.Name&#xA;            不能有相同类型的匿名成员&#xA;            不可导出类型的匿名成员，内部成员不影响，但匿名成员本身不可见&#xA;引用类型&#xA;    Type&#xA;    IntegerType&#xA;    FloatType&#xA;    ComplexType&#xA;&#xA;    chan&#xA;        ch := make(chan string)&#xA;&#xA;        var cin chan&amp;lt;- string&#xA;        var cout &amp;lt;-chan string&#xA;&#xA;        ch &amp;lt;- &amp;quot;&amp;quot;&#xA;        &amp;lt;-ch&#xA;接口类型&#xA;    error&#xA;        Error()&#xA;命名类型&#xA;    type&#xA;    结构体&#xA;        type Point struct {&#xA;            X, Y int&#xA;        }&#xA;函数&#xA;    make()&#xA;        make([]int)&#xA;        make(map[string]int)&#xA;        make(chan int)&#xA;    delete()&#xA;        delete(m, &amp;quot;a&amp;quot;)          # 删除map元素, 没key不报错返回零值&#xA;    len()&#xA;        len(ch)                 # 当前缓冲个数&#xA;    cap()&#xA;        cap(ch)                 # 缓冲区容量&#xA;    new()                       # 创建指定类型变量，初始化为零值，返回地址。不带任何信息且是零值(struct{}和[0]int)的类型, new出的地址不同(从前相同)&#xA;        t := new(T)&#xA;    append()                    # 操作slice&#xA;        先检查原容量，容量够修改原数组元素，不够创建新数组(容量扩一倍)复制元素, 返回新slice&#xA;        所以append()最好赋值给原slice&#xA;        s1 := append(s1, s2...)&#xA;    copy()                      # slice或string元素复制&#xA;    close()                     # channel中用&#xA;    complex()                   # 创建复数对象&#xA;    real()                      # 获取复数的实部&#xA;    imag()                      # 获取复数的虚部&#xA;    panic()&#xA;    recover()&#xA;反射&#xA;    谨慎使用&#xA;        脆弱，能导致编译报错的写法，反射中都对应panic，执行时才知道&#xA;        降低自动重构和分析工具的安全性与准确度，反射对类型操作无法静态检查&#xA;        反射慢1-2个数量级(实测20位左右), 适合测试用，不适合关键路径上用&#xA;unsafe&#xA;    值在内存中对齐，计算更高效。结构体用内存间隙来对齐，占空间比元素之和更大&#xA;    结构体成员内存中重新排列可省内存，但目前不是&#xA;cgo&#xA;    o-&amp;gt; c文件&#xA;    #include &amp;lt;bzlib.h&amp;gt;&#xA;    int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen) {...}&#xA;&#xA;    o-&amp;gt; go文件&#xA;    /*&#xA;    #cgo CFLAGS: -I/usr/include&#xA;    #cgo LDFLAGS: -L/usr/lib -lbz2&#xA;    #include &amp;lt;bzlib.h&amp;gt;&#xA;    int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen);&#xA;    */&#xA;    import &amp;quot;C&amp;quot;&#xA;    import (&#xA;        &amp;quot;io&amp;quot;&#xA;        &amp;quot;unsafe&amp;quot;&#xA;    )&#xA;    type writer struct {&#xA;        w io.Writer&#xA;        stream *C.bz_stream&#xA;        outbuf [64*1024]byte&#xA;    }&#xA;    func NewWriter(out io.Writer) io.WriteCloser{&#xA;        const (&#xA;            blockSize = 9&#xA;            verbosity = 0&#xA;            workFactor = 30&#xA;        )&#xA;        w := &amp;amp;writer{w: out, stream: C.bz2alloc()}&#xA;        C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)&#xA;        return w&#xA;    }&#xA;    func (w *writer) Write(data []byte) (int, erro) {&#xA;        if w.stream == nil {&#xA;            panic(&amp;quot;closed&amp;quot;)&#xA;        }&#xA;        var total int&#xA;        for len(data) &amp;gt; 0 {&#xA;            inlen, outlen := C.uint(len(data)), C.uint(cap(w.outbuf))&#xA;            C.bz2compress(w.stream, C.BZ_RUN, (*C.char)(unsafe.Pointer(&amp;amp;data[0])), &amp;amp;inlen, (*C.char)(unsafe.Pointer(&amp;amp;w.outbuf)), &amp;amp;outlen)&#xA;            total += int(inlen)&#xA;            data = data[inlen:]&#xA;            if _, err := w.w.Write(w.outbuf[:outlen]); err != nil {&#xA;                return total, err&#xA;            }&#xA;        }&#xA;        return total, nil&#xA;    }&#xA;&#xA;    注释&#xA;        #cgo 指令指定C工具链选项&#xA;    import &amp;quot;c&amp;quot;&#xA;        编译时促使go build用cgo预处理其上注释&#xA;        产生临时包包含c函数对应声明&#xA;            包含类型，函数，预处理宏对象&#xA;            这里用了C.bz_stream和C.BZ2_bzCompressInit&#xA;    go也可编译成静态库链接进C, 或编译成动态库通过C加载和共享&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内部包&#34;&gt;&#xA;  内部包&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e9%83%a8%e5%8c%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# golang.org/pkg 找到索引&#xA;errors&#xA;    New()&#xA;testing&#xA;    T&#xA;        Error()&#xA;        Errorf()&#xA;        Fatal()&#xA;        Fatalf()&#xA;    B&#xA;syscall                 # 执行其它语言&#xA;syscall/js&#xA;js/wasm                 # 1.11, webAssembly&#xA;go/doc&#xA;go/token&#xA;runtime&#xA;    Stack()                             # 调用栈&#xA;    Gosched()                           # 让出执行权&#xA;    Goexit()                            # 终止当前goroutine, 会执行defer&#xA;    LockOSThread()                      # 绑定协程到当前线程&#xA;    UnlockOSThread()&#xA;    GOMAXPROCS()                        # 并发线程数&#xA;    NumGoroutine()                      # 限制goroutine数&#xA;runtime/debug&#xA;os&#xA;    Stdin                   # 输入流&#xA;    Args                    # 运行参数&#xA;    FileInfo&#xA;&#xA;    Open()                  # 打开文件&#xA;        File&#xA;            Read()&#xA;            Write()&#xA;            Close()&#xA;    Exit(1)                 # 1异常退出&#xA;    RemoveAll()&#xA;    Stat()                  # 文件信息&#xA;os/exec                     # 子进程&#xA;io&#xA;    EOF                     # 文件结束标志, 是一个error&#xA;&#xA;    Copy()&#xA;    WriteString()&#xA;io/ioutil&#xA;    Discard                 # 丢弃&#xA;&#xA;    ReadFile()              # 读整个文件到内存&#xA;    ReadAll()&#xA;    WriteFile()&#xA;    ReadDir()&#xA;bufio                       # 带缓冲io&#xA;    NewScanner()&#xA;        Scanner             # 以行或单词断开&#xA;            Scan()          # 有内容返回true&#xA;            Text()&#xA;    NewReader()&#xA;        ReadRune()&#xA;path                        # 文件路径&#xA;    Base()                  # 获得最后文件名&#xA;path/filepath               # 根据平台处理文件路径&#xA;net&#xA;    Conn&#xA;net/http&#xA;    poolServer(epoll/kqueue/iocp)&#xA;        # 支持多核大量并发连接fd&#xA;    Get()&#xA;        Header&#xA;            Get()&#xA;        Body&#xA;            Close()&#xA;    HandleFunc()&#xA;        ResponseWriter&#xA;        Request&#xA;            RemoteAddr      # 客户ip:端口&#xA;            Host&#xA;            Method&#xA;            Proto           # 网络协议&#xA;            Header&#xA;            Form            # 先ParseForm()&#xA;            URL&#xA;                Path&#xA;&#xA;            ParseForm()&#xA;    ListenAndServe()&#xA;net/http/httputil&#xA;net/url&#xA;    QueryEscape()           # url转义&#xA;context                     # 线程安全, 树形结构&#xA;    Cancel()&#xA;    Deadline(Timeout)&#xA;    Value()&#xA;    TODO()&#xA;&#xA;    o-&amp;gt; ctx.Done()&#xA;    func f(ctx context.Context) (error) {&#xA;        errc := make(chan error, 1)&#xA;&#xA;        go func() {&#xA;            defer close(errc)&#xA;            time.Sleep(2 * time.Second)&#xA;            errc &amp;lt;- nil&#xA;        }()&#xA;&#xA;        select {&#xA;        case &amp;lt;-ctx.Done():&#xA;            &amp;lt;-errc&#xA;            return ctx.Err()&#xA;        case err := &amp;lt;-errc:&#xA;            return err&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; WithTimeout&#xA;    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)     # 调cancel提前结束&#xA;    defer cancel()&#xA;    return f(ctx)&#xA;flag&#xA;    Args                    # 非标识参数&#xA;    Parse()                 # 出错调os.Exit(2)&#xA;&#xA;    o-&amp;gt; 输入&#39;-s / a bc&#39;, 输出&#39;a/bc&#39;&#xA;    sep := flag.Strings(&amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;desc s&amp;quot;)&#xA;    flag.Parse()&#xA;    println(strings.Join(flag.Args(), *sep))&#xA;log&#xA;    SetPrefix()&#xA;    SetFlags()              # 格式标记&#xA;    Fatal()                 # 加日期时间前缀&#xA;    Fatalf()&#xA;time&#xA;    Time&#xA;        Format()&#xA;&#xA;    Now()&#xA;    Since()&#xA;        Seconds()&#xA;    After()&#xA;    AfterFunc()&#xA;    NewTicker()&#xA;        ticker := time.NewTicker(1 * time.Second)&#xA;        &amp;lt;- ticker.C&#xA;        ticker.Stop()&#xA;    Tick()&#xA;        tick := time.Tick(1 * time.Second)          # 无法中止, 用于全局，否则内部goroutine泄漏&#xA;        for {&#xA;            &amp;lt;-tick&#xA;        }&#xA;&#xA;&#xA;fmt                         # string类型会调对象的String()方法&#xA;    Stringer                # 接口，有String()方法可匹配&#xA;&#xA;    Printf()                # 可以用转义序列(\t等)表示不可见字符&#xA;        %d                  # 十进制整数&#xA;        %x, %o, %b          # 十六进制、八进制、二进制整数&#xA;            %X&#xA;            % x             # 十六进制输出，两数一空格&#xA;        %f, %g, %e          # 浮点数6位小数、15位小数并自动精度与表示方式、6位小数e表示&#xA;            &amp;quot;%8.3f&amp;quot;         # 输出8字符宽度，保留3位小数&#xA;        %t                  # 布尔&#xA;        %c                  # unicode字符&#xA;        %s                  # 字符串&#xA;            %*s             # 缩进后面指定数字个空格&#xA;        %q                  # 带引号字符串(&amp;quot;abc&amp;quot;)，或字符(&#39;c&#39;)&#xA;        %v                  # 内置格式的任何值&#xA;            %#v             # 包含结构体成员名字&#xA;        %T                  # 类型&#xA;        %[1]c               # 重复利用第一个参数&#xA;            Printf(&amp;quot;%d %[1]c %[1]q&amp;quot;, &#39;a&#39;)&#xA;        %%                  # %本身&#xA;        特殊数字&#xA;            var z float64&#xA;            fmt.Println(z,-z,1/z,-1/z,z/z)              # &amp;quot;0 -0 +Inf -Inf NaN&amp;quot;&#xA;    Fprintf()&#xA;    Scanf()                 # 格式化输入&#xA;    Errorf()                # 产生一个error&#xA;strconv                     # 类型转换&#xA;    ParseFloat()&#xA;    ParseInt()&#xA;    ParseUint()&#xA;    Itoa()                  # 整数转字符串&#xA;    FormatInt(int64(1a), 2)&#xA;    FormatUint()&#xA;unicode                 # 单符号&#xA;    ToUpper()&#xA;    ToLower()&#xA;    IsDigit()&#xA;    IsLetter()&#xA;unicode/utf8            # 逐个处理&#xA;    RuneCountInString()                 # 字符数&#xA;    DecodeRuneInString()                # 解码, string类型默认调用&#xA;bytes                       # 操作byte数组&#xA;    Buffer&#xA;        WriteByte()&#xA;        WriteRune()&#xA;        WriteString()&#xA;        String()&#xA;&#xA;    Index()&#xA;    Contains()&#xA;    Count()&#xA;    Fields()&#xA;    HasPrefix()&#xA;    Join()&#xA;    Equal()&#xA;strings                     # 处理UTF-8或位序列&#xA;    Index()&#xA;    Split()&#xA;    HasPrefix()&#xA;    HasSuffix()&#xA;    Contains()&#xA;    Count()&#xA;    Fields()&#xA;    Join()&#xA;regexp&#xA;    MustCompile()           # 检查&#xA;    Compile()               # 编译表达式&#xA;text/template&#xA;    Must()                  # 检查，有错panic&#xA;&#xA;&#xA;    o-&amp;gt;&#xA;    {{.Name}}               # .代表当前值&#xA;    {{range .Items}}&#xA;        {{.Title | printf &amp;quot;%.64s&amp;quot;}}&#xA;        {{.CreateAt | daysAgo}}&#xA;    {{end}}&#xA;    template.New(&amp;quot;report&amp;quot;).&#xA;        Funcs(template.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}).&#xA;        Parse(templ)&#xA;text/tabwriter              # 生成表格&#xA;    Flush()&#xA;html/template               # 对html, js, css, url中原字符转义, 避免对输出页面注入控制&#xA;    Html                    # 字符串转成该类型，受信任，不用转义&#xA;&#xA;    Parse()                 # 解析html&#xA;encoding/json               # unicode&#xA;    Marshal()               # 转成json, 不可导出不可见&#xA;    MarshalIndent()         # 格式化转成json&#xA;    Unmarshal()&#xA;    NewDecoder()            # 流式解码&#xA;        Decode()&#xA;encoding/xml&#xA;encoding/gob&#xA;encoding/asn1&#xA;compress/gzip               # DEFLATE算法&#xA;    NewWriter()&#xA;    NewReader()&#xA;compress/bzip2              # Burrows-Wheeler变换, 压缩高，慢&#xA;&#xA;&#xA;sort&#xA;    IntSlice&#xA;        sort.Sort(sort.IntSlice(ints))&#xA;&#xA;    Sort()&#xA;    Reverse()&#xA;        sort.Sort(sort.Reverse(values))&#xA;    IsSorted()&#xA;    Strings()&#xA;    Ints()&#xA;    IntsAreSorted()&#xA;&#xA;    o-&amp;gt;&#xA;    type StringSlice []string&#xA;    func (p StringSlice) Len()int {return len(p)}&#xA;    func (p StringSlice) Less(i, j int)bool {return p[i] &amp;lt; p[j]}&#xA;    func (p StringSlice) Swap(i, j int) {p[i], p[j] = p[j], p[i]}&#xA;    sort.Sort(StringSlice(names))&#xA;math&#xA;    Sin()&#xA;    NaN()               # 返回NaN, NaN值比较总false(除!=), NaN用作信号量&#xA;math/rand&#xA;    Seed(time.Now().UTC().UnixNano())&#xA;    Float64()&#xA;math/cmplx              # 复数运算&#xA;    Sqrt(-1)            # 0 + 1i&#xA;math/bits&#xA;image&#xA;    Rect()&#xA;    NewPaletted()&#xA;        SetColorIndex()&#xA;    Decode()&#xA;    Encode()&#xA;image/color&#xA;    Color&#xA;    White&#xA;    Black&#xA;image/gif&#xA;    GIF&#xA;image/jpeg              # 空导入注册解码器&#xA;image/png               # 空导入注册解码器&#xA;&#xA;&#xA;sync&#xA;    Mutex&#xA;        Lock()&#xA;        Unlock()&#xA;    RWMutex&#xA;        Lock()&#xA;        Unlock()&#xA;        RLock()&#xA;        RUnlock()&#xA;    Once                                # 单例资源初始化，解决了多线程下读检查，防重写的问题&#xA;        Do()&#xA;    WaitGroup&#xA;    Cond&#xA;        Wait()                          # 计数加1, 进入阻塞&#xA;        Signal()                        # 解除一个阻塞，计数减1&#xA;        Broadcast()                     # 解除所有阻塞&#xA;    Map&#xA;    Pool&#xA;&#xA;&#xA;reflect                 # 非导出字段反射可见, 不可更新&#xA;    Type                # 类型&#xA;        String()        # 类型描述, fmt.Printf()中的&amp;quot;%T&amp;quot; 内部调用&#xA;        Field()         # 结构体成员, 返回StructField&#xA;            Name&#xA;        Method()&#xA;    Value               # 值&#xA;        String()        # 值描述，如&amp;quot;&amp;lt;int Value&amp;gt;&amp;quot;&#xA;        Type()&#xA;        Interface()     # 返回接口具体值&#xA;            x := v.Interface()&#xA;            i := x.(int)&#xA;        Kind()          # 得到类型，Bool, String, 各种数字, Array, Struct, Chan, Func, Ptr, Slice, Map, Interface, Invalid(零值), Func&#xA;        Index()         # 数组&#xA;        NumField()      # 结构体成员数&#xA;        FieldByName()&#xA;        MapKeys()       # map&#xA;        MapIndex()      # map&#xA;        IsValid()&#xA;        IsNil()         # 指针&#xA;        Elem()          # 指针指向元素&#xA;        CanAddr()       # 是否可寻址，如指针元素取Elem()的值，数组元素&#xA;        Addr()          # 取地址&#xA;            v.Addr().Interface().(*int)&#xA;        CanSet()        # 检查CanAddr()和是否非导出字段&#xA;        Set()           # 要求可寻址, 类型一致。可Set()interface{}类型&#xA;            SetInt(), SetUint(), SetString(), SetFloat()            # 相对Set()有容错性,不可SetXx()interface{}类型&#xA;            SetMapIndex()&#xA;        NumMethod()     # 方法数&#xA;        Method()        # 取方法&#xA;            Name&#xA;        Call()          # 执行Func类型Value&#xA;    StructField&#xA;        Tag&#xA;    StructTag&#xA;        Get()           # 字段标签中key的值&#xA;    Method&#xA;&#xA;    TypeOf()&#xA;    ValueOf()&#xA;    Zero()              # 零值&#xA;    Append()&#xA;    MakeMap()&#xA;    New()               # 类型新对象地址&#xA;    DeepEqual()         # 深度比较，基本类型用==, 组合类型逐层比较。&#xA;        判断武断，不认为值为nil的map和值不为nil的空map相等。slice同理&#xA;            var c, d map[string]int = nil, make(map[string]int)&#xA;            var a, b []string = nil, []string{}&#xA;&#xA;unsafe                  # 由编译器实现，暴露了内存布局。&#xA;    Pointer             # 任何地址，可比较，可比较nil。无类型向内存写任意值。&#xA;        可转成uintptr对地址计算&#xA;            问题&#xA;                移动垃圾回收器(目前未用)在移变量时地址改变使地址出错。&#xA;                goroutine增长栈时旧栈地址重新分配&#xA;            解决&#xA;                Pointer转uintptr再转回来在一条语句中实现&#xA;            应用&#xA;                深度比较时，防止循环引用，每次比较存两个抽象的指针(即Pointer)和类型(y和y[0]地址一样)&#xA;        var f float64&#xA;        i := *(*uint64)unsafe.Pointer(&amp;amp;f)&#xA;    Sizeof()            # 表达式占字节长度, 不计算表达式，由编译器推断&#xA;    Alignof             # 报告类型对齐方式&#xA;    Offsetof()          # 成员相对起始偏移量, 计算空位&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;外部包&#34;&gt;&#xA;  外部包&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%96%e9%83%a8%e5%8c%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# godoc.org 搜索&#xA;goimports           # 格式化imports顺序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;测试&#34;&gt;&#xA;  测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;规则&#xA;    文件名以_test.go结尾&#xA;    汇报PASS或FAIL, 平均执行时间&#xA;    忽略main函数, 当作库测试&#xA;        main特权函数 log.Fatal()和os.Exit()会阻止跟踪过程&#xA;    包测试循环依赖时，建立外部测试包&#xA;        导出内部成员用于测试的后门成员声明，放在export_test.go内&#xA;机制&#xA;    扫描*_test.go&#xA;    生成临时main包来调用，再编译、运行、汇报, 最后清空临时文件&#xA;Test函数                          # t用于汇报结果和日志&#xA;    func TestF(t *testing.T) {}&#xA;benchmark函数                     # 基准测试，性能&#xA;    b增加了成员N指定执行次数, 增加了性能检测方法&#xA;        开始指定小N, 再推断足够大的N检测稳定运行时间&#xA;    基准测试时初始化代码放循环外面，它的执行时间不加到每次迭代时间中。普通Test做不到&#xA;    用go test -bench=.运行&#xA;        报告中 f-8 1000000 1035 ns/op 分别代表GOMAXPROCS=8, 执行100000次，平均每次1035ns&#xA;&#xA;    o-&amp;gt; 基本使用&#xA;    func BenchmarkF(b *testing.B) {&#xA;        for i := 0; i &amp;lt; b.N; i++{&#xA;            f()&#xA;        }&#xA;    }&#xA;    o-&amp;gt; 相对比较, 如数量级、找最佳缓冲区大小、选算法策略&#xA;    func benchmark(b *testing.B, size int){}&#xA;    func Benchmark10(b *testing.B) {benchmark(b, 10)}&#xA;    func Benchmark100(b *testing.B) {benchmark(b, 100)}&#xA;Example函数                       # 示例，无参无结果。&#xA;    用处&#xA;        可举例子作为文档&#xA;        结尾注释 // output: 验证终端输出&#xA;        实验代码&#xA;    func ExampleF()  {&#xA;        fmt.Print(&amp;quot;a&amp;quot;)&#xA;        // output: aa&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发编程&#34;&gt;&#xA;  并发编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;同步&#xA;    func&#xA;    channel                                 # 和调度器深度关联，控制goroutine的阻塞和唤醒&#xA;        缓冲区&#xA;            作用&#xA;                异步&#xA;                    发送接收解耦&#xA;                    让数据可并行处理(计数信号量)&#xA;                    消除goroutine间速率差异(速率大致相同, 某刻休息)&#xA;                        上下游速率差异大时无作用&#xA;                阻塞时同步&#xA;            c := make(chan struct{})&#xA;            c1 := make(chan struct{}, 1)&#xA;            c ← struct{}{}                  # 阻塞&#xA;            ← c                             # 阻塞&#xA;&#xA;            c1 ← struct{}{}                 # 不阻塞&#xA;            c1 ← struct{}{}                 # 阻塞&#xA;            ← c1                            # 不阻塞&#xA;            ← c1                            # 阻塞&#xA;        方向&#xA;            var c chan struct{}             # in和out&#xA;            var cin &amp;lt;-chan struct{}         # in, 关闭时panic&#xA;                v := &amp;lt;-cin&#xA;            var cout chan&amp;lt;- struct{}        # out&#xA;                cout &amp;lt;- v&#xA;&#xA;            cin = c&#xA;            cout = c&#xA;            c = cin                         # 编译错误&#xA;            c = cout                        # 编译错误&#xA;        nil                                 # 永远阻塞, 用于开启禁用情况&#xA;            var c chan struct{}&#xA;            c &amp;lt;- struct{}{}                 # 阻塞&#xA;        关闭                                 # 关闭不是必须的，不影响回收。只是用来通知和广播&#xA;            c := make(chan struct{})&#xA;            close(c)                        # 再关闭panic&#xA;            c ← struct{}{}                  # panic&#xA;            o, ok := ← c                    # o得到零值, ok是false&#xA;    for range&#xA;        c := make(chan struct{})&#xA;        ...&#xA;        for x := range c {}                 # close(c)时break&#xA;    select&#xA;&#xA;    sync包&#xA;    sync/atomic包&#xA;&#xA;&#xA;    o-&amp;gt; 并发三个业务, 一起结束&#xA;    cond := sync.NewCond(new(sync.Mutex))&#xA;    wg := sync.WaitGroup{}&#xA;    wg.Add(3)&#xA;    wg1 := sync.WaitGroup{}&#xA;    wg1.Add(3)&#xA;    for i := 0; i &amp;lt; 3; i++ {&#xA;        go func(i int) {&#xA;            defer wg1.Done()&#xA;            cond.L.Lock()&#xA;            fmt.Println(&amp;quot;wait&amp;quot;, i)          # 业务预处理&#xA;            wg.Done()&#xA;            cond.Wait()                     # 阻塞&#xA;            fmt.Println(&amp;quot;done&amp;quot;, i)          # 业务后续处理(要求所有业务预处理过)&#xA;            cond.L.Unlock()&#xA;        }(i)&#xA;    }&#xA;    wg.Wait()                               # 业务预处理完成&#xA;&#xA;    cond.L.Lock()&#xA;    cond.Broadcast()                        # 处理业务后续&#xA;    cond.L.Unlock()&#xA;    wg1.Wait()                              # goroutine完成&#xA;异步&#xA;    语句&#xA;        语句是串行一致的(sequentially consistent)&#xA;        串行一致基础上，语句会重排, 重排中可能穿插执行其它goroutine语句&#xA;            t := map[string]int{&#xA;                &amp;quot;a&amp;quot;: 1&#xA;                &amp;quot;b&amp;quot;: 2&#xA;            }&#xA;            重排为&#xA;            t := make(map[string]int)&#xA;            t[&amp;quot;a&amp;quot;]=1&#xA;            t[&amp;quot;b&amp;quot;]=2&#xA;    goroutine&#xA;        语句&#xA;            go f()&#xA;        泄漏&#xA;            阻塞不能自动结束                  # 如操作channel时&#xA;            main中最后调panic(), 从崩溃转储信息判断资源释放情况&#xA;        死锁(deadlock)                      # 指没有可调度的goroutine&#xA;            所有goroutine阻塞或没有goroutine&#xA;        运行main的是主goroutine, main返回所有goroutine暴力终结&#xA;        无id(标识)&#xA;        不能中断&#xA;        无返回值&#xA;    runtime&#xA;    context&#xA;    time&#xA;并发模式                                    # 避免goroutine泄漏，保证通信顺序&#xA;    done/quit&#xA;        o-&amp;gt; done控制goroutine退出。         # 更快的响应要写更多的逻辑入侵，找到响应慢点写done逻辑&#xA;        func f(done &amp;lt;-chan struct{}) {&#xA;            select {&#xA;            case &amp;lt;-done:&#xA;                for range ch{              # 耗尽通道, 其它goroutine不会卡在ch&amp;lt;-上而退出&#xA;                }&#xA;                return&#xA;            }&#xA;        }&#xA;        func cancelled()bool{&#xA;            select {&#xA;            case &amp;lt;-done:&#xA;                return true&#xA;            default:&#xA;                return false&#xA;            }&#xA;        }&#xA;        func f2(){                          # 轮循函数中入口检查, 避免创建新goroutine&#xA;            if cancelled() {&#xA;                return&#xA;            }&#xA;        }&#xA;&#xA;        done := make(chan struct{})&#xA;        defer close(done)&#xA;        f(done)&#xA;    channels of channels&#xA;        o-&amp;gt; 循环处理请求&#xA;        func handle(reqs chan chan interface{}) {&#xA;            for req := range reqs {&#xA;                req &amp;lt;- 0&#xA;            }&#xA;        }&#xA;        func server(req chan interface{}) {&#xA;            reqs := make(chan chan interface{})&#xA;            defer close(reqs)&#xA;            go handle(reqs)&#xA;            reqs &amp;lt;- req&#xA;        }&#xA;        func client() interface{} {&#xA;            req := make(chan interface{})&#xA;            defer close(req)&#xA;            go server(req)&#xA;            return &amp;lt;-req&#xA;        }&#xA;        fmt.Println(client())&#xA;&#xA;        o-&amp;gt; 循环异常退出&#xA;        type S struct {&#xA;            closing chan chan error&#xA;        }&#xA;        func (s *S) close() error {&#xA;            errc := make(chan error)&#xA;            s.closing &amp;lt;- errc&#xA;            return &amp;lt;-errc&#xA;        }&#xA;        func (s *S) loop() {&#xA;            for {&#xA;                select {&#xA;                case errc := &amp;lt;-s.closing:&#xA;                    errc &amp;lt;- nil&#xA;                    return&#xA;                }&#xA;            }&#xA;        }&#xA;    pipeline(fan-in, fan-out)           # 传入传出channel来处理&#xA;        o-&amp;gt;&#xA;        func gen(done &amp;lt;-chan struct{}, nums ...int) &amp;lt;-chan int {&#xA;            out := make(chan int)&#xA;            go func() {&#xA;                defer close(out)&#xA;                for _, n := range nums {&#xA;                    select {&#xA;                    case out &amp;lt;- n:&#xA;                    case &amp;lt;-done:&#xA;                        return&#xA;                    }&#xA;                }&#xA;            }()&#xA;            return out&#xA;        }&#xA;        func sq(done &amp;lt;-chan struct{}, in &amp;lt;-chan int) &amp;lt;-chan int {&#xA;            out := make(chan int)&#xA;            go func() {&#xA;                defer close(out)&#xA;                for n := range in {&#xA;                    select {&#xA;                    case out &amp;lt;- n * n:&#xA;                    case &amp;lt;-done:&#xA;                        return&#xA;                    }&#xA;                }&#xA;            }()&#xA;            return out&#xA;        }&#xA;        func merge(done &amp;lt;-chan struct{}, cs ...&amp;lt;-chan int) &amp;lt;-chan int {&#xA;            # wg等cs数目个协程合并数据到out后，关闭out&#xA;            var wg sync.WaitGroup&#xA;            out := make(chan int)&#xA;&#xA;            output := func(c &amp;lt;-chan int) {&#xA;                for n := range c {&#xA;                    select {&#xA;                    case out &amp;lt;- n:&#xA;                    case &amp;lt;-done:&#xA;                    }&#xA;                }&#xA;                wg.Done()&#xA;            }&#xA;&#xA;            wg.Add(len(cs))&#xA;            for _, c := range cs {&#xA;                go output(c)&#xA;            }&#xA;&#xA;            go func() {&#xA;                wg.Wait()&#xA;                close(out)&#xA;            }()&#xA;            return out&#xA;        }&#xA;&#xA;        func main() {&#xA;            done := make(chan struct{})&#xA;            defer close(done)&#xA;&#xA;            for n := range sq(done, sq(done, gen(done, 2, 3))) {&#xA;                # gen产生维护数字chan, sq产生维护平方chan。三个chan&#xA;                # 三个goroutine done()时return, chan return时close()&#xA;                fmt.Println(n)&#xA;            }&#xA;&#xA;            // 扇出&#xA;            in := gen(done, 2, 3)&#xA;            c1 := sq(done, in)&#xA;            c2 := sq(done, in)&#xA;            // 扇进&#xA;            for n := range merge(done, c1, c2) {&#xA;                fmt.Println(n)&#xA;            }&#xA;        }&#xA;    timeout&#xA;        select {&#xA;        case &amp;lt;-ch:&#xA;            ...&#xA;        case &amp;lt;-time.After(time.Second)&#xA;            return&#xA;        }&#xA;    控制并发数&#xA;        并发写缓冲区channel&#xA;        for循环产生并发数goroutine&#xA;常用&#xA;    中断&#xA;        # os.Exit()程序返回错误码&#xA;&#xA;        done := make(chan struct{})&#xA;        go func() {&#xA;            defer close(done)&#xA;            c := make(chan os.Signal, 1)&#xA;            defer close(c)&#xA;            signal.Notify(c, os.Interrupt, os.Kill)&#xA;            defer signal.Stop(c)&#xA;            &amp;lt;-c&#xA;        }()&#xA;    并发压测&#xA;        func concurrent(done chan struct{}, fn func(), num int, ccu int, qps int) {     # num总数，ccu并行数，qps并发数&#xA;            interval := time.Duration(1e9/qps) * time.Nanosecond&#xA;            don := make(chan struct{}, 2)&#xA;            go func() {&#xA;                &amp;lt;-done&#xA;                for i := 0; i &amp;lt; ccu; i++ {&#xA;                    don &amp;lt;- struct{}{}&#xA;                }&#xA;            }()&#xA;&#xA;            //&#xA;            tasks := make(chan struct{})&#xA;            go func() {&#xA;                var wg sync.WaitGroup&#xA;                wg.Add(num)&#xA;                for i := 0; i &amp;lt; num; i++ {&#xA;                    tasks &amp;lt;- struct{}{}&#xA;                    wg.Done()&#xA;                    time.Sleep(interval)&#xA;                }&#xA;                wg.Wait()&#xA;                close(tasks)&#xA;            }()&#xA;&#xA;            //&#xA;            var wg sync.WaitGroup&#xA;            wg.Add(ccu)&#xA;            for i := 0; i &amp;lt; ccu; i++ {&#xA;                go func() {&#xA;                    defer wg.Done()&#xA;                    for range tasks {&#xA;                        select {&#xA;                        case &amp;lt;-don:&#xA;                            return&#xA;                        default:&#xA;                            fn()&#xA;                        }&#xA;                    }&#xA;                }()&#xA;            }&#xA;            wg.Wait()&#xA;        }&#xA;        m := sync.Mutex{}&#xA;        count := 0&#xA;        do := func(){&#xA;            m.Lock()&#xA;            count++&#xA;            m.Unlock()&#xA;        }&#xA;        concurrent(done, do, 999, 100, 1e3)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Python</title>
      <link>https://runout.run/docs/pl/python/</link>
      <pubDate>Tue, 09 Oct 2018 16:05:05 +0800</pubDate>
      <guid>https://runout.run/docs/pl/python/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;虚拟机语言&#xA;虽然是脚本语言，可以预编译成pyc文件来执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;shell&#34;&gt;&#xA;  shell&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shell&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;#! /usr/bin/python&#xA;# -*- coding: utf8 -*-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;规范&#xA;    pep8&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内置函数&#34;&gt;&#xA;  内置函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;&#xA;    input(&amp;quot;&amp;quot;)&#xA;        # x = int(input(&amp;quot;Please enter an integer:&amp;quot;))&#xA;    print(&amp;quot;%s&amp;quot;, % s1)&#xA;        ## %.3s % (&amp;quot;abcdef&amp;quot;)取3字符&#xA;        ## %.* s % (2, &amp;quot;abcd&amp;quot;)取2字符)&#xA;    # %r repr()显示字符串&#xA;        # %c 单个字符&#xA;        # %b 二进制整数&#xA;        # %x 十六进制整数&#xA;        # %d 十进制整数&#xA;        # %i 十进制整数&#xA;        # %o 八进制整数&#xA;        # %e %E 指数(基底分别为e E)&#xA;        # %-10.3f %-10.3F 浮点数&#xA;        ## 10位宽, 小数精确3位, 右对齐&#xA;        # %g %G 指数(e E)或浮点数(根据显示长度决定)&#xA;        # %% 字符%&#xA;        print(&amp;quot;c is %s, e is %i&amp;quot; % (c, e)&#xA;    str(1)&#xA;    int(&amp;quot;1&amp;quot;)&#xA;    range(1, 10)&#xA;        # range(-2, -11, -3)&#xA;    exec(&#39;&#39;)&#xA;        # 执行字符串中的代码&#xA;    execfile(r&#39;a.py&#39;)&#xA;    eval(&#39;2 * 3&#39;, globals, locals)&#xA;        # 执行字符串中的表达式&#xA;        # ast.literal_eval&#xA;    compile(str, filename, kind)&#xA;        # 编译字符串为模块&#xA;        # kind取值: single单语句, exec多语句, eval一个表达式&#xA;    assert 1 != 1&#xA;    repr(list)&#xA;        # 对象转换成代码字符串　&#xA;    map(str, range(100))&#xA;    filter()&#xA;    reduce()&#xA;    locals()&#xA;        # 当前作用域的变量字典&#xA;    isinstance(value, list)&#xA;    hasattr(obj, &#39;__call__&#39;)&#xA;        # 判断是否函数&#xA;    type(l)&#xA;        # 返回对象类型，或创建metaclass&#xA;    chr(48)&#xA;        # 返回字符&#xA;    unichr&#xA;    ord(&#39;0&#39;)&#xA;        # 返回ascii码&#xA;    bool()&#xA;    iter()&#xA;    next()&#xA;    zip(&#39;abc&#39;, &#39;123&#39;)&#xA;        list(zip())&#xA;o-&amp;gt; 文件&#xA;    spath = &amp;quot;D:/a.txt&amp;quot;&#xA;    f = open(spath, &amp;quot;w&amp;quot;)&#xA;        # 没有时创建&#xA;    f.write(&amp;quot;a\n&amp;quot;)&#xA;    f.writelines(&amp;quot;b&amp;quot;)&#xA;    f.close()&#xA;&#xA;    f = open(spath, &amp;quot;r&amp;quot;)&#xA;    for line in f:&#xA;        print(&amp;quot;%s&amp;quot; % line)&#xA;    f.readline()&#xA;    f.close()&#xA;o-&amp;gt; 文档&#xA;    dir(list)&#xA;    help(s.replace)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 基本类型&#xA;    数字&#xA;        1.2, 3+4j, Decimal, Fraction&#xA;    字符串&#xA;&#xA;&#xA;    列表&#xA;        [1, 2]&#xA;    字典&#xA;        {&#39;a&#39;:1}&#xA;    元组&#xA;        (1)&#xA;    文件&#xA;        open(&#39;eggs&#39;, &#39;r&#39;)&#xA;    集合&#xA;        {&#39;a&#39;}&#xA;    其他类型&#xA;        类型, None, False, True&#xA;    编程单元&#xA;        函数, 模块, 类&#xA;    实现相关类型&#xA;        编译代码堆栈跟踪&#xA;                &#xA;o-&amp;gt; 扩展属性&#xA;    dict = type(&#39;dict&#39;, (dict,), {})&#xA;    d = dict()&#xA;    d.a = 1&#xA;&#xA;o-&amp;gt; 序列&#xA;    [1,&#xA;    2]&#xA;    [1, [2]]&#xA;&#xA;    len(l)&#xA;    l[0]&#xA;    l[-1]&#xA;    l[1:3]&#xA;    l[1:]&#xA;    l[:3]&#xA;    l[:-1]&#xA;    l[:]&#xA;&#xA;    l + l&#xA;    l * 2&#xA;    del l[1:3]&#xA;    o-&amp;gt; 字符串&#xA;        # 不可变&#xA;        r&#39;a&#39; R&#39;a&#39; u&#39;a&#39; U&#39;a&#39; b&#39;a&#39; B&#39;a&#39;&#xA;        &#39;abc\&#xA;        def&#39;&#xA;        &#39;a&#39; &#39;b&#39;&#xA;        &#39;a&#39; &amp;quot;a&amp;quot; &#39;&#39;&#39;a&#39;&#39;&#39; &amp;quot;&amp;quot;&amp;quot;a&amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;        s.startswith(&#39;a&#39;)&#xA;        s.find(&#39;a&#39;)&#xA;        s.replace(&#39;a&#39;, &#39;A&#39;)&#xA;        s.split(&#39;,&#39;)&#xA;        s.join(list)&#xA;        s.upper()&#xA;        s.isalpha()&#xA;        s.isdigit()&#xA;        s.rstrip()&#xA;                # 去右侧空白&#xA;        &#39;%s, %s&#39; % (&#39;a&#39;, &#39;b&#39;)&#xA;        &#39;{0},{1}&#39;.format(&#39;a&#39;, &#39;b&#39;)&#xA;&#xA;        if &#39;a&#39; in name:&#xA;    o-&amp;gt; 列表&#xA;        l.append(&#39;h&#39;)&#xA;        l.pop(2)&#xA;            # 弹出特定位置&#xA;        l.sort()&#xA;        l.reverse()&#xA;&#xA;        print(l)&#xA;&#xA;        for x in word:&#xA;&#xA;        [2 * i for i in [2,3,4] if i &amp;gt; 2]&#xA;            # 列表解析&#xA;            [row[1] + 1 for row in M]&#xA;            [M[i][i] for i in [0, 1, 2]]&#xA;            {ord(x) for x in &#39;spaam&#39;}&#xA;                # 创建集合&#xA;            {x: ord(x) for x in &#39;spaam&#39;}&#xA;                # 创建字典&#xA;    o-&amp;gt; 元组&#xA;        # 不可变&#xA;        (&#39;a&#39;, &#39;b&#39;)&#xA;        (1,) + (2,)&#xA;            # (1, 2)&#xA;        t.index(&#39;c&#39;)&#xA;        t.count(&#39;c&#39;)&#xA;    o-&amp;gt; set&#xA;        s = set(&#39;a&#39;)&#xA;        set([1])&#xA;        s.add(2)&#xA;&#xA;        s1, s2&#xA;        s1 &amp;amp; s2&#xA;        s1 | s2&#xA;        s1 - s2&#xA;        {x ** 2 for x in [1,2,3,4]}&#xA;            # 返回set&#xA;&#xA;o-&amp;gt; 字典&#xA;    d = {&#39;a&#39;: &#39;aaa&#39;, &#39;b&#39;: &#39;bbb&#39;, &#39;c&#39;: 12}&#xA;    d[&#39;d&#39;] = 3&#xA;&#xA;    d.items()&#xA;        # key value&#xA;    d.keys()&#xA;        list(d.keys())&#xA;&#xA;    len(d)&#xA;    del d[&#39;a&#39;]&#xA;    d.get(&#39;a&#39;, 0)&#xA;    d[&#39;a&#39;]&#xA;&#xA;    for key in d:&#xA;    if &#39;a&#39; in d:&#xA;    d[&#39;a&#39;] if &#39;a&#39; in d else 0&#xA;o-&amp;gt; 文件&#xA;    f = open(&#39;data.txt&#39;, &#39;w&#39;)&#xA;    f.write(&#39;a&#39;)&#xA;    f.close()&#xA;&#xA;    text = f.read()&#xA;        text.split()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;语句&#34;&gt;&#xA;  语句&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 语句&#xA;    在物理行中用分号划分逻辑行&#xA;    pass&#xA;o-&amp;gt; 运算符&#xA;    + - * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= == !=&#xA;    &amp;amp; | ^ ~&#xA;        # 按位与 或 异或 翻转(x 变为 -(x + 1))&#xA;    not and or&#xA;    **&#xA;        # 幂&#xA;    //&#xA;        # 取整除&#xA;    code if None else 0&#xA;    True and 1 or 0&#xA;o-&amp;gt; 条件&#xA;    if x &amp;lt; 0:&#xA;            x = 0&#xA;    elif x == 0:&#xA;    else:&#xA;o-&amp;gt; 循环&#xA;    for x in a:&#xA;    else:&#xA;&#xA;    while running:&#xA;    else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;函数&#xA;    def sum(a, b=2, *args, **kwargs):&#xA;            # *args得到元组, kwargs得到字典&#xA;            &#39;&#39;&#39; doc&#xA;        string&#39;&#39;&#39;&#xA;&#xA;        global x&#xA;        nonlocal y&#xA;        return a + b&#xA;    sum(a=1)&#xA;    sum.__doc__&#xA;&#xA;    def make_repeater(n):&#xA;        return lambda s: s * n&#xA;            # lambda只能跟表达式，返回一个函数&#xA;生成器&#xA;    def gn2():&#xA;        yield&#xA;    def gn(N):&#xA;        for i in range(N):&#xA;            yield i ** 2&#xA;        yield from gn2()&#xA;            # 相当于静态引入gn2&#xA;    g = gn()&#xA;    next(g)&#xA;    g.send(1)&#xA;asyncio模块&#xA;    @asyncio.coroutine&#xA;    def f():&#xA;        yield from asyncio.sleep(1)&#xA;    loop = asyncio.get_event_loop()&#xA;    tasks = [asyncio.async(f())]&#xA;    loop.run_until_complete(asyncio.wait(tasks))&#xA;    loop.close()&#xA;协程&#xA;    @types.coroutine&#xA;    def f2():&#xA;        yield&#xA;&#xA;    async def f():&#xA;        print(1)&#xA;        await f2()&#xA;                # 协程显式交替，线程不用写，会隐式交替&#xA;&#xA;    try:&#xA;        f().send(None)&#xA;    except StopIteration:&#xA;        pass&#xA;协程asyncio&#xA;    async f():&#xA;        await asyncio.sleep(1)&#xA;    loop = asyncio.get_event_loop()&#xA;    tasks = [asyncio.ensure_future(f())]&#xA;    loop.run_until_complete(asyncio.wait(tasks))&#xA;    loop.close()&#xA;协程属性&#xA;    gi_frame&#xA;        f_code&#xA;            co_filename&#xA;        f_lineno&#xA;属性&#xA;    __name__&#xA;    __code__&#xA;    __annotations__&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;oop&#34;&gt;&#xA;  oop&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#oop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Base:&#xA;    __metaclass__ = models.SubfieldBase&#xA;        # __metaclass__实例化结果是类，用于继承&#xA;    description = &#39;&#39;&#xA;    def __init__(self, name):&#xA;        # self就是this&#xA;        #  __del__(self)&#xA;        # __str__(self)&#xA;        # __lt__(self)&#xA;        # __getitem__(self, key)&#xA;        ## x[key]索引时调用&#xA;        # __len__(self)&#xA;        super(Base, self).__init__(*args, **kwargs)&#xA;        self.data = []&#xA;&#xA;    def add(self, x)&#xA;        self.data.append(x)&#xA;    @classmethod&#xA;    def t1(cls):&#xA;    @staticmethod&#xA;    def t2():&#xA;class Child(Base):&#xA;    # 继承&#xA;    def plus(self, a, b):&#xA;        return a + b&#xA;oChild = Child()&#xA;oChild.add(&amp;quot;str1&amp;quot;)&#xA;oChild.data&#xA;oChild.plus(2, 3)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模块&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# .pyc是字节编译文件&#xA;# __name__ 等于&#39;__main__&#39;时程序本身使用运行, 否则是引用&#xA;&#xA;# a.py&#xA;def add_func(a, b):&#xA;        return a + b&#xA;# b.py&#xA;from a import add_func&#xA;    # import add_func as f&#xA;    # from a import *&#xA;&#xA;# __init__.py&#xA;    # 表示文件夹为包, 可空&#xA;&#xA;包路径&#xA;    # 环境变量PYTHONPATH中的值&#xA;    import sys&#xA;    import os&#xA;&#xA;    sys.path&#xA;    sys.path.append(os.getcwd() + &amp;quot;\\parent\\child&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;异常&#34;&gt;&#xA;  异常&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e5%b8%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;if s == &amp;quot;&amp;quot;:&#xA;    raise Exception(&amp;quot;must not be empty.&amp;quot;)&#xA;try:&#xA;    i = int(s)&#xA;except Exception as err:&#xA;    # except Exception, err&#xA;    print(&#39;Error %d: %s&#39; % (e.args[0], e.args[1]))&#xA;except:&#xA;finally:&#xA;    print(&amp;quot;Goodbye.&amp;quot;)&#xA;else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模块-1&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;os&#xA;sys&#xA;    argv&#xA;        # 参数列表, 多维列表&#xA;    exit()&#xA;        # 退出线程&#xA;imp&#xA;    reload&#xA;        # 重载模块&#xA;time&#xA;timeit&#xA;profile&#xA;decimal&#xA;fractions&#xA;urllib&#xA;http&#xA;    http.server&#xA;        # python3中的SimpleHTTPServer&#xA;re&#xA;functools&#xA;itertools&#xA;SimpleHTTPServer&#xA;    # python2自带ftp服务器。&#xA;    pythom -m SimpleHTTPServer 8080&#xA;&#xA;&#xA;PyQt&#xA;    # gui&#xA;PyGTK&#xA;    # gui&#xA;wxPython&#xA;    # gui&#xA;TkInter&#xA;    # gui&#xA;matplotlib&#xA;    # 图形&#xA;pillow&#xA;    # ocr, 文字识别&#xA;pytesseract&#xA;    # ocr, 精确&#xA;&#xA;&#xA;numpy&#xA;math&#xA;random&#xA;scipy&#xA;    # 科学计算&#xA;&#xA;beautifulsoup&#xA;    # 网页结构化&#xA;scrapy&#xA;    # 网页结构化&#xA;requests&#xA;phantomJS&#xA;    # 运行网页js&#xA;selenium&#xA;    # 运行网页js&#xA;&#xA;&#xA;pandas&#xA;    # 数据分析，产生数据结构、操作、统计、绘图&#xA;seaborn&#xA;    # 数据可视化&#xA;scikit-learn&#xA;    # 机器学习&#xA;nltk&#xA;    # 自然语言分析&#xA;&#xA;&#xA;mysql-connector&#xA;mysqlclient&#xA;PyMySQL&#xA;MySQLdb&#xA;redis.py&#xA;south&#xA;    # 表结构迁移, django自带&#xA;&#xA;pickle&#xA;    # 持久化&#xA;qrcode&#xA;    # 二维码&#xA;&#xA;&#xA;ast&#xA;    # 运算前检查的eval()&#xA;datetime&#xA;shutil&#xA;    # shell&#xA;&#xA;&#xA;fabric&#xA;    # 运程自动部署&#xA;celery&#xA;    # 定时调度&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ipython notebook&#xA;    # 在线运行python&#xA;bpython&#xA;    # 更好的repl&#xA;pdb&#xA;    # 调试&#xA;cprofile&#xA;    # 性能测试&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;steuptools&#34;&gt;&#xA;  steuptools&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#steuptools&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;easy_install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pip&#34;&gt;&#xA;  pip&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pip&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pip install -i http://pypi.douban.com/simple/ torndb&#xA;    # 用豆辨的pypi索引&#xA;pip install ipython==4.2.0&#xA;    # 安装指定版本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pyenv&#34;&gt;&#xA;  pyenv&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pyenv&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pyenv versions&#xA;pyenv install 3.7.6&#xA;    --list&#xA;pyenv virtualenv 3.7.6 37&#xA;eval &amp;quot;$(pyenv init -)&amp;quot;&#xA;eval &amp;quot;$(pyenv virtualenv-init -)&amp;quot;&#xA;pyenv activate 37&#xA;pyenv deactivate&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;conda&#34;&gt;&#xA;  conda&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#conda&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;环境相关&#xA;    conda env&#xA;        create -f e.yml     # 创建环境&#xA;            -n name1    &#xA;        list                # 列出所有环境&#xA;        remove -n name1     # 删除环境&#xA;    conda activate e1&#xA;    conda init bash&#xA;包相关&#xA;    conda list              # 当前环境所有软件包&#xA;    conda search pillow     # 列出包所有版本&#xA;    conda install pillow=7.0.0&#xA;        -c                  # 指定channel，相当于命名空间&#xA;    conda uninstall pillow&#xA;    conda upgrade numpy&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;容器&#34;&gt;&#xA;  容器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;gunicorn&#xA;    # python实现&#xA;    sudo pip install gunicorn&#xA;    gunicorn -w4 -b0.0.0.0:8001 app.wsgi&#xA;uwsgi&#xA;    # c语言实现&#xA;    sudo pip install uwsgi&#xA;    uwsgi --http :8001 --chdir /path/to/project --home=/path/to/env --module project.wsgi&#xA;            # --home指定virtualenv的路径&#xA;nginx&#xA;shell&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Clojure</title>
      <link>https://runout.run/docs/pl/clojure/</link>
      <pubDate>Tue, 09 Oct 2018 16:00:21 +0800</pubDate>
      <guid>https://runout.run/docs/pl/clojure/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程&#xA;    操作符知道自己的特征值(identity value), 如+是0, *是1&#xA;    数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃&#xA;    集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能&#xA;            # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的&#xA;    没有尾递归优化，不常用递归，要用loop.recur&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    s-expressions&#xA;            (max 3 5)&#xA;            (+ 1 (* 2 3))&#xA;            (def meaning-of-life 42)&#xA;            (if (&amp;lt; meaning-of-life 0) &amp;quot;negative&amp;quot; &amp;quot;non-negative&amp;quot;)&#xA;    (def droids [&amp;quot;Huey&amp;quot; &amp;quot;Dewey&amp;quot; &amp;quot;Louie&amp;quot;])&#xA;            (count droids)&#xA;            (droids 0)&#xA;    (def me {:name &amp;quot;Paul&amp;quot; :age 45 :sex :male})&#xA;            (:age me)&#xA;    (defn percentage [x p] (* x (/ p 100.0)))&#xA;            (percentage 200 10)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发&#34;&gt;&#xA;  并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 原子变量&#xA;        # 对一个值进行同步更新&#xA;(def my-atom (atom 42))&#xA;(deref my-atom)&#xA;@my-atom&#xA;(swap! my-atom inc)&#xA;(swap! my-atom + 2)&#xA;(reset! my-atom 0)&#xA;&#xA;(def session (atom {}))&#xA;(swap! session assoc :username &amp;quot;paul&amp;quot;)&#xA;&#xA;(if (compare-and-set! a old new)&#xA;        # 判断原子变量a的值是否是old, 是时赋成new并返回true&#xA;new&#xA;(recur))&#xA;&#xA;o-&amp;gt; conj 添加新成员&#xA;(def players (atom ()))&#xA;(defn list-players []&#xA;(response (json/encode @players)))&#xA;(defn create-player [player-name]&#xA;(swap! players conj player-name)&#xA;(status (response &amp;quot;&amp;quot;) 201))&#xA;(defroutes app-routes&#xA;(GET &amp;quot;/players&amp;quot; [] (list-players))&#xA;(PUT &amp;quot;/players/:player-name&amp;quot; [player-name] (create-player player-name)))&#xA;(defn -main [&amp;amp; args]&#xA;(run-jetty (site app-routes) {:port 3000}))&#xA;&#xA;o-&amp;gt; cons列表首添加元素&#xA;(def listv2 (cons 4 listv1))&#xA;&#xA;o-&amp;gt; validator&#xA;        # 值改变之前调用&#xA;(def non-negative (atom 0 :validator #(&amp;gt;= % 0)))&#xA;(reset! non-negative -1)&#xA;&#xA;o-&amp;gt; 监视器&#xA;        # 值改变之后调用　&#xA;(def a (atom 0))&#xA;(add-watch a :print #(println &amp;quot;Changed from &amp;quot; %3 &amp;quot; to &amp;quot; %4))&#xA;(swap! a + 2)&#xA;        # !的命名表示函数是事务不安全的&#xA;&#xA;o-&amp;gt; 代理&#xA;        # 对一个值进行异步更新。&#xA;        # 代理维护的数据与事务数据相同。代理具有事务性，send会在事务成功后生效&#xA;        # 方便做内存并发日志系统&#xA;(def my-agent (agent 0))&#xA;@my-agent&#xA;(send my-agent inc)&#xA;        # send在值更新之前立即返回，不进行重试。多线程同时调用send, 调用被串行。具有副作用&#xA;        # send使用公用线程池，send-off使用一个新线程，send-via使用由参数指定的executor&#xA;(send my-agent #((Thread/sleep 2000) (inc %)))&#xA;        # 设置延迟时间&#xA;(await my-agent)&#xA;        # 等待代理执行完成后再继续。await-for函数可以设置超时时间&#xA;&#xA;(def non-negative (agent 1 :validator (fn [new-val] (&amp;gt;= new-val 0))))&#xA;        # 代理可以使用校验器和监视器&#xA;        # 校验器失败时抛出异常，代理进入失效状态&#xA;        # 错误处理模式默认为 :fail, 可以置为:continue&#xA;        # 可以设置错误处理函数&#xA;(agent-error non-negative)&#xA;        # 查看代理是否在失效状态&#xA;(restart-agent non-negative 0)&#xA;        # 重置失效状态&#xA;&#xA;o-&amp;gt; 引用&#xA;        # 只有在事务中才能修改引用的值，对多个值进行同步更新&#xA;(def my-ref (ref 0))&#xA;@my-ref&#xA;&#xA;(dosync (ref-set my-ref 42))&#xA;        # dosync创建一个事务，事务同swap!一样，用重试机制实现&#xA;        # clojure的事务有原子性，一致性，隔离性，没有持久性&#xA;(dosync (alter my-ref inc))&#xA;        # commute替换alter，可以得到不很强的隔离性，用于做优化&#xA;(defn transfer [from to amount]&#xA;(dosync &#xA;    (alter from - amount)&#xA;    (alter to + amount)))&#xA;&#xA;o-&amp;gt; threed&#xA;(defn stress-thread [from to iterations amount]&#xA;(Thread. #(dotimes [_ iterations] (transfer from to amount))))&#xA;(let [t1 (stress-thread checking savings 100 100)&#xA;    t2 (stress-thread savings checking 200 100)]&#xA;(.start t1)&#xA;(.start t2)&#xA;(.join t1)&#xA;(.join t2))&#xA;&#xA;o-&amp;gt; ensure确保当前返回的值不被其它事务修改&#xA;(when (and (= (ensure left) :thinking) (= (ensure right) :thinking))&#xA;(ref-set philosopher :eating))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;csp&#34;&gt;&#xA;  csp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#csp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        core.async提供了channel和go块&#xA;        引入的core.async中部分函数名与clojure核心库函数名冲突&#xA;&#xA;o-&amp;gt; channel&#xA;(def c (chan))&#xA;(thread (println &amp;quot;Read:&amp;quot; (&amp;lt;!! c) &amp;quot;from c&amp;quot;))&#xA;        # thread是core.async提供的辅助宏，将其中代码运行在一个单独的线程上&#xA;(&amp;gt;!! c &amp;quot;Hello thread&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;用例&#34;&gt;&#xA;  用例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%a8%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;求和&#xA;(defn recursive-sum &#xA;&amp;quot;&amp;quot;&#xA;        # 文档字符串&#xA;        ## (require &#39;[philosophers.util :refer :all])&#xA;        ## (clojure.repl/doc swap-when!) 来查看文档字符串&#xA;[numbers &amp;amp; args])&#xA;        # &amp;amp;表示可变参数&#xA;        ## (apply f old args) 将args展开，作为附加参数传递给f&#xA;(if (empty? numbers)&#xA;    0&#xA;    (+ (first numbers) (recursive-sum (rest numbers))))&#xA;&#xA;(defn reduce-sum [numbers]&#xA;(reduce (fn [acc x] (+ acc x)) 0 numbers))&#xA;&#xA;(defn sum [numbers]&#xA;(reduce + numbers))&#xA;&#xA;o-&amp;gt;并行&#xA;(ns sum.core&#xA;(:require [clojure.core.reducers :as r]))&#xA;&#xA;(defn parallel-sum [numbers]&#xA;(r/fold + numbers))&#xA;&#xA;(def numbers (into [] (range 0 10000)))&#xA;(time (sum numbers))&#xA;(time (sum numbers))&#xA;        # 预热jim编译器&#xA;(time (parallel-sum numbers))&#xA;&#xA;o-&amp;gt; map&#xA;(def counts {&amp;quot;apple&amp;quot; 2 &amp;quot;orange&amp;quot; 1})&#xA;        (get counts &amp;quot;apple&amp;quot; 0)&#xA;        (get counts &amp;quot;banana&amp;quot; 0)&#xA;                # 没有时返回设定的默认值0&#xA;        (assoc counts &amp;quot;banana&amp;quot; 1)&#xA;        (assoc counts &amp;quot;apple&amp;quot; 3)&#xA;&#xA;o-&amp;gt; frequencies&#xA;(defn word-frequencies [words]&#xA;(reduce&#xA;(fn [counts word] (assoc counts word (inc (get counts word 0))))&#xA;{} words))&#xA;&#xA;(frequencies [&amp;quot;one&amp;quot; &amp;quot;potato&amp;quot;])&#xA;        # 标准库中已提供&#xA;&#xA;o-&amp;gt; partial函数&#xA;        # 返回一个被局部代入的函数&#xA;(def multiply-by-2 (partial * 2))&#xA;(multiply-by-2 3)&#xA;&#xA;o-&amp;gt; 序列&#xA;(defn get-words [text] (re-seq #&amp;quot;\w+&amp;quot; text))&#xA;(get-words &amp;quot;one tow three four&amp;quot;)&#xA;(map get-words [&amp;quot;one two three&amp;quot; &amp;quot;four five six&amp;quot;])&#xA;(mapcat get-words [&amp;quot;one two three&amp;quot; &amp;quot;four five six&amp;quot;])&#xA;        # 平辅数组&#xA;&#xA;o-&amp;gt; iterate&#xA;        # 不断将函数应用到初始值，第一次返回值，第二次返回值&#xA;(take 10 (iterate inc 0))&#xA;(take 10 (iterate (partial + 2) 0))&#xA;(take-last 5 (range 0 10000))&#xA;        # 头元素使用后舍弃，耗相同的内存&#xA;&#xA;o-&amp;gt; pmap&#xA;(pmap #(frequencies (get-words %)) pages)&#xA;        # pmap在需要结果时并行计算，仅生成需要的结果，称为半懒惰(semi-lazy)&#xA;        # #(...)是读取器宏，来快速创建匿名函数，参数通过%1, %2标识, 只有一个参数时可以是%&#xA;        ## (fn [page] (frequencies (get-words page)))与其等价&#xA;&#xA;o-&amp;gt; merge-with&#xA;        # 标准库函数&#xA;(merge-with f &amp;amp; maps)&#xA;        # 将maps中其余map合并到第一个map中，返回合并后的map&#xA;        ## 同键名时，多个值从左向右地合并，调用传递的f(val-in-result val-in-latter)&#xA;(def merge-counts (partial merge-with +))&#xA;(merge-counts {:x 1 :y 2} {:y 1 :z 1})&#xA;&#xA;o-&amp;gt; partition-all&#xA;        # 序列分批&#xA;(partition-all 4 [1 2 3 4 5 6 7 8 9 10])&#xA;        # ((1 2 3 4) (5 6 7 8) (9 10))&#xA;&#xA;o-&amp;gt; reducers包&#xA;        # 化简器，不代表函数的结果，代表如何产生结果的描述&#xA;        ## 嵌套的函数返回化简器，比返回懒惰序列效率更高&#xA;        ## 可以对整个嵌套链的集合操作，可以用fold进行并行化&#xA;        # clojure.core中大部分函数都有其对应的化简器版本&#xA;(require &#39;[clojure.core.reducers :as r]&#39;)&#xA;(r/map (partial * 2) [1 2 3 4])&#xA;        # 返回一个化简器(reducible)&#xA;(reduce conj [] reducible)&#xA;        # conj函数第一个参数为一个集合(初始值为[]), 将第二个参数合并到第一个参数中&#xA;(into [] reducible)&#xA;        # into函数为内置函数，同上&#xA;&#xA;o-&amp;gt;协议(类似java中的接口)来定义&#xA;(defprotocol CollReduce&#xA;        # 化简&#xA;(coll-reduce [coll f] [coll f init]))&#xA;        # coll相当于this, 支持多态性分派(polymorphic dispatch)&#xA;(coll-reduce coll f)&#xA;&#xA;(defn my-reduce&#xA;([f coll] (coll-reduce coll f))&#xA;([f init coll] (coll-reduce coll f init)))&#xA;(my-reduce + [1 2 3 4])&#xA;(my-reduce + 10 [1 2 3 4])&#xA;&#xA;(defn make-reducer [reducible transforms]&#xA;(reify&#xA;    CollReduce&#xA;    (coll-reduce [_ f1]&#xA;    (coll-reduce reducible (transformf f1) (f1)))&#xA;    (coll-reduce [_ f1 init]&#xA;    (coll-reduce reducible (transformf f1) init))))&#xA;        # 用reify实现一个协议&#xA;        # 调用reducible的coll-reduce方法。用transformf对f1进行转换，转换出的函数作为传给coll-reduce方法的一个参数&#xA;        # _表示未被使用的函数参数名，可以写成(coll-reduce [this f1])&#xA;&#xA;(defn my-map [mapf reducible]&#xA;(make-reducer reducible&#xA;    (fn [reducef]&#xA;    (fn [acc v]&#xA;        (reducef acc (mapf v))))))&#xA;        # acc是之前化简结果, v是集合元素。mapf对v进行转换&#xA;&#xA;o-&amp;gt; fold折叠&#xA;        # 不能适用于懒惰序列&#xA;(defprotocol CollFold&#xA;(coll-fold [coll n combinef reducef]))&#xA;&#xA;(defn my-fold&#xA;([reducef coll]&#xA;    (my-fold reducef reducef coll))&#xA;([combinef reducef coll]&#xA;    (my-fold 512 combinef reducef coll))&#xA;([n combinef reducef coll]&#xA;    (coll-fold coll n combinef reducef)))&#xA;&#xA;(defn make-reducer [reducible transformf]&#xA;(reify&#xA;    CollFold&#xA;    (coll-fold [_ n combinef reducef]&#xA;    (coll-fold reducible n combinef (transformf reducef)))&#xA;&#xA;    (CollReduce&#xA;    (coll-reduce [_ f1]&#xA;        (coll-reduce reducible (transformf f1) (f1)))&#xA;    (coll-reduce [_ f1 init]&#xA;        (coll-reduce reducible (transformf f1) init))))&#xA;&#xA;(def numbers (into [] (take 10000000 (repeatedly #(rand-int 10)))))&#xA;(require [&#39;reducers.parallel-frequencies :refer :all&#39;])&#xA;(time (frequencies numbers))&#xA;(time (parallel-frequencies numbers))&#xA;&#xA;o-&amp;gt; doall强迫懒惰序列对全部元素求值&#xA;(reduce + (doall (map (partial * 2) (range 10000))))&#xA;&#xA;o-&amp;gt; future&#xA;        # 单独线程中执行一段代码&#xA;        # 典型场景是异步通信&#xA;(def sum (future (+ 1 2 3 4 5)))&#xA;sum&#xA;        # 返回一个future对象&#xA;(deref sum)&#xA;@sum&#xA;        # 运行&#xA;(let [a (future (+ 1 2))&#xA;    b (future (+ 3 4))]&#xA;(+ @a @b))&#xA;        # let给a赋值，阻塞当前线程直到被求值&#xA;        # 外层加法将一直阻塞，直到所有代表的值被求值&#xA;&#xA;o-&amp;gt; promise&#xA;        # 创建promise对象后，代码并不会像future一样立即执行，等待deliver赋值后执行&#xA;(def meaning-of-life (promise))&#xA;(future (println &amp;quot;The meaning of life is:&amp;quot; @meaning-of-life))&#xA;(deliver meaning-of-life 42)&#xA;&#xA;o-&amp;gt; Compojure库的服务器&#xA;(def snippets (repeatedly promise))&#xA;(defn accept-snippet [n test]&#xA;(deliver (nth snippets n) test))&#xA;(future&#xA;(doseq [snippet (map deref snippets)]&#xA;    (println snippet)))&#xA;&#xA;(defroutes app-routes&#xA;(PUT &amp;quot;/snippet/:n&amp;quot; [n :as {:keys [body]}]&#xA;    (accept-snippet (edn/read-string n) (slurp body))&#xA;    (response &amp;quot;OK&amp;quot;)))&#xA;(defn -main [&amp;amp; args]&#xA;(run-jetty (site app-routes) {:port 3000}))&#xA;&#xA;o-&amp;gt; re-seq正则&#xA;(defn sentence-split [text]&#xA;(map trim (re-seq #&amp;quot;[^\.!\?:;]+[\.!\?:;]*&amp;quot; text)))&#xA;        # trim是内置函数&#xA;(defn is-sentence? [text]&#xA;(re-matches #&amp;quot;^.*[\.!\?:;]$&amp;quot; text))&#xA;&#xA;o-&amp;gt; reductions&#xA;        # 同reduce, 返回中间值构成的序列&#xA;(reductions + [1 2 3 4])&#xA;        # (1 3 6 10)&#xA;&#xA;o-&amp;gt; clj-http库&#xA;(def translator &amp;quot;http://localhost:3001/translate&amp;quot;)&#xA;(defn translate [text]&#xA;(future&#xA;    (:body (client/post translator {:body text}))))&#xA;&#xA;o-&amp;gt; delay在解引用前不求值&#xA;(def translations&#xA;(delay&#xA;    (map translate (strings-&amp;gt;sentences (map deref snippets)))))&#xA;&#xA;o-&amp;gt; 系统时间&#xA;(defn now []&#xA;(System/currentTimeMillis))&#xA;&#xA;o-&amp;gt; Schejulure库&#xA;(def session-sweeper&#xA;(schedule {:min (range 0 60 5)} sweep-sessions))&#xA;        # 定期调用&#xA;&#xA;o-&amp;gt; Useful库&#xA;(defn expired? [session]&#xA;(&amp;lt; @(:last-referenced session) (session-expiry-time)))&#xA;(defn sweep-sessions []&#xA;(swap! sessions #(remove-vals % expired?)))&#xA;        # 删除元素&#xA;&#xA;o-&amp;gt; Loop/Recur&#xA;(defn swap-when! [a pred f &amp;amp; args]&#xA;(loop []&#xA;    (let [old @a]&#xA;    (if (pred old)&#xA;        (let [new (apply f old args)]&#xA;        (if (compare-and-set! a old new)&#xA;            new&#xA;            (recur)))&#xA;        nil))))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;clojureScript&#xA;        # 编译到js&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>JS</title>
      <link>https://runout.run/docs/pl/js/</link>
      <pubDate>Tue, 09 Oct 2018 10:31:30 +0800</pubDate>
      <guid>https://runout.run/docs/pl/js/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特性&#xA;    原型链, 面向对象, 动态语言(已超出脚本语言的范畴)&#xA;    弱类型，变量都是var&#xA;    解释器有自己的内存管理机制(garbage collection)&#xA;    自由数据类型转换                        # 产生了==, ===的判断相等的不同定义&#xA;v8引擎&#xA;    直接生成机器码&#xA;    分代式GC&#xA;    java jvm工程师参数了优化&#xA;历史&#xA;    Netscape(现Mozilla)创建JavaScript, 但JavaScript是Sun(现Oracle)的注册商标&#xA;    作为标准提交给ECMA(欧洲计算机制造协会), 改名为ECMAScript&#xA;        ECMAScript 3(ES3) 作为标准广泛使用&#xA;        ECMAScript 5(ES5) 定义了新的语言标准&#xA;        JavaScript1.5是Mozilla的版本号, 相当于ES3,包含一些非标准语言扩展&#xA;            JavaScript1.8 在实现es7&#xA;        JavaScript解释器或引擎(engine)也有版本号&#xA;            Google的叫做V8(现在是4.0)&#xA;    微软改动并取名Jscript&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;标准&#34;&gt;&#xA;  标准&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%87%e5%87%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;ecmascript-6&#34;&gt;&#xA;  ECMAScript 6&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ecmascript-6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    目标是js可写&#xA;        复杂的应用程序&#xA;        函数库&#xA;        代码自动自成器(code generator)&#xA;    mozilla基于ECMAScript6 发布 JavaScript2.0&#xA;    V8, node.js使用&#xA;&#xA;let                                 # 块级作用域中声明变量&#xA;const                               # 声明常量&#xA;Set对象                              # 同java Set, 是一个数组&#xA;    属性&#xA;        size&#xA;    方法&#xA;        add(value)&#xA;        delete(value)&#xA;        has(value)&#xA;        clear()&#xA;Map对象                              # 键值对，键可以是对象&#xA;    使用&#xA;        var m = new Map();&#xA;        o = {p: &amp;quot;Helllo&amp;quot;};&#xA;        m.set(o, &amp;quot;content&amp;quot;);&#xA;        m.get(o);&#xA;    属性&#xA;        size&#xA;    方法&#xA;        set(key, value)&#xA;        get(key)&#xA;        has(key)&#xA;        delete(key)&#xA;        clear()&#xA;... (rest运算符)&#xA;yield关键字&#xA;class关键字&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;commonjs&#34;&gt;&#xA;  commonJS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#commonjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    模块化标准&#xA;    require同步加载, 再执行代码，会阻塞。对服务器不是问题，对浏览器是大问题&#xA;    输出的是值的拷贝&#xA;    require后的模块运行后缓存, 可手动清除缓存&#xA;commonJs规范下的javascript&#xA;    node.js&#xA;    mongoDB&#xA;    ringojs&#xA;使用&#xA;    var math = require(&#39;math&#39;);&#xA;    math.add(2, 3);&#xA;    let {stat, exists, readFile} = require(&#39;fs&#39;)&#xA;        # 加载fs所有方法生成_fs, 再取其中3个方法。没法做静态优化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;amd&#34;&gt;&#xA;  AMD&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#amd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    模块化标准&#xA;    异步加载, 预执行&#xA;使用&#xA;    require([&#39;math&#39;], functioni (math){&#xA;        math.add(2, 3);&#xA;    });&#xA;        # 加载成功后进行回调&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cmd&#34;&gt;&#xA;  CMD&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cmd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    sea.js提出&#xA;    懒执行&#xA;使用&#xA;    define(function(require, exports, module){ ... })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;词法&#34;&gt;&#xA;  词法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%8d%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;unicode编写的&#xA;    转义&#xA;        &#39;café&#39;表示为&#39;caf\u00e9&#39;&#xA;        &#39;é&#39; 也可以表示为&#39;e\u0301&#39;, e后面跟一个语调符&#xA;区分大小写                                   # html中不区分大小写&#xA;注释&#xA;    //, /**/&#xA;标识符和保留字&#xA;    要求&#xA;        开头以字母、下划线、dollar符。&#xA;        后续可以加数字&#xA;        可以出现unicode字符集中的Mn类、Mc类、Pc类，如           # Mn表示非间距字符，Mc表示影响基字符标志位的间距字符, Pc是连接两个字符的连接符或标点符号。&#xA;            é, π,&#xA;    保留字&#xA;        break, delete, function, return, typeof, case, do, if, switch, var, catch, else, in, this, void, continue, false, instanceof, throw, while, debugger, finally, new, true, with, default, for, null, try&#xA;    未被使用的名保留字&#xA;        class, const, enum, export, extends, import, super&#xA;    严格模式下的保留字&#xA;        implements, let, private, public, yield, interface, package, protected, static&#xA;    严格模式下不能用做变量名&#xA;        arguments, eval&#xA;    es6新增保留字&#xA;        await&#xA;    ECMAScript3将所有java关键字列为保留字&#xA;    全局属性和对象和函数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;直接量&#34;&gt;&#xA;  直接量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b4%e6%8e%a5%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;直接量(numeric literal)&#xA;    1&#xA;    1.2&#xA;    &amp;quot;hi&amp;quot;&#xA;    &#39;hi&#39;&#xA;    true&#xA;    false&#xA;    /javascript/gi&#xA;        # 用于模式匹配&#xA;        ## 实际是一个RegExp对象&#xA;        ## gi是用来修饰匹配模式的含义&#xA;    null&#xA;    {x:1, y:2}&#xA;        {foo}                                   # 等同 {foo: foo}, 简化写法常用于函数返回值&#xA;        {method () {}}                          # 等同 {method: function () {}}&#xA;        {*m () {}}                              # generator&#xA;        {[&#39;a&#39; + &#39;b&#39;]: 1}                        # object&#xA;        {[&#39;hello&#39;](){reutrn 0;}}                # 对象属性是Symbol值时, name属性返回这个Symbol值的描述&#xA;        {get a () {}, set a (val) {}}           # 属性getter, setter。get, set函数的函数名name是 &#39;get xxx&#39;, &#39;set xxx&#39;&#xA;    [1,2,3,4]&#xA;整型直接量&#xA;    0&#xA;    10&#xA;    0xff/0Xff                                   # 16进制&#xA;    0o377                                       # 8进制&#xA;        0377                                    # ECMAScript标准不支持八进制直接量，某些实现可以采用八进制表示&#xA;                                                # ECMAScript6严格模式下, 八进制直接量是明令禁止的&#xA;    0b11/0B11                                   # 2进制&#xA;浮点型直接量&#xA;    3.14&#xA;    .333&#xA;    6.02e23                                     # 6.02 x 10^23&#xA;    1.4E-32&#xA;字符串直接量&#xA;    ECMAScript5可多行                             # ECMAScript3规定必须一行&#xA;        &amp;quot;one\&#xA;        long line&amp;quot;&#xA;    模板字符串                                   # 保留换行，空格，缩进&#xA;        var name = &#39;Bob&#39;;&#xA;        `hello ${name}                          # ${}中可用任意表达式，包括函数&#xA;        how are you`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;可省略的分号&#xA;    通用规则: 独占一行，并与下一行不能整体解析时&#xA;        var a = f&#xA;        反例                                      # 以 (, [, /, +, - 开始的语句极可能和前一条语句一起解析，可写成 ;(a+b)&#xA;            (a+b).toString(); 就不可以&#xA;    例外规则&#xA;        return, break, continue占一行时，总加分号&#xA;        ++, -- 永远解析为前缀, 所以作后缀时要加分号   # 如　x [换行] ++ [换行] y, 解析为 x; ++y&#xA;    &#39;}&#39;之前的分号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;严格模式&#34;&gt;&#xA;  严格模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a5%e6%a0%bc%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;区别&#xA;    所有变量都要先声明&#xA;    增加了保留字(如await, protected, static, interface)&#xA;    eval, arguments当作关键字&#xA;    不允许八进制整数直接量(0前缀)&#xA;    不能给只读属性赋值，不能给不可扩展对象创建新成员&#xA;    arguments对象拥有参数的静态副本。               # 非严格模式中，都是引用，可以改变原值&#xA;    限制调用栈检测能力                              # 具有caller和arguments属性，但访问时会抛出异常&#xA;        arguments.caller, arguments.callee都会抛出类型错误异常&#xA;        fn.caller, fn.arguments禁止使用&#xA;    对象定义同名属性产生语法错误, 函数声明同名参数产生语法错误&#xA;&#xA;    禁止使用with语句&#xA;    this值在调用的函数中是undefined,                # this禁止指向全局变量&#xA;        指非属性调用，如eval()，非a.test()&#xA;    eval()代码不能创建局部变量或函数&#xA;        而是定义在eval创建的新作用域(在eval返回时弃用)中&#xA;        eval不包含外层作用域&#xA;    delete后非法标识符抛出异常&#xA;        如delete prop, 只能delete global[prop]&#xA;        delete不可配置属性抛出异常&#xA;    es5, es6中尾调用优化只在严格模式下开启             # 因为arguments.caller会跟踪函数调用栈, 无法开启&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模块化&#34;&gt;&#xA;  模块化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    es6中模块化思想是尽量静态化，编译时确定模块依赖关系与输入输出&#xA;    CommonJS(CMD)与AMD都只能在运行时确定&#xA;    UMD模式只是加了CMD和AMD的切换&#xA;es6&#xA;    特点&#xA;        import, export可以出现在顶层的任何位置&#xA;        import&#xA;            会变量提升, 会执行import的模块&#xA;            引入的变量是只读的，修改会报错。但可以修改引入变量的内部属性&#xA;            只加载3个方法，编译时加载，可能静态分析。但不能引用fs模块本身&#xA;            使引入宏(macro)和类型检查(type system)成为可能&#xA;        模块自动采用严格模式&#xA;        输出/引入的是值的只读引用, 值在运行时计算&#xA;    import&#xA;        import {stat, exists, readFile} from &#39;fs&#39;                   # 多引用&#xA;        import {a as b} from &#39;./profile&#39;                            # b 作为 a 的别名&#xA;        import &#39;lodash&#39;                                             # 只运行模块&#xA;        import * as circle from &#39;./circle&#39;                          # 引入模块到对象&#xA;            circle.area&#xA;        import a from &#39;./export-default&#39;                            # 引入模块中默认的导出, a可以起任意名，不用大括号&#xA;            import {default as xxx} from &#39;./&#39;                       # 本质是输出名字为default变量&#xA;        import def, {a} from &#39;./module&#39;                             # 同时引入default和其它变量&#xA;    export&#xA;        export var a = 1;&#xA;        export function f () {}&#xA;&#xA;        var b = 1, c = 1;&#xA;        export {b, c}                                               # 用于统一输出&#xA;&#xA;        export {v1 as sv1}&#xA;        export {a as b} from &#39;./someModule&#39;                         # 导入同时导出&#xA;        export v from &#39;mod&#39;                                         # 导入同时导出, es7提案可省略大括号&#xA;        export default function() {}                                # export default命令来配置默认导出, 本质是输出名字为default的变量，系统允许它取任意名&#xA;                                                                    # export default foo 导出的foo名在模块外部是无效&#xA;    继承&#xA;        export * from &#39;circle&#39;&#xA;        export var e = 2.7&#xA;        export default function() {}                                # 输出了circle模块的所有方法(忽略default), 又输出了自定义属性&#xA;循环引用&#xA;    CommonJS会输出已执行的部分&#xA;        写法问题&#xA;            var foo = require(&#39;a&#39;).foo&#xA;                a在别处循环引用时, 得到的foo可能是执行到一半的值&#xA;                而var a = require(&#39;a&#39;), a.foo就会得到执行完后的值&#xA;        o-&amp;gt; 例子&#xA;        a.js&#xA;            exports.done = false;&#xA;            var b = require(&#39;./b.js&#39;);&#xA;            console.log(&#39;a.js =&amp;gt; b.done : &#39;, b.done)&#xA;            exports.done = true;&#xA;            console.log(&#39;a.js done&#39;)&#xA;        b.js&#xA;            exports.doen = false;&#xA;            var a = require(&#39;./a.js&#39;)&#xA;            console.log(&#39;b.js =&amp;gt; a.done : &#39;, a.done);&#xA;            exports.done = true;&#xA;            console.log(&#39;a.js done&#39;)&#xA;            main.js&#xA;            var a = require(&#39;./a.js&#39;), b = require(&#39;./b.js&#39;)&#xA;            console.log(&#39;main.js =&amp;gt; a.done: &#39;, a.done, &#39; b.done: &#39;, b.done)&#xA;        执行&#xA;            b.js =&amp;gt; a.done: false&#xA;            b.js done&#xA;            a.js =&amp;gt; b.done: true&#xA;            a.js done&#xA;            main.js =&amp;gt; a.done: true b.done: true&#xA;&#xA;            a.js中require(&#39;./b.js&#39;)阻塞, 执行b.js&#xA;            b.js中require(&#39;./a.js&#39;), 加载已执行的a.js&#xA;            执行完b.js回到a.js, 执行完a.js&#xA;            main.js加载已执行的a.js b.js&#xA;    es6 import时不执行代码，而是引用&#xA;        o-&amp;gt; 例子                                  # CommonJS中不能执行, a加载b, b加载a, a没有输出, foo不存在, es6中可以执行&#xA;        a.js&#xA;            import {bar} from &#39;./b.js&#39;;&#xA;            export function foo() {&#xA;                bar();&#xA;                console.log(&#39;a.js done&#39;)&#xA;            }&#xA;        b.js&#xA;            import {foo} from &#39;./a.js&#39;;&#xA;            export function bar() {&#xA;                if(Math.random() &amp;gt; 0.5) {foo()}&#xA;            }&#xA;        babel-node a.js&#xA;&#xA;        o-&amp;gt; 例子&#xA;        even.js&#xA;            import {odd} from &#39;./odd&#39;&#xA;            export var counter = 0;&#xA;            export function even(n) {&#xA;                counter++;&#xA;                return n == 0 || odd(n - 1);&#xA;            }&#xA;        odd.js&#xA;            import {even} from &#39;./even&#39;;&#xA;            export function odd(n) {&#xA;                return n != 0 &amp;amp;&amp;amp; even(n - 1);&#xA;            }&#xA;        main.js&#xA;            import * as m from &#39;./even.js&#39;&#xA;            m.even(10)  // true&#xA;            m.counter    // 6                       # 10 变到 0 even执行了6次&#xA;            m.even(20)    // true                   # 20 变到 0 even执行了11次&#xA;            m.counter    // 17                      ＃es6中引用加载机制保证even, odd函数能加载，所以可执行。而CommonJS中循环引用，even和odd函数都不会加载&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类型与变量&#34;&gt;&#xA;  类型与变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b%e4%b8%8e%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;声明&#xA;    特点&#xA;        存值之前是undefined&#xA;        声明提前&#xA;        非声明变量赋值创建全局变量                     # ECMAScript 5 严格模式下未声明赋值会报错&#xA;            非声明的全局变量与声明全局变量的区别: 非声明的全局变量是可配置的(可delete)，而var声明的全局变量不可配置&#xA;        let&#xA;            支持了直接用{}的块级作用域&#xA;            只在块级作用域有效&#xA;                for(let i = 0; ...; ...)&#xA;            无变量提升&#xA;            声明前存在暂时性死区&#xA;                死区中使用该变量会直接报错&#xA;            重复声明报错&#xA;            声明的全局变量不再是全局对象的属性&#xA;                同样机制的还有const, class&#xA;        const&#xA;            只能在声明时赋值一次, 其他同let&#xA;    var x;&#xA;    x = 1;&#xA;    let a = 10&#xA;    const PI = 3.1415&#xA;        export const A = 1;&#xA;            import * as constants from &#39;./constants&#39;&#xA;            constants.A&#xA;类型&#xA;    特点&#xA;        可以拥有方法的类型, 不能拥有方法的类型&#xA;        可变(mutable)类型                           # 值可以改变, 比较(==, ===)是地址的比较&#xA;            对象&#xA;        不可变(immutable)类型                       # 比较(==, ===)是值的比较&#xA;            数字、布尔值、null、undefined、字符串     # 字符串不像c语言可以看作字符数组，js的字符串不可变&#xA;    原始值&#xA;        # 不可以拥有自己的方法&#xA;        null&#xA;        undefined&#xA;    原始类型(primitive type)                        # 可以拥有自己的方法, 原始类型都包含内置构造函数&#xA;        数字&#xA;        字符串&#xA;        布尔值&#xA;        Symbol&#xA;    对象类型(object type)或引用类型，如&#xA;        对象(object)是属性(property)的集合&#xA;            property由key/value组成&#xA;        全局对象(global object)&#xA;        数组类: Array&#xA;            内存连续保住的带编号的值的有序集合&#xA;        函数类: Function&#xA;            具有相关联的可执行代码的特殊对象&#xA;类型转换                                            # Symbol不可转换&#xA;    转换为数字                                      # 字符串允许在开始和结尾处带有空格&#xA;        false为 0&#xA;        true为 1&#xA;        &amp;quot;&amp;quot;为 0&#xA;        失败为 NaN&#xA;    转换为字符串&#xA;        -0 为&amp;quot;0&amp;quot;&#xA;        -Infinity 为&amp;quot;-Infinity&amp;quot;&#xA;        [9]为 &amp;quot;9&amp;quot;&#xA;        [&#39;a&#39;]其他数组，调用join()方法&#xA;    对象转换字符串                                    # 运算符+ == != 的处理运用这里的原理&#xA;                                                    # 日期对象有自己的重定义,valueOf与toString返回的原始值将直接使用&#xA;        toString()&#xA;        valueOf()                                   # 没有toString()方法时调用, 如果返回原始值，自动将它转换为字符串&#xA;            数组、函数、正则表达式返回对象本身&#xA;            日期类返回毫秒数&#xA;        无法得到原始值则抛出异常&#xA;    对象转换数字                                      # 运算符 - &amp;lt; 用了这里的原理&#xA;        首先尝试valueOf()                            # 如果返回原始值，自动转换为数字&#xA;        再尝试toString()                             # 自动转换为数字&#xA;        无法得到原始值则抛出异常&#xA;        例子&#xA;            数字&#xA;                []为0                                # valueOf -&amp;gt; toString -&amp;gt; &amp;quot;&amp;quot; -&amp;gt; 0&#xA;                [9]为9                               # valueOf -&amp;gt; toString -&amp;gt; &amp;quot;9&amp;quot; -&amp;gt; 9&#xA;相等性&#xA;    null == undefined&#xA;    &amp;quot;0&amp;quot; == 0&#xA;    0 == false&#xA;    &amp;quot;0&amp;quot; == false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;数字&#xA;    基础&#xA;        所有数字用二进制浮点数表示(64位, 如java中的double)&#xA;            # IEEE-754标准&#xA;            ## 整数范围 -2^53 ~ 2^53(大约900亿亿)&#xA;        实际的操作(数组索引, 位操作符)基于32位整数&#xA;        负号是一元运算符，并不是数字直接量语法的组成部分&#xA;        0与-0唯一差别&#xA;            1/zero !== 1/-0    # 正无穷大和负无穷大不等&#xA;    实数近似表示(几乎所有现代编程语言都存在, 因为都是IEEE-754标准)&#xA;        浮点数表示褛的个数为18 437 736 874 454 810 627个&#xA;        IEEE-754标准精确表示1/2, 1/8, 1/1024，但不精确表示1/10, 1/00。&#xA;            # 建议用大整数进行重要计算(如元, 角, 分各用整数表示)&#xA;            所以js只能近似表示0.1&#xA;            var x = .3 - .2&#xA;            var y = .2 - .1&#xA;            x == y        // =&amp;gt; false&#xA;            x == .1    // =&amp;gt; false&#xA;            y == .1    // =&amp;gt; true&#xA;字符串&#xA;    基础&#xA;        从0开始&#xA;        没有如c语言中的字符型&#xA;        采用UTF-16编码的Unicode字符集。&#xA;            是一组无符号16位值组成的序列。&#xA;                # 用16位内码表示, 表示一个单个字符&#xA;                ## 不能16位Unicode表示的遵循UTF-16编码规则，两个16位值来表示一个(代理项对)&#xA;                ### 长度为2的字符串可能表示一个Unicode字符,如var e =&amp;quot;\ud835\udc52&amp;quot;; e.length // =&amp;gt; 2&#xA;            字符串的操作不对代理项对单独处理&#xA;            不对字符串做标准代加工&#xA;                所以不能保证字符串是剑的UTF-16格式&#xA;    运算&#xA;        +            # 字符串连接&#xA;    unicode&#xA;        允许采用\uxxxx表示\u0000 到 \uFFFF之间的字符&#xA;        超出范围时用4字节表示, 如 \uD842\uDFB7&#xA;        &#39;\u20BB7&#39; 会被解释成 &#39;\u20BB&#39; + &#39;7&#39;&#xA;        &#39;\u{20BB7}&#39; 会正确解释&#xA;        多种表示法&#xA;            &#39;\z&#39;&#xA;            &#39;\172&#39;&#xA;            &#39;\x7A&#39;&#xA;            &#39;\u007A&#39;&#xA;            &#39;\u{7A}&#39;&#xA;    转义&#xA;        十六进制数表示Latin-1或Unicode中的任意字码, 由两位十六进制数指定&#xA;            &#39;\xA9&#39;        // =&amp;gt; ©&#xA;        \u表示4个十六进制数指定的Unicode字符&#xA;            &#39;\u03c0&#39;    // =&amp;gt;&#xA;        \n&#xA;        \&#39;&#xA;        \0            # 同\u0000, 表示空字符串&#xA;        \b            # 同\u0008, 表示退格符&#xA;        \t            # 同\u0009, 表示tab&#xA;        \v            # \u000B, 垂直制表符&#xA;        \f            # \u000C, 换页符&#xA;        \r            # \u000D, 回车&#xA;布尔&#xA;    转换&#xA;        # 所有值都可以转换为布尔值&#xA;        false&#xA;            undefined&#xA;            null&#xA;            0&#xA;            -0&#xA;            NaN&#xA;            &amp;quot;&amp;quot;&#xA;        true&#xA;            除以上，全部为true&#xA;    api&#xA;        toString()                              # 转换成&amp;quot;true&amp;quot;或&amp;quot;false&amp;quot;&#xA;null undefined&#xA;    类型&#xA;        null为object                            # 但可以表示数字类型、字符串类型&#xA;        undefined为&amp;quot;undefined&amp;quot;, 是一个单独类型&#xA;    比较&#xA;        null == undefined        // =&amp;gt; true&#xA;        null === undefined        // =&amp;gt; false&#xA;    无api                                       # .和[]取成员会产生类型错误&#xA;    bug&#xA;        undefined在ECMAScript可读/写，可赋任意值&#xA;    结论&#xA;        undefined表示系统级类似错误的空缺&#xA;        null表示程序级的，正常出现的空缺&#xA;&#xA;Symbol&#xA;    介绍&#xA;        原始数据类型，因为不是对象，所以不能new, 不能添加属性&#xA;        不参与类型转换, 但可以toString            # 可以String(s)得到 &#39;Symbol(a)&#39;, Boolean(s)得到true, !s 得到false。Number(s)会报错&#xA;        可以做属性名a[sym1] = 1, 不能用点运算符赋值或取值&#xA;        常用于设置常量结构体来switch，以消除魔术字符串&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;作用域&#34;&gt;&#xA;  作用域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%9c%e7%94%a8%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局变量&#xA;    就是定义顶级对象的属性                         # 这点在ECMAScript规范中强制规定&#xA;    在js代码任何地方都有定义&#xA;局部变量&#xA;    在函数内有定义，优先于全局变量&#xA;与c语言区别(嵌套作用域)&#xA;    c中{}内产生块级作用域(block scope), 其中变量其外不可见&#xA;    js中没有块级作用域，是函数作用域(function scope), 变量在内部嵌套函数中有定义。&#xA;声明提前&#xA;    内部嵌套函数而言, 变量声明之前就可用, 称为声明提前(hoisting)         # hoisting js函数里声明的所有变量(不赋值), 被&amp;quot;提前&amp;quot;到函数体顶部，在js引擎预编译时进行。&#xA;    例子&#xA;        var scope = &amp;quot;global&amp;quot;&#xA;        function f(){&#xA;            console.log(scope)                  # undefined, 因为局部scope声明提前，覆盖了全局scope, 而声明提前不定义, 定义在执行代码时进行&#xA;            var scope = &amp;quot;local&amp;quot;                 # 等价于开头var scope;&#xA;            console.log(scope)&#xA;        }&#xA;特点&#xA;    js本身设计中没有构造函数，普通函数，对象方法，闭包。这些都是莫须有的叫法&#xA;    内部函数可以访问外部函数上下文&#xA;    非严格格式直接声明变量，挂到global上&#xA;    作用域在函数中定义, 非块定义, 所以&#xA;        for(var i = 0; i &amp;lt; 10; i++){            # 中定义的i与value，在for之外可以被访问, 且声明提前&#xA;            var value = &#39;hello&#39;;&#xA;        }&#xA;this&#xA;    有调用对象就指向调用对象&#xA;    没调用对象指向全局对象&#xA;        O.a = function(){&#xA;            var b = function(){                 # b中的this永远是全局对象&#xA;                console.log(this);&#xA;            };&#xA;            b();&#xA;        };&#xA;        O.a()&#xA;    new 构造时this指向新对象&#xA;        var O = function(){this.val = 100;}&#xA;        var o = new O();&#xA;        console.log(o.val);                     # 这里输出o.val而不是O.val&#xA;    用apply或call或bind方法改变this指向&#xA;        function tt(){&#xA;            console.log(arguments.callee);      # 永远是tt本身&#xA;            console.log(this);                  # 都是下面定义的a&#xA;        }&#xA;        var a = &#39;1&#39;;&#xA;        tt.call(a, 1, 2);&#xA;        tt.apply(a, [1, 2]);&#xA;        var att = tt.bind(a);&#xA;        att();&#xA;参数调用时，会扩展作用域，如&#xA;    f(a.b)()                                    # a挂到f的作用域&#xA;    var f = function(c){}&#xA;作用域链(scope chain)&#xA;    特点&#xA;        每一段js代码有关联的作用域链&#xA;        一个对象链表，定义这段代码的作用域&#xA;        变量解析(variable resolution)时，从链第一个开始查找到最后一个   # 查找不存在时抛出引用错误(ReferenceError)&#xA;    原理&#xA;        定义一个函数时，实际上保存一个作用域链&#xA;        调用该函数时，创建新对象放局部变量，添加到保存的作用域链&#xA;        同时，创建一个新的、更长的&amp;quot;函数调用作用域链&amp;quot;&#xA;        该函数每次调用外部函数时，嵌套函数重定义&#xA;    代码作用域链分类&#xA;        顶层代码&#xA;            顶级对象属性&#xA;        无嵌套函数体&#xA;            var定义的局部变量&#xA;            顶级对象属性&#xA;        嵌套函数体&#xA;            var定义的局部变量&#xA;            顶级对象属性&#xA;            函数调用作用域&amp;quot;链&amp;quot;&#xA;    注意&#xA;        函数创建时，它的作用域链中会填入全局对象&#xA;        执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象&#xA;            运行期上下文定义了函数执行时的环境&#xA;            每个运行期上下文都有自己的作用域链&#xA;            其作用域链初始化为当前运行函数的Scope所包含的对象。&#xA;        函数中的值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中&#xA;            它们共同组成了一个新的对象，叫“活动对象(activation object)”&#xA;            该对象包含了函数的所有局部变量、命名参数、参数集合以及this&#xA;            此对象会被推入作用域链的前端&#xA;            运行期上下文被销毁，活动对象也随之销毁&#xA;        在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。&#xA;            该过程从作用域链头部，也就是从活动对象开始搜索&#xA;            如果没找到继续搜索作用域链中的下一个对象&#xA;            如果搜索完所有对象都未找到，则认为该标识符未定义&#xA;        作用域链只会被 with 语句和 catch 语句影响。&#xA;    优化代码：&#xA;        因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。&#xA;            所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量&#xA;            一个好的经验法则是, 如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用&#xA;        优化with&#xA;            with(o){&#xA;            }&#xA;            使用with语句来避免多次书写document，看上去更高效，实际上产生了性能问题。&#xA;                代码运行到with语句时，运行期上下文的作用域链临时被改变了&#xA;                一个新的可变对象被创建，它包含了参数指定的对象的所有属性, 这个对象将被推入作用域链的头部&#xA;                这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。&#xA;        优化try-catch&#xA;            try{&#xA;                doSomething();&#xA;            }catch(ex){&#xA;                alert(ex.message);              # 作用域链在此处改变。同理，catch语句使效率下降&#xA;&#xA;            try{&#xA;                doSomething();&#xA;            }catch(ex){&#xA;                handleError(ex);                # 委托给处理器方法, 没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。&#xA;            }                                   # 优化后的代码，handleError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;表达式&#34;&gt;&#xA;  表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    表达式(expression), 由解释器计算(evaluate)&#xA;原始表达式(primary expression)&#xA;    常量&#xA;    直接量&#xA;    关键字&#xA;        true, false, null, this&#xA;    变量名&#xA;对象和数组初始化表达式                             # 对象直接量、数组直接量&#xA;    {}&#xA;    []&#xA;函数定义表达式                                    # 函数直接量&#xA;    var square = function(x){reutrn x*x}&#xA;属性访问表达式                                    # 其前面的表达式首先计算, null, undefined会抛出类型错误异常，因为它们不能包含属性&#xA;    .&#xA;    [1]&#xA;    [&amp;quot;a&amp;quot;]&#xA;调用表达式(invocation expression)&#xA;    顺序&#xA;        首先计算函数表达式，再计算参数表达式&#xA;        传入实参的值赋值给形参&#xA;        执行函数体&#xA;        return返回值给变量名，无return 函数名赋为undefined&#xA;    左边是属性访问表达式时，称作方法调用(method invocation)&#xA;        函数体的this是宿主对象(执行者)&#xA;        非方法调用时，this是顶级对象&#xA;            ECMAScript 5中非方法调用时, this是undefined&#xA;    f(0)                                        # 非方法调用&#xA;    Math.max(x, y, z)                           # 静态方法调用, this为Math类&#xA;    a.sort()                                    # 动态方法调用, this为a实例&#xA;对象创建表达式(object creation expression)&#xA;    特点&#xA;        创建一个对象并调用构造函数&#xA;        与调用表达式相似&#xA;    过程&#xA;        创建空对象，该对象作为构造函数的this，可用来初始化动态属性&#xA;        传入指定参数，执行构造函数。&#xA;        返回值以构造函数返回值优先(本次对象废弃)，没有时则返回本次创建的对象&#xA;    new Point(2, 3)&#xA;    new Object()&#xA;    new Object                                  # 不传参时, ()可以省略&#xA;关系表达式&#xA;    ==&#xA;    &amp;lt;&#xA;    in&#xA;    instanceof&#xA;逻辑表达式&#xA;    !&#xA;    &amp;amp;&amp;amp;&#xA;    ||&#xA;赋值表达式&#xA;    (a=b) == 0&#xA;    i = j = k = 0;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;运算符&#34;&gt;&#xA;  运算符&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e7%ae%97%e7%ac%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    可符号，可关键字&#xA;    一元、二元、三元运算符                         # - +(正负号)是一元，*是二元, ?!是三元&#xA;    期望与转型&#xA;        &amp;quot;3&amp;quot; * &amp;quot;5&amp;quot;                               # 期望数字, 自动转型&#xA;        对类型依赖&#xA;            +                                   # 数字则运算，字符串则拼接&#xA;            &amp;lt;                                   # 数字则比较, 字符则比较字符表次序&#xA;    左值(lvalue)&#xA;        表达式只能出现在赋值运算(=)的左侧&#xA;            &amp;amp;, ++等操作符的操作数&#xA;            内存栈中的变量名&#xA;                变量、对象属性、数组元素&#xA;        内置函数可返回左值，自定义函数不可以&#xA;    优先级&#xA;    左右结合性&#xA;    运算顺序&#xA;        总是严格从左到右计算表达式&#xA;        表达式会影响变量值(如++, --, delete)时，先执行&#xA;            b = (a++)+a                         # 计算b, 计算a++(返回的结果是1), 计算右边的a(结果是2), 计算等号右边(1 + 2), 赋值&#xA;关键字运算符&#xA;    delete, typeof, instanceof, in, void&#xA;    in运算符                                     # 判断是否存在属性, 左是字符串, 右是对象&#xA;        &#39;toString&#39; in obj&#xA;        for( var i in ojb)&#xA;    instanceof运算符                             # 判断是否实例, 会判断父类, (prototype chain)&#xA;        o instanceof f                          # 遍历原型链, 计算f.prototype, 然后在o原型链中查找f, 找到则返回true&#xA;    typeof 运算符                                # 返回一个对象的类型描述字符串&#xA;        typeof value == &amp;quot;string&amp;quot; ? &amp;quot;&#39;&amp;quot; + value + &amp;quot;&#39;&amp;quot; : value&#xA;        typeof(value)                           # 可以写作函数的形式&#xA;        返回值&#xA;            &amp;quot;undefined&amp;quot;, &amp;quot;object&amp;quot;, &amp;quot;boolean&amp;quot;, &amp;quot;number&amp;quot;, &amp;quot;string&amp;quot;, &amp;quot;function&amp;quot;&#xA;            null, 对象和数组 返回&amp;quot;object&amp;quot;         # 函数是对象的一种，但typeof特殊对待。&#xA;                                                # instanceof, class特性, constructor属性&#xA;    delete运算符                                 # 严格模式下删除失败会报错&#xA;        删除属性, 成功则返回true&#xA;        内置核心客户端属性不能删除&#xA;        var语句声明的变量不能删除&#xA;        function定义的函数和其参数不能删除&#xA;    void运算符&#xA;        写在操作数前，操作数照常计算, 但返回undefined&#xA;            &amp;lt;a href=&amp;quot;javascript:void window.open();&amp;quot;&amp;gt;               # 使浏览器不必显示计算结果&#xA;普通一元(目)运算符&#xA;    +                                           # 这里+, -表示正负号, +, -会把变量自动转型为数字&#xA;    -&#xA;    ++                                          # ++, -- 作为前增量时, 返回计算后的值，后增量时，返回计算前的值。与c语言不一样，c语言的前后增量作用于整个表达式s&#xA;    --&#xA;普通二元(目)运算符&#xA;    特点&#xA;        必要时转换数字&#xA;        js中数字都是浮点数, 所以5/2 = 2.5&#xA;        左结合&#xA;        根据类型进行数字相加或字符串连接&#xA;        对象先尝试转换数字(Date除外，先转换字符串)&#xA;            如果存在字符串，则拼接(不论字符串值是否数字)&#xA;            都为非字符串，则转换数字计算，失败返回NaN&#xA;    -&#xA;    *&#xA;    /&#xA;    %&#xA;    **                                          # **是指数运算符&#xA;    +&#xA;三元(目)运算符&#xA;    ?:                                          # 条件运算符, 唯一三元运算符&#xA;位运算符(对操作数每位布尔运算)&#xA;    特点&#xA;        要求操作数是整数(32位整形而非64位浮点型)&#xA;        会自动强制转换&#xA;        NaN, Infinity, -Infinity转换为0&#xA;    &amp;amp;                                           # 按位与&#xA;        0x1234 &amp;amp; 0x00FF = 0x0034&#xA;    |                                           # 按位或&#xA;        0x1234 | 0x00FF = 0x12FF&#xA;    ^                                           # 按位异或&#xA;        0xFF00 ^ oxF0F0 = 0x0FF0&#xA;    ~                                           # 按位非&#xA;        ~0x0f = 0xFFFFFFF0或 -16&#xA;    &amp;lt;&amp;lt;                                          # 左移&#xA;        7&amp;lt;&amp;lt;2 = 28&#xA;                                                # 移动倍数是0~31的整数，用0补&#xA;    &amp;gt;&amp;gt;                                          # 左边高位 正数填0, 负数填1&#xA;        7&amp;gt;&amp;gt;1 = 3&#xA;        -7&amp;gt;&amp;gt;1 = -4&#xA;    &amp;gt;&amp;gt;&amp;gt;                                         # 无符号右移，左边高位总填0&#xA;相等不等运算符&#xA;    ==(equality operator), ===(严格相等(strict equality)或恒等(identity operator))&#xA;        ==                                      # 数字和字符串原始类型也是地址的相等(恒等)&#xA;            null == undefined&#xA;            数字==字符串, 字符串转换为数字比较, true转换成1比较&#xA;            &amp;quot;1&amp;quot;==true    # 同时转换为数字比较&#xA;            对象根据另一个值的类型转换&#xA;        === 与 ==&#xA;            不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等&#xA;    !=, !==是==, ===的求反&#xA;比较运算符&#xA;    &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=                                # 存在NaN则返回false, &amp;lt;=只是简单的不大于，&amp;gt;=相反。不进行==比较&#xA;        0 == -0&#xA;        Infinity最大(除了本身)&#xA;        -Infinity最小(除了本身)&#xA;    转换&#xA;        对象转换为数字&#xA;        同为字符串，字母表顺序比较(16位unicode字符索引顺序)&#xA;        存在不为字符串，转换数字&#xA;逻辑运算符&#xA;    ! &amp;amp;&amp;amp; ||                                     # !会隐式转换为布尔类型, &amp;amp;&amp;amp;比||优先级要高, !优先级最高&#xA;    隔断性&#xA;        (a == b) &amp;amp;&amp;amp; stop()                      # 同if(a == b) stop();&#xA;        var max = a || b || 0;                  # 常用。层层按优先级判断，给max赋值, 用来给可能未传入的参数赋默认值&#xA;赋值运算符&#xA;    =&#xA;    带操作的赋值运算符&#xA;        +=, -=, *=, /=, %/, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;gt;&amp;gt;&amp;gt;=, &amp;amp;=, |=, ^=, **=&#xA;    注意&#xA;        data[i++] *=2&#xA;        data[i++] = data[i++] * 2               # 以上不相同&#xA;逗号运算符                                       # 计算左边表达式并忽略结果, 连接多上表达式成为一个表达式&#xA;    i=0, j=1, k=2                               # 计算结果是2&#xA;    for(var i=0, j=10; i &amp;lt; j;j--)&#xA;扩展(spread)运算符                               # 展开具有[Symbol.iterator]接口的可遍历对象，所以可以展开字符串, Map, Set, Generator&#xA;                                                # 内部使用for of, 支持4字节字符&#xA;    [1, 2, ...arguments]                        # 展开成新数组, 等于[1, 2].concat(arguments)&#xA;    [a, ...rest] = [1, 2, 3]                    # 模式匹配给rest赋值, 只能放在最后&#xA;    array.push(1, ...items, 2)                  # 函数调用&#xA;函数绑定运算符                                    # 返回原对象, 可以链式调用a::b::c, 把b, c都绑定到a&#xA;    foo::bar                                    # bar.bind(foo)&#xA;    ::obj.foo                                   # obj.foo.bind(obj)&#xA;优先级&#xA;    优先级(js权威指南六版66页)&#xA;算术运算&#xA;    不报错&#xA;        溢出(overflow), 下溢(underflow), 被零整除&#xA;        overflow&#xA;            超过表示的数字上限, 得到Infinity或-Infinity&#xA;        underflow&#xA;            比最小值还小, 返回0或负0, 负0几乎和0一样, 很少用到&#xA;        除零&#xA;            返回无穷大或负无穷大&#xA;    返回NaN&#xA;        零除以零&#xA;        无穷除以无穷&#xA;        负数开方&#xA;        无法转换为数字&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;eval&#34;&gt;&#xA;  eval&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eval&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    计算由源代码组成的字符串, 用eval(&amp;quot;&amp;quot;)来运行&#xA;    eval()是一个函数，但设计上更像运算符。&#xA;        限制eval()函数使它更像运算符&#xA;eval()&#xA;    一个参数，如果不传入字符串，则直接返回传入的参数。&#xA;        传入字符串, 则编译该字符串&#xA;            失败则抛出语法错误异常(SyntaxError)，成功则开始执行这段代码&#xA;            执行成功，返回字符串中最后一个语句的值。最后语句没有值，返回undefined&#xA;            执行中抛出异常, 该异常将调用传递给eval()[?]&#xA;    eval的作用域是当前作用域, 如eval(&amp;quot;var y = 3;&amp;quot;)&#xA;    用eval向函数中粘贴代码片段是无意义的，如&#xA;        var foo = function(a){eval(a)};&#xA;        foo(&amp;quot;return;&amp;quot;);                                             # 执行eval(a)的上下文是全局的, 会抛出return not in function错误&#xA;    eval作为单独脚本，如eval(&amp;quot; y = 1;&amp;quot;)是有意义的&#xA;问题&#xA;    eval()中的代码，解释器不能分析和优化&#xA;        eval()可以改变局部变量，对优化是很大的问题&#xA;    eval()的函数名可以被赋予其他名字(与运算符的区别)&#xA;        var f = eval;&#xA;        var g = f;&#xA;        这样解释器无法优化任何调用g()的函数&#xA;            所以ECMAScript规定不可以对eval()赋予别名，会抛出EvalError异常&#xA;            实际上，大多数实现并不这么做。别名调用时, 会当作顶层全局代码来执行&#xA;            这样不会修改局部变量的值，不影响优化&#xA;    ECMAScript 5规定&#xA;        直接eval(direct eval), 总是在调用它的上下文作用域执行&#xA;        间接调用(指别名调用)则作为顶层代码执行，不能读、写、定义局部变量   # 间接eval是有用的特性，允许在局部作用域执行上下文无依赖的脚本&#xA;    ie9之前的不同&#xA;        别名调用eval()是局部调用&#xA;        用execScript()来全局eval调用                                  # 与eval不同在于总是返回null&#xA;    ECMAScript 5 严格模式&#xA;        eval作为保留字, 不能用别名覆盖(更像运算符)&#xA;        eval中的字符串以&amp;quot;use strict&amp;quot;指令开始&#xA;        可以使用和更改局部变量，不可以定义新的变量&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;语句&#34;&gt;&#xA;  语句&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    语句以分号结束&#xA;    表达式计算出值，语句来执行。&#xA;        有副作用的表达式也会执行，叫作表达式语句(expression statement)&#xA;        声明语句(declaration statement), 来声明新变量或定义新函数&#xA;    js解释器依照语句编写顺序执行&#xA;        控制结构(control structure)改变顺序&#xA;            条件conditional&#xA;                switch&#xA;            循环loop&#xA;                while, for&#xA;            跳转jump&#xA;                break, return, throw&#xA;表达式语句&#xA;    赋值语句，如 greeting = &amp;quot;Hello&amp;quot; + name;&#xA;    ++, --&#xA;    delete&#xA;    函数调用，如 alert(greeting);                 # Math.cos(x)不是表达式语句，它没有对浏览器造成影响&#xA;复合语句和空语句&#xA;    {}括起来当作单独语句&#xA;        内部语句必须分号&#xA;        内部声明的变量作用域在外部(es6之前)&#xA;        如&#xA;            {&#xA;                x = Math.PI;&#xA;                cx = Math.cos(x);&#xA;            }&#xA;    空语句&#xA;        ;&#xA;        如&#xA;            if(){....}&#xA;            if();&#xA;块作用域(es6之后)                                 # 内部使用严格模式&#xA;    {&#xA;    }&#xA;声明语句&#xA;    特点&#xA;        声明语句创建的变量无法删除，但不是只读的，可以重写&#xA;        函数声明常出现在代码最顶层&#xA;        函数声明并没有归类为真正的语句&#xA;        函数声明不能出现在if, while等语句中&#xA;    var, function&#xA;    如&#xA;        var f = function(){}                    # 变量名指向函数对象，声明提前。初始化要在执行到时进行, 不可以在代码之前调用&#xA;        function f(){}                          # 函数声明和定义均提前，可以在代码之前调用&#xA;条件语句&#xA;    if(expression1) statement1&#xA;        else if(expression2) statement2&#xA;        else statement3&#xA;    switch(expression){ statements}&#xA;        特点&#xA;            不重复计算表达式&#xA;            无break向下执行，如c语言&#xA;            ECMAScript规定case可跟随任意表达式&#xA;                case是恒等比较, 所以不会作类型转换&#xA;                case是运行时(run-time)计算的, 灵活但效率低。&#xA;                c, c++, java中case是编译时(compile-time)常量&#xA;            编译时常量形成跳转表(jump table), 执行非常高效&#xA;            避免使用函数表达式和赋值表达式，建议常量表达式&#xA;            default标签可以在switch语句内的任何地方&#xA;        switch(typeof x){&#xA;            case &#39;number&#39;: break;&#xA;            default: break;&#xA;        }&#xA;    while(expression) statement&#xA;    do statement while(expression);             # 代码至少执行一次&#xA;    for(initialize; test; increment) statement                      # for(;;)比while(true)高效&#xA;    for(variable in object)                     # 遍历对象属性成员, 遍历出的数组key(如0, 1, 2)是字符串&#xA;        for(a[i++] in o)&#xA;        for(i in [1,2,3])&#xA;        原理&#xA;            计算object表达式&#xA;                为null或undefined 则跳过         # ECMAScript3的实现可能会抛出一个类型错误异常&#xA;                为原始值, 则包装对象&#xA;                否则就一定是对象，枚举对象属性(或数组索引)&#xA;                    只有可枚举(enumerable)属性才会遍历到&#xA;                        代码中所有属性和方法可枚举&#xA;                        ECMAScript 5可以特殊手段变为不可枚举&#xA;                        js语言核心定义的内置方法不可枚举(nonenumerable)，如toString()&#xA;                        很多内置属性不可枚举&#xA;                        继承的自定义属性也可以枚举出来&#xA;                    prototype上有多个原型(原型链上多个对象), 每个都遍历&#xA;                    for/in中提前删除的未枚举属性不会枚举到&#xA;                        定义的新属性不会枚举到(有些实现是可以枚举到的)&#xA;                    每次循环计算variable表达式的值，以它为左值赋值&#xA;        顺序&#xA;            通常实现按照定义先后顺序&#xA;            原型链多继承对象有特定顺序&#xA;            数组依照数字顺序                    # 不是全部实现, 索引非数字或不连续时，按照特定顺序&#xA;    for(let c of s)                           # 会正确识别4字节字符&#xA;跳转语句(jump statement)&#xA;    break, continue, return, throw            # throw是复杂的跳转语句，跳转到最近闭合异常处理程序, 处理程序可以在同函数中或高层调用栈中&#xA;标签语句&#xA;    identifier: statement&#xA;        identifier不能是保留字。与变量或函数命名空间不同，可以使用同一个标识符作标签和函数名&#xA;        外层语句标签不能和它内部的重名。不嵌套下是可重名的&#xA;        break, continue是唯一可以使用语句标签的语句&#xA;    mainloop: while(token != null){&#xA;        continue mainloop;&#xA;        // break mainloop;&#xA;    }&#xA;break语句&#xA;    特点&#xA;        break后面无内容自动补分号&#xA;        不可以跳出函数边界，只在一个函数中起作用&#xA;        for中不会计算自增表达式, 直接退出&#xA;    break;&#xA;    break labelname;&#xA;continue语句&#xA;    特点&#xA;        continue后面无内容自动补分号&#xA;        while中跳到开头检测expression, do/while跳到结尾&#xA;        for中先计算自增表达式，再检测expression, for/in中遍历下一个属性名，赋给变量&#xA;    continue;&#xA;    continue labelname;&#xA;return语句&#xA;    特点&#xA;        return后面无内容自动补分号&#xA;        函数调用是表达式，return返回函数表达式的值并跳过后续结果。无return时, 函数表达式结果为undefined&#xA;        只在函数中出现&#xA;throw语句&#xA;    特点&#xA;        js解释器立即停止当前执行的逻辑，并跳转到就近异常处理程序&#xA;        try/catch/finally语句的catch编写异常处理程序&#xA;        没有异常处理程序, js把异常当作程序错误处理，报告给用户&#xA;    throw expression;&#xA;    throw new Error(&#39;x不能是负数&#39;);              # Error对象, name属性表示错误类型, message属性存放传递给构造函数的错误信息&#xA;try/catch/finally语句                           # catch可选, finally可选, try finally一起, finally用于清理代码&#xA;    finally中常写的逻辑                          # finally中return, continue, break, throw跳转，忽略已有返回值或异常，以finally中的为准&#xA;        o-&amp;gt; 正常终止, 收尾语句&#xA;        o-&amp;gt; break, continue或return终止&#xA;        o-&amp;gt; 抛出异常，被catch捕获。抛出异常未被捕获, 继续向上传播&#xA;    模拟for(initialize; test; increment)body;&#xA;    initialize;&#xA;    while(test){&#xA;        try{body;}                              # body中有break时, 这里相比for循环有一次额外的自增运算, 所以while不能完全模拟for&#xA;        finally{increment;}&#xA;    }&#xA;with语句&#xA;    with(object) statement&#xA;    with语句用于临时扩展作用域链, 将对象添加到作用域链的头部&#xA;    with下创建未声明变量不会添加到with对应对象作属性，而是和平时一样&#xA;        with执行完后把作用域链恢复到原始状态&#xA;        作用域链(scope chain)&#xA;            按序检索的对象列表, 通过它进行变量名解析&#xA;        严格模式下禁止使用with语句。非严格模式不擒获with, 因为运行慢且非常难于优化&#xA;            对象嵌套层很深时使用with来简化代码编写&#xA;debugger语句&#xA;    debugger;                                   # 产生一个断点(breakpoint)，在解释器调试模式运行时使用&#xA;                                                # ECMAScript 5中加入的debugger语句。但从前主流浏览器已经实现了&#xA;&amp;quot;use strict&amp;quot;指令&#xA;    只出现在代码或函数体的开始或eval()中。其前可以有其字符串直接量表达式语句&#xA;        解释器可能将&amp;quot;use strict&amp;quot;之前的字符串和它都解释成解释器自有的指令&#xA;        直到第一条常规语句出现之后, 字符串直接量就只当作普通表达式语句对待&#xA;    表示其后的代码将会解析为严格代码&#xA;        函数和eval()只作用到自身&#xA;    ECMAScript 5引入的指令。可以使用单引号。对于没有实现ECMAScript 5的解释器来说，它什么也不做(没有副作用)&#xA;        将来ECMAScript希望用use做关键字&#xA;tag函数                                         # 用于过滤html字符串, 嵌入其他语言执行或filter出特定的值&#xA;    tag`hello ${1} world ${2}`&#xA;    function tag(strArr, ...values){}           # [&#39;hello &#39;, &#39; world &#39;, &#39;&#39;] , 1, 2&#xA;数组推导                                        # 支持iterator接口, 即也支持字符串。惰性求值, 可以替代filter方法&#xA;    var a1 = [1, 2, 3]&#xA;    var a2 = [for (i of a1) i * 2]&#xA;    var a3 = [for (i of a1) if(i &amp;lt; 3) i]&#xA;    var b1 = [1, 2]&#xA;    var b2 = [&#39;a&#39;, &#39;b&#39;]&#xA;    [for (s of b1) for (w of b2) s+w]    // [&#39;1a&#39;, &#39;1b&#39;, &#39;2a&#39;, &#39;2b&#39;]&#xA;    let c = (for (n of generator()) n * n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;模式匹配&#34;&gt;&#xA;  模式匹配&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    模式匹配只对自身属性起作用&#xA;&#xA;数组&#xA;    let [foo, [[bar], baz]] = [1, [[2], 3]]     # var, const同样适用&#xA;    let [,, third] = [1, 2, 3]&#xA;    let [head, ...tail] = [1, 2, 3]&#xA;    let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])    # 只要有Iterator接口，都可以匹配&#xA;&#xA;    var [foo = true] = []                       # 设置默认值，在值严格等于undefined时生效&#xA;        var [x = 1] = [undefined]&#xA;            x = 1&#xA;        var [x = 1] = [null]&#xA;            x = null&#xA;        let [x = f()] = [1]                     # 惰性求值&#xA;        let [x = y, y = 1]                      # 报错, y 未声明&#xA;&#xA;对象&#xA;    var {bar, foo} = {foo: &#39;a&#39;, bar: &#39;b&#39;};&#xA;    var {foo: baz} = {foo: &#39;a&#39;};                # baz = &#39;a&#39;&#xA;    var {p: [x, {y}]} = {p: [&#39;a&#39;, {&#39;b&#39;}]}       # 这里p是模式，不是变量，所以不声明或赋值&#xA;    let obj = {}, arr = [];&#xA;    ({foo: obj.prop, bar: arr[0]} = {foo: 1, bar: 0});              # 嵌套值, 不加()时{}会被解释成代码块&#xA;    var {x = 3} = {};&#xA;    let {log, sin, cos} = Math                  # 将对象的方法赋值到变量&#xA;    let n = {...{a: 3, b: 4}}                   # {a: 3, b: 4}, 扩展null, undefined会被忽略, 被扩展对象中的getter会执行&#xA;        let n = {x: 1, ...a}                    # a中的x属性会被覆盖掉, 原理同Object.assign&#xA;        let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4}                 # x // 1, y // 2, z // {a: 3, b: 4}, z 是引用&#xA;基本类型&#xA;    const [a, b] = &#39;hello&#39;&#xA;    let {toString: s} = 123                     # 如果右边不是对象，先包装, null 和 undefined不能匹配&#xA;        # let {toString: s} = true&#xA;&#xA;函数&#xA;    function add([x, y]){}&#xA;    add([1, 2])&#xA;    function move({x = 0, y = 0} = {})          # function move({x, y} = {x: 0, y: 0}) 是错误的&#xA;&#xA;圆括号&#xA;    [(b)] = [3]&#xA;    ({p: (d)} = {})&#xA;    [(parseInt.prop)] = [3]                     # 只有非声明语句的非模式部分可以用圆括号&#xA;&#xA;用途&#xA;    [x, y] = [y, x]                             # 交换值&#xA;    function f(){return [1, 2]}&#xA;    var [a, b] = f();&#xA;    function f(){return {foo: 1, bar: 2}}&#xA;    var {foo, bar} = f();                       # 函数返回多个值&#xA;    function f([x, y]){}&#xA;    f([1, 2])&#xA;    function f({x, y, z = 3}){}&#xA;    f({y: 2, x: 1})                             # 参数定义&#xA;    let {id} = {id: 42, status: &#39;ok&#39;}           # json匹配&#xA;    var map = new Map(); map.set(&#39;a&#39;, 1)&#xA;    for(let [, val] of map){}                   # 遍历map&#xA;    const {SourceMapConsumer, SourceNode} = require(&#39;source-map&#39;)   # 输入模块方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    js的函数是参数化的&#xA;        在js中，函数即对象，可以随意传递，可以设置属性和调用该函数的函数&#xA;        在js中，函数可以嵌套定义, 嵌套的函数可以访问被定义所处作域中的变量，这个作用域就是闭包(closure)&#xA;        函数是对象，但typeof经过处理，所以返回&amp;quot;function&amp;quot;, 可以拥有静态属性和方法，可以用内部构造函数Function()创建&#xA;    形参 标识符列表(函数中定义的变量)，调用时为其提供实参值。&#xA;    初始化对象的函数是构造函数&#xA;    return停止函数执行并返回它的表达式。没有表达式时返回undefined。没有return语句时返回undefined&#xA;    this是关键字，不是变量或属性名，所以不允许赋值。&#xA;        this没有作用域限制&#xA;    将函数绑定到Function.prototype上，以便所有函数对象都继承它&#xA;关键字&#xA;    this&#xA;        除实参外，每次调用拥有一个调用上下文 this&#xA;        对象调用函数时, 此次调用上下文是该对象。&#xA;    super&#xA;        super()调用父类的构造方法, super相当与父类的实例，super同时部署了父类的静态属性&#xA;        对象总是继承其他对象，所以在任意对象中，都可以使用super, 如&#xA;            var obj = {toString() {return &#39;a &#39; + super.toString() }}&#xA;    new.target&#xA;        构造函数中使用, 返回调用该构造函数时new 命令作用的对象&#xA;        如果直接调用等, 则值为undefined&#xA;        function Person() {new.target === Person}&#xA;        class {constructor() {new.target}}                          # 子类继承父类调用super()时, 父类构造方法中new.target指向子类, 可以利用写出不能继承的类&#xA;定义                                              # 函数名通常是动词或以动词为前缀的词组，常用的写短&#xA;    function a(){}&#xA;        声明和定义均提前&#xA;        ECMA只允许它作为顶级语句，不能出现在循环、条件判断或者try/cache/finally及with语句中&#xA;            一些js实现并未严格遵守规则，比如firefox就可以在if中出现函数声明&#xA;    var a = function(){}&#xA;        只声明提前。可作匿名函数&#xA;        此为函数定义表达式, 可以出现在js代码的任何地方&#xA;    o.m = f&#xA;        给已有对象的属性引用方法&#xA;创建函数&#xA;    function fun(){}&#xA;    var fun = function {}&#xA;    var fun = new Function(&amp;quot;输入变量1&amp;quot;,&amp;quot;输入变量2&amp;quot;,&amp;quot;执行内容&amp;quot;);        # 动态创建函数&#xA;&#xA;    var f = (a, b) =&amp;gt; a + b&#xA;    var f = n =&amp;gt; n&#xA;    var f = () =&amp;gt; {return 1}&#xA;    var f = () =&amp;gt; ({a: 1})&#xA;    箭头函数特性:&#xA;        没有自己的this, this是外部的this, 所以不能用call, apply, bind改变this&#xA;        不能当作构造函数, 没有super, new.target&#xA;        没有arguments, arguments是外部的&#xA;        不能成为Generator&#xA;        大括号解释为代码块, 要返回对象时用圆括号括起来&#xA;        const pipeline = (...funcs) =&amp;gt; val =&amp;gt; funcs.reduce((a, b) =&amp;gt; b(a), val)&#xA;        const plus1 = a =&amp;gt; a + 1, mult2 = a =&amp;gt; a * 2, addThenMult = pipeline(plus1, mult2);&#xA;        addThenMult(5)    // 12&#xA;        let insert = val =&amp;gt; ({into: (arr) =&amp;gt; ({after: (afterVal) =&amp;gt; {&#xA;            arr.splice(arr.indexOf(afterVal) + 1, 0, val); return arr;&#xA;        }})})&#xA;        insert(2).into([1, 3]).after(1)    // [1, 2, 3]&#xA;参数&#xA;    function f(x, y = 5)&#xA;        f({x: 1, y: 2})可以模式匹配&#xA;        默认值可以是变量，作用域是函数内作用域。函数a默认值是函数b时, 函数b的作用域链不包含函数a&#xA;        默认值一般在最后, 可以一眼看出哪些参数可以省略，调用时也好看&#xA;    function f(url, {method = &#39;GET&#39;} = {})&#xA;    function f({a, b}) {a, b}&#xA;        f({a: 1, b: 2}) 对象匹配&#xA;    function f(a = throwErr())&#xA;        设置不可省略的参数, 默认值是延迟计算的&#xA;    function f(...rest)&#xA;        一定在末尾&#xA;嵌套函数&#xA;    特性    &#xA;        内部嵌套函数可以读写外部参数&#xA;        this不会在嵌套函数中继承，函数调用和方法调用中this的规则不变。&#xA;            如果要在内部访问外部this, 需要将外部this保存到变量中(通常用self, [that 是传递this时使用的变量名])&#xA;调用&#xA;    方式&#xA;        作为函数&#xA;        作为方法&#xA;        作为构造函数&#xA;        通过它们的call()和apply()方法间接调用&#xA;    原理&#xA;        调用由函数对象，左圆括号，参数列表(逗号分隔)，右圆括号组成&#xA;        每个参数表达式都会计算出一个值作为实参传递给声明时定义的形参&#xA;            在函数体中存在一个形参的引用指向当前传入的实参列表&#xA;        函数表达式的值成为调用表达式的值&#xA;        ECMAScritp 3和非严格ECMAScript 5中，函数调用上下文(this)是全局对象。严格模式下是undefined&#xA;            常用this判断是否严格模式&#xA;    调用表达式&#xA;        f()                                     # 作为普通函数调用&#xA;        o.m(x, y)                               # 函数表达式本身就是属性访问表达式, 此时函数作为一个方法调用, 方法调用的上下文是该调用对象o&#xA;        o[&amp;quot;m&amp;quot;](x, y)&#xA;        a[0](z)                                 # 可以用方括号来方法调用&#xA;        a.b.c()&#xA;        f().m()                                 # 方法链, 链式调用, 返回this或构造对象&#xA;构造函数调用&#xA;    方法名前带有new, 就是构造函数的调用&#xA;    与普通的函数调用及方法调用在实参处理、调用上下文、返回值方面都不同&#xA;    定义一类(class)对象，创建对象继承构造函数的prototype属性&#xA;        class看作是对象类型的子类型&#xA;    使用新对象作为调用上下文, 如new o.m()中，this不是o&#xA;    如果return一个对象，则构造的就是这个对象，如果返回原始值或没有值，则忽略返回值&#xA;    原理&#xA;        计算实参表达式，传入函数内。没有形参，允许省略实参列表和圆括号，如&#xA;            var o = new Object()                # 无参时圆括号可以省略&#xA;        创建空对象，继承构造函数的prototype, 试图初始化该对象，并将该对象作为调用上下文&#xA;            尽管构造函数看起来像方法调用，但它用新对象作为调用上下文&#xA;            所以 new o.m()看起来是方法调用，但它的调用上下文并不是o&#xA;        通常不使用return关键字，显式返回构造的新对象&#xA;            显式使用return时，如果没有值或是原始值，就忽略return。如果是对象，就返回return的对象&#xA;间接调用&#xA;    call和apply&#xA;        可以显式指定调用上下文，这样任何函数都可以作为任何对象的方法来调用&#xA;        call使用自有的实参列表作为函数实参，apply以数组形式传入参数&#xA;实参和形参&#xA;    不检查传入的参数类型和参数个数，所以要手动做参数检查&#xA;        传入参数少时，剩下的形参都设置为undefined&#xA;            所以在参数检查时，要给省略的参数赋默认值。如 a = a || []&#xA;            a = a || [] 是习惯用法，用来代替if语句，前提是a必须预先声明&#xA;        前面的参数可选且不传时，传入占位符null(也可以传undefined)&#xA;        函数定义中使用/*optional*/来强调形参可选, 如&#xA;            function f(o, /*optional*/ a)&#xA;    可变长实参列表(实参对象)&#xA;        arguments&#xA;            是类数组对象，可以通过数字下标访问传入的实参值&#xA;            这种可以接收任意个数实参的函数    称为 不定实参函数(varargs function)&#xA;            非严格模式下, 实参对象的数组元素是函数形参对应实参的别名，改变实参值时，实参对象中的值也改变&#xA;                ECMAScript 5中移除了别名这个特性(实测没有移除)&#xA;            非严格模式中, arguments是一个标识符，严格模式中，它是一个保留字&#xA;            arguments的callee和caller属性&#xA;                ECMAScript 5 严格模式中，对这两个属性的读写操作都会产生类型错误&#xA;            非严格模式中, callee指代当前正在执行的函数，caller是非标准的，但大多数浏览器都实现了这个属性，指代调用callee的函数。&#xA;                通过caller属性可以访问调用栈&#xA;            可通过callee递归调用自身&#xA;                var factorial = function(x){&#xA;                    if( x &amp;lt;= 1) return 1;&#xA;                    return x * arguments.callee(x-1)&#xA;                }&#xA;    对象属性作实参，如&#xA;        easycopy({from: a, to: b, length: 4})&#xA;        function easycopy(args){&#xA;            args.from;&#xA;            args.from_start || 0;&#xA;        }&#xA;    类型注释&#xA;        function max(/*number*/a, /*optional*/b, /*array*/c, /*integer*/d, /*index*/e){&#xA;            if(isArrayLike(c)){&#xA;                if(isFinite(a));&#xA;            }&#xA;        }&#xA;函数作为值&#xA;    function a(){}                              # 定义创建函数对象，赋值给a。函数对象的名字是看不见&#xA;    o.f = f                                     # 将函数赋值给对象的属性，就称为方法&#xA;    var a = [function() {}, 20]                 # 没有名字的函数，放在数组直接量中&#xA;函数的自定义属性&#xA;    如当函数需要专属常量时，可在上面定义静态属性&#xA;    如要求函数返回唯一整数，可以定义静态属性做个计数器，&#xA;    如果要做缓存，也可以定义多个静态属性来缓存返回过的结果，属性名就是传入过的值&#xA;作命名空间&#xA;    无法声明只在一个代码块中可见的变量。所以定义一个函数做临时命名空间&#xA;    有些js扩展中(如mozilla的java script 1.7)可以使用let声明语句块内的变量, 如&#xA;        let(x = 1){ print(x)}&#xA;    (function(){&#xA;    }());&#xA;        匿名函数不会定义全局函数变量并运行, 定义了内部的局部变量&#xA;        最外层圆括号是习惯写法，尽管有些时候没必要也不应当省略&#xA;闭包&#xA;    js采用词法作用域(lexical scoping), 函数的执行依赖变量作用域。作用域在函数定义时决定，而非调用时&#xA;        当前函数的变量保存在函数作用域内(闭包)&#xA;        闭包指函数变量可以被隐藏于作用域链之内，象是函数将变量&amp;quot;包裹&amp;quot;了起来&#xA;    每函数中引入当前作用域链&#xA;    定义时与运行时&#xA;        大多定义函数时的作用域链在调用函数时依然有效&#xA;        调用函数时与定义函数时作用域链不是同一个时&#xA;            如返回内部嵌套的函数a时，外部运行a，其作用域链仍然是a的作用域链而非外部作用域链&#xA;    作用&#xA;        捕捉局部变量并一直保存&#xA;    原理&#xA;        如果一个函数的局部变量定义在cpu栈中, 函数返回时它们的确不存在了&#xA;        js中作用域链是一个对象列表，不是绑定的栈。&#xA;            运行js函数a时, 都创建新的对象保存局部变量。该新对象添加到作用域链中&#xA;                函数a返回时，从作用域链中删除该局部变量对象，等待垃圾回收&#xA;                如果a有嵌套函数，每个嵌套函数各自对应一个作用域链         # 该嵌套函数的作用域链，保留a的局部变量对象&#xA;                    嵌套函数在a中局部变量对象中保存时，会随其一起从作用域链删除&#xA;                    嵌套函数被返回或被外部引用时, 该嵌套函数不被回收，且其自身作用域链中的自身局部变量对象、a的局部变量对象也不删除。&#xA;        闭包的this值会随外部调用者而变动，所以要先将this转存。var self = this;&#xA;            闭包中使用的arguments也会变动，也要转存。var outerArguments = arguments;&#xA;可调用对象&#xA;    如&amp;quot;类数组对象&amp;quot;不是真正的数组，&amp;quot;可调用对象&amp;quot;不是函数，但所有函数都是可调用的&#xA;    可调用对象使用越来越少&#xA;    例如&#xA;        ie8及之前的版本window.alert()和document.getElementById()使用了可调用的宿主对象&#xA;        RegExp对象可以直接调用(如RegExp()), 是非标准特性, Netscape提出后被后续浏览器兼容&#xA;            typeof RegExp可能是&amp;quot;function&amp;quot;也可以是&amp;quot;object&amp;quot;&#xA;            最好不要对可调用RegExp对象有太多依赖，其可调用特性将来可能被删除&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;generator&#34;&gt;&#xA;  generator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#generator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;基本&#xA;    generator生成的遍历器g, g[Symbol.iterator]()得到自己。继承它prototype上的方法&#xA;        generator中this添加的属性, 生成的遍历器实例中没有, generator new相当于执行得到遍历器&#xA;        g.bind(obj) 可以改变generator中的this&#xA;    作为对象属性时写做 {* g() {}}, {g: function* () {}}&#xA;应用&#xA;    状态机&#xA;    协程(coroutine)&#xA;        generator是半协程(semi-coroutine), 只有generator函数的调用者，才能改变程序运行状态&#xA;        将多个协作的任务写成generator, 用yield语句交换控制权&#xA;    异步程序同步写法&#xA;    部署iterator接口&#xA;    可看作数组结构&#xA;yield&#xA;    特点&#xA;        惰性求值&#xA;        在表达式中时加圆括号, 如&#39;hello&#39; + (yield 1)，字符串模板中`${yield}`&#xA;        var n = yield i; g.next(1) 来返回值给n, g.next()返回undefined&#xA;        第一次调用g.next()不能传值，因为执行第一个yield之前的代码, 还没有yield来接收&#xA;    var a = yield* g()&#xA;        展开g()得到的generator(可展开所有iterator), 是for ... of的一种简写形式&#xA;        g()中有return 时, a 得到return 的值&#xA;    yield [a(), b()]&#xA;        非展开，而是并列执行, 全部执行返回时返回&#xA;throw&#xA;    特点&#xA;        外部的throw语句只被外部捕获&#xA;        generator中throw的错误先内部捕获，再抛出, g.throw(1)相当于从内部yield处抛出一个错误&#xA;        generator抛出错误后不再能继续执行，再执行返回done=true&#xA;    var g = function* () {try {yield;} catch (e) {}}                # 可以多个yield一个try catch ,  而回调函数只能一个回调一个try catch&#xA;    var i = g(); i.next()&#xA;    try{i.throw(&#39;a&#39;); i.throw(&#39;b&#39;) } catch(e){}                     # 内部捕获a, 外部捕获b&#xA;return&#xA;    特点&#xA;        相当于强制内部return&#xA;        generator中有finally时, g.return()延迟到所有finally执行后执行，再结束&#xA;    g.return(0)    // {value: 0, done: true}&#xA;使用&#xA;    function* f () {&#xA;        yield 1; yield 2; return 3;&#xA;    }&#xA;    var ff = f(), ff.next()&#xA;        # {value: 1, done: false}, {value: 2, done: false}, {value: 3, done: true}, {value: undefined, done: true}&#xA;        ## 没有return语句时, 去掉第三个结果，其它不变&#xA;自动执行                                    # 写执行器处理thunk和promise&#xA;    非promise&#xA;        thunk函数, 把回调函数抽离出来&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;promise&#34;&gt;&#xA;  promise&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#promise&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;三种状态&#xA;    进行中(pending)&#xA;    完成(fulfilled)&#xA;    失败(rejected)&#xA;状态转换&#xA;    状态可以由pending转换成fulfilled，或pending转换成rejected&#xA;    promise的状态转换只发生一次，之后代码会执行，但抛出的错误不捕获&#xA;    p2中return p1, 则p1的状态决定了p2的状态, 如果p1是resolved或reject, p2的回调立即执行&#xA;    所以返回promise对象时, then的回调相当于返回promise的then的回调&#xA;    新建即执行，不能取消。内部错误不抛出。无法得到具体pending状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;async&#34;&gt;&#xA;  async&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#async&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    generator的语法糖, 自动执行generator, 处理promise&#xA;    内置执行器，返回promise对象&#xA;使用&#xA;    var asyncReadFile = async function () {&#xA;        try {&#xA;            var f1 = await readFile(&#39;/etc/fstab&#39;);&#xA;        } catch (e) {}&#xA;        await p2.catch(function (e) {})&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;class&#34;&gt;&#xA;  class&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#class&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    所有方法在prototype上(constructor, static外)，不可枚举&#xA;    无变量提升&#xA;    类内部即严格模式&#xA;    class A的A.name = &#39;A&#39;, 意义同函数名&#xA;&#xA;语法&#xA;    class Point {&#xA;        constructor(x, y) {                         # 不定义时，生成空constructor方法, this代表新生的实例&#xA;            this.x = x, this.y = y;&#xA;        }&#xA;        toString() {return &#39;a&#39;}&#xA;        [methodName]() {}&#xA;        get prop() {...}&#xA;        set prop(val) {}&#xA;        * [Symbol.iterator]() {}&#xA;        static sMethod() {}                         # 相当于直接在Point上定义, es6 内只有方法，没有属性&#xA;        prop: 1                                     # es6中忽略, es7提案&#xA;        static prop2: 2                             # es6中忽略 es7提案&#xA;    }&#xA;    Point.a = 1;                                    # es6 静态属性只能在class外部定义&#xA;    var point = new Point(2, 3);&#xA;&#xA;    o-&amp;gt;&#xA;    var A = class B{};                              # 这时类的名字是A, 而B只能在类内中指代自己&#xA;    var A = class {};&#xA;    var a = new class {}();&#xA;&#xA;继承&#xA;    两条原型链&#xA;        Object.setPrototypeOf(B.prototype, A.prototype)&#xA;        B.prototype.__proto__ = A.prototype         # 作为构造函数, 子类B的prototype是A的实例&#xA;        Object.setPrototypeOf(B, A)&#xA;        B.__proto__ = A                             # 作为一个对象, 子类B的原型是A(强行成为继承关系来得到A的静态属性)&#xA;        B.__proto__.__proto__ = A.__proto__,        # 子类原型的原型是父类的原型&#xA;    继承的特殊种类&#xA;        class A {}, A.__proto__ = Function.prototype, A.prototype.__proto__ = Object.prototype&#xA;        class A extends null {}, A.__proto__ = Function.prototype, A.prototype.__proto__ = undefined&#xA;&#xA;    o-&amp;gt;&#xA;    class A extends B {&#xA;        constructor(x, y, color) {                  # 默认construcotr为constructor(...args) {super(...args)};&#xA;            super(x, y);                            # 调用B的constructor, 必须调用super来创建父类对象作用自己的prototype, 否则整个继承失败，报错&#xA;            this.color = color                      # this必须在super调用之后才能使用, 否则没有prototype生成this, 报错&#xA;        }&#xA;    }&#xA;    let cp = new A(1, 2, &#39;a&#39;)&#xA;    cp instanceof A    // true&#xA;    cp instanceof B    // true&#xA;&#xA;    o-&amp;gt; 继承原生构造函数(es5不可以)&#xA;        es5机制决定先新建子类实例this, 再将父类属性添加到子类上。父类的内部属性无法获取(如Array的[[DefineOwnProperty]])。&#xA;        es6允许继承原生父类构造函数定义子类, 即先新建父类this, 再用子类修饰, 父类的所有行为都可继承&#xA;    function MyArray() {Array.apply(this, arguments)}&#xA;    MyArray.prototype = Object.create(Array.prototype, {constructor: {&#xA;        value: MyArray,&#xA;        writable: true,&#xA;        configurable: true,&#xA;        enumerable: true,&#xA;    }})&#xA;    class MyArray extends Array {&#xA;        constructor(... args) {&#xA;        super(... args);&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; 用mixin来混合继承&#xA;    class A extends mix(B, C)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;decorator&#34;&gt;&#xA;  decorator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#decorator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    编译时执行&#xA;    相当于 class A {}, A = decorator(A) || A;&#xA;    不能用于函数，因为函数提升?&#xA;&#xA;o-&amp;gt; 修饰类&#xA;function testable(target) {                         # target是被修饰的类, 参数2为属性名, 参数3为属性描述对象&#xA;    target.isTestable = true;&#xA;}&#xA;function testable(val) {&#xA;    return function(target) {&#xA;        target.isTestable = val;&#xA;    }&#xA;}&#xA;@testable&#xA;class A {}&#xA;A.isTestable    // true&#xA;&#xA;o-&amp;gt; 修饰类属性&#xA;function readonly(target, name, descriptor) {&#xA;    descriptor.writable = false;&#xA;    return descriptor;&#xA;}&#xA;class Person {&#xA;    @readonly&#xA;    name() {return 0}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基础&#xA;    一种复合值。属性的无序集合，属性由名/值对组成，看作字符串到值的映射。&#xA;        这种数据结构叫做散列(hash), 散列表(hashtable), 字典(dictionary), 关联数组(associative array)&#xA;        常用来模拟静态对象或静态语言的结构体。也可以模拟json字符串&#xA;    可以基于原型(prototype)继承属性，称作原型式继承(prototypal inheritance)&#xA;    除了字符串、数字、true、false、null、undefined外，js中的值都是对象&#xA;        字符串、数字、布尔值可以自动包装为对象(构造函数的实例)&#xA;    对象操作通过引用(而非值)。&#xA;    常见属性操作&#xA;        创建(create)&#xA;        设置(set)&#xA;        查找(query)&#xA;        删除(delete)&#xA;        检测(test)&#xA;        枚举(enumerate)&#xA;组成&#xA;    属性的名/值对 + 属性特性(property attribute) + 对象特性(object attribute)&#xA;            属性名可以是空字符串，不能重名&#xA;        属性特性包括: 可写(writable attribute), 可枚举(enumerable attribute), 可配置(configurable attribute)&#xA;            可配置表明是否可以删除或修改该属性&#xA;            通过代码给对象创建的所有属性都是可写、可枚举、可配置的, ECMAScript 5 中可以改变&#xA;        对象特性包括&#xA;            对象原型(prototype)                     # 指向另外一个对象, 本对象继承它的原型&#xA;            对象的类(class)                         # 一个标识对象类型的字符串&#xA;            对象的扩展标记(extensible flag)          # ECMAScript 5中指明是否可以向该对象添加新属性&#xA;分类&#xA;    内置对象(native object)                         # 由ECMAScript定义的对象或类。如数组、函数、日期、正则表达式&#xA;    宿主对象(host object)                           # js解释器( 如web浏览器)嵌入的宿主环境,如 HTMLElement对象&#xA;                                                   # 宿主环境定义的方法可当作普通js函数对象, 宿主对象可当作内置对象&#xA;    自定义对象(user-defined object)                  # 运行中的js代码创建的对象&#xA;    自有属性(own property)                          # 直接在对象中定义的属性&#xA;    继承属性(inherited property)                    # 对象的原型对象中定义的属性&#xA;原型&#xA;    每一个js对象(null除外)都与另一个对象(原型)关联，从原型继承属性。&#xA;    内容&#xA;        对象直接量创建的对象有同一个原型对象Object.prototype&#xA;        new的对象原型是构造函数prototype的属性的值     # 于是new Object()创建的对象继承自Object.prototype&#xA;        Object.prototype这个对象没有原型&#xA;        具体&#xA;            除Object.prototype的对象是普通对象，都有原型。&#xA;            所有内置构造函数都继承Object.prototype&#xA;                如, new Date()创建的对象同时继承Date.prototype和Object.prototype&#xA;                这一系列的链接的原型对象就是&amp;quot;原型链&amp;quot;(prototype chain)&#xA;创建对象&#xA;    {}&#xA;        ECMAScript 5中(ECMAScript3的部分实现), 保留字用作属性名可以不带引号&#xA;            ECMAScript 3中保留字作属性名必须用引号&#xA;        ECMAScript 3的IE中, 最后一个逗号不可以忽略&#xA;        每次计算对象直接量，都会计算它的每个属性的值&#xA;    new            # 关键字创建&#xA;        new后的函数是构造函数(constructor)。&#xA;    Object.create()&#xA;        ECMAScript 5中出现的静态函数&#xA;        参数1是原型对象, 参数2可选，对对象属性进一步描述&#xA;&#xA;        Object.create({x:2})&#xA;        Object.create(null)&#xA;            传入参数null来创建没有原型的新对象。&#xA;            没有原型的对象没有toString等方法, 所有不能+运算&#xA;        Object.create(Object.prototype)&#xA;            创建普通对象&#xA;对象序列化(serialization)                            # json(JavaScript Object Notation)&#xA;    ECMAScript 5 api                                # stringify, parse的第二个参数可选，传入属性列表来定制序列化或还原操作&#xA;        JSON.stringify()&#xA;            支持对象, 数组, 字符串, 无穷大数字, true, false, null。NaN, Infinity, -Infinity序列化结果是null&#xA;                日期stringify为日期字符串，parse不能还原成对象&#xA;                只序列化对象的可枚举自有属性。不能序列化的属性自动省略掉&#xA;            函数, RegExp, Error对象和undefined不能序列化和还原&#xA;        JSON.parse()&#xA;创建对象                                            # 函数即对象，本身为构造方法&#xA;    var obj = {};                                  # var obj = []是数组, 数组中Obj[&#39;aa&#39;]添加的是属性而非成员, 静态对象&#xA;    function Obj(a, b){};&#xA;        new Obj(a, b);&#xA;    function Obj(a, b){&#xA;        thisf = new Array();&#xA;        return new Object(a, b)&#xA;    };            &#xA;        Obj(a, b);&#xA;            只能返回Obj里定义的新对象的实例(不能返回本身的实例)&#xA;            内的变量函数静态。指向外部函数可动态&#xA;            内对象为动态&#xA;        new Obj(a, b);                              # 内变量函数动态(内存浪费)&#xA;        Obj.prototype.c = &#39;c&#39;&#xA;        Obj.prototype.d = function(){};&#xA;        Obj.prototype.e = new Array();              # prototype函数为静态函数, prototype对象为静态&#xA;    function Obj(a, b){ }                           # 内部prototype, 与外部完全相同&#xA;        if(typeof Obj._initialized == &#39;undefined&#39;){&#xA;            Obj.prototype.c = function(){};&#xA;            Obj._initialized = true;&#xA;        }&#xA;    最好方式:&#xA;        内部定义变量和对象, prototype定义函数(防止new对象的函数动态)。&#xA;        prototype定义函数可以在内部，也可以在外部。&#xA;    扩展对象&#xA;        Obj.prototype.extend                        # 添加或重写当前对象的属性&#xA;        Object.prototype.extend                     # 所有对象上添加属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;属性&#34;&gt;&#xA;  属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;查询和设置&#xA;    . []&#xA;        ECMAScript 3中, 点运算符后的标识符不能是保留字。ECMAScript5(包括ECMAScript3的某些实现)中可以&#xA;        []中必须返回可以转换为字符串的值&#xA;        []的写法用了字符串索引，叫做关系数组(associative array), 散列或字典&#xA;    属性不存在时自动创建&#xA;描述对象&#xA;    value&#xA;    writable                                        # 可修改&#xA;    enumerable                                      # 可枚举性&#xA;        for...in, Object.keys(), JSON.stringify(), Object.assign(), Reflect.enumerate()会忽略不可枚举属性&#xA;        for...in等价Reflect.enumerate(), 会返回继承的属性&#xA;    configurable                                    # 可配置&#xA;遍历属性                                             # 先遍历属性名是数值的属性，再遍历字符串，再遍历Symbol&#xA;    for ... in                                      # 自身和继承的可枚举属性&#xA;    Object.keys                                     # 自身的可枚举属性(不含Symbol)&#xA;    Object.getOwnPropertyNames                      # 自身所有属性(不含Symbol)&#xA;    Object.getOwnPropertySymbols                    # 自身所有Symbol属性&#xA;    Reflect.ownKeys                                 # 自身所有属性&#xA;    Reflect.enumerate                               # 同for ... in&#xA;访问错误&#xA;    查询不存在的属性不报错, 返回undefined&#xA;    对象不存在，会查询null和undefined的属性，会报错&#xA;        建议写法: var len = book &amp;amp;&amp;amp; book.subtitle &amp;amp;&amp;amp; book.subtitle.length&#xA;    只读的设置不报错，如                              # ECMAScript 5的严格模式中会报错&#xA;        Object.prototype = 0;        &#xA;设置属性失败的情况&#xA;    o中属性p是只读的                                  # defineProperty()可以&#xA;    o中属性p是继承属性，且它是只读的&#xA;    o没有属性p, o没有使用p的setter方法, o可扩展性为false&#xA;删除属性&#xA;    delete&#xA;        删除成功，属性不存在，不是属性访问表达式时，返回true&#xA;        属性可配置性为false，非严格模式下返回false, 严格模式下抛出异常&#xA;        全局对象可以不用属性访问表达式, 如 delete x;&#xA;            严格模式下, delete x; 会报语法错误, 必须delete this.x&#xA;        只是断开联系&#xA;        只删除自有属性，不能删除继承属性&#xA;            继承属性可以从原型对象上删除它&#xA;            a = {p:{x:1}}; b= a.p; delete a.p; 执行后p.x还是1。因为属性的引用依然存在&#xA;                会内存泄漏，所以在销毁对象时，要遍历属性中的属性，依次删除&#xA;检测属性&#xA;    in                                              # 检测自有属性和继承属性&#xA;        &amp;quot;x&amp;quot; in o;&#xA;    o.x !== undefined                               # 同in，但没法区分属性的值为undefined时的属性，in可以&#xA;                                                    # !==可以区分null和undefined, 所以用!==&#xA;    hasOwnProperty()                                # 只检测自有属性&#xA;        o.hasOwnProperty(&amp;quot;x&amp;quot;);&#xA;    propertyIsEnumerable()                          # 自有属性且可枚举&#xA;        o.propertyIsEnumerable(&amp;quot;x&amp;quot;)&#xA;枚举属性                                             # ECMAScript 3 的不可枚举属性不能得到&#xA;    for/in&#xA;        ECMAScript 5之前, 工具库给Object.prototype添加的属性必须可枚举&#xA;        所以for/in会枚举出来，要用hasOwnProperty(p)来过滤&#xA;    Object.keys()                                   # ECMAScript 5中定义，返回可枚举的自有属性名数组&#xA;    Object.getOwnPropertyNames()                    # ECMAScript 5中定义，返回自有属性名数组&#xA;getter和setter&#xA;    通常用来表示同一组数据的两种方法(如笛卡尔坐标系表示法和极坐标系表示法)&#xA;        也用于检测属性的写入和读取值&#xA;    ECMAScript 5中属性值可以用方法替代，就是getter和setter, 叫做存取器属性(accessor property)&#xA;        是访问描述符，相对数据描述符(如writable)&#xA;        普通的属性叫做数据属性(data property), 只有一个简单的值&#xA;        存取器属性不具有可写性(writable attribute)&#xA;        作为替代, 只有getter, 则只读。只有setter, 则只写。同时拥有, 则可读写&#xA;            读取只写属性总是返回undefined&#xA;        存取器属性是可以继承的&#xA;    定义&#xA;        var o = {&#xA;            data_prop: 1,&#xA;            get accessor_prop(){},                  # 函数中的this表示当前对象o&#xA;            set accessor_prop(value){}&#xA;        };&#xA;        var descriptor = Object.getOwnPropertyDescriptor(o, &#39;accessor_prop&#39;);&#xA;        &#39;get&#39; in descriptor    // true&#xA;        &#39;set&#39; in descriptor    // true&#xA;    例子&#xA;        var p = {&#xA;            $x: 1.0, &#xA;            $y: 1.0,&#xA;            get r () {return Math.sqrt(this.x * this.x + this.y * this.y);},&#xA;            set r (newvalue) {&#xA;                var oldvalue = Math.sqrt(this.x * this.x + this.y * this.y);&#xA;                var ratio = newvalue/oldvalue;&#xA;                this.x *= ratio;&#xA;                this.y *= ratio;&#xA;            },&#xA;            get theta () {return Math.atan2(this.y, this.x); }&#xA;        }&#xA;    例子&#xA;        var serialnum = {                           # 序列&#xA;            $n: 0,                                  # $暗示私有属性&#xA;            get next(){return this.$n++;},&#xA;            set next(n){&#xA;                if(n &amp;gt;= this.$n) this.$n = n;&#xA;                else throw &amp;quot;序列号的值不能比当前值小&amp;quot;;&#xA;            }&#xA;        }&#xA;    例子2&#xA;        var random = {                              # 返回不同数量范围的随机数&#xA;            get octet(){ return Math.floor(Math.random() * 256)},&#xA;            get uint16(){ return Math.floor(Math.random() * 65536)},&#xA;            get int16(){ return Math.floor(Math.random() * 65536) - 32768}&#xA;        };&#xA;属性的特性                                           # ECMAScrit 3这些特性不可以配置, ECMAScript 5中提供查询和设置的api&#xA;    作用&#xA;        给原型对象添加方法，设置该方法为不可枚举，看起来像内置方法&#xA;        给普通对象定义不能修改或删除的属性，实现&amp;quot;锁定&amp;quot;&#xA;    组成&#xA;        值(value), 可写性(writable)、可枚举性(enumerable)、可配置性(configurable)&#xA;            存取器特性是读取(get)、写入(set)、可枚举性、可配置性&#xA;    原理&#xA;        ECMAScript 5定义了 属性描述符(property descriptor)对象, 代表4个特性&#xA;            该对象的属性有value, writable, enumerable, configurable, 代表4个特性&#xA;            存取器属性描述符用get和set代替value和writable&#xA;                writable, enumerable, configurable是布尔值&#xA;                get和set是函数值, value什么都可以&#xA;    调用                                             # 新建属性的默认特性对象为false或undefined&#xA;        Object.getOwnPropertyDescriptor(o, p)&#xA;            获得对象o的p自有属性的 属性描述符对象&#xA;            要得到继承属性的特性, 要遍历原型链&#xA;        Object.defineProperty(o, &amp;quot;x&amp;quot;, {             # 新建或修改自有属性的特性, 传入对象和属性名与属性描述符对象&#xA;            value: 1,&#xA;            writable: true,&#xA;            enumerable: false,&#xA;            configurable: true&#xA;        });&#xA;        Object.defineProperty(o, &amp;quot;x&amp;quot;, {get: function(){ return 0; }});&#xA;            修改x为存取器属性&#xA;                返回修改后的对象&#xA;            不允许创建或修改的属性，抛出类型错误异常&#xA;                规则(违反则抛异常)&#xA;                    对象不可扩展，可以编辑已有属性, 不能添加&#xA;                    属性不可配置, 不能修改可配置性和可枚举性&#xA;                    存取器属性不可配置, 不能修改getter, setter方法, 不能转换为数据属性&#xA;                    数据属性不可配置，不能转换在存取器属性&#xA;                    数据属性不可配置，不能可写性从false修改为true&#xA;                    数据属性不可配置且不可写, 不能修改值。可配置但不可写时可以修改值&#xA;                        实际上自动标记为可写，再改值，再转换为可写&#xA;        Object.defineProperties({}, {&#xA;            x: {value: 1, writable: true, enumerable: true, configurable: true},&#xA;            y: {value: 1, writable: true, enumerable:true, configurable:true},&#xA;            r: {&#xA;                get: function(){return Math.sqrt(this.x * this.x + this.y * this.y)},&#xA;                enumerable: true,&#xA;                configurable: true&#xA;            }&#xA;        })&#xA;            新建或修改多个属性及特性。第一个参数是修改对象，第二个参数是映射表&#xA;                返回修改后的对象&#xA;            不允许创建或修改的属性，抛出类型错误异常&#xA;    老式api(ECMAScript 5之前，非IE浏览器)&#xA;        __lookupGetter__()&#xA;        __lookupSetter__()                              # 返回一个属性的getter和setter&#xA;        __defineGetter__()&#xA;        __defineSetter__()                              # 定义getter和setter, 第一个参数是属性名, 第二个参数是getter或setter方法&#xA;对象三个属性&#xA;    包括&#xA;        原型(prototype)&#xA;        类(class)&#xA;        可扩展性(extensible attribute)&#xA;    原型&#xA;        api&#xA;            Object.getPrototypeOf()                     # ECMAScript 5出现, 传入对象返回原型&#xA;            o.constructor.prototype                     # 得到对的原型，对于Object.create()创建的对象常不是这样&#xA;            p.isPrototypeof(o)                          # 检测p是否是o的原型(或牌原型链中)，与instanceof运算符类似&#xA;            __proto__                                   # Mozilla实现的js有的属性, safari和chrome也支持&#xA;    类属性&#xA;        表示对象类型信息的字符串, 用toString()方法可以得到&#xA;        ECMAScript 3和5 都不能设置这个属性，只能间接查询&#xA;        js内置构造函数创建的对象类属性与函数名称相匹配&#xA;            对象直接量、Object.create、自定义构造函数 创建的对象类属性是&amp;quot;Object&amp;quot;&#xA;            对于自定义类来说，没办法通过类属性来区分对象的类&#xA;        api&#xA;            toString()                                  # 返回如 [object class], 提取class, 很多对象的toString方法重写了, 要间接调用Function.call()方法&#xA;            function classof(o){&#xA;                if(o === null) return &amp;quot;Null&amp;quot;;&#xA;                if(o === undefined) return &amp;quot;Undefined&amp;quot;; # ECMAScript 5中不需要对null和undefined作处理&#xA;                return Object.prototype.toString.call(o).slice(8, -1);&#xA;            }&#xA;    可扩展性&#xA;        表示是否可以给对象添加新属性。ECMAScript 5中 内置对象和自定义对象都显式可扩展&#xA;        宿主对象可扩展性由js引擎定义&#xA;        api&#xA;            # preventExtensions, seal, freeze 都返回传入的对象&#xA;            Object.esExtensible()                       # 判断对象是否可扩展&#xA;            Object.preventExtensions()                  # 转换对象为不可扩展, 参数为待转换对象, 对象转换不可扩展后，无法再转换回来, 给不可扩展对象原型添加属性, 对象同样会继承新属性&#xA;            Object.seal()                               # 对象设置不可扩展, 同时对象自有属性不可配置, 已有属性标记为可写的依然可配置, seal后的对象不能解封&#xA;            Object.isSealed()                           # 检测对象是否封闭&#xA;            Object.freeze()                             # 除了seal外，将自有数据属性设置为只读, setter方法不受影响&#xA;            Object.isFrozen()                           # 检测是否冻结&#xA;继承&#xA;    介绍&#xA;        js对象有自有属性(own property)，有从原型继承来的属性&#xA;    原型链(prototype chain)                              # 原型，原型的原型 ...&#xA;        属性的查询先找自有属性，再找原型链&#xA;        属性修改时, 先检查属性是否允许赋值。&#xA;            总在自有属性修改或创建，不修改原型链上的对象。这就是属性的覆盖(override)&#xA;                继承的对象有setter方法且是accessor属性时，修改属性时会由当前对象(非原型对象)调用setter方法。&#xA;                由当前对象调用，所以还是不会修改原型链&#xA;                setter方法如setTitle()&#xA;    inherit(p)函数&#xA;        function inherit(p){&#xA;            if(p == null) throw TypeError();&#xA;            if(Object.create) return Object.create(p);&#xA;            var t = typeof p;&#xA;            if(t !== &amp;quot;object&amp;quot; &amp;amp;&amp;amp; t !== &amp;quot;function&amp;quot;) throw TypeError();&#xA;            function f(){};&#xA;            f.prototype = p;&#xA;            return new f();&#xA;        }&#xA;        var o = {x: &amp;quot;don&#39;t change this value&amp;quot;};&#xA;        library_function(inherit(o));                   # 可以防止对o的意外修改&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数组&#34;&gt;&#xA;  数组&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    数字索引                                             # 最大索引 2^32 - 2, 实现经过优化, 数字索引访问比访问常规属性快很多&#xA;    元素无类型&#xA;    数组是动态, 根据需要它们会增长或缩减&#xA;    数组可能是稀疏的, 索引不一定连续, length对于稀疏数组取最大索引+1&#xA;原理&#xA;    数组对象使用小于0 ~ 2^32 - 2 非负整数属性名时, 自动维护其length属性值&#xA;    [] 索引内的数字作为索引创建和访问, 其它作为属性&#xA;    a[&#39;1&#39;] 同 a[1] 同 a[1.000]&#xA;    数组可以原型继承, 可以定义getter, setter方法&#xA;    数组元素可以delete, in, for/in                        # delete a[0], 0 in a&#xA;稀疏数组&#xA;    稀疏数组比稠密数组更慢, 内存利用率更高, 查找元素与常规对象属性查找时间一样长&#xA;    for/in时会跳过未有元素&#xA;&#xA;    a = new Array(5)&#xA;    a = [, , ,]&#xA;    a = [1, , 3]                                        # 旧版本实现中, [1,,3]与[1,undefined, 3]是一样的，不是稀疏数组&#xA;    a[1000] = 0&#xA;创建与调用&#xA;    var misc = [1.1, , true]                            # 第二个是undefined&#xA;    new Array()&#xA;    new Array(10)                                       # 预分配数组空间&#xA;    new Array(5, 4, &amp;quot;testing&amp;quot;)&#xA;    a[0]        &#xA;    a.length    &#xA;        length大于每一个索引&#xA;        对lenght赋值, 小于length索引的元素将删除, 如length=0清空数组&#xA;            Object.defineProperty()让数组的length变成只读&#xA;            Object.defineProperty(a, &amp;quot;length&amp;quot;, {writable: false})来避免删除元素&#xA;            让数组无线不能配置也可以，如Object.seal, Object.freeze方法&#xA;添加删除&#xA;    a[1] = &amp;quot;a&amp;quot;;&#xA;    a.push(&amp;quot;zero&amp;quot;, &amp;quot;one&amp;quot;)&#xA;    delete a[1]&#xA;    a.pop()                                             # 反push&#xA;    a.shift()                                           # 头部删除, 重改所有元素索引&#xA;    a.unshift()                                         # 反shift, 头部插入元素&#xA;    splice()                                            # 通用方法插入, 删除, 替换数组元素, 根据需要修改length属性&#xA;遍历&#xA;    for(var i = 0; i &amp;lt; a.length; i++)                   # 判断undefined&#xA;    for(var index in a){                                # 会遍历出Array.prototype中的方法, 要进行过滤, ECMAScript 允许for/in遍历顺序不同, 一般是升序的, 如果同时有属性和元素，很可能是创建顺序&#xA;        if(!a.hasOwnProperty(i)) continue;&#xA;        // if(String(Math.floor(Math.abs(Nuber(i)))) !== i) continue;        # 跳过不是正整数的i&#xA;    }&#xA;    a.forEach(function(x){})                            # ECMAScript 5定义的新方法&#xA;多维数组                                                 # js不支持真正的多维数组，可以用数组模拟&#xA;    var a = new Array(10)&#xA;    a[0] = new Array(10)&#xA;    a[0][0]&#xA;空位问题&#xA;    Array(3)    // [, , , ]                             # 没有0位置, 但length = 3, 不同于有0位置但值为undefined, es5中对空位处理很不一致, 一般是跳过, es6会将空位值转为undefined&#xA;类数组对象                                               # 与数组相似的对象, 字符串虽然与数组类似，但length没有限制, 最好不看作类数组对象&#xA;    特性&#xA;        自动更新length属性, length设置后自动截断数组&#xA;        从Array.prototype中继承了一些有用的方法&#xA;        类属性(class)为&amp;quot;Array&amp;quot;(Date等类也是&amp;quot;Date&amp;quot;)&#xA;    创建                                                 # 数组的方法对于自定义的类数组对象是通用的, 虽然不能继承Array.prototype, 但可以间接调用Function.call&#xA;        要求&#xA;            自动维护length属性&#xA;            下标是数字字符串并在数组下标范围内&#xA;        var a = {&amp;quot;0&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;1&amp;quot;: &amp;quot;b&amp;quot;}&#xA;作为数组的字符串&#xA;    介绍&#xA;        ECMAScript 5中，字符串类似只读数组。访问如下&#xA;            s.charAt(0)&#xA;            s[0]&#xA;        Array.isArray(s)是false&#xA;        通用字符串方法可以乃至字符串中，如                   # 但字符串是不可变值的，所以中push, sort, reverse, splice在字符串上是无效的, 出错时没有提示&#xA;            Array.prototype.join.call(&#39;abc&#39;, &amp;quot; &amp;quot;)        # &amp;quot;a b c&amp;quot;&#xA;二进制数组&#xA;    介绍&#xA;        ArrayBuffer, TypedArray, DataView&#xA;        TypedArray按小端字节序来处理ArrayBuffer, 大端字节序可以自定义DataView&#xA;    TypedArray&#xA;        溢出&#xA;            正向溢出(overflow)&#xA;                uint8[0] = 256    // 0                  # 值为 数据类型最小值 + 余值 - 1, 这里为 0 + 1 - 1&#xA;                int8[0] = 128    // -128                # -128 + 1 - 1&#xA;            负向溢出(underflow)&#xA;                uint8[0] = -1    // 255                 # 值为 数据类型最大值 - 余值 + 1, 这里为 255 - 1 + 1&#xA;                int8[0] = -129    // 127                # 127 - 1 + 1&#xA;            Uint8ClampedArray负向溢出都为0, 正向溢出都为255&#xA;    场景&#xA;        o-&amp;gt;ajax中&#xA;        xhr.responseType设置为 &#39;arraybuffer&#39;来接收二进制数据(也可以设blob)&#xA;&#xA;        o-&amp;gt; canvas中&#xA;        ctx.getImageData(0, 0, canvas.width, canvas.height)&#xA;        uint8ClampedArray = imageData.data;&#xA;&#xA;        o-&amp;gt;　websocket中&#xA;        socket.binaryType = &#39;arraybuffer&#39;&#xA;        var arrayBuffer = event.data;&#xA;        socket.send(new Uint8Array(4).buffer);&#xA;&#xA;        o-&amp;gt; fetch api中&#xA;        返回request.arrayBuffer()得到arrayBuffer数据&#xA;&#xA;        o-&amp;gt; file api中&#xA;        reader.readAsArrayBuffer(file);&#xA;        reader.onload = function() { var arrayBuffer = reader.result; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;集合&#34;&gt;&#xA;  集合&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e5%90%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Set&#xA;    数据唯一&#xA;    Nan等于自身&#xA;WeakSet&#xA;    成员只能是对象&#xA;    成员弱引用，垃圾回收不考虑其引用，所以不能引用其成员，所以WeakSet不可遍历，因为刚遍历出的成员可能已删除&#xA;    可用于储存dom节点，实时判断是否存在，且防止内存泄漏&#xA;Map&#xA;    各种类型都可作为键, 键唯一覆盖, NaN等于自身, +0 等于 -0&#xA;WeakMap&#xA;    只接受对象作key&#xA;    元素被回收后, 自动移除对应的键值对&#xA;    适用于dom节点作键名，部署关联外部的私有属性(外部对象删除后，私有属性同步删除)，不会内存泄漏&#xA;遍历器&#xA;    介绍&#xA;        默认三种结构支持, Array, Set, Map。Object不支持，因为不确定遍历顺序&#xA;        字符串是类数组，有原生的iterator接口&#xA;    内部调用方式&#xA;        解构&#xA;            let [x, y] = new Set().add(1).add(2);&#xA;        扩展运算符&#xA;            [...iterable]&#xA;        yield* iterable&#xA;        参数&#xA;            for ... of&#xA;            Array.from()&#xA;            Map(), Set(), WeakMap(), WeakSet()&#xA;            Promise.all()&#xA;            Promise.race()&#xA;    实现&#xA;        iterable[Symbol.iterator] = function* () {&#xA;            yield 1;&#xA;            yield 2;&#xA;        }&#xA;        iterable[Symbol.iterator] = function () {&#xA;            return {&#xA;                next(){},&#xA;                return () { return {done: true}}        # return 在for ... of 提前退出(出错, break, continue), 可以用于释放资源, return 方法必须返回一个对象，这是Generator规格规定的&#xA;                throw() {}                              # 配合Generator使用&#xA;            };&#xA;&#xA;        }&#xA;    使用&#xA;        var result = iterator.next()&#xA;        while(!result.done) {&#xA;            var x = result.value;&#xA;            result = iterator.next();&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;proxy&#34;&gt;&#xA;  proxy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#proxy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    元编程(meta programming), 在对象外层进行代理&#xA;    在obj.proxy上设置Proxy对象，该对象的操作会变成对Proxy对象的操作&#xA;&#xA;var obj = new Proxy({}, {&#xA;    get: function (target, key, receiver) {&#xA;        return Reflect.get(target, key, receiver);&#xA;    },&#xA;    set: function (target, key, value, receiver) {&#xA;        return Reflect.set(target, key, value, receiver);&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reflect&#34;&gt;&#xA;  reflect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reflect&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    将Object上一些明显属于语言内部的方法(如Object.defineProperty)放到Reflect上&#xA;    修改Object上原有方法，变得更合理, 如Object.defineProperty在无法定义属性时抛出异常, 而Reflect.definePropert则返回false&#xA;    让Object操作变成函数作为, 如name in obj, delete obj[name]变成Reflect.has, Reflect.deleteProperty&#xA;    让Proxy上方法与Reflect方法对应，让Proxy的对象操作默认行为在Reflect上执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;正则&#34;&gt;&#xA;  正则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a3%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基本字符&#xA;    会精确匹配一段字符，如hi。这段字符可以出现多次&#xA;字面量&#xA;    /^[a-z]+$/.text(str);                   # ^代表开头, $是结尾&#xA;转义&#xA;    \&#xA;元字符                                       # metacharacter&#xA;    .                                       # 匹配除换行符以外任意字符&#xA;    \b&#xA;                                            # 表示单词的开头或结尾，也就是单词的分界。只匹配一个位置\s\S&#xA;        \bhi\b                              # hi单词&#xA;    \d                                      # 表示数字&#xA;    \s                                      # 匹配任意空白符，包括空格、tab、换行、中文全角空格等&#xA;        \s\S                                # 匹配包括\n在内的所有字符&#xA;    \w                                      # 匹配非特殊字符，包括字母、数字、下划线或汉字&#xA;    ^                                       # 匹配开头&#xA;    $                                       # 匹配结尾&#xA;    反义&#xA;        \W                                  # 非字符&#xA;        \S                                  # 非空白&#xA;        \D                                  # 非数字c&#xA;        \B                                  # 非单词位置&#xA;非&#xA;    [^x]                                    # 非x, [^aeiou] 除了aeiou以外的任意字符&#xA;限定字符&#xA;    {2}                                     # 表示前面的内容出现2次, {5, 12}内容出现5到12次, {5, }内容出现5或更多次&#xA;    ?                                       # 零次或一次&#xA;    *                                       # 零个或多个&#xA;    +                                       # 表示一个或多个&#xA;字符类&#xA;    [aeiou]                                 # 匹配其中的一个, [.?!] 匹配.或?或!&#xA;    [0-9]                                   # 同\d, [a-z0-9A-Z] 同\w&#xA;分枝条件&#xA;    |                                       # jpg|png,&#xA;        每个分支都从第一个分支开始匹配, 如\d{5}|\d{5}-d{4}只能匹配11111或11111-2222中的11111&#xA;分组                                         # 零宽断言只占用不消费&#xA;    ()&#xA;    语法&#xA;        (exp)&#xA;        (?&amp;lt;name1&amp;gt;exp)                       # 组命名&#xA;        (?:exp)                             # 消费exp, 不捕获匹配的文本，也不分配组号&#xA;        (?=exp)                             # 零宽断言，正向前瞻，后面能匹配表达式exp&#xA;            \b\w+(?=ing\b)                  # 匹配以ing结尾单词的前面部分，如dancing中的danc&#xA;            /(\w)\1{2}(?=(\w)\2{2})/g       # 匹配所有在3个连续相同字符前的相邻3个连续相同字符, aaalllsss0tAAAnnn999结果是aaa, lll, AAA, nnn&#xA;        (?&amp;lt;=exp)                            # 零宽断言，正向后瞻，前面能匹配表达式exp&#xA;            (?&amp;lt;=\bre)\w+\b                  # 匹配以re开头单词的后半部分，如reading中的ading&#xA;        (?!exp)                             # 零宽断言，负向前瞻，后面不匹配exp的位置, js不支持&#xA;            \b\w*q(?!u)\w*\b                # 匹配一个单词，该单词包含后面不是字母u的字母q&#xA;                &#xA;            \d{3}(?!\d)                     # 匹配三位数字，且它们后面不能有数字&#xA;            \b((?!abc)\w)+\b                # 匹配不包含连续字符串abc的单词&#xA;        (?&amp;lt;!exp)                            # 零宽断言，负向后瞻，前面不匹配exp的位置, js不支持&#xA;            (?&amp;lt;![a-z])\d{7}                 # 匹配前面不是小写字母的七位数字&#xA;        (?#comment)                         # 注释&#xA;后向引用                                     # 分组捕获后会自动编号，从左到右，1234。后向引用用于引用前面匹配到的文本，如 \1 代表分组1匹配的文本&#xA;    \b(\w+)\b\s+\1\b                        # 匹配重复的单词, 如go go&#xA;    (?&amp;lt;Word&amp;gt;\w+) 或 (?&#39;Word&#39;\w+)             # 把\w+的组名指定为Word, 用\k&amp;lt;Word&amp;gt;引用&#xA;贪婪与懒惰&#xA;    o-&amp;gt; 包含能接受重复限定符时，会匹配尽可能多的字符。如a.*b&#xA;    o-&amp;gt; a.*?b会懒惰匹配&#xA;        懒惰限定符&#xA;            *? 重复懒惰匹配任意次&#xA;            +? 重复懒惰匹配1次或多次&#xA;            ?? 重复懒惰匹配0次或1次&#xA;            {n, m}? 重复懒惰匹配n到m次&#xA;            {n,}? 重复懒惰匹配n次以上&#xA;平衡组/递归匹配&#xA;    (?&#39;group&#39;) 把捕获的内容命名为group，并压入栈(Stack)&#xA;    (?&#39;-group&#39;) 从栈中弹出最后压入的名为group的捕获内容。如果栈为空，则匹配失效&#xA;    (?(group)yes|no) 如果栈中存在名为group的捕获内容，继续匹配yes部分的表达式，否则则继续匹配no部分的表达式&#xA;    示例                                      # 平衡组最常见的应用是匹配HTML&#xA;        匹配xx&amp;lt;aa&amp;lt;bbb&amp;gt;&amp;lt;bbb&amp;gt;aa&amp;gt;yy&#xA;            思路&#xA;                每碰到左括号，就压入一个Open, 每碰到右括号，弹出一个&#xA;                最后看栈是否空，如果否则表示不配对，应该失败&#xA;                正则表达式引擎会进行回溯(放弃最前面或最后面一些字符), 尽量使整个表达式得到匹配&#xA;        &amp;lt;                                     # 最外层的左括号&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号的内容&#xA;        (&#xA;        (&#xA;        (?&#39;Open&#39;&amp;lt;)                            # 又碰到了左括号, 压入一个Open&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号内容&#xA;        )+&#xA;        (&#xA;        (?&#39;-Open&#39;&amp;gt;)                           # 碰到了右括号, 擦掉一个Open&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号内容&#xA;        )+&#xA;        )*&#xA;        (?(Open)(?!))                         # 负向前瞻，判断栈中还有没有Open, 有则匹配失败&#xA;        &amp;gt;                                     # 最外层右括号&#xA;        )&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; js中不支持 回顾后发断言&#xA;o-&amp;gt; 可以跟三个flag，比如/something/igm&#xA;    i表示不区分大小写&#xA;    g表示匹配多个&#xA;        g会影响String.prototype.match()和RegExp.prototype.exec()的行为&#xA;        match中加g会返回数组，不加g返回比较详细的信息&#xA;        exec中加g，且正则存在变量中时,该正则变量执行exec后会存储信息, 如&#xA;        var re = /h(.*?)\b/g;&#xA;        re.exec(&#39;hello helloo&#39;) 执行三次，匹配内容有变化&#xA;    m表示，^$可以匹配每一个的开头和结尾&#xA;o-&amp;gt; api&#xA;    RegExp&#xA;        exec                                    # 执行第一个, exp本身保留执行状态&#xA;            exp = /#/&#xA;            exp.exec(&#39;##&#39;)&#xA;        test&#xA;    String&#xA;        replace                                 # 替换第一个, &#39;abc - 123 - #$*&#39;&#xA;            &#39;John Smith&#39;.replace(/(\w+)\s(\w+)/, &#39;$2, $1&#39;)&#xA;            &#39;abc123#$*&#39;.replace(/([^\d]*)(\d*)([^\w]*)/, function replacer(match, p1, p2, p3, offset, string) {&#xA;            return [p1, p2, p3].join(&#39; - &#39;);&#xA;            });&#xA;        replaceAll&#xA;        match                                   # 不能有g选项，只得到第一个匹配&#xA;&#xA;.net中处理选项&#xA;    IgnoreCase                                  # 忽略大小写&#xA;    Multiline                                   # 多行模式, 更改^$的含义为一行首和行尾, $表示\n之前的位置以及字符串结束前的位置&#xA;    Singleline                                  # 单行模式(可以与Multiline通用)，更改.的含义，便它与每一个字符匹配(包括\n)&#xA;    IgnorePatternWhitespace                     # 忽略空白，会忽略表达式中非转义空白并启用#作为标记注释&#xA;    ExplicitCapture                             # 显式捕获，仅捕获已被显式命名的组&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;常用&#34;&gt;&#xA;  常用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;a[^&amp;gt;]+&amp;gt;&#xA;    # 用尖括号括起来的以a开头的字符串&#xA;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$&#xA;    # 密码的强度必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间&#xA;^[\\u4e00-\\u9fa5]{0,}$&#xA;    # 字符串只能是中文&#xA;^\\w+$&#xA;    # 由数字，26个英文字母或下划线组成的字符串&#xA;[\\w!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?&#xA;    # 校验E-Mail 地址&#xA;^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$&#xA;    # 校验身份证号码 15位&#xA;^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$&#xA;    # 校验身份证号码 18位&#xA;^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$&#xA;    # “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年&#xA;^[0-9]+(.[0-9]{2})?$&#xA;    # 金额校验，精确到2位小数&#xA;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$&#xA;    # 国内 13、15、18开头的手机号正则表达式&#xA;^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$&#xA;    # 判断IE的版本&#xA;\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&#xA;    # 校验IP-v4地址&#xA;(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))&#xA;    # 校验IP-v6地址&#xA;/^[a-zA-Z]+:\\/\\//&#xA;    # 检查URL的前缀&#xA;^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;amp;=]*)?&#xA;    # 提取URL链接&#xA;^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&amp;quot;&amp;lt;&amp;gt;|]+\\.txt(l)?$&#xA;    # 文件路径及扩展名校验&#xA;^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$&#xA;    # 提取Color Hex Codes&#xA;\\&amp;lt; *[img][^\\\\&amp;gt;]*[src] *= *[\\&amp;quot;\\&#39;]{0,1}([^\\&amp;quot;\\&#39;\\ &amp;gt;]*)&#xA;    # 提取网页图片&#xA;(&amp;lt;a\\s*(?!.*\\brel=)[^&amp;gt;]*)(href=&amp;quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&amp;quot;]+)&amp;quot;((?!.*\\brel=)[^&amp;gt;]*)(?:[^&amp;gt;]*)&amp;gt;&#xA;    # 提取页面超链接&#xA;^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}&#xA;    # 查找CSS属性&#xA;&amp;lt;!--(.*?)--&amp;gt;&#xA;    # 抽取注释&#xA;&amp;lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&amp;quot;.*?&amp;quot;|&#39;.*?&#39;|[\\^&#39;&amp;quot;&amp;gt;\\s]+))?)+\\s*|\\s*)\\/?&amp;gt;&#xA;    # 匹配HTML标签&#xA;&#39;12345678901&#39;.replace(/(\d{3})\d{4}(\d{4})/, &#39;$1****$2&#39;)&#xA;    # 替换中四位到*&#xA;&#39;1111111&#39;.replace(/([\d]{3})(?=[\d]+)/g, &#39;$1-&#39;)&#xA;    # 替换为 &#39;111-111-1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;元字符扩展&#34;&gt;&#xA;  元字符扩展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%83%e5%ad%97%e7%ac%a6%e6%89%a9%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;\a              # 报警字符&#xA;\t              # 制表符&#xA;\v              # 竖向制表符&#xA;\r              # 回车&#xA;\f              # 换页符&#xA;\n              # 换行符&#xA;\e              # Escape&#xA;\0nn            # ASCII码中八进制代码为nn的字符&#xA;\xnn            # ASCII码中十六进制代码为nn的字符&#xA;\unnnn          # Unicode码中十六进制代码为nnnn的字符&#xA;\cN             # ASCII控制字符，如\cC 代表ctrl + c&#xA;\A              # 字符串开头，同^但不受多行选项影响&#xA;\Z              # 字符串结尾或行尾，不受多行选项影响&#xA;\z              # 字符串结尾，同$但不受多行选项影响&#xA;\G              # 当前搜索的开头&#xA;\p{name}        # Unicode中命名为name的字符类，如\p{IsGreek}&#xA;(?&amp;gt;exp)         # 贪婪子表达式&#xA;(?&amp;lt;x&amp;gt;-&amp;lt;y&amp;gt;exp)   # 平衡组&#xA;(?im-nsx:exp)   # 在子表达式exp中改变处理选项&#xA;(?im-nsx)       # 为表达式后面的部分改变处理选项&#xA;(?(exp)yes|no)  # 把exp当作零宽正向先行断言，如果能匹配，使用yes作为此组表达式，否则使用no&#xA;    (?(exp)yes) 只使用空表达式为no&#xA;    (?(name)yes|no) 命名为name的组捕获到内容，使用yes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;风格&#34;&gt;&#xA;  风格&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a3%8e%e6%a0%bc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 最好js和html用独立的引号风格，如&#xA;        html双引号, js单引号&#xA;o-&amp;gt; 始终用var之类来声明变量，不用未声明变量&#xA;&#xA;o-&amp;gt; let和const取代var, 全局常量使用const&#xA;&#xA;o-&amp;gt; 特意将变量声明放在函数体顶部, 而不是使用变量之外, 来反映真实的作用域声明提前&#xA;&#xA;o-&amp;gt; 多用解构&#xA;    const [first, second] = arr                 # 数组取元素&#xA;    function f({a, b}) {}                       # 对象解构给函数赋值&#xA;    function f() {return {a, b}}, const {a, b} = f()                # 函数返回值解构&#xA;    var arr2 = [...arr]                         # 扩展运算符拷贝数组&#xA;&#xA;o-&amp;gt; 单行定义对象不逗号结尾(以后不扩展), 多行时逗号结尾(以后可能会扩展), 尽量用简洁的写法&#xA;    {a: 1, b}&#xA;    {&#xA;        [getKey(&#39;a&#39;)],&#xA;    }&#xA;&#xA;o-&amp;gt; Array.from转换类数组到数组&#xA;&#xA;o-&amp;gt; 匿名函数 (() =&amp;gt; {})(), 同时绑定了this为当前作用域&#xA;&#xA;o-&amp;gt; 不使用arguments, 使用rest运算符&#xA;&#xA;o-&amp;gt; 函数使用默认值 function f (opts = {})  {}&#xA;&#xA;o-&amp;gt; 用Map取代Object, 因为Map内建遍历机制, key可为对象。只能要数据转换时用Object&#xA;&#xA;o-&amp;gt; 总是用class取代需要的prototype操作, 因为class写法更简洁。extends也更简单, 不会有破坏instanceof运算的危险&#xA;&#xA;o-&amp;gt; 模块使用es6的机制, 模块只能一个输出时用export default, 多输出时用export, 不要export 和export default混合使用&#xA;&#xA;o-&amp;gt; 运算符&#xA;var t = o &amp;amp;&amp;amp; o.a || &#39;&#39;                          # 有o时取o.a, 无o时取&#39;&#39;, 因为&amp;amp;&amp;amp;的优先级比||高&#xA;var ifExist = !!o.a                             # 转换成布尔类型, 当然o.a = 0 什么的值时， 会判断失误，所以用来判断对象&#xA;&#xA;o-&amp;gt; 判断类型&#xA;typeof a === &amp;quot;string&amp;quot;                           # 数组等其他Object类型通通是Object&#xA;a instanceof Array                              # 判断Object类型的具体类型&#xA;a.constructor == Array                          # 判断构造函数&#xA;Object.prototype.toString.call(o) === &#39;[object Array]&#39;              # 用toString判断&#xA;&#xA;o-&amp;gt; 柯里化&#xA;function currying (fn, n) {&#xA;    return function (m) {&#xA;        return fn.call(this, m, n);&#xA;    }&#xA;}&#xA;function tailFactorial(n, total) {              # 尾递归调用优化&#xA;    if(n === 1) return total;&#xA;    return tailFactorial (n - 1, n * total);&#xA;}&#xA;const factorial = currying(tailFactorial, 1);&#xA;factorial(5)&#xA;&#xA;o-&amp;gt; 尾递归&#xA;function factorial (n, total = 1) {&#xA;    if(n === 1) return total;&#xA;    return factorial(n - 1, n * total);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;浏览器&#34;&gt;&#xA;  浏览器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8f%e8%a7%88%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;js执行顺序&#xA;    当页面载入时，会执行位于 body 部分的 JavaScript。&#xA;    当被调用时，位于 head 部分的 JavaScript 才会被执行。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;常用函数&#34;&gt;&#xA;  常用函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础扩展&#34;&gt;&#xA;  基础扩展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e6%89%a9%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;循环变量作用域&#xA;    function constfunc(v){&#xA;        return function(){return v}&#xA;    }&#xA;    var funcs = []&#xA;    for(var i = 0; i &amp;lt; 10; i++){&#xA;        funcs[i] = constfunc(i)&#xA;    }&#xA;闭包序列&#xA;    var uniqueInteger = (function(){&#xA;        var counter = 0;&#xA;        return function(){return counter++;}&#xA;    }());&#xA;    seq  = uniqueInteger()&#xA;    id = seq()&#xA;闭包计数器&#xA;    function counter(){&#xA;        var n = 0;&#xA;        return {&#xA;            count: function(){return n++;},&#xA;            reset: function(){n = 0;}&#xA;        };&#xA;    }&#xA;属性存取器&#xA;    function counter(n){&#xA;        return{&#xA;            get count() {return n++},&#xA;            set count(m){&#xA;                if(m &amp;gt;= n) {n = m }&#xA;                else {throw Error(&amp;quot;count can only be et to a larger value&amp;quot;)}&#xA;            }&#xA;        }&#xA;    }&#xA;    var c = counter(1000);&#xA;    c.count;&#xA;属性define&#xA;    Object.defineProperty(Object.prototype, &amp;quot;extend&amp;quot;, {&#xA;        writable: true,&#xA;        enumerable: false,&#xA;        configurable: true,&#xA;        value: function(o){&#xA;            var names = Object.getOwnPropertyNames(o);&#xA;            for(var i = 0; i &amp;lt; names.length; i++){&#xA;                if(names[i] in this) continue;&#xA;                var desc = Object.getOwnPropertyDescriptor(o, names[i]);&#xA;                Object.defineProperty(this, names[i], desc);&#xA;            }&#xA;        }&#xA;    });&#xA;私有属性&#xA;    function addPrivateProperty(o, name, predicate){&#xA;        var value;&#xA;        o[&amp;quot;get&amp;quot; + name] = function(){return value;}&#xA;        o[&amp;quot;set&amp;quot; + name] = function(v){&#xA;            if(predicate &amp;amp;&amp;amp; ! predicate(v)) {throw Error(&amp;quot;set&amp;quot; + name + &amp;quot;: invalid value &amp;quot; + v)}&#xA;            else {value = v}&#xA;        };&#xA;    }&#xA;    var o = {}&#xA;    addPrivateProperty(o, &amp;quot;Name&amp;quot;, function(x){ return typeof x == &amp;quot;string&amp;quot;;});&#xA;    o.setName(&amp;quot;A&amp;quot;);&#xA;    o.setName(o);&#xA;嵌套属性名&#xA;    function getAllPropertyNames = function(obj){&#xA;        var props = [];&#xA;        do {&#xA;            props = props.concat(Object.getOwnPropertyNames(obj));&#xA;        } while (obj = Object.getPrototypeOf(obj));&#xA;        return props;&#xA;    }&#xA;嵌套属性名2&#xA;    function keys(o){&#xA;        if(typeof o !== &amp;quot;object&amp;quot;) throw TypeError();&#xA;        var result = [];&#xA;        for(var prop in o){&#xA;            if(o.hasOwnProperty(prop))&#xA;            result.push(prop);&#xA;        }&#xA;        return result;&#xA;    }&#xA;嵌套累加&#xA;    function flexisum(a){&#xA;        var total = 0;&#xA;        for(var i = 0; i &amp;lt; arguments.length; i++) {&#xA;            var element = arguments[i], n;&#xA;            if(element == null){&#xA;                continue;&#xA;            } else if(isArray(element)){&#xA;                n = flexisum.apply(this, element);&#xA;            } else if(typeof element === &amp;quot;function&amp;quot;){&#xA;                n = Number(element());&#xA;            } else{&#xA;                n = Number(element);&#xA;            }&#xA;            if(isNaN(n)){&#xA;                throw Error(&amp;quot;flexisum(): can&#39;t convert &amp;quot; + element + &amp;quot; to number&amp;quot;);&#xA;            }&#xA;            total +=n;&#xA;        }&#xA;        return total;&#xA;    }&#xA;泛函代理, monkey-patching &#39;this&#39;&#xA;    function trace(o, m){&#xA;        var original = o[m];&#xA;        o[m] = function(){&#xA;            return original.apply(this, arguments);&#xA;        }&#xA;    }&#xA;兼容ECMAScript 3实现bind&#xA;    function bind(f, o){&#xA;        if(f.bind) {return f.bind(o)}&#xA;        else {&#xA;            return function(){&#xA;                return f.apply(o, arguments);&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数式&#34;&gt;&#xA;  函数式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;thunk&#xA;    function thunk (fileName) {&#xA;        return function (callback) {&#xA;            return fs.readFile(fileName, callback)&#xA;        }&#xA;    }&#xA;extend, 同名覆盖&#xA;    function extend(o, p){&#xA;        for(prop in p){&#xA;            o[prop] = p[prop];&#xA;        }&#xA;        return o&#xA;    }&#xA;merge, 同名不覆盖&#xA;    function merge(o, p){&#xA;        for(prop in p){&#xA;            if(o.hasOwnProperty[prop]) {continue}&#xA;            o[prop] = p[prop];s&#xA;        }&#xA;        return o;&#xA;    }&#xA;restrict, 删除非公共属性&#xA;    function restrict(o, p){&#xA;        for(prop in o){&#xA;            if(!(prop in p)) delete o[prop];&#xA;        }&#xA;        return o;&#xA;    }&#xA;substract, 删除公共属性&#xA;    function subtract(o, p){&#xA;        for(prop in p){&#xA;            delete o[prop];&#xA;        }&#xA;        return o;&#xA;    }&#xA;union, extend产生新对象&#xA;    function union(o, p) { return extend(extend({}, o), p);}&#xA;intersection, restrict产生新对象&#xA;    function intersection(o, p){ return restrict(extend({}, o), p);}&#xA;mixin&#xA;    function mix (...mixins) {&#xA;        class Mix {}&#xA;        for (let mixin of mixins) {&#xA;            copyProperties(Mix, mixin);&#xA;            copyProperties(Mix.prototype, mixin.prototype);&#xA;        }&#xA;        return Mix;&#xA;    }&#xA;    function copyProperties(target, source) {&#xA;        for(let key of Reflect.ownKeys(source)) {&#xA;            if(key !== &#39;constructor&#39;&#xA;                &amp;amp;&amp;amp; key !== &#39;prototype&#39;&#xA;                &amp;amp;&amp;amp; key !== &#39;name&#39;) {&#xA;                let desc = Object.getOwnPropertyDescriptor(source, key);&#xA;                Object.defineProperty(target, key, desc);&#xA;            }&#xA;        }&#xA;    }&#xA;混合继承&#xA;    class A extends mix(B, C) {}&#xA;mixins方法不被覆盖&#xA;    let Mixin1 = (superclass) =&amp;gt; class extends superclass {&#xA;        foo () {if(super.foo) super.foo()}&#xA;    }&#xA;    let Mixin2 = (superclass) =&amp;gt; class extends superclass {&#xA;        foo () {if(super.foo) super.foo()}&#xA;    }&#xA;    class S {&#xA;        foo() {}&#xA;    }&#xA;    class C extends Mixin1(Mixin2(s)) {&#xA;        foo() {super.foo()}&#xA;    }&#xA;    new c().foo()        // C, Mixin1, Mixin2, S&#xA;trait&#xA;    # 同mixins 额外功能: 防止同名方法冲突, 排除混入某些方法，为混入方法起别名等&#xA;    @traits(A, B)&#xA;    class C()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;generator-1&#34;&gt;&#xA;  generator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#generator-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;状态机 generator clock&#xA;    var clock = function* (_) {&#xA;        while(true) {&#xA;            yield _;&#xA;            console.log(&#39;Tick&#39;);&#xA;            yield _;&#xA;            console.log(&#39;Tock&#39;);&#xA;        }&#xA;    }&#xA;    非generator实现&#xA;        var ticking = true;&#xA;        var clock = function() {&#xA;            if (ticking) {console.log(&#39;Tick&#39;);}&#xA;            else {console.log(&#39;Tock&#39;);}&#xA;            ticking = !ticking&#xA;        }&#xA;递归next&#xA;    function run(fn) {&#xA;        var gen = fn();&#xA;        function next (err, data) {&#xA;            var result = gen.next(data);&#xA;            if (result.done) {return result.value;}&#xA;            result.value(next);&#xA;        }&#xA;        next();&#xA;    }&#xA;    run(gen);&#xA;generator, promise, 递归next2&#xA;    var readFile = function(fileName) {&#xA;        return new Promise(function (resolve, reject) {&#xA;            fs.readFile(fileName, function(err, data) {&#xA;                if(err) {reject(err);}&#xA;                resolve(data);&#xA;            })&#xA;        })&#xA;    }&#xA;    var gen = function* () {&#xA;        var f1 = yield readFile(&#39;/etc/fstab&#39;);&#xA;    }&#xA;    function run(gen) {&#xA;        var g = gen();&#xA;        function next(data) {&#xA;            var result = g.next(data);&#xA;            if (result.done) {return result.value;}&#xA;            result.value.then(function(data) {&#xA;                next(data);&#xA;            })&#xA;        }&#xA;        next()&#xA;    }&#xA;    run(gen);&#xA;co, thunkify&#xA;    var readFile = thunkify(fs.readFile);&#xA;    var gen = function* () {&#xA;        var r1 = yield readFile(&#39;/etc/fstab&#39;);&#xA;        var r2 = yiled readFile(&#39;/etc/shells&#39;)&#xA;    }&#xA;    co(gen)&#xA;mixins注解&#xA;    function mixins (...list) {&#xA;        return function (target) {&#xA;            Object.assign(target.prototype, ...list)&#xA;        }&#xA;    }&#xA;    const Foo = {&#xA;        foo() {}&#xA;    }&#xA;    @mixins(Foo)&#xA;    class MyClass()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;全局&#34;&gt;&#xA;  全局&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a8%e5%b1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    Infinity                                # 表示正无穷大&#xA;    NaN                                     # 指示是不是数字, Infinity与NaNECMAScript中可读写， ECMAScript修正为只读, Infinity与NaN与任何值不相等(包括自身), 建议用非来判断&#xA;    undefined&#xA;    console&#xA;        log(&#39;abc %s&#39;, &#39;d&#39;)                  # &#39;abc d&#39;, 格式化输出&#xA;&#xA;方法&#xA;    parseFloat                              # 可以解析整数和浮点数, 跳过前导空格, 忽略后面非数字内容。第一个非空格字符是非法数字直接量时，返回NaN&#xA;    parseInt                                # 只解析整数, 可接收第二个可选参数，指定数字转换基数&#xA;        &amp;quot;0x&amp;quot;, &amp;quot;0X&amp;quot;前缀, 解析为16进制数&#xA;    isNaN&#xA;    isFinite                                # NaN, Infinity 不通过, 非数字报错&#xA;    escape                                  # deprecated since ECMAScript v3&#xA;    decodeURI                               # 不处理 =, &amp;amp; 等&#xA;    decodeURIComponent                      # 会处理 =, &amp;amp; 等&#xA;    encodeURI&#xA;    encodeURIComponent&#xA;    eval                                    # 可以访问调用时的整个作用域，所以编译器不能裁剪作用域, 要间接调用, 如 (0, eval)(src)&#xA;    requestAnimationFrame&#xA;    fetch&#xA;        fetch(url).then(function (request) { return request.arrayBuffer })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;构造函数&#34;&gt;&#xA;  构造函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;包装对象函数&#34;&gt;&#xA;  包装对象函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8c%85%e8%a3%85%e5%af%b9%e8%b1%a1%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基本类型(数字，布尔，字符串)在构建时，会通过new String(s)的方式转换成对象，有了对象的方法，这个过程就是包装对象&#xA;undefined没有包装对象，所以访问属性会造成类型错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    是Object类型, 是基本类型string的包装类型&#xA;        引用字符串类型的属性时,js会调用new String(s)来转换成对象&#xA;            属性引用结束, 该新对象销毁&#xA;            实际上有优化&#xA;包装测试&#xA;    自动包装测试&#xA;        1.toString                          # 异常&#xA;        (1).toString                        # =&amp;gt; &amp;quot;1&amp;quot;&#xA;    原始类型属性只读&#xA;        var s = &amp;quot;test&amp;quot;;&#xA;        s.len = 4;                          # 相当于new String(&amp;quot;test&amp;quot;).len = 4&#xA;        s.len   // undefined                # 相当于new String(&amp;quot;test&amp;quot;).len&#xA;    运算&#xA;        ==                                  # 原始类型与包装类型相等&#xA;        ===                                 # 原始类型与包装类型不相等&#xA;语法&#xA;    ECMAScript 5中，可以用数组方式访问16位值, 如&#xA;        s[0]&#xA;属性&#xA;    length                                  # 4字节的字符会误判为2&#xA;&#xA;静态方法&#xA;    localCompare()                          # 参照本地语言字母表字符次序&#xA;    fromCodePoint()                         # 支持4字节字符值转换, 多参数时合并成字符串&#xA;    raw                                     # 一个tag函数, 转义模板字符串到字符串&#xA;        String.raw`\n${2 + 3}`              # &#39;\\n5&#39;&#xA;        String.raw({raw: &#39;test&#39;}, 0, 1, 2)  # 正常调用时, 第一个参数对象中必要有raw属性，其值为tag函数的第一个字符串数组的参数。其余参数与tag函数其余参数对应&#xA;                &#xA;方法&#xA;    substring(1, 4) // =&amp;gt; 返回第2~4个字符     # 与java不同，java是第1~3个&#xA;    slice(1, 4)&#xA;    indexOf(&amp;quot;&amp;quot;)&#xA;    lastIndexOf(&amp;quot;&amp;quot;)&#xA;    toUpperCase()&#xA;    charAt(0)                               # 取2个字节的字符&#xA;    charCodeAt()                            # 取2个字节字符的十进制值&#xA;    codePointAt()                           # index位的4字节字符当作一个字符，正确处理，得到十进制值, index+1位会取该4字节字符的后2字节, 为了匹配length属性&#xA;    at()                                    # 支持4字节字符, 匹配正确长度的方法&#xA;    fromCharCode()                          # 2字节字符值转换到字符&#xA;    normalize()&#xA;        &#39;\u01D1&#39;.normalize() === &#39;\u004F\u030C&#39;.normalize()&#xA;            原重音符号与 (字符 + 重音)合成符等价&#xA;        不支持3个及以上字符合成&#xA;    includes                                # s.includes(&#39;o&#39;, 6) 从6位置开始搜索o是否出现&#xA;    startsWith&#xA;    endsWith                                # s.endsWith(&#39;o&#39;, 6) 前6个字符是否以o结尾&#xA;    repeat(3)                               # 字符串重复3次返回&#xA;    padStart                                # &#39;x&#39;.padStart(5, &#39;ab&#39;) 返回 &#39;ababx&#39;, padStart(5)会填充空格&#xA;    padEnd&#xA;    正则                                    # es6中内部调用RegExp.prototype[Symbol.match]等方法&#xA;        search(pattern)                     # 返回首次匹配成功的位置&#xA;        match(pattern)                      # 所有匹配位置的数组&#xA;        replace(pattern, &amp;quot;&amp;quot;)                # 所有匹配替换&#xA;        split(pattern)                      # 匹配分割&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;number&#34;&gt;&#xA;  Number&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#number&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    NaN&#xA;    POSITIVE_INFINITY&#xA;    NEGATIVE_INFINITY&#xA;    MAX_VALUE&#xA;    MIN_VALUE&#xA;    EPSILON                                 # 极小的常量 2.22....e-16, 用来设置浮点计算的一个合理误差范围&#xA;    MAX_SAFE_INTEGER                        # 越界最大值&#xA;    MIN_SAFE_INTEGER                        # 越界最小值&#xA;静态方法&#xA;    isFinite&#xA;    isNaN&#xA;    isInteger&#xA;    isSafeInteger                           # 判断是否越界&#xA;    parseInt&#xA;    parseFloat&#xA;        &#xA;方法&#xA;    字符串解析&#xA;        构造方法                            # 只基于十进制转换&#xA;        调用全局函数parseInt(), parseFloat()&#xA;    转换为字符串&#xA;        toString()                          # Number类的toString()可接收转换基数, 来转换进制&#xA;            如 n.toString(2); n.toStrng(8); n.toString(16)&#xA;        toFixed(0)                          # 保留几位小数, 从不使用指数计数法&#xA;        toExponential(1)                    # 转换为指数, 参数为指数前保留几位小数&#xA;        toPrecision(4)                      # 保留有效数字，多出位数转换成指数, 以上三个方法自动补0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;boolean&#34;&gt;&#xA;  Boolean&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#boolean&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;object&#34;&gt;&#xA;  Object&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#object&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    __proto__&#xA;        用来读取或设置当前对象的prototype对象，只有浏览器必须部署这个属性&#xA;        语义上是内部属性，被支持仅因为被广泛使用&#xA;动态方法&#xA;    hasOwnProperty&#xA;         是否有某属性，可判断属性值为undefined的情况&#xA;         没prototype的对象, 该方法直接调用失败，需要Object.prototype.hasOwnProperty.call来调用&#xA;    propertyIsEnumerable&#xA;    isPrototypeOf&#xA;        b.isPrototypeOf(c)                  # b是否出现在c的prototype链中&#xA;    toString&#xA;    toLocaleString&#xA;        返回对象的本地化字符，默认时仅调用toString方法&#xA;        Date和Number对toLocaleString做了定制&#xA;        Array的toLocalString对每个数组元素调用toLocaleString方法&#xA;            toString会对每个数组元素调用toString方法&#xA;    *toJSON&#xA;        Object.prototype没有定义这个方法, JSON.stringigy会调用要序列化对象的toJSON方法,如Date.toJSON()&#xA;    valueOf&#xA;        要将对象转换为原始值时调用&#xA;        如果需要使用原始值的上下文中使用了对象，会自动调用这个方法&#xA;静态方法&#xA;    create                                  # new会执行构造方法，有副作用&#xA;        Object.create(null)                 # 创建的对象没有prototype，不同于{}&#xA;    getPrototypeOf                          # 用于判断继承&#xA;            Object.getPrototypeOf(B) === A&#xA;    getOwnPropertyNames                     # 所有自身属性&#xA;    getOwnPropertyDescriptor(obj, &#39;foo&#39;)    # 获得属性的描述对象&#xA;    getEnumPropertyNames                    # 可枚举自身属性和继承属性&#xA;    setPrototypeOf                          # 标准可靠的方法修改对象prototype的关联&#xA;            Object.setPrototypeOf(Bar.prototype, Foo.prototype)     # 同Bar.prototype = Object.create(Foo.prototype)&#xA;    keys                                    # 可枚举自身属性&#xA;    defineProperty                          # 数据描述符，getter、setter是访问描述符&#xA;        # 修改属性，在原型链上层属性为writable: false或有对应属性的setter时，不会发生屏蔽。使用defineProperty可发生屏蔽&#xA;        Object.defineProperty(Object, &#39;is&#39;, {&#xA;                value: function (x, y) {...},&#xA;                configurable: true,         # false时，delete该属性会静默失败&#xA;                enumerable: false,&#xA;                writable: true,&#xA;                get: function(){return 1}&#xA;        })&#xA;    toLocaleString&#xA;    toString                                # toString(16) 转换为16进制&#xA;    is(&#39;foo&#39;, &#39;foo&#39;)                        # 比较两个值是否相等, 基本是===，不同在于, +0 等于 -0, NaN 等于 NaN&#xA;    assign(target, source1, source2)&#xA;        复制源对象自身可枚举属性到目标对象, source2覆盖source2覆盖target&#xA;        Symbol值的属性也会被拷贝&#xA;        _.defaultsDeep方法可以深拷贝&#xA;        常用于给对象添加静态方法或方法，合并对象，为属性指定默认值&#xA;            Object.assign({}, DEFAULTS, options);&#xA;    preventExtensions                       # 使对象不可设置属性&#xA;    isExtensible&#xA;    seal                                    # 创建“密封”对象, 在现有对象上调用preventExtensions并把现在属性标记为configurable: false&#xA;    freeze                                  # 调用seal并标记现有属性为writable: false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;array&#34;&gt;&#xA;  Array&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#array&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;静态方法&#xA;    isArray(a)                              # ECMAScript 5 判断是否数组&#xA;            [] instanceof Array的问题&#xA;                多frame中有多个js环境, 都有自己的全局对象与构造函数。一个窗体中的对象是当前窗体构造函数创建，而另外窗体构造函数判断该对象则不成立。&#xA;                    # 但窗体间的混淆不常发生&#xA;            ECMAScript 3 可以检查对象类属性来判断。&#xA;                # 实际上就是ECMAScript 5中Array.isArray的代码&#xA;                var isArray = Array.isArray || function(o){&#xA;                    return typeof o === &amp;quot;ojbect&amp;quot; &amp;amp;&amp;amp; Object.prototype.toString.call(o) == &amp;quot;[object Array]&amp;quot;&#xA;                };&#xA;    from&#xA;        # 类数组对象或可遍历对象(如Set, Map)转为数组，转换后的数组具有了iterator接口&#xA;        # 类数组对象同[].slice.call(arraylike), 可遍历对象同[...traversable]&#xA;        Array.from(arraylike)&#xA;        Array.from([1, , 2, , 3], (n) =&amp;gt; n || 0)&#xA;        Array.from(&#39;abc&#39;)&#xA;            # 字符串转数组&#xA;        Array.from(new Set(array))&#xA;            # 去除重复元素&#xA;    of&#xA;        # 一组值转换为数组, 用于替代Array(), new Array()&#xA;        # 弥补Array()的返回不一致问题, 如Array(3) // [, , ,]&#xA;        Array.of(1, 2, 3)        // [1, 2, 3]&#xA;动态方法&#xA;    join, ...                               # firefox1.5 后 动态方法也写入到了静态方法中。但不是标准, 是String.split()的逆向操作&#xA;        a.join()                                // =&amp;gt; &amp;quot;1,2,3&amp;quot;&#xA;        a.join(&amp;quot;&amp;quot;)                        // =&amp;gt; &amp;quot;123&amp;quot;&#xA;        new Array(2).join(&#39;-&#39;)                // =&amp;gt; &amp;quot;--&amp;quot;&#xA;    reverse                                 # 倒序&#xA;        a.reverse()&#xA;    sort                                    # 排序&#xA;        a.sort()                            # 默认以字母表排序, 自动转字符串 undefined排到最后&#xA;        a.sort(function(a, b){&#xA;            return a-b;                     # a在前, 返回负数。b在前返回正数。0表示相等，顺序无关紧要, 此处是升序排列&#xA;        })&#xA;    concat                                  # 连接数组, 创建返回一个新数组, 传入数组, 连接数组元素而非本身, 但不扁平化数组的数组&#xA;        a.concat(4, [5, [6, 7]])&#xA;    slice                                   # 截取新数组&#xA;        var a = [1,2,3,4,5]&#xA;        a.slice(0,3)    // 返回 [1,2,3]&#xA;        a.slice(3)      // 返回 [4,5]&#xA;        a.slice(1, -1)  // 返回 [2,3,4]&#xA;        a.slice(-3, -2) // 返回 [3]&#xA;    splice                                  # 修改数组&#xA;        第一个参数起始位置(包含), 第二个参数删除个数(省略则从起始到结束都删除)&#xA;        后面任意个参数指定插入到数组中的元素&#xA;        返回由删除元素组成的数组&#xA;    push 和 pop                              # 数组作为栈(先进后出)来用, push在结尾添加, pop在结尾删除, 插入元素时不解封数组&#xA;    unshift 和 shift                         # unshift在头部添加元素, shift在头部删除。都改变索引, 插入元素时不解封数组&#xA;    toString                                # 调用每个元素的toString()方法, 输出有逗号分隔的字符串列表(没有方括号), 与不使用任何参数的join()是一样的&#xA;    toLocaleString                          # 调用元素的toLocaleString&#xA;    copyWithin                              # 当前数组中复制一段到另一位置&#xA;        [1, 2, 3, 4, 5].copyWithin(0, 3)        // [4, 5, 3, 4, 5]&#xA;            # 第三个参数是结束位置(不包含), 默认是结尾。把4, 5 复制替换到1, 2&#xA;        [1, 2, 3, 4, 5].copyWithin(0, -2, -1)        // [4, 2, 3, 4, 5]&#xA;            # 4到5(不包含)复制到1&#xA;    find                                    # 返回第一个符合条件的元素, 没有时返回undefined, 可处理NaN, 第二个参数绑定回调函数的this对象&#xA;        [1, 4, -5, 10].find((n) =&amp;gt; n &amp;lt; 0)&#xA;    findIndex                               # 返回第一个符合条件的index, 没有时返回-1&#xA;    fill                                    # 用某元素填充数组, 可标识起始位置&#xA;        [1, 2, 3].fill(0)        // [0, 0, 0]&#xA;        [1, 2, 3].fill(0, 1, 2)        // [1, 0, 3]&#xA;    includes                                # 是否包含元素，可识别NaN, 返回布尔值, 第二个参数表示起始位置, indexOf 使用===判断, 会对NaN误判&#xA;            [1, 2, 3].includes(2, 0)&#xA;&#xA;    遍历类方法&#xA;        对稀疏数组，不存在的元素不调用传递的回调函数&#xA;        方法第一个参数是回调函数, 第二个参数是回调函数的this&#xA;        多数情况下, 传入的回调函数传递三个参数: 数组元素, 元素的索引, 数组本身&#xA;        forEach                             # 没有break语句，用抛出异常替代&#xA;            a.forEach(function(value){})&#xA;                function foreach(a, f, t){&#xA;                try{a.forEach(f, t);}&#xA;                catch(e){&#xA;                    if(e === foreach.break) return;&#xA;                    else throw e;&#xA;                }&#xA;            }&#xA;            foreach.break = new Error(&amp;quot;StopIteration&amp;quot;);&#xA;        map                                 # 映射数组元素, 稀疏数组也返回相同的缺失元素&#xA;            [1,2,3].map(function(x){return x * x})  // 返回 [1, 4, 9]&#xA;        filter                              #  回调返回true的元素保留，返回新数组, 返回的数组总是稠密的，可用于压缩空缺并删除undefined 和 null元素&#xA;            [5, 4, 3, 2, 1].filter(function(x){ return x &amp;lt; 3}) // 返回 [2, 1]&#xA;        every和some&#xA;            every表示所有, 在都返回true时返回true&#xA;            some表示存在, 都返回false时返回false&#xA;                在确定返回值时停止遍历&#xA;            a.some(func)&#xA;        reduce和reduceRight                  # 使用指定函数将数组元素进行组合，称为&amp;quot;注入&amp;quot;和&amp;quot;折叠&amp;quot;&#xA;            a.reduce(function(x, y){ return x + y}, 0)&#xA;                第一个是回调函数。第二个可选，是初始值，无初始值时一开始直接传入第一第二个元素&#xA;                    回调函数中第一个是累积的结果, 第二个是当前元素&#xA;                空数组无初始值调用会导致类型错误异常。&#xA;                只有一个值并没有初始值时, reduce只简单抬这个值&#xA;            reduceRight同reduce，但索引从高到低处理数组&#xA;        indexOf和lastIndexOf&#xA;            搜索数组元素, 返回第一个匹配元素的索引, 失败则返回 -1&#xA;                indexOf从前往后, lastIndexOf从后往前&#xA;            第二个参数可选，指定起始索引。负索引代表相对末尾的偏移量&#xA;            字符串也有indexOf和lastIndexOf, 针对每个字符&#xA;    返回遍历器&#xA;            entries&#xA;                for(let [ind, ele] of [&#39;a&#39;, &#39;b&#39;].entries()) {}&#xA;                    # 得到 0 &#39;a&#39;, 1 &#39;b&#39;&#xA;                    # 不用for of , entriesIterator.next().value        // [0, &#39;a&#39;]&#xA;            keys&#xA;            values&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;function&#34;&gt;&#xA;  Function&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#function&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    var f = new Function(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;return x*y;&amp;quot;);&#xA;        # 任意数量实参。最后一个实参是函数体，语句间用分号隔开&#xA;        # 创建一个匿名函数&#xA;特点&#xA;    允许js在运行时动态创建并编译函数&#xA;    每次调用，都解析函数体并创建新函数对象，效率低&#xA;        # 循环中嵌套函数和函数定义表达式不会每次都重新编译&#xA;    总在全局作用域创建，可以认为其构造函数是全局作用域中执行eval()&#xA;函数体代码内&#xA;    arguments&#xA;        callee&#xA;        caller                              # 调用栈的上层函数, 出于安全考虑，大部分编译器已不支持caller, 用非标准的 fn.caller来取代, fn为当前函数名&#xA;属性&#xA;    length&#xA;        只读属性，代表函数形参数量。不包含设置了默认值的形参，也不包含...rest参数&#xA;        arguments.length是实际实参个数, arguments.callee.length是期望实参个数, 同本length&#xA;    name&#xA;        函数名, es5中只支持具名函数如function a(){}, es6支持var a = function(){}&#xA;        (new Function).name        // &#39;anonymous&#39;&#xA;        foo.bind({}).name        // &#39;bound foo&#39;&#xA;    prototype                               # 指向原型对象(prototype object)，从该函数创建对象时，从原型对象上继承属性&#xA;&#xA;方法&#xA;    call(o, 1, 2)                           # 传入可变调用时参数&#xA;    apply(o, [1, 2])                        # 传入调用时参数数组或类数组对象, 这样可以将arguments数组直接传入另一个函数来调用&#xA;        ECMAScript 严格模式中，o传入什么,this就是什么。其它情况下，o为null或undefined时替换为顶级对象，原始值会被包装。&#xA;    bind(o, ...)&#xA;        ECMAScript 5新增方法。在函数a上调用bind, 传入对象o，反回以o调用a的新函数b&#xA;            bind返回的是一个闭包, 返回的函数不包含prototype属性&#xA;            普通函数固有的prototype属性是不能删除的&#xA;            除第一个实参外，其它实参按顺序绑定到调用bind函数f的实参上，称为柯里化(currying), 如&#xA;            f = function(x, y); ff = f.bind(o, 1); ff(2);        // 此时x绑定为1, y传入为2&#xA;            ECMAScript 5中的bind, 返回的函数对象的length属性，值是返回函数的形参个数减其实参个数&#xA;            返回的函数可以用作构造函数，此时以原始函数的形式调用作为构造函数(实参也会原封不动地传入)&#xA;                用作构造函数时, 使用原始函数的prototype&#xA;    toString()&#xA;        ECMAScript规定返回和函数声明语法相关的字符串&#xA;        大多数toString()方法返回函数的完整源码，内置函数往往返回类似&amp;quot;[native code]&amp;quot;的字符串作函数体&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;date&#34;&gt;&#xA;  Date&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#date&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;var now = new Date()&#xA;var then = new Date(2011, 0, 1)&#xA;var later = new Date(2011, 0, 1, 17, 10, 30)&#xA;var elapsed = now - then;&#xA;&#xA;now.setMonth(now.getMonth - 1);&#xA;方法&#xA;    getFullYear()&#xA;    getMonth()&#xA;    getDate()&#xA;    getDay()&#xA;    getHours()&#xA;    getUTCHours()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;error&#34;&gt;&#xA;  Error&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#error&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;regexp&#34;&gt;&#xA;  RegExp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#regexp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new RegExp(&#39;xyz&#39;, &#39;i&#39;); // /xyz/i&#xA;    new RegExp(/abc/ig, &#39;i&#39;) // /abc/i&#xA;修饰符&#xA;    i&#xA;    g                                       # 全局多次匹配, 下次匹配从剩余中重新开始&#xA;    u                                       # 正确处理4字节字符, 存在u修饰符时, /\u{61}/可以表示unicode字符, 否则会匹配61个连续的u&#xA;    y                                       # 粘连，基本同g，不同在于剩余第一个字符开始必须匹配上, 确保匹配之间不会有漏掉的字符&#xA;        var s = &#39;aaa_aa_a&#39;, r1 = /a+/g, r2 = /a+/y;&#xA;        r1.exec(s), r2.exec(s)              # [&#39;aaa&#39;] [&#39;aaa&#39;]&#xA;        r1.exec(s), r2.exec(s)              # [&#39;aa&#39;] null&#xA;属性&#xA;    flags                                   # 修饰符&#xA;    lastIndex                               # 从这个index开始匹配&#xA;    sticky                                  # 是否设置了y字符&#xA;静态方法&#xA;        &#xA;方法&#xA;    test&#xA;        /\d+/g.test(&amp;quot;testing: 1, 2, 3&amp;quot;)&#xA;    exec                                    # 返回带有特殊属性的Array match&#xA;        match&#xA;            属性&#xA;                index&#xA;                    # 在index上匹配成功&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;set&#34;&gt;&#xA;  Set&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#set&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new Set()&#xA;    new Set([1, 2, 3])&#xA;属性&#xA;    size                                    # Set实例成员数&#xA;方法&#xA;    add(x)&#xA;    delete(x)&#xA;    has(x)                                  # 是否有x&#xA;    clear()                                 # 清除所有成员&#xA;    keys()&#xA;    values()                                # values同keys完全一致, 返回遍历器&#xA;    entries()                               # 返回[key, key]的遍历器&#xA;    forEach(function (value, key, obj) {}, boundThis)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;weakset&#34;&gt;&#xA;  WeakSet&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#weakset&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new WeakSet()&#xA;    new WeakSet([1, 2, 3])                  # 任何可遍历对象&#xA;属性                                         # 没有size&#xA;方法&#xA;    add(x)&#xA;    delete(x)&#xA;    has(x)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;map&#34;&gt;&#xA;  Map&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#map&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new Map()&#xA;    new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2]])&#xA;属性&#xA;    size&#xA;方法&#xA;    set(key, value)&#xA;    get(key)&#xA;    delete(key)&#xA;    has(key)&#xA;    clear()&#xA;    keys()&#xA;    values()&#xA;    entries()                               # map[Symbol.iterator] === map.entries&#xA;    forEach(function(value, key, map) {}, boundThis)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;weakmap&#34;&gt;&#xA;  WeakMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#weakmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    get&#xA;    set&#xA;    delete&#xA;    has&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;proxy-1&#34;&gt;&#xA;  Proxy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#proxy-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;new Proxy(target, handlers)                 # target表示要拦截的对象, handler是回调方法&#xA;拦截器&#xA;    get(target, propKey, receiver)          # 属性读取。propKey是属性名, receiver是继承该proxy的对象&#xA;    set(target, propKey, value, receiver)   # 属性设置&#xA;    has(target, propKey)                    # in操作，返回布尔值&#xA;    deleteProperty(target, propKey)         # delete操作，返回布尔值&#xA;    enumerate(target)                       # for in , 返回遍历器&#xA;    ownKeys(target)                         # Object.getOwnPropertyNames, Object.getOwnPropertySymbols, Object.keys, 返回数组&#xA;    getOwnPropertyDescriptor(target, propKey)                       # Object.getOwnPropertyDescriptor, 返回描述对象&#xA;    defineProperty(target, propKey, propDesc)                       # Object.defineProperty, Object.defineProperties, 返回布尔值&#xA;    preventExtensions(target)               # Object.preventExtensions, 返回布尔值&#xA;    getPrototypeOf(target)                  # Object.getPrototypeOf, 返回对象&#xA;    isExtensible(target)                    # Object.isExtensible, 返回布尔值&#xA;    setPrototypeOf(target, proto)           # Object.setPrototypeOf, 返回布尔值&#xA;    apply(target, object, args)             # 拦截proxy作为函数调用的操作, 如proxy(), proxy.call, proxy.apply&#xA;    construct(target, args, proxy)          # 拦截proxy作用构造函数的操作, 如new proxy&#xA;静态方法&#xA;    revocable(target, handler)              # 返回有proxy, revoke属性的对象实例, proxy是Proxy实例, 调用revoke()函数可以取消Proxy&#xA;        et {proxy, revoke} = Proxy.revocable({}, {})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;arraybuffer&#34;&gt;&#xA;  ArrayBuffer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#arraybuffer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var buf = new ArrayBuffer(32)           # 生成32字节的内存区域，每个字节默认值为0&#xA;    if(buf.byteLength === 32)               # 由于内存可能不够大，要检查是否分配成功&#xA;属性&#xA;    byteLength                              # 内存区字节长度&#xA;方法&#xA;    slice(0, 3)                             # 拷贝前3个字节，生成新的ArrayBuffer&#xA;    isView(v)                               # 检查某视图是否为该buf的视图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;typedarray&#34;&gt;&#xA;  (TypedArray)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#typedarray&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;9种类型数组&#xA;    Int8Array&#xA;    Uint8Array&#xA;    Uint8ClampedArray                       # 自动过滤溢出。用于处理图像颜色, 只取值0 - 255, 过滤掉高位, ie10不支持该类型&#xA;    Int16Array&#xA;    Uint16Array&#xA;    int32Array&#xA;    Uint32Array&#xA;    Float32Array&#xA;    Float64Array&#xA;构造&#xA;    var x1 = new Int32Array(buf)&#xA;        带符号整形方式读buf&#xA;        new Int32Array(buf, 2, 2) 开始于字节2, 长度为2(2 * 32bit)。第3个参数不填则到末尾&#xA;            开始字节数要符合视图类型, 如16位类型视图单位是2个字节, 不能从1字节开始, 否则将报错&#xA;            用于构建复合视图&#xA;    x1[0] = 1;                              # 第0位4个字节赋值&#xA;    var x2 = new Uint8Array([0, 1, 2])      # 数组会直接分配内存生成ArrayBuffer&#xA;    new Float64Array(8)                     # 直接分配8字节生成ArrayBuffer来创建视图&#xA;    new Int8Array(new Uint8Array(4))        # 会开辟新的ArrayBuffer，复制原有数据来建立视图&#xA;        new Int8Array(new Uint8Array(4).buffer)可以用同一个buffer&#xA;属性&#xA;    length&#xA;    BYTES_PRE_ELEMENT                       # 表示当前数据类型占用的字节数&#xA;    buffer                                  # 该视图的ArrayBuffer对象&#xA;    byteLength                              # 该视图中buffer占内存的长度，是只读属性&#xA;    byteOffset                              # 该视图从哪个字节开始, 只读属性&#xA;静态方法&#xA;    of                                      # 将参数转为TypedArray实例&#xA;    from                                    # 可遍历数据转TypedArray, 可将TypedArray转为另一种TypedArray。可以接map函数&#xA;        Int16Array.from(Int8Array.of(1, 2, 3), x =&amp;gt; 2 * x)&#xA;方法                                        # 没有concat方法&#xA;    set                                     # 复制数组，整段内存覆盖&#xA;        b.set(a, 2)                         # 从b的index2开始复制a&#xA;    subarray                                # 建立新视图&#xA;        a.subarray(2, 3)                    # 从index2复制到index3(不包含), 参数2不填默认复制到结尾&#xA;    slice&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dataview&#34;&gt;&#xA;  DataView&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dataview&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new DataView(buf)                       # DataView(ArrayBuffer buffer [, startIndex [, length]])&#xA;属性&#xA;    buffer&#xA;    byteLength&#xA;    byteOffset&#xA;方法&#xA;    getInt8(0, true)                        # 以带符号整形格式读第0个字节, 第二个参数默认false, 使用大端字节序解读(两个或以上字节的数据需要), 设置true则为小端字节序&#xA;    getUint8&#xA;    getInt16&#xA;    getUint16&#xA;    getInt32&#xA;    getUint32&#xA;    getFloat32&#xA;    getFloat64&#xA;    setUint8(0, 1, true)                    # 开始序号, 数据, 小端字节序&#xA;    setInt16&#xA;    setUint16&#xA;    setInt32&#xA;    setUint32&#xA;    setFloat32&#xA;    setFloat64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;websocket&#34;&gt;&#xA;  WebSocket&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#websocket&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new WebSocket(&#39;ws://127.0.0.1:8081&#39;)&#xA;属性&#xA;    binaryType                              # 设置成&#39;arraybuffer&#39;来接收和发送arraybuffer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;filereader&#34;&gt;&#xA;  FileReader&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#filereader&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var fileInput = document.getElementById(&#39;fileInput&#39;);&#xA;    var file = fileInput.files[0];&#xA;    var reader = new FileReader();&#xA;    reader.readAsArrayBuffer(file);&#xA;    reader.onload = function () { var arrayBuffer = reader.result; }&#xA;    或&#xA;    reader.addEventListener(&#39;load&#39;, processimage, false);&#xA;    function processimage(e) { var buffer = e.target.result; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;promise-1&#34;&gt;&#xA;  Promise&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#promise-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var promise = new Promise(function (resolve, reject) {resolve(0); /* reject(err)*/})&#xA;方法&#xA;    then(func1, func2, func3)               # func1对就fulfilled回调, func2对应rejected回调, func3用于处理进度信息&#xA;    catch                                   # 是then(null, rejection)的别名，尽量使用catch而非then(null, rejection), 这样看起来更接近同步写法&#xA;静态方法&#xA;    all([p1, p2, p3])                       # 成员不是promise对象时，先promise.resolve(data), 全部完成, fullfilled。一个rejected, rejected, 返回第一个reject的错误&#xA;    race([p1, p2, p3])                      # 一个完成, fullfiled, 返回该promise&#xA;        Promise.race([p1, new Promise((resolve, reject) =&amp;gt; {&#xA;            setTimeout(() =&amp;gt; reject(new Error(&#39;time out.&#39;)), 5000)&#xA;        })])&#xA;    resolve&#xA;    reject&#xA;    done                                    # 不在规范内, 总是在回调链尾端, 保证抛出任何可能出现的错误&#xA;    finally                                 # 不在规范内, 接受一个回调函数，永远执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;全局对象&#34;&gt;&#xA;  全局对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a8%e5%b1%80%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;顶级全局对象&#34;&gt;&#xA;  顶级全局对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a1%b6%e7%ba%a7%e5%85%a8%e5%b1%80%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    js代码最外层的this&#xA;    初始化时, 定义所有预定义全局值&#xA;    代码中定义的全局变量，实际是该对象的属性&#xA;Global&#xA;Window&#xA;    介绍&#xA;        初始化时定义了一部分其他全局属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;math&#34;&gt;&#xA;  Math&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#math&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    PI&#xA;    E                                       # 自然对数底数&#xA;    LN10                                    # 同Math.log(10), 表示以e为低10的对数, Math.log(100)/Math.LN10 消底后表示以10为底100的对数&#xA;    LN2&#xA;静态方法&#xA;    trunc                                   # 去除小数部分&#xA;    sign                                    # 判断正负或零&#xA;    exp                                     # e的x次方&#xA;    log                                     # x的自然对数&#xA;    cbrt                                    # 立方根, 同Math.pow(Math.abs(x), 1/3)&#xA;    clz32&#xA;        二进制下32位无符号整数有多少个前导0。小数会取floor&#xA;            count leading zero bits in 32-bit binary representations of a number&#xA;        Math.clz32(1000)        // 22&#xA;        Math.clz32(1000 &amp;lt;&amp;lt; 1)        // 21&#xA;    imul                                    # 32位带符号整数的乘积, 在乘积越界时会返回正确的低位数值&#xA;    fround                                  # 返回一个数的单精度浮点数表示, 4位无法精确表示的小数，会返回最接近的数, 同new Float32Array([x])[0]&#xA;        Math.fround(1.337);        // 1.337000012...&#xA;    hypot                                   # 所有参数平方和的平方根&#xA;    expm1                                   # 返回Math.exp(x) - 1&#xA;    log1p                                   # 返回Math.log(1 + x)&#xA;    log10                                   # 返回以10为低x的对数, 同 Math.log(x) / Math.LN10&#xA;    log2&#xA;    sinh                                    # 双曲正弦 hyperbolic sine&#xA;    cosh                                    # 双曲余弦 hyperbolic cosine&#xA;    tanh                                    # 双曲正切 hyperbolic tangent&#xA;    asinh                                   # inverse hyperbolic sine&#xA;    acosh&#xA;    atanh&#xA;方法&#xA;    pow(x, y)                               # x的y次方, pow(x, 1/3) 表示立方根&#xA;    round(.6)                               # 四舍五入&#xA;    ceil(.6)                                # 向上求整&#xA;    floor(.6)                               # 向下求整&#xA;    abs(-5)                                 # 绝对值&#xA;    max(x, y)                               # 最大值&#xA;    min(x, y)                               # 最小值&#xA;    random()                                # &amp;gt;=0, &amp;lt; 1.0的伪随机数&#xA;    sqrt(3)                                 # 平方根&#xA;    sin(0)&#xA;    log(10)                                 # 自然对数&#xA;    exp(3)                                  # e的3次幂&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;json&#34;&gt;&#xA;  JSON&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#json&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    parse(str)&#xA;    stringify(obj)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reflect-1&#34;&gt;&#xA;  Reflect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reflect-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;静态方法&#xA;    ownKeys(target)                         # 返回对象自身所有属性&#xA;    enumerate(target)                       # 返回Iterator，遍历对象自身和继承的所有可枚举属性, 同for ... in&#xA;    apply(target, thisArg, args)&#xA;    construct(target, args)&#xA;    get(target, name, receiver)&#xA;    set(target, name, value, receiver)&#xA;    defineProperty(target, name, desc)&#xA;    deleteProperty(target, name)&#xA;    has(target, name)&#xA;    isExtensible(target)&#xA;    preventExtensions(target)&#xA;    getOwnPropertyDescriptor(target, name)&#xA;    getPrototypeOf(target)&#xA;    setPrototypeOf(target, prototype)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;symbol&#34;&gt;&#xA;  Symbol&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#symbol&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    hasInstance                             # Obj[Symbol.hasInstance]方法在instanceof运算时调用，如Foo[Symbol.hasInstance](foo)&#xA;    isConcatSpreadable                      # arr.concat时是否要展开&#xA;        let arr = [1, 2], arr[Symbol.isConcatSpreadable] = false,&#xA;        [&#39;a&#39;, &#39;b&#39;].concat(arr, &#39;c&#39;)        // [&#39;a&#39;, &#39;b&#39;, [1, 2], &#39;c&#39;]&#xA;    species                                 # 如果this.constructor[Symbol.species]存在, 用它来做构造函数&#xA;    match                                   # str.match(obj)时, 调用obj[Symbol.match](str)&#xA;    replace                                 # str.replace(s, r)时, 调用s[Symbol.replace](s, r)&#xA;    search                                  # str.search(obj)时，调用obj[Symbol.search](str)&#xA;    split                                   # str.split(separator, limit)时, 调用separator[Symbol.split](str, limit)&#xA;    iterator&#xA;        for ... of指向调用的默认遍历器&#xA;        function A {*[Symbol.iterator] () {&#xA;            let i = 0; while(this[i] != undefined) {yield this[i]; i++;}&#xA;        }}&#xA;    toPrimitive                             # 对象转原始类型值时调用&#xA;        {[Symbol.toPrimitive] (hint) {}}        // hint值有 &#39;number&#39;, &#39;string&#39;, &#39;default&#39;&#xA;    toStringTag&#xA;        toString时拼在后面, 如 &#39;[object xxx]&#39;&#xA;    unscopables&#xA;        排除with时的属性, Array.prototype[Symbol.unscopables]        // {copyWithin: true, ...}&#xA;&#xA;方法&#xA;    s.toString()        // &#39;Symbol(foo)&#39;    # 可以String(s) 得到字符串&#39;Symbol(foo)&#39;&#xA;静态方法&#xA;    for(&#39;foo&#39;)                              # 搜索以&#39;foo&#39;作参数登记的Symbol值, 没有时会新建、登记并返回, 这种登记是全局的&#xA;    keyFor(s)                               # 返回s登录的字符串，没有时返回undefined&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;dom&#34;&gt;&#xA;  dom&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dom&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;window对象&#34;&gt;&#xA;  window对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#window%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;document&#34;&gt;&#xA;  document&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#document&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    id&#xA;    innerHTML                               # 非标准但通用&#xA;    body&#xA;        方法&#xA;            appendChild(domElement)&#xA;方法&#xA;    getElementById(&amp;quot;&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;element&#34;&gt;&#xA;  element&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#element&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    innerHTML&#xA;    style&#xA;        display = &amp;quot;none&amp;quot;&#xA;        visibility = &amp;quot;hidden&amp;quot;&#xA;    className&#xA;方法&#xA;    createElement(&amp;quot;div&amp;quot;)&#xA;    createTextNode(msg)&#xA;    appendChild(ele)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;xmlhttprequest&#34;&gt;&#xA;  XMLHttpRequest&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xmlhttprequest&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;var req = new XMLHttpRequest()&#xA;方法&#xA;    open(&amp;quot;GET&amp;quot;, url)&#xA;    send(null)                              # null表示不带正文地发送这个请求&#xA;    onreadystatechange = function(){        # 重写回调函数&#xA;        if(req.readyState == 4 &amp;amp;&amp;amp; req.status == 200){&#xA;            var text = req.responseText;    # 响应的字符串&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;localstorage&#34;&gt;&#xA;  localStorage&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#localstorage&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;worker&#34;&gt;&#xA;  Worker&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#worker&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    it is a javascript running in the background, without affecting the performance of the page.&#xA;    dom中的js线程在执行时会阻塞&#xA;使用&#xA;    var w;&#xA;    // start worker&#xA;    function startWorker(){&#xA;        if(typeof(Worker) !== &#39;undefined&#39;){&#xA;            if(typeof(w) == &#39;undefined&#39;){&#xA;                w = new Worker(&#39;demo_workers.js&#39;);&#xA;            }&#xA;            w.onmessage = function(event){&#xA;                ＃ worker &#39;s api, will call postMessage()&#xA;                document.getElementById(&#39;result&#39;).innerHTML = event.data;&#xA;            };&#xA;        }else {&#xA;            document.getElementById(&#39;result&#39;).innerHTML = &#39;sorry, your browser does not support Web Workers...&#39;;&#xA;        }&#xA;    }&#xA;    // stop worker&#xA;    w.terminate();                                                        ＃ worker &#39;s api, will trigger w.onmessage();&#xA;    w = undefined;&#xA;&#xA;    /* demo_workers.js */                                            # 外部的js文件不能访问window, document, parent对象&#xA;    var i = 0;&#xA;    function timeCount(){&#xA;        i = i + 1;&#xA;        postMessage(i);                                            # worker &#39;s api, when onmessage() was triggered.&#xA;        setTimeout(&#39;timeCount()&#39;, 500);&#xA;    }&#xA;    timedCount();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;eventsource&#34;&gt;&#xA;  EventSource&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eventsource&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    浏览器推送&#xA;事件&#xA;    onopen&#xA;    onmessage&#xA;    onerror&#xA;使用&#xA;    var source = new EventSource(&amp;quot;demo_sse.php&amp;quot;);&#xA;    source.onmessage = function(event){&#xA;        document.getElementById(&#39;result&#39;).innerHTML += event.data + &#39;&amp;lt;br/&amp;gt;&#39;;&#xA;    };&#xA;    // demo_sse.php&#xA;    &amp;lt;?php&#xA;    header(&#39;Content-Type: text/event-stream&#39;);&#xA;    header(&#39;Cache-Control: no-cache&#39;);&#xA;&#xA;    $time = date(&#39;r&#39;);&#xA;    echo &amp;quot;data: The server time is: {$time}\n\n&amp;quot;;&#xA;        # data在上面event.data中引用&#xA;    flush();&#xA;    ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;控件&#34;&gt;&#xA;  控件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;activexobject&#34;&gt;&#xA;  ActiveXObject&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#activexobject&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;new ActiveXObject(&amp;quot;Excel.Application&amp;quot;);         # Microsoft.XMLHTTP, ie中适用&#xA;Server.CreateObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;)        # 在chrome中不起作用, 可以用 new XMLHttpRequest()创建&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;canvas&#34;&gt;&#xA;  canvas&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#canvas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    原点: canvas左上角&#xA;    默认Style为black&#xA;    颜色设定&#xA;        &amp;quot;red&amp;quot; &amp;quot;blue&amp;quot;&#xA;        &amp;quot;#EEEEFF&amp;quot;&#xA;        &amp;quot;rgb(1-255, 1-255, 1-255)&amp;quot;&#xA;        &amp;quot;rgba(1-255, 1-255, 1-255, 0-1)&amp;quot;&#xA;    路径&#xA;        可以被填充多个轮廓或图形的操作。&#xA;基本使用&#xA;    var context =canvas.getContext(&amp;quot;2d&amp;quot;);&#xA;&#xA;    context.fill()//填充&#xA;    context.stroke()//绘制边框&#xA;    context.lineWidth//图形边框宽度&#xA;&#xA;    context.fillStyle//填充的样式&#xA;    context.strokeStyle//边框样式&#xA;绘制&#xA;    矩形&#xA;        content.fillRect(x, y, width, height)&#xA;        strokeRect(x, y, width, height)         # x, y是起点坐标, width, height为宽和高&#xA;    清除矩形区域&#xA;        context.clearRect(x,y,width,height)&#xA;    圆弧&#xA;        context.arc(x, y, radius, startAngle,endAngle, anticlockwise)&#xA;            x, y是圆心坐标, radius是半径, startAngle, endAngle是开始、结束弧度, anticlockwise=false时顺时针画圆&#xA;            一刻钟是零度, 弧度可以用Math.PI来表示&#xA;例子&#xA;    矩形&#xA;        context.fillRect(0, 120, 100, 100);&#xA;        context.strokeRect(120, 120, 100, 100);&#xA;        context.clearRect(50, 50, 240, 120);&#xA;    圆弧&#xA;        context.beginPath();&#xA;        ctx.arc(100,75,50,0,1.3 * Math.PI, false);&#xA;        context.closePath();&#xA;        context.fill();                         # 或ctx.stroke()画线, fill()填充开始点与结束点的连线&#xA;image&#xA;    var image = ctx.getImageData(0, 0, 256, 256);                   # 取画布矩形区域的图像&#xA;    ctx.putImageData(image, 10, 70)             # 把图像复制到画布的一个起点&#xA;    例子&#xA;        var c=document.getElementById(&amp;quot;myCanvas&amp;quot;);&#xA;        var ctx=c.getContext(&amp;quot;2d&amp;quot;);&#xA;        var imgData=ctx.createImageData(100,100);&#xA;        for (var i=0;i&amp;lt;imgData.data.length;i+=4)                    # 一个像素有4个值RGB + alpha, alpha=255表示不透明&#xA;        {&#xA;            imgData.data[i+0]=255;&#xA;            imgData.data[i+1]=0;&#xA;&#xA;            imgData.data[i+2]=0;&#xA;            imgData.data[i+3]=255;&#xA;        }&#xA;        ctx.putImageData(imgData,10,10);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;优化&#34;&gt;&#xA;  优化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;canvas.width = canvas.width                     # 一种巧妙的方法清除并重置画布&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;webgl&#34;&gt;&#xA;  webgl&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#webgl&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    由Khronos Group维护                          # 还维护了OpenGL和COLLADA&#xA;    使用OpenGL渲染语言GLSL ES&#xA;    WebGL是在浏览器中实现三维效果的一套规范&#xA;    webgl通过增加openGL es 2.0的一个js绑定, 把它们结合在一起&#xA;    webgl可以为html5 canvas提供硬件3d加速渲染&#xA;        更流畅地展示3d场景和模型&#xA;        创建复杂的导航和数据视觉化&#xA;名词&#xA;    科纳斯组织       Khronos Group&#xA;    GLSL ES         OpenGL Shading Language Embedded System&#xA;    网格          Mesh&#xA;    模型          model&#xA;    纹理映射        texture map&#xA;    材质          material&#xA;    光源          light&#xA;    变换          transform&#xA;    相机          camera&#xA;    视口          viewport&#xA;    投影矩阵       projection matrix&#xA;    视锥体         view volume&#xA;    视平截头体      view frustum&#xA;    着色器         shader&#xA;    图元          primitive&#xA;    三角形带        triangle strip&#xA;    类型化数组       typed array&#xA;    模型视图矩阵      modelview matrix&#xA;    投影矩阵        projection matrix&#xA;    顶点着色器        vertex shader&#xA;    片元着色器        fragment shader&#xA;    像素着色器        pixel shader, 同fragment shader&#xA;    自发光         unlit&#xA;    预置光照        prelit&#xA;    镜面高光        specular highlights&#xA;    镜面反射        specular reflection&#xA;    alpha混合        alpha blending&#xA;    变换层级        transform hierarchy&#xA;    帧动画         frame-based animation&#xA;    补间动画        tweening&#xA;    关键帧         keyframe&#xA;    关键帧动画       keyframe animation&#xA;    插值          interpolation&#xA;    线性插值        linear interpolation&#xA;    关节动画        articulated animation&#xA;    蒙皮动画        skinned animation&#xA;    骨骼          skeleton&#xA;    目标变形动画      morph target animation&#xA;    程序贴图        procedural texture&#xA;    纹理变换        texture transform&#xA;    拾取          picking&#xA;    面法线        face normal&#xA;    程序贴图        procedural texture&#xA;    多级渐进纹理过滤        mipmapping / mipmapping filtering&#xA;    数码内容创作软件        DCC        digital content creation&#xA;    包围盒        bounding box&#xA;框架&#xA;    three.js&#xA;    physi.js&#xA;    glMatrix&#xA;    GLGE&#xA;    philoGL&#xA;    sceneJS&#xA;    spiderGL&#xA;着色器&#xA;工具&#xA;    webgl inspector&#xA;        # chrome的扩展, webgl调试&#xA;网站&#xA;    www.khronos.org/webgl/&#xA;        # Khronos提供的主页&#xA;    learningwebgl.com/blog&#xA;    blog.tojicode.com&#xA;    https://developer.mozilla.org/en/WebGL&#xA;        # mozilla的webgl教程&#xA;    www.chromeexperiments.com&#xA;        # chrome体验&#xA;    www.html5rocks.com&#xA;        # 提供html5资源&#xA;    www.lao3d.com&#xA;        # 国内首个webgl网站&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>JavaWeb</title>
      <link>https://runout.run/docs/pl/java/javaweb/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/javaweb/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分层&#xA;    视图层         jsp&#xA;    控制层         servlet&#xA;    业务层         过滤数据&#xA;    manager层     封装第三方，service能力下沉，dao中间件&#xA;    数据访问层对象  封装对象&#xA;    数据库&#xA;java web 13种技术&#xA;    JDBC        Java Database Connectivty&#xA;    JNDI        Java Name and Directory Interface&#xA;    EJB        Enterprise JavaBean&#xA;    RMI        Remote Method Invoke&#xA;    Java IDL/CORBA&#xA;    JSP        Java Server Pages&#xA;    Java Servlet&#xA;    XML        Extensible Markup Language&#xA;    JMS        Java Message Service&#xA;    JTS        Java Transaction Service&#xA;    JTA        Java Transaction Architecture&#xA;    JavaMail&#xA;    JAF        JavaBeans Activation Framework&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jsp&#34;&gt;&#xA;  jsp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层&#xA;域对象&#xA;    pageContext     # 当前页面有效&#xA;    request         # 一次请求范围&#xA;    session         # 会话&#xA;    application context     # 同一服务器&#xA;内置对象&#xA;    Request&#xA;    Response&#xA;    Session&#xA;    Out             # 输出流&#xA;    PageContext     # context&#xA;    Page            # jsp的this&#xA;    Exception       # &amp;lt;%@ page isErrorPage=&amp;quot;true&amp;quot;%&amp;gt; 时使用，显示异常信息&#xA;    Application     # 服务器&#xA;    Config          # 服务器配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp-el表达式&#34;&gt;&#xA;  jsp-el表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp-el%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;${  }&#xA;11个内置对象&#xA;    pageContext    // pageContext&#xA;    page        // map （相当于pageScope，不过写法上省略了Scope）&#xA;    requestScope    // map&#xA;    sessionScope    // map&#xA;    applicationScope    // map&#xA;    param        // map        ,用${param.name}的形式得到传递的参数&#xA;    paramValues    // map&amp;lt;String,String []&amp;gt;&#xA;    header        // map&#xA;    hearderValues    // map&amp;lt;String, String []&amp;gt;&#xA;    cookie        // map&#xA;    initParam        // map&#xA;&#xA;语法&#xA;${list[0]}&amp;lt;br&amp;gt;&#xA;    ${map.mapteststring}&amp;lt;br&amp;gt;&#xA;    ${map[mapkey]}&amp;lt;br&amp;gt;&#xA;    ${map[&#39;mapteststring&#39;]}&amp;lt;br&amp;gt;&#xA;    ${request }&#xA;    ${pageContext.request.contextPath }&amp;lt;br&amp;gt;        # el表达式中访问内置对象&#xA;    ${requestScope.aaa }                # 访问内置对象requestScope，得到request作用域中的aaa元素&#xA;    ${pageContext.servletContext.contextPath }&amp;lt;br&amp;gt;&#xA;    ${param}&amp;lt;br&amp;gt;&#xA;    ${paramValues[&#39;a&#39;] }&amp;lt;br&amp;gt;&#xA;    ${paramValues[&#39;a&#39;][0] }&#xA;    ${paramValues[&#39;a&#39;][1] }&#xA;    ${paramValues[&#39;a&#39;][2] }&amp;lt;br&amp;gt;&#xA;    ${empty novalue}&amp;lt;br&amp;gt;&#xA;    ${1&amp;gt;2?&amp;quot;yes&amp;quot; : &amp;quot;no&amp;quot;}&amp;lt;br&amp;gt;&#xA;&#xA;        #  . 与 [] 可以替换使用，但有两点需要注意&#xA;        1  .1不行，但是[1]可以&#xA;        2    1&amp;gt; map[&amp;quot;key&amp;quot;]    是取map中&amp;quot;key&amp;quot;对应的值&#xA;            2&amp;gt; map[key]是先从作用域中取得key的字符串如&amp;quot;aaa&amp;quot;,再取map中&amp;quot;aaa&amp;quot;对应的值&#xA;            3&amp;gt; .key    相当于1&amp;gt;中的介绍，是取map中&amp;quot;key&amp;quot;对应的值&#xA;            4&amp;gt; .是不能相当于2&amp;gt;中的介绍那样使用的&#xA;比较符${ }中使用&#xA;    empty&#xA;    not empty&#xA;    三元式（?:）&#xA;    简单的算术运算&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp-taglib标签库&#34;&gt;&#xA;  jsp-taglib标签库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp-taglib%e6%a0%87%e7%ad%be%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;jstl标签库1.1 或1.2&#xA;    标签库1.1中需要    jstl.jar 与 standard.jar 库&#xA;可放入域scope的类型&#xA;    page&#xA;    request&#xA;    session&#xA;    application&#xA;    functions&#xA;el表达式级使用，其它都标签级使用&#xA;functions&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;fn&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/functions&amp;quot;%&amp;gt;&#xA;    ${fn:contains(&amp;quot;gzitcast&amp;quot;, &amp;quot;itcast&amp;quot;) }  &amp;lt;br&amp;gt;&#xA;    ${fn:containsIgnoreCase(&amp;quot;gzitcast&amp;quot;, &amp;quot;ITCAST&amp;quot;) }  &amp;lt;br&amp;gt;&#xA;    ${fn:endsWith(&amp;quot;gzitcast&amp;quot;, &amp;quot;st&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:indexOf(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:join(arr, &amp;quot;-&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:length(&amp;quot;gzitcast&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:replace(&amp;quot;gzitcast&amp;quot;, &amp;quot;gz&amp;quot;, &amp;quot;广州&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:split(&amp;quot;gz,it,cast&amp;quot;, &amp;quot;,&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:startsWith(&amp;quot;gzitcsat&amp;quot;, &amp;quot;gz&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:substring(&amp;quot;gzitcsat&amp;quot;, 3, 8) } &amp;lt;br&amp;gt;&#xA;    ${fn:substringAfter(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:substringBefore(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:toLowerCase(&amp;quot;gziTCsat&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:toUpperCase(&amp;quot;gziTCsat&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:trim(&amp;quot;  gzitcsat  &amp;quot;) } &amp;lt;br&amp;gt;&#xA;    &amp;lt;%-- 对字符串中进行转义处理，如：会把&amp;quot;&amp;lt;&amp;quot;替换为&amp;quot;&amp;amp;lt;&amp;quot;，把&amp;quot;&amp;gt;&amp;quot;替换为&amp;quot;&amp;amp;gt;&amp;quot; --%&amp;gt;&#xA;    ${fn:escapeXml(&amp;quot;&amp;lt;h3&amp;gt;gzitcsat&amp;lt;/h3&amp;gt;&amp;quot;) } &amp;lt;br&amp;gt;&#xA;core&#xA;    所有标签：&#xA;        out&#xA;        set&#xA;        remove&#xA;        catch&#xA;        if&#xA;        choose&#xA;        when&#xA;        otherwise&#xA;        forEach&#xA;        url&#xA;        param&#xA;        redirect&#xA;        forTokens&#xA;        import&#xA;&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/cores&amp;quot;%&amp;gt;&#xA;    &amp;lt;c:out var=&amp;quot;&amp;quot;    default=&amp;quot;&amp;quot;    escapeXml=&amp;quot;true&amp;quot;&amp;gt;    &amp;lt;%--    放过xml过滤，让它显示，默认不显示    --%&amp;gt;&#xA;    -------------------------------------&#xA;    scope方式&#xA;    &amp;lt;c:set    var=&amp;quot;&amp;quot;    value=&amp;quot;&amp;quot;    scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    target方式    &amp;lt;%--    这个放入page作用域中的map值    --%&amp;gt;&#xA;    &amp;lt;%  Map map = new HashMap();  %&amp;gt;&#xA;    &amp;lt;c:set    property=&amp;quot;key1&amp;quot;    value=&amp;quot;key1value&amp;quot;    target=&amp;quot;&amp;lt;%=map%&amp;gt;&amp;quot;&#xA;    &amp;lt;%  pageContext.setAttribute(&amp;quot;map&amp;quot;, map);  %&amp;gt;&#xA;    &amp;lt;c:out    value=&amp;quot;${map[key2]}&amp;quot;&#xA;&#xA;    -------------------------------------&#xA;    &amp;lt;c:catch var=&amp;quot;e&amp;quot;&amp;gt;&amp;lt;/c:catch&amp;gt;&#xA;    &amp;lt;c:out value=&#39;&amp;lt;%= ((Exception)pageContext.getAttribute(&amp;quot;e&amp;quot;,PageContext.PAGE_SCOPE)).getMessage() %&amp;gt;&#39;&amp;gt;&amp;lt;/c:out&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:remove    var=&amp;quot;&amp;quot;    scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:if test=&amp;quot;${not empty    }&amp;quot; scope=&amp;quot;&amp;quot;    var=&amp;quot;&amp;quot;&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;%--    if...else标签    --%&amp;gt;&#xA;    &amp;lt;c:choose&amp;gt;&#xA;    &amp;lt;c:when test=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;c:otherwise&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:forEach  begin=&amp;quot;&amp;quot;    end=&amp;quot;&amp;quot;    step=&amp;quot;&amp;quot;    items=&amp;quot;&amp;quot;    var=&amp;quot;&amp;quot;    varStatus=&amp;quot;state&amp;quot;&amp;gt;          &amp;lt;%--    varStatus中的函数有first last count begin end    --%&amp;gt;&#xA;    &amp;lt;tr bgcolor=&#39;${state.count%2 == 0? &amp;quot;red&amp;quot; : &amp;quot;pink&amp;quot;}&#39; &amp;gt;&#xA;    &amp;lt;/c:forEach&amp;gt;&#xA;&#xA;    varStatus可用的函数&#xA;        current    // 当前这次迭代的项&#xA;        index    // 索引&#xA;        count    // 计数&#xA;        first        // 第一个&#xA;        last        // 最后一个&#xA;        begin    // begin属性值&#xA;        end        // end 属性值&#xA;        step        // step属性值&#xA;    -------------------------------------&#xA;    uri 代表所有协议路径&#xA;&#xA;    &amp;lt;c:url    var=&amp;quot;itcast&amp;quot;    value=&amp;quot;http://www.itcast.cn&amp;quot;    scope=&amp;quot;page&amp;quot;    context=&amp;quot;&amp;quot;    &amp;gt;    &amp;lt;%--    context 是整个网站    --%&amp;gt;&#xA;    &amp;lt;c:param    name=&amp;quot;name&amp;quot;    value=&amp;quot;中文&amp;quot;&amp;gt;    &amp;lt;%--    这样传参数有编码    --%&amp;gt;&#xA;&#xA;    如果value值为&amp;quot;/&amp;quot; 则加入context属性提供上下文名称，如果context也被省略，就使用当前servlet的上下文名称&#xA;    -------------------------------------&#xA;    &amp;lt;c:redirect    url=&amp;quot;${itcast}&amp;quot;    context=&amp;quot;&amp;quot;    &amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:set    var=&amp;quot;name&amp;quot;    value=&amp;quot;xx,xxx,xxx,xx&amp;quot;    scope=&amp;quot;request&amp;quot;    &amp;gt;&#xA;    &amp;lt;c:forTokens    items=&amp;quot;${name}&amp;quot;    delims=&amp;quot;,&amp;quot;    begin=&amp;quot;&amp;quot;    end=&amp;quot;&amp;quot;    step=&amp;quot;1&amp;quot;    var=&amp;quot;name&amp;quot;    varStatus=&amp;quot;&amp;quot;    &amp;gt;    &amp;lt;%--切割字符串--%&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:import    url=&amp;quot;/publics/head.jsp&amp;quot;    &amp;gt;    &amp;lt;%--动态包含，引入公共文件--%&amp;gt;&amp;lt;%--网站publics文件夹--%&amp;gt;&#xA;&#xA;&#xA;sql标签库&#xA;    # 以前没有mvc模式的时候，通过页面访问数据库时用的，现在不用&#xA;    引入&#xA;        &amp;lt;%@ taglib prefix=&amp;quot;sql&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/sql&amp;quot; %&amp;gt;&#xA;    设置数据源&#xA;        &amp;lt;sql:setDataSource dataSource=”dataSource”[var=”name”]&#xA;                            [scope=”page|request|session|application”]/&amp;gt;&#xA;    jdbc连接&#xA;        &amp;lt;sql:setDataSource driver=”driverClass” url=”jdbcURL”&#xA;                user=”username”&#xA;                password=”pwd”&#xA;                [var=”name”]&#xA;                [scope=”page|request|session|application”]/&amp;gt;&#xA;&#xA;    JSTL提供了&amp;lt;sql:query&amp;gt;、&amp;lt;sql:update&amp;gt;、&amp;lt;sql:param&amp;gt;、&amp;lt;sql:dateParam&amp;gt;和&amp;lt;sql:transaction&amp;gt;这5个标签&#xA;        1.query:&#xA;        query必需指定数据源&#xA;        &amp;lt;sql:query sql=”sqlQuery” var=”name” [scope=”page|request|session|application”]&#xA;        [dataSource=”dateSource”]&#xA;        [maxRow=”maxRow”]&#xA;        [startRow=”starRow”]/&amp;gt;&#xA;        或&#xA;        &amp;lt;sql:query var=”name” [scope=”page|request|session|application”]&#xA;        [dataSource=”dateSource”]&#xA;        [maxRow=”maxRow”]    # 设定最多可以暂存数据的长度&#xA;        [startRow=”starRow”]    # 设定从哪一行开始&#xA;                &amp;gt;&#xA;                sqlQuery&#xA;                &amp;lt;/sql:query&amp;gt;&#xA;&#xA;        结果集的参数&#xA;            rowCount    # 结果集中的记录总数&#xA;            rowsByIndex    # 以数字为作索引的查询结果&#xA;            columnNames    # 字段名称数组&#xA;            Rows    # 以字段为索引查询的结果&#xA;            limitedByMaxRows    # 是否设置了maxRows属性来限制查询记录的数量&#xA;                limitedByMaxRows用来判断程序是否收到maxRows属性的限制。&#xA;                并不是说设定了maxRows属性，得到结果集的limitedByMaxRows的属性都为true，&#xA;                当取出的结果集小于maxRows时，则maxRows没有对结果集起到作用此时也为false。&#xA;                例如可以使用startRow属性限制结果集的数据量。&#xA;&#xA;        2.update:&#xA;        &amp;lt;/sql:update&amp;gt;&#xA;        &amp;lt;sql:update sql=”SQL语句” [var=”name”] [scope=”page|request|session|application”]&#xA;                [dateSource=”dateSource”]/&amp;gt;&#xA;        或&#xA;    &amp;lt;sql:update [var=”name”] [scope=”page|request|session|application”]&#xA;                [dateSource=”dateSource”]&#xA;                    &amp;gt;&#xA;                    SQL语句&#xA;        参数说明&#xA;            dataSource    # 数据源对象&#xA;            其它与query一样&#xA;&#xA;        3.param 参数设置&#xA;        &amp;lt;sql:param value=”value”/&amp;gt;&#xA;        或&#xA;        &amp;lt;sql:param&amp;gt;&#xA;            Value&#xA;            &amp;lt;/sql:param&amp;gt;&#xA;&#xA;        4.dataParam 标签    # 用于为SQL标签填充日期类型的参数值&#xA;&#xA;        参数说明&#xA;            value：java.util.Date类型的参数。&#xA;            type属性：指定填充日期的类型timestamp（全部日期和时间）、time（填充的参数为时间）、date（填充的参数为日期）。&#xA;&#xA;        5.transaction 标签&#xA;&#xA;        &amp;lt;sql:transaction [dataSource=”dataSource”]&#xA;            [isolation=”read_committed|read_uncommitted|repeatable|serializable”]&#xA;            &amp;gt;&#xA;            &amp;lt;sql:query&amp;gt;&#xA;            &amp;lt;sql:uptade&amp;gt;&#xA;        &amp;lt;/sql:transation&amp;gt;&#xA;&#xA;xml标签库&#xA;    核心操作&#xA;    out    # 主要用来取出XML中的字符串。&#xA;        属性&#xA;        select    # XPath语句&#xA;        escapeXml    # 是否转换特殊字符&#xA;&#xA;    parse    # 用来解析xml文件&#xA;        属性&#xA;        doc    # XML文件&#xA;        systemId    # XML文件的URL&#xA;        filter    # XMLFilter过滤器&#xA;        varDom    # 储存解析后的XML文件&#xA;        scopeDom    # varDom的范围&#xA;&#xA;    set    # 将从XML文件取得的内容储存至属性范围中&#xA;        属性&#xA;        select    # XPath语句&#xA;&#xA;    流程控制&#xA;    if&#xA;    choose when otherwise&#xA;        属性&#xA;        select    # XPath语句&#xA;    文件转换&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]/&amp;gt;&#xA;    或&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]&#xA;        &amp;gt;&#xA;        &amp;lt;x:param/&amp;gt;&#xA;        &amp;lt;/x:transform&amp;gt;&#xA;    或&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]&#xA;        &amp;gt;&#xA;&#xA;        属性&#xA;        doc    # 指定xml文件来源&#xA;        xslt    # 转化xml的样式模板&#xA;        docSystemId    # xml文件的URI&#xA;        xsltSystemId    # xslt文件的URI&#xA;        result    # 用来存储转换后的结果对象&#xA;&#xA;国际化&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;fmt&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/fmt&amp;quot; %&amp;gt;&#xA;    国际化标签&#xA;    1.setLocale    # 设置一个全局的地区代码,设定的是本地的环境&#xA;        中文－大陆:&amp;lt;fmt:setLocale value=&amp;quot;zh_CN&amp;quot;/&amp;gt; &amp;lt;fmt:formatDate value=&amp;quot;${todayValue}&amp;quot;/&amp;gt;&amp;lt;br&amp;gt;&#xA;&#xA;    2.requestEncoding    # 设置统一的请求编码&#xA;        &amp;lt;fmt:requestEncoding value=&amp;quot;GB2312&amp;quot;/&amp;gt;&#xA;&#xA;    信息显示标签&#xA;    1.&amp;lt;fmt:bundle&amp;gt; 设置临时要读取的资源文件&#xA;    2.&amp;lt;fmt:message&amp;gt;  通过key取得value&#xA;    3.&amp;lt;fmt:setBundle&amp;gt;  设置一个要读取的全局的资源文件&#xA;        如&#xA;        &amp;lt;fmt:setBundle basename=&amp;quot;applicationMessage&amp;quot; var=&amp;quot;MyResourse&amp;quot;/&amp;gt;    # 绑定了名为applicationMessage_zh_CN.properties一类 的文件&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot; prefix=&amp;quot;label.&amp;quot;&amp;gt;&#xA;        &amp;lt;fmt:message key=&amp;quot;backcolor&amp;quot; bundle=&amp;quot;${applicationBundle}&amp;quot;/&amp;gt;&#xA;        &amp;lt;fmt:message key=&amp;quot;fontcolor&amp;quot; /&amp;gt;&#xA;    &amp;lt;/fmt:bundle&amp;gt;&#xA;&#xA;&#xA;    数字及日期格式化标签&#xA;    1.&amp;lt;fmt:formatDate&amp;gt;  日期的格式化&#xA;        属性&#xA;        value:格式化的日期，该属性的内容应该是 java.util.Date 类型的实例&#xA;        type:格式化的类型&#xA;        pattern:格式化模式&#xA;        timeZone:指定格式化日期的时区&#xA;    2.&amp;lt;fmt:parseDate&amp;gt;  解析日期&#xA;        属性&#xA;        value:将被解析的字符串&#xA;        type:解析格式化的类型&#xA;        pattern:解析格式化模式&#xA;        parseLocale:以本地化的形式来解析字符串，该属性的内容为 String 或 java.util.Locale 类型的实例&#xA;        timeZone:指定解析格式化日期的时区&#xA;    3.&amp;lt;fmt:formatNumber&amp;gt;  数字格式化&#xA;        属性&#xA;        value:格式化的数字,该数值可以是 String 类型或 java.lang.Number 类型的实例&#xA;        type:格式化的类型,可能值包括:currency（货币）、number（数字）和percent（百分比）&#xA;        pattern:格式化模式&#xA;        maxIntegerDigits:指定格式化结果的最大值&#xA;        minIntegerDigits:指定格式化结果的最小值&#xA;        maxFractionDigits:指定格式化结果的最大值，带小数&#xA;        minFractionDigits:指定格式化结果的最小值，带小数&#xA;        如&#xA;        &amp;lt;fmt:formatNumber value=&amp;quot;1000.888&amp;quot; type=&amp;quot;currency&amp;quot; var=&amp;quot;money&amp;quot;/&amp;gt;&#xA;&#xA;    4.&amp;lt;fmt:parseNumber&amp;gt;  解析数字&#xA;        属性&#xA;        value:将被解析的字符串&#xA;        type:解析格式化的类型&#xA;        pattern:解析格式化模式&#xA;        如&#xA;        &amp;lt;fmt:parseNumber value=&amp;quot;15%&amp;quot; type=&amp;quot;percent&amp;quot; var=&amp;quot;num&amp;quot;/&amp;gt;&#xA;    5.&amp;lt;fmt:setTimeZone&amp;gt;  标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行属性描述&#xA;        属性&#xA;        value    # 时区的设置&#xA;        var    # 用于保存时区为一个变量&#xA;    6.&amp;lt;fmt:timeZone&amp;gt;  标签将使得在其标签体内的工作可以使用该时区设置&#xA;        属性&#xA;        value    # 时区的设置&#xA;    7.&amp;lt;fmt:param&amp;gt; 标签:用于参数传递&#xA;        如：在MyResourse.properties文件中,有一个索引值如下(其中,{0}代表占位符):&#xA;        Str2=Hi,{0}&#xA;        则,使用&amp;lt;fmt:param&amp;gt;标签传入值如下:&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:message key=&amp;quot;Str2&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:param value=&amp;quot;张三&amp;quot; /&amp;gt;&#xA;            &amp;lt;/fmt:message&amp;gt;&#xA;        &amp;lt;/fmt:bundle&amp;gt;&#xA;        也可以在资源文件中指定参数的类型:&#xA;        如:在MyResourse.properties文件中,有一个索引值如下:&#xA;        Str3={0,date}&#xA;        则,使用&amp;lt;fmt:param&amp;gt;标签传入值如下:&#xA;        &amp;lt;% request.setAttribute(&amp;quot;now&amp;quot;,new Date()); %&amp;gt;&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:message key=&amp;quot;Str3&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:param value=&amp;quot;${now}&amp;quot; /&amp;gt;&#xA;            &amp;lt;/fmt:message&amp;gt;&#xA;        &amp;lt;/fmt:bundle&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp动作标签&#34;&gt;&#xA;  jsp动作标签&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%8a%a8%e4%bd%9c%e6%a0%87%e7%ad%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。&#xA;&#xA;一、Include行为&#xA;&#xA;    &amp;lt;jsp:include&amp;gt;标签表示动态包含一个静态的或者动态的文件。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot; /&amp;gt;&#xA;    or&#xA;    &amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot;&amp;gt;&#xA;    &amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;&#xA;    &amp;lt;/jsp:include&amp;gt;&#xA;&#xA;    注：&#xA;    1、page=&amp;quot;path&amp;quot; 为相对路径，或者代表相对路径的表达式。&#xA;    2、flush=&amp;quot;true&amp;quot; 必须使用flush为true，它默认值是false。&#xA;    3、&amp;lt;jsp:param&amp;gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&amp;lt;jsp:param&amp;gt;来传递多个参数给动态文件。&#xA;    4、&amp;lt;jsp:include page=&amp;quot;&amp;quot; flush=&amp;quot;&amp;quot;&amp;gt; 与&amp;lt;%@ include file=&amp;quot;&amp;quot;%&amp;gt;的区别：&#xA;        &amp;lt;jsp:include &amp;gt;是动态包含&amp;lt;%@include%&amp;gt;是静态包含。&#xA;        # jsp页面是把include指令元素（&amp;lt;%@ include file=&amp;quot;&amp;quot;%&amp;gt;）所指定的页面的实际内容（也就是代码段）加入到引入它的jsp页面中,合成一个文件后被jsp容器将它转化成servlet。&#xA;        ## 可以看到这时会产生一个临时class文件和一个servlet源文件。&#xA;        ## 而动作元素（&amp;lt;jsp:include page=&amp;quot;&amp;quot;/&amp;gt;）是在请求处理阶段引入的，会被JSP容器生成两个临时class文件和两个servlet原文件。&#xA;        ## 而引入的只是servlet的输出结果，即JspWriter对象的输出结果，而不是jsp的源代码。&#xA;&#xA;二、Forward行为&#xA;&#xA;    &amp;lt;jsp:forward&amp;gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} /&amp;gt;&#xA;    or&#xA;    &amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} &amp;gt;&#xA;    &amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;……&#xA;    &amp;lt;/jsp:forward&amp;gt;&#xA;&#xA;    注：&#xA;    1、page=&amp;quot;path&amp;quot; 为一个表达式，或者一个字符串。&#xA;    2、&amp;lt;jsp:param&amp;gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&amp;lt;jsp:param&amp;gt;将多个参数发送到一个动态文件中。&#xA;&#xA;三、UseBean行为&#xA;&#xA;    &amp;lt;jsp:useBean&amp;gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;name&amp;quot; scope=&amp;quot;page | request | session | application&amp;quot; typeSpec /&amp;gt;&#xA;    其中typeSpec有以下几种可能的情况：&#xA;    class=&amp;quot;className&amp;quot; | class=&amp;quot;className&amp;quot; type=&amp;quot;typeName&amp;quot; | beanName=&amp;quot;beanName&amp;quot; type=&amp;quot;typeName&amp;quot; | type=&amp;quot;typeName&amp;quot; |&#xA;&#xA;    注：&#xA;    你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。&#xA;&#xA;四、GetProperty行为&#xA;&#xA;    &amp;lt;jsp:getProperty&amp;gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:getProperty name=&amp;quot;name&amp;quot; property=&amp;quot;propertyName&amp;quot; /&amp;gt;&#xA;&#xA;    注：&#xA;    1、在使用&amp;lt;jsp:getProperty&amp;gt;之前，必须用&amp;lt;jsp:useBean&amp;gt;来创建它。&#xA;    2、不能使用&amp;lt;jsp:getProperty&amp;gt;来检索一个已经被索引了的属性。&#xA;    3、能够和JavaBeans组件一起使用&amp;lt;jsp:getProperty&amp;gt;，但是不能与Enterprise Java Bean一起使用。&#xA;JavaScript通用库  Jsp语法&#xA;JSP的动作标签  2008-04-01 11:47:49|  分类： JSP学习 |  标签： |字号大&#xA;中&#xA;小 订阅&#xA;在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。&#xA;&#xA;一、Include行为&#xA;&#xA;&amp;lt;jsp:include&amp;gt;标签表示包含一个静态的或者动态的文件。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot; /&amp;gt;&#xA;or&#xA;&amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot;&amp;gt;&#xA;&amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;&#xA;&amp;lt;/jsp:include&amp;gt;&#xA;&#xA;注：&#xA;1、page=&amp;quot;path&amp;quot; 为相对路径，或者代表相对路径的表达式。&#xA;2、flush=&amp;quot;true&amp;quot; 必须使用flush为true，它默认值是false。&#xA;3、&amp;lt;jsp:param&amp;gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&amp;lt;jsp:param&amp;gt;来传递多个参数给动态文件。&#xA;&#xA;二、Forward行为&#xA;&#xA;&amp;lt;jsp:forward&amp;gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} /&amp;gt;&#xA;or&#xA;&amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} &amp;gt;&#xA;&amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;……&#xA;&amp;lt;/jsp:forward&amp;gt;&#xA;&#xA;注：&#xA;1、page=&amp;quot;path&amp;quot; 为一个表达式，或者一个字符串。&#xA;2、&amp;lt;jsp:param&amp;gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&amp;lt;jsp:param&amp;gt;将多个参数发送到一个动态文件中。&#xA;&#xA;三、UseBean行为&#xA;&#xA;&amp;lt;jsp:useBean&amp;gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:useBean id=&amp;quot;name&amp;quot; scope=&amp;quot;page | request | session | application&amp;quot; typeSpec /&amp;gt;&#xA;其中typeSpec有以下几种可能的情况：&#xA;class=&amp;quot;className&amp;quot; | class=&amp;quot;className&amp;quot; type=&amp;quot;typeName&amp;quot; | beanName=&amp;quot;beanName&amp;quot; type=&amp;quot;typeName&amp;quot; | type=&amp;quot;typeName&amp;quot; |&#xA;&#xA;注：&#xA;你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。&#xA;&#xA;四、GetProperty行为&#xA;&#xA;&amp;lt;jsp:getProperty&amp;gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:getProperty name=&amp;quot;name&amp;quot; property=&amp;quot;propertyName&amp;quot; /&amp;gt;&#xA;&#xA;注：&#xA;1、在使用&amp;lt;jsp:getProperty&amp;gt;之前，必须用&amp;lt;jsp:useBean&amp;gt;来创建它。&#xA;2、不能使用&amp;lt;jsp:getProperty&amp;gt;来检索一个已经被索引了的属性。&#xA;3、能够和JavaBeans组件一起使用&amp;lt;jsp:getProperty&amp;gt;，但是不能与Enterprise Java Bean一起使用。&#xA;&#xA;五、SetProperty行为&#xA;&#xA;    &amp;lt;jsp:setProperty&amp;gt;标签表示用来设置Bean中的属性值。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;beanName&amp;quot; prop_expr /&amp;gt;&#xA;    其中prop_expr有以下几种可能的情形：&#xA;    property=&amp;quot;*&amp;quot; | property=&amp;quot;propertyName&amp;quot; | property=&amp;quot;propertyName&amp;quot; param=&amp;quot;parameterName&amp;quot; | property=&amp;quot;propertyName&amp;quot; value=&amp;quot;propertyValue&amp;quot;&#xA;&#xA;    注：&#xA;    使用 jsp:setProperty 来为一个Bean的属性赋值；可以使用两种方式来实现。&#xA;    1、在jsp:useBean后使用jsp:setProperty：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;myUser&amp;quot; … /&amp;gt;&#xA;    …&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;user&amp;quot; property=&amp;quot;user&amp;quot; … /&amp;gt;&#xA;    在这种方式中，jsp:setProperty将被执行。&#xA;    2、jsp:setProperty出现在jsp:useBean标签内：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;myUser&amp;quot; … &amp;gt;&#xA;    …&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;user&amp;quot; property=&amp;quot;user&amp;quot; … /&amp;gt;&#xA;    &amp;lt;/jsp:useBean&amp;gt;&#xA;    在这种方式中，jsp:setProperty只会在新的对象被实例化时才将被执行。&#xA;&#xA;    * 在&amp;lt;jsp:setProperty&amp;gt;中的name值应当和&amp;lt;jsp:useBean&amp;gt;中的id值相同。&#xA;&#xA;六、Plugin行为&#xA;&#xA;    &amp;lt;jsp:plugin&amp;gt;标签表示执行一个applet或Bean，有可能的话还要下载一个Java插件用于执行它。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:plugin&#xA;    type=&amp;quot;bean | applet&amp;quot;&#xA;    code=&amp;quot;classFileName&amp;quot;&#xA;    codebase=&amp;quot;classFileDirectoryName&amp;quot;&#xA;    [ name=&amp;quot;instanceName&amp;quot; ]&#xA;    [ archive=&amp;quot;URIToArchive, ...&amp;quot; ]&#xA;    [ align=&amp;quot;bottom | top | middle | left | right&amp;quot; ]&#xA;    [ height=&amp;quot;displayPixels&amp;quot; ]&#xA;    [ width=&amp;quot;displayPixels&amp;quot; ]&#xA;    [ hspace=&amp;quot;leftRightPixels&amp;quot; ]&#xA;    [ vspace=&amp;quot;topBottomPixels&amp;quot; ]&#xA;    [ jreversion=&amp;quot;JREVersionNumber | 1.1&amp;quot; ]&#xA;    [ nspluginurl=&amp;quot;URLToPlugin&amp;quot; ]&#xA;    [ iepluginurl=&amp;quot;URLToPlugin&amp;quot; ] &amp;gt;&#xA;    [ &amp;lt;jsp:params&amp;gt;&#xA;    [ &amp;lt;jsp:param name=&amp;quot;parameterName&amp;quot; value=&amp;quot;{parameterValue | &amp;lt;％= expression ％&amp;gt;}&amp;quot; /&amp;gt; ]+&#xA;    &amp;lt;/jsp:params&amp;gt; ]&#xA;    [ &amp;lt;jsp:fallback&amp;gt; text message for user &amp;lt;/jsp:fallback&amp;gt; ]&#xA;    &amp;lt;/jsp:plugin&amp;gt;&#xA;&#xA;    注：&#xA;    &amp;lt;jsp:plugin&amp;gt;元素用于在浏览器中播放或显示一个对象（典型的就是applet和Bean),而这种显示需要在浏览器的java插件。&#xA;    当Jsp文件被编译，送往浏览器时，&amp;lt;jsp:plugin&amp;gt;元素将会根据浏览器的版本替换成&amp;lt;object&amp;gt;或者&amp;lt;embed&amp;gt;元素。注意，&amp;lt;object&amp;gt;用于HTML 4.0 ，&amp;lt;embed&amp;gt;用于HTML 3.2。&#xA;    一般来说，&amp;lt;jsp:plugin&amp;gt;元素会指定对象是Applet还是Bean,同样也会指定class的名字，还有位置，另外还会指定将从哪里下载这个Java插件。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp函数&#34;&gt;&#xA;  jsp函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;用response.getOutputStream返回数据（而非JspWriter）时，调用：&#xA;    # 如输出图片对象：ImageIO.write(image, &amp;quot;jpeg&amp;quot;, response.getOutputStream());&#xA;    out.clear();        # 清空 out&#xA;    out = pageContext.pushBody()    # 将图片对象的流从out输出，直到整个输出结束（接收方网页加载全部完成时）后才断开&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp基本&#34;&gt;&#xA;  jsp基本&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%9f%ba%e6%9c%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;模板元素&#xA;脚本&#xA;&amp;lt;%    %&amp;gt;&#xA;脚本表达式&#xA;&amp;lt;%=    %&amp;gt;&#xA;注释&#xA;&amp;lt;%--    --%&amp;gt;&#xA;指令&#xA;    &amp;lt;%@ page%&amp;gt;&#xA;    language=&amp;quot;java&amp;quot;&#xA;    import=&amp;quot;java.util.*,java.io.*&amp;quot;&#xA;    contentType=&amp;quot;mineType [; charset=characterSet]&amp;quot;&#xA;    pageEncoding=&amp;quot;characterSet&amp;quot;&#xA;    session=&amp;quot;true&amp;quot;&#xA;    buffer=&amp;quot;none | 8kb | sizekb&amp;quot;&#xA;    autoFlush=&amp;quot;true&amp;quot;&#xA;    isThreadSafe=&amp;quot;true&amp;quot;&#xA;    info=&amp;quot;text&amp;quot;&#xA;    errorPage=&amp;quot;relative_url&amp;quot;&#xA;    isErrorPage=&amp;quot;true&amp;quot;&#xA;    isELIgnored=&amp;quot;true&amp;quot;&#xA;    &amp;lt;%@ include%&amp;gt;    # &amp;lt;%@ include file=&amp;quot;in.jspf&amp;quot; %&amp;gt; 是静态包含（原代码中包含），一般包含名字为*.jspf的jsp文件&#xA;    &amp;lt;%@ taglib%&amp;gt;    # 标签库&#xA;声明&#xA;    &amp;lt;%!    %&amp;gt;    # 全局声明（刷新页面仍然保存数据）&#xA;    &amp;lt;% %&amp;gt;    # 局部的声明（刷新页面不保存数据）&#xA;标签&#xA;    &amp;lt;jsp:forward page=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/jsp:forward&amp;gt;&#xA;    &amp;lt;jsp:include page=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/jsp:include&amp;gt;&#xA;内置对象 9个&#xA;    pageContext&#xA;    request&#xA;    response&#xA;    config&#xA;    session&#xA;    application&#xA;    page&#xA;    out&#xA;    exception&#xA;&#xA;    全局变量&#xA;    static final JspFactory        _jspxFactory&#xA;    static java.util.List        _jspx_dependants&#xA;    javax.el.ExpressionFactory    _el_expressionfactory&#xA;    org.apache.AnnotationProcessor    _jsp_annotationprocessor&#xA;    在_jspService中的变量&#xA;    HttpServletRequest        request&#xA;    HttpServletResponse        response&#xA;    PageContext        pageContext = null;&#xA;                pageContext = _jspxFactory.getPageContext(this,request,response,null,true,8192,ture);&#xA;    HttpSession        session = null;&#xA;                session = pageContext.getSession();&#xA;    ServletContext        application = null;&#xA;                application = pageContext.getServletContext();&#xA;    ServletConfig        config = null;&#xA;                config = pageContext.getServletConfig();&#xA;    JspWriter            out = null;&#xA;                out = pageContext.getOut();&#xA;    Object            page = this;&#xA;    JspWriter            _jspx_out = null;&#xA;                _jspx_out = out;&#xA;    PageContext        _jspx_page_context = null;&#xA;                _jspx_page_context = pageContext;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp验证码&#34;&gt;&#xA;  jsp验证码&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e9%aa%8c%e8%af%81%e7%a0%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;实例    # 在&amp;lt;img&amp;gt;标签的src属性中指定该jsp文件即可&#xA;&#xA;    ## out.clear();out = pageContext.pushBody();两条语句的作用是&#xA;    ## 使该验证码jsp文件的传输不会默认地在返回数据后中断，而是在&amp;lt;img&amp;gt;标签调用该jsp的页面加载结束之后再中断数据的传输&#xA;    &amp;lt;%@ page language=&amp;quot;java&amp;quot; pageEncoding=&amp;quot;UTF-8&amp;quot;%&amp;gt;&#xA;&amp;lt;%@ page contentType=&amp;quot;image/jpeg&amp;quot; import=&amp;quot;java.util.*,java.awt.*,java.awt.image.*,javax.imageio.*&amp;quot;%&amp;gt;&#xA;&amp;lt;%!&#xA;    // 声明区，定义产生颜色和验证内容的全局方法&#xA;    public Color getColor(){&#xA;&#xA;    Random random = new Random();&#xA;    int r = random.nextInt(256);&#xA;    int g = random.nextInt(256);&#xA;    int b = random.nextInt(256);&#xA;    return new Color(r,g,b);&#xA;    }&#xA;    public String getNum(){&#xA;    String str = &amp;quot;&amp;quot;;&#xA;    Random random = new Random();&#xA;    for(int i = 0; i &amp;lt; 4; i++){&#xA;        str += random.nextInt(10) + &amp;quot; &amp;quot;;&#xA;    }&#xA;    return str;&#xA;    }&#xA;%&amp;gt;&#xA;&amp;lt;%&#xA;    // 设置响应无缓存&#xA;    response.setHeader(&amp;quot;pragma&amp;quot;, &amp;quot;mo-cache&amp;quot;);&#xA;    response.setHeader(&amp;quot;cache-control&amp;quot;, &amp;quot;no-cache&amp;quot;);&#xA;    response.setDateHeader(&amp;quot;expires&amp;quot;, 0);&#xA;    // 图片对象,画笔对象&#xA;    BufferedImage image = new BufferedImage(80,30,BufferedImage.TYPE_INT_RGB);&#xA;    Graphics g = image.getGraphics();&#xA;    // 画背景&#xA;    g.setColor(new Color(200,200,200));&#xA;    g.fillRect(0, 0, 80, 30);&#xA;    // 画干扰线&#xA;    for(int i = 0; i &amp;lt; 30; i++){&#xA;    Random random = new Random();&#xA;    int x = random.nextInt(80);&#xA;    int y = random.nextInt(30);&#xA;    int xl = random.nextInt(x+10);&#xA;    int yl = random.nextInt(y+10);&#xA;    g.setColor(getColor());&#xA;    g.drawLine(x, y, x + xl, y + yl);&#xA;    }&#xA;    // 画内容&#xA;    g.setFont(new Font(&amp;quot;serif&amp;quot;, Font.BOLD,16));&#xA;    g.setColor(Color.BLACK);&#xA;    String checkNum = getNum();&#xA;    g.drawString(checkNum,15,20);&#xA;    // 放内容到session中，返回图片流&#xA;    session.setAttribute(&amp;quot;validateCode&amp;quot;, checkNum.replaceAll(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;));&#xA;    ImageIO.write(image, &amp;quot;jpeg&amp;quot;, response.getOutputStream());&#xA;    out.clear();&#xA;    out = pageContext.pushBody();    // 不按照jsp默认的getWriter()方法输出，用我们定义的流的方法进行输出&#xA;%&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;自定义标签&#34;&gt;&#xA;  自定义标签&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a0%87%e7%ad%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;1、JspTag 接口（标记接口，类以Serializable）&#xA;2、Tag 接口（空标签，如&amp;lt;img/&amp;gt;）&#xA;    属性：&#xA;    static int EVAL_BODY_INCLUDE        通过流执行标签体&#xA;    static int EVAL_PAGE              继续执行页面&#xA;    static int SKIP_BODY            忽略执行标签体&#xA;    static int SKIP_PAGE            忽略后面的JSP页面&#xA;    方法：&#xA;    // 生命周期方法&#xA;    int doEndTag()            当遇到标签结束的时候自动执行&#xA;    int doStartTag()            当遇到标签开始的时候自动执行&#xA;    // 实现方法&#xA;    Tag getParent()            获取当前标签的父标签处理类对象&#xA;    void release()            当事件改变的时候自动执行&#xA;    void setPageContext(PageContext pc)    设置当前的JSP上下文环境&#xA;    void setParent(Tag t)        设置当前标签的父标签对象&#xA;3、TagSupport 类（有属性的标签，如&amp;lt;img src=&amp;quot;&amp;quot;/&amp;gt;）&#xA;    实现了Tag接口并且提供处理标签属性的方法(set和get)。而且内部定义了一个PageContext变量并且已经初始化开发者可以直接使用this或者super直接方法该属性。&#xA;4、BodyTagSupport类（有属性有文本内容和标签，如&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;aaa&amp;lt;/img&amp;gt;）&#xA;    新属性&#xA;    protected  BodyContent bodyContent&#xA;    新方法&#xA;    void setBodyContent(BodyContent b)&#xA;    BodyContent getBodyContent()&#xA;&#xA;    BodyContent类&#xA;        abstract String getString()    //获取标签体&#xA;&#xA;    写Tag接口的标签库&#xA;    1、写Tag接口实现类&#xA;        写属性pageContext（getter 和setter），从setPageContext(PageContext pc)方法中获得该属性&#xA;        复写方法&#xA;    2、写tld文件，放到/META-INF文件夹中&#xA;        &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;        &amp;lt;taglib xmlns=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot;&#xA;        xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&#xA;        xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&amp;quot;&#xA;        version=&amp;quot;2.1&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;tlib-version&amp;gt;1.0&amp;lt;/tlib-version&amp;gt;&#xA;        &amp;lt;short-name&amp;gt;ouru&amp;lt;/short-name&amp;gt;    # 简称&#xA;        &amp;lt;uri&amp;gt;/outrun-tags&amp;lt;/uri&amp;gt;    # 自定义引入标签时写的路径&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;testDate&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.test.DataImplTag&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;empty&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;/taglib&amp;gt;&#xA;    3、jsp 中引用它&#xA;        &amp;lt;%@ taglib prefix=&amp;quot;ouru&amp;quot; uri=&amp;quot;/META-INF/myUtil.tld&amp;quot; %&amp;gt;&#xA;    写TagSupport接口的实现类&#xA;    pageContext已内置&#xA;    定义接收属性&#xA;    tld文件中加入attribute属性&#xA;        &amp;lt;attribute&amp;gt;        属性描述的开始&#xA;        &amp;lt;name&amp;gt;pattern&amp;lt;/name&amp;gt;    描述属性名&#xA;        &amp;lt;required&amp;gt;true&amp;lt;/required&amp;gt;    描述属性是否是必须的&#xA;        &amp;lt;rtexprvalue&amp;gt;true&amp;lt;/rtexprvalue&amp;gt;  描述属性值是否可以是输出表达式&#xA;        &amp;lt;/attribute&amp;gt;&#xA;    写BodyTagSupport接口的实现类&#xA;    BodyContent body = this.getBodyContent();&#xA;    String desc = body.getString();&#xA;&#xA;    tld 文件中&#xA;    &amp;lt;body-content&amp;gt;JSP&amp;lt;/body-content&amp;gt;    # 有标签体，可执行脚本表达式&#xA;                        ## scriptless，有标签体，不执委脚本表达式&#xA;                        ## empty,没有标签体&#xA;&#xA;Jsp2.0&#xA;    JspTag — SimpleTag — SimpleTagSupport&#xA;&#xA;    SimpleTagSupport类&#xA;    该类可以直接进行操作标签的属性和标签体。&#xA;    void doTag()                遇到标签的时候自动指定&#xA;    protected  JspFragment getJspBody()          获取标签体对象&#xA;    protected  JspContext getJspContext()      获取JSP上下文环境对象&#xA;    JspTag getParent()            获取该标签的父标签处理类对象&#xA;        JspFragment类&#xA;        该类代表的标签的标签体。&#xA;        abstract  void invoke(Writer out)    输出数据到指定的流，null输出到JSP页面&#xA;    获得标签体的方法：&#xA;        Writer writer = new StringWriter();&#xA;        JspFragment jspFragment = getJspBody();&#xA;        jspFragment.invoke(writer);&#xA;        String text = writer.toString();&#xA;    项目：实现 if else 判断&#xA;    Choose.java&#xA;        private boolean tag = true;&#xA;&#xA;        public boolean isTag() {&#xA;            return tag;&#xA;        }&#xA;&#xA;        public void setTag(boolean tag) {&#xA;            this.tag = tag;&#xA;        }&#xA;&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            getJspBody().invoke(null);&#xA;            super.doTag();&#xA;        }&#xA;    when.java 文件&#xA;        private boolean test = false;&#xA;        public boolean isTest() {&#xA;            return test;&#xA;        }&#xA;&#xA;        public void setTest(boolean test) {&#xA;            this.test = test;&#xA;        }&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            Choose parent = (Choose) getParent();&#xA;            if(isTest() &amp;amp;&amp;amp; parent.isTag()){&#xA;            // 条件成立&#xA;            getJspBody().invoke(null);&#xA;            // 设置父的tag为false&#xA;            parent.setTag(false);&#xA;            }&#xA;            super.doTag();&#xA;        }&#xA;    Otherwise.java 文件&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            Choose parent = (Choose) getParent();&#xA;            if(parent.isTag()){&#xA;            // 条件成立&#xA;            getJspBody().invoke(null);&#xA;            parent.setTag(false);&#xA;            }&#xA;            super.doTag();&#xA;        }&#xA;    tld文件&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;choose&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.Choose&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;    # 有标签体，可执行脚本表达式&#xA;                                ## scriptless，有标签体，不执委脚本表达式&#xA;                                ## empty,没有标签体&#xA;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;when&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.When&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;attribute&amp;gt;&#xA;        &amp;lt;name&amp;gt;test&amp;lt;/name&amp;gt;&#xA;        &amp;lt;required&amp;gt;true&amp;lt;/required&amp;gt;&#xA;        &amp;lt;rtexprvalue&amp;gt;true&amp;lt;/rtexprvalue&amp;gt;&#xA;        &amp;lt;/attribute&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;otherwise&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.Otherwise&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;&#xA;&#xA;控件标签：&#xA;自定义函数库&#xA;    1 创建函数库类&#xA;    public class MyFunctions {&#xA;    public static String formatMyName(String name) {&#xA;    return &amp;quot;your name is &amp;quot; + name;&#xA;    }&#xA;    public static int add(int a, int b) {&#xA;    return a+b;&#xA;    }&#xA;    }&#xA;&#xA;    2 在TLD文件中配置 (引用于目标1中的tld文件)&#xA;    &amp;lt;function&amp;gt;&#xA;    &amp;lt;name&amp;gt;formatMyName&amp;lt;/name&amp;gt;&#xA;    &amp;lt;function-class&amp;gt;com.taglib.MyFunctions&amp;lt;/function-class&amp;gt;&#xA;    &amp;lt;function-signature&amp;gt;java.lang.String formatMyName(java.lang.String)&amp;lt;/function-signature&amp;gt;&#xA;    &amp;lt;/function&amp;gt;&#xA;&#xA;    &amp;lt;function&amp;gt;&#xA;    &amp;lt;name&amp;gt;add&amp;lt;/name&amp;gt;&#xA;    &amp;lt;function-class&amp;gt;com.taglib.MyFunctions&amp;lt;/function-class&amp;gt;&#xA;    &amp;lt;function-signature&amp;gt;java.lang.String add(int, int)&amp;lt;/function-signature&amp;gt;&#xA;    &amp;lt;/function&amp;gt;&#xA;&#xA;    3 JSP中调用&#xA;&#xA;    ${cc:formatMyName(&amp;quot;wangfei&amp;quot;) }&#xA;    ${cc:add(12, 34) }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jdbc&#34;&gt;&#xA;  jdbc&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdbc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;流程&#xA;    Class.forName()     # 加载驱动&#xA;    DriverManager.getConnection()&#xA;    获得sql会话对象 Statement或PreparedStatement&#xA;    设置参数setXxx(), 执行sql，处理结果集&#xA;    关闭结果集、关闭会话、关闭连接&#xA;Statement&#xA;    execute&#xA;    executeQuery&#xA;    executeUpdate&#xA;    不要使用Statement&#xA;        容易sql注入&#xA;        代码可读性可维护性差&#xA;        PreparedStatement性能高，db缓存机制，相同预编译语句调用不再编译&#xA;PreparedStatement&#xA;    # 继承Statement, 预编译sql&#xA;&#xA;事务怎么写&#xA;    编程式&#xA;    声明式: 用aop注入&#xA;三种连接&#xA;    Connection&#xA;        默认自动提交&#xA;        禁止自动提交开启事务, 后调commit&#xA;    Pooled Connection&#xA;        使用完后不用关闭&#xA;    XA Connection&#xA;        分布式事务&#xA;        XAResource获得&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;i18n&#34;&gt;&#xA;  i18n&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#i18n&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;页面需要获取用户信息，从数据库中取数据显示&#xA;&#xA;java类中试用：&#xA;cn.itcast.resource包中&#xA;    hello_en_US.properties&#xA;    hello=hello&#xA;    hello_zh_CN.properties&#xA;    hello=编码后的“你好”&#xA;    Test.java&#xA;    #  获取信息&#xA;    Locale locale = locale.CHINA;&#xA;    #  加载资源&#xA;    ResourceBundle bundler = ResourceBundle.getBundle(&amp;quot;cn.itcast.resource.hello&amp;quot;,locale);&#xA;    #  取出数据&#xA;    String str = bundler.getString(&amp;quot;hello&amp;quot;);&#xA;&#xA;jsp中&#xA;&amp;lt;%&#xA;    ResourceBundle bundler = ResourceBundle.getBundle(&amp;quot;lang.properties.hello&amp;quot;, request.getLocale());&#xA;    out.write(bundler.getString(&amp;quot;title&amp;quot;));&#xA;%&amp;gt;&#xA;&amp;lt;fmt&amp;gt;标签&#xA;    &amp;lt;fmt:setLocale value=&amp;quot;${pageContext.request.locale }&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&#xA;    &amp;lt;fmt:setBundle basename=&amp;quot;lang.properties.hello&amp;quot; var=&amp;quot;bundler&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&#xA;    &amp;lt;fmt:message bundle=&amp;quot;${bundler }&amp;quot; key=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;/fmt:message&amp;gt;&#xA;资源转码&#xA;    native2ascii.exe&#xA;    myeclipse properties文件编辑器&#xA;ie 中得到en_US&#xA;Locale locale&#xA;    getLanguage();&#xA;    getCountry();&#xA;    getDefault();&#xA;ResourceBundle&#xA;    读取文件cn.itcast.resource.hello省略_en_US.properties&#xA;    getString(String key)&#xA;实例1：&#xA;    创建页面&#xA;    创建资源文件&#xA;    编辑页面&#xA;    request.getLocale();&#xA;    ResourceBundle.getBundle(&amp;quot;&amp;quot;,locale);&#xA;    getString(&amp;quot;&amp;quot;)&#xA;实例2：&#xA;    编辑页面&#xA;    &amp;lt;%@ taglib%&amp;gt;&#xA;    &amp;lt;f:setLocale scope=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;f:setBundle basename=&amp;quot;&amp;quot; var=&amp;quot;&amp;quot; scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;f:message bundle=&amp;quot;&amp;quot; key=&amp;quot;&amp;quot; &amp;gt;&#xA;动态数据国际化&#xA;日期国际化&#xA;    SimpleDateFormat    #  继承DateFormat&#xA;    getDateTimeInstance&#xA;    getDateInstance&#xA;    getTimeInstance&#xA;&#xA;    static int FULL&#xA;    static int LONG&#xA;    static int MEDIUM&#xA;    static int SHORT&#xA;实例3：&#xA;    cn.itcast.i18n.MyDateI18n&#xA;    DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);&#xA;    String str = format.format(new Date());&#xA;    解析页面中的字符串&#xA;    FULL 和 LONG  和 MEDIUM 和 SHORT 的 区别&#xA;    DataFomat&#xA;    String format(Date date)&#xA;    Date parse(String source)&#xA;    创建static string2Date(String str)&#xA;    #  分析区域&#xA;    Locale locale = Locale.CHINA;&#xA;&#xA;    #  分析日期的风格&#xA;    int dateType = DateFormat.SHORT;&#xA;    int timeType = DateFormat.FULL;&#xA;&#xA;    #  获取对象&#xA;    DateFormat format = DateFormat.getDateTimeInstance(dateType,timeType,locale);&#xA;&#xA;    #  解析&#xA;    format.parse(str);&#xA;动态数字国际化&#xA;    java.text.*;&#xA;    Number类&#xA;    NumberFormat(普通数字，货币，百分比)&#xA;    getIntegetInstance&#xA;    getCurrencyInstance&#xA;    getPercentInstance(Locale inLocale)&#xA;&#xA;    format&#xA;    parse&#xA;    创建cn.itcast.i18n.MyNumberI18n&#xA;    #  获取对象&#xA;    #  getPercentInstance&#xA;    #  getCurrencyInstance&#xA;    NumberFormat format = NumberFormat.getIntegerInstance(Locale.CHINA);&#xA;&#xA;    #  格式化 或解析&#xA;    long num = 10000000000L;&#xA;    #  Number num = format.parse(str);&#xA;    #  double price = num.doubleValue();&#xA;    format.format(num);&#xA;动态文本国际化&#xA;    At 12:30 pm on jul 3,1998, a hurricance destroyed 99 houses and caused $1000000 of damage.&#xA;    MessageFormat&#xA;    MessageFormat(String pattern,Locale locale)&#xA;    format(String pattern,Object...arguments)&#xA;    format(Object)&#xA;    parse()&#xA;    占位&#xA;    At{0}  on {0}, a hurricance destroyed{1} houses and caused {2} of damage.&#xA;&#xA;    实例1：&#xA;    MyMessageI18n.java&#xA;    #  定义模式字符串&#xA;    String pattern&#xA;    #  定义locale对象&#xA;    MessageFormat format = new MessageFormat(pattern,Locale.CHINA);&#xA;    #  定义参数数组&#xA;    DateFormat datef = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.SHORT,Locale.US);&#xA;    Date date = datef.parse(&amp;quot;Jul 3,1998 12:30 PM&amp;quot;);&#xA;&#xA;    Integer num = new Integer(99);&#xA;&#xA;    long currency = NumberFormat.getCurrencyInstance(Locale.US).parse(&amp;quot;$1000000&amp;quot;);&#xA;    String damage = NumberFormat.getCurrencyInstance(locale).format(currency);&#xA;&#xA;    Object [] values = {date,num,damage};&#xA;    #  格式化&#xA;    String str = format.format(values);&#xA;&#xA;    分析：{索引，对象，类型}&#xA;    MessageFormat messf = new MessageFormat(&amp;quot;{0,time,short} on {0,date}, a hurricance destroyed {1} houses and caused {2,number,currency} of damage.&amp;quot;,Locale.CHINA);&#xA;&#xA;    Object [] values = {new Date(),new Integer(100),1000};&#xA;&#xA;    String str = messf.format(values);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;中间件&#34;&gt;&#xA;  中间件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e9%97%b4%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;顺序&#xA;    监听器 -&amp;gt; 过滤器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;监听器&#34;&gt;&#xA;  监听器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e5%90%ac%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    ServletContextListener&#xA;    ServletContextAttributeListener&#xA;    HttpSessionListener&#xA;    HttpSessionAttributeListener&#xA;    HttpSessionActivationListener&#xA;web.xml 注册在过滤器后面，servlet前面&#xA;    &amp;lt;listener&amp;gt;&#xA;    &amp;lt;listener-class&amp;gt;cn.listen.MyListener&amp;lt;/listener-class&amp;gt;&#xA;    &amp;lt;/listener&amp;gt;&#xA;自定义&#xA;    public class MyListener implements ServletContextListener {&#xA;        public void contextDestroyed(ServletContextEvent sce) {&#xA;            System.out.println(&amp;quot;die&amp;quot;);&#xA;        }&#xA;        public void contextInitialized(ServletContextEvent sce) {&#xA;            System.out.println(&amp;quot;init&amp;quot;);&#xA;        }&#xA;&#xA;        // 当过滤器被销毁时自动执行&#xA;        public void destroy(){&#xA;            System.out.println(&amp;quot;Filterdestroyed&amp;quot;);&#xA;        }&#xA;        // 当拦截的时候&#xA;        public void doFilter(request,response,chain){&#xA;            System.out.println(&amp;quot;doFilter&amp;quot;);&#xA;            System.out.println(&amp;quot;放行目标资源&amp;quot;);&#xA;            chain.doFilter(request,response);&#xA;            System.out.println(&amp;quot;目标已经放行&amp;quot;);&#xA;        }&#xA;        // 初始化的时候&#xA;        public void init(FilterConfig config){&#xA;            System.out.println(&amp;quot;FilterInited&amp;quot;);&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;过滤器&#34;&gt;&#xA;  过滤器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%87%e6%bb%a4%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;web.xml&#xA;    &amp;lt;filter&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;testFilter&#xA;        &amp;lt;filter-class&amp;gt;cn.itcast.filter.text.TestFilter&#xA;        &amp;lt;init-param&amp;gt;&#xA;            &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;&#xA;            &amp;lt;param-value&amp;gt;GB2312&amp;lt;/param-value&amp;gt;&#xA;        &amp;lt;/init-param&amp;gt;&#xA;    &amp;lt;/filter&amp;gt;&#xA;    &amp;lt;filter-mapping&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;testFilter&#xA;        &amp;lt;url-pattern&amp;gt;/*&#xA;    &amp;lt;/filter-mapping&amp;gt;&#xA;&#xA;api&#xA;    Filter接口&#xA;        ## 多个过滤器, 按web.xml中注册的顺序映射调用。servlet执行完后, 从后向前返回执行chain.doFilter之后的方法&#xA;        init&#xA;        destroy&#xA;        doFilter(ServletRequest request, ServletResponse response, FilterChain chain)&#xA;    FilterChain接口&#xA;        doFilter(ServletRequest request, ServletResponse response)&#xA;    FilterConfig接口&#xA;        private FilterConfig config = null;&#xA;        init()&#xA;            this.config = config;&#xA;        doFilter()&#xA;            String ip = this.config.getInitParameter(&amp;quot;ip&amp;quot;);&#xA;&#xA;映射&#xA;    1.映射的url&#xA;    2.servlet的名字&#xA;        # 通配servlet &amp;lt;url-pattern&amp;gt;/servlet/*&amp;lt;/url-pattern&amp;gt;&#xA;    3.为了映射servlet中的转发, 映射一个过滤器到某种传递方式&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;            &amp;lt;dispatcher&amp;gt;FORWARD&#xA;                # FORWARD 转发方式&#xA;                # REQUEST  请求方式&#xA;                # INCLUDE  包含方式&#xA;                # ERROR  错误页面&#xA;            &amp;lt;/dispatcher&amp;gt;&#xA;        &amp;lt;/filter-mapping&amp;gt;&#xA;设置编码&#xA;    doFilter()&#xA;        HttpServletRequest httpRequest = (HttpServletRequest) request;&#xA;        HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;        httpRequest.setCharacterEncoding(&amp;quot;utf-8&amp;quot;)&#xA;        String method = httpRequest.getMethod();&#xA;        if(&amp;quot;get&amp;quot;.equalsIgnoreCase(method)){&#xA;            chain.doFilter(new MyWapperRequest(httpRequest),response);&#xA;        }else{&#xA;            request.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);&#xA;        }&#xA;&#xA;    class MyWapperRequest extends HttpServletRequestWrapper{&#xA;        private HttpServletRequest request = null;&#xA;&#xA;        public MyWapperRequest (HttpServletRequest request){&#xA;            super(request);&#xA;            this.request = request;&#xA;        }&#xA;&#xA;        @Override&#xA;        public String getParameter(String name){&#xA;            String value = request.getParameter(name);&#xA;            String method = request.getMethod();&#xA;            if(value != null &amp;amp;&amp;amp;&amp;quot;get&amp;quot;.equalsIgnoreCase(method)){&#xA;                value = new String(value.getBytes(&amp;quot;iso8859-1&amp;quot;),request.getCharacterEncoding())&#xA;            }&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;设置缓存&#xA;    # Expires:-1&#xA;    # Cache-Control:no-cache&#xA;    # Pragma:no-cache&#xA;&#xA;    NoCacheFilter implements Filter # 设置不缓存&#xA;        doFilter()&#xA;            HttpServletResponse httpResponse = response;&#xA;            httpResponse.setHeader(&amp;quot;Expires&amp;quot;,-1 + &amp;quot;&amp;quot;);&#xA;            //  setDataHeader(&amp;quot;expires&amp;quot;,-1);&#xA;            httpResponse.setHeader(&amp;quot;cache-control&amp;quot;,&amp;quot;no-cache&amp;quot;);&#xA;            httpResponse.setHeader(&amp;quot;pragma&amp;quot;,&amp;quot;no-cache&amp;quot;);&#xA;            chain.doFilter(request,httpResponse);&#xA;&#xA;&#xA;&#xA;    CacheFilter&#xA;        # 缓存静态资源&#xA;        # web.xml中url-pattern 可以映射多个 param-name=jpg param-value=2&#xA;        private FilterConfig config = null;&#xA;&#xA;        doFilter()&#xA;            HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;            HttpServletResponse httpRequest = (HttpServletRequest) request;&#xA;&#xA;        String resource = request.getRequestURI();&#xA;        String date  = null;&#xA;        if(resource.endsWith(&amp;quot;jpg&amp;quot;)){&#xA;            date =  config.getInitParameter(&amp;quot;jpg&amp;quot;);&#xA;            httpResponse.setDateHeader(&amp;quot;expires&amp;quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);    // 换算成秒&#xA;        } else if(resource.endsWith(&amp;quot;js&amp;quot;)){&#xA;            String date  = config.getInitParameter(&amp;quot;js&amp;quot;);&#xA;            config.getInitParameter(&amp;quot;js&amp;quot;);&#xA;            httpResponse.setDateHeader(&amp;quot;expires&amp;quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);&#xA;        }&#xA;&#xA;        chain.doFilter(httpRequest,httpResponse);&#xA;&#xA;修改编码&#xA;    EncodingFilter implements Filter{&#xA;        doFilter(request,response){&#xA;            HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;            HttpServletResponse httpRequest = (HttpServletRequest) request;&#xA;            httpRequest.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);&#xA;            chain.doFilter(httpRequest,httpResponse);&#xA;        }&#xA;    }&#xA;    class EncodingRequest extends HttpServletRequestWrapper{&#xA;        private HttpServletRequest request;&#xA;        public EncodingRequest (HttpServletRequest request){&#xA;            super(request);&#xA;            this.request = request;&#xA;        }&#xA;&#xA;        @Override&#xA;        public String getParameter(String name){&#xA;            String value = request.getParameter(name)&#xA;            if(value != null &amp;amp;&amp;amp; &amp;quot;get&amp;quot;.equalsIgnoreCase(request.getMethod)){&#xA;                value = new String(value.getBytes(&amp;quot;iso8859&amp;quot;),&amp;quot;utf-8&amp;quot;);&#xA;            }&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;登录&#xA;    LoginFilter&#xA;        init(){&#xA;            this.config  = config;&#xA;        }&#xA;        private FilterConfig config = null;&#xA;        doFilter(){&#xA;            String path = this.config.getInitParameter(&amp;quot;loginPage&amp;quot;);&#xA;            HttpSession session = httpRequest.getSession(false);&#xA;&#xA;            // 判断用户请求的是否是UserServlet&#xA;            String servletName = httpRequest.getServletPath();&#xA;            servletName = substring(servletName.lastIndexOf(&amp;quot;/&amp;quot;)+1);&#xA;            if(&amp;quot;UsersServlet&amp;quot;.equals(servletName)){&#xA;            }else{ // 一般的servlet&#xA;                if(session != null){&#xA;                    // 获取登录标记&#xA;                    User user = null;&#xA;                    user = (User)session.getAttribute(&amp;quot;user&amp;quot;);&#xA;&#xA;                    // 判断&#xA;                    if(user != null){&#xA;                        // 放行资源&#xA;                        chain.doFilter(httpRequest,httpResponse);&#xA;                    }else{&#xA;                        // 页面重定向到登录页面&#xA;                        httpResponse.sendRedirect(httpRequest.getContextPath() + &amp;quot;/&amp;quot; + path);&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    web.xml&#xA;        &amp;lt;filter&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;loginFilter&#xA;            &amp;lt;filter-class&amp;gt;&#xA;            &amp;lt;init-param&amp;gt;&#xA;                &amp;lt;param-name&amp;gt;loginPage&#xA;                &amp;lt;param-value&amp;gt;&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;/jsps/*&#xA;                &amp;lt;url-pattern&amp;gt;/servlet/*&#xA;                &amp;lt;url-pattern&amp;gt;/publics/*&#xA;            &amp;lt;filter-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;/publics/head.jsp&#xA;                &amp;lt;dispatcher&amp;gt;INCLUDE&#xA;                &amp;lt;dispatcher&amp;gt;FORWARD&#xA;                &amp;lt;dispatcher&amp;gt;ERROR&#xA;                &amp;lt;dispatcher&amp;gt;REQUEST&#xA;                    # 默认是request，当加上其它参数时（如include），request会没有，所以要加两个forward,request&#xA;                    ## 是指向里面以该方法请求的时候进行过滤&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;struts2&#34;&gt;&#xA;  struts2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#struts2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Java并发</title>
      <link>https://runout.run/docs/pl/java/juc/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/juc/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;并发编程三大特性&#xA;    可见性(visibility)&#xA;        synchronized会刷新线程栈&#xA;    有序性(ordering)&#xA;    原子性(atomicity)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  CPU&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;PC寄存器(Program Counter Register, 存下一指令)&#xA;优化&#xA;    乱序读&#xA;    合并写&#xA;    乱序执行(流水线)&#xA;ALU&#xA;    访问速度&#xA;        Registers: &amp;lt; 1ns&#xA;        L1 cache(核内): 1ns&#xA;        WC(Writer Comblining) Buffer    # 合并写, 一般4个字节&#xA;        L2 cache(核内): 3ns&#xA;        L3 cache(CPU内): 15ns&#xA;        memory: 80ns&#xA;局部性原理&#xA;    空间&#xA;        按块读取(cache line)&#xA;            一次读64Bytes               # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知&#xA;            Java1.8注解@Contended       # 保证不在同一行，需要JVM参数-XX:-RestrictContended&#xA;    时间&#xA;        批量读指令&#xA;内存屏障                        # 不同CPU不一样&#xA;    Intel&#xA;        sfence                      # save, 之前写操作必须完成&#xA;        lfence                      # load, 之前读操作必须完成&#xA;        mfence                      # mix(save + load)&#xA;lock指令                            # 指令执行完之前，锁内存&#xA;    lock_add&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;cpu缓存一致性协议&#34;&gt;&#xA;  CPU缓存一致性协议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁&#xA;状态&#xA;    MESI Cache一致性协议                    # Intel CPU，实现方式为主动监听&#xA;        Modified                            # 一行数据在CPU Modified, 其它CPU为Invalid&#xA;        Exclusive                           # 独享，其它CPU没有&#xA;        Shared                              # 别人也在读&#xA;        Invalid                             # 别人改过了&#xA;    MSI&#xA;    MOSI&#xA;缓存行                                      # 多数64字节&#xA;    伪共享                                  # 缓存行内无关数据也要同步&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;os&#34;&gt;&#xA;  OS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#os&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;进程&#xA;    # 资源分配&#xA;线程&#xA;    # 调度执行&#xA;    切换(Context Switch)&#xA;        CPU导出原线程指令和data到cache, 再导入新线程数据&#xA;    线程数&#xA;        N(threads) = N(CPU) * U(CPU) * (1 + W/C)&#xA;            # N(CPU): CPU数&#xA;            # U(CPU): 期望CPU利用率, 0到1&#xA;            # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析&#xA;        压测决定&#xA;CPU性能压榨&#xA;    单进程&#xA;    批处理&#xA;    多进程切换&#xA;    多线程进程内切换&#xA;        I/O复用&#xA;    协程(纤程、绿色线程)用户空间切换&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jvm&#34;&gt;&#xA;  JVM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;内存屏障&#34;&gt;&#xA;  内存屏障&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;LoadLoad&#xA;StoreStore&#xA;LoadStore&#xA;StoreLoad&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;乱序执行指令重排序&#34;&gt;&#xA;  乱序执行(指令重排序)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;为什么&#xA;    CPU快, 指令1阻塞时，指令2先执行&#xA;判断&#xA;    代码不影响单线程最终一致性&#xA;例子，多线程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0, b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Long.&lt;span style=&#34;color:#a6e22e&#34;&gt;MAX_VALUE&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&amp;gt;&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                x&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                y&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                CountDownLatch latch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CountDownLatch(2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Thread one &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Thread other &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                one.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                other.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;例子，类初始化指令换顺序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 8;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        T t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; T();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        汇编码&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            0 &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 变量半初始化状态为0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            3 dup&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            4 invokespecial &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;3 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T.&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;init&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            7 astore_1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;线程访问时中间状态逸出&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            8 &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;)).&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; C();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#a6e22e&#34;&gt;in&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;unsafe类&#34;&gt;&#xA;  Unsafe类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#unsafe%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 相当于指针。1.8只能根部类用, 11可以直接用&#xA;操作内存&#xA;    allocateMemory&#xA;    putXX&#xA;    freeMemory&#xA;    pageSize&#xA;生成类实例&#xA;    allocateInstance&#xA;操作类或实例&#xA;    objectFieldOffset&#xA;    getInt&#xA;    getObject&#xA;CAS&#xA;    compareAndSwapObject()          # JDK1.8&#xA;    compareAndSetObject()&#xA;    weakCompareAndSetObject()       # JDK11&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;修饰符与锁&#34;&gt;&#xA;  修饰符与锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e4%b8%8e%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;&#xA;  概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;锁细化                              # 少代码加轻量锁&#xA;锁粗化                              # 锁太多时，如行锁变表锁&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;synchronized&#34;&gt;&#xA;  synchronized&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;实现方式&#xA;    JVM没要求实现方式&#xA;    早期都是OS调度&#xA;    HotSpot&#xA;        在对象头(64位)上用2位实现，组合成锁的类型&#xA;        锁升级                      # 不比原子类慢，升完不降&#xA;            偏向锁, 第一个线程第一次访问只记线程id&#xA;            自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平&#xA;            重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景&#xA;原子性、可见性&#xA;可重入                              # 同一个对象同线程可重入&#xA;加锁对象&#xA;    方法锁和对象锁锁this&#xA;    static方法锁和类锁锁class类&#xA;    继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象&#xA;使用注意&#xA;    抛异常立即释放锁，但被锁数据已更新&#xA;    不能用的对象&#xA;        String常量，可能未知地方锁同一个&#xA;        Integer、Long等基本类型, 值变化会生成新对象&#xA;    synchronized的属性加final防止赋值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;volatile&#34;&gt;&#xA;  volatile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#volatile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 用synchronized性能差不多，volatile一般不用&#xA;作用&#xA;    # 没有原子性，可能写同一值&#xA;    变量在线程见可见性&#xA;        依靠CPU缓存一致性协议&#xA;    禁止指令重排序                  # 用JVM的读写屏障&#xA;        &#xA;修饰引用类型，内部属性不监控&#xA;&#xA;DCL(Double Check Lock)单例volatile问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; C c;    &lt;span style=&#34;color:#75715e&#34;&gt;// 禁止了创建c指令重排序&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;(){}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; C &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (C.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// 申请内存(半初始化状态默认0)，成员变量初始化，赋值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; C();    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; c;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cas&#34;&gt;&#xA;  CAS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Compare And Set/Swap, 无锁优化, 乐观锁, 自旋&#xA;# Unsafe类支持&#xA;CPU原语&#xA;    cas(V, Expected, NewValue)&#xA;        if V == E                   # 无并发值判断问题，原语上加了屏障&#xA;        V = New&#xA;        else try again or fail&#xA;Java&#xA;    AtomicInteger&#xA;        incrementAndGet()&#xA;ABA问题&#xA;    # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据&#xA;    版本号                          # Java版本号类AtomicStampedReference&#xA;LongAdder&#xA;    LongAdder每次加数字, LongAccumulator用lambda&#xA;    分段锁(CAS)。值分开放数组里, 多线程对应一个item&#xA;性能测试&#xA;    LongAdder(713) &amp;gt; Atomic(2166) &amp;gt; Synchronized(3129)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;锁&#34;&gt;&#xA;  锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;aqs&#34;&gt;&#xA;  AQS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种&#xA;# 实现方式: CAS，volatile, 模板方法&#xA;类图&#xA;    AbstractQueueSynchronizer&#xA;        Sync&#xA;            NonfairSync&#xA;方法&#xA;    AbstractQueueSynchronizer&#xA;        # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待)&#xA;        Node&#xA;            volatile Node prev&#xA;            volatile Node next&#xA;            volatile Thread thread&#xA;        VarHandle&#xA;            # JDK1.9，保存引用，普通属性原子操作。&#xA;            # 相比反射，直接操作二进制码&#xA;            get()&#xA;            set()&#xA;            compareAndSet()         # 原子性&#xA;            getAndAdd()             # 原子性&#xA;            class C {&#xA;                int x = 0;&#xA;                private static VarHandle handle;&#xA;                static {&#xA;                    handle = MethodHandles.lookup().findVarHandle(C.class, &amp;quot;x&amp;quot;, int.class)&#xA;                    handle.compareAndSet(c, 0, 1);&#xA;&#xA;                }&#xA;            }&#xA;        volatile state              # 多态实现&#xA;        acquire()&#xA;        tryAcquire()                # 模板方法&#xA;        acquireQueued()             # 获得&#xA;        addWaiter(Node.EXCLUSIVE)   # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表)&#xA;        cancelAcquire()             # status CANCELLED, tail时设置null, 非tail时unpark下一节点&#xA;    NonfairSync&#xA;        nonfairTryAcquire()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reentrantlock&#34;&gt;&#xA;  ReentrantLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reentrantlock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 可重入锁，CAS实现, state记重入多少次&#xA;    new ReentrantLock(true)         # 公平锁&#xA;    tryLock(long, TimeUnit)&#xA;    lockInterruptibly()             # 响应interrupt()标记&#xA;    newCondition()                  # 多一个等待队列&#xA;&#xA;    源码&#xA;        调NonfairSync&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;countdownlatch&#34;&gt;&#xA;  CountDownLatch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#countdownlatch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 比join()灵活&#xA;    new CountDownLatch(4)&#xA;    countDown()&#xA;    await()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;cyclicbarrier&#34;&gt;&#xA;  CyclicBarrier&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cyclicbarrier&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 满了一起放行, 场景如I/O批量消费&#xA;    new CyclicBarrier(4, ()-&amp;gt;{})&#xA;    await()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;phaser&#34;&gt;&#xA;  Phaser&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#phaser&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 阶段批量执行过滤&#xA;    class MyPhaser extends Phaser {&#xA;        @Override&#xA;        protected boolean onAdvance(int phase, int registeredParties) {&#xA;            switch(phase) {&#xA;                case 0:&#xA;                    print(&amp;quot;arrived&amp;quot; + registeredParties);&#xA;                    return false;&#xA;                case 1:&#xA;                    print(&amp;quot;eated&amp;quot; + registeredParties);&#xA;                    return false;&#xA;                case 2:&#xA;                    print(&amp;quot;hugged&amp;quot; + registeredParties);&#xA;                    return true;&#xA;                default:&#xA;                    return true;&#xA;            }&#xA;        }&#xA;    }&#xA;    Person implements Runnable {&#xA;        private int i;&#xA;        public Person(int i) {&#xA;            this.i = i;&#xA;        }&#xA;        public void arrive() {&#xA;            phaser.arriveAndAwaitAdvance();&#xA;        }&#xA;        public void eat() {&#xA;            phaser.arriveAndAwaitAdvance();&#xA;        }&#xA;        public void hug() {&#xA;            if (i == 0 || i == 1) {&#xA;                phaser.arriveAndAwaitAdvance();&#xA;            } else {&#xA;                phaser.arriveAndDeregister();&#xA;            }&#xA;        }&#xA;&#xA;        @Override&#xA;        public void run() {&#xA;            arrive();&#xA;            eat();&#xA;            hug();&#xA;        }&#xA;    }&#xA;    phaser = new MyPhaser();&#xA;    phaser.bulkRegister(5);&#xA;    for (int i = 0; i &amp;lt; 5; i++) {&#xA;        new Thread(new Person(i)).start()&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;readwritelock&#34;&gt;&#xA;  ReadWriteLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readwritelock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 读锁是共享锁，不能写，悲观锁&#xA;    # 写锁是排他锁，不能读写&#xA;    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();&#xA;    Lock readLock = readWriteLock.readLock();&#xA;    Lock writeLock = readWriteLock.writeLock();&#xA;    void read(Lock lock) {&#xA;        lock.lock()&#xA;        lock.unlock()&#xA;    }&#xA;    void write(Lock lock) {&#xA;        lock.lock()&#xA;        lock.unlock()&#xA;    }&#xA;    for (int i =0; i&amp;lt;10;i++) {&#xA;        new Thread(()-&amp;gt;read(readLock)).start();&#xA;    }&#xA;    for (int i =0; i&amp;lt;2; i++) {&#xA;        new Thread(()-&amp;gt;write(writeLock)).start();&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;stampedlock&#34;&gt;&#xA;  StampedLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stampedlock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 读时允许写，读完判断不一致再读一遍，乐观锁&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;semaphore&#34;&gt;&#xA;  Semaphore&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#semaphore&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 信号量, 限流同时运行, 用于线程间同步。可设置公平&#xA;    Semaphore s = new Semaphore(1, true)&#xA;    new Thread(() -&amp;gt; {&#xA;        s.acquire();&#xA;        s.release()&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;exchanger&#34;&gt;&#xA;  Exchanger&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#exchanger&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 线程间通信, 阻塞交换&#xA;    exchange()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;locksupport&#34;&gt;&#xA;  LockSupport&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#locksupport&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 线程间通信，非锁阻塞，指定线程唤醒&#xA;    # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1)&#xA;    Thread t = new Thread(() -&amp;gt; {&#xA;        for (int i = 0; i &amp;lt; 10; i++) {&#xA;            if (i == 5) {&#xA;                LockSupport.park();&#xA;            }&#xA;        }&#xA;    })&#xA;    t.start();&#xA;    TimeUnit.SECONDS.sleep(1);&#xA;    LockSupport.unpark(t);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;线程及线程池&#34;&gt;&#xA;  线程及线程池&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%8f%8a%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;使用注意&#34;&gt;&#xA;  使用注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;为什么不用Executors线程池&#xA;    用LinkedBlockingQueue超数量OOM&#xA;    拒绝策略&#xA;    线程命名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类&#34;&gt;&#xA;  类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Object&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;wait&lt;/span&gt;()                              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 释放synchronized锁并加入等待队列&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;唤醒后执行需要得到synchronized锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;notify&lt;/span&gt;()                            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 只唤醒&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不释放当前synchronized锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentThread&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yield&lt;/span&gt;()                      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 让出CPU, 进Ready队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        getState()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        join()                              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 等待结束&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;setDaemon&lt;/span&gt;()                         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 是否后台&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;setPriority&lt;/span&gt;(Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;NORM_PRIORITY&lt;/span&gt;)   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 优先级&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;没有用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Runnable&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Callable&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        V &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Future&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        get(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cancel(&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        isCanceled()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        isDone()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RunnableFuture&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FutureTask&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompletableFuture&lt;/span&gt;         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; parallel&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;supplyAsync&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;allOf&lt;/span&gt;(CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;...)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;anyOf&lt;/span&gt;(CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;...)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            T &lt;span style=&#34;color:#a6e22e&#34;&gt;join&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;thenApply&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;thenAccept&lt;/span&gt;(Consumer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadFactory&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread &lt;span style=&#34;color:#a6e22e&#34;&gt;newThread&lt;/span&gt;(Runnable)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DefaultThreadFactory&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Executor&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExecutorService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;shutdown&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            shutdownNow()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            isShutdown()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            isTerminated()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            awaitTermination(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Future &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Future &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Runnable, T)                     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 手动设个result&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Runnable)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; AbstractExecutorService&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                RunnableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newTaskFor&lt;/span&gt;(Runnable, T)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                RunnableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newTaskFor&lt;/span&gt;(Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                T &lt;span style=&#34;color:#a6e22e&#34;&gt;doInvokeAny&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; timed, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                submit()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 忽略CancellationException, ExecutionException&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其它异常抛出并取消未完成任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;invokeAll&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 忽略CancellationException, ExecutionException, TimeoutException&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其它异常抛出并取消未完成任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;invokeAny&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadPoolExecutor&lt;/span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 线程池&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;任务队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 任务顺序: 核心线程, 任务队列&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;起新线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;拒绝策略&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledThreadPoolExecutor&lt;/span&gt;       &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 用DelayedWorkQueue&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#a6e22e&#34;&gt;scheduleAtFixedRate&lt;/span&gt;(()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{}, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; initial, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; period, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ForkJoinPool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;(ForkJoinTask)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledExecutorService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompletionService&lt;/span&gt;                             &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 不阻塞全部任务&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;已有结果入队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExecutorCompletionService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Executors&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newSingleThreadExecutor&lt;/span&gt;()                           &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 为了用任务队列和生命周期管理&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newCachedThreadPool&lt;/span&gt;()                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 超时60s, max为MAX_VALUE, 任务不堆积场景&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newFixedThreadPool&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        newScheduledThreadPool()                            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; AbstractQueuedSynchronizer&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newWorkStealingPool&lt;/span&gt;()                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; ForkJoinPool, go的M,G,P&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 每个线程单独队列, 尾部偷加尾部&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;创建线程&#34;&gt;&#xA;  创建线程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 继承&#xA;class MyThread extendws Thread {&#xA;    @Override&#xA;    public void run(){}&#xA;}&#xA;new MyThread().start();&#xA;&#xA;# 组合&#xA;class MyRun implements Runnable {&#xA;    @Override&#xA;    public void run(){}&#xA;}&#xA;new Thread(new MyRun()).start();&#xA;&#xA;# 返回值&#xA;class myCall implements Callable&amp;lt;String&amp;gt; {&#xA;    @Override&#xA;    public String call(){}&#xA;}&#xA;FutureTask = ft = new FutureTask&amp;lt;String&amp;gt;(new MyCall())&#xA;new Thread(ft).start();&#xA;ft.get();&#xA;&#xA;# 线程池&#xA;// execute无返回值&#xA;ExecutorService service = Executors.newCachedThreadPool()&#xA;service.execute(()-&amp;gt;{});&#xA;// submit有返回值 &#xA;Future&amp;lt;String&amp;gt; f = service.submit(new MyCall());&#xA;service.shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程状态&#34;&gt;&#xA;  线程状态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;NEW&#xA;RUNNABLE            # 可调度&#xA;    READY&#xA;    RUNNING&#xA;WAITING             # 等待唤醒，忙等待(一直占CPU)&#xA;    o.wait()&#xA;    t.join()&#xA;    LockSupport.park()&#xA;    Lock.lock()&#xA;&#xA;    o.notify()&#xA;    o.notifyAll()&#xA;    LockSupport.unpark()&#xA;    Lock.unlock()&#xA;TIMED WAITING&#xA;    Thread.sleep(time)&#xA;    o.wait(time)&#xA;    t.join(time)&#xA;    LockSupport.parkNanos()&#xA;    LockSupport.parkUntil()&#xA;BLOCKING            # 阻塞等待（不占CPU但经过OS调度)&#xA;    synchronized&#xA;TERMINATED&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程打断&#34;&gt;&#xA;  线程打断&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%89%93%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法 &#xA;    interrupt()                 # 设置打断标记位&#xA;    isInterrupted()             # 检查标记位&#xA;    static interrupted()        # 检查当前线程标记位，并重置&#xA;检测当前线程打断标记的方法      # 抛异常并重置&#xA;    Thread.sleep()&#xA;    o.wait();&#xA;    o.join();&#xA;    ReentrantLock&#xA;        lockInterruptibly()&#xA;不检测当前线程打断标记的方法&#xA;    synchronized                # 不是代码实现检测不了&#xA;    ReentrantLock&#xA;        lock()&#xA;强制打断&#xA;    Thread&#xA;        stop()                  # 已废弃, 立即释放所有锁&#xA;        suspend()               # 已废弃，强制暂停，所有锁不释放容易死锁&#xA;        resume()                # 已废弃，强制恢复&#xA;volatile&#xA;    判断数字不准，有同步的时间延迟, interrupt()也有延迟&#xA;    也需要代码中判断, 但interrupt()有wait()等系统方法支持&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程间通信&#34;&gt;&#xA;  线程间通信&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;通知&#34;&gt;&#xA;  通知&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%9a%e7%9f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# synchronized wait() notify(), CountDownLatch, LockSupport&#xA;volatile List c = new ArrayList();&#xA;final Object lock = new Object();&#xA;new Thread(() -&amp;gt; {&#xA;    synchronized(lock) {&#xA;        if (c.size() != 5) {&#xA;            lock.wait();&#xA;        }&#xA;        lock.notify();              // 唤醒t1&#xA;    }&#xA;}, &amp;quot;t2&amp;quot;).start();&#xA;&#xA;TimeUnit.SECONDS.sleep(1);&#xA;&#xA;new Thread(() -&amp;gt; {&#xA;    synchronized(lock) {&#xA;        for (int i = 0; i &amp;lt; 10; i++) {&#xA;            c.add(new Object());&#xA;            if (c.size() == 5) {&#xA;                lock.notify();&#xA;                lock.wait();        // 让出sychronized锁&#xA;            }&#xA;        }&#xA;    }&#xA;}, &amp;quot;t1&amp;quot;).start();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;生产消费&#34;&gt;&#xA;  生产消费&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e4%ba%a7%e6%b6%88%e8%b4%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 优化count可以用CAS加(有ABA问题)&#xA;class MyContainer&amp;lt;T&amp;gt; {&#xA;    final private List&amp;lt;T&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&#xA;    final private int MAX = 10;&#xA;    private int count = 0;&#xA;&#xA;    public synchronized void put(T t) {&#xA;        while(list.size() == MAX) {&#xA;            this.wait();            // 期间可能有add() &#xA;        }&#xA;        list.add(t);&#xA;        count++;&#xA;        this.notifyAll();           // 应该只唤醒消费者&#xA;    }&#xA;&#xA;    public synchronized T get() {&#xA;        T t = null;&#xA;        while(list.size() == 0) {&#xA;            this.wait();&#xA;        }&#xA;        t = list.removeFirst();&#xA;        count--;&#xA;        this.notifyAll();           // 应该只唤醒生产者&#xA;        return t;&#xA;    }&#xA;}&#xA;&#xA;# 同步容器, ReentrantLock Condition&#xA;private Lock lock = new ReentrantLock();&#xA;private Condition producer = lock.newCondition();&#xA;private Condition consumer = lock.newCondition();&#xA;&#xA;public void put(T t) {&#xA;    try {&#xA;        lock.lock();&#xA;        while(list.size() == MAX) {&#xA;            producer.await();&#xA;        }&#xA;        list.add(t);&#xA;        count++;&#xA;        consumer.signalAll();&#xA;    } finally {&#xA;        lock.unlock();&#xA;    }&#xA;}&#xA;&#xA;public T get() {&#xA;    T t = null;&#xA;    try {&#xA;        lock.lock();&#xA;        while(list.size() == 0) {&#xA;            consumer.await();&#xA;        }&#xA;        t = list.removeFirst();&#xA;        count--;&#xA;        producer.signalAll();&#xA;    } finally {&#xA;        lock.unlock();&#xA;    }&#xA;    return t;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;协程&#34;&gt;&#xA;  协程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%8f%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;quasar库                            # 需要设javaagent, 每个fiber生成栈&#xA;    fiber =  new Fiber&amp;lt;Void&amp;gt;()&#xA;    fiber.start()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发api&#34;&gt;&#xA;  并发API&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;stream&#34;&gt;&#xA;  Stream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;parallelStream()                    # ForkJoinPool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;threadlocal&#34;&gt;&#xA;  ThreadLocal&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;内部类&#xA;    ThreadLocalMap&amp;lt;ThreadLocal, Object&amp;gt;&#xA;        # 存在每个线程里。场景如声明式事务拿conn&#xA;        # key是弱引用指向ThreadLocal, value是强引用。&#xA;    Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {&#xA;        Object value;&#xA;        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&#xA;            super(k);&#xA;            value = v;&#xA;        }&#xA;    }&#xA;方法&#xA;    set(T)&#xA;内存泄露问题&#xA;    ThreadLocal&amp;lt;M&amp;gt; tl = new ThreadLocal();&#xA;    tl.set(new M());&#xA;    tl = null;&#xA;        # threadLocalMap中key弱引用回收, value不回收&#xA;    tl.remove();&#xA;        # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pipedstream&#34;&gt;&#xA;  PipedStream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pipedstream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 效率不高&#xA;PipedInputStream&#xA;    connect(PipedOutputStream)&#xA;    read(byte[])&#xA;PipedOutputStream&#xA;    write(byte[])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jmh&#34;&gt;&#xA;  JMH&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmh&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Java Microbenchmark Harness&#xA;概念&#xA;    Warmup                              # 预热&#xA;    Mesurement                          # 总执行次数&#xA;    Timeout                             # 每次执行超时时间&#xA;    Threads                             # fork线程数&#xA;    Benchmark mode                      # 模式&#xA;    Benchmark                           # 方法名&#xA;环境变量&#xA;    TEMP或TMP                           # JHM临时文件存放&#xA;使用&#xA;    @Benchmark&#xA;    @Warmup(iterations = 2, time = 3)           # 执行2次, 每次隔3秒&#xA;    @Fork(5)                                    # 多少线程&#xA;    @BenchmarkMode(Mode.Throughput)             # 显示每秒多少次&#xA;    @Measurement(iterations = 10, time = 3)     # 共测10次, 每次隔3秒&#xA;    public void testA() {&#xA;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;disruptor&#34;&gt;&#xA;  Disruptor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#disruptor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    CAS, 环形数组Buffer&#xA;        数组用sequence定位修改快,也避免了头尾加锁&#xA;        直接覆盖降低GC&#xA;            覆盖前有等待策略&#xA;    单机MQ&#xA;        发布订阅模式&#xA;        观察者模式&#xA;    EventFactory&#xA;        会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC&#xA;使用&#xA;    class MyEvent {}&#xA;    class MyEventFactory implements EventFactory&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        public MyEvent newInstance() {}&#xA;    }&#xA;    class MyEventHandler implements EventHandler&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        void onEvent(MyEvent, long sequence, boolean endOfBatch) {}&#xA;    }&#xA;    class MyExceptionHandler implements ExceptionHandler&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        void handleEventException()&#xA;        @Override&#xA;        void handleOnStartException()&#xA;        @Override&#xA;        void handleOnShutdownException()&#xA;    }&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(factory, 1024, Executors,defaultThreadFactory())&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(MyEvent::new, 1024, Executors,defaultThreadFactory())&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(factory, 1024, Executors,defaultThreadFactory(), &#xA;        ProducerType.SINGLE, new BlockingWaitStrategy())&#xA;        # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁&#xA;    // 消费&#xA;    disruptor.handleEventsWith(handler1, handler2)&#xA;    disruptor.handleEventsWith((event,seq,end)-&amp;gt;{})&#xA;    disruptor.handleExceptionsFor(handler1).with(excptionHandler1)&#xA;&#xA;    disruptor.start()&#xA;&#xA;    // 生产&#xA;    ringBuffer = disruptor.getRingBuffer()&#xA;    sequence = ringBuffer.next()&#xA;    event = ringBuffer.get(sequence)&#xA;    event.set(&amp;quot;&amp;quot;)&#xA;    ringBuffer.publish(sequence)&#xA;    translator = new EventTranslator&amp;lt;&amp;gt;() {&#xA;        @Override&#xA;        void translateTo(event, sequence) {&#xA;            event.set(&amp;quot;&amp;quot;)&#xA;        }&#xA;    }&#xA;    ringBuffer.publishEvent(translator)&#xA;    ringBuffer.publishEvent((event,seq, &amp;quot;&amp;quot;) -&amp;gt; event.set(l), &amp;quot;&amp;quot;)&#xA;等待策略&#xA;    BlockingWaitStrategy                # 阻塞直到再次唤醒&#xA;    BusySpinWaitStrategy                # 自旋等待&#xA;    SleepingWaitStrategy                # sleep等待&#xA;    LiteBlockingWaitStrategy            # 同BlockingWaitStrategy减少加锁次数                &#xA;    LiteTimeoutBlockingWaitStrategy     # 同LiteBlockingWaitStrategy加超时            &#xA;    PhasedBackoffWaitStrategy&#xA;    TimeoutBlockingWaitStrategy         # 同BlockingWaitStrategy加超时                &#xA;    YieldingWaitStrategy                # 尝试100然后Thread.yield()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;源码分析&#34;&gt;&#xA;  源码分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;threadpoolexecutor&#34;&gt;&#xA;  ThreadPoolExecutor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadpoolexecutor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;new ThreadPoolExecutor()                    &#xA;    int corePoolSize                    # 核心线程数, 永远存活。可设置参与回收&#xA;    int maximumPoolSize                 # 最大线程数&#xA;    long keepAliveTime                  # 生存时间&#xA;    TimeUnit&#xA;    BlockingQueue&amp;lt;Runnable&amp;gt;             # 任务队列&#xA;    ThreadFactory                       # 线程工厂, 设线程名&#xA;    RejectedExecutionHandler            # 拒绝策略&#xA;        Abort                           # 抛异常&#xA;        Discard                         # 忽略掉&#xA;        DiscardOldest                   # 忽略掉排除最久的&#xA;        CallerRuns                      # 调用者线程执行, 再多就阻塞&#xA;AtomicInteger ctl&#xA;    # 高3位线程池状态，低29位线程数量&#xA;void execute()&#xA;    判断添加核心线程&#xA;    放入队列成功&#xA;        拒绝或添加非核心线程&#xA;    添加非核心线程失败&#xA;        拒绝&#xA;boolean addWorker(Runable, boolean)&#xA;    线程数量加1&#xA;    添加Worker&#xA;        加锁&#xA;        加线程&#xA;        启动&#xA;class Worker extends AbstractQueuedSynchronizer implements Runnable&#xA;    # 本身是AQS锁, 被多任务(线程)访问&#xA;    Tread thread&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;forkjoinpool&#34;&gt;&#xA;  ForkJoinPool&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#forkjoinpool&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;abstract class ForkJoinTask&#xA;    ForkJoinTask&amp;lt;V&amp;gt; fork()&#xA;    V join()&#xA;    abstract class RecursiveAction          # 无返回值&#xA;        void compute()&#xA;    abstract class RecursiveTask            # 有返回值&#xA;例子&#xA;    class MyTask extends RecursiveTask&amp;lt;Long&amp;gt; {&#xA;        int start;&#xA;        int end;&#xA;        @Override&#xA;        Long compute() {&#xA;            if (end - start &amp;lt;= MAX_NUM) {&#xA;                return sum&#xA;            }&#xA;            subTask1 = new MyTask(start, mid)&#xA;            subTask2 = new MyTask(mid, end)&#xA;            subTask1.fork()&#xA;            subTask2.fork()&#xA;            return subTask1.join() + subTask2.join();&#xA;        }&#xA;    }&#xA;    fjp = new ForkJoinPool()&#xA;    task = new MyTask(0, nums.length)&#xA;    fjp .execute(task)&#xA;    result = task.join()&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Java设计模式</title>
      <link>https://runout.run/docs/architect/code/design_mode/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/architect/code/design_mode/</guid>
      <description>&lt;h1 id=&#34;六个原则&#34;&gt;&#xA;  六个原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ad%e4%b8%aa%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;单一职责原则(SRP, Single Responsibility Principle)&#xA;    一个类只做一件事，应该只有一个引起它修改的原因&#xA;开闭原则(OCP, Open-Close Principle)&#xA;    对修改封闭，对扩展开放&#xA;里氏替换原则(LSP, the Liskov Substitution Principle)&#xA;    子类可以完全替换父类。也就是继承只扩展新功能&#xA;依赖倒置原则(DIP, the Dependency Inversion Principle)&#xA;    细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定&#xA;接口隔离原则(ISP, the Interface Segregation Principle)&#xA;    客户端不依赖它不需要的接口。冗余依赖应该将接口拆分&#xA;迪米特法则（最少知道原则）(LoD, Law of Demeter)&#xA;    一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;构建型&#34;&gt;&#xA;  构建型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e5%bb%ba%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;工厂方法factory-method&#34;&gt;&#xA;  工厂方法(Factory Method)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95factory-method&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 简单工厂, 根据参数创建不同的类&#xA;# 静态工厂，单例工厂&#xA;public interface Sender{&#xA;    public void Send();&#xA;}&#xA;public class MySender implements Sender{&#xA;    @Override&#xA;    public void Send(){}&#xA;}&#xA;public SenderFactory {&#xA;    public static Sender produceStatic() {&#xA;        return new MySender();&#xA;    }&#xA;    public Sender produce(){&#xA;        return new MySender();&#xA;    }&#xA;    public Sender produce(int i){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&#xA;# 工厂子类继承工厂接口, 不同产品对应不同工厂&#xA;public interface AbstractFactory {&#xA;    public MySender produce();&#xA;}&#xA;public class MyFactory implements AbstractFactory {&#xA;    @Override&#xA;    public MySender produce(){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;抽象工厂abstract-factory&#34;&gt;&#xA;  抽象工厂(Abstract Factory)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82abstract-factory&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 生产抽象产品&#xA;public interface AbstractFactory {&#xA;    public Sender produce();&#xA;}&#xA;public class MyFactory implements AbstractFactory {&#xA;    @Override&#xA;    public Sender produce(){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;单例singleton&#34;&gt;&#xA;  单例(Singleton)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e4%be%8bsingleton&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;确保只有一个实例&#xA;    # 大多有资源管理器的功能&#xA;    # 反射机制会使所有单例失效：私有构造方法可以被访问&#xA;应用&#xA;    线程池&#xA;    缓存&#xA;    日志对象&#xA;    对话框&#xA;    打印机&#xA;    显卡驱动程序&#xA;o-&amp;gt; 饿汉&#xA;public class Singleton {&#xA;    public static Singleton instance = new Singleton();&#xA;    private Singleton(){}&#xA;    public static Singleton getInstance(){&#xA;        return instance;&#xA;    }&#xA;}&#xA;o-&amp;gt; 懒汉式&#xA;public class Singleton {&#xA;    private static Singleton single=null;&#xA;    private Singleton() {}&#xA;    public synchronized  static Singleton getInstance() {&#xA;        if (single == null) {&#xA;            single = new Singleton();&#xA;        }&#xA;        return single;&#xA;    }&#xA;}&#xA;o-&amp;gt; 懒汉，双重检测(DCL)&#xA;    # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。&#xA;    # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized&#xA;public class Singleton {&#xA;    private static volatile Singleton singleton = null;&#xA;        # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。&#xA;    private Singleton(){}&#xA;    public static Singleton getInstance(){&#xA;        if (singleton == null) {&#xA;            // t1,t2并发进入&#xA;            synchronized (Singleton.class) {&#xA;                // t1释放后，t2进入&#xA;                if (singleton == null) {&#xA;                    singleton = new Singleton();&#xA;                }&#xA;            }&#xA;        }&#xA;        return singleton;&#xA;    }&#xA;}&#xA;o-&amp;gt; map注册&#xA;    # 学Spring，将类名注册&#xA;public class Singleton {&#xA;    private static Map&amp;lt;String,Singleton&amp;gt; map = new HashMap&amp;lt;String,Singleton&amp;gt;();&#xA;    static{&#xA;        Singleton single = new Singleton();&#xA;        map.put(single.getClass().getName(), single);&#xA;    }&#xA;    protected Singleton(){}&#xA;    public static Singleton getInstance(String name) {&#xA;        if(name == null) {&#xA;            name = Singleton.class.getName();&#xA;        }&#xA;        if(map.get(name) == null) {&#xA;            map.put(name, (Singleton) Class.forName(name).newInstance());&#xA;        }&#xA;        return map.get(name);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;建造者builder&#34;&gt;&#xA;  建造者(Builder)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bb%ba%e9%80%a0%e8%80%85builder&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 提供工厂方法，建造内部复合对象&#xA;o-&amp;gt;&#xA;public class Builder {&#xA;    private List&amp;lt;Sender&amp;gt; list = new ArrayList&amp;lt;Sender&amp;gt;();&#xA;    public void produceMailSender() {&#xA;        list.add(new MailSender())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;原型prototype&#34;&gt;&#xA;  原型(Prototype)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%9e%8bprototype&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 复制原型来创建新对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;结构型&#34;&gt;&#xA;  结构型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;适配器adapter&#34;&gt;&#xA;  适配器(Adapter)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%82%e9%85%8d%e5%99%a8adapter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 用来匹配接口&#xA;o-&amp;gt; 类&#xA;public class Source(){&#xA;    public void method1(){}&#xA;}&#xA;public interface Targetable {&#xA;    public void method1()&#xA;    public void method2()&#xA;}&#xA;public class Adapter extends Source implements Targetable {&#xA;    @Override&#xA;    public void method2(){}&#xA;}&#xA;o-&amp;gt; 对象&#xA;public class Wrapper implements Targetable {&#xA;    private Source source;&#xA;    public Wrapper(Source source){&#xA;        super();&#xA;        this.source = source;&#xA;    }&#xA;    @Override&#xA;    public void method1(){&#xA;        source.method1()&#xA;    }&#xA;    @Override&#xA;    public void method2(){}&#xA;}&#xA;o-&amp;gt; 接口&#xA;public abstract class AbstractTarget implements Targetable {&#xA;    @Override&#xA;    public void method1(){}&#xA;}&#xA;public class Adapter extends AbstractTarget {&#xA;    @Override&#xA;    public method2(){}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;桥接bridge&#34;&gt;&#xA;  桥接(Bridge)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%a5%e6%8e%a5bridge&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 分离抽象和具体(两个维度发展)分别继承，抽象聚合(桥接)具体&#xA;public abstract class Gift {&#xA;    GiftImpl impl;&#xA;}&#xA;public class Flower extends GiftImpl {}&#xA;public class WarmGift extends Gift {&#xA;    public WarmGift(GiftImpl impl) {&#xA;        this.impl = impl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;组合composite&#34;&gt;&#xA;  组合(Composite)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e5%90%88composite&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 树状结构&#xA;abstract class Node{}&#xA;class LeafNode extends Node{}&#xA;class BranchNode extends Node{&#xA;    List&amp;lt;Node&amp;gt; nodes = new ArrayList&amp;lt;&amp;gt;();&#xA;}&#xA;&#xA;tree(Node b, int depth) {&#xA;    b.print();&#xA;    if (b instanceof BranchNode) {&#xA;        for (Node n : ((BranchNode)b).nodes){&#xA;            tree(n, depth+1)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;装饰decorator&#34;&gt;&#xA;  装饰(Decorator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a3%85%e9%a5%b0decorator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 持有被装饰实例，实现同一接口&#xA;public interface Sourceable {&#xA;    public void method();&#xA;}&#xA;public class Source implements Sourceable {&#xA;    @Override&#xA;    public void method(){}&#xA;}&#xA;public class Decorator implements Sourceable {&#xA;    private Sourceable source;&#xA;    public Decorator(Sourceable source) {&#xA;        super();&#xA;        this.source = source;&#xA;    }&#xA;    @Override&#xA;    public void method() {&#xA;        source.method();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;门面facade&#34;&gt;&#xA;  门面(Facade)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%a8%e9%9d%a2facade&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 对外接待&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中介者mediator&#34;&gt;&#xA;  中介者(Mediator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e4%bb%8b%e8%80%85mediator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 内部都只关联它，如mq&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;享元flyweight&#34;&gt;&#xA;  享元(Flyweight)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ab%e5%85%83flyweight&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 共享元数据&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;代理&#34;&gt;&#xA;  代理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 静态代理，实现同装饰&#xA;class TankTimeProxy implements Movable {&#xA;    Movable m;&#xA;    @Override&#xA;    public void move(){&#xA;        m.move();&#xA;    }&#xA;}&#xA;&#xA;# 动态代理，Proxy调asm生成代理类&#xA;Tank tank = new Tank();&#xA;Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader()), &#xA;    new Class[]{Movable.class},&#xA;    new Hander(tank)&#xA;);&#xA;class Handler implements InvocationHandler {&#xA;    Tank tank;&#xA;    @Override&#xA;    public Object invoke(Object proxy, Method method, Object[] args) {&#xA;        return method.invoke(tank, args);&#xA;    }&#xA;}&#xA;&#xA;// 动态代理, CGLIB调asm，由于是继承，所以final类不能代理&#xA;Enhancer enhancer = new Enhancer();&#xA;enhancer.setSuperclass(Tank.class);&#xA;enhancer.setCallback(new TimeMethodInterceptor());&#xA;Tank tank = (Tank)enhancer.create();&#xA;tank.move();&#xA;class TimeMethodInterceptor implements MethodInterceptor {&#xA;    @Override&#xA;    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) {&#xA;        return methodProxy.invokeSuper(o, objects);&#xA;    }&#xA;}&#xA;&#xA;// Spring AOP: aspect指定代理类, pointcut指定被代理方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;行为型&#34;&gt;&#xA;  行为型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%8c%e4%b8%ba%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;观察者&#34;&gt;&#xA;  观察者&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%82%e5%af%9f%e8%80%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Observer, 对象变化，对观察者广播&#xA;public interface Observer {&#xA;    public void update();&#xA;}&#xA;public class Observer1 implements Observer {&#xA;    @Override&#xA;    public void update(){}&#xA;}&#xA;public interface Subject{&#xA;    public void add(Observer observer);&#xA;    public void del(Observer observer);&#xA;    public void notifyObservers();&#xA;    public void operate()&#xA;}&#xA;public abstract class AbstractSubject implements Subject {&#xA;    private Vector&amp;lt;Observer&amp;gt; vector = new Vector&amp;lt;Observer&amp;gt;();&#xA;    @Override&#xA;    public void add(Observer observer) {&#xA;        vector.add(observer);&#xA;    }&#xA;    @Override&#xA;    public void del(Observer observer) {&#xA;        vector.remove(observer);&#xA;    }&#xA;    @Override&#xA;    public void notifyObservers(){&#xA;        Enumeration&amp;lt;Observer&amp;gt; enumo = vector.elements();&#xA;        while (enumo.hasMoreElements()) {&#xA;            enumo.nextElement().update();&#xA;        }&#xA;    }&#xA;}&#xA;public class MySubject extends AbstractSubject {&#xA;    @Override&#xA;    public void operate() {&#xA;        notifyObservers();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模板方法templatemethod&#34;&gt;&#xA;  模板方法(TemplateMethod)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95templatemethod&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 钩子函数&#xA;abstract class F {&#xA;    public void m() {&#xA;        op1();&#xA;    }&#xA;    abstract void op1();&#xA;}&#xA;class C1 extends F {&#xA;    @Override&#xA;    void op1(){}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;状态state&#34;&gt;&#xA;  状态(State)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8a%b6%e6%80%81state&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 状态便于扩展, 方法不便扩展。如果相反用switch&#xA;public class MM {&#xA;    MMState state;&#xA;    public void smile(){&#xA;        state.smile();&#xA;    }&#xA;}&#xA;public abstract class MMState {&#xA;    abstract void smile();&#xA;}&#xA;public class MMHappyState extends MMState {&#xA;    @Override&#xA;    void smile(){}&#xA;}&#xA;&#xA;# FSM例子，线程状态&#xA;public class Thread_ {&#xA;    ThreadState_ state;&#xA;    void move(Action a) { state.move(a);}&#xA;}&#xA;abstract class ThreadState_ {&#xA;    abstract void move(Action a);&#xA;}&#xA;public class NewState extends ThreadState_ {&#xA;    private Thread_ t;&#xA;    @Override&#xA;    void move(Action a) {&#xA;        if (&amp;quot;start&amp;quot;.equals(a.msg)) {&#xA;            t.state = new RunningState(t);&#xA;        }&#xA;    }&#xA;}&#xA;public class Action {&#xA;    String msg;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;迭代器iterator&#34;&gt;&#xA;  迭代器(Iterator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e5%99%a8iterator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;public interface Iterator&amp;lt;E&amp;gt; {&#xA;    boolean hasNext();&#xA;    E next();&#xA;}&#xA;public interface Collection&amp;lt;E&amp;gt; {&#xA;    Iterator&amp;lt;E&amp;gt; iterator();&#xA;}&#xA;class List&amp;lt;E&amp;gt; implements Collection&amp;lt;E&amp;gt; {&#xA;    private class Itr&amp;lt;E&amp;gt; implements Iterator&amp;lt;E&amp;gt; {&#xA;        @Override&#xA;        public boolean hasNext(){}&#xA;        @Override&#xA;        public E next(){}&#xA;    }&#xA;    @Override&#xA;    public Iterator iterator(){&#xA;        return new Itr();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;策略&#34;&gt;&#xA;  策略&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ad%96%e7%95%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# strategy, 封装多个算法类, 更换策略，调用方式一致&#xA;o-&amp;gt;&#xA;public interface ICalculator {&#xA;    public int calculate(String exp);&#xA;}&#xA;public class Minus extends AbstractCaculator implements ICalculator {&#xA;    @Override&#xA;    public int calculate(String exp) {&#xA;        int arrayInt[] = split(exp, &amp;quot;-&amp;quot;);&#xA;        return arrayInt[0] - arrayInt[1];&#xA;    }&#xA;}&#xA;public class AbstractCalculator {&#xA;    public int[] split(String exp, String opt) {&#xA;        String[] array = exp.split(opt);&#xA;        int arrayInt[] = new int[2];&#xA;        arrayInt[0] = Integer.parseInt(array[0]);&#xA;        arrayInt[1] = Integer.parseInt(array[1]);&#xA;        return arrayInt;&#xA;    }&#xA;}&#xA;Icalculator cal = new Minus();&#xA;cal.calculate(exp);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;备忘录memento&#34;&gt;&#xA;  备忘录(Memento)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%87%e5%bf%98%e5%bd%95memento&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 快照&#xA;# Java序列化, ProtoBuf库&#xA;class C implements Serializable {&#xA;    private transient List&amp;lt;Object&amp;gt; list;&#xA;}&#xA;ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&amp;quot;&amp;quot;)));&#xA;oos.writeObject(o1)&#xA;oos.writeObject(o2)&#xA;ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&amp;quot;&amp;quot;)));&#xA;o1 = ois.readObject();&#xA;o2 = ois.readObject();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;命令command&#34;&gt;&#xA;  命令(Command)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4command&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 别名Action或Transaction&#xA;# 配合组合实现宏命令, 配合责任链实现undo，配合备忘录实现事务回滚&#xA;abstract class Command {&#xA;    abstract void do();&#xA;    abstract void undo();&#xA;}&#xA;class InsertCommand extends Command {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;责任链chain-of-responsibility&#34;&gt;&#xA;  责任链(Chain of Responsibility)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%a3%e4%bb%bb%e9%93%bechain-of-responsibility&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;interface Filter {&#xA;    boolean doFilter(Msg m);&#xA;}&#xA;class HTMLFilter implements Filter {}&#xA;class FilterChain implements Filter{&#xA;    List&amp;lt;Filter&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;();&#xA;    public boolean doFilter(Msg msg){&#xA;        for (Filter f : filters) {&#xA;            if (!f.doFilter(msg)) {&#xA;                return false;&#xA;            }&#xA;        }&#xA;        return true;&#xA;    }&#xA;    public FilterChain add(Filter f) {&#xA;        filters.add(f);&#xA;        return this;&#xA;    }&#xA;}&#xA;FilterChain fc = new FilterChain();&#xA;FilterChain fc2 = new FilterChain();&#xA;Filter f = new Filter();&#xA;fc.add(f).add(fc2);&#xA;&#xA;# ServletFilter&#xA;Filter1 implements Filter {&#xA;    void doFilter(req, resp, chain) {&#xA;        chain.doFilter(req, resp);&#xA;    }&#xA;}&#xA;FilterChain implements Filter {&#xA;    List&amp;lt;Filter&amp;gt; filters;&#xA;    int curIndex = 0;&#xA;    void doFilter(req, resp){&#xA;        curIndex++;&#xA;        if (curIndex &amp;lt; filters.size()) {&#xA;            filters[curIndex].doFilter(req, resp, this);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;访问者visitor&#34;&gt;&#xA;  访问者(Visitor)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%bf%e9%97%ae%e8%80%85visitor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 内部结构不变，访问方式扩展&#xA;interface Visitor {&#xA;    void visitCpu(CPU cpu);&#xA;} &#xA;class Visitor1 implements Visitor {&#xA;    double price = 0.0;&#xA;    @Override&#xA;    void visitCpu(CPU cpu) {&#xA;        price += cpu.getPrice() * 0.9;&#xA;    }&#xA;}&#xA;class Computer {&#xA;    Part cpu;&#xA;    void accept(Visitor v) {&#xA;        this.cpu.accept(v);&#xA;    }&#xA;}&#xA;abstract class Part {&#xA;    abstract void accept(Visitor v);&#xA;    abstract double getPrice();&#xA;}&#xA;class CPU extends Part {&#xA;    @Override&#xA;    void accept(Visitor v){&#xA;        v.visitCpu(this);&#xA;    }&#xA;}&#xA;&#xA;Visitor p = new Visitor1();&#xA;new Computer().accept(p);&#xA;p.price;&#xA;&#xA;# Java类AST编译器Visitor, ASM&#xA;// 打印&#xA;class ClassPrinter extends ClassVisitor {&#xA;    @Override&#xA;    MethodVisitor visitMethod(){&#xA;        print(name + &amp;quot;()&amp;quot;);&#xA;        retrun null;&#xA;    }&#xA;}&#xA;ClassPrinter cp = new ClassPrinter();&#xA;ClassReader cr = new ClassReader(&amp;quot;java.lang.Runnable&amp;quot;);&#xA;cr.accept(cp, 0);&#xA;&#xA;// 生成类&#xA;ClassWriter cw = new ClassWriter(0);&#xA;cw.visitMethod(ACC_PULIC + ACC_ABSTRACT, &amp;quot;compareTo&amp;quot;, &amp;quot;(Ljava/lang/Object;)I&amp;quot;, null, null).visitEnd();&#xA;cw.visitEnd();&#xA;MyClassLoader cl = new MyClassLoader();&#xA;byte[] b = cw.toByteArray();&#xA;Class c = cl.defineClass(&amp;quot;pkg.Comparable&amp;quot;, b, 0, b.length);&#xA;&#xA;// 代理类&#xA;ClassReader cr = new ClassReader();&#xA;ClassWriter cw = new ClassWriter(0);&#xA;ClassVisitor cv = new ClassVisitor(ASM4, cw) {&#xA;    @Override&#xA;    public MethodVisitor visitMethod() {&#xA;        MethodVisitor mv = super.visitMethod(); &#xA;        return new MethodVisitor(ASM4, mv) {&#xA;            @Override&#xA;            public void visitCode(){&#xA;                visitMethodInsn(INVOKESTATIC, &amp;quot;TimeProxy&amp;quot;, &amp;quot;before&amp;quot;, &amp;quot;()v&amp;quot;, false);&#xA;                super.visitCode();&#xA;            }&#xA;        }&#xA;    }&#xA;};&#xA;cr.accept(cv, 0);&#xA;cw.toByteArray();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;解释器intepreter&#34;&gt;&#xA;  解释器(Intepreter)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%87%8a%e5%99%a8intepreter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 解释出AST&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;其它补充&#34;&gt;&#xA;  其它补充&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b6%e5%ae%83%e8%a1%a5%e5%85%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;元素模式&#xA;    # 抽象各模式成元素，简化表示&#xA;actor&#xA;    # 消息通信&#xA;reactor&#xA;    # 事件轮循，注册回调，如libevent&#xA;proactor&#xA;    # 注册事件回调，os通知触发回调&#xA;惰性求值&#xA;    链式定义(配方)，后自动触发(js tick调度)终止操作&#xA;dsl测试(如jasmine.js)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>JVM</title>
      <link>https://runout.run/docs/pl/java/jvm/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/jvm/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;定义&#xA;    JVM规范说明书, JVMS(Java Virtual Machine Specifications)&#xA;    Java语言规范, JLS(Java Language Specification)&#xA;    虚拟机&#xA;        指令集&#xA;        内存管理&#xA;过程&#xA;    x.java -&amp;gt; javac -&amp;gt; x.class -&amp;gt; ClassLoader -&amp;gt; (字节码解释器、JIT) -&amp;gt; 执行引擎&#xA;JVM语言&#xA;    Scala, Kotlin, Groovy, Clojure, jython, jruby等100多个&#xA;JVM实现&#xA;    HotSpot                 # Oracle官方, 8之后收费, OpenJDK为开源版本&#xA;    Jrockit                 # Oracle收购, 合并入HotSpot&#xA;    J9                      # IBM&#xA;    Microsoft VM&#xA;    TaobaoVM                # HotSpot深度定制&#xA;    LiquidVM                # 直接匹配专门硬件&#xA;    azul zing               # 收费，快, GC1mm, HotSpot参考写的G1&#xA;JRE, JDK&#xA;    JRE = jvm + core lib&#xA;    JDK = JRE + development kit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jvm构造&#34;&gt;&#xA;  JVM构造&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm%e6%9e%84%e9%80%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;指标&#34;&gt;&#xA;  指标&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e6%a0%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;吞吐量: 代码时间 / (代码时间 + GC时间)&#xA;响应时间: STW越短, 响应时间越好&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;指令instructions&#34;&gt;&#xA;  指令(Instructions)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e4%bb%a4instructions&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    基于栈的指令类          # 简单, HotSpot&#xA;    基于寄存器的指令集      # 复杂但快, HotSpot局部变量表&#xA;8大原子操作(JSR-133已放弃这个描述，但指令没变化)&#xA;    lock                    # 主内存，标识变量线程独占&#xA;    unlock                  # 主内存，解锁独占&#xA;    read                    # 主内存，读到工作内存&#xA;    load                    # 工作内存，read后的值放入线程本地变量副本&#xA;    use                     # 工作内存，传值给执行引擎&#xA;    assign                  # 工作内存，执行引擎结果赋值给线程本地变量 &#xA;    store                   # 工作内存，存值到主内存给write备用&#xA;    write                   # 主内存，写变量值&#xA;方法指令                    # 在methods的Code中罗列&#xA;    aload_0                 # 变量表第0项入栈&#xA;    invokespecial #1        # 调private(无多态)的方法&#xA;    invokevirtual           # 调有多态可能性的方法&#xA;    invokestatic            # 调静态方法&#xA;    invokeinterface         # 调interface方法&#xA;    invokedynamic           # 1.7加入，定义类似函数指针时生成(但每个函数都创建了类)&#xA;        调用动态产生的类&#xA;            lambda&#xA;            反射&#xA;            scala等JVM语言&#xA;            CGLib ASM&#xA;        组成&#xA;            bootstrapMethod&#xA;            方法签名&#xA;        &amp;lt;1.8的bug           # 类产生于Perm Space，内存不回收&#xA;            for(;;) {I j = C::n;}&#xA;    return                  # 方法返回&#xA;    bipush 8                # byte扩展成int类型，放到方法栈中&#xA;    sipush 200              # short&#xA;    istore_1                # 出栈，放到下标为1的局部变量表&#xA;    iload_1                 # 局部变量表下标1位置值压栈&#xA;    iinc 1 by 1             # 局部变量表1位置值+1&#xA;    iadd                    # 出栈两个，相加压栈&#xA;    new                     # new对象, 地址压栈&#xA;    dup                     # 复制栈顶并压栈&#xA;    pop                     # 弹出栈顶&#xA;    if_icmpne 7             # int值比较，不等时跳到第7条指令&#xA;    mul                     # 乘法&#xA;    sub                     # 减法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;class结构&#34;&gt;&#xA;  class结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#class%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;javap -v a.class&#xA;jetbrain jclasslib&#xA;jetbrain BinEd&#xA;JBE                         # 可编辑&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;二进制&#34;&gt;&#xA;  二进制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Magic Number(4字节)&#xA;    cafe babe&#xA;Minor Version(2字节)        # 小版本&#xA;Major Version(2字节)        # 大版本&#xA;    JDK1.7是51.0&#xA;    JDK1.8是52.0&#xA;constant_pool_count(2字节)&#xA;    # 长度constant_pool_count-1的表&#xA;constant_pool               # 索引、tag、类型&#xA;    1 CONSTANT_Utf8_info                        # 存一些描述字符串&#xA;    2 标记&#xA;    3 CONSTANT_Integer_info&#xA;    4 CONSTANT_Float_info&#xA;    5 CONSTANT_Long_info&#xA;    6 CONSTANT_Double_info&#xA;    7 CONSTANT_Class_info&#xA;    8 CONSTANT_String_info&#xA;    9 CONSTANT_Fieldref_info                &#xA;    10 CONSTANT_Methodref_info                  # 方法引用&#xA;        指向CONSTANT_Class_info&#xA;        指向CONSTANT_NameAndType_info&#xA;    11 CONSTANT_InterfaceMethodref_info&#xA;    12 CONSTANT_NameAndType_info                # 方法名与类型&#xA;    15 CONSTANT_MethodHandle_info&#xA;    16 CONSTANT_MethodType_info&#xA;    18 CONSTANT_InvokeDynamic_info&#xA;access_flags(2字节)         # bitmap按位与组合&#xA;    # class的修饰符&#xA;    ACC_PUBLIC 0x0001 public&#xA;    ACC_FINAL 0x0010 final&#xA;    ACC_SUPER 0x0020 JDK1.0.2之后必须为真, 表示invokespectial用新语义&#xA;    ACC_INTERFACE 0x0200 是否接口&#xA;    ACC_ABSTRACT 0x0400 抽象类&#xA;    ACC_SYNTHETIC 0x1000 编译器自动生成&#xA;    ACC_ANNOTATION 0x2000 &#xA;    ACC_ENUM 0x2000 &#xA;this_class(2字节)&#xA;    存名字对应指向常量池序号&#xA;super_class(2字节)&#xA;    存名字对应指向常量池序号&#xA;interfaces_count(2字节)&#xA;interfaces&#xA;fields_count(2字节)&#xA;fields&#xA;    access_flags(2字节)&#xA;    name_index              # 存常量池索引&#xA;    descriptor_index&#xA;        byte B&#xA;        char C&#xA;        double D&#xA;        float F&#xA;        int I&#xA;        long L&#xA;        short S&#xA;        boolean Z&#xA;        void V&#xA;        Object Ljava/lang/Object&#xA;        数组&#xA;            一维数组 [B&#xA;            多维数组 [[C&#xA;    attributes_count        # 赋加属性&#xA;    attributes&#xA;methods_count(2字节)&#xA;methods&#xA;    access_flags(2字节)&#xA;    name_index&#xA;    descriptor_index        # 先参数列表，后返回值&#xA;        void m() -&amp;gt; ()V&#xA;        String toString() -&amp;gt; Ljava/lang/String;&#xA;    attributes_count&#xA;    attributes              # 赋加属性&#xA;        Code                # 指令列表, 一般先压栈this(aload_0)&#xA;            LineNumberTable&#xA;            LocalVariableTable&#xA;attributes_count(2字节)&#xA;attributes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;agent&#34;&gt;&#xA;  Agent&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#agent&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;例子&#xA;    打包 a.jar&#xA;        MANIFEST.MF&#xA;            Premain_Class: MyAgent&#xA;        public class MyAgent {&#xA;            public static Instrumentation inst;&#xA;            public static void premain(String agentArgs, Instrumentation _inst) {&#xA;                inst = _inst;&#xA;            } &#xA;        }&#xA;    JVM参数 -javaagent: a.jar&#xA;    使用 MyAgent.inst&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jmmjava-memory-model&#34;&gt;&#xA;  JMM(Java Memory Model)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmmjava-memory-model&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;运行时区域&#34;&gt;&#xA;  运行时区域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8c%ba%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Runtime data areas&#xA;分类&#xA;    Program Counter             # 程序计数器，下一条指令位置&#xA;    Method Area                 # 方法区,线程间共享&#xA;        存储&#xA;            Class元信息&#xA;            代码编译信息, JIT编译信息&#xA;            常量池(Runtime Constant Pool)           # 常量池在运行时存放区&#xA;        版本区别&#xA;            Perm Space(&amp;lt;1.8)    # 要设定大小, 会溢出报错&#xA;                存字符串常量&#xA;                lambda生成临时类永远存在&#xA;                Full GC不清理&#xA;            Meta Space(&amp;gt;=1.8)   # 自动大小无上限&#xA;                字符串常量位于堆&#xA;                会触发Full GC&#xA;    JVM stacks                  # 线程栈 &#xA;        Frame(栈帧)             # 一个方法一个栈帧&#xA;            Local Variable Table                # 局部变量表, 方法内的局部变量，值在常量池&#xA;                默认第0个为this&#xA;            Operand Stack                       # 操作数栈&#xA;            Dynamic Linking                     # 指向调用方法的 运行时常量池的符号连接&#xA;            return address                      # 当前方法执行完的返回地址&#xA;    Native Method Stacks        # C/C++方法栈&#xA;    Direct Memory               # 直接内存&#xA;    Heap                        # 堆, 线程间共享&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;屏障&#34;&gt;&#xA;  屏障&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%8f%e9%9a%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;CPU屏障&#xA;JVM规范&#xA;    LoadLoad                # 上load和下load不能重排&#xA;    StoreStore&#xA;    LoadStore&#xA;    StoreLoad               # 最强&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;对象内存存储&#34;&gt;&#xA;  对象内存存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%86%85%e5%ad%98%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;普通对象&#xA;    对象头: markword 8字节&#xA;    ClassPointer            # 指向Class对象, 启用压缩4字节，不启用8字节&#xA;    实例数据&#xA;        引用类型            # 启用压缩4字节，不启用8字节&#xA;    Padding: 对齐8的倍数&#xA;数组对象&#xA;    对象头&#xA;    ClassPointer&#xA;    数组长度4字节&#xA;    数组数据&#xA;    Padding&#xA;对象头&#xA;    # 32位64位(25位没用到)，内容不同&#xA;    锁标志位2位             # 根据锁标志位判断存储内容&#xA;        01 无锁/偏向锁&#xA;        00 轻量级锁&#xA;        10 重量级锁&#xA;        11 GC标记&#xA;    是否偏向锁1位&#xA;    剩余位 &#xA;        无锁状态&#xA;            对象hashCode(25位或31位)&#xA;                没重写过时默认计算(System.identityHashCode())&#xA;                重写过的hashCode()结果不存在这里&#xA;            分代年龄&#xA;        轻量级锁&#xA;            指向栈中锁记录的指针&#xA;        重量级锁&#xA;            指向互斥量（重量级锁）的指针&#xA;        偏向锁&#xA;            线程ID 23位&#xA;            Epoch 2位&#xA;            分代年龄4位(所以分代年龄只有15)&#xA;    其它问题&#xA;        对象计算过hashCode，对象不能进入偏向锁状态(位已经被占了)&#xA;实验工具 javaagent&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;对象定位&#34;&gt;&#xA;  对象定位&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%ae%9a%e4%bd%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;句柄池                      # 指向句柄，句柄有对象指针和class指针, 三色标记GC提高效率&#xA;直接指针                    # 指向对象，对象指class, HotSpot使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;并发&#34;&gt;&#xA;  并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;硬件层数据一致性&#34;&gt;&#xA;  硬件层数据一致性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a1%ac%e4%bb%b6%e5%b1%82%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;硬件结构&#xA;    L0寄存器                # 1 cycles&#xA;    L1高速缓存              # 3-4 cycles, 1ns&#xA;    L2高速缓存              # 10 cycles, 3ns&#xA;    L3高速缓存              # 40-45 cycles, 15ns, 在主板&#xA;    (QPI总线传输)           # 20ns&#xA;    L4主存                  # 60-80ns&#xA;    L5磁盘&#xA;    L6远程文件存储&#xA;数据不一致                  # 从L2多CPU开始&#xA;    锁总线(bus lock)&#xA;    CPU缓存一致性协议(如intel MESI)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;volatile&#34;&gt;&#xA;  volatile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#volatile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;工具&#xA;    hsdis                   # HotSpot Dis Assembler, 虚拟机字节码对应汇编&#xA;bytecode&#xA;    ACC_VOLATILE&#xA;JVM&#xA;    StoreStoreBarrier&#xA;    volatile写操作          # 上边写完再写，写完下边再读，写一致&#xA;    StoreLoadBarrier&#xA;&#xA;    LoadLoadBarrier&#xA;    volatile读操作          # 上边读完再读，读完下边再写，读一致&#xA;    LoadStoreBarrier&#xA;OS&#xA;    windows&#xA;        lock&#xA;    linux&#xA;        上下屏障，最后lock&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;synchronized&#34;&gt;&#xA;  synchronized&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;bytecode&#xA;    方法修饰&#xA;        synchronized&#xA;    代码&#xA;        monitorenter&#xA;        monitorexit&#xA;JVM&#xA;    C/C++实现，会调用OS的同步机制&#xA;OS&#xA;    lock&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;happens-before原则&#34;&gt;&#xA;  happens-before原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#happens-before%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Java要求指令不能重排的几种情况&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;as-if-serial&#34;&gt;&#xA;  as if serial&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#as-if-serial&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 不管如何重排序，单线程执行结果不变&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;过程&#34;&gt;&#xA;  过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;编译&#34;&gt;&#xA;  编译&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%af%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;过程&#xA;    代码 -&amp;gt; bytecode -&amp;gt; JVM指令 -&amp;gt; OS指令&#xA;解释器(bytecode intepreter)&#xA;JIT(Just In-Time compiler)&#xA;混合模式&#xA;    解释器 + 热点代码编译&#xA;    热点代码检测&#xA;        方法计数器&#xA;        循环计数器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;加载&#34;&gt;&#xA;  加载&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a0%e8%bd%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;HotSpot C++代码加载&#xA;    class对象加载到MethodArea&#xA;        metaspace(JDK1.8)&#xA;        permGeneration(JDK1.8之前)&#xA;class加载过程&#xA;    loading                 # 读到内存&#xA;    linking&#xA;        verification        # 校验&#xA;        preparation         # 静态变量赋默认值&#xA;        resolution          # 解析, loadClass()可指定是否解析。常量池的符号引用转换成内存地址引用&#xA;    initializing            # 静态变量赋初始值，执行静态代码&#xA;对象加载&#xA;    new过程&#xA;        class加载&#xA;        申请对象内存&#xA;        成员变量赋默认值&#xA;        调用构造方法&amp;lt;init&amp;gt;&#xA;            成员变量顺序赋初始值&#xA;            执行构造方法语句(先super)&#xA;双亲委派                &#xA;    过程&#xA;        类名一层层向上找&#xA;        找不到时，一层层找再向下委派找&#xA;        都不能加载时, 抛ClassNotFound&#xA;    为什么&#xA;        安全, 自定义类不能覆盖&#xA;        已加载不用重复加载&#xA;    父加载器&#xA;        不是类加载器的加载器&#xA;        不是父类&#xA;        是组合的parent对象&#xA;    打破&#xA;        为什么                    &#xA;            JDK1.2之前都重写loadClass()&#xA;            thread.setContextClassLoader()指定线程上下文classLoader&#xA;            热启动/热部署(OSGi tomcat)加载同一类不同版本&#xA;        做法&#xA;            重写loadClass(), new多个ClassLoader&#xA;类加载器&#xA;    Bootstrap               # 加载核心类 lib/rt.jar charset.jar等, C++实现所以get时为null&#xA;        如加载String&#xA;    Extension               # 加载扩展jar jre/lib/ext/*.jar, 由-Djava.ext.dirs指定&#xA;    App                     # 加载classpatch指定内容&#xA;    Custom ClassLoader      # 自定义ClassLoader&#xA;加载路径环境变量            # 来自Launcher源码&#xA;    Bootstrap.ClassLoader   sun.boot.class.path&#xA;    ExtensionClassLoader    java.ext.dirs&#xA;    AppClassLoader          java.class.path&#xA;API&#xA;    Class&#xA;        getClassLoader()&#xA;    ClassLoader             # findInCache() -&amp;gt; parent.loadClass() -&amp;gt; findClass()&#xA;        private final ClassLoader parent&#xA;        loadClass           # 热加载&#xA;    Launcher&#xA;        $AppClassLoader&#xA;        $ExtClassLoader&#xA;自定义类加载器&#xA;    class MyClassLoader extends ClassLoader {&#xA;        @Override&#xA;        Class findClass(String) {&#xA;            return defineClass()&#xA;        }&#xA;    }&#xA;懒加载                      # JVM未规定什么时候加载,但规定了什么时候初始化&#xA;初始化&#xA;    new getstatic putstatic invokestatic指令，访问final变量除外&#xA;    java.lang.reflect对类进行反射调用&#xA;    初始化子类时，父类首先初始化&#xA;    虚拟机启动时，被执行的主类&#xA;    动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic, REF_putstatic, REF_invokestatic的方法句柄时, 该类初始化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gc&#34;&gt;&#xA;  GC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引用方式强软弱虚&#34;&gt;&#xA;  引用方式(强软弱虚)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e7%94%a8%e6%96%b9%e5%bc%8f%e5%bc%ba%e8%bd%af%e5%bc%b1%e8%99%9a&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;软引用&#xA;    # 内存不够用时回收，用做缓存&#xA;    # -Xms20M -Xmx20M&#xA;    SoftReference&amp;lt;byte[]&amp;gt; m = new SoftReference&amp;lt;&amp;gt;(new byte[1024*1024*10]);&#xA;    System.gc();&#xA;    m.get();&#xA;    new byte[1024*1024*15]&#xA;    m.get();&#xA;弱引用&#xA;    # 只要gc就回收，用做容器如WeakHashMap(key是弱引用), ThreadLocalMap的key&#xA;    WeakReference&amp;lt;M&amp;gt; m = new WeakReference&amp;lt;&amp;gt;(new M());&#xA;    System.gc();&#xA;    m.get();&#xA;虚引用&#xA;    # 值被回收时放入队列来通知, 用来触发回收堆外内存(用Unsafe的freeMemory())&#xA;    # 如NIO的直接内存DirectByteBuffer&#xA;    PhantomReference&amp;lt;M&amp;gt; r = new PhantomReference&amp;lt;&amp;gt;(new M(), QUEUE);&#xA;    r.get() // 自己写永远返回null                     &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;对象分配过程&#34;&gt;&#xA;  对象分配过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;向栈分配                # 不要调参数&#xA;    好处&#xA;        不必GC&#xA;    条件&#xA;        线程私有小对象&#xA;        无逃逸&#xA;        可标量替换(基本类型替换整个对象)&#xA;过大，分配到老年代&#xA;线程本地分配            # TLAB(Thread Local Allocation Buffer), 不要调参数&#xA;    好处&#xA;        为了减少线程争用&#xA;    条件&#xA;        小对象&#xA;        占用eden, 默认每个线程占1%&#xA;伊甸区&#xA;s1,s2&#xA;    次数                   # 最大15(对象头上空间决定)&#xA;        Parallel Scavenge 15&#xA;        CMS 6&#xA;        G1 15&#xA;    动态年龄&#xA;        eden + s1 复制到s2, 超过s2总内存一半时，年龄最大的对象进入老年代&#xA;    分配担保&#xA;        YGC时survivor区空间不够, 直接进入老年代&#xA;GC清除或到老年代&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;gc分代过程&#34;&gt;&#xA;  GC分代过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gc%e5%88%86%e4%bb%a3%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;YGC -&amp;gt; s0&#xA;YGC, eden + s0 -&amp;gt; s1&#xA;    年龄足够 -&amp;gt; old&#xA;    s区装不下 -&amp;gt; old&#xA;YGC, eden + s1 -&amp;gt; s0&#xA;old满了 -&amp;gt; FGC&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;常见的回收器&#34;&gt;&#xA;  常见的回收器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%9b%9e%e6%94%b6%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    Safe Point              # STW时机&#xA;    没有无STW的回收器&#xA;分代&#xA;    Young&#xA;        Serial              # 第一个GC&#xA;            STW, 单线程串行回收&#xA;        Parallel Scavenge&#xA;            STW, 并行回收&#xA;        ParNew              # Parallel New&#xA;            增强PS, 以配合CMS并行回收, CMS到某阶段时PN运行&#xA;    Old&#xA;        Serial Old&#xA;            特点&#xA;                适用几十M&#xA;                mark-sweep-compact，单线程&#xA;        Parallel Old&#xA;            特点&#xA;                适用几个G&#xA;                mark-sweep-compact，多线程&#xA;        CMS                 # concurrent mark sweep, 1.4后期引入, JDK11取消&#xA;            特点&#xA;                适用20G&#xA;                多线程并行回收, 并发回收(GC与程序同时运行)，降低STW时间(200ms)&#xA;            不足            # 问题多，没有版本默认CMS&#xA;                浮动垃圾&#xA;                碎片多，新对象分配不下时，使用SerialOld&#xA;                    设低GC阈值回收浮动垃圾&#xA;            清理过程&#xA;                初始标记(initial mark)&#xA;                    STW, 单线程, 标记根对象&#xA;                [预标记]                        # Card Marking, 把Card标为Dirty&#xA;                并发标记(concurrent mark)&#xA;                    不STW, 多线程, 执行多次&#xA;                重新标记(remark)                # 处理并发标记过程中的变化&#xA;                    STW, 多线程, &#xA;                并发清理(concurrent sweep)      # 过程中产生的浮动垃圾, 下次回收&#xA;                    不STW, 多线程, &#xA;                [整理阶段]&#xA;            日志&#xA;                [GC(Allocation Failure)[ParNew:6144K-&amp;gt;640K(6144K)], 0.02 secs] 6585K-&amp;gt;2770K(19840K),0.02 secs][Times:user=0.02 sys=0.00, real=0.02 secs]&#xA;                    6144K-&amp;gt;640K(6144K): 回收前 回收后 总容量&#xA;                    6585K-&amp;gt;2770K(19840K): 堆回收前 回收后 总大小  &#xA;&#xA;                [GC (CMS Initial Mark)]&#xA;                    [1 CMS-initail-mark]&#xA;                [CMS-concurrent-mark-start]&#xA;                [CMS-concurrent-preclean-start]&#xA;                [GC (CMS Final Remark)]&#xA;                    [YG occupancy]              # 清理后年轻代占用及容量&#xA;                    [Rescan(parallel)]          # STW下标记存活对象&#xA;                    [weak refs processing]      # 弱引用处理&#xA;                    [class unloading]           # 卸载用不到的class&#xA;                    [scrub symbol table]        # 清理常量池&#xA;                    [scrub string table]        # 清理常量池&#xA;                    [1 CMS-remark]              # 清理后老年代占用及容量&#xA;                [CMS-concurrent-sweep-start]&#xA;                [CMS-concurrent-reset-start]&#xA;&#xA;不分代&#xA;    G1                      # Garbage First, 1.7引入, 1.8完善, 1.9默认&#xA;        特点&#xA;            适用上百G&#xA;            STW 10ms回收&#xA;                容易预测STW时间&#xA;                低latency, 但throughput也低&#xA;            并发回收, 三色标记&#xA;            只逻辑分代, 不物理分代 &#xA;                内存分Region, Region组成不同大小块，块在逻辑分代中&#xA;                Eden和Old区的内存映射会变化&#xA;            动态新老代空间                      # 如果YGC频繁，就Young调大&#xA;                不要手工指定, 是G1预测YGC停顿时间的基准, 停顿时间通过参数设置&#xA;        概念&#xA;            CSet            # Collection Set&#xA;                可回收Region集合, 回收时存活的对象被移动&#xA;                占堆空间不到1%&#xA;            RSet            # Remembered Set&#xA;                用于找到谁引用当前对象(对象级别), 记录其他Region的引用&#xA;                赋值时有GC写屏障                # 非内存屏障&#xA;            CardTable       # YGC定位垃圾，要从Root查所有Old区对象，效率低&#xA;                Old区对象引用Young区时, bitmap标DirtyCard。YGC时只扫描DirtyCard&#xA;            MixedGC         # 默认45%, 同CMS&#xA;                初始标记&#xA;                重新标记&#xA;                筛选回收    # 筛选Region回收，有用对象复制到其它Region&#xA;        日志&#xA;            [GC pause (G1 Evacuation Pause) (young) (initial-mark)]         # 复制存活对象, initial-mark在MixedGC时有&#xA;            [GC concurrent-root-region-scan-start]                          # 混合回收&#xA;            [GC concurrent-mark-start]                                      # 混合回收&#xA;            [Full GC (Allocation Failure)]                                  # 无法evacuation时, G1中很严重&#xA;    ZGC                     # JDK11, 不分代(SingleGeneration)&#xA;        特点&#xA;            STW设计10ms, 实际1ms&#xA;            适用4T（JDK13 16T）&#xA;            内存分块（有大有小）&#xA;        概念&#xA;            没有RSet, 改进了SATB指针&#xA;    Shenandoah              # JDK11&#xA;    Epsilon                 # JDK11, debug用&#xA;    Zulu&#xA;组合&#xA;    S + SO&#xA;    PS + PO                 # 1.8默认, 10G内存10+秒&#xA;    PN + CMS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;算法&#34;&gt;&#xA;  算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;定位&#xA;    引用计数(ReferenceCount)&#xA;        循环引用问题        # 内部互相引用，没有外部引用&#xA;    根可达算法(RootSearching)&#xA;        线程栈变量 &#xA;        静态变量&#xA;        常量池&#xA;        JNI指针             # 本地方法用到的对象&#xA;并发标记&#xA;    三色标记&#xA;        白                  # 未被标记&#xA;        灰                  # 自身被遍历到，成员变量未被遍历到&#xA;        黑                  # 自身、成员变量都被遍历到&#xA;        漏标问题 &#xA;            两个必要条件 &#xA;                黑引用白后，灰对白的引用断开&#xA;            算法&#xA;                incremental update                      # 增量更新，关注引用的增加, CMS用的&#xA;                    增加引用后，标记为灰, 重新标记阶段再扫描&#xA;                    缺点是灰色还要重新扫描&#xA;                SATB snapshot at the beginning          # 关注引用的删除, G1用的&#xA;                    开始时快照, 引用消失时，引用推到堆栈, 下次扫描还扫白色对象&#xA;                    优点是只扫描修改过的对象, 看RSet中有没有引用&#xA;    颜色指针                # 信息记在指针里&#xA;    租户隔离, Session Base GC           # Web专用, 基于session, session断开后删除&#xA;    各GC应用&#xA;        CMS&#xA;            三色标记 + Incremental Update&#xA;        G1&#xA;            三色标记 + SATB&#xA;        ZGC&#xA;            颜色指针 + 写屏障&#xA;        Shenandoah&#xA;            颜色指针 + 读屏障&#xA;清除&#xA;    标记清除(Mark-Sweep)    # 一遍标记，一遍清理, 适合老年代&#xA;        算法简单，戚对象多时效率高&#xA;        两遍扫描效率低，容易产生碎片&#xA;    拷贝(Copying)           # 存活对象copy到新内存, 旧内存直接清理，适合伊甸区(新生代)&#xA;        适用存活对象少的情况&#xA;        内存减半&#xA;    标记压缩(Mark-Compact)  # 有用的填到前边去空隙去, 适合老年代&#xA;        不会碎片，不会内存减半&#xA;        扫描两次，还要移动&#xA;分代模型&#xA;    分代模型                # -Xms -Xmx设置大小&#xA;        new/young(新生代)   # MinorGC/YGC, -Xmn设置大小, 默认占比1&#xA;            eden(伊甸)      # 默认占比8&#xA;            survivor x 2    # 默认每个占比1&#xA;        old(老年代)         # MajorGC/FullGC, 1.8默认占比2, 之前是3&#xA;            tenured(终身)&#xA;        methodArea          # 1.7永久代, 1.8元数据区&#xA;    各JVM的分代模型&#xA;        Epsilon ZGC Shenandoah不是分代模型&#xA;        G1是逻辑分代，物理不分代&#xA;        其他都是逻辑分代 + 物理分代&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;调优tuning&#34;&gt;&#xA;  调优(Tuning)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b0%83%e4%bc%98tuning&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;前提&#xA;    从业务场景开始&#xA;    无监控(能压测), 不调优&#xA;目标&#xA;    减少FGC&#xA;    确定倾向                        # 吞吐量, 或响应时间&#xA;        吞吐量好: PS + PO&#xA;        响应时间好: G1 或 PN + CMS  # G1吞吐量少10%&#xA;组成部分&#xA;    JVM预规划&#xA;    优化JVM运行环境(慢、卡顿)&#xA;    解决JVM运行时出现的问题(OOM)&#xA;步骤&#xA;    熟悉业务场景&#xA;        响应时间&#xA;        吞吐量&#xA;    选择回收器组合&#xA;    计算内存需求(小的快，大的少gc)&#xA;    选CPU&#xA;    设定年代大小、升级年龄&#xA;    设定日志参数&#xA;    观察日志情况&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;问题分析&#34;&gt;&#xA;  问题分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工具-1&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;CPU经常100%&#xA;    top查进程CPU(top)&#xA;    进程中线程CPU(top -Hp)&#xA;    导出该线程堆栈(jstack)&#xA;    查哪个方法(栈帧)消耗时间(jstack)&#xA;内存高&#xA;    导出堆内存(jmap)&#xA;    分析(jhat jvisualvm mat jprofiler ...)&#xA;监控JVM&#xA;    jstat jvisualvm jprofiler arthas top ...&#xA;    网管: Ansible&#xA;流程&#xA;    网管报警&#xA;    top -Hp 进程号&#xA;    jstack 进程号               # 列出所有线程号, 线程状态&#xA;        WAITING, 一直等不到, BLOCKED, 拿不到锁&#xA;        waiting on &amp;lt;0x0000&amp;gt; (a java.lang.Object)    # 找到目标等待的线程&#xA;    jstack -l 16进制线程号      &#xA;    jps&#xA;    jinfo 进程号                # 列JVM信息&#xA;    jstat -gc 进程号 500        # 每500ms打印一次gc信息&#xA;    jmap -histo 进程号 | head -20                   # 列所有对象&#xA;        有性能消耗，但不很高，可以在线执行&#xA;    jmap -dump:format=b, file=x pid                 # 导出转储文件&#xA;        内存特别大时，jmap会卡顿&#xA;        多个服务器可用，停一个不影响&#xA;        设定HeapDumpOnOutOfMemoryError产生堆转储文件                 &#xA;        在线定位(中小型公司用不到)&#xA;    jhat -J-mx512M x.hprof      # 分析堆dump文件, 有OQL&#xA;    arthas                      # 在线定位&#xA;        启动&#xA;            java -jar arthas-boot.jar&#xA;        常用命令                # 没有集成jmap功能&#xA;            jvm                 # jinfo&#xA;            thread              # jstack&#xA;                thread 1&#xA;            dashboard           # top&#xA;            heapdump            # jmap -dump&#xA;            dump&#xA;            redefine            # 热替换&#xA;                目前只能改method实现，不能改方法名与属性&#xA;            jad                 # 反编译类&#xA;                看动态代理生成的类&#xA;                看第三方类&#xA;                看版本&#xA;            sc                  # search class, 显示class信息&#xA;            watch               # watch method&#xA;    MAT                         # 分析dump文件&#xA;    jprofiler&#xA;    jconsole                    # 需要JMX&#xA;        JMX会消耗性能生产服务器不开&#xA;        JMX图形界面只用于压测&#xA;    jvisualVM                   # 需要JMX, 可分析dump文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;内存-1&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;现象&#xA;    OOM崩溃&#xA;    CPU飙高, 不断FGC&#xA;线程池不当运用&#xA;加内存反而卡顿&#xA;    GC, 应该用CMS或G1替换 PS+PO&#xA;JIRA不停FGC, 没定位出来&#xA;    扩内存到50G, GC换G1, 重启&#xA;tomcat server.max-http-header-size过大&#xA;    默认4096, 每个请求都分配&#xA;lambda表达式导致方法区溢出&#xA;    java.lang.OutofMemoryError: Compressed class space&#xA;disruptor不释放缓存&#xA;使用Unsafe分配内存, 直接内存溢出&#xA;-Xss设定小, 栈溢出&#xA;重写finalize()引发GC&#xA;    finalize()耗时长, GC时回收不过来，不停GC&#xA;内存不到10%，频繁FGC&#xA;    有人显式调用System.gc()                         # 不定时调，但会频繁调&#xA;大量线程, native thread OOM&#xA;    减少堆空间，留更多系统内存产生native thread&#xA;G1产生FGC&#xA;    降低MixedGC触发的阈值       # 默认45%&#xA;    扩内存&#xA;    提高CPU                     # 回收快&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hotspot参数&#34;&gt;&#xA;  HotSpot参数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hotspot%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;辅助&#xA;    -XX:+PrintCommandLineFlags -version             # 打印启动参数, -version是随便一个命令&#xA;    -XX:+PrintFlagsFinal -version                   # 打印所有XX参数&#xA;    -XX:+PrintFlagsInitial      # 打印默认参数&#xA;    -XX:+PrintVMOptions         # 显示VM启动参数&#xA;    -                           # 标准参数&#xA;    -X                          # 显示非标参数&#xA;    -XX                         # 显示不稳定参数&#xA;内存&#xA;    -XX:+HeapDumpOnOutOfMemoryError                 # OOM时产生堆转储文件 &#xA;    -Xms40M                     # 堆起始大小&#xA;    -Xmx60M                     # 堆最大大小, 最好和Xms一样以免堆弹大弹小&#xA;    -Xmn                        # 年经代&#xA;    -Xss                        # 栈空间&#xA;    -XX:InitialHeapSize         # 起始堆大小，自动算&#xA;    -XX:MaxHeapSize             # 堆最大大小，自动算&#xA;内存模型&#xA;    -XX:-DoEscapeAnalysis       # 去逃逸分析&#xA;    -XX:-EliminateAllocations   # 去标量替换&#xA;    -XX:-UseTLAB                # 去tlab&#xA;    -XX:TLABSize                # 设置TLAB大小&#xA;    -XX:+PrintTLAB&#xA;    -XX:MaxTenuringThreshold    # 进老年代（升代）回收次数, 最大值15， CMS默认6，其它默认15&#xA;对象和类&#xA;    -XX:+UseCompressedClassPointers                 # class指针压缩&#xA;        开启时4字节，不开启时8字节&#xA;    -XX:+UseCompressedOops                          # 引用类型指针压缩, Ordinary Object Pointers&#xA;        开启为4字节，不开启时8字节&#xA;    -verbose:class              # 类加载详细过程&#xA;    -XX:PreBlockSpin            # 锁自旋次数&#xA;编译&#xA;    -Xmixed                     # 混合模式&#xA;    -Xint                       # 解释模式&#xA;    -Xcomp                      # 编译模式&#xA;    -XX:CompileThreshold = 10000                    # 检测热点代码次数&#xA;GC&#xA;    -XX:+PrintGC                # 打印GC信息&#xA;    PrintGCDetails              # 打印GC更详细&#xA;    PrintGCTimeStamps           # 打印GC时间&#xA;    PrintGCCauses               # GC原因&#xA;    PrintHeapAtGC&#xA;    PrintGCApplicationConcurrentTime                # GC应用程序时间&#xA;    PrintCApplicationStoppedTime                    # 打印STW时长&#xA;    -XX:+PrintReferenceGC       # 打印回收多少种引用类型&#xA;    -XX:+UseConcMarkSweepGC     # 用CMS&#xA;    -XX:+DisableExplictGC       # System.gc()不管用&#xA;&#xA;    Parallel常用&#xA;        -XX:SurvivorRatio           # 新生代Eden区和Surivor区的比例&#xA;        -XX:PreTenureSizeThreshold  # 大对象到底多大&#xA;        -XX:+ParallelGCThreads      # 并发线程数, 默认是CPU数&#xA;        -XX:+UseAdaptiveSizePolicy  # 自动调所有区比例&#xA;    CMS常用&#xA;        -XX:ParallelCMSThreads      # 并发线程数，默认是CPU数一半&#xA;        -XX:CMSInitiatingOccupancyFraction 92%          # 老年代占多少时触发GC, 1.8 92%, 之前68%&#xA;            设小一点，清除浮动垃圾&#xA;            过大时，栈分配不下，Promotion Failure，触发FGC&#xA;        -XX:+UseCMSCompactAtFullCollection              # GC时压缩，避免碎片片&#xA;        -XX:CMSFullGCsBeforeCompaction                  # 多少次GC后压缩&#xA;        -XX:+CMSClassUnloadingEnabled                   # 回收方法区&#xA;        -XX:CMSInitiatingPermOccupancyFraction          # 到什么比例时进行Perm回收, 1.8之前&#xA;        GCTimeRatio                                     # GC占程序运行时间的百分比&#xA;        -XX:MaxGCPauseMillis                            # GC停顿时间, CMS会减少年轻代大小&#xA;    G1&#xA;        -XX:MaxGCPauseMillis                            # STW时间, 区别CMS, G1会调整Young区的块数&#xA;        GCTimeRatio&#xA;        -XX:GCPauseIntervalMillis                       # STW之间间隔时间&#xA;        -XX:+G1HeapRegionSize                           # Region大小, 1 2 4 8 16 32, 逐渐增大, GC间隔更长, 每次GC时间更长&#xA;            ZGC是动态调整的&#xA;        G1NewSizePercent                                # 新生代最小比例, 默认5%&#xA;        G1MaxNewSizePercent                             # 新生代最大比例，默认60%&#xA;        ConcGCThreads                                   # GC线程数&#xA;        InitiatingHeapOccupancyPercent                  # 启动GC的堆空间占用比例&#xA;&#xA;JMX监控&#xA;    -Djava.rmi.server.hostname=192.168.1.1&#xA;    -Dcom.sun.management.jmxremote &#xA;    -Dcom.sun.management.jmxremote.port=11111 &#xA;    -Dcom.sun.management.jmxremote.authenticate=false &#xA;    -Dcom.sun.management.jmxremote.ssl=false&#xA;调优                            # 参数越来越少&#xA;    JVM参数800个&#xA;    CMS参数300个&#xA;    G1参数100个&#xA;    ZGC更少&#xA;    Zing1个&#xA;GC组合参数&#xA;    -XX:+UseSerialGC&#xA;        S + SO&#xA;    -XX:+UseParNewGC                # 已废弃&#xA;        PN + SO&#xA;    -XX:+UseConc(urrent)MarkSweepGC&#xA;        PN + CMS + SO&#xA;    -XX:+UseParallelGC               # 1.8默认&#xA;        PS + PO&#xA;    -XX:+UseParallelOldGC&#xA;        PS + PO&#xA;    -XX:+UseG1GC&#xA;        G1&#xA;日志参数&#xA;    -Xloggc:/logs/xx-xx-%t.log&#xA;    -XX:+UseGCLogFileRotation           # 5个满了，覆盖第一个&#xA;    -XX:NumberOfGCLogFiles=5&#xA;    -XX:GCLogFileSize=1024M&#xA;    -XX:+PrintGCDetails&#xA;    -XX:+PrintGCDateStamps&#xA;    -XX:+PrintGCCause&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hotspot日志&#34;&gt;&#xA;  HotSpot日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hotspot%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;GC                          # PrintGCDetails&#xA;    [GC&#xA;        GC表示YGC, Full GC是FGC&#xA;    (Allocation Failure)&#xA;        原因&#xA;    [DefNew:4544k-&amp;gt;259k(6144k), 0.0873 secs]&#xA;        DefNew表示年轻代, 回收前后的大小, 6144是年轻代总大小，回收时间&#xA;    4544k-&amp;gt;4356k(19840k), 0.0812 secs]&#xA;        堆的前后大小, 19840是堆总空间, 回收时间&#xA;    [Times: user=0.01 sys=0.00, real=0.01 secs]&#xA;        linux time命令，用户态时间，内核态时间，总时间&#xA;异常退出dump堆&#xA;    def new generation total 6144k, used 5504k [0x00, 0x00, 0x00]&#xA;        新生代总共多少，用了多少。内存起始地址，使用空间结束地址，整体空间结束地址&#xA;        total = eden + 1个survivor&#xA;    eden space 5504k, 100% used []&#xA;        eden&#xA;    from space 640k, 0% used []&#xA;        s0&#xA;    to space 640, 0% used []&#xA;        s1&#xA;    tenured generation total 13696k, used 13312k []&#xA;        old&#xA;    the space 13696k, 97% used []&#xA;        old&#xA;    Metaspace used 2538k, capacity 4486k, committed 4864k, reserved 1056768k&#xA;        used真正使用的大小&#xA;        capacity目前指定的容量 &#xA;        committed 表示预先占用的大小&#xA;        reserved表示共保留的大小&#xA;    class space used 275k, capacity 386k, committed 512k, reserved 1048576k&#xA;        metaspace中存class的部分&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>算法思想</title>
      <link>https://runout.run/docs/basic/algorithm/thought/</link>
      <pubDate>Mon, 08 Oct 2018 22:21:21 +0800</pubDate>
      <guid>https://runout.run/docs/basic/algorithm/thought/</guid>
      <description>&lt;h1 id=&#34;口诀&#34;&gt;&#xA;  口诀&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%a3%e8%af%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;难题首选动归&#xA;受阻贪心暴力&#xA;考虑分治思想&#xA;配合排序哈希&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;递归recursion&#34;&gt;&#xA;  递归(recursion)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%92%e5%bd%92recursion&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    利用递归，把状态的管理责任推给运行时&#xA;递归转迭代&#xA;    可加上memory做优化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;分治divide-and-conquer&#34;&gt;&#xA;  分治(divide and conquer)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%b2%bbdivide-and-conquer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    广义分治法&#xA;例子&#xA;    二分检索&#xA;    找最大/最小元素&#xA;    归并分类&#xA;    快速分类&#xA;    选择问题&#xA;    斯特拉森矩阵乘法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;贪心greedy&#34;&gt;&#xA;  贪心(greedy)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%aa%e5%bf%83greedy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;案例&#xA;    Dijkstra最短路径&#xA;    最小生成树Prim, Kruskal&#xA;&#xA;    背包问题&#xA;    作业排序&#xA;    最优归并模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;动态规划dynamic-planning&#34;&gt;&#xA;  动态规划(dynamic planning)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92dynamic-planning&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    常用滚动数组降低空间复杂度&#xA;案例&#xA;    多段图&#xA;    结点间最短路径&#xA;    最优二叉检索树&#xA;    0/1背包问题&#xA;    可靠性设计&#xA;    货郎担问题(旅行商问题)&#xA;    流水线调度问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;检索与周游retrievaltravel&#34;&gt;&#xA;  检索与周游(retrieval/travel)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a3%80%e7%b4%a2%e4%b8%8e%e5%91%a8%e6%b8%b8retrievaltravel&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;案例&#xA;    深度优先检索&#xA;    广度优先检索&#xA;    与/或图&#xA;    对策树&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;回溯backtracking&#34;&gt;&#xA;  回溯(backtracking)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%9e%e6%ba%afbacktracking&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;案例&#xA;    8皇后问题&#xA;    图的着色&#xA;    哈密顿环&#xA;    背包问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;暴力brute-force&#34;&gt;&#xA;  暴力(brute force)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9a%b4%e5%8a%9bbrute-force&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    分支限界条件加快效率&#xA;例子&#xA;    DFS, BFS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分支-限界(branch and bound)&#xA;案例&#xA;LC检索&#xA;0/1背包问题&#xA;货郎担问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;并行parallel&#34;&gt;&#xA;  并行(parallel)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e8%a1%8cparallel&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;时间复杂度time-complexity&#34;&gt;&#xA;  时间复杂度(time complexity)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6time-complexity&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;O()表示上界(&amp;lt;=), Ω() [omega]表示下界(&amp;gt;=), Θ() [Theta] 表示上下界相同, o()表示非Θ()的O()&#xA;    N &amp;gt;= n0时, T(N) &amp;lt;= cf(N), 记为T(N) = O(f(N))&#xA;    N &amp;gt;= n0时, T(N) &amp;gt;= cg(N), 记为T(N) = Ω(g(N))&#xA;    T(N) = Θ(h(N)) 当且仅当T(N) = O(h(N)) 和 T(N) = Ω(h(N))&#xA;上界(upper bound)&#xA;下界(lower bound)&#xA;法则&#xA;    # 约定, 不存在特定的时间单位&#xA;    # 约定, 机器模型中, 1. 所有指令顺序执行。2. 任一简单的工作都恰好花费一个时间单位&#xA;    ## 假设不存在如矩阵求逆或排序这样的单位操作&#xA;    1. 如果T1(N) = O(f(N)), T2(N) = O(g(N)), 那么&#xA;        T1(N) + T2(N) = O(f(N) + g(N)), 或写成 max(O(f(N)), O(g(N)))&#xA;        T1(N) * T2(N) = O(f(N) * g(N))&#xA;    2. 如果T(N)是一个k次多项式, 则T(N) = Θ(N^k)&#xA;    3. 对任意常数k, (logk) * N = O(N)&#xA;        # 对数增长得非常缓慢&#xA;一般法则&#xA;    1. for 循环时间, 为内部语句的运行时间 * 迭代次数&#xA;    2. 嵌套for 循环, 内部语句时间 * 迭代次数n次方&#xA;    3. 顺序语句, 各语句时间求和&#xA;    4. if(S1)/else(S2), 判断的运行时间加 S1和S2中时间长者&#xA;相对增长率(relative rate of growth)&#xA;    lim(N-&amp;gt;∞)f(N)/g(N)来确定两个函数的相对增长率&#xA;        1. 极限是0, 则f(N) = o(g(N))&#xA;        2. 极限是c&amp;lt;&amp;gt;0, 则f(N) = Θ(g(N))&#xA;        3. 极限是∞, 则g(N) = o(f(N))&#xA;        4. 极限摆动，则f(N)与g(N)无关&#xA;    洛必达法则&#xA;        lim(N-&amp;gt;∞)f(N) = ∞, 且lim(N-&amp;gt;∞)g(N) = ∞ 时, lim(N-&amp;gt;∞)f(N)/g(N) = lim(N-&amp;gt;∞)f&#39;(N)/g&#39;(N)&#xA;多项式时间算法&#xA;    O(1) &amp;lt; O(logn) &amp;lt; O(n) &amp;lt; O(nlogn) &amp;lt; O(n^2) &amp;lt; O(n^3)&#xA;指数时间算法&#xA;    O(2^n) &amp;lt; O(n!) &amp;lt; O(n^n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://runout.run/docs/algorithm/p1.jpg&#34; alt=&#34;时间复杂度&#34; /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据结构</title>
      <link>https://runout.run/docs/basic/algorithm/data_structure/</link>
      <pubDate>Sun, 07 Oct 2018 13:46:46 +0800</pubDate>
      <guid>https://runout.run/docs/basic/algorithm/data_structure/</guid>
      <description>&lt;h1 id=&#34;线性&#34;&gt;&#xA;  线性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;列表(list)&#xA;    数组(array)&#xA;        # 相同数据类型元素的序列，下标(index)访问&#xA;        low high&#xA;        字符串&#xA;            二进制串(binary string)&#xA;                # 位串(bit string)&#xA;    链表(linked list)&#xA;        节点(node)&#xA;            指针(pointer)&#xA;        表头(header)&#xA;        单链表(singly linked list)&#xA;        双链表(doubly linked list)&#xA;    栈(stack)&#xA;        # 插入和删除只能在端部进行的列表，应用于递归&#xA;        栈顶(top)&#xA;        LIFO last-in-first-out&#xA;    队列(queue)&#xA;        队头(front)&#xA;        队尾(rear)&#xA;        入队(enqueue)&#xA;        FIFO first-in-first-out&#xA;        优先队列(priority queue)&#xA;            # 数据项多来自于全序域(常整数或实数)&#xA;            查找最大元素，删除最大元素，插入新元素&#xA;            堆(heap)实现&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;散列表&#34;&gt;&#xA;  散列表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%a3%e5%88%97%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    有序输入时，树效率低，如果不要求查找有序结果，可以用散列&#xA;概念&#xA;    hash table&#xA;    hashing(散列)&#xA;    item(项)&#xA;    key(关键字)&#xA;        # 项中某部分&#xA;    hash function(散列函数)&#xA;        # 映射函数&#xA;    collsion(冲突)&#xA;        # 多个关键字散列到同项的状况&#xA;    load factor(装填因子)&#xA;        # λ 元素个数对表长度的比，&#xA;        # 如果散列是均匀的，表示了一个项中关键字的平均长度&#xA;        # 一次成功查找要遍历约1 + (λ / 2)个链，1表示被匹配的项&#xA;    rehashing(再散列)&#xA;        一半时进行&#xA;        直到插入失败再进行&#xA;        middle-of-the-road&#xA;            # 到达某load factor时进行&#xA;    caching the hash code(闪存散列代码)&#xA;算法&#xA;    separate chaining(分离链接法)&#xA;        # 解决冲突&#xA;    probing hash table(探测散列表)&#xA;        线性探测法&#xA;            primary clustering(聚集)&#xA;                # 线性探测法中形成数据区块&#xA;        平方探测法&#xA;            secondary clustering(二次聚集)&#xA;                # 模拟结果指出，对每次查找，会引起另外的少于一半的探测&#xA;        double hashing(双散列)&#xA;            # 模拟表明, 两个散列都mod质数时，探测次数几乎和随机冲突解决方法相同&#xA;    extendible hashing(可扩散列)&#xA;        D directory(目录)&#xA;            # 一个分区中bit的个数，所以M最多2^D&#xA;        性质&#xA;            # 基于位模式(bit patterm)是均匀分布的事实, 是&amp;quot;分支系数(branch factor)&amp;quot;, N 是记录总数(随时间变化)&#xA;            树叶期望个数为(N/M)log(2)(e)&#xA;                所以平均树叶满的程度为ln2 = 0.69, 同B树&#xA;            目录期望大小为O(N^(1 + 1 / M) / M)&#xA;        叶子可以指向实际记录的链表(内存装不下太大目录时)，这样得到实际数据就需要第二次磁盘访问&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;队列&#34;&gt;&#xA;  队列&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%9f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    queue 先进先出&#xA;概念&#xA;    enqueue(入队)&#xA;    dequeue(出队)&#xA;    priority queue(优先队列)&#xA;        insert&#xA;        deleteMin&#xA;    binomial queue(二项队列)&#xA;        merge, insert, deleteMin 最坏时间为O(logN), 插入花费常数时间&#xA;        堆序树(二项树)的森林实现&#xA;        B0 = 2^0, B1 = 2^1, B2 = 2^2 ...&#xA;        Bn = B0 + B1 + ... B(n-1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;集合&#34;&gt;&#xA;  集合&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e5%90%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    set(集合)，互不相同项的无序组合(可空)&#xA;    element(元素)&#xA;    dictionary(字典)，能够查找，增加，删除元素的集合&#xA;        # 实现时要达到效率的平衡&#xA;    set union problem(集合合并问题)&#xA;        # 动态地把n个元素集合划分为一系列不相交的子集&#xA;    ADT abstract data type(抽象数据类型)&#xA;        # 由表示数据项的抽象对象集合和一系列对它的操作构成&#xA;实现&#xA;    universal set(通用集合)&#xA;        通用集合的子集，用长度为n(通用集合的长度)的位向量(bit vector)表示&#xA;            # 占用大量存储空间&#xA;    线性列表&#xA;        # 去除包含的重复元素&#xA;        # 列表是有序的，但这差别并不重要&#xA;        多重集(multiset)、包(bag)&#xA;            # 可重复项的无序组合&#xA;&#xA;表示&#xA;    S = {2, 3, 5, 7}&#xA;    S = {n: n 为小于0的质数}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;树&#34;&gt;&#xA;  树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    tree&#xA;    free tree(自由树)，连通无回路的图&#xA;    full tree(满树)，所有节点要么是树叶，要么是两个儿子&#xA;    forest(森林)，无回路但不一定连通的图&#xA;    root&#xA;    rooted tree(有根树)，确定根的树，常简称为树&#xA;    node&#xA;    ancestor(祖先)，顶点本身也作为自己的祖先&#xA;        proper ancestor(真祖先)，除了自己的祖先&#xA;    parent(父母)&#xA;    child(子女)&#xA;    sibling(兄弟)&#xA;    leaf(叶节点), 没有子女的顶点&#xA;    parental(父节点)，至少有一个子女的顶点&#xA;    descendant(子孙)，以v为祖先的所有节点，包含v&#xA;        proper descendant(真子孙)，不包含本身&#xA;    subtree(子树) &#xA;&#xA;    depth(深度)，从根到v简单路径的长度&#xA;        height depth 树中结点的最大级数&#xA;    rank(秩)&#xA;        # 子女数&#xA;    height(高度)，从根到叶节点最长简单路径的长度&#xA;        # 按树的层的数量定义时，高度增加1&#xA;    degree(度，一个节点子树的数目) &#xA;    level(root为1级, 结点为p级时，儿子在p+1级)&#xA;&#xA;    state-space tree(状态空间树)，可用于分析回溯和分支界限&#xA;    ordered tree(有序树)，有根树的每个顶点，所有子女有序&#xA;        first child-next sibling representation(先子女后兄弟表示法)&#xA;            # 子女数不定，父节点只存第一个子女，该子女存兄弟链表&#xA;            ## 以一种高效方式将有序树改造成关联二叉树&#xA;            ## 关联二叉树中，左指针表示下层，右指针表示兄弟节点&#xA;    binary tree(二叉树)，属于有序树&#xA;        left child(左子女)&#xA;        right child(右子女)&#xA;        左(右)子树&#xA;            # 二叉树可以递归定义，所有可以用递归算法&#xA;        binary search tree(二叉查找树)，父母顶点比左子树中所有数字大，右子树中小&#xA;            效率，多取决于高度&#xA;                logn &amp;lt;= h &amp;lt;= n - 1&#xA;                    # h 为高度, n为顶点数&#xA;    multiway search tree(多路查找树)&#xA;        B树, B+树, B-树&#xA;边&#xA;    树向边&#xA;    回边&#xA;    前向边&#xA;        # 顶点到非子孙&#xA;    交叉边&#xA;        # 非前三都是交叉边&#xA;性质&#xA;    |E| = |V| - 1&#xA;        # 树的边数总比顶点数小1&#xA;        # 图变树的必要不充分条件，连通图变树的必要充分条件&#xA;    任意两个顶点间总存在简单路径，任选顶点可作根&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;二叉树&#34;&gt;&#xA;  二叉树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e5%8f%89%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    binary tree&#xA;    常用顺序表或链表存储&#xA;概念&#xA;    full binary tree(满二叉树)&#xA;        # 满子节点，且子节点在同一层上&#xA;    heap(堆)&#xA;        # 根向下从大到小排序&#xA;    binary search tree(二分检索树)&#xA;        # 左子节点小于父节点小于右子节点&#xA;    left child(左子女)&#xA;    right child(右子女)&#xA;    左(右)子树&#xA;        # 二叉树可以递归定义，所有可以用递归算法&#xA;&#xA;    complete binary tree(完全二叉树)&#xA;        # 只有最大层节点不满且连续集中在左边&#xA;        高是logN&#xA;        可以用数组实现(从index = 1开始存储)&#xA;            左儿子在2i, 右儿子在2i + 1, 父亲在i / 2&#xA;    perfect binary tree(理想二叉树)&#xA;        # 满节点二叉树&#xA;    full binary tree(满二叉树)&#xA;        # 同理想二叉树&#xA;    skewed tree(斜树)        &#xA;        # 一个节点不断左斜是左斜树，相反为右斜树&#xA;    binary search tree(二叉查找树)&#xA;        # 父母顶点比左子树中所有数字大，右子树中小&#xA;    AVL tree(Adelson-Velskii-Landis tree)&#xA;        # 带有平衡条件(balance condition)的二叉查找树&#xA;        平衡条件: 左右子树最多差1&#xA;            # 节点中存储高度信息&#xA;    splay tree(伸展树)&#xA;        # 分析树的一种&#xA;&#xA;效率，多取决于高度&#xA;    logn &amp;lt;= h &amp;lt;= n - 1&#xA;        # h 为高度, n为顶点数&#xA;树转换二叉树&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;堆&#34;&gt;&#xA;  堆&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a0%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    binary heap(二叉堆、堆)&#xA;        # 一棵完全二叉树&#xA;        结构性&#xA;        heap-order property(堆序性)&#xA;            heap-order tree(堆序树)&#xA;            已证明，平均一次插入需要2.607次比较，所以上移1.607层&#xA;    d-堆&#xA;        # 二叉堆是2-堆&#xA;        deleteMin为时间为O(dlog(d)(N))&#xA;        实践中&#xA;            插入次数比deleteMin次数多(可加速)&#xA;            主存不够时如B树使用&#xA;            4-堆胜过二叉堆&#xA;    leftist heap(左式堆)&#xA;        不是理想平衡(perfectly balanced)的，实际趋向于不平衡&#xA;        具有堆序性&#xA;        npl(X) null path length 零路径长&#xA;            # X到一个不具有两个儿子节点的最短路径。到本身npl(X) = 0。npl(null) = -1&#xA;        o(N)时间处理一个merge&#xA;        定义&#xA;            堆中每个节点，左儿子的npl &amp;gt;= 右儿子的npl&#xA;        操作&#xA;            merge&#xA;            insert&#xA;            deleteMin&#xA;        性质&#xA;            左儿子npl &amp;gt;= 右儿子npl&#xA;    skew heap(斜堆)&#xA;        有堆序性&#xA;        定义&#xA;            不维护npl&#xA;            每次合并都交换左右(只有左儿子的除外)&#xA;            其它同左式堆&#xA;        性质&#xA;            任意M次连续操作, 总的最坏情况运行时间为O(MlogN), 每次摊开销为O(logN)&#xA;        操作&#xA;            merge&#xA;            insert&#xA;            deleteMin&#xA;    binomial queue(二项树)&#xA;        B(k) 由B(0), B(1), ... B(k - 1)连接根组成&#xA;        有2^k个节点, k为高度&#xA;    pairing heap(配对堆)&#xA;    fibonacci heap(斐波那契堆)&#xA;算法&#xA;    heapsort(堆排序)&#xA;    merge(合并)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;图&#34;&gt;&#xA;  图&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    graph&#xA;    vertices(结点)&#xA;    edge(边)&#xA;        # 是结点对偶的集合&#xA;    endpoint(端点)&#xA;        # 边(u, v)的端点u, v&#xA;    incident(关联)&#xA;        # u, v和边(u, v)关联&#xA;    尾(tail)头(head)&#xA;        # 边(u, v)离开u进入v, u是尾, v是头&#xA;    loop(环)&#xA;        # 连接顶点自身的边，只考虑不含圈的图&#xA;    cycle(圈)&#xA;        # 长至少1的路径&#xA;    acycle(无圈的)&#xA;    DAG(无圈图)&#xA;    adjacent(邻接)&#xA;        # (i, j)则i, j邻接&#xA;&#xA;    directed(图是有向的)&#xA;        # 对偶&amp;lt;i, j&amp;gt;与对偶&amp;lt;j, i&amp;gt;不同&#xA;    digraph(有向图)&#xA;    undirected(无向的)&#xA;        # 边表示为(i, j)&#xA;&#xA;    network(网络)&#xA;        # 边上有成本的图&#xA;    weighted graph(加权图)&#xA;        # weighted digraph(加权有向图)相同&#xA;        weight(权重)&#xA;        cost(成本)&#xA;&#xA;    度&#xA;        # 点的邻接点的数目&#xA;    出度&#xA;        # 有向图中，用该点作为第一个成分的边数目&#xA;    path(路)&#xA;        # 结点序列&#xA;        cycle(环、回路)&#xA;            # 首尾相同的简单路&#xA;        acyclicity(无环性)&#xA;&#xA;        connected(连通的)&#xA;            # 每一对结点间存在一条路&#xA;        connectivity(连通性)&#xA;        connected component(连通分量)&#xA;            # 非连通图中包含的连通部分&#xA;        underlying graph(基础图)&#xA;            # 有向图去掉方向&#xA;        strongly connected(强连通的)&#xA;            # 有向图中, 一对结点都存在互相连通的路，则两点强连能&#xA;        weakly connected(弱连通的)&#xA;            # 有向图的基础图是连通的&#xA;        strongly connected graph(强连通图)&#xA;            # 所有结点对强连通&#xA;        strongly connected components(强连通分量)&#xA;            # 极大强连通子图&#xA;    length(路的长度)&#xA;        # 路的边数&#xA;    simple path(简单路)&#xA;        # 除首尾结点外，所有结点不同的路&#xA;    directed path(有向路经)&#xA;&#xA;    complete(完全的)&#xA;        # 任意两个顶点之间都有边相连，表示为K|V|&#xA;    dense(稠密)&#xA;        # 缺少边较少&#xA;    connected(连通的)&#xA;    biconnected(双连通的)&#xA;        # 不存在割点(articulation point)&#xA;表示&#xA;    V = {a, b, c, d, e, f}, E = {(a, c), (a, d), (b, c), (b, f), (c, e), (d, e), (e, f)}&#xA;    |E|&#xA;        # 边的数量&#xA;    |V|&#xA;        # 顶点的数量&#xA;    adjacency matrix(邻接矩阵)&#xA;        # 图的顺序表示法&#xA;        无向图的邻接矩阵总是对称的&#xA;        稠密图，邻接矩阵占空间小&#xA;        weight matrix(权重矩阵)、cost matrix(成本矩阵)&#xA;    adjacency list(邻接表)&#xA;        # 图的链接表示法&#xA;        稀疏图，邻接表占空间小&#xA;公式&#xA;    0 &amp;lt;= |E| &amp;lt;= |V|(|V| - 1) / 2&#xA;        # 无圈无向图，可能包含边的数量&#xA;算法&#xA;    critical path analysis(关键路径分析法)&#xA;应用&#xA;    activity-node graph(动作节点图)&#xA;    event-node graph(事件节点图)&#xA;        slack time(松弛时间)&#xA;        critical path(关键路径)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>数学</title>
      <link>https://runout.run/docs/basic/algorithm/math/</link>
      <pubDate>Sun, 07 Oct 2018 12:46:46 +0800</pubDate>
      <guid>https://runout.run/docs/basic/algorithm/math/</guid>
      <description>&lt;h1 id=&#34;指数&#34;&gt;&#xA;  指数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;X^A * X^B = X^(A + B)&#xA;X^A / X^B = X^(A - B)&#xA;(X^A)^B = X^(A * B)&#xA;X^N + X^N = 2X^N &amp;lt;&amp;gt; X^(2N)&#xA;2^N + 2^N = 2^(N + 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;对数&#34;&gt;&#xA;  对数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;约定&#xA;    计算机科学中, log默认为log(2)&#xA;&#xA;X^A = B, log(X)(B) = A&#xA;log(A)(B) = log(C)(B)/log(C)(A)&#xA;logAB = logA + logB&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;级数&#34;&gt;&#xA;  级数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%a7%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;∑(i=0)(N)2^i = 2^(N + 1) - 1&#xA;∑(i=0)(N)A^i = (A^(N + 1) - 1) / (A - 1)&#xA;    如果0 &amp;lt; A &amp;lt; 1, 则 &amp;lt;= 1 / (1 - A)&#xA;∑(i=1)(∞)i/2^i = 2&#xA;∑(i=1)(N)i = N(N + 1) / 2 ≈ N^2 / 2&#xA;∑(i=1)(N)i^2 = N(N + 1)(2N + 1) / 6 ≈ N^3 / 3&#xA;∑(i=1)(N)i^k ≈ N^(k + 1) / |k + 1|        k &amp;lt;&amp;gt; -1&#xA;    k = -1时, Hn = ∑(i=1)(N)1 / i ≈ log(e)(N), Hn是调和级数&#xA;        该近似式误差趋向于 λ ≈ 0.57721566, 称为欧拉常数(Euler&#39;s constant)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模&#34;&gt;&#xA;  模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;如果N整除A - B, 则称A与B模N同余, 记为A≡B(mod N)&#xA;    81≡61≡1(mod 10)&#xA;如果A≡B(mod N), 则A + C ≡ B + C(mod N)，则AD≡BD(mod N)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;证明方法&#34;&gt;&#xA;  证明方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%81%e6%98%8e%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;归纳法&#xA;    基准情形(base case)&#xA;    归纳假设(inductive hypothesis), k成立&#xA;        证明k + 1成立&#xA;反证法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;无理数&#34;&gt;&#xA;  无理数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a0%e7%90%86%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;圆周率π，黄金分割比ψ，重力加速度g，和自然对数的底e&#xA;    # e约等于2.718281828&#xA;    # e表示基础增长率为1时连续增长的实际增长率&#xA;    ## 连续增长是自然界最广泛、增长最快的一种&#xA;    ## ，所以e也表示自然增长速度, 也是增长的极限速度&#xA;    e=lim(x→∞)(1+1/x)^x&#xA;例子&#xA;    单细胞24小时分裂一次，x天产生2^x个细胞&#xA;    加条件, 一天中新生细胞产生到一半(12小时)的时候自身可以分裂&#xA;        一天产生2.25个细胞, 1个原有，1个新生, 0.25个是新生细胞分裂的&#xA;    改条件，每8小时细胞具有分裂能力&#xA;        一天可得到2.37个细胞&#xA;    改条件，新生细胞每个细微时间都有分裂能力，一天最多可以产生的细胞&#xA;        一天可得到e个细胞&#xA;例子2&#xA;    e或e经过一定变换得到&amp;quot;自然律&amp;quot;&#xA;例子3&#xA;    螺线φkρ=αe。其中，α和k为常数，φ是极角，ρ是极径，e是自然对数的底&#xA;&#xA;pi = 3.&#xA;    14159    26535    89793    23846    26433&#xA;    83279    50288    41971    69399    37510&#xA;    58209    74944    59230    78164    06286&#xA;    20899    86280    34825    34211    70679&#xA;    82148    08651    32823    06647    09384&#xA;    46095    50582    23172    53594    08128&#xA;    48111    74502    84102    70193    85211&#xA;    05559    64462    29489    54930    38196&#xA;    44288    10975    66593    34461    28475&#xA;    64823    37867    83165    27120    19091&#xA;    45648    56692    34603    48610    45432&#xA;    66482    13393    60726    02491    41273&#xA;    72458    70066    06315    58817    48815&#xA;    20920    96282    92540    91715    36436&#xA;    78925    90360    01133    05305    48820&#xA;    46652    13841    46951    94151    16094&#xA;    33057    27036    57595    91953    09218&#xA;    61173    81932    61179    31051    18548&#xA;    07446    23799    62749    56735    18857&#xA;    52724    89122    79381    83011    94912&#xA;    98336    73362    44065    66430    86021&#xA;    39494    63952    24737    19070    21798&#xA;    60943    70277    05392    17176    29317&#xA;    67523&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;组合数学&#34;&gt;&#xA;  组合数学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    鸽巢原理、ramsey定理&#xA;    概率&#xA;        加法原理、乘法原理&#xA;        排列组合、多重集排列组合&#xA;            组合恒等式&#xA;        容斥原理&#xA;            多重集r-组合数&#xA;            mobius反演&#xA;    集合&#xA;        集合分划 stirling数&#xA;    生成函数&#xA;        组合数&#xA;        指数型&#xA;        catalan数列与stirling数列&#xA;        分拆数&#xA;    递推关系&#xA;    群&#xA;        置换群&#xA;        burnside引理&#xA;            共轭类&#xA;            不动置换类&#xA;            等价类&#xA;        polya定理&#xA;&#xA;问题&#xA;    幻方&#xA;    拉丁方&#xA;    涂色&#xA;    非降路径&#xA;    正整数分拆&#xA;        无序分拆&#xA;        ferrers图&#xA;    分配&#xA;    错位排列&#xA;    棋盘多项式与有禁区的排列&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;离散数学&#34;&gt;&#xA;  离散数学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a6%bb%e6%95%a3%e6%95%b0%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;集合&#xA;    c(0)(n) + c(1)(n) + ... + c(n)(n) = 2^n&#xA;        # 幂集&#xA;    关系r&#xA;        子关系&#xA;        逆&#xA;        自反&#xA;        对称、反对称&#xA;        传递&#xA;        乘积(合成)&#xA;        自反闭包&#xA;        等价&#xA;        部分序&#xA;    映射&#xA;        原像、映像&#xA;        满射、单射&#xA;    基数(浓度)&#xA;逻辑&#xA;    联结词&#xA;        ∨, ∧, ￢, ←, →, ↔&#xA;        =, =&amp;gt;&#xA;            # 等价，蕴涵&#xA;    原子、公式、解释&#xA;    范式&#xA;        析取范式&#xA;        合取范式&#xA;        前束范式、skolem范式&#xA;    谓词&#xA;        ∀, ∃&#xA;        谓词演算&#xA;图&#xA;    权图&#xA;        dijkstra算法&#xA;    树&#xA;        最优树&#xA;                kruskal、t*&#xA;    有向图&#xA;        euler路、euler图&#xA;    无向图&#xA;        hamilton路&#xA;    平面图&#xA;        kuratowski判定&#xA;        同胚&#xA;        平面图的euler公式&#xA;        plato体&#xA;        着色&#xA;    匹配&#xA;        二部图&#xA;        增广路&#xA;        最大匹配&#xA;    konig无限性引理&#xA;        王浩定理&#xA;    计算机表示&#xA;        邻接矩阵&#xA;        关联矩阵&#xA;        弧表表示&#xA;        邻接表表示&#xA;        星形表示&#xA;    单源最短路径&#xA;        dijkstra&#xA;        bellman - ford&#xA;    最大流问题&#xA;        增广路定理&#xA;        ford - fulkerson&#xA;        最大容量增广路算法&#xA;        dinic、dinic改进&#xA;        最短增广路算法&#xA;        一般的预流推进算法&#xA;        最高标号预流推进算法&#xA;数论&#xA;    辗转相除&#xA;    质数&#xA;    合同&#xA;        剩余类&#xA;        一次同余式&#xA;        秦九韶定理&#xA;        euler函数&#xA;        一元高次同余式&#xA;        二次剩余&#xA;            legendre符号&#xA;            euler判别法&#xA;            二次剩余互反律&#xA;    应用&#xA;        加密&#xA;群&#xA;    性质&#xA;        封闭性         # 运算结果还在群中&#xA;        结合律         # (a·b)·c = a·(b·c)&#xA;        单位元(幺元)    # e·a = a·e = a&#xA;        逆元           # a·b = b·a = e&#xA;    代数系统&#xA;    半群&#xA;        封闭性&#xA;        结合律&#xA;    幺半群&#xA;        封闭性&#xA;        结合律&#xA;        幺元&#xA;    置换群&#xA;        轮换表&#xA;        奇偶性&#xA;    子群&#xA;        循环群&#xA;        右陪集&#xA;        正规子群&#xA;        lagrange定理&#xA;    同态映射&#xA;        同构映射&#xA;        核&#xA;    环&#xA;        整数环、矩阵环、多项式环&#xA;        消去环、交换环&#xA;        整区&#xA;        域&#xA;        子环&#xA;            理想&#xA;                平凡理想&#xA;                单纯环&#xA;                极大理想&#xA;        合同关系&#xA;        环同态、同构&#xA;    应用&#xA;        计数问题&#xA;            轨道&#xA;            代表元素&#xA;            burnside引理&#xA;        纠错码&#xA;域&#xA;    素域&#xA;    多项式&#xA;        根&#xA;    有理域多项式&#xA;        eisenstein定则&#xA;    分圆多项式&#xA;    有限域&#xA;格&#xA;    x, ⊕&#xA;    对偶原理&#xA;        对偶表达式&#xA;    同态、同构&#xA;    几个分类&#xA;        有界格&#xA;        有余格&#xA;        分配格&#xA;        模格&#xA;    布尔代数&#xA;        有余分配格&#xA;        stone定理&#xA;        化简&#xA;            quine&#xA;            karnaugh图&#xA;语言&#xA;    语法&#xA;        # 任何3型语法都是2型语法...都是1型语法...都是0型语法&#xA;        g = (v, t, s, p)&#xA;            # v 字母表, t是v的一个终止符子集, s是v的一个元素初始符，p是产生式集合&#xA;        0型语法&#xA;            # 没有任何限制&#xA;        1型语法&#xA;            # 产生式如 w1 -&amp;gt; w2, w2长度大于等于w1, 或者 w1 -&amp;gt; λ&#xA;            # 可以写 lw1r -&amp;gt; lw2r , 所以上下文有关&#xA;        2型语法&#xA;            # w1 -&amp;gt; w2, w1是单个非终止符&#xA;        3型语法&#xA;            # w1 -&amp;gt; w2, w1 = a 并且w2 = ab 或者w2 = a, 其中a, b为非终止符, a是终止符，也可以是λ&#xA;            # 正则语法&#xA;    演绎树&#xA;    有输出的fsm&#xA;        mealy机&#xA;        moore&#xA;    没有输出的fsm&#xA;        kleeme闭包&#xA;        终止状态&#xA;    非确定fsm&#xA;        转换确定fsm&#xA;    语言识别&#xA;        可识别集合(stephen kleene)&#xA;        正则表达式&#xA;            kleene定理&#xA;    其它fsm&#xA;        pushdown自动机&#xA;            识别到上下文无关语法&#xA;        线性有界自动机&#xA;            识别到上下文有关语法&#xA;        turing机&#xA;            识别所有语法结构产生的语言，可实现任何算法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;随机数学&#34;&gt;&#xA;  随机数学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%8f%e6%9c%ba%e6%95%b0%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;概率&#xA;    古典概型&#xA;    几何概型&#xA;    条件概率&#xA;        全概率公式&#xA;        bayes公式&#xA;    bernoulli概型&#xA;随机变量&#xA;    离散&#xA;    连续&#xA;    分布函数&#xA;    概率密度&#xA;分布&#xA;    (0 - 1)分布&#xA;    二项分布&#xA;    poisson分布&#xA;    几何分布&#xA;        均匀分布&#xA;        指数分布&#xA;    正态分布&#xA;二维&#xA;    联合概率密度&#xA;    边缘概率分布&#xA;        边缘概率密度&#xA;    二维正态分布&#xA;    条件分布&#xA;    卷积公式&#xA;    n维&#xA;数字特征&#xA;    期望、方差&#xA;        cauchy - schwarz不等式&#xA;        标准化随机变量&#xA;        协方差&#xA;    矩&#xA;        k阶原点矩&#xA;        k阶中心矩&#xA;        k + l 阶混合原点矩&#xA;        k + l 阶混合中心矩&#xA;        协方差矩阵&#xA;            n维正态分布　&#xA;大数&#xA;    chebyshev不等式&#xA;        chebyshev定理&#xA;    bernoulli定理&#xA;    中心极限定理(levy - lindberg定理)&#xA;        de moivre - laplace 极限定理&#xA;        liapunov 定理&#xA;样本&#xA;    样本分布函数&#xA;    伽玛函数&#xA;    χ2分布&#xA;    t 分布&#xA;    f 分布&#xA;参数估计&#xA;    矩估计&#xA;    最大似然估计&#xA;    评选标准&#xA;        无偏性&#xA;        有效性&#xA;        一致性&#xA;    区间估计&#xA;        置信下限、置信上限&#xA;    正态总体参数的区间估计&#xA;    两个正态区间估计&#xA;        u估计&#xA;        t估计&#xA;        f估计&#xA;假设检验&#xA;    显性检验&#xA;    参数检验&#xA;    正态总体参数&#xA;        u检验&#xA;        t检验&#xA;        χ2检验&#xA;        f检验&#xA;        ...&#xA;    分布拟合检验&#xA;回归分析&#xA;    一元线性回归&#xA;        最小二乘&#xA;    可线性化的回归方程&#xA;        双曲线&#xA;        幂函数&#xA;        指数函数&#xA;        倒指数&#xA;        对数&#xA;        s型曲线 1 / (a + b * e ^ -x)&#xA;    多元线性回归模型&#xA;方差分析&#xA;    单因素&#xA;    双因素&#xA;    交互作用双因素&#xA;    正交试验&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/architect/strategy/ai/deep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/architect/strategy/ai/deep/</guid>
      <description></description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/architect/strategy/datalake/ecology/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/architect/strategy/datalake/ecology/</guid>
      <description>&lt;h1 id=&#34;hadoop体系&#34;&gt;&#xA;  Hadoop体系&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hadoop%e4%bd%93%e7%b3%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;发行版&#xA;    Apache Hadoop&#xA;    CDH(Cloudera&#39;s Distribution Including Apache Hadoop)&#xA;    HDP(Hortonworks Data Platform)&#xA;    宜信&#xA;        D.Bus&#xA;            # 数据收集与计算&#xA;        UAVStack&#xA;            # AIOps, 智能运维&#xA;            UAV.Monitor&#xA;                # 监控&#xA;            UAV.APM&#xA;                # 性能管理&#xA;            UAV.ServiceGovern&#xA;                # 服务治理&#xA;            UAV.MSCP&#xA;                # 微服务计算&#xA;        Wormhole&#xA;            # SPaaS(Stream Processing as a Service)&#xA;        Gartner&#xA;            # ITOA，算法即运维&#xA;大数据 &#xA;    PB级数据&#xA;    4V&#xA;        volume(大量)&#xA;        velocity(高速)&#xA;        variety(多样)&#xA;        value(低价值密度)&#xA;    场景&#xA;        物流仓储: 精细化运营，命中率&#xA;        推荐&#xA;        保险: 风险预测&#xA;        金融: 用户特征&#xA;        房产: 精准投策、营销&#xA;        AI&#xA;    组织部门&#xA;        平台: 集群&#xA;            Hadoop、Flume、Kafka、HBase、Spark等搭建&#xA;            性能监控、调优&#xA;        数据仓库: 写SQL&#xA;            ETL, 数据清洗&#xA;            Hive, 数据分析、建模&#xA;        数据挖掘&#xA;            数据支持&#xA;            算法、推荐、用户画像&#xA;        报表&#xA;            JavaEE&#xA;hadoop&#xA;    Apache开源, 分布式系统基础架构&#xA;    面临问题&#xA;        硬盘&#xA;            1块: 10TB-14TB &#xA;            1PB: 102块硬盘&#xA;        算&#xA;            MySQL5.5: 300w-500w&#xA;            MySQL8: 1亿、1GB&#xA;    Doug Cutting&#xA;        GFS -&amp;gt; HDFS&#xA;            存储&#xA;        Map-Reduce -&amp;gt; MapReduce&#xA;            计算&#xA;        BigTable -&amp;gt; HBase&#xA;            表式存储&#xA;    发展&#xA;        2003-2004: Google公开部分GFS和MapReduce&#xA;        2005: Hadoop成为Apache Lucene子项目Nutch了一部分&#xA;        2006.3: MapReduce和NDFS(Nutch Distributed File System)纳入Hadoop&#xA;    发行版本&#xA;        Apache: 开源&#xA;        Cloudera: Doug Cutting, 一键部署, 资源占用大&#xA;        Hortonworks: 雅虎工程师，贡献Hadoop 80%代码, 一键部署&#xA;        阿里云&#xA;    特点&#xA;        高可靠性：多副本&#xA;        高扩展性&#xA;        高效性: 并行运行&#xA;        高容错性&#xA;    组成&#xA;        Hadoop1.x&#xA;            HDFS(存), MapReduce(算、资源调度), Common&#xA;        Hadoop2.x&#xA;            HDFS(存), MapReduce(算), Yarn(资源调度), Common&#xA;        Hadoop3.x&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hdfs&#34;&gt;&#xA;  HDFS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hdfs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Hadoop Distributed File System, 一开始为Nutch搜索引擎开发&#xA;存储模型&#xA;&#x9;按字节切割,block存储,block多副本&#xA;&#x9;不支持修改(因为修改文件而非block, 且会引发规模修改)，可以追加&#xA;主从架构&#xA;&#x9;NameNode&#xA;&#x9;&#x9;树形目录&#xA;&#x9;&#x9;内存存储元数据，可持久化(EditLog事务日志, FsImage)&#xA;&#x9;&#x9;&#x9;NameNode启动时安全模式&#xA;&#x9;&#x9;&#x9;&#x9;SecondaryNameNode合并EditLog到新FsImage&#xA;&#x9;&#x9;&#x9;&#x9;DataNode上报block列表&#xA;&#x9;&#x9;存副本策略&#xA;&#x9;DataNode&#xA;&#x9;&#x9;本地文件形式存block, 存校验&#xA;&#x9;&#x9;与NameNode心跳，汇报block列表&#xA;&#x9;Client&#xA;&#x9;&#x9;交互元数据和block&#xA;API结构&#xA;&#x9;推荐节点数不过5000&#xA;&#x9;角色：一个进程&#xA;Block副本放置策略&#xA;&#x9;Pipeline&#xA;HA&#xA;&#x9;JournalNode&#xA;&#x9;&#x9;NameNode同步EditLog&#xA;&#x9;FailoverController&#xA;&#x9;&#x9;利用ZooKeeper&#xA;&#x9;&#x9;同主机下监控NameNode&#xA;&#x9;&#x9;验证对方主机主NN是否真的挂掉，调用对方降级为Standby&#xA;问题及方案&#xA;    单点故障&#xA;        多NameNode，主备(2.x只能1主1备, 3.x可以1主5备)&#xA;    压力大，内存受限&#xA;        联帮: Federation(元数据分片)&#xA;配置网络&#xA;    /etc/sysconfig/network-scripts/ifcfg-eth0&#xA;    /etc/sysconfig/network&#xA;        NETWORKING=YES&#xA;        HOSTNAME=node01    &#xA;    /etc/hosts&#xA;    /etc/selinux/config&#xA;        SELINUX=disabled&#xA;    /etc/ntp.conf&#xA;        server htp1.aliyun.com&#xA;    /etc/profile&#xA;        export JAVA_HOME=/usr/java/default&#xA;        export PATH=$PATH:$JAVA_HOME/bin&#xA;    service iptables stop &amp;amp; chkconfig iptables off&#xA;    service ntp start &amp;amp; chkconfig ntp on&#xA;    配ssh免密登录&#xA;部署配置&#xA;    mkdir /opt/bigdata&#xA;    /etc/profile&#xA;        export HADOOP_HOME=/opt/bigdata/hadoop-2.6.5&#xA;        export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin&#xA;    /etc/hadoop&#xA;        hadoop-env.sh&#xA;            export JAVA_HOME=/usr/java/default&#xA;        core-site.xml&#xA;            &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;hdfs://node01:9000&amp;lt;/value&amp;gt;&#xA;        hdfs-site.xml&#xA;            &amp;lt;name&amp;gt;fs.replication&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;1&amp;lt;/value&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;/var/bigdata/hadoop/local/dfs/name&amp;lt;/value&amp;gt;&#xA;                # namenode元数据&#xA;            &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;/var/bigdata/hadoop/local/dfs/data&amp;lt;/value&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.namenode.secondary.http-address&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;node01:50090&amp;lt;/value&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.namenode.checkpoint.dir&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;/var/bigdata/hadoop/local/dfs/secondary&amp;lt;/value&amp;gt;&#xA;        slaves&#xA;            node1&#xA;命令&#xA;    hdfs namenode -format&#xA;    start-dfs.sh&#xA;    访问页面 node01:50070 node01:50090&#xA;    hdfs dfs -mkdir -p /user/root&#xA;    hdfs dfs -D dfs.blocksize=1048576 -put a.txt /user/root&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;软件结构&#xA;    0        jdk, Hadoop                        NameNode, DFSZKFailoverController&#xA;    1        jdk, Hadoop                        NameNode, DFSZKFailoverController&#xA;    2        jdk, Hadoop                        ResourceManager&#xA;    3        jdk, Hadoop, Zookeeper        DataNode, NodeManager, JournalNode, QuorumPeerMain&#xA;    4        jdk, Hadoop, Zookeeper        DataNode, NodeManager, JournalNode, QuorumPeerMain&#xA;    5        jdk, Hadoop, Zookeeper        DataNode, NodeManager, JournalNode, QuorumPeerMain&#xA;Zookeeper&#xA;    配置conf/zoo.cfg&#xA;        tickTime=2000                        # 心跳间隔(ms)&#xA;        initLimit=10                        # 初始化时最多容忍心跳次数&#xA;        syncLimit=5                        # 同步失败最多容忍心跳次数&#xA;        dataDir=/usr/local/Zookeeper/data        # 运行时文件目录&#xA;        clientPort=2181                # 运行端口号&#xA;        server.1=主机名或ip:2888:3888        # 服务运行端口与选举端口&#xA;        server.2=主机名或ip:2888:3888&#xA;        server.3=主机名或ip:2888:3888&#xA;    命令&#xA;        ./bin/zkServer.sh start&#xA;        ./bin/zkServer.sh status&#xA;        jps                                        # 显示名为QuorumPeerMain&#xA;Hadoop&#xA;    Hadoop-env.sh&#xA;        export JAVA_HOME=&#xA;    core-site.xml&#xA;        &amp;lt;configuration&amp;gt;&#xA;            &amp;lt;property&amp;gt;&#xA;                &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;&#xA;                &amp;lt;value&amp;gt;HDFS://ns1&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;            &amp;lt;property&amp;gt;&#xA;                &amp;lt;name&amp;gt;Hadoop.tmp.dir&amp;lt;/name&amp;gt;&#xA;                &amp;lt;value&amp;gt;/usr/local/Hadoop-2.2.0/tmp&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;            &amp;lt;property&amp;gt;&#xA;                &amp;lt;name&amp;gt;ha.Zookeeper.quorum&amp;lt;/name&amp;gt;&#xA;                &amp;lt;value&amp;gt;192.168.56.13:2181, 192.168.56.14:2181, 192.168.56.15:2181&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;        &amp;lt;/configuration&amp;gt;&#xA;    HDFS-site.xml&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;ns1&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.ha.namenodes.ns1&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;nn1,nn2&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.namenode.rpc-address.ns1.nn1&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;192.168.56.10:9000&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.namenode.http-address.ns1.nn1&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;192.168.56.10:50070&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.namenode.rpc-address.ns1.nn2&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;192.168.56.11:9000&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.namenode.http-address.ns1.nn2&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;192.168.56.11:50070&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.namenode.shared.edits.dir&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;qjournal://192.168.56.13:8485;192.168.56.14:8485;192.168.56.15:8485&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.journalnode.edits.dir&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;/usr/local/Hadoop-2.2.0/journal&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.ha.automatic-failover.enabled&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.client.failover.proxy.provider.ns1&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;org.Apache.Hadoop.HDFS.server.namenode.ha.ConfiguredFailoverProxyProvider&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.ha.fencing.methods&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;sshfence&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;dfs.ha.fencing.ssh.private-key-files&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;/root/.ssh/id_rsa&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    mapred-site.xml&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;Yarn&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    Yarn-site.xml&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;Yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;192.168.56.12&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property&amp;gt;&#xA;            &amp;lt;name&amp;gt;Yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;&#xA;            &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    etc/Hadoop/slaves&#xA;        192.168.56.13&#xA;        192.168.56.14&#xA;        192.168.56.15&#xA;收尾&#xA;    ssh免登录(0到1,2,3,4,5)&#xA;        ssh-keygen -t rsa&#xA;        ssh-copy-id -i 192.168.56.11            # 这样就可以免登录访问192.168.56.11了&#xA;                                                ## ssh-copy-id -i localhost 免登录自己&#xA;    复制Hadoop2.2.0(从0到1,2,3,4,5)&#xA;    添加Hadoop_home到环境变量&#xA;        etc/profile&#xA;            export HADOOP_HOME=/usr/local/Hadoop-2.2.0&#xA;            export PATH=$PATH:$HADOOP_HOME/bin&#xA;启动&#xA;    0 上启动&#xA;        ./sbin/Hadoop-daemons.sh start journalnode&#xA;    0 上格式化namenode&#xA;        Hadoop namenode -format&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hbase&#34;&gt;&#xA;  HBase&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hbase&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;&#x9;Hadoop Database, 实时分布式, bigtable列簇数据库, 非结构化，自动切分, 并发读写&#xA;&#x9;只能row key查询, master有单点问题&#xA;版本&#xA;&#x9;0.98&#xA;&#x9;1.x&#xA;&#x9;2.x&#xA;原理&#xA;&#x9;修改只追加记录，合并时删除&#xA;架构&#xA;&#x9;Client&#xA;&#x9;&#x9;提供接口，维护客户端缓存&#xA;&#x9;Zookeeper&#xA;&#x9;&#x9;只有一个活跃master&#xA;&#x9;&#x9;存Region寻址入口&#xA;&#x9;&#x9;实时监控region server在线信息，通知master&#xA;&#x9;&#x9;存schema、table元数据&#xA;&#x9;Master&#xA;&#x9;&#x9;为region server分配region&#x9;&#xA;&#x9;&#x9;region server负载均衡&#xA;&#x9;&#x9;失效region server重新分配region&#xA;&#x9;&#x9;管理table CRUD&#xA;&#x9;RegionServer&#xA;&#x9;&#x9;维护region&#xA;&#x9;&#x9;切分大region&#xA;&#x9;Region&#xA;&#x9;&#x9;表水平分region分配在多个region server, region增大时裂变&#xA;&#x9;HLog&#xA;&#x9;&#x9;写Store之前先写HLog, flush到HDFS, store写完后HDFS存储移到old，2天后删除&#x9;&#xA;&#x9;Store&#xA;&#x9;&#x9;region由多个store组成, 一个store对应一个CF&#xA;&#x9;&#x9;store先写入memstore, 到阈值后启动flashcache写入storefile&#xA;&#x9;&#x9;storefile增长到阈值，进行合并&#xA;&#x9;&#x9;&#x9;minor compaction&#xA;&#x9;&#x9;&#x9;major compaction，默认最多256M&#xA;&#x9;&#x9;region所有storefile达到阈值，region分割&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spark&#34;&gt;&#xA;  Spark&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spark&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;&#x9;in memory, 准实时的批处理，生态好于Storm&#xA;&#x9;无事务&#xA;集群&#xA;&#x9;Master&#xA;&#x9;Worker&#xA;&#x9;Driver&#xA;&#x9;Executor&#x9;&#xA;组件&#xA;&#x9;Spark RDD(Resiliennt Distributed Datasets)&#xA;&#x9;Spark Core 批计算，取代MR&#xA;&#x9;&#x9;粗粒度资源申请，task自行分配启动快，executor不kill&#xA;&#x9;&#x9;内存计算&#xA;&#x9;&#x9;chain&#xA;&#x9;Spark Streamming 流计算，取代Storm&#xA;&#x9;&#x9;批计算无限缩小，实时性差&#xA;&#x9;&#x9;默认无状态&#xA;&#x9;&#x9;&#x9;用updateStateByKey保存上次计算结果，变成有状态&#xA;&#x9;&#x9;&#x9;借助Redis或ES存&#xA;&#x9;Spark SQL 数据处理&#xA;&#x9;Spark MlLib 机器学习&#xA;&#x9;Spark R 数据分析&#xA;使用&#xA;&#x9;val session = SparkSessionBase.createSparkSession()&#xA;&#x9;var sc = session.sparkContext&#xA;&#x9;var rdd = sc.makeRDD(List(1,2,3,4,5,6))&#xA;&#x9;val mapRDD = rdd.map(x -&amp;gt; {&#xA;&#x9;&#x9;x&#xA;&#x9;})&#xA;&#x9;val filterRDD = mapRDD.filter(x =&amp;gt; {&#xA;&#x9;&#x9;true&#xA;&#x9;})&#xA;&#x9;filterRDD.count&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;独立体系&#34;&gt;&#xA;  独立体系&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8b%ac%e7%ab%8b%e4%bd%93%e7%b3%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;flink&#34;&gt;&#xA;  Flink&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#flink&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;&#x9;高吞吐、低延迟、高性能&#xA;&#x9;支持事件时间(Event Time)&#xA;&#x9;擅长有状态的计算&#x9;&#xA;&#x9;&#x9;内存&#xA;&#x9;&#x9;磁盘&#xA;&#x9;&#x9;RocksDB&#xA;&#x9;灵活的窗口（Window）操作： time, count, session&#xA;&#x9;基于轻量级分布式快照（CheckPoint）实现容错，保证exactly-once&#xA;&#x9;基于JVM实现独立内存管理&#xA;&#x9;Save Points方便代码升级&#xA;批计算是流计算的特例&#xA;&#x9;unbound streams&#x9;&#x9;# 定义开始不定义结束，流计算&#xA;&#x9;bounded streams&#x9;&#x9;# 定义开始也定义结束，批计算&#xA;迟到数据问题&#xA;&#x9;温度窗口&#xA;&#x9;水位线(Watermark)&#xA;集群&#xA;&#x9;JobManager(JVM进程)&#xA;&#x9;TaskManager(JVM进程)&#xA;&#x9;&#x9;Task Slot&#x9;&#xA;&#x9;&#x9;&#x9;一组固定的资源，隔离内存，不隔离核&#xA;&#x9;&#x9;&#x9;一般与核数对应，核支持超线程时一个算两个&#xA;配置&#xA;&#x9;/etc&#xA;&#x9;&#x9;/flink-conf.yaml&#xA;&#x9;&#x9;/slaves&#xA;&#x9;&#x9;/masters&#xA;组件&#xA;&#x9;部署&#xA;&#x9;&#x9;Single JVM&#x9;&#x9;# 多线程模拟&#xA;&#x9;&#x9;Standalone&#xA;&#x9;&#x9;YARN&#x9;&#xA;&#x9;库&#xA;&#x9;&#x9;CEP&#x9;&#x9;&#x9;&#x9;# 复杂事件库&#xA;&#x9;&#x9;Table&#xA;&#x9;&#x9;FlinkML&#xA;&#x9;&#x9;Gelly&#xA;使用&#xA;&#x9;import org.apache.flink.streaming.api.scala._&#xA;&#xA;&#x9;val env = StreamExecutionEnvironment.getExecutionEnvironment&#xA;&#x9;val initStream:DataStream[String] = env.socketTextStream(&amp;quot;node01&amp;quot;, 8888)&#xA;&#x9;val wordStream = initStream.flatMap(_.split(&amp;quot; &amp;quot;))&#xA;&#x9;val pairStream = wordStream.map((_, 1))&#xA;&#x9;val keyByStream = pairStream.keyBy(0)&#xA;&#x9;val restStream = keyByStream.sum(1)&#xA;&#x9;restStream.print()&#xA;&#x9;env.execute(&amp;quot;job1&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/architect/strategy/iot/framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/architect/strategy/iot/framework/</guid>
      <description>&lt;h1 id=&#34;thingsboard&#34;&gt;&#xA;  ThingsBoard&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#thingsboard&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# java, 社区版、企业版&#xA;文档&#xA;    github.com/thingsboard/thingsboard&#xA;    thingsboard.io/docs&#xA;    localhost:8080/swagger-ui.html      # 本地swagger&#xA;安装&#xA;    docker&#xA;        docker run -it -p 9090:9090 -p 1883:1883 -p 5683:5683/udp -v ~/.mytb-data:/data -v ~/.mytb-logs:/var/log/thingsboard --name mytb thingsboard/tb-postgres&#xA;    maven&#xA;        确定ui/pom.xml中&amp;lt;nodeVersion&amp;gt;&#xA;        mvn install -DskipTests&#xA;    配置&#xA;        application&#xA;            zk&#xA;                ZOOKEEPER_ENABLED&#xA;                ZOOKEEPER_URL&#xA;            cassandra&#xA;                CASSANDRA_URL&#xA;                CASSANDRA_USERNAME&#xA;                CASSANDRA_PASSWORD&#xA;            redis&#xA;                REDIS_HOST&#xA;                REDIS_PORT&#xA;                REDIS_DB&#xA;                REDIS_PASSWORD&#xA;            postgresql&#xA;                SPRING_DATASOURCE_URL&#xA;                SPRING_DATASOURCE_USERNAME&#xA;                SPRING_DATASOURCE_PASSWORD&#xA;            kafka&#xA;                TB_KAFKA_SERVERS&#xA;    运行&#xA;        application&#xA;            server&#xA;        transport&#xA;            http&#xA;    demo数据&#xA;        admin&#xA;            sysadmin@thingsboard.org    sysadmin&#xA;        tenant&#xA;            tenant@thingsboard.org  tenant&#xA;        customer&#xA;            customer@thingsboard.org或customerA@thingsboard.org  customer&#xA;            customerB@thingsboard.org   customer&#xA;            customerC@thingsboard.org   customer&#xA;        device&#xA;            A1, A2, A3  A1_TEST_TOKEN,...   customerA&#xA;            B1  B1_TEST_TOKEN   customerB&#xA;            C1  C1_TEST_TOKEN   customerC&#xA;            &#39;DHT11 Demo Device&#39;     DHT11_DEMO_TOKEN&#xA;            &#39;Raspberry Pi Demo Device&#39;  RASPBERRY_PI_DEMO_TOKEN&#xA;包结构&#xA;    application                         # 可改, 网关&#xA;        server&#xA;            install&#xA;            config                      # 同源策略、swagger、websocket、消息、安全&#xA;            exception&#xA;            controller                  # 页面调用&#xA;            service&#xA;            actors&#xA;                service&#xA;                    DefaultActorService&#xA;                        actorContext&#xA;                            actorService(this)&#xA;                            actorSystem&#xA;                            appActor&#xA;                            statsActor&#xA;                        rpcManagerActor&#xA;    common                              # 不可改, 功能代理&#xA;        data                            # 数据结构&#xA;        message                         # 消息类型&#xA;        transport                       # 客户端调用&#xA;    dao                                 # 可改, 业务, 适配db&#xA;        model                           # 数据库对象&#xA;        resources&#xA;            sql                         # 表结构&#xA;    netty-mqtt                          # 不可改, 数据通信协议&#xA;    rule-engine                         # 不可改, 规则引擎&#xA;    transport                           # 不可改, 设备端运行&#xA;        http                            # 启动http传输协议&#xA;        coap&#xA;        mqtt&#xA;    tools                               # 可改, 工具&#xA;    ui                                  # 可改, 页面, angular, react, webpack&#xA;    docker                              # 不可改, 打包&#xA;    msa                                 # 不可改，分布式&#xA;        black-box-tests                 # 黑盒测试&#xA;        js-executor                     # 执行js&#xA;    log&#xA;    img         &#xA;模块&#xA;    application&#xA;        common&#xA;            data                        # 数据结构&#xA;            message                     # 消息结构&#xA;            transport                   # 接口结构，适配客户端&#xA;    dao                                 # 交互data, 兼容不同db&#xA;    tools&#xA;        extensions&#xA;            kafka&#xA;            mqtt&#xA;            rabbitmq&#xA;            rest-api-call&#xA;        extensions-api&#xA;            action&#xA;            filter&#xA;            plugin&#xA;            processor&#xA;        extensions-core                 # 实现公用extensions-api&#xA;    transport&#xA;        http                            # rest&#xA;        coap                            # californium&#xA;        mqtt                            # netty&#xA;    规则引擎                             # 基于actors执行&#xA;        filters&#xA;        processors&#xA;        action&#xA;    ui                                  # node.js + yarn&#xA;表结构&#xA;    tenant&#xA;    customer                            # 关联tenant&#xA;    tb_user                             # user信息、角色&#xA;    user_credentials                    # user密码&#xA;    admin_settings                      # admin信息, key value形式&#xA;    audit_log                           # 登录日志&#xA;&#xA;    asset&#xA;    entity_view     &#xA;    attribute_kv                        # entity attribute&#xA;    component_descriptor                # node类&#xA;&#xA;    device                              # 设备, label&#xA;    device_credentials                  # 设备ACCESS_TOKEN&#xA;    ts_kv                               # 设备事件&#xA;    ts_kv_latest                        # 设备当前状态&#xA;&#xA;    rule_chain                          # rule root chain&#xA;    rule_node                           # rule节点&#xA;    relation                            # rule关系&#xA;    event                               # rule事件&#xA;    alarm                               # alarm事件&#xA;&#xA;    dashboard                           # dashboard设置&#xA;    widget_type                         # widget, 别名&#xA;    widgets_bundle&#xA;api&#xA;    host:port/api/v1/$ACCESS_TOKEN/&#xA;        telementry                      # 上传遥测数据&#xA;            post {&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;}&#xA;            post [{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;}]&#xA;            post {&amp;quot;ts&amp;quot;:1451649600512, &amp;quot;values&amp;quot;:{&amp;quot;key1&amp;quot;:&amp;quot;value1&amp;quot;}}&#xA;        attributes&#xA;            post {&amp;quot;attribute1&amp;quot;:&amp;quot;value1&amp;quot;}          # 更新属性&#xA;            get                         # 请求属性&#xA;        attributes/updates&#xA;            get ?timeout=20000          # 订阅属性&#xA;        rpc&#xA;            get ?timeout=20000          # 要求订阅，返回id, method, params&#xA;            post {&amp;quot;method&amp;quot;: &amp;quot;getTime&amp;quot;, &amp;quot;params&amp;quot;:{}}     # 执行method&#xA;        rpc/{$id}&#xA;            post&#xA;        claim                           # 用户认领设备&#xA;            post&#xA;服务架构&#xA;产品架构&#xA;    设备接入: MQTT、CoAP、HTTP&#xA;    规则引擎                             # 处理设备消息&#xA;        消息(message)&#xA;            设备传入数据&#xA;            设备生命周期事件&#xA;            rest api事件&#xA;            rpc请求&#xA;        规则节点(node)                   # 过滤消息&#xA;            filter&#xA;            enrichment&#xA;            transformation&#xA;            action&#xA;            external&#xA;            rule chain&#xA;        规则链                           # 连接节点&#xA;    核心服务&#xA;        设备认证: token、X.509&#xA;        规则和插件&#xA;        多租户(tenant)&#xA;            客户&#xA;                资产&#xA;                设备&#xA;        部件(widget)仪表盘(dashboard)&#xA;            alarm&#xA;            实体视图&#xA;                设备即服务(DaaS)&#xA;                共享资产、设备&#xA;                传感器等权限&#xA;        告警和事件&#xA;    网关: rest api, websocket&#xA;    actor模型: 用于并发&#xA;    集群: zookeeper服务发现, 一致性哈希&#xA;    安全: SSL&#xA;    第三方&#xA;        akka&#xA;        zookeeper&#xA;        grpc&#xA;        cassandra&#xA;&#xA;    system&#xA;        general&#xA;        mail&#xA;        security&#xA;功能模块&#xA;    admin&#xA;    tenant&#xA;        rule chain&#xA;            filter&#xA;            enrichment&#xA;            transformation&#xA;            action&#xA;            *analytics&#xA;            external&#xA;            rule chain&#xA;        *data converters&#xA;        *integrations&#xA;        *roles&#xA;        *customers hierarchy&#xA;        *user groups&#xA;        customers&#xA;        *customer groups&#xA;        assets&#xA;        *asset groups&#xA;        devices&#xA;        *device groups&#xA;        entity views&#xA;        *entity view groups&#xA;        widgets library&#xA;        dashboards&#xA;        *dashboard groups&#xA;        *scheduler&#xA;            report&#xA;            send rpc&#xA;            update attributes&#xA;        *white labeling&#xA;            main server&#xA;            mail templates&#xA;            custom translation&#xA;            custom menu&#xA;            white labeling&#xA;            login white labeling&#xA;            self registration&#xA;        audit logs&#xA;    entities&#xA;        包含&#xA;            tenants&#xA;            customers&#xA;            users&#xA;            devices&#xA;            assets&#xA;            alarms&#xA;            dashboards&#xA;            rule node&#xA;            rule chain&#xA;        操作&#xA;            detail&#xA;            assigned to customer&#xA;            attributes&#xA;                client&#xA;                server&#xA;                shared&#xA;            telemetry&#xA;            alarms&#xA;            events&#xA;            relations&#xA;            audit logs&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/basic/computer/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/basic/computer/performance/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;性能指标&#xA;    latency&#xA;    throughput&#xA;    qps = throughput / latency&#xA;性能分析&#xA;    bottle-nect(first-principle)&#xA;资源&#xA;    CPU和GPU&#xA;    内存&#xA;    磁盘&#xA;    网络&#xA;    能源&#xA;逻辑资源&#xA;    fds(文件描述符)&#xA;    sockets&#xA;    内核对象: locks&#xA;    inodes(磁盘索引节点)&#xA;    transactions&#xA;    ip addresses&#xA;    ports&#xA;    random numbers(分布式随机数)&#xA;容量&#xA;    2000前   尽量少&#xA;    200~    不到机型限制&#xA;    2017    尽量把机器用满&#xA;    以后     metrics分离, 单独规划&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;计算&#34;&gt;&#xA;  计算&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;cpu&#xA;gpu&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储&#34;&gt;&#xA;  存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;类型&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;时间&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L1 cache&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;0.5ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;branch mispredict(分支、转移)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;5ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L2 cache&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;7ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;14x L1 cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Mutex lock/unlock&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;25ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Main memory&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;100ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;20x L2 cache, 200x L1 cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1k字节压缩Zippy&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;3,000ns = 3us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在1Gbps网络上发送1k字节&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;10,000ns = 10us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;SSD随机读4k&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;150,000ns = 150us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1GB/秒&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;内存顺序读1MB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;250,000ns = 250us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;同一数据中心往返&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;500,000ns = 500us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;SSD顺序读1MB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1,000,000ns = 1000us = 1ms&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1GB/秒, 4x 内存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;磁盘搜索&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;10,000,000ns = 10,000us = 10ms&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;20x 数据中心往返&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;磁盘顺序读1MB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;20,000,000ns = 20,000us = 20ms&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;80x 内存, 20x SSD&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;发包: 美国 -&amp;gt; 荷兰 -&amp;gt; 加拿大&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;150,000,000ns = 150,000us = 150ms&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;传输&#34;&gt;&#xA;  传输&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%a0%e8%be%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;带宽&#xA;    热门并发1.5倍到2倍购买&#xA;方式&#xA;    HDD&#xA;    SSD&#xA;    ethernet&#xA;    南桥、北桥芯片&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发&#34;&gt;&#xA;  并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;并发&#xA;    jetty 2k-3k&#xA;    nginx 1w&#xA;    lvs 100w&#xA;    f5 + lvs 400w-800w&#xA;    mysql 1k&#xA;    oracle 1.5k-2k&#xA;    tomcat 1k&#xA;&#xA;1并发/10在线用户/100注册用户&#xA;&#xA;1用户/20pv&#xA;&#xA;访问时段&#xA;    8点 - 23点&#xA;    最大访问量为平均值1.7倍&#xA;&#xA;每个html页面20k, 40k/css, 50k/js. css与js会缓存&#xA;&#xA;数据库&#xA;    mongodb&#xA;        查询&#xA;            4w++/5s                # aurora测&#xA;&#xA;一个进程13M左右&#xA;    10g内存787多并发(最早的apache)&#xA;一个线程2M内存&#xA;    10g内存5120并发&#xA;&#xA;cpu一级缓存取数据: 3个时钟周期(tick)&#xA;cpu二级缓存取数据: 14 tick&#xA;内存取数据: 250 tick&#xA;磁盘取数据: 4100w tick&#xA;网络取数据: 24000w tick&#xA;&#xA;负载均衡器&#xA;    # 并发在100w - 800w&#xA;    深信服&#xA;    F5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;性能调优&#34;&gt;&#xA;  性能调优&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;影响因素&#xA;    内因&#xA;        项目设计、实现&#xA;        资源加载&#xA;        配置&#xA;    外因&#xA;        网络&#xA;        流量&#xA;        架构&#xA;        服务器配置&#xA;步骤&#xA;    分析用户习性          # 功能路径，热点&#xA;    内存瓶颈&#xA;        内部&#xA;            托管资源&#xA;                对象分配回收  # session、缓存、对象池等&#xA;            非托管资源&#xA;                数据库、文件、线程&#xA;        外部&#xA;            进程竞争&#xA;    cpu瓶颈&#xA;        cpu密集业务&#xA;            加密、解密，垃圾回收，解压缩，算术运算，过度编译&#xA;    缓存分析&#xA;        浏览器缓存       # 资源文件，过期&#xA;        代理缓存        # 地域、安全、更新&#xA;        内核缓存、IIS缓存&#xA;        数据缓存&#xA;    资源等待分析&#xA;        数据库等待&#xA;        线程锁定&#xA;        磁盘读写&#xA;    数据库瓶颈(找数据库笔记)&#xA;    http优化&#xA;        减小页面&#xA;        只传必要数据&#xA;        资源加载&#xA;架构&#xA;    去单点&#xA;    服务化&#xA;    优质业务专门机器&#xA;    广播改订阅&#xA;    换语言/框架重构&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 小米论坛&#xA;    pv 2000w&#xA;    热门并发300&#xA;    20k/页面&#xA;    300k/图片(未压缩)&#xA;    70k/无图帖子&#xA;    500k-3M/有图帖子&#xA;&#xA;    动态服务器最小带宽: 48Mbps&#xA;    静态服务器最小带宽: 1440Mbps&#xA;    实际购买带宽: 800M&#xA;    带宽费用: 8.7w/month&#xA;&#xA;o-&amp;gt; 糗事百科&#xA;    pv 1000w&#xA;    热门并发150&#xA;    10k/页面&#xA;    70k/图&#xA;    4图/页&#xA;    90k-400k/综合页&#xA;    动态服务器带宽: 12Mbps&#xA;    静态服务器带宽: 336Mbps&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具数据&#34;&gt;&#xA;  工具数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;nodejs&#xA;    虚拟机数据&#xA;        mem: 512m&#xA;        mem: 66.7%&#xA;        cpu: 1%&#xA;    执行&#xA;        5秒循环mongo数据: 17w条&#xA;    状况&#xA;        程序完全阻塞&#xA;&#xA;    并发: 300&#xA;    qps: 140&#xA;    8核全满&#xA;&#xA;    2-4G 内存 3000万并发&#xA;    5w socket                        # 系统最高65535个端口，支持这么多连接&#xA;    已实现成就&#xA;        ruby迁移到node.js有10倍的性能提升，特定情况下20倍性能提升&#xA;        5w并发/min&#xA;&#xA;&#xA;redis&#xA;    200并发, 每次3ms, 37000次/s&#xA;&#xA;mysql&#xA;    最多3.5w写入/s&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/cache/ops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/cache/ops/</guid>
      <description>&lt;h1 id=&#34;java&#34;&gt;&#xA;  java&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;-Dserver.port=18001&#xA;-Deureka.client.serviceUrl.defaultZone=http://localhost:19090/eureka&#xA;-javaagent:/opt/svc/apache-skywalking-apm-bin/agent/skywalking-agent.jar&#xA;-Dspring.profiles.active=prod&#xA;-Dlogging.config=classpath:logback-spring-prod.xml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;mac-os-改mac&#34;&gt;&#xA;  mac os 改mac&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mac-os-%e6%94%b9mac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -z&#xA;sudo ifconfig &amp;lt;intf&amp;gt; lladdr 00:bb:cc:dd:ee:ff &#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/cache/work_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/cache/work_code/</guid>
      <description>&lt;h1 id=&#34;框架编写&#34;&gt;&#xA;  框架编写&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%86%e6%9e%b6%e7%bc%96%e5%86%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;git update-index &amp;ndash;assume-unchanged a&#xA;mvn clean deploy -P keruyun -pl alsc-item-solution-kryun-dish-client -DskipTests&lt;/p&gt;&#xA;&lt;h1 id=&#34;阿里云搜索词&#34;&gt;&#xA;  阿里云搜索词&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%bf%e9%87%8c%e4%ba%91%e6%90%9c%e7%b4%a2%e8%af%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;大屏&#34;&gt;&#xA;  大屏&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%a7%e5%b1%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;and &lt;strong&gt;tag&lt;/strong&gt;:&lt;strong&gt;path&lt;/strong&gt;: &amp;ldquo;/data/app/jncloud/screen/log/info.log&amp;rdquo;  and resourceMap and {7435ca87-1c8c-4c76-bcfd-6f45b9c8b167}&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;时长请求&#34;&gt;&#xA;  时长请求&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%b6%e9%95%bf%e8%af%b7%e6%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;tag&lt;/strong&gt;:&lt;strong&gt;path&lt;/strong&gt;:/var/log/nginx/access.log and upstream_response_time &amp;gt; 1 | select distinct request_uri , count(request_uri) as &amp;ldquo;count&amp;rdquo;, max(upstream_response_time) as max_time, min(upstream_response_time) as min_time, avg(upstream_response_time) as avg_time from log group by request_uri order by count desc&lt;/p&gt;&#xA;&lt;h2 id=&#34;ip分布&#34;&gt;&#xA;  IP分布&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ip%e5%88%86%e5%b8%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;tag&lt;/strong&gt;:&lt;strong&gt;path&lt;/strong&gt;:/var/log/nginx/access.log | select count(1) as c, ip_to_province(remote_addr) as address group by address order by c desc limit 100&#xA;&lt;strong&gt;tag&lt;/strong&gt;:&lt;strong&gt;path&lt;/strong&gt;:/var/log/nginx/access.log | select count(1) as c, remote_addr, ip_to_province(remote_addr) as address group by remote_addr order by c desc limit 100&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/db/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/db/elasticsearch/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分布式实时lucene&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;./bin/elasticsearch&#xA;curl http://localhost:9200&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;概念存储&#34;&gt;&#xA;  概念存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e5%bf%b5%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;index&#xA;    type&#xA;        # document中加_type field实现&#xA;        # 所以不同type中的field在index要唯一，否则冲突&#xA;        # 对field排序会载入所有type的document&#xA;        document&#xA;            # 对应lucene中的key value倒排文档&#xA;            # 对就一个请求的json对象&#xA;            field&#xA;                mapping&#xA;                    # 定义type的field，映射json到document field&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;设置&#34;&gt;&#xA;  设置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;config/elasticsearch.yml&#xA;    action.auto_create_index: -l*, +z*&#xA;        # 自动创建，以z开头和非l开头的索引&#xA;    action.destructive_requires_name: true&#xA;        # 允许通配删index&#xA;    http.cors.enables: true&#xA;    http.cors.allow-origin: &amp;quot;*&amp;quot;&#xA;    cluster.name: c1&#xA;    node.name: n1&#xA;    node.master: true&#xA;    node.data: true&#xA;    transport.host: localhost&#xA;    transport.tcp.port: 9300&#xA;    network.host: 0.0.0.0&#xA;        # 修改es监听地址，别的机器也可以访问。同时设置bind_host和publish_host&#xA;        # 需要设置transport.host:localhost&#xA;    network.bind_host&#xA;        # 节点绑定ip&#xA;    network.publish_host&#xA;        # 发布地址，其它节点通过这个地址通信&#xA;    http.port: 9200&#xA;    transport.tcp.port&#xA;        # 通信端口，默认9300&#xA;    discovery.zen.minimum_master_nodes: 2&#xA;&#xA;o-&amp;gt; 可用配置&#xA;cluster.name: myES_Cluster&#xA;node.name: ESNODE_CYR&#xA;node.master: true&#xA;node.data: true&#xA;transport.host: localhost&#xA;transport.tcp.port: 9300&#xA;http.port: 9200&#xA;network.host: 0.0.0.0&#xA;discovery.zen.minimum_master_nodes: 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;接口&#34;&gt;&#xA;  接口&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;index&#34;&gt;&#xA;  index&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#index&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;get/put/delete /index1              # 创建index, get查询，delete删除&#xA;    settings&#xA;    mappings&#xA;    aliases:&#xA;put /index1/_mapping/type2&#xA;get/put /index1/type2/_mapping      # 创建type或给已有type加mappings&#xA;    properties&#xA;put /index1/_settings&#xA;get/put /index1/type1/1             # 插入doc&#xA;    name: &amp;quot;name1&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_cat&#34;&gt;&#xA;  _cat&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_cat&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;get /_cat/health?v                  # 集群健康&#xA;get /_cat/nodes?v                   # 集群节点&#xA;get /_cat/indices?v                 # 所有索引&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_cluster&#34;&gt;&#xA;  _cluster&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_cluster&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;get /_cluster/state?pretty          # 集群状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_aliases&#34;&gt;&#xA;  _aliases&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_aliases&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /_aliases                      # 索引别名&#xA;    actions:&#xA;        add:&#xA;            alias: &amp;quot;my_index&amp;quot;&#xA;            index: &amp;quot;my_index_v1&amp;quot;&#xA;        remove&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_template&#34;&gt;&#xA;  _template&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_template&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;put /_template/tpl1&#xA;    template: &amp;quot;te*&amp;quot;&#xA;        # 匹配所有re开头的index&#xA;    settings:&#xA;    mappings:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_search&#34;&gt;&#xA;  _search&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_search&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/type1/_search&#xA;    # from size实时分页&#xA;    # scroll快照分页&#xA;    ?from=0&amp;amp;size=50&#xA;    ?scroll=1m&amp;amp;size=50&#xA;        # 过期时间1分钟，每次返回50条&#xA;    ?search_type=scan&amp;amp;scroll=1m&#xA;        # scroll-scan分页不排序，更快,&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_analyze&#34;&gt;&#xA;  _analyze&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_analyze&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/_analyze&#xA;    text: &amp;quot;刘德华&amp;quot;&#xA;    analyzer: &amp;quot;analyzer1&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_close&#34;&gt;&#xA;  _close&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_close&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/_close&#xA;    # 关闭索引，此后可以改settings&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_open&#34;&gt;&#xA;  _open&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_open&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/_open&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_cache&#34;&gt;&#xA;  _cache&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_cache&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/type1/_cache/clear?filter_keys=k1&#xA;    # 清空query filter的缓存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据对象&#34;&gt;&#xA;  数据对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;_search-1&#34;&gt;&#xA;  _search&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_search-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;query&#xA;    match&#xA;        # 理解如何分词的, 会对field分词再查询&#xA;        field1:&#xA;            query: &amp;quot;a b&amp;quot;&#xA;            operator: &amp;quot;and&amp;quot;&#xA;            minimum_should_match: &amp;quot;75%&amp;quot;&#xA;                # 匹配的query分词的最低占比&#xA;    match_all&#xA;        # 默认，会查出所有文档&#xA;    multi_match&#xA;        query: &amp;quot;a b&amp;quot;&#xA;        fields: [&amp;quot;field1&amp;quot;, &amp;quot;field2&amp;quot;]&#xA;    match_phrase&#xA;        # 所有term命中，并且位置邻接&#xA;        field1: &amp;quot;a b&amp;quot;&#xA;    term&#xA;        # 确切查询&#xA;        field1: &amp;quot;value1&amp;quot;&#xA;    terms&#xA;        # 多条件and&#xA;        field1: [1,2,3]&#xA;    range&#xA;        field1:&#xA;            gt: 20&#xA;            gte:&#xA;            lt:&#xA;            lte:&#xA;    exists:&#xA;        field: &amp;quot;field1&amp;quot;&#xA;    missing:&#xA;        field: &amp;quot;field1&amp;quot;&#xA;    regexp&#xA;        postcode: &amp;quot;W[0-9].+&amp;quot;&#xA;    wildcard&#xA;        postcode: &amp;quot;W?F*HW&amp;quot;&#xA;    prefix&#xA;        # 以某些字符开头&#xA;        field1: &amp;quot;a&amp;quot;&#xA;    bool&#xA;        # 分值计算来自must和should语句, must_not不影响&#xA;        must&#xA;            match&#xA;        must_not&#xA;        should: []&#xA;        minimum_should_match: 2&#xA;    filtered&#xA;        query&#xA;        filter:&#xA;            # filter的field会缓存起来&#xA;            ## geo, and, or, not, script, numeric_range的默认不缓存&#xA;            term:&#xA;                field1: &amp;quot;a&amp;quot;&#xA;                _cache_key: &amp;quot;k1&amp;quot;&#xA;                _cache: false&#xA;            range:&#xA;                field1:&#xA;                    gte: 0&#xA;aggs&#xA;    diy1:&#xA;        avg:&#xA;            field: &amp;quot;field1&amp;quot;&#xA;    diy2:&#xA;        terms:&#xA;            # 聚合查询中的所有term&#xA;            field: &amp;quot;field1&amp;quot;&#xA;post_filter:&#xA;    # 对搜索结果进行过滤&#xA;    term:&#xA;        field1: &amp;quot;a&amp;quot;&#xA;sort: []&#xA;    # 默认升序，_score默认降序&#xA;    field1&#xA;        order: &amp;quot;desc&amp;quot;&#xA;            # asc&#xA;        mode: &amp;quot;min&amp;quot;&#xA;            # 对数组元素排序时的取值, 还有max, sum, avg, median&#xA;        missing: &amp;quot;field1&amp;quot;&#xA;    &amp;quot;_score&amp;quot;,&#xA;highlight&#xA;    pre_tags: [&amp;quot;&amp;lt;tag1&amp;gt;&amp;quot;]&#xA;    post_tags: [&amp;quot;&amp;lt;/tag1&amp;gt;&amp;quot;]&#xA;    fields:&#xA;        content: {}&#xA;simple_query_string:&#xA;    query: &amp;quot;&amp;quot;&#xA;    analyzer:&#xA;    fields: [&amp;quot;body^5&amp;quot;, &amp;quot;_all&amp;quot;]&#xA;    default_operator: &amp;quot;and&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;mappings&#34;&gt;&#xA;  mappings&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mappings&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;type1:&#xA;    dynamic: true&#xA;        # 默认true,自动给未知field建索引&#xA;        # false: 忽略未知field， strict: 未知field报错&#xA;    include_in_all: false&#xA;        # 默认不include&#xA;    _all:&#xA;        # meta field&#xA;        enabled: false&#xA;                # 关闭all作用域&#xA;        analyzer:&#xA;                # 其实是search_analyzer&#xA;        term_vector: no&#xA;                # 对field建立词频向量空间&#xA;        store: &amp;quot;false&amp;quot;&#xA;    _source:&#xA;        #  是否保存内容&#xA;        enabled: true&#xA;    properties:&#xA;        field1:&#xA;            type: “text”&#xA;                # text分词，keyword不分词，numeric, date, string&#xA;                # multi_field可定义多个field&#xA;            fields:[]&#xA;                field1:&#xA;                    type&#xA;            store: &amp;quot;yes&amp;quot;&#xA;            index: &amp;quot;not_analyzed&amp;quot;&#xA;                # analyzed&#xA;            analyzer: &amp;quot;ik_max_word&amp;quot;&#xA;            search_analyzer: &amp;quot;ik_max_word&amp;quot;&#xA;                # 默认为analyzer&#xA;            include_in_all: &amp;quot;true&amp;quot;&#xA;                # 是否加入_all作用域&#xA;            boost: 8&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;aliases&#34;&gt;&#xA;  aliases&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aliases&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;alias1:&#xA;    filter:&#xA;        term: user: &amp;quot;kimchy&amp;quot;&#xA;    routing: &amp;quot;kimchy&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;settings&#34;&gt;&#xA;  settings&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#settings&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 有些设置不能动态修改&#xA;index:&#xA;    number_of_shards: 3&#xA;    number_of_replicas: 2&#xA;    max_result_window: 10000&#xA;        # from + size的上限，默认10000&#xA;    analysis:&#xA;        tokenizer:&#xA;            # 处理原始输入&#xA;            tokenizer1&#xA;                type: &amp;quot;pinyin&amp;quot;&#xA;                pinyin_field1:&#xA;        filter:&#xA;            # tokenizer作为输入&#xA;            filter1:&#xA;                type: &amp;quot;pinyin&amp;quot;&#xA;                pinyin_field1:&#xA;        analyzer:&#xA;            # 组合tokenizer和filter&#xA;            analyzer1:&#xA;                type: &amp;quot;custom&amp;quot;&#xA;                tokenizer: &amp;quot;ik_smart&amp;quot;&#xA;                filter: [&amp;quot;filter1&amp;quot;, &amp;quot;word_delimiter&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    复制到/plugins&#xA;    场景中，指定type:&amp;quot;xx&amp;quot;使用&#xA;## ik&#xA;    介绍&#xA;        elasticsearch-analysis-ik&#xA;    安装&#xA;        mvn package&#xA;        unzip -d /elasticsearch/plugins/ik ./target/releases/elasticsearch-analysis-ik-1.8.0.zip&#xA;        重启elasticsearch&#xA;    分词器&#xA;        ik_max_word&#xA;            curl -XGET &#39;http://localhost:9200/_analyze?pretty&amp;amp;analyzer=ik_max_word&#39; -d &#39;联想是全球最大的笔记本厂商&#39;&#xA;        ik_smart&#xA;            curl -XGET &#39;http://localhost:9200/_analyze?pretty&amp;amp;analyzer=ik_smart&#39; -d &#39;联想是全球最大的笔记本厂商&#39;&#xA;    mapping type&#xA;        {&#xA;        &amp;quot;properties&amp;quot;: {&#xA;            &amp;quot;content&amp;quot;: {&#xA;            &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;,&#xA;            &amp;quot;store&amp;quot;: &amp;quot;no&amp;quot;,&#xA;            &amp;quot;term_vector&amp;quot;: &amp;quot;with_positions_offsets&amp;quot;,&#xA;            &amp;quot;analyzer&amp;quot;: &amp;quot;ik_smart&amp;quot;,&#xA;            &amp;quot;search_analyzer&amp;quot;: &amp;quot;ik_smart&amp;quot;,&#xA;            &amp;quot;include_in_all&amp;quot;: &amp;quot;true&amp;quot;,&#xA;            &amp;quot;boost&amp;quot;: 8&#xA;            }&#xA;        }&#xA;        }&#xA;## pinyin&#xA;    介绍&#xA;        elasticsearch-analysis-pinyin&#xA;&#xA;&#xA;    o-&amp;gt;&#xA;    &amp;quot;analysis&amp;quot; : {&#xA;        &amp;quot;analyzer&amp;quot; : {&#xA;            &amp;quot;pinyin_analyzer&amp;quot; : {&#xA;                &amp;quot;tokenizer&amp;quot; : &amp;quot;my_pinyin&amp;quot;,&#xA;                &amp;quot;filter&amp;quot; : &amp;quot;word_delimiter&amp;quot;&#xA;            }&#xA;        },&#xA;        &amp;quot;tokenizer&amp;quot; : {&#xA;            &amp;quot;my_pinyin&amp;quot; : {&#xA;                # 单字&#xA;                &amp;quot;type&amp;quot; : &amp;quot;pinyin&amp;quot;,&#xA;                &amp;quot;first_letter&amp;quot; : &amp;quot;none&amp;quot;,&#xA;                &amp;quot;padding_char&amp;quot; : &amp;quot; &amp;quot;&#xA;            },&#xA;            &amp;quot;my_pinyin_fisrt_letter&amp;quot; : {&#xA;                # 首字母, 如北京为bj&#xA;                &amp;quot;type&amp;quot; : &amp;quot;pinyin&amp;quot;,&#xA;                &amp;quot;first_letter&amp;quot; : true,&#xA;                &amp;quot;padding_char&amp;quot; : &amp;quot; &amp;quot;&#xA;            },&#xA;        }&#xA;    }&#xA;    o-&amp;gt; pinyin&#xA;    &amp;quot;analysis&amp;quot; : {&#xA;        &amp;quot;tokenizer&amp;quot; : {&#xA;            &amp;quot;my_pinyin&amp;quot; : {&#xA;                &amp;quot;type&amp;quot; : &amp;quot;pinyin&amp;quot;,&#xA;                &amp;quot;keep_separate_first_letter&amp;quot; : false,&#xA;                &amp;quot;keep_full_pinyin&amp;quot; : true,&#xA;                &amp;quot;keep_original&amp;quot; : true,&#xA;                &amp;quot;limit_first_letter_length&amp;quot; : 16,&#xA;                &amp;quot;lowercase&amp;quot; : true,&#xA;                &amp;quot;remove_duplicated_term&amp;quot; : true&#xA;            }&#xA;        },&#xA;        &amp;quot;analyzer&amp;quot; : {&#xA;            &amp;quot;pinyin_analyzer&amp;quot; : {&#xA;                &amp;quot;tokenizer&amp;quot; : &amp;quot;my_pinyin&amp;quot;&#xA;            }&#xA;        }&#xA;    }&#xA;    &amp;quot;properties&amp;quot;: {&#xA;        &amp;quot;name&amp;quot;: {&#xA;            &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot;,&#xA;            &amp;quot;fields&amp;quot;: {&#xA;                &amp;quot;pinyin&amp;quot;: {&#xA;                    &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;,&#xA;                    &amp;quot;store&amp;quot;: &amp;quot;no&amp;quot;,&#xA;                    &amp;quot;term_vector&amp;quot;: &amp;quot;with_offsets&amp;quot;,&#xA;                    &amp;quot;analyzer&amp;quot;: &amp;quot;pinyin_analyzer&amp;quot;,&#xA;                    &amp;quot;boost&amp;quot;: 10&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; ik-pinyin&#xA;    &amp;quot;analysis&amp;quot;: {&#xA;        &amp;quot;filter&amp;quot;: {&#xA;            &amp;quot;pinyin1&amp;quot;: {&#xA;                &amp;quot;type&amp;quot;: &amp;quot;pinyin&amp;quot;&#xA;            }&#xA;        },&#xA;        &amp;quot;analyzer&amp;quot;: {&#xA;            &amp;quot;ik_pinyin_analyzer&amp;quot;: {&#xA;                &amp;quot;filter&amp;quot;: [&amp;quot;pinyin1&amp;quot;,&amp;quot;word_delimiter&amp;quot;],&#xA;                &amp;quot;type&amp;quot;: &amp;quot;custom&amp;quot;,&#xA;                &amp;quot;tokenizer&amp;quot;: &amp;quot;ik_smart&amp;quot;&#xA;            }&#xA;        }&#xA;    },&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;工具&#xA;kopf&#xA;bigdesk&#xA;head&#xA;使用&#xA;&lt;a href=&#34;https://github.com/mobz/elasticsearch-head&#34;&gt;https://github.com/mobz/elasticsearch-head&lt;/a&gt;&#xA;cnpm i&#xA;npm i -g grunt-cli&#xA;grunt server&#xA;curl localhost:9100&#xA;配置&#xA;Gruntfile.js&#xA;port:9100&#xA;client&#xA;olivere/elastic&#xA;Search&#xA;# SearchService&#xA;Do&#xA;Index&#xA;Query&#xA;Sort&#xA;From&#xA;Pretty&#xA;Index&#xA;# IndexService&#xA;Do&#xA;Index&#xA;Type&#xA;Id&#xA;BodyJson&#xA;Refresh&#xA;Suggest&#xA;# SuggestService&#xA;query&#xA;SimpleQueryString&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/db/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/db/mysql/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    c++编写&#xA;端口&#xA;    3306&#xA;命令&#xA;    mysql&#xA;        --max-relay-logs-size=300           # 中继日志大小(sql语句数)&#xA;        --relay-log-purge={0|1}             # 中继日志自动清空&#xA;        --relay-log-space-limit=0           # 限制中继日志大小,0表示无限制&#xA;&#xA;        o-&amp;gt;&#xA;        mysql -h 127.0.0.1 -u root -p&#xA;    mysqldump&#xA;        -uroot&#xA;        -p&#xA;        -h127.0.0.1&#xA;        -P3306&#xA;        --force&#xA;        --all-databases                     # 所有库&#xA;        --databases db1 db2                 # 多库&#xA;&#xA;        o-&amp;gt;&#xA;        mysqldump -uroot -p db1 tb1&amp;gt; tb1.sql&#xA;    mysqladmin -uroot -p status             # 查看当前连接数&#xA;组件&#xA;    mysql enterprise monitor documentation&#xA;    mysql enterprise monitor connector&#xA;    mysql enterprise monitor service manager&#xA;    mysql enterprise monitor agent&#xA;    mysql enterprise backup&#xA;    mysql connector&#xA;    工具&#xA;        mysql database&#xA;        mysql cluster          # 创建集群，配置复杂&#xA;        mysql cluster manager  # cluster帮助软件，配置简单&#xA;        mysql workbench        # 据库建模工具&#xA;        mysql utilities        # 提供一组命令行工具用于维护和管理 MySQL 服务器&#xA;连接参数&#xA;    root:123456@tcp(abcdefg:3306)/meiqia?&#xA;        charset=utf8mb4,utf8&amp;amp;&#xA;        characterEncoding=UTF-8&amp;amp;&#xA;        loc=UTC&amp;amp;&#xA;        interpolateParams=true&amp;amp;&#xA;        time_zone=%27%2B00%3A00%27&amp;amp;&#xA;        sql_mode=%27NO_ENGINE_SUBSTITUTION%2CSTRICT_TRANS_TABLES%27&#xA;数据类型&#xA;    int             # int(5) zerofill&#xA;    varchar(20)     # null不占空间&#xA;    decimal(10,2)   # 小数&#xA;    char(10)        # 空间已固定, 不论null与否&#xA;    date&#xA;    bool或boolean&#xA;    double&#xA;    float&#xA;    longtext&#xA;    longblob&#xA;    timestamp       # 自动在插入、修改记录时添加，用于记录更新&#xA;    enum(&#39;male&#39;,&#39;female&#39;) default male  # 枚举，只有一个&#xA;    set((&#39;football&#39;,&#39;sleep&#39;,&#39;film&#39;)     # 集合，可以多个&#xA;架构&#xA;    服务器&#xA;        连接管理与安全验证&#xA;        解析器     # 解析到缓存&#xA;            查询缓存(修改时清出缓存)，分析查询语句，生成解析树&#xA;        优化器&#xA;            查询语句优化&#xA;                选索引&#xA;                读取方式&#xA;                获取查询开销信息&#xA;                统计信息&#xA;        执行器&#xA;            执行查询语句，返回结果&#xA;            生成执行计划&#xA;    缓存&#xA;        执行计划缓存&#xA;        数据缓存&#xA;    存储引擎&#xA;        缓存管理    # 管理缓存&#xA;        锁管理      # 管理执行器&#xA;        事务管理&#xA;        文件管理&#xA;            innodb&#xA;事务&#xA;    由存储引擎决定     # 与其它数据库产品不同&#xA;    默认自动提交&#xA;        # variables autocommit, 0 off 1 on&#xA;    一些命令强制自动提交&#xA;        DLL命令&#xA;        lock tables&#xA;目录&#xA;    /var/lib/mysql              # 默认数据库&#xA;    /var/log/mariadb            # 默认日志&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;引擎&#34;&gt;&#xA;  引擎&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e6%93%8e&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;XtraDB&#xA;Memory(Heap)&#xA;    # 之前叫Heap, 存到内存&#xA;NDB&#xA;    特点&#xA;        集群设计&#xA;        share nothing, 高可用，可扩展&#xA;        存到内存, 主键查找快&#xA;        join操作在数据库层完成，不是引擎完成。需要网络开销大，查询慢&#xA;Archive&#xA;    # 适合归档数据，只支持insert和select,提供高速插入和压缩功能&#xA;Federated&#xA;    # 不存数据, 指向远程表，类似oracle的透明网关&#xA;Maria&#xA;    # 开源，用于取代M主ISAM&#xA;MyISAM&#xA;    特点&#xA;        不支持事务&#xA;        表锁&#xA;        适用联机分析(OLAP)&#xA;        不缓存数据文件，只缓存索引文件&#xA;        占较少空间保存数据与索引&#xA;    表文件&#xA;        .frm    # 存储定义&#xA;        .MYD    # MYData 存储数据&#xA;        .MYI    # MYIndex 存储索引&#xA;InnoDB&#xA;    特点&#xA;        支持事务&#xA;        行锁&#xA;        支持外键&#xA;        支持非锁定读  # 类似oracle, 默认读不产生锁&#xA;        面向联机事务(OLTP)&#xA;        数据放在一个逻辑表空间中    # 类oracle&#xA;        实现4种隔离级别&#xA;            默认可重复读repeatable, 使用next-key locking的策略避免幻读&#xA;        索引组织表(Clustered)的方式进行存储     # 类oracle&#xA;        内存池维护并发线程&#xA;    注意&#xA;        自增id最大值放在内存中，重启后会再查找。MyISAM的自增id最大值在文件中，重启不丢失。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;count(*)&#xA;count(name)                        # 不统计null，所以不推荐，会漏数据&#xA;sum(english)/count(*) as 英语平均分&#xA;avg(chinese)&#xA;max(english)&#xA;min(english)&#xA;password(&#39;jiaoningbo&#39;)&#xA;concat(&#39;jiao&#39;,&#39;ning&#39;,&#39;bo&#39;)                concat(38.8) # 连接                转换数字到字符串&#xA;cast(38.8 as char)                        # 转换数字到字符串  同 concat(38.8) 但这个更正式&#xA;strcmp(&#39;text&#39;,&#39;text2&#39;)                # 比较字符串，相同则返回0，不同则返回-1&#xA;abs(&#39;-1&#39;)                                        # 绝对值&#xA;crc32(&#39;mysql&#39;)                                # 计算循环冗余码校验值并返回一个 32比特无符号值&#xA;pi()                                                # pi&#xA;floor(1.2)                                        # 取整 返回一个bigint&#xA;mod(29,9)                                        # 取摩&#xA;is                                                        # select 1 is true,0 is false,null is unknown,null is not unknown  结果 ：1,1,1,0&#xA;coalesce(null,1)                        # 返回第一个非空值，全空则返回null&#xA;greatest(0,2,66,34)                        # 返回不定参数个数的 参数的最大值，个数为0时返回null&#xA;least(2,0)                                        # 返回不定参数个数的 参数的最小值，个数为0时返回null&#xA;1 xor 0 xor 1                                # 异或，两个1消为0&#xA;ascii(&#39;ab&#39;)                                        # 返回最左字符的ascii码&#xA;bin(13)                                                # 返二进制&#xA;bit_length(&#39;text&#39;)                        # 返回二进制长度&#xA;char_length(&#39;str&#39;)                        # 返回字符长度&#xA;left(&#39;foobar&#39;,5)                        # 截取左数前5个&#xA;right(&#39;foobar&#39;,4)                        # 截取右数前4个&#xA;locate(&#39;bar&#39;,&#39;foobar&#39;)                # 返回位置4&#xA;locate(&#39;bar&#39;,&#39;foobarbar&#39;,5)        # 返回从5开始数的子串的位置，这里是7&#xA;ltrim(str)                                        # 去左空格&#xA;rtrim(str)                                        # 去右空格&#xA;trim(str)                                        # 去空格&#xA;make_set(1|4,&#39;hello&#39;,&#39;nice&#39;,&#39;world&#39;)                # 第一位是bit,1|4 表示1+4=5 即二进制101，所以显示结果为&amp;quot;hello,world&amp;quot;, 0 输出空字符串&#xA;repeat(&#39;m&#39;,3)                                # 重复&#xA;replace(&#39;wb&#39;,&#39;w&#39;)                        # replaceAll&#xA;reverse(str)                                # 倒序&#xA;space(6)                                        # 输出6个空格&#xA;adddate(&#39;1998-01-02&#39;,31)        # 加日期  同 adddate(&#39;1998-01-02&#39;,interval 31 day)同 date_add(&#39;1998-01-02&#39;,interval 31 day)&#xA;addtime(&#39;1997-12-31 23:59:59.999999&#39;,&#39;1 1:1:1.000002&#39;)        #加时间 同 &#39;1997-12-31 23:59:59.999999&#39;,&#39;1 1:1:1.000002&#39;);&#xA;curdate()+ 3                                # 当前日期 + 3 天&#xA;date(str)                                        # 提取日期时间表达字符串中的日期部分&#xA;date(&#39;1997-11-12&#39;,&#39;1997-11-11&#39;)                # 前面减后面 得到天数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;系统库数据字典&#34;&gt;&#xA;  系统库/数据字典&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e5%ba%93%e6%95%b0%e6%8d%ae%e5%ad%97%e5%85%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;系统库&#xA;    information_schema&#xA;        # 默认内置元信息数据库&#xA;        INNODE_TRX&#xA;            # 当前开启的事务&#xA;    mysql&#xA;        # 内置安全设置数据库&#xA;    performance_schema&#xA;        # 资源消耗，资源等待等情况&#xA;    sys&#xA;        # 5.7后，数据来源performance_schema, 降低复杂度&#xA;    test&#xA;        # 5.7移除，内置测试数据库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;触发器trigger&#34;&gt;&#xA;  触发器(trigger)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a6%e5%8f%91%e5%99%a8trigger&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;new与old&#xA;    # 指代新数据&#xA;    insert只有new是合法的；&#xA;    delete只有old才合法；&#xA;    update可同时使用。&#xA;语句&#xA;    show triggers [from schema_name];&#xA;    drop trigger [if exists] [schema_name.]trigger_name&#xA;例1&#xA;    create trigger tr1&#xA;    after                   # before, after&#xA;    insert on tb1           # insert, update, delete&#xA;    for each row&#xA;    update tb2 set field1 = field1+char_length(new.name);&#xA;        # 当更新表tb1的name字段时，更新表tb2 field1加上name的长度&#xA;例2      # UPDATE同时使用NEW和OLD&#xA;    create trigger tr1&#xA;    before update on t22&#xA;    for each row&#xA;    begin&#xA;    set @old = old.s1;&#xA;    set @new = new.s1;&#xA;    end;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储过程stored-procedure&#34;&gt;&#xA;  存储过程(stored procedure)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8bstored-procedure&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 5.0加入&#xA;结束符号(delimiter) //&#xA;语法&#xA;    create procedure 存储过程名(参数类型 参数名 参数数据类型)&#xA;    begin&#xA;            业务逻辑&#xA;    end//&#xA;&#xA;    call pro1()//&#xA;        # 执行&#xA;&#xA;    drop function pro1;&#xA;&#xA;    语句&#xA;        # 所有sql语句都是合法的&#xA;&#xA;        declare a int default 2;&#xA;&#xA;        set @name = &#39;admin&#39;;&#xA;            # @name 为局部变量        @@name 为全局变量&#xA;&#xA;        if&#xA;        then&#xA;        else&#xA;        end if;&#xA;&#xA;        case variable1&#xA;        when 0 then&#xA;        when 1 then&#xA;        else&#xA;        end case&#xA;&#xA;        while true do&#xA;        end while&#xA;&#xA;        loop_label:LOOP&#xA;        LEAVE[ITERATE] loop_label;&#xA;        end loop [end loop_label]        # iterate是迭代&#xA;&#xA;        LABEL label_name&#xA;        GOTO label_name&#xA;&#xA;        repeat until&#xA;        end repeat # 执行后检查结果&#xA;&#xA;存储过程名&#xA;    大小写不敏感&#xA;    可以包含空格，最长为64位&#xA;    最好数据库名.过程名&#xA;    不要使用内建函数名&#xA;参数类型&#xA;    IN参数    # 不修改传递进来的参数&#xA;    OUT参数   # 参数无法传进来，只修改参数&#xA;    INOUT参数 # 可读可写&#xA;&#xA;特征子句(characteristics clauses)&#xA;查看&#xA;    show procedure status;&#xA;    show create procedure proc_name;&#xA;    show create function func_name;&#xA;    &#xA;&#xA;异常&#xA;    DECLARE&#xA;    { EXIT | CONTINUE }&#xA;    HANDLER FOR&#xA;    { error-number | { SQLSTATE error-string } | condition }&#xA;    SQL statement&#xA;&#xA;    DECLARE EXIT HANDLER FOR 1216&#xA;    DECLARE CONTINUE HANDLER FOR not found        # 写在存储过程的begin后，当前程序出错后会自动触发代码 MySQL允许两种处理器，&#xA;                                                                                    ## 一种是EXIT处理，上面所用的就是这种。另一种就是我们将要演示的，CONTINUE处理，&#xA;                                                                                    ## 它跟EXIT处理类似，不同在于它执行后，原主程序仍然继续运行&#xA;    DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;23000&#39; SET @x2 = 1; # 如果下面将@x2的值赋为1就会出错&#xA;    DECLARE EXIT HANDLER FOR `Constraint Violation` ROLLBACK;        # 回滚&#xA;&#xA;    DECLARE `Constraint Violation` CONDITION FOR SQLSTATE &#39;23000&#39;;&#xA;    DECLARE EXIT HANDLER FOR `Constraint Violation` ROLLBACK;                        # 先声明条件&#xA;&#xA;游标&#xA;    declare cur_1 cursor for select s1 from t;&#xA;    open cur_1&#xA;    fetch cur_1 into a&#xA;    close cur_1&#xA;&#xA;函数&#xA;    # 与存储过程唯一不同必须有RETURN语句&#xA;    # 不能在函数中访问表&#xA;                &#xA;    function example1:&#xA;    create function myadd(num1 int, num2 int)&#xA;    returns int&#xA;    begin&#xA;    return num1 + num2;&#xA;    end//&#xA;&#xA;                &#xA;例1&#xA;    create procedure pro(in name varchar(20))&#xA;    begin&#xA;    select name;&#xA;    set name=&#39;hello world&#39;;&#xA;    select name;&#xA;    end//&#xA;&#xA;    set @name=&#39;jnb&#39;//&#xA;    call pro(@name)//&#xA;&#xA;例2      # if语句，根据输入0/1 判断 男/女&#xA;    create procedure findGender(in op int)&#xA;    begin&#xA;    declare gendar varchar(20);                                # 在函数中定义变量gendar和其类型&#xA;    if op=0 then                                                        # =表示判断&#xA;    set gendar=&#39;male&#39;;&#xA;    else set gendar=&#39;female&#39;;&#xA;    end if;&#xA;    select gendar;&#xA;    end//&#xA;&#xA;例3      # switch语句，判断星期&#xA;    create procedure findday(in day int)&#xA;    begin&#xA;    declare findday varchar(20);&#xA;    case day&#xA;    when 1 then set findday=&#39;星期一&#39;;&#xA;    when 2 then set findday=&#39;星期二&#39;;&#xA;    when 3 then set findday=&#39;星期三&#39;;&#xA;    when 4 then set findday=&#39;星期四&#39;;&#xA;    when 5 then set findday=&#39;星期五&#39;;&#xA;    when 6 then set findday=&#39;星期六&#39;;&#xA;    when 7 then set findday=&#39;星期七&#39;;&#xA;    else set findday=&#39;无效&#39;;&#xA;    end case;&#xA;    select findday;&#xA;    end//&#xA;        &#xA;例4      # while循环&#xA;    create procedure findsum(in n int)&#xA;    begin&#xA;    declare sum int default 0;&#xA;    declare i int default 0;&#xA;    while i&amp;lt;=n do&#xA;    set sum=sum+i;&#xA;    set i=i+1;&#xA;    end while;&#xA;    select sum;&#xA;    end//&#xA;        &#xA;例5      # 验证登录&#xA;    create procedure prologin(in user_name varchar(20), in user_psw varchar(100), out flag int)&#xA;    begin&#xA;    if exists(select name from users where name=user_name and psw=password(user_psw)) then&#xA;            set flag = 1;&#xA;    else&#xA;            set flag = 0;&#xA;    end if;&#xA;    end//&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; my.cnf文件&#xA;[client]&#xA;&#xA;port=3306&#xA;socket=/tmp/mysql.sock&#xA;&#xA;[mysql]&#xA;default-character-set=gbk&#xA;&#xA;[mysqld]&#xA;character-set-server=utf8&#xA;&#xA;port=3306&#xA;socket=/tmp/mysql.sock&#xA;log-bin=mysql-bin&#xA;server-id=1&#xA;skip-name-resolve&#xA;        # 远程访问时非常慢解决&#xA;innodb-flush-log-at-trx-commit=2&#xA;innodb_log_file_size=268435456&#xA;sync-binlog=1&#xA;        # 这两个配置为了使用事务的InnoDB在复制中最大的持久性和一致性&#xA;master-connect-retry=60&#xA;        # 从服务器断开重连时间&#xA;binlog-do-db=test&#xA;        # 主从都可以设置，复制的数据库&#xA;binlog-ignore-db=mysql&#xA;        # 主从都可以设置，不复制的数据库&#xA;lower_case_table_names=1&#xA;        # 设置大少写不敏感&#xA;interactive_timeout=3600&#xA;sql_mode=IGNORE_SPACE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;安全性&#34;&gt;&#xA;  安全性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e5%85%a8%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;跨域访问，使用ssh隧道加密通信&#xA;set password设置密码&#xA;用grant和revoke对用户授权&#xA;    少开权限&#xA;    只有启动mysql的用户有写权限&#xA;    只授权process和super权限给管理用户&#xA;        mysqladmin processlist 可列举当前执行的查询&#xA;        super 可切断连接，改变服务器运行参数，控制从库&#xA;    不信任dns时，权限表只设置ip&#xA;常见攻击&#xA;    防偷听&#xA;    篡改&#xA;    回放&#xA;    拒绝服务&#xA;acl控制接口权限&#xA;设置只有root可访问mysql数据库和user表&#xA;不用明文密码，密码强度高&#xA;数据库放在防火墙后，或在DMZ(demilitarized zone, 隔离区)&#xA;防火墙设置3306端口不可访问&#xA;sql预编译，避免sql注入&#xA;存数据时检查大小&#xA;以普通用户启动mysql&#xA;tcpdump检查传输数据的安全性&#xA;    tcpdump -l -i eth0 -w -src or dst port 3306 strings&#xA;max_user_connections变量限制指定帐户连接数&#xA;打开mysqld安全开关&#xA;    --local-infile=0     # 0时客户端无法使用local load data&#xA;    --skip-grant-tables     # 对用户不做访问控制&#xA;        mysqladmin flush-privileges # 运行中开启访问控制&#xA;        mysqladmin reload           # 运行中开启访问控制&#xA;    --skip-show-databases   # 禁止show databases&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;初始化&#xA;    systemctl start mariadb&#xA;    mysql_secure_installation&#xA;    etc/my.cnf文件&#xA;        [mysqld]&#xA;        default-storage-engine = innodb&#xA;        innodb_file_per_table&#xA;        max_connections = 4096&#xA;        collation-server = utf8_general_ci&#xA;        character-set-server = utf8&#xA;        [mysql]&#xA;        default-character-set=utf8&#xA;    systemctl restart mariadb&#xA;移数据库&#xA;    同mysql版本, 新目录下替换(/var/lib/mysql/)ibdata1、数据库名目录&#xA;    error: mysqld does not have the access rights to the directory. File name ./ibdata1&#xA;        chcon -R --reference=/var/lib/mysql 新目录&#xA;        或&#xA;        chcon -R -t mysqld_db_t -u system_u -r object_r 新目录&#xA;重初始化数据库&#xA;    rm -r /var/lib/mysql/*&#xA;    mysql_install_db&#xA;    chown mysql:mysql -R /var/lib/mysql&#xA;    systemctl restart mariadb&#xA;    mysql -uroot mysql&#xA;    update user set password=password(&#39;asdf&#39;) where user=&#39;root&#39;;&#xA;    flush privileges;&#xA;授权远程登录&#xA;    GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;asdf&#39; WITH GRANT OPTION;&#xA;创建用户&#xA;    CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;&#xA;删除用户&#xA;    DROP USER &#39;username&#39;@&#39;host&#39;;&#xA;免密登录&#xA;    mysql_safe --user=mysql --skip-grant-tables --skip-networking&#xA;修改密码&#xA;    问题&#xA;        error 1045(28000) access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:no)&#xA;    不能登录时&#xA;        mysqld_safe方式&#xA;            mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;amp;&#xA;            mysql -u root mysql&#xA;            update user set password=password(&#39;newpassword&#39;) where user=&#39;root&#39;;&#xA;                    # 新版中password改为authentication_string&#xA;            flush privileges;&#xA;        mysqld_safe方式2&#xA;            创建a.sql&#xA;                update mysql.user set password=password(&#39;mysql&#39;) where user=&#39;修改用户&#39;;&#xA;                flush privileges&#xA;            mysqld_safe --defaults-file=&amp;quot;a.sql&amp;quot;&#xA;        文件方式&#xA;            使用/etc/mysql/my.cnf中[client]下的user与password&#xA;    能登录时&#xA;        mysqladmin方式&#xA;            mysqladmin -uroot -p password 新密码&#xA;        update方式&#xA;            update mysql.user set password=password(&#39;root&#39;) where user=&#39;root&#39;;&#xA;            flush privileges;&#xA;        set方式&#xA;            SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;newpassword&#39;);&#xA;            flush privileges;&#xA;编码问题&#xA;    查询&#xA;        show variables like &amp;quot;%colla%&amp;quot;       # 字符串排序规则&#xA;        show variables like &amp;quot;%char%&amp;quot;&#xA;    修改&#xA;        set character_set_client=&#39;utf8&#39;&#xA;    创建db时指定&#xA;        create database `db1` character set &#39;utf8&#39; collate &#39;utf8_general_ci&#39;&#xA;    创建表时指定&#xA;        create table (...) engine=innodb default charset=utf8&#xA;    查看db和表编码&#xA;        show database `db1`&#xA;        show create table `tb1`&#xA;    修改db和表编码&#xA;        alter database `db1` default character set utf8 collate utf8_general_ci&#xA;        alter table `tb1` default character set utf8 collate utf8_general_ci&#xA;导库&#xA;    导出&#xA;        o-&amp;gt;&#xA;        mysqldump -uroot -p db1 &amp;gt; db1.sql&#xA;        o-&amp;gt;&#xA;        mysqldump -uroot -p db1 tb1 &amp;gt; db1_tb1.sql&#xA;    导入&#xA;        o-&amp;gt;&#xA;        mysql -uroot -p db1 &amp;lt; db1.sql&#xA;        o-&amp;gt; 数据库中&#xA;        source db1.sql&#xA;主从复制&#xA;    mysql配置文件my.cnf&#xA;    [mysqld]&#xA;        log-bin=mysql-bin&#xA;        server-id=222&#xA;        log-slave-updates =1&#xA;            # m-m-s结构中第二个m配置&#xA;    主服务器授权从服务器&#xA;        GRANT REPLICATION SLAVE ON *.* to &#39;slave&#39;@&#39;%&#39; identified by &#39;asdf&#39;;&#xA;    从服务器设置主服务器&#xA;        change master to master_host=&#39;192.168.56.14&#39;, master_user=&#39;slave&#39;, master_password=&#39;asdf&#39;, master_log_file=&#39;mysql-bin.000001&#39;, master_log_pos=319;&#xA;    命令&#xA;        主服务器&#xA;            flush tables with read lock;&#xA;            grant replication slave on *.* to &#39;slave&#39;@&#39;%&#39; identified by &#39;asdf&#39;&#xA;            show master status\G&#xA;            unlock tables;&#xA;        从服务器&#xA;            stop slave&#xA;            change master to master_host=&#39;192.168.0.42&#39;, master_user=&#39;slave&#39;, master_passowrd=&#39;asdf&#39;, master_log_file=&#39;mysql-bin.000001&#39;, master_log_pos=120;&#xA;            start slave&#xA;            show slave status\G&#xA;    问题&#xA;        The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.&#xA;            # 随意修改data/auto.cnf中的uuid的值&#xA;        主A复制到主B后，主B不会把数据复制到主B的从&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/db/oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/db/oracle/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;安装&#xA;    运行services.msc&#xA;    找到OracleServiceORCL 服务 （最后是数据库名）改为手动&#xA;    sqlplus / as sysdba 运行oracle测试是否安装成功&#xA;    解锁scott用户&#xA;        sqlplus / as sysdba&#xA;        alter user scott account unlock;&#xA;        alter user scott identified by tiger;&#xA;启动&#xA;    OracleServiceORCL&#xA;    OracleOraDb11g_home1TNSListener&#xA;端口&#xA;    1521    # 停了以后再开会变&#xA;权限&#xA;    系统权限：创建数据库，创建用户&#xA;    对象权限：表操作&#xA;    sys create database权限&#xA;    system  没有create database权限&#xA;    scott&#xA;    hr&#xA;    角色  # 超管以角色进入，普通用户输入用户名密码&#xA;        dba&#xA;        dbaoperator&#xA;服务器的组成&#xA;    oracle数据库&#xA;        存储位置 oracle安装位置/oradata/&#xA;            每个数据库文件夹中有多个二进制文件（*.dbf）&#xA;    oracle实例(内存概念)&#xA;        一个数据库进程可以有多个实例&#xA;        一个实例可以有多个数据库进程和一个内存池(缓存)    # 不同于windows进程，每个进程对应一个用户访问&#xA;        服务名为OracleService数据库名&#xA;    集群(多实例)&#xA;        连接失败转移&#xA;        负载均衡&#xA;连接类型&#xA;    normal sysdba sysoper&#xA;分布式&#xA;认证&#xA;    开发技术认证&#xA;    Java认证&#xA;                数据库开发语言SQL和PL/SQL认证&#xA;    数据库技术认证&#xA;        OCM【大师】&#xA;        OCP【专家】&#xA;        OCA【初级】&#xA;    中间件技术认证&#xA;        OracleServer认证，WEB服务器认证&#xA;    专业领域技术认证&#xA;        ERP&#xA;        CRM&#xA;        HR&#xA;        OA&#xA;支持的事务隔离&#xA;    只支持读提交与序列化两种&#xA;版本&#xA;    8i 9i 10i   # i是internet&#xA;    11g         # 基于jdk6, g是grid网格(一个请求多个服务器运行)&#xA;    12c         # c是cloud&#xA;SQL99标准     # 不区分大小写&#xA;    PLSQL是Oracle对SQl99标准的扩展&#xA;    结构代查询语言&#xA;        DML select,insert,update,delete&#xA;        DDL create table,alter table, drop table&#xA;        DCL grant, revoke&#xA;        TCL(杜撰) commit, rollback,rollback to savepoint&#xA;加载过程&#xA;     启动oracle服务&#xA;        oradim -startup -sid 数据库名                 # 相当于windows服务中启动该服务，会从windows注册表中加载配置&#xA;        oradim -shutdown -sid orcl -shuttype srvc    # 停止oracle 服务&#xA;        普通登录&#xA;            sqlplus system/asdf                 # 从注册表中查找默认的数据库名称进行登录&#xA;            sqlplus system/asdf@orcl            # 指定数据库名登录，必须有监听的时候该命令可以执行，监听的进程是独立于oracle之外的进程&#xA;        管理员登录&#xA;            sqlplus / as sysdba                 # windows管理员的身份进行登录，不需要用户名密码，可以在配置文件中禁用它&#xA;        无连接登录&#xA;            sqlplus /nolog                      #用来设置sql/plus&#xA;    启动实例&#xA;        cmd&amp;gt; sqlplus / as sysdba                    # 连接到数据库的空闲实例&#xA;        sql&amp;gt; select status from v$instance          # 查看实例状态&#xA;        sql&amp;gt; shutdown abort                         # 立即终止当前的实例,实例结束后用户仍然登录状态，但没有连接实例&#xA;        sql&amp;gt; startup nomount                        # 启动默认实例（不加载数据库）&#xA;        sql&amp;gt; startup open                           # 启动、装载、打开默认的数据库&#xA;        cmd&amp;gt; set oracle_sid=orcl                    # 在windows下设置oracle的默认登录数据库&#xA;&#xA;        启动过程&#xA;            加载参数文件database/init数据库名&#xA;            分配sga (system global area)到内存空间，用于缓存数据库信息&#xA;            创建后台进程&#xA;    挂载数据库&#xA;        sql&amp;gt; startup mount&#xA;&#xA;        挂载过程&#xA;            装载数据库文件夹中的文件    # sga中有已经初始化了ctl文件的路径，通过ctl文件装载数据库&#xA;            ctl(从中得到数据库文件名) -&amp;gt; dbf&#xA;                    # 3种数据库文件: .ctl(控制文件) .dbf(数据库文件) .log(日志文件)&#xA;            这时，数据库还是不能访问,但是管理员可以访问（debug数据库）&#xA;    打开数据库       # 使外界可以访问&#xA;        sql&amp;gt; alter database 数据库名 open                # 数据库文件夹中记录日志&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;varchar2(7)        # 可变字符串&#xA;char                # 字符&#xA;number(precision [, scale])    # presision是有效位（从左边第一个不为0的数算起，小数点和负号不计入有效位数），scale是精确位（正数为小数的精确位，负数为整数的精确位）&#xA;constant number                # 常量&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据字典&#34;&gt;&#xA;  数据字典&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ad%97%e5%85%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;dual                # dual表只有一行，用于执行一些特殊操作&#xA;dba_sequences&#xA;        select SEQUENCE_OWNER,SEQUENCE_NAME from dba_sequences&#xA;                # 查询序列&#xA;dba_users&#xA;        select username,password from dba_users;&#xA;                # 查询用户和密码&#xA;tab&#xA;        select * from tab&#xA;                # 查看自己的可用表，视图，等&#xA;v$session&#xA;        select count(*) from v$session&#xA;                # 查看当前数据库的连接&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储过程&#34;&gt;&#xA;  存储过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;过程与函数&#xA;    返回值&#xA;        函数有且只一个返回值&#xA;        过程没有或多个返回值用(out参数)&#xA;        过程可返回函数,函数只能返回值或表对象&#xA;    过程和函数不能重名&#xA;    函数可嵌入sql执行，过程不行&#xA;语法&#xA;    IF .. THEN&#xA;            null;&#xA;    ELSIF .. THEN&#xA;            null;&#xA;    ELSE&#xA;            null;&#xA;    END IF;&#xA;&#xA;    select into给变量赋值&#xA;&#xA;    raise 异常名   # 抛异常&#xA;函数&#xA;    create or replace function calculate_score&#xA;    ( cat in varchar2&#xA;    , score in number&#xA;    , weight in number&#xA;    ) return number as&#xA;    begin&#xA;    return null;&#xA;    end calculate_score;&#xA;&#xA;&#xA;    例子1     # in参数 和返回值的函数&#xA;        create or replace function findEmpIncome(pempno in number) return number&#xA;        as&#xA;            income number(10);&#xA;        begin&#xA;            select sal*12+NVL(comm,0) into income from emp where empno = pempno;&#xA;            return income;&#xA;        end;&#xA;        /&#xA;    例子2     # in、out 参数和返回值的函数&#xA;        create or replace function findEmpNameAndSal (pempno in number, psal out number)return varchar2&#xA;        as&#xA;        pename emp.ename%type;&#xA;        begin&#xA;        select ename , sal into pename,psal from emp where empno = pempno;&#xA;        return pename;&#xA;        end;&#xA;        /&#xA;        执行&#xA;        declare&#xA;        psal emp.sal%type;&#xA;        pename emp.ename%type;&#xA;            begin&#xA;                pename := findEmpNameAndSal(7788,psal);&#xA;                dbms_output.put_line(pename||&#39;的工资是&#39;||psal);&#xA;            end;&#xA;            /&#xA;过程&#xA;    # 参数默认in&#xA;    create or replace procedure add_evaluation&#xA;    ( evaluation_id in number&#xA;    , employee_id in number&#xA;    , evaluation_date in date&#xA;    , job_id in varchar2&#xA;    , manager_id in number&#xA;    , department_id in number&#xA;    ) as            # as 变量 类型 (值范围);&#xA;    begin&#xA;    null;&#xA;    exception&#xA;        when others then&#xA;            rollback;&#xA;    end add_evaluation;&#xA;&#xA;    exec  add_evaluation&#xA;&#xA;    drop procedure add_evaluation;&#xA;&#xA;    例子1                # in 参数的使用&#xA;        create or replace procedure raiseSalary(pempno in emp.empno%type)&#xA;        as&#xA;        begin&#xA;            update emp set sal = sal * 1.1 where empno = pempno;&#xA;        end;&#xA;        /&#xA;        exec raiseSalary(7369);&#xA;    例子2                # out参数的使用                select into&#xA;        create or replace procedure findEmpNameAndSalAndJob (pempno in emp.empno%type,&#xA;        pename out emp.ename%type,&#xA;        pjob out emp.job%type,&#xA;        psal out emp.sal%type)&#xA;        as&#xA;        begin&#xA;            select ename,job,sal into pename,pjob,psal from emp where empno = pempno;&#xA;        end;&#xA;        /&#xA;        declare&#xA;            pename emp.ename%type;&#xA;            pjob  emp.job%type;&#xA;            psal  emp.sal%type;&#xA;        begin&#xA;            findEmpNameAndSalAndJob(7788,pename,pjob,psal);&#xA;            dbms_output.put_line(&#39;7788号员工的姓名是&#39;||pename||&#39;,职位是&#39;||pjob||&#39;,薪水是&#39;||psal);&#xA;        end;&#xA;        /&#xA;包&#xA;    声明&#xA;        create or replace PACKAGE emp_eval AS&#xA;        PROCEDURE eval_department(department_id IN NUMBER);&#xA;        FUNCTION calculate_score(evaluation_id IN NUMBER , performance_id IN NUMBER)&#xA;            RETURN NUMBER;&#xA;        END emp_eval;&#xA;    定义&#xA;        CREATE OR REPLACE PACKAGE BODY emp_eval AS&#xA;&#xA;        PROCEDURE eval_department(department_id IN NUMBER) AS&#xA;        BEGIN&#xA;            /* TODO implementation required */&#xA;            NULL;&#xA;        END eval_department;&#xA;&#xA;        FUNCTION calculate_score(evaluation_id IN NUMBER , performance_id IN NUMBER)&#xA;            RETURN NUMBER AS&#xA;        BEGIN&#xA;            /* TODO implementation required */&#xA;            RETURN NULL;&#xA;        END calculate_score;&#xA;&#xA;        END emp_eval;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;触发器&#34;&gt;&#xA;  触发器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a6%e5%8f%91%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    # select 没有触发器&#xA;    语句级insert / delete           # 只在语句执行时触发&#xA;    行级(for each row)update        # 每一行都执行，出错后不会继续执行并且回滚&#xA;语法&#xA;    create [or replace] trigger 触发器名&#xA;    {before|after}&#xA;    {insert|delete|update of 列名}&#xA;    on 表名&#xA;    for each row&#xA;    plsql块&#xA;&#xA;    行级触发器中&#xA;        :new 代表更新后那一行整行的值&#xA;        :old 则是旧的整行的值&#xA;        update of 列名 for each row是连起来用的。语句级触发器没有for each row&#xA;&#xA;    drop trigger 触发器名&#xA;&#xA;例子(语句级)&#xA;    # 当在休息日与非9点到17点之间的时候，禁止对emp表进行插入操作&#xA;    create or replace trigger securityTrigger&#xA;    before insert on emp&#xA;    declare&#xA;    pday varchar2(10);&#xA;    phour number(20);&#xA;    begin&#xA;    select to_char(sysdate,&#39;day&#39;) into pday from dual;&#xA;    select to_char(sysdate,&#39;hh24&#39;) into phour from dual;&#xA;    if(pday in (&#39;星期六&#39;,&#39;星期日&#39;) or (phour not between 9 and 17)) then&#xA;    raise_application_error(&#39;-20666&#39;,&#39;禁止操作&#39;);&#xA;    end if;&#xA;    end;&#xA;    /&#xA;例子(行级)：当对每一行的工资进行修改的时候，新的工资不能小于原来的工资&#xA;    create or replace trigger checkSalayTrigger&#xA;    before update of sal on emp for each row&#xA;    begin&#xA;    if :new.sal &amp;lt; :old.sal then&#xA;    raise_application_error(&#39;-20555&#39;,&#39;工资不能减少&#39;);&#xA;    end if;&#xA;    end;&#xA;    /&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数及常量&#34;&gt;&#xA;  函数及常量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%8f%8a%e5%b8%b8%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;常量&#xA;    sysdate 当前日期&#xA;&#xA;单行函数&#xA;    nvl(comm,0)                        # 替换comm列中的空值为0&#xA;    nvl2(comm,comm,0)                # 替换comm列中的空值为0，非空时为comm&#xA;    select lower(&#39;AAA&#39;) from dual;                        # 取小写&#xA;    upper(&#39;&#39;)                # 取大写&#xA;    initcap(&#39;www.itcast.cn&#39;)        # 每一段字符串的首字符大写&#xA;    concat(&#39;&#39;,&#39;&#39;)                        # 拼接字符串&#xA;    substr(&#39;itcast&#39;,1,3)        # 取第一个和第三个字符，脚标从1开始&#xA;    length(&#39;&#39;)                # 字符的长度&#xA;    lengthb(&#39;&#39;)                # 字节的长度&#xA;    instr(&#39;itcast&#39;,&#39;t&#39;)      # 查找第一个匹配字符串的位置,区分大小写&#xA;    lpad(&#39;a&#39;,10,&#39;*&#39;)                # 左填充，一直到10位,也可以截取左边的10位字节（并非字符）&#xA;    rpad(&#39;a&#39;,10,&#39;*&#39;)                # 右填充，一直到10位,也可以截取右边的10位字节（并非字符）&#xA;    trim(&#39;x&#39; from &#39;xxhelloxsx&#39;)                # 增强版trim(),去掉字符串中的所有&#39;x&#39;&#xA;    replace(&#39;hello&#39;,&#39;l&#39;,&#39;o&#39;)                # 替换字符串中的&#39;l&#39; 为 &#39;o&#39;&#xA;    round(3.45,2)                # 四舍五入，2代表小数点后的位数  -1代表个位，-2代表十位&#xA;            round(sysdate,&#39;month&#39;)      # 四舍五入到月(15号前后判断)&#xA;    round(sysdate,&#39;year&#39;)      # 四舍五入到年(6月30号前后判断)&#xA;    trunc(3.142,1)                # 截取小数点后1位&#xA;    mod(10,3)                        # 10mod3取余&#xA;    nullif(10,20)                # 比较两个数值，相同时返回空，不同时返回第一个数值&#xA;    (job,&#39;analyst&#39;,sal + 1000,&amp;quot;manager&amp;quot;,sal + 800, sal + 400) &amp;quot;新工资&amp;quot; from emp;&#xA;    decode(...)函数：例子&#xA;        select ename &amp;quot;姓名&amp;quot; , sal &amp;quot;原工资&amp;quot; , decode(job, &#39;analyst&#39;,sal + 1000, &#39;manager&#39;,sal + 800, sal + 400) &amp;quot;新工资&amp;quot; from emp;&#xA;        select ename &amp;quot;姓名&amp;quot; , sal &amp;quot;原工资&amp;quot; , case job when &#39;analyst&#39; then sal + 1000 when &#39;manager&#39; then sal + 800 else sal + 400 end &amp;quot;新工资&amp;quot; from emp&#xA;            #sql99语法&#xA;    日期函数&#xA;        sysdate +/- 1                # 增加或减少1天&#xA;        sysdate - hiredate                # 日期减日期，得到天数&#xA;        to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;)                # 格式化显示时间&#xA;        months_between(&#39;12-2月-13&#39;,sysdate)        # 日期之间的月数&#xA;        add_months(sysdate,1)                # 给当前日期增加1个月&#xA;        next_day(sysdate,&#39;星期一&#39;)        # 下一个星期一的日期&#xA;        last_day(sysdate)                        # 反回这个月的最后一天&#xA;    类型转换：&#xA;        隐式转换                # 要求 1，格式正确。2，内容合理&#xA;            字符串与Date,number相互转换&#xA;        显式转换&#xA;            到字符串：&#xA;                日期到字符串：to_char(sysdate,&#39;yyyy &amp;quot;年&amp;quot; mm &amp;quot;月&amp;quot; dd &amp;quot;日&amp;quot; day hh12:mi:ss:am&#39;)&#xA;                    # day是星期、hh12是12进制计时(hh24代表24进制计时)、am是个变量,上午时是am，下午是pm&#xA;                    ##　双引号中的内容直接显示&#xA;                货币值到字符串：to_char(1234,&#39;L9,999&#39;)&#xA;                    # L可以小写，代表当地货币，&#39;,&#39;可以省略&#xA;            字符串到Date： to_date(&#39;1980-12-17&#39;,&#39;yyyy-mm-dd&#39;)&#xA;            字符串转换到数字：        to_number(&#39;123&#39;)&#xA;多行函数    # 多行函数分为接收多个输入，返回一个输出。&#xA;           ##　多行函数本身不会统计值为null的记录&#xA;           ## 多表的多行函数的统计多会用到group by ，因为where 只是筛选出了不符合条件的部分&#xA;           ## ,剩下的部分分列在不同的表中，只有按照列名分组以后才能按列名执行多行函数&#xA;    having&#xA;    count([distinct] deptno)                # 统计deptno【不重复的】记录数&#xA;    sum(sal)                # 统计数值的和&#xA;    avg(sal)                # 统计平均值&#xA;    max(sal)                # 统计最大值，可以用在日期上&#xA;    min(sal)                # 统计最小值 ，可以用在日期上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;游标&#34;&gt;&#xA;  游标&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b8%b8%e6%a0%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    显示&#xA;        cursor is&#xA;    隐式&#xA;        执行insert, delete, update，返回单条记录的select时，pl/sql自动定义&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;闪回技术&#34;&gt;&#xA;  闪回技术&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%aa%e5%9b%9e%e6%8a%80%e6%9c%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;可以闪回的操作&#xA;        dml &#xA;        ddl操作（回收站中存在）&#xA;&#xA;闪回记录&#xA;        1.获取当前时间与改变号&#xA;            select to_char(sysdate,&#39;yyyy-mm-dd:mi:ss&#39;) &amp;quot;系统时间&amp;quot;, timestamp_to_scn(sysdate) &amp;quot;系统改变号&amp;quot; from dual;&#xA;                    # scn 是 系统改变号，每秒钟都会变，oracle根据它来进行闪回,如1216687&#xA;    2.给普通用户授于闪回的权限&#xA;        grant flashback any table to scott;&#xA;    3.alter table emp enable row movement;      # 更改rowid号可以更改&#xA;    4.flashback table emp to SCN 1216687;      # 闪回表到时间改变号&#xA;        # 如果没有做第三步，这里会出错 ，原因是 还原表记录时，递增的rowid后面不能插入数据。在rowid之间插入数据必须改变rowid的状态为可以&#39;移动&#39;，即还原记录后面的表记录可以&#39;移动&#39;。 &#xA;&#xA;闪回表（回收站中才可以）&#xA;        1.确定回收站中有该表，可以用show recyclebin命令查看&#xA;        2.flashback table emp to before drop;&#xA;                # flachback table &amp;quot;BIN$Pu9C2euHQ96xySmn08e5aQ==$0&amp;quot; to before drop;        也是可以的&#xA;        3.如果回收站中有两个相同的表需要闪回时，设置一个表名&#xA;                flashback table emp to before drop rename to newemp;&#xA;                        # 两张同名的表首先恢复最近删除的表&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;审计&#34;&gt;&#xA;  审计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%a1%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;审计（Audit)&#xA;        用于监视用户所执行的数据库操作，并且Oracle会将审计跟踪结果存放到OS文件（默认位置为$ORACLE_BASE/admin/$ORACLE_SID/adump/）&#xA;        或数据库（存储在system表空间中的SYS.AUD$表中，可通过视图dba_audit_trail查看）中。&#xA;        默认情况下审计是没有开启的。&#xA;        不管你是否打开数据库的审计功能，以下这些操作系统会强制记录：用管理员权限连接Instance；启动数据库；关闭数据库。&#xA;        &#xA;两个参数                # cmd&amp;gt; set xxx=xx&#xA;                        ## 这两个参数是static参数，需要重新启动数据库才能生效。&#xA;        Audit_sys_operations&#xA;                默认为false，当设置为true时，所有sys用户（包括以sysdba,sysoper身份登录的用户）的操作都会被记录，&#xA;                audit trail不会写在aud$表中，因为数据库还没有启动，conn / as sysdba 这样的命令是没法记录的&#xA;                windows平台记录在windows的事件管理中,unix平台记录在audit_file_dest参数指定的文件中&#xA;        Audit_trail&#xA;                None：是默认值，不做审计；&#xA;                DB：将audit trail 记录在数据库的审计相关表中，如aud$，审计的结果只有连接信息；&#xA;                DB,Extended：这样审计结果里面除了连接信息还包含了当时执行的具体语句；&#xA;                OS：将audit trail 记录在操作系统文件中，文件名由audit_file_dest参数指定；&#xA;                XML：10g里新增的。&#xA;                &#xA;审计级别&#xA;        Statement(语句)、Privilege（权限）、object（对象）。&#xA;        &#xA;        Statement        按语句来审计，比如audit table 会审计数据库中所有的create table,drop table,truncate table语句。&#xA;        Privilege        按权限来审计，当用户使用了该权限则被审计，如执行grant select any table to a，&#xA;        object                按对象审计，只审计on关键字指定对象的相关操作，如aduit alter,delete,drop,insert on cmy.t by scott; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;sqldeveloper&#xA;isqlplus&#xA;dbconsole&#xA;toad&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sqlplus&#34;&gt;&#xA;  sqlplus&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sqlplus&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;命令&#xA;    # ;或/结束&#xA;&#xA;    /               # 执行最近一次的sql命令（不执行工具命令）&#xA;    host cls        # 清屏&#xA;    edit            # 用本地编辑器编辑&#xA;    设置显示&#xA;        column deptno format 9999       # deptno是列名,9999 代表4个数字宽度&#xA;        column ename format a8          # a8代表8个字符宽度(date也用a)&#xA;            col ename for a8            # 简写&#xA;        set pagesize 40                 # 设置一页显示40条记录&#xA;        spool d:/a.sql                  # 假脱机,开始记录控制台信息&#xA;            spool off                   # 正式保存记录信息到文件&#xA;            @ d:/a.sql                  # 从脱机文件中导入命令并执行&#xA;    监查时间&#xA;        set timing on / set timing off  # 每执行一段语句显示语句的执行时间&#xA;        set time on / set time off      # 在输入标记前面显示当前时间&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;plsql&#34;&gt;&#xA;  pl/sql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#plsql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;procedure language&#xA;oracle对sql99的扩展&#xA;    增加了类型定义&#xA;    判断&#xA;    循环&#xA;    指针/游标/光标&#xA;    输出语句&#xA;    异常&#xA;语法&#xA;    符号&#xA;        /   # 结束标记&#xA;        :=                # 赋值号&#xA;        &amp;amp;   # 进行定义运行时赋值&#xA;    语句&#xA;        declare    分号结束&#xA;        ;&#xA;        begin  dml语句/tcl语句,以分号结束 # 必写&#xA;        ;&#xA;        [exception]&#xA;        ;&#xA;        end;        # 必写&#xA;        /&#xA;&#xA;        set serveroutput on;        # 设置plsql的输出打开，默认是off 的&#xA;&#xA;        dbms_output.put_line(&#39;&#39;);  # 只能在 plsql 的执行语句中使用，dbms_output的输出方法,会自动换行&#xA;&#xA;        emp.ename%type;        # 同emp表中的ename的类型一样的类型&#xA;        emp_record emp%rowtype      # 匹配一行类型&#xA;            emp_record.ename输出一个字段的数据&#xA;&#xA;&#xA;        if 条件1.1 and 条件1.2 then 语句1;&#xA;        elsif 条件2 then 语句2;&#xA;        else 语句3;&#xA;        end if;&#xA;&#xA;        loop&#xA;        exit [when];&#xA;        end loop;&#xA;&#xA;        while 条件&#xA;        loop&#xA;        ;&#xA;        end loop;&#xA;&#xA;        for i in 1..3                # 不可以在循环中更改i的值&#xA;        loop&#xA;        ;&#xA;        end loop;&#xA;&#xA;    cursor      # 多行数据 ，相当于resultset&#xA;        cursor c1 查询语句&#xA;        open c1;&#xA;        loop&#xA;        fetch                        # 先判断再下移，最后一条记录打印两次&#xA;                                        ## 先下移再判断 ，正常显示&#xA;        exit when 条件;&#xA;        end loop;&#xA;        close c1;&#xA;&#xA;异常&#xA;        内置异常&#xA;        no_data_found  # 没有查到数据,游标中使用的时候异常不抛出&#xA;            select ename into pename from emp where deptno = 100;      # select into 插入的数据找不到的时候&#xA;        too_many_rows  #&#xA;        zero_divide    # 除零异常&#xA;        value_error&#xA;        timeout_on_resource&#xA;                例子&#xA;                        declare&#xA;                    i number(2) := 10;&#xA;                    s number(2);&#xA;                begin&#xA;                    s:= i/0;&#xA;                exception&#xA;                    when zero_divide then dbms_output.put_line(&#39;除0异常&#39;);&#xA;                end;&#xA;                        /&#xA;        自定义异常&#xA;                declare&#xA;                no_emp_found exception;&#xA;            begin&#xA;                if()then&#xA;                raise no_emp_found;&#xA;                end if;&#xA;            exception&#xA;                when no_emp_found then dbms_output.put_line(&#39;查无数据&#39;);&#xA;            end;&#xA;            /&#xA;        抛出异常的函数&#xA;                raise_application_error(&#39;-20666&#39;,&#39;禁止操作&#39;);&#xA;                        # begin语句中的相关地方调用此函数即可&#xA;                        # 20000-20999错误编号范围，是负数&#xA;&#xA;例1                # dbms_output.put_line(&#39;&#39;);&#xA;    declare&#xA;        mysum number(3);&#xA;    begin&#xA;        mysum := 10 + 100;      # :=就是赋值&#xA;        dbms_output.put_line(&#39;结果为&#39; || mysum);&#xA;    end;&#xA;    /&#xA;例2      # emp.ename%type&#xA;        ## select .. into ..&#xA;    declare&#xA;        x emp.ename%type;&#xA;        y emp.sal%type;&#xA;    begin&#xA;        --select ename,sal from emp where empno = 7369        # sql语句可以单独执行&#xA;        select ename,sal into x,y from emp where empno = 7369      # plsql语句只能整体执行&#xA;        dbms_output.put_line(x || &#39;是&#39; || y);&#xA;    end;&#xA;    /&#xA;例3                # emp%rowtype&#xA;    declare&#xA;        emp_record emp%rowtype;&#xA;    begin&#xA;        select * into emp_record from emp where empno = 7788;&#xA;        dbms_output.put_line(emp_record.ename || emp_record.sal);&#xA;    end;&#xA;    /&#xA;例4                        # 运行时赋值符号与if判断语句&#xA;    declare&#xA;    num number(2);&#xA;    begin&#xA;    num := &amp;amp;num;&#xA;    if num&amp;lt;5 then dbms_output.put_line(num || &#39;&amp;lt;5&#39;);&#xA;    elsif num=5 then ..&#xA;    else ..&#xA;    end if;&#xA;    end;&#xA;    /&#xA;例5                        # loop 循环&#xA;    declare&#xA;        i number(2) := 1;      # 声明的时候可以赋值&#xA;    begin&#xA;        loop&#xA;            exit when i &amp;gt; 10;&#xA;            dbms_output.put_line(i);&#xA;            i := i + 1;&#xA;        end loop;&#xA;    end;&#xA;    /&#xA;例6                        # while循环&#xA;    declare&#xA;        i number(2) := 10;&#xA;    begin&#xA;        while i &amp;lt;= 20&#xA;        loop&#xA;            dbms_output.put_line(i);&#xA;            i := i + 1;&#xA;        end loop;&#xA;    end;&#xA;    /&#xA;例7                        # for循环&#xA;    declare&#xA;        i number(2)&#xA;    begin&#xA;            loop&#xA;        for i in 20..30    # 一个一个增加,循环中不能再对i进行操作&#xA;            dbms_output.put_line(i);&#xA;        end loop;&#xA;    end;&#xA;    /&#xA;例8                        # cursor&#xA;    declare&#xA;        cursor cemp is select ename,sal from emp;&#xA;        pename emp.ename%type;&#xA;        psal emp.sal%type;&#xA;    begin&#xA;        open cemp;&#xA;        loop&#xA;            exit when cemp%notfound;&#xA;            fetch cemp into pename,psal;&#xA;            dbms_output.put_line(pename || &#39;的薪水是&#39; || psal);&#xA;        end loop;&#xA;        close cemp;&#xA;    end;&#xA;    /&#xA;例9 # 有参游标&#xA;    declare&#xA;        cursor cemp(pdeptno emp.deptno%type) is select ename,sal from emp where deptno=pdeptno;&#xA;        pename emp.ename%type;&#xA;        psal emp.sal%type;&#xA;    begin&#xA;        open cemp(&amp;amp;deptno);&#xA;        loop&#xA;            fetch cemp into pename,psal;&#xA;            exit when cemp%notfound;&#xA;            dbms_output.put_line(pename ||&#39;的薪水是&#39; || psal);&#xA;    end loop;&#xA;            close cemp;&#xA;            end;&#xA;            /&#xA;例10 # 输入&amp;amp;emptno没有的时候，输出&amp;quot;查无员工&amp;quot;                # 综合if loop 与cursor&#xA;    declare&#xA;        cursor cemp(pdeptno emp.deptno%type) is select ename,sal from emp where deptno=pdeptno;&#xA;        pename emp.ename%type;&#xA;        psal emp.sal%type;&#xA;                    pdeptno emp.deptno%type := &amp;amp;deptno;&#xA;    begin&#xA;            if pdeptno in (10,20,30) then dbms_output.put_line(&#39;输入的值正确&#39;);&#xA;        open cemp(pdeptno);&#xA;        loop&#xA;            fetch cemp into pename,psal;&#xA;            exit when cemp%notfound;&#xA;            dbms_output.put_line(pename ||&#39;的薪水是&#39; || psal);&#xA;    end loop;&#xA;            close cemp;&#xA;            else dbms_output.put_line(&#39;输入的值不正确&#39;);&#xA;            end if;&#xA;            end;&#xA;            /&#xA;&#xA;例11 # 给所有ANALYST加工资        # 综合cursor if loop ,循环之后执行了tcl 事务控制语言&#xA;    declare&#xA;        cursor cemp is select empno,ename,job,sal from emp;&#xA;        pempno emp.empno%type;&#xA;        pename emp.ename%type;&#xA;        pjob emp.job%type;&#xA;        psal emp.sal%type;&#xA;    begin&#xA;        open cemp;&#xA;        loop&#xA;            fetch cemp into pempno,pename,pjob,psal;&#xA;            exit when cemp%notfound;&#xA;            if pjob=&#39;ANALYST&#39; then&#xA;                update emp set sal = sal+1000 where empno = pempno;&#xA;            end if;&#xA;        end loop;&#xA;        commit;&#xA;        close cemp;&#xA;    end;&#xA;    /&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/db/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/db/redis/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;remote dictionary server&#xA;特点&#xA;    no-sql, c编写&#xA;    内存数据库       # 请求不经过parser和optimizer&#xA;    key-value&#xA;    单线程&#xA;    可持久化&#xA;&#xA;与memcache区别&#xA;    memcache全在内存，不能持久化，redis部分硬盘&#xA;    memcache类型支持简单&#xA;        # memcache类型只有字符串，append字符串, blacklist删除麻烦&#xA;    emecache多线程, redis单线程&#xA;    底层模型，与客户端通信协议不同，redis自己实现vm机制(冷热数据分离)&#xA;    value, memcache只能存1MB, redis可存1GB&#xA;    redis可设置expire, 支持排行榜, 浮点数&#xA;类型&#xA;    string&#xA;        整个或一部分操作&#xA;        整数、浮点数自增自减&#xA;    list&#xA;        两边推入或弹出&#xA;        偏移量trim&#xA;        读单个多个元素&#xA;        值查找移除元素&#xA;    set&#xA;        增删查单个元素&#xA;        单个元素是否存在&#xA;        交集、并集、差集&#xA;        随机取元素&#xA;    hash&#xA;        增删查单个键值对&#xA;        获取所有键值对&#xA;    zset&#xA;        # 有序集合, 排序根据score, score为双精度浮点数&#xA;        增删查单个元素&#xA;        根据range或成员获取元素&#xA;应用&#xA;    会话缓存(session cache)&#xA;    全面缓存(FPC)&#xA;    队列&#xA;    排行榜/计数器&#xA;    发布/订阅&#xA;命令&#xA;    文件命令&#xA;        redis-server&#xA;            # 端口为6379&#xA;            redis-server /etc/redis.conf  来加载配置文件&#xA;        redis-cli&#xA;        redis-benchmark&#xA;            # 性能测试工具&#xA;&#xA;    redis-cli命令&#xA;        ping&#xA;            # 成功时返回 PONG&#xA;        shutdown&#xA;            # 关闭redis-server服务&#xA;            -p 端口号&#xA;        quit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;功能&#34;&gt;&#xA;  功能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%9f%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;性能高     # 100k次读写/s&#xA;数据类型丰富&#xA;所有操作有原子性&#xA;支持发布/订阅，通知，key过期&#xA;&#xA;&#xA;发布订阅&#xA;        subscribe&#xA;        psubscribe&#xA;                # 订阅给定模式匹配的所有频道&#xA;        unsubscribe&#xA;        punsubscribe&#xA;        publish&#xA;&#xA;        sort&#xA;                # 列表、集合、有序集合排序，返回结果或生成存储&#xA;&#xA;过期&#xA;        persist&#xA;                # 移除键过期时间&#xA;        ttl&#xA;                # 键距离过期时间还有多少秒&#xA;        pttl&#xA;                # 多少毫秒&#xA;        expire&#xA;                # 给定键指定数秒后过期&#xA;        pexpire&#xA;                # 指定的毫秒后过期&#xA;        expireat&#xA;                # unix时间戳过期&#xA;        pexpireat&#xA;                # 毫秒unix时间戳&#xA;&#xA;事务&#xA;                # 事务期其他客户端命令阻塞&#xA;        multi&#xA;                # 创建事务队列，开始记录命令&#xA;        exec&#xA;                # 提交事务队列&#xA;        watch&#xA;                # 对键加锁&#xA;        unwatch&#xA;        discard&#xA;                # 取消事务&#xA;持久化&#xA;        bgsave&#xA;                # fork线程创建快照, windows不支持&#xA;        save&#xA;                # 停止响应创建快照&#xA;        sync&#xA;                # 向主服务器要求复制时，主服务器bgsave，非刚bgsave过&#xA;        bgrewriteaof&#xA;                # 重写aof文件使它缩小&#xA;复制&#xA;        slaveof&#xA;客户端分片&#xA;不完全事务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;性能&#34;&gt;&#xA;  性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内存数据库，需要预估内存，使用key过期节约&#xA;完整重同步占资源，可以部分重同步&#xA;重启数据加载慢&#xA;&#xA;master内存快照时，save命令调rdbSave阻塞主线程&#xA;master AOF持久化，追加文件大时影响master重启恢复速度&#xA;    用slave AOF&#xA;master调用BGREWRITEAOF重写AOF文件时，cpu和内存负载高&#xA;主从复制最好同局域网&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据&#34;&gt;&#xA;  数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;set mykey somvalue&#xA;get mykey&#xA;del mykey&#xA;incr&#xA;decr&#xA;incrby&#xA;decrby&#xA;incrbyfloat&#xA;append&#xA;getrange&#xA;setrange&#xA;getbit&#xA;setbit&#xA;bitcount&#xA;        # 二进制位串位为1的数量&#xA;bitop&#xA;        # 二进制位串执行and, or, xor, not&#xA;&#xA;rpush list-key item&#xA;lpush&#xA;lrange list-key 0 -1&#xA;        # -1为结束索引&#xA;lindex list-key 1&#xA;rpop&#xA;lpop list-key&#xA;lrange&#xA;ltrim&#xA;        # 修剪&#xA;blpop&#xA;        # timeout秒内阻塞并等待弹出元素&#xA;brpop&#xA;rpoplpush&#xA;        # 一个列表中右弹元素推入另一个列表左端，最后返回这个元素&#xA;brpoplpush&#xA;&#xA;sadd set-key item&#xA;smembers set-key&#xA;sismember set-key item&#xA;srem set-key item&#xA;        # 删除，返回删除的数量&#xA;scard&#xA;        # 元素数&#xA;srandmember&#xA;        # 随机返回一个或多个元素。count正数时，返回的元素不重复, 负数时可重复&#xA;spop&#xA;        # 随机移除一个元素&#xA;smove&#xA;        # 一个集合中移除，并在一个集合中添加。返回移除的数量&#xA;sdiff&#xA;        # 差集&#xA;sdiffstore&#xA;        # 差集生成集合&#xA;sinter&#xA;        # 交集&#xA;sinterstore&#xA;sunion&#xA;        # 并集&#xA;sunionstore&#xA;&#xA;hset hash-key sub-key value&#xA;hget hash-key sub-key&#xA;hdel hash-key sub-key&#xA;hlen&#xA;hexists hash-key sub-key&#xA;hkeys hash-key&#xA;hvals&#xA;hgetall hash-key&#xA;hincrbyfloat&#xA;hincrby hash-key field -1&#xA;hmget&#xA;hmset hash-key field1 &amp;quot;foo&amp;quot; field2 &amp;quot;bar&amp;quot;&#xA;&#xA;zadd zset-key 728 member&#xA;zrange zset-key 0 -1 withscores&#xA;zrevrange zset-key 0 -1 withscores&#xA;zrangebyscore zset-key 0 800 withscores&#xA;        # 根据score范围查找&#xA;zrevrangebyscore&#xA;zrem zset-key member&#xA;zremrangebyrank&#xA;zremrangebyscore&#xA;zincrby&#xA;zinterstore sum 3 sub1 sub2 sub3&#xA;        # 生成交集, 重复值score相加, 3 指定可变参数的数量&#xA;zunionstore&#xA;        # 并集&#xA;zcard&#xA;        # 成员数量&#xA;zcount        &#xA;        # 分值之间的成员数量&#xA;zrank&#xA;        # 返回排名&#xA;zrevrank&#xA;zscore&#xA;        # 返回分值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;client&#34;&gt;&#xA;  client&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#client&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;jedis&#xA;    # java, 支持redis sharding, 即ShardedJedis结合ShardedJedisPool&#xA;&#xA;    Jedis jedis = new Jedis(&amp;quot;localhost&amp;quot;);                        # 连接redis数据库&#xA;    jedis.set(&amp;quot;name&amp;quot;, &amp;quot;aa&amp;quot;);                                                # 添加、覆盖&#xA;    jedis.append(&amp;quot;name&amp;quot;, &amp;quot;bb&amp;quot;);                                                # 追加，结果为 name=aabb&#xA;    jedis.get(&amp;quot;name&amp;quot;);                                                                # 取值&#xA;    jedis.del(&amp;quot;name&amp;quot;);                                                                # 删除&#xA;    jedis.mset(&amp;quot;name1&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;name2&amp;quot;, &amp;quot;bb&amp;quot;);                # 批量添加、覆盖&#xA;    jedis.mget(&amp;quot;name1&amp;quot;, &amp;quot;name2&amp;quot;)                                        # 批量取值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;分布式&#34;&gt;&#xA;  分布式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;redisCluster&#xA;twemProxy&#xA;    # twitter开发的redis集群代理&#xA;redisMonitor&#xA;redisSentinel&#xA;    # 主从复制，高可用&#xA;codis&#xA;    # 豌豆荚开发的redis集群代理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;持久化&#34;&gt;&#xA;  持久化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%81%e4%b9%85%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;方式&#xA;    无持久化&#xA;    RDB&#xA;        # 一段时间备份一个RDB文件，RDB文件很紧凑。用fork子进程的方式备份，恢复速度快&#xA;        # 服务器故障时，会丢当前时段数据。数据集大时，fork耗时出现停止服务(毫秒至1秒)&#xA;        point-in-time dump&#xA;            dump-to-disk二条命令&#xA;    AOF&#xA;        # 记录写操作, AOF先于RDB&#xA;        # fsync不fork在后台执行, 追加写文件，文件大时自动重写&#xA;        # AOF文件结构不紧凑，AOF速度慢于RDB(关闭fsync一样快)&#xA;        append-only文件&#xA;        fsync策略&#xA;            从不同步&#xA;            每秒同步一次      # 只丢一秒数据&#xA;            一命令同步一次&#xA;策略&#xA;配置&#xA;    save 60 1000&#xA;            # 60秒内有1000次写入时，自动save&#xA;    stop-writes-on-bgsave-error no&#xA;    rdbcompression yes&#xA;    dbfilename dump.rdb&#xA;&#xA;    appendonly no&#xA;            # 打开AOF&#xA;    appendfsync everysec&#xA;            always&#xA;                    # 每个写命令都马上同步&#xA;            everysec&#xA;                    # 每秒&#xA;            no&#xA;                    # 操作系统决定&#xA;    no-appendfsync-on-rewrite no&#xA;    auto-aof-rewrite-percentage 100&#xA;    auto-aof-rewrite-min-size 64mb&#xA;&#xA;    dir ./&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/middleware/library/hibernate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/middleware/library/hibernate/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;优点&#xA;    完全面向对象编程思想，无sql&#xA;    减少代码&#xA;    控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率&#xA;    hibernate具有独立性（访问层随时可以更换）&#xA;特性&#xA;    不写hbm.xml映射文件，而是基于注解的验证&#xA;    对象、集合、属性的延迟加载&#xA;        dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常&#xA;目录&#xA;    .                                        # hibernate程序包&#xA;    documentation                # 文档&#xA;    lib                                        # 所有依赖包&#xA;    project                                # 源码文件&#xA;加载顺序&#xA;    后面的覆盖前面的&#xA;    hibernate.properties中的配置被覆盖&#xA;        # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置   hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准）&#xA;开发流程&#xA;    加载配置: jdbc参数，数据库方言，hbm映射&#xA;    创建SessionFactory    # 内有连接池&#xA;    创建session&#xA;    事务处理&#xA;    关闭session&#xA;    关闭连接池&#xA;对象状态&#xA;    𣊬时态     # 没有OID(持久化标识), 没有关联session&#xA;    持久态     # 有OID, 与session关联, 事务未提交&#xA;    脱管态     # 有OID, 没有关联session&#xA;缓存机制&#xA;    一级缓存(session)&#xA;        事务级，事务结束缓存失效    # 请求同一对象，取得同一实例&#xA;        总是打开&#xA;    二级缓存&#xA;        SessionFactory级别，session共享&#xA;        缓存散装持久化实例, 有不同缓存策略&#xA;        先设置策略，再设置过期时间与cache提供器&#xA;    优点&#xA;        提高速度、减小压力&#xA;        缓存失效时，不立即查找，而是合并sql查找&#xA;查询方式&#xA;    HQL&#xA;    QBC(命名查询)&#xA;    SQL&#xA;get与load&#xA;    get立即加载，load延时加载&#xA;    get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库&#xA;        # 代理对象只存id&#xA;    get没有时返回null, load抛异常&#xA;检索策略            # 取关联对象&#xA;    立即检索        # 一次全加载, select多&#xA;    延迟检索        # 访问游离状态代理类，需要在持久化状态时已被初始化&#xA;    迫切左外连接检索 # 用外连接取代select，全加载&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;优化&#34;&gt;&#xA;  优化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据库设计调整&#xA;HQL优化&#xA;api正确使用&#xA;配置参数          # 日志、查询缓存，fetch_size, batch_size等&#xA;映射文件优化      # id生成策略，二级缓存，延迟加载，关联优化&#xA;一级缓存管理, 二级缓存策略&#xA;事务控制策略&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;基本概念&#34;&gt;&#xA;  基本概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题&#xA;o-&amp;gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想)&#xA;    DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准&#xA;    它们的区别在于&#xA;        hibernate中不写sql语句&#xA;        ibatis中写少量sql语句&#xA;        DBUtils中写sql语句&#xA;    它们的另一个相同点是&#xA;         底层全都是jdbc&#xA;o-&amp;gt; 结构对应 javabean中的 类，对象，属性&#xA;         数据库中的            表，记录，字段&#xA;o-&amp;gt; hql        hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用&#xA;o-&amp;gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;1.导入核心包(10 + 1个)&#xA;    hibernate3.jar                                # 核心包&#xA;    c3p0-0.9.1.jar&#xA;    antlr-2.7.6.jar                                # 转换hql到sql&#xA;    commons-collections-3.1.jar        # apache的集合增强包&#xA;    dom4j-1.6.1.jar&#xA;    javassist-3.9.0.GA.jar                # 动态代理&#xA;    jta-1.1.jar                                        # java transaction api        处理事务用&#xA;    slf4j-api-1.5.8.jar&#xA;    log4j.jar&#xA;    slf4j-log4j12.jar                        # 三个日志&#xA;    +&#xA;    mysql-connector-java-5.1.7.bin.jar&#xA;        &#xA;2.建立目录&#xA;    hibernate.dao&#xA;            demo.java&#xA;    hibernate.db&#xA;            xx.sql&#xA;    hibernate.domain&#xA;            xx.java&#xA;    hibernate.util&#xA;            HibernateUtil.java&#xA;3.创建映射文件&#xA;    xx.java文件的同目录下，创建&#xA;            xx.hbm.xml&#xA;4.创建配置文件&#xA;    src/hibernate.cfg.xml        (可变)&#xA;    src/hibernate.properties&#xA;5.写提供hibernate session的工具类&#xA;    HibernateUtil&#xA;6.demo中用hibernate session创建事务进行数据库操作&#xA;    demo.java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;session&#34;&gt;&#xA;  session&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#session&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;查询不需要事务，其它都需要事务&#xA;&#xA;流程&#xA;    Session session = HibernateUtil.getSession();&#xA;    Transaction t = session.getTransaction();&#xA;    t.begin();&#xA;    session.update(hero);&#xA;    session.delete(hero);&#xA;    t.comment();&#xA;    &#xA;批量&#xA;    t.begin();&#xA;    session.save(hero);&#xA;    t.commit();&#xA;    session.clear();&#xA;    &#xA;    查询&#xA;    Query query = session.createQuery(hql);&#xA;    List&amp;lt;Hero&amp;gt; heroList = query.list();&#xA;    &#xA;    查询2&#xA;    Query query = session.createQuery(hql);&#xA;    query.setString(0,name);                // hql中参数从0开始&#xA;    query.setString(1,des);&#xA;    Hero hero = (Hero) query.uniqueResult();        // 只有一个结果时使用&#xA;    &#xA;    修改&#xA;    Query query = session.createQuery(hql);&#xA;    int i = query.executeUpdate();&#xA;&#xA;结尾&#xA;    }catch(Exception e){&#xA;            e.printStackTrace();&#xA;            t.rollback();&#xA;    }finally{&#xA;            HibernateUtil.closeSession(); // session.close();&#xA;    }&#xA;        &#xA;session&#xA;    元素的状态&#xA;        # oid: object id,hibernate 的id值唯一并且与表中的数据一一对应&#xA;        ## hibernate中分辨数据只看oid&#xA;        临时（new），无oid,不在session中.生成sql语句&#xA;            持久化（persistence object）：session.save(hero),有oid,在session中;(saveOrUpdate(hero))&#xA;            游离：session.evict(hero),有oid,不在session中,session.update(hero)重新持久化&#xA;            删除：sesssion.delete(hero),有oid,不在session中,不可恢复,提交后可修改数据库&#xA;                # 隐含将po对象转成持久化状态，并生成delete语句。提交后成delete状态，执行语句&#xA;                ## 临时、持久、游离都可以调用&#xA;                ## 临时调用delete时会删除数据库中相应id的值 ，危险&#xA;    函数&#xA;        get 与 load&#xA;            session.get(hero.class,1),从数据库得到持久状态对象&#xA;                与数据库交互&#xA;                查到时返回po&#xA;                查不到时返回null&#xA;            session.load(hero.class,1)&#xA;                不与数据库交互,返回自己创建的po(只有id)&#xA;            访问非id值的时候，与数据库交互&#xA;        session.clear() # session中的引用变量清空&#xA;        session.close() # clear() + 关闭session对象，回收资源，但session非空&#xA;        session.isOpen()&#xA;        session.flush() # 对session中的更改部分生成相应的sql语句,只在session中，不访问数据库&#xA;        session.update()    # 只是将游离重新持久化,不产生sql语句。（执行更新语句时加上它增加可读性）&#xA;                                                ## update()方法执行时会检验一级缓存（session）中是否有 oid相同的po&#xA;                                                ## ,同时会连接数据库，查询一级缓存中po与数据库中记录的一一对应关系&#xA;        session.commit()    # flush() + 提交事务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hibernatecfgxml&#34;&gt;&#xA;  hibernate.cfg.xml&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hibernatecfgxml&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;必要性&#xA;        必须配置&#xA;&#xA;目录与文件名&#xA;        任意，建议 src/hibernate.cfg.xml&#xA;&#xA;源码中的案例文件：&#xA;        \project\tutorials\web\src\main\resources\hibernate.cfg.xml&#xA;        \project\etc\hibernate.cfg.xml&#xA;约束文件位置&#xA;        hibernate3.jar/org/hibernate/hibernate-configuration-3.0.dtd&#xA;数据库连接属性与方言属性的属性名和值可以查找&#xA;        \project\etc\hibernate.properties                # 由于xml文件中配置要覆盖的是hibernate.properties文件中的属性&#xA;                                                                                        ## 所以属性内容从hibernate.properties文件的属性中查找&#xA;        方言类的位置是：hibernate3.jar/org.hibernate/dialect/中查找到相应的类，&#xA;                这是最终的路径，（oracle的通用方言类的类路径 可以用这种方法找到，hibernate.properties配置文件中没有写）&#xA;        &#xA;加载&#xA;        该配置文件属于纯人为配置，需要在Configuration类的实例中调用addResource(&amp;quot;&amp;quot;)方法加载&#xA;        addResource()方法中的参数是本配置文件相对于src/目录的全限定名&#xA;        &#xA;作用&#xA;        1.映射数据库&#xA;        2.配置 类-表映射 资源xml文件的路径&#xA;        &#xA;内容&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;&amp;lt;!DOCTYPE hibernate-configuration PUBLIC&#xA;        &amp;quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&amp;quot;&#xA;        &amp;quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&amp;quot;&amp;gt;&#xA;&amp;lt;hibernate-configuration&amp;gt;&#xA;        &amp;lt;session-factory&amp;gt;&#xA;                &amp;lt;!-- 配置访问数据库需要的属性 --&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;connection.driver_class&amp;quot;&amp;gt;oracle.jdbc.driver.OracleDriver&amp;lt;/property&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;connection.url&amp;quot;&amp;gt;jdbc:oracle:thin:@localhost:1521:orcl&amp;lt;/property&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;connection.username&amp;quot;&amp;gt;scott&amp;lt;/property&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;connection.password&amp;quot;&amp;gt;tiger&amp;lt;/property&amp;gt;&#xA;                &amp;lt;!-- 配置方言 通知hibernate访问哪种数据库的语法结构--&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;dialect&amp;quot;&amp;gt;org.hibernate.dialect.OracleDialect&amp;lt;/property&amp;gt;&#xA;                &amp;lt;!-- 类表映射文件 --&amp;gt;&#xA;                &amp;lt;mapping resource=&amp;quot;hibernate/domain/Hero.hbm.xml&amp;quot;/&amp;gt;&#xA;        &amp;lt;/session-factory&amp;gt;&#xA;&amp;lt;/hibernate-configuration&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hibernateproperties&#34;&gt;&#xA;  hibernate.properties&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hibernateproperties&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;必要性&#xA;        不必须配置&#xA;位置：&#xA;        该文件的位置在src/目录下是不可以改变的，是hibernate加载配置的入口 &#xA;&#xA;源码中的参考文件：&#xA;        /project/etc/hibernate.properties&#xA;                # oracle的通用驱动可以从hibernate3.jar/org.hibernate/dialect包中查找&#xA;        &#xA;作用&#xA;        1.配置连接的数据库，更换数据库只需要更改配置文件即可&#xA;        2.配置数据库方言&#xA;        3.其它控制开关&#xA;&#xA;方言的作用&#xA;        更换数据库访问形式，实现通用性&#xA;&#xA;内容&#xA;        hibernate.dialect org.hibernate.dialect.MySQLDialect&#xA;        hibernate.connection.driver_class com.mysql.jdbc.Driver&#xA;        hibernate.connection.url jdbc:mysql:///outrun&#xA;        hibernate.connection.username outrun&#xA;        hibernate.connection.password asdf&#xA;        hibernate.show_sql true                # 开关：显示实际操作数据库的sql语句&#xA;自动创建表&#xA;    hibernate.hbm2ddl.auto=create      # 每次都创建&#xA;    hibernate.hbm2ddl.auto=update      # 没有时再创建(有但是结构不同时会按照酌情增加列字段)&#xA;                                                                            ## 当更新或插入记录不满足条件时会出错&#xA;缓存&#xA;        hibernate.cache.provider_class                # 开启二级缓存中的普通区           &#xA;        hibernate.cache.use_query_cache                # 开启二级缓存中的查询区&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hibernateutil&#34;&gt;&#xA;  HibernateUtil&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hibernateutil&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;目的&#xA;        对SessionFactory返回Session的方式进行了重构，通过调用该静态工具方法&#xA;        实现只有一个SessionFactory实例，由它产生和销毁很多Session的工厂机制。&#xA;&#xA;缓存&#xA;        SessionFactory 是二级缓存&#xA;        Session 是一级缓存&#xA;                # 查询时，先在二级缓存中查找，没有数据时查找一级缓存，最后查询数据库&#xA;                # 缓存中的数据会用镜像联系着数据库，如果数据库有更新，缓存中的数据会自动更新&#xA;&#xA;SessionFactory对象与Session对象&#xA;        SessionFactory:只创建一次，重量级对象，线程安全，可以共享，实例变量，开始时创建 &#xA;        Session:创建多次，轻量级对象，线程不安全，不可以共享，局部变量，临时创建 &#xA;        &#xA;&#xA;实现代码&#xA;/**&#xA;* 提供hibernate session &#xA;* 并且用threadLocal跟踪实现无参删除&#xA;* &#xA;* @author Administrator&#xA;*&#xA;*/&#xA;public final class HibernateUtil {&#xA;        // 单例的SessionFactory工厂 &#xA;        private static SessionFactory sessionFactory;&#xA;        // 单例的ThreadLocal&amp;lt;Session&amp;gt;实例，但是每个调用者都有自己独有的方法？&#xA;        private static ThreadLocal&amp;lt;Session&amp;gt; threadLocal;&#xA;        /**&#xA;        * 解析配置文件（properties,xml）到hibernate 的配置JavaBean,常驻内存&#xA;        * &#xA;        */&#xA;        static{&#xA;                // 在这里加载了hibernate.properties配置文件（这里可以配置数据库），执行其它配置&#xA;                // 相当于jdbc中的DriverManager类（如果配置了数据库，相当于也注册了连接数据库的类文件 【Class.forName(&amp;quot;..Driver&amp;quot;)语句 ..Driver 新建实例的时候自动向DriverManager注册自己】）&#xA;                Configuration config = new Configuration();&#xA;                // 这里写xml配置文件对于src/目录的相对路径,加载映射用xml文件&#xA;                config.addResource(&amp;quot;hibernate.hbm.xml&amp;quot;);&#xA;                // 加载src/目录下的hibernate.cfg.xml配置文件&#xA;                config.configure();                # configure(&amp;quot;classpath:hibernate.cfg.xml&amp;quot;);&#xA;                                                                        1.configure方法中可以加路径&#xA;                                                                        2.classpath:代表src/目录&#xA;                // 导入org.hibernate.SessionFactory类而非org.hibernate.classic.SessionFactory类&#xA;                sessionFactory = config.buildSessionFactory();&#xA;        }&#xA;        /**&#xA;        * 从单例工厂中得到被跟踪定位(每个调用者)的Session对象,没有就创建&#xA;        * &#xA;        * @return&#xA;        */&#xA;        public static Session getSession(){&#xA;                /* 根据不同的调用者返回跟踪的不同的Session对象,如果是第一次调用，就创建新的session，绑定到单例的ThreadLocal对象中记录，返回给调用者&#xA;                * 如果不是第一次调用 ，也能返回让其得到原来为它创建的Session对象 &#xA;                */ &#xA;                Session session = threadLocal.get();&#xA;                if(session == null){&#xA;                        session = sessionFactory.openSession();&#xA;                        threadLocal.set(session);&#xA;                }&#xA;                return session;&#xA;        }&#xA;        /**&#xA;        * 删除调用者在ThreadLocal实例中的跟踪记录，并且关闭该Session实例&#xA;        * &#xA;        */&#xA;        public static void closeSession(){&#xA;                &#xA;                Session session = threadLocal.get();&#xA;                if(session != null){&#xA;                        session.close();&#xA;                        threadLocal.remove();&#xA;                }&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hql&#34;&gt;&#xA;  hql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;hql特性&#xA;    1.hql是hibernate专用，有专用的技术转换hql到sql,但降低效率&#xA;    2.hql完全面向对象,只出现类，属性，操作符和关键字,例如sum(),order by&#xA;            而sql是面向关系的语言&#xA;使用语句&#xA;        Query query = session.createQuery(hql);&#xA;        Customer c = (Customer)query.uniqueResult();        # 只返回一条结果&#xA;        List&amp;lt;Customer&amp;gt; list = query.list();                        # 返回多条结果&#xA;&#xA;常用 api&#xA;        session.createQuery()&#xA;        session.getNamedQuery()                # 从映射文件中加载&amp;lt;query&amp;gt;标签配置的与&amp;lt;class&amp;gt;标签同级的hql语句&#xA;        query.setString(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;)&#xA;        Object o = query.uniqueResult();&#xA;        List list = query.list();&#xA;        分页&#xA;                query.setFirstResult(0);        # 开始标号&#xA;                setMaxResults(3);              # 最多显示的条数&#xA;        &#xA;query语句                习惯用别名替代类名&#xA;                # from后面出现的是类名，where中比较的是对象属性（已经在映射文件中映射到了表名与字段名）&#xA;        占位符&#xA;                冒号占位符&#xA;                        &amp;quot;from Customer c where c.name = :cname&amp;quot;&#xA;                        query.setString(&amp;quot;cname&amp;quot;,&amp;quot;司马懿&amp;quot;);&#xA;                问号占位符&#xA;                        &amp;quot;from Customer c where c.name = ?&amp;quot;&#xA;                        query.setString(0,&amp;quot;司马懿&amp;quot;);&#xA;        映射文件中分离hql语句&#xA;                        # &amp;lt;query&amp;gt;标签与&amp;lt;class&amp;gt;标签同级&#xA;                &amp;lt;Query name=&amp;quot;findCustomerByAge&amp;quot;&amp;gt;&#xA;        &amp;lt;![CDATA[&#xA;            from Customer c where c.age &amp;lt; ? &#xA;        ]]&amp;gt;&#xA;        Query query = session.getNamedQuery(&amp;quot;findCustomerByAge&amp;quot;);&#xA;        query.setInteger(0,60);&#xA;        查询&#xA;                &amp;quot;from Customer where id = 1&amp;quot;&#xA;            &amp;quot;from Customer as c where c.name = &#39;司马懿&#39; &amp;quot;&#xA;            &amp;quot;from java.lang.Object&amp;quot;    # 映射中没有，写类的全称。查找 src/hibernate.cfg.xml中加载到内存中的映射的类对应的表中的所有记录&#xA;            &amp;quot;from Order o order by o.price desc&amp;quot;&#xA;                投影查询&#xA;                        1.&amp;quot;select c.name,c.age from Customer c &amp;quot;&#xA;                        List&amp;lt;Object[]&amp;gt; list = query.list();        # Object[]中存储的是查询的select 语句中的数值&#xA;                        for(Object [] o : list){&#xA;                System.out.println(o[0]);&#xA;                System.out.println(o[1]);&#xA;            }&#xA;            2.&amp;quot;select count(o), sum(o.price),min(o.price) from Order o&amp;quot;                # count()中的是表类名，统计实例数，查询Order表记录对象的个数 &#xA;            3.&amp;quot;select o.customer.id from Order o&amp;quot;&#xA;用到过的hql&#xA;        级联抓取&#xA;                FROM Role r LEFT JOIN FETCH r.privilegeSet WHERE r.id = :id&#xA;        级联抓取顶级权限表（去重复）&#xA;                SELECT DISTINCT p FROM Privilege p LEFT JOIN FETCH p.childrenSet WHERE p.parent IS NULL&#xA;        级联抓取角色        &#xA;                FROM Account a LEFT JOIN FETCH a.roleSet WHERE a.id = :id&#xA;        三级级联抓取                # 对抓取的集合也可以直接抓取下一层&#xA;                FROM Account a LEFT JOIN FETCH a.roleSet r LEFT JOIN FETCH r.privilegeSet WHERE a.login = :login AND a.pass = :pass&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;编码&#xA;    hibernate用用户操作系统的编码作为自己的编码&#xA;&#xA;    mysql5.5中设置编码：根目录下my文件 default-character-set=gbk&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;查询&#34;&gt;&#xA;  查询&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;hibernate的查询方式&#xA;    1.session.get(字节码,1)&#xA;    2.session.load(字节码,1)&#xA;    3.HQL查询session.createQuery()        session.getNamedQuery()        # 后面是从配置文件中载入hql语句&#xA;    4.对象导航，如多表映射中&#xA;            # 以对象的形式操作数据库中的表，如&#xA;                ## p是person表的一个对象，c是card（身份证表）表的一个对象，p通过配置外键时定义的属性card得到自己的身份证表对象&#xA;                ## 1.从表对象中：Card c = p.getCard();&#xA;                ## 2.从hql语句中：select o.customer.id,o.customer.name,sum(o.price) from Order o group by o.customer.id&#xA;        5.createSQLQuery原生sql语句查询：        # 不要用，用了以后 hibernate跨平台的特性就没有了&#xA;                String sql = &amp;quot;select {a.*} from sysgroup {a} where department regexp ?&amp;quot;;&#xA;                Query query = session.createSQLQuery(sql).addEntity(&amp;quot;a&amp;quot;,SysGroup.class);&#xA;                        # addEntity将表的别名与类字节码关联起来（否则返回的表字段数据是Object类型,jsp页面读取时会出错）&#xA;连接查询的hql语法&#xA;                # 只能连接有外键关系的表类，用表类中的关系类来表示第二张表，不能用笛卡尔积查询&#xA;                ## 也就是说只能查一个表类&#xA;                注意&#xA;                        hql连接查询的语法中用where替代了sql语法中的on&#xA;                        外连接与 sql不同，只能查询与一个表类有关系的外连接表（from语句后面不能写两个表类）&#xA;        内连接&#xA;            from Customer c join c.orderSet o where c.id = o.customer.id&#xA;        外连接                # 这里与 sql不同，只能查询与一个表类有关系的外连接表&#xA;            select c.name,count(o.orderno) from Customer c left join c.orderSet o group by c.name;&#xA;        自连接&#xA;            select a.name, b.name from emp a, emp b where a.mgr=b.id;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;多表映射&#34;&gt;&#xA;  多表映射&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e8%a1%a8%e6%98%a0%e5%b0%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;主控方                # 就是只有主控方的操作成立，非主控方的改变忽略&#xA;        inverse=&amp;quot;true&amp;quot;&#xA;                # false:主表管理，主表插入成功后，再发送n条更新语句来更新外键&#xA;        ## true:从表管理，自己插入时加上：自己javabean中存放的外键关联&#xA;            # 所以购物项中要关联购物车，由于购物车中已经一对多购物项，所以形成了双向关联&#xA;        有该属性的标签&#xA;                &amp;lt;set&amp;gt;&#xA;        缺少主控方出现的问题&#xA;                双向一对多中&#xA;                        1.hibernate生成的sql语句产生重复&#xA;                        2.主键冲突                # 插入操作时，由于“一”表级联插入“多”表，“多”表也要插入自己，它们的主键是相同的，会引起主键冲突&#xA;&#xA;级联                # 数据库只有级联删除&#xA;        cascade=&amp;quot;save-update&amp;quot;  # 插入和更新&#xA;                        # 一般使用save-update，因为表一般软删除，（更新也没有，因为主键不更新，但是hibernate没有单save）&#xA;    cascade=&amp;quot;delete&amp;quot;;  # 删除订单，级联删上层客户&#xA;    cascade=&amp;quot;none&amp;quot;  # 什么都不做（默认）&#xA;    cascade=&amp;quot;all&amp;quot;  # save-update + delete&#xA;        有级联属性的标签&#xA;                class标签下的&#xA;                        &amp;lt;set&amp;gt;&#xA;                        &amp;lt;one-to-one&amp;gt;&#xA;                        &amp;lt;many-to-one&amp;gt;&#xA;        注意&#xA;                级联插入的子表的id内容要为空，否则会变成级联更新                # 这里和单个数据插入时设置对象的id属性不起作用【只有hibernate的主键增长策略起作用】是不同的&#xA;                &#xA;单向一对多                        # 集合映射的一种&#xA;        “一”的类中&#xA;                private Set&amp;lt;Order&amp;gt; orderSet = new LinkedHashSet&amp;lt;Order&amp;gt;();&#xA;        映射xml文件中&#xA;                &amp;lt;!-- set标签用于映射单向一对多 &#xA;                    name表示单方的关联属性&#xA;                    table表示多方对应表的名字&#xA;                    key-column表示多方对应表的外健&#xA;                    one-to-many-class表示单方关联属性中的每个元素的类型&#xA;                --&amp;gt;&#xA;                &amp;lt;set name=&amp;quot;orderSet&amp;quot; table=&amp;quot;ORDERS&amp;quot; cascade=&amp;quot;all&amp;quot;&amp;gt;&#xA;                        &amp;lt;key column=&amp;quot;CUSTOMERS_ID&amp;quot;/&amp;gt;&#xA;                        &amp;lt;one-to-many class=&amp;quot;Order&amp;quot;/&amp;gt;&#xA;                &amp;lt;/set&amp;gt;&#xA;单向多对一                        # 常用&#xA;        映射xml文件中&#xA;                &amp;lt;!--&#xA;                many-to-one映射多方的关联属性&#xA;                name表示多方的关联属性名&#xA;                column表示多方对应表的外健(存储关联类对应表的主键)&#xA;                cascade 级联&#xA;                lazy表示“一”的类数据是否在一开始的时候就查询                # 如果lazy=&amp;quot;proxy&amp;quot;【相当于懒加载】，action类中加载“一”方数据时会出错，因为调用service类结束后线程中的session销毁,延迟加载找不到session会失败&#xA;                fetch表示抓取策略&#xA;                                # 这里产生了hibernate的n+1问题：一条查询语句查出&amp;quot;一&amp;quot;的集合，n条查询语句查出集合中每个元素的一&#xA;                        join代表用join语句查询(一条语句),但是hibernate在多对一的时候不支持fetch=&amp;quot;join&amp;quot;&#xA;                        默认是select，每次查询用一条select语句（多条语句）&#xA;                                解决：自己写新的查询方法查询,执行hql如：FROM Category c LEFT JOIN FETCH c.account&#xA;                --&amp;gt;&#xA;                &amp;lt;many-to-one &#xA;                        name=&amp;quot;customer&amp;quot; &#xA;                        column=&amp;quot;CUSTOMERS_ID&amp;quot; &#xA;                        cascade=&amp;quot;all&amp;quot;&#xA;                /&amp;gt;&#xA;        &#xA;双向一对多  # 双向映射就存在主控方的问题  &#xA;                ##　主表从表（外键【可以为空】）        &#xA;                ## 集合映射的应用&#xA;        1.同时配置单向一对多与单向多对一&#xA;        2.在&amp;quot;一&amp;quot;表中配置inverse=&amp;quot;true&amp;quot;,反转权力，“多”表为主控方&#xA;双向一对一      # 主表从表（从表id既是主键又是外键）&#xA;                ## 双方都是主控方 &#xA;    1.两表都配置&amp;lt;one-to-one/&amp;gt;&#xA;    2.主表配置cascade&#xA;        3.从表中constrained=true属性（主键是否同时为外键约束）&#xA;        &#xA;多对多（单向左到右，单向右到左，双向）                # 集合映射的应用&#xA;                                                                ## 多对多关系中一定要有主控方，否则主键冲突问题&#xA;        1.创建中间表  &#xA;                        # 中间表可以没有自己的JavaBean类文件对应，这时默认有联合主键（联合主键分别是保存的两个外键）&#xA;                students_id&#xA;                teachers_id &#xA;                        # student_id 与 teachers_id为联合主键&#xA;            ## sql语句是primary key(student_id,teacher_id);&#xA;                创建中间表原因：&#xA;                        之所以中间表是因为两边的表中主键唯一，所以不能在一个记录中对对应另一个表的多个记录&#xA;                        中间表相当于把多对多分成两个一对多。&#xA;        2.表对象类中都有对方表的set集合 &#xA;        3.映射xml中      # 可以用inverse,cascade&#xA;                                ##  cascade=&amp;quot;none&amp;quot;时,middle表中的记录也会被删除&#xA;                ## 不配置主控方的话一边更新另一边，另一边也更新自己，会出错&#xA;        &amp;lt;set table=&amp;quot;MIDDLES&amp;quot; name=&amp;quot;teacherSet&amp;quot;&amp;gt;&#xA;            &amp;lt;key columnet=&amp;quot;STUDENTS_ID&amp;quot;/&amp;gt; &#xA;            &amp;lt;many-to-many class=&amp;quot;Teacher&amp;quot; column=&amp;quot;TEACHERS_ID&amp;quot;/&amp;gt;&#xA;        4.dao中&#xA;                在cascade=&amp;quot;all&amp;quot;的配置下实现只删除老师与middle表中的教学关系          # 手工解除关系&#xA;                        # 不手工解除关系的话， 表记录对象：Teacher t1&#xA;                                ，t1删除时,级联删除middle表中数据，middle表中对应了学生的外键&#xA;                                ，由于多对一级联，会删除学生，由于该学生的主键可能会被middle表中的其它记录作为外键引用，所以不能删除，删除时会出错。 &#xA;                &#xA;                查询1号老师对应的学生,并解除关系 &#xA;                        Teacher t1&#xA;                        for(Student s: t1.getStudentSet()){&#xA;                            s.getTeacherSet().remove(t1);&#xA;                        }&#xA;                        1号老师解除关系&#xA;                        t1.setStudentSet(null);&#xA;                        session.delete(t1);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;缓存&#34;&gt;&#xA;  缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;缓存        &#xA;        1.一级缓存(session)中的数据是独享的，二级缓存(sessionFactory)中的数据是共享的&#xA;        2.一级缓存中的数据改变时会更新二级缓存(如果二级缓存设置为read-only时，会更新出错)&#xA;        3.二级缓存默认不能存po(持久化对象) ，只存放连接数据库的信息和映射文件 &#xA;                # 这时查询数据时的顺序是 一级缓存 -&amp;gt; 数据库&#xA;                &#xA;启用二级缓存                # 开启的二级缓存中可以保存po&#xA;                                ## 二级缓存的两个空间：普通缓存区(get、load)、查询缓存区(query对象查询)&#xA;        普通缓存区&#xA;        hibernate.properties文件中配置&#xA;            hibernate.cache.provider_class &#xA;                    org.hibernate.cache.HashtableCacheProvider                # 只能内存缓存&#xA;                    org.hibernate.cache.EhCacheProvider                                # 也能磁盘缓存ehcache的jar包中ehcache-failsafe.xml配置文件中可以查到默认缓存配置&#xA;                                                                            # 可以在hibernate的中文官方教程中查到缓存策略提供商的类&#xA;                                                                            ## hibernate3.2之前缓存类jar包是集成的，默认是EhCache&#xA;                                                                            ## hibernate3.2之后缓存类jar包要自己导入&#xA;                                                                            ## ...Provider类并不是实现类，而是桥接类&#xA;            cache.use_second_level_cache&#xA;                    true                                                # 开启二级缓存（默认是true,但是没有配置缓存提供商之前不开启）&#xA;        hibernate.cfg.xml文件中配置使用二级缓存的类              # 可以设置&amp;lt;cache&amp;gt;的标签&amp;lt;class&amp;gt;&amp;lt;set&amp;gt;&#xA;                                                                                        ## 设置&amp;lt;set&amp;gt;时，set对应表类的也要设置&amp;lt;cache&amp;gt;标签&#xA;                &amp;lt;class-cache usage=&amp;quot;read-write&amp;quot; class=&amp;quot;pojo.Goods&amp;quot; /&amp;gt;&#xA;                usage属性&#xA;                        read-only：二级缓存只读(只是不能进行修改，但是从表中读取数据时一级缓存可以向二级缓存中放入数据)&#xA;                        read-write:可读写&#xA;        查询缓存区（hql语句）：默认不开启&#xA;                        # 因为hql命中率低(要求hql语句相同才行，模糊查询每次基本不同),每次查找会到缓存，找不到再到数据库，查询完数据再存入缓存，效率低&#xA;            ## 不配置的话查询还会存到缓存，但只提供get使用，hql自己不用&#xA;                1.首先开启普通缓存区（设置了表类可以缓存）&#xA;                2.在query对象中开启查询缓存区&#xA;                        query.setCacheable(true);&#xA;        查询顺序：一级缓存 -&amp;gt; 二级缓存 -&amp;gt; 数据库&#xA;&#xA;缓存提供商配置&#xA;        ehcache缓存提供商&#xA;                创建src/ehcache.xml配置文件，使用ehcache缓存时会自动加载其中的配置&#xA;                        &amp;lt;diskStore path=&amp;quot;java.io.tmpdir&amp;quot;/&amp;gt;        # 设置缓存目录，java.io.tmpdir指操作系统的临时目录&#xA;                        diskPersistent&#xA;                        diskExpiryThreadIntervalSeconds                # 这两个集群中使用，上面是是否集群持久化，下面是设置持久化时间&#xA;                        maxElementsInMemory                                        # 内存支持最大对象数目(溢出的对象会存到硬盘中)&#xA;                        overflowToDisk                                                # 内在到最大数目时是否缓存到硬盘&#xA;                        eternal                                                                # 缓存是否永久有效，如果为true，则timeToIdleSeconds与timeToLiveSeconds不起作用&#xA;                        timeToLiveSeconds                                        # 内存中缓存最大存活时间，服务器启动的时间加入其中&#xA;                        timeToIdleSeconds                                        # 缓存不被访问时最大存活时间&#xA;                        memoryStoreEvictionPolicy                        # 内存中对象的替换算法FIFO(先进先出first in first out) &#xA;                                                                                                ## LRU(最近最未使用算法,最久没有被访问的对象踢出) &#xA;                                                                                                ## LFU(最少未被使用算法,考虑了对象的访问频率,踢出最近最少被访问的对象)      &#xA;                                                                                                ## 是windows自己的替换算法&#xA;清空缓存&#xA;        一级缓存：session.clear();&#xA;        二级缓存：sessionFactory.close();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;集合映射&#34;&gt;&#xA;  集合映射&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e5%90%88%e6%98%a0%e5%b0%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;作用&#xA;        集合包含于表类中，对应其一个属性，相当于该类对应表的一个子表&#xA;        每种集合对应一张表，内容对应记录。&#xA;        把java类中经常使用的数据结构对应到表中&#xA;&#xA;使用&#xA;        javaBean（User）中&#xA;                private Set&amp;lt;String&amp;gt; telSet = new LinkedHashSet&amp;lt;String&amp;gt;();&#xA;                private List&amp;lt;String&amp;gt; cityList = new ArrayList&amp;lt;String&amp;gt;();&#xA;                private Map&amp;lt;String,String&amp;gt; telCityMap = new LinkedHashMap&amp;lt;String,String&amp;gt;();&#xA;        xml文件中&#xA;                &amp;lt;set name=&amp;quot;telSet&amp;quot; table=&amp;quot;TELS&amp;quot;&amp;gt;&#xA;            &amp;lt;key column=&amp;quot;USERS_ID&amp;quot;/&amp;gt;        # 外键列：集合所创建的表的外键列名&#xA;            &amp;lt;element column=&amp;quot;TEL&amp;quot; type=&amp;quot;string&amp;quot;/&amp;gt;      # 内容列：这里必需要有type &#xA;                    # set中也可以把&amp;lt;element&amp;gt;标签换成&amp;lt;one-to-many class=&amp;quot;Order&amp;quot;/&amp;gt;标签来对应JaveBean作为值，这就是一对多的映射&#xA;        &amp;lt;list name table&amp;gt;&#xA;            &amp;lt;key column/&amp;gt;&#xA;            &amp;lt;list-index column=&amp;quot;IDX&amp;quot;/&amp;gt;      # 索引列：表中的索引号列(对应在list中的索引)&#xA;            &amp;lt;element column type/&amp;gt;&#xA;        &amp;lt;map name table&amp;gt;&#xA;            &amp;lt;key&amp;gt;&#xA;            &amp;lt;map-key type column&amp;gt;                        # map对应key的列&#xA;            &amp;lt;element column type&amp;gt;&#xA;        dao中使用&#xA;                user.getTelSet().add(&amp;quot;131&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;检索策略&#34;&gt;&#xA;  检索策略&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a3%80%e7%b4%a2%e7%ad%96%e7%95%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;hibernate检索的两种类型&#xA;        立刻检索:session.get,query.list        &amp;lt;class lazy=&amp;quot;true&amp;quot;&amp;gt;标签中类的检索策略，get方法与list都不遵循&#xA;        延迟检索:session.load      # 初始时是代理对象,使用时查询  只有load方法遵循&amp;lt;class lazy=&amp;quot;true&amp;quot;&amp;gt;标签中类的检索策略&#xA;            检索方法是load时&#xA;                lazy属性出现在&amp;lt;class&amp;gt;与&amp;lt;set&amp;gt;标签中,两个标签中lazy属性的含义是不同的，两个lazy属性都是对load方法执行时是否查询数据库进行设置。&#xA;                        # &amp;lt;class&amp;gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中除了set集合之外的所有属性&#xA;                        ## &amp;lt;set&amp;gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中set集合的数据&#xA;                        ## &amp;lt;class&amp;gt;中默认lazy属性的值为true&#xA;                        ## &amp;lt;set&amp;gt;中默认lazy属性的值为true&#xA;                true true 时    查类时没有查集合&#xA;                false true 时    查类时没有查集合&#xA;                false false 时    查类时查集合&#xA;                true false 时    查类时没有查集合&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;经验&#34;&gt;&#xA;  经验&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%8f%e9%aa%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;删除的两种方法 &#xA;        session.delete(session.get(Category.class,id));    # 先查询再删除，效率低&#xA;    session.createQuery(&amp;quot;delete Categroy c where c.id=:id&amp;quot;).setInteger(&amp;quot;id&amp;quot;,id).executeUpdate();&#xA;                    # 执行hql语句，效率高&#xA;                    &#xA;hibernate注解&#xA;        hibernate3.6支持注解&#xA;                javaee5不支持，默认关闭&#xA;                javaee6支持，默认开启，此时不加载注解配置文件会报错，所以要关掉&#xA;                        hibernate.cfg.xml中&#xA;                        &amp;lt;property name=&amp;quot;javax.persistence.validation.mode&amp;quot;&amp;gt;none&amp;lt;/property&amp;gt;&#xA;                        &#xA;DB Browser反射编译表的生成映射文件和类的时候，会生成项目目录下hibernate.reveng.xml的临时配置文件，可以删掉&#xA;&#xA;映射文件class属性&#xA;        dynamic-update=&amp;quot;true&amp;quot;                # 动态更新，只有对相同的session有效，而且性能不好&#xA;                                                                ## 用字段设置中的update=&amp;quot;false&amp;quot;（对象中有字段值时更新，没有时不更新）属性来设置动态更新&#xA;映射文件set标签属性&#xA;        Order-by=&amp;quot;id&amp;quot;                                # set中级联对象按照&amp;quot;id&amp;quot;属性进行排序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;c3p0&#34;&gt;&#xA;  c3p0&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#c3p0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;c3p0并不是hibernate默认的连接池（默认的是hibernate自带的连接池算法）&#xA;        配置c3p0以后自动关闭Hibernate自带的连接池，而使用c3p0连接池&#xA;&#xA;&#xA;hibernate.cfg.xml文件中&#xA;        &amp;lt;!-- 最大连接数 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.max_size&amp;quot;&amp;gt;20&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 最小连接数 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.min_size&amp;quot;&amp;gt;5&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.timeout&amp;quot;&amp;gt;120&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 最大的PreparedStatement的数量 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.max_statements&amp;quot;&amp;gt;100&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.idle_test_period&amp;quot;&amp;gt;120&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.acquire_increment&amp;quot;&amp;gt;2&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 每次都验证连接是否可用 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.validate&amp;quot;&amp;gt;true&amp;lt;/property&amp;gt; &#xA;hibernate.properties文件中&#xA;        hibernate.c3p0.min_size=5 &#xA;        hibernate.c3p0.max_size=20 &#xA;        hibernate.c3p0.timeout=1800 &#xA;        hibernate.c3p0.max_statements=50 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;映射&#34;&gt;&#xA;  映射&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%a0%e5%b0%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;hbm.xml&#xA;    位置与名称：&#xA;            domain.xx.java 文件同级目录 xx.hbm.xml&#xA;&#xA;    约束文件位置&#xA;            hibernate3.jar/org/hibernate/hibernate-mapping-3.0.dtd&#xA;            从其中复制约束头&#xA;            &#xA;    源码中的案例文件&#xA;            \project\tutorials\中搜索 hbm.xml&#xA;&#xA;    类-表映射的特点&#xA;            1.映射JavaBean到表字段（动态占位符），可以使用面向对象的hql语名生成sql语句&#xA;            2.session中保存类对象，缓存查询过的表的内容&#xA;            3.在映射关系的xml文件中可以设置主键的改变方式（这样以后dao类中设置的主键内容被配置文件中的设置覆盖）&#xA;            &#xA;    主键&#xA;            表中的主键&#xA;                    自然主键：有业务逻辑含义的字段（如name）（多个自然主键：联合主键）&#xA;                    代理主键&#xA;            hibernate中id的增加类型&#xA;                    increment  整型,不依赖数据库自增,多线程不安全&#xA;                uuid        缺点：占空间&#xA;                identity    整型，依赖数据库自增,线程安全&#xA;                sequence    专用于oracle数据库,要用特定名字的序列，create sequence hibernate_sequence;线程安全&#xA;                native(重点)    根据情况判断是identity或sequence&#xA;                assigned    自然主键：&amp;lt;id name=&amp;quot;name&amp;quot; column=&amp;quot;name&amp;quot;&amp;gt;,线程不安全&#xA;                composite-id    多个自然主键,表的javaBean必须实现序列化(1.对象序列化到硬盘、数据库【其它JavaBean有id属性，hibernate自动实现序列化】2.线程间传递数据)&#xA;                    &amp;lt;composite-id&amp;gt;&amp;lt;key-property name=&amp;quot;firstname&amp;quot; column=&amp;quot;firstname&amp;quot;/&amp;gt;&amp;lt;key-property name=&amp;quot;firstname&amp;quot; column=&amp;quot;lastname&amp;quot;/&amp;gt;&#xA;&#xA;    持久化对象的两种类型&#xA;            实体型：具有id属性的类，映射成一条含有id主键的完整记录&#xA;            值类型或组件：与上面相反(被实体型包含)，如&#xA;                            # 包含以后会把组件的属性添加到实体类属性的后面，一起当作一张表，仅此而已&#xA;            # Address   &#xA;                province&#xA;                city&#xA;                area&#xA;            映射组件型属性&#xA;            1.类中引用组件：private Address address&#xA;            2.映射 &amp;lt;component name=&amp;quot;address&amp;quot; class=&amp;quot;Address&amp;quot;&amp;gt;&amp;lt;property name column/&amp;gt;&#xA;            3.dao中    star.setAdrress(address);&#xA;    内容&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;!DOCTYPE hibernate-mapping PUBLIC &#xA;        &amp;quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&amp;quot;&#xA;        &amp;quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&amp;quot;&amp;gt;        &#xA;    &amp;lt;hibernate-mapping package=&amp;quot;hibernate.domain&amp;quot;&amp;gt;&#xA;            &amp;lt;class name=&amp;quot;Hero&amp;quot; table=&amp;quot;heros&amp;quot; dynamic-insert=&amp;quot;true&amp;quot;&amp;gt;&#xA;                                    # 设置动态插入为true:如果是null的值，不再插入&#xA;                                    ## 如果不设定动态插入，会插入数据库null值，数据库中设定的默认值不会起作用&#xA;                    &amp;lt;!-- hibernate通过自己内部的类型type=&amp;quot;&amp;quot;,来转换java类型与sql类型之间的转换，一般不必写，自动反射 --&amp;gt;&#xA;                    &amp;lt;!-- id 是指主键，property是属性 --&amp;gt;&#xA;                    &amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;&#xA;                            &amp;lt;!-- hibernate内部的主键生成器 --&amp;gt;&#xA;                            &amp;lt;generator class=&amp;quot;increment&amp;quot;/&amp;gt;&#xA;                    &amp;lt;/id&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;name&amp;quot; column=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;gender&amp;quot; column=&amp;quot;gender&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;age&amp;quot; column=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;birthday&amp;quot; column=&amp;quot;birthday&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;des&amp;quot; column=&amp;quot;des&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;            &amp;lt;/class&amp;gt;&#xA;    &amp;lt;/hibernate-mapping&amp;gt;&#xA;javaBean&#xA;    实现序列化接口&#xA;            在有名为id属性的JavaBean中，hibernate会自动实现序列化接口&#xA;            没有名为id属性的JavaBean中，需要我们自己实现序列化接口&#xA;&#xA;    public class Hero implements java.io.Serializable{&#xA;                private Integer id;&#xA;                private String name;&#xA;                private String gender;&#xA;                private Integer age;&#xA;                private Date birthday;&#xA;                private String des;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/pl/java/collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/pl/java/collection/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;物理容器&#xA;    数组&#xA;    链表&#xA;Java容器&#xA;    Collection&#xA;        List&#xA;            ArrayList&#xA;            Vector                          # JDK1.0，所有方法加synchronized&#xA;                Stack&#xA;            LinkedList&#xA;            CopyOnWriteList                 # 写时复制整个list, 写加锁读无锁, 无fail-fast&#xA;        Set&#xA;            HashSet&#xA;                LinkedHashSet&#xA;            SortedSet&#xA;                TreeSet&#xA;            EnumSet&#xA;            CopyOnWriteArraySet&#xA;            ConcurrentSkipListSet&#xA;        Queue                               # 相比List添加线程友好API&#xA;            Deque                           # 双端队列&#xA;                ArrayDeque&#xA;                BlockingDeque&#xA;                    LinkedBlockingDeque&#xA;            BlockingQueue                   # LockSupport实现, channel, 生产者消费者&#xA;                SynchronousQueue            # 锁实现, 无缓冲区channel&#xA;                TransferQueue               # CAS, 生产者带队列阻塞&#xA;                    LinkedTransferQueue&#xA;                ArrayBlockingQueue          # 有缓冲区channel&#xA;                DelayQueue                  # 内部维护按时间排序队列&#xA;                PriorityBlockingQueue&#xA;                LinkedBlockingQueue         # 最大数量Integer.MAX_VALUE&#xA;            PriorityQueue                   # 堆排序实现&#xA;            ConcurrentLinkedQueue           # CAS&#xA;    Map&#xA;        HashMap&#xA;            LinkedHashMap                   # 双向链表，按插入或访问顺序遍历&#xA;        Hashtable                           # JDK1.0，所有方法加synchronized&#xA;        ConcurrentHashMap                   # CAS, 写慢、读快&#xA;        ConcurrentSkipListMap               # 有序, 没有concurrentTreeMap因为CAS红黑树难实现&#xA;        TreeMap                             # 有序，红黑树, 查找效率高。&#xA;        WeakHashMap&#xA;        IdentityHashMap&#xA;工具类&#xA;    Collections&#xA;        synchronizedMap(Map)                # 内部mutex加synchronized&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;queue&#34;&gt;&#xA;  Queue&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#queue&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    add()                                   # 满了报异常&#xA;    boolean offer()                         # 返回是否成功&#xA;    boolean offer(long, TimeUnit)           # 返回是否成功&#xA;    poll()&#xA;    peek()&#xA;    element()                               # 同peek(), 但空时报错&#xA;    remove()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;blockingqueue&#34;&gt;&#xA;  BlockingQueue&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#blockingqueue&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    put()                                   # 阻塞&#xA;    take()                                  # 阻塞&#xA;TransferQueue&#xA;    transfer()&#xA;    take()&#xA;    getWaitingConsumerCount()               # 阻塞的消费者长度&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/pl/java/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/pl/java/spring/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    容器, 也容纳管理了第三方框架         # 目的是解耦框架api&#xA;    轻量级，模块化，无(少)侵入&#xA;IOC(inversion of control)&#xA;    容器用工厂装配对象并管理, 面向接口编程&#xA;    优点&#xA;        降低代码量&#xA;        容易测试&#xA;        最小侵入性松耦合&#xA;    方式&#xA;        Setter&#xA;        构造器&#xA;        静态工厂、实例工厂&#xA;DI(dependency injection)&#xA;    容器向类添加属性        # 反射，用带参构造或set方法&#xA;AOP(aspect oriented programming)&#xA;    # 继承是纵向组织，AOP横切入业务&#xA;    # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用）&#xA;    动态代理实现切入代码&#xA;        权限控制&#xA;        事务管理&#xA;        记录日志&#xA;    概念&#xA;        连接点:普通方法&#xA;        切入点:名称满足条件的连接点&#xA;        增强（通知）类:服务对象&#xA;            # 切入点与增强是多对多的&#xA;        切面:切入点 + 增强类                        # 我们切入的是横切面&#xA;        目标对象（服务对象）：要注入的对象&#xA;    通知&#xA;        before              # 执行前&#xA;        after               # 执行后&#xA;        after-returning     # 正常退出&#xA;        after-throwing      # 异常退出&#xA;        around              # 执行前后&#xA;        代理对象(业务对象)：被注入的对象&#xA;模块&#xA;    dao, orm, aop, jee, web, core&#xA;结构&#xA;    核心容器(core container)&#xA;        Core        # 最底层，资源访问，类型转换&#xA;        Beans       # IOC, DI, BeanFactory&#xA;        Context     # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播&#xA;        EL          # 表达式语言&#xA;    AOP, Aspects    # Aspects对AspectsJ集成, 功能多于spring asp&#xA;    数据访问/集成&#xA;        JDBC&#xA;        ORM&#xA;        OXM         # object xml 映射&#xA;        JMS         # 消息与异步通信&#xA;        事务&#xA;    Web/Remoting&#xA;        Web             # ioc窗口，rmi, hessian,burlap, web service&#xA;        Web-Servlet&#xA;        Web-Struts&#xA;        Web-Porlet      # portal认证&#xA;    Test&#xA;设计模式&#xA;    代理&#xA;        目标对象实现接口，使用Proxy&#xA;        未实现接口，使用CGLIB&#xA;    单例&#xA;        bean默认单例&#xA;    模板, 解决代码重复问题&#xA;        RestTemplate, JmsTemplate, JpaTemplate&#xA;    控制器&#xA;        DispatherServlet对请求分发&#xA;    视图帮助(view helper)&#xA;        提供jsp标签、高效宏 帮助在视图中写代码&#xA;    依赖注入&#xA;        BeanFactory, ApplicationContext核心理念&#xA;    工厂&#xA;        BeanFactory&#xA;循环依赖问题&#xA;    构造器, 正在创建在Bean池标记，创建完删除标记，标记冲突报错      # 所以用@Autowired决定注入时机，不写在构造方法里&#xA;    单例， 三级缓存, 提前暴露使双方都可初始化&#xA;    setter, 提前暴露bean&#xA;版本&#xA;    2.5&#xA;        注解&#xA;    3.2&#xA;        基于注解的注入测试类@RunW..&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;jar包 ：&#xA;    核心包：/dist/modules                # 或是/dist中的spring.jar包&#xA;        core模块&#xA;            beans&#xA;            context&#xA;            context-support&#xA;            core&#xA;    日志包：/lib/jakata-commons/commons-logging.jar&#xA;创建xml文件(最好在JavaBean的旁边)&#xA;    绑定约束文件        /dist/resources/spring-beans-2.5.xsd&#xA;    copy xml文件的头：/sample/petclinic/war/web-inf/app...xml&#xA;    创建JavaBean.java&#xA;    xml文件中配置bean                # src下&#xA;        &amp;lt;bean id=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot;&amp;gt;                # id值唯一,class指定 javaBean的类目录&#xA;            &amp;lt;property name=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;&amp;quot; ref=&amp;quot;girlID&amp;quot;&amp;gt;                # 引用类型，其中girlID为spring配置的bean Id&#xA;业务类中&#xA;    ApplicationContext ac = new ClassPathXmlApplicationContext(new String [] {&amp;quot;配置xml文件路径&amp;quot;})&#xA;        # 注意：ac创建时，其内部的JavaBean默认全部实例化一遍，并且全部注入了属性&#xA;        ## 该容器不用关闭&#xA;    if(ac.containsBean(&amp;quot;boyID&amp;quot;)){&#xA;        Boy boy = (Boy)ac.getBean(&amp;quot;boyID&amp;quot;);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ApplicationContext是一个接口，表示spring容器/ioc容器&#xA;&#xA;ClassPathXmlApplicationContext        # 只从类路径中读取xml配置文件（src/目录下能访问的路径）省略src/目录&#xA;&#xA;FileSystemXmlApplicationContext                # 文件路径 ,从src/开始&#xA;&#xA;    ac.getBean(&amp;quot;boyID&amp;quot;)&#xA;    ac.containsBean(&amp;quot;boyID&amp;quot;)                # 通过此方法去判断是否存在 ，而不是得到的是否为null&#xA;    ac.destroy()                                        # ac中的bean实例全部销毁&#xA;&#xA;BeanFactory&#xA;    # 基础IOC容器, 默认延迟初始化&#xA;    DefaultListableBeanFactory&#xA;    ApplicationContext&#xA;    XmlBeanFactory      # 根据xml中的定义加载bean&#xA;Spring-DAO      # 提供规范, 翻译框架(JDBC&amp;lt;Hibernate,JPA等)异常为DataAccessException&#xA;    @Repository 注解DAO类&#xA;Spring-JDBC     # 模板类&#xA;    DataSource&#xA;    JdbcTemplate&#xA;    JdbcDaoSupport  # 对dao扩展, DataAccessExceptions异常翻译器&#xA;Spring-ORM      # 统称，对各模块(JPA,JDO,Hibernate,iBatis,TopLink,OJB)实现了spring的集成类&#xA;    把DataSource注入到SessionFactory或EntityManagerFactory等bean中     # jdbc不需要，因为jdbc直接使用DataSource&#xA;    HibernateTemplate&#xA;    HibernateDAOSupport     # 继承它提供aop拦截器&#xA;Web&#xA;    # 在ApplicationContext基础上, 提供web上下文和面向web的服务&#xA;    ApplicationContext      # 以BeanFactory为基础,容器启动后默认全部初始化绑定&#xA;        FileSystemXmlApplicationContext     # 指定文件&#xA;        ClassPathXmlApplicationContext      # 从classpath找设置&#xA;        WebXmlApplicationContext&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;注解&#34;&gt;&#xA;  注解&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e8%a7%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;applicationContext.xml&#xA;    &amp;lt;context:annotation-config/&amp;gt;&#xA;    &amp;lt;!-- 添加注解扫描功能,启动的时候哪些包要检查是否有注解 --&amp;gt;&#xA;    &amp;lt;context:component-scan base-package=&amp;quot;xxx&amp;quot; /&amp;gt;&#xA;&#xA;&#xA;@Required           # setter&#xA;@Autowired          # setter、构造方法、变量&#xA;@Qualifier(&amp;quot;dataSource)                     # 多类配置时，指定使用类&#xA;@Bean               # 返回对象注册为bean&#xA;@Configuration      # bean定义&#xA;&#xA;@Service            # 添加类名小写的spring bean id        也可以@Service(value=&amp;quot;xx&amp;quot;)自定义id&#xA;                    ## action类前换成@Controller                @Service也是可以的&#xA;@Scope(value=&amp;quot;prototype&amp;quot;)&#xA;                    # 工具类或其它组件类换成@Component 也可以@Service,如定时器TimerTask就是组件&#xA;@Resource           # 按属性名注入资源&#xA;&#xA;测试类&#xA;    @RunWith(SpringJUnit4ClassRunner.class)&#xA;    @ContextConfiguration(locations = &amp;quot;classpath:applicationContext*.xml&amp;quot;)&#xA;&#xA;&#xA;@PostConstruct      # 类加载时运行的方法，相当于xml中配置的init-method&#xA;@PreDestroy         # 类销毁前运行的方法&#xA;&#xA;aop&#xA;    applicationContext.xml&#xA;        &amp;lt;aop:aspectj-autoproxy/&amp;gt;&#xA;    @Aspect&#xA;        # 注册一个类为切面&#xA;    @Pointcut(value=&amp;quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&amp;quot;)&#xA;        # 配置切点表达式&#xA;    private void testAop(){}&#xA;    @AfterReturning(pointcut=&amp;quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&amp;quot;)&#xA;        # 配置通知，在通知中配置切点&#xA;    @AfterReturning(value=&amp;quot;testAop()&amp;quot;)&#xA;        # 配置通知，使用已经配置的切点&#xA;    @Around(value=&amp;quot;testAop()&amp;quot;)&#xA;        # 配置通知，使用已经配置的切点&#xA;    @Around(value=&amp;quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.queryByWord(..))&amp;quot;)&#xA;        # 配置通知，在通知中配置切点,注意这里没有pointcut,只有value&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模块&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;监听器&#34;&gt;&#xA;  监听器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e5%90%ac%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    org.springframework.web.context.ContextLoaderListener中&#xA;        this.contextLoader.initWebApplicationContext(event.getServletContext());&#xA;            # 加载Spring 的配置文件 ，加载Application内置对象中&#xA;    initWebApplicationContext方法中&#xA;        this.context = createWebApplicationContext(servletContext, parent);&#xA;        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);&#xA;            # 创建并存储spring的application内置对象到ServletContext中，属性名称是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&#xA;    createWebApplicationContext方法中&#xA;        wac.setConfigLocation(sc.getInitParameter(CONFIG_LOCATION_PARAM));&#xA;            # 该类文件中有：public static final String CONFIG_LOCATION_PARAM = &amp;quot;contextConfigLocation&amp;quot;;&#xA;            # 获得web.xml中配置的context-param初始化参数：contextConfigLocation的内容，并加载spring配置文件&#xA;&#xA;使用&#xA;    servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);&#xA;&#xA;    ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;properties&#34;&gt;&#xA;  properties&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#properties&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;spring xml配置文件中使用properties配置的属性&#xA;    配置一个bean的class类是org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer的单例bean&#xA;        &amp;lt;property name=&amp;quot;locations&amp;quot; value=&amp;quot;classpath:public.properties&amp;quot; &amp;gt;&#xA;            &amp;lt;array&amp;gt;&#xA;                &amp;lt;value&amp;gt;classpath:conn.properties&amp;lt;/value&amp;gt;&#xA;        或&#xA;        &amp;lt;property name=&amp;quot;location&amp;quot; value=&amp;quot;classpath:conn.properties&amp;quot; /&amp;gt;&#xA;    xml文件中用&amp;quot;${driver}&amp;quot;的方式引用properties中配置的属性&#xA;java类中用spring的注解注入properties配置的属性&#xA;    # 要求必须是spring管理的类&#xA;    bean中的class类换成org.springframework.beans.factory.config.PropertiesFactoryBean&#xA;    id=&amp;quot;Xxx&amp;quot;其它相同&#xA;    java类的属性或set方法上添加注解：&#xA;    @Value(&amp;quot;#{public.basePath}#{public.filePath}&amp;quot;)&#xA;        # 其中public 是上面配置的bean的id(xml文件中注入属性的话用不到id,所以没有配置)&#xA;        ## &#39;#{}&#39;代表引用属性&#xA;        ## &#39;.&#39;可以用&#39;[]&#39;代替，如public[basePath]&#xA;        ## 字符串的拼接可以用+连接&#xA;        # 第一次配置@Value的时候不会成功，改一次值再试就可以了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;bean&#34;&gt;&#xA;  bean&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;创建bean的顺序&#xA;    xml中按配置顺序的先后&#xA;    注解中按照字母的顺序&#xA;生命周期&#xA;    配置中定义&amp;lt;bean&amp;gt;&amp;lt;/bean&amp;gt;&#xA;    初始化&#xA;        配置文件中init-method&#xA;        实现org.springframework.beans.factory.InitializingBean接口&#xA;    调用&#xA;    销毁&#xA;        配置文件中destroy-method&#xA;        实现org.springframework.bean.factory.DisposeableBean&#xA;scope&#xA;    # 默认singleton&#xA;    prototype   # 每次产生新对象&#xA;    singleton   # 单例&#xA;    request     # 一个请求一个对象，只在ApplicationContext下有效&#xA;    session     # 一个session一个对象，只在ApplicationContext下有效&#xA;    global-session      # 一个全局session一个对象, 只在ApplicationContext下有效&#xA;内部bean&#xA;    &amp;lt;property&amp;gt;或&amp;lt;constructor-arg&amp;gt;中定义的&amp;lt;bean&amp;gt;,通常匿名&#xA;注入对象&#xA;    &amp;lt;list&amp;gt;&#xA;    &amp;lt;set&amp;gt;&#xA;    &amp;lt;map&amp;gt;&#xA;    &amp;lt;props&amp;gt;         # 键值都只能是string类型&#xA;自动装配&#xA;    方式&#xA;        no      # 不自动装配，通过ref属性指定&#xA;        byName&#xA;            查找类中setter&#xA;            容器中找id&#xA;            报空指针&#xA;        byType&#xA;            容器中找类型      # 找到多个时抛异常&#xA;        constructor&#xA;            byType带构造函数参数&#xA;        autodetect&#xA;            先试constructor, 再试byType&#xA;    写法&#xA;        &amp;lt;bean&amp;gt;属性autowire=&amp;quot;byName&amp;quot;&#xA;        @Autowired&#xA;            类型自动装配&#xA;            加上@Qualifier(value=&amp;quot;a&amp;quot;)&#xA;                @Resource(name=&amp;quot;a&amp;quot;)注解的name装配&#xA;                byName装配&#xA;                byType装配&#xA;&#xA;配置&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;&#xA;        xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;&#xA;        xsi:schemaLocation=&amp;quot;&#xA;            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&#xA;            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&amp;quot;&amp;gt;&#xA;        &amp;lt;bean&#xA;            id=&amp;quot;userDaoID&amp;quot;&#xA;            name=&amp;quot;&amp;quot;&#xA;            class=&amp;quot;cn.itcast.javaee.spring.bean.life.UserDao&amp;quot;&#xA;            init-method=&amp;quot;getSession&amp;quot;&#xA;            destroy-method=&amp;quot;closeSession&amp;quot;&#xA;            factory-method=&amp;quot;getUserDao&amp;quot;&#xA;            scope=&amp;quot;singleton&amp;quot;&#xA;            lazy-init=&amp;quot;false&amp;quot;&#xA;            parent=&amp;quot;userDaoID&amp;quot;&#xA;            abstract=&amp;quot;true&amp;quot;&#xA;            autowire=&amp;quot;no&amp;quot;&amp;gt;&#xA;                &amp;lt;constructor-arg type=&amp;quot;java.lang.Integer&amp;quot; index ref&amp;gt;&#xA;                    &amp;lt;value&amp;gt;2013&amp;lt;/value&amp;gt;&#xA;                &amp;lt;constructor-arg type=&amp;quot;java.lang.Double&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;6000&amp;lt;/value&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;aa&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;name&amp;quot; ref=&amp;quot;dateID&amp;quot; /&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;telSet&amp;quot;&amp;gt;&#xA;                &amp;lt;set&amp;gt;&#xA;                    &amp;lt;value&amp;gt;11&amp;lt;/value&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;cityList&amp;quot;&amp;gt;&#xA;                &amp;lt;list&amp;gt;&#xA;                    &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;telCityMap&amp;quot;&amp;gt;&#xA;                &amp;lt;map&amp;gt;&#xA;                    &amp;lt;entry key=&amp;quot;&amp;quot;&amp;gt;&#xA;                        &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;&amp;quot;&amp;gt;&#xA;                    &amp;lt;props&amp;gt;&#xA;                        &amp;lt;prop key=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/prop&amp;gt;&#xA;标签、属性分析&#xA;    bean标签：代表一个JavaBean&#xA;        # 多个JavaBean配置时，先配置的先创建，先创建的后销毁&#xA;        id：该JavaBean的唯一标识&#xA;        name：可以和id一样用，但是name可以设置&amp;quot;/a&amp;quot;来绑定路径&#xA;        class：该JavaBean的类路径&#xA;        init-method：创建该JavaBean时运行的其中的方法&#xA;        destroy-method：销毁该JavaBean时运行的其中的方法&#xA;            # ClassPathXmlApplicationContext类的实例不监听销毁方法&#xA;            ## 用AbstractApplicationContext中的close()与registerShutdownHook()方法&#xA;            ## close()直接马上销毁，registerShutdownHook()方法会注册关闭钩子,监听容器的销毁&#xA;            ## &#xA;        factory-method：创建该Bean的函数&#xA;            得到接口实现类的方法&#xA;            1.通过实现类的无参构造器                # 没有factory-method属性&#xA;            2.没有无参构造器时，工厂静态方法创建实例&#xA;                &amp;lt;bean id=&amp;quot;userDaoID&amp;quot; factory-bean=&amp;quot;daoFactoryID&amp;quot; factory-method=&amp;quot;getUserDao&amp;quot;&amp;gt;&#xA;                    # class中的内容是工厂类，而非UserDao类，factory-method是工厂类中返回UserDao类的静态方法&#xA;            3.没有无参构造器时，工厂非静态方法创建实例&#xA;                &amp;lt;bean id=&amp;quot;daoFactoryID&amp;quot; class=&amp;quot;cn.itcast.javaee.spring.bean.create.type3.DaoFactory&amp;quot;&amp;gt;&#xA;                    &amp;lt;bean id=&amp;quot;userDaoID&amp;quot; factory-bean=&amp;quot;daoFactoryID&amp;quot; factory-method=&amp;quot;getUserDao&amp;quot;&amp;gt;&#xA;                        # 先实例化工厂（Spring 加载本xml文件默认实例化），然后静态方法的配置即可&#xA;        scope：作用域&#xA;            1.singleton（单例）是默认值，是单例的，会调用init destory方法 &#xA;            2.prototype（原型）每次创建一个实例， 调用init方法，但不调用destory方法（实例的维护 ：javase程序交给jvm,javaee程序交给服务器）&#xA;        lazy-init&#xA;            1.false:为启动容器时立即创建一个实例                # singleton与prototype模式都会创建&#xA;            2.true:启动时不加载,获取时创建&#xA;        parent：        继承一个Spring bean(包含其中的所有属性)&#xA;            # javaBean类中不必有实际的继承关系（但是有继承关系则必要配置parent）&#xA;        abstract=&amp;quot;true&amp;quot;        : 配置此Bean为抽象Bean&#xA;        autowire=&amp;quot;no&amp;quot;:自动装配，只能装配关联属性&#xA;            # 还可以进行注解装配&#xA;            byName      装配时根据bean中的每个属性名从spring中找id同名的bean,通过setter方法注入到该属性中&#xA;            byType      根据bean中的每个属性的类型找到spring中映射该类型的bean进行装配,通过setter方法注入到该属性中&#xA;            constructor 找满参构造器装载，构造器中的参数以byType方式注入&#xA;            autodetect  先找构造器装载，再set方法注入。但实际使用中只能set方法注入&#xA;            no          不注入&#xA;        可以配置init-method与destroy-method属性来配置该bean创建和销毁时执行的方法&#xA;    注入值                  # 通过setter方法注入值 &#xA;        &amp;lt;constructor-arg type=&amp;quot;java.lang.Integer&amp;quot; index ref&amp;gt;        &#xA;            &amp;lt;value&amp;gt;2013&amp;lt;/value&amp;gt;    # 传入构造方法参数注入值，,位置不能颠倒，不调用setter方法&#xA;                ## type是注入参数的类型，index是参数的标号，从0开始，ref是引用类型,有引用类型时不用&amp;lt;value&amp;gt;标签&#xA;            &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;aa&amp;quot;/&amp;gt;                # 基本类型直接赋值（包括包装类型与String）&#xA;            &amp;lt;property name=&amp;quot;name&amp;quot; ref=&amp;quot;dateID&amp;quot;/&amp;gt;        # 引用类型,dateID是一个Spring Bean&#xA;                ## 可以直接引用Spring Bean 的id &#xA;                &amp;lt;set&amp;gt;&#xA;                    &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;                                                # set集合&#xA;                &amp;lt;list&amp;gt;&#xA;                    &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;                                                # list集合&#xA;                &amp;lt;map&amp;gt;&#xA;                    &amp;lt;entry key=&amp;quot;&amp;quot;&amp;gt;&#xA;                            &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;                                        # map集合&#xA;                    # 集合的值均可配置引用类型&#xA;                &amp;lt;property name=&amp;quot;&amp;quot;&amp;gt;&#xA;                    &amp;lt;props&amp;gt;&#xA;                        &amp;lt;prop key=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/prop&amp;gt;                        # 属性类型，只能配置基本类型 （包括包装类型与String）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;aop&#34;&gt;&#xA;  aop&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;实现      # 基于Aspectj&#xA;原理&#xA;    启动容器时，创建目标对象与代理对象&#xA;    &amp;lt;aop:config/&amp;gt;加载完时,通过cglib创建目标对象的代理对象，运行时产生&#xA;    程序员-代理对象-代理方法-目标对象-目标方法-代理对象&#xA;使用&#xA;    写类文件&#xA;    1.jar包  aspectjweaver.jar/aspectjrt.jar/cglib-nodep-2.1_3.jar(动态代理包)&#xA;    2.配置xml文件头,保留aop&#xA;        &amp;lt;bean id class/&amp;gt;        # 目标对象&#xA;        &amp;lt;bean id=&amp;quot;serviceBeanID&amp;quot; class /&amp;gt;    # 配置增强对象&#xA;        &amp;lt;aop:config&amp;gt;            # 相当于创建了代理对象&#xA;            &amp;lt;aop:pointcut id=&amp;quot;xxxx&amp;quot; expression=&amp;quot;&amp;quot; /&amp;gt;        # 切入点表达式：expression=&amp;quot;execution(public void addUser() throws java.lang.Exception)&amp;quot;&#xA;                ## 可以写成execution(public void 类名.*()),表示匹配所有方法&#xA;                ## execution(* *(..))        第一个*是返回值，第二个*是方法，..表示参数不限&#xA;                ## 可以声明抛异常&#xA;                ## 条件命名为xxxx,升级连接点到切入点&#xA;            &amp;lt;aop:aspect ref=&amp;quot;serviceBeanID&amp;quot;&amp;gt;&#xA;                &amp;lt;aop:before method=&amp;quot;writeLog&amp;quot; pointcut-ref=&amp;quot;xxxx&amp;quot;/&amp;gt;    # 前置增强，method是注入的方法，xxxx是增强的条件,只能写一个方法&#xA;                &amp;lt;aop:after/&amp;gt;&#xA;                &amp;lt;aop:after-returning/&amp;gt;      # 方法返回后执行&#xA;                &amp;lt;aop:after-throwing/&amp;gt;      # 抛出异常时执行&#xA;                &amp;lt;aop:around/&amp;gt;              # 环线，执行目标方法前、后都执行,出错则之后的函数不执行&#xA;                    public void both(ProceedingJoinPoint pjp){      # ProceedingJoinPoint是连接代理对象 与目标对象的桥梁&#xA;                        open();&#xA;                        pjp.proceed();      # 执行目标代码&#xA;                        close();&#xA;                    }&#xA;                    # 目标方法出错，后置增强仍然执行,after-throwing执行，前置增强不执行,after-returning不执行&#xA;                    &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot; pointcut-ref=&amp;quot;xxxx&amp;quot;/&amp;gt;                # 配置事务的切面&#xA;切入点表达式&#xA;    execution(方法的修饰符 方法的返回值类型 方法所属的类 方法名 方法中参数列表 方法抛出的异常)&#xA;        方法的修饰符：    支持通配符*，可省略&#xA;        方法的返回值类型：支持通配符*，表示所有返回值，不可省&#xA;        方法所属的类：    支持通配符*，可省略&#xA;        方法名：          支持通配符*，表示所有方法，不可省&#xA;        方法中参数列表：  支持通配符*，不可省&#xA;                # *表示【一个】任意类型的参数&#xA;                ## ..表示零个或一个或多个任何类型的参数【提倡】&#xA;    execution(方法的返回值类型 方法名（方法中参数列表））                # 一般形式&#xA;&#xA;    例如:&#xA;    execution(public void add()throws Exception)&#xA;    execution(public void add(..)throws Exception)&#xA;    execution(public void add(*)throws Exception)&#xA;    execution(* cn.itcast.web.spring.aop.UserDao.add(..))&#xA;    execution(* add()throws Exception)&#xA;    execution(public void *(..)throws Exception)&#xA;            execution(public void a*(..)throws Exception)：方法名以a字符开始&#xA;    execution(public void *d(..)throws Exception)：方法名以d字符结束&#xA;    execution(* add())&#xA;    execution(* *(..))&#xA;切点方法的编写&#xA;    public void Xxx(JoinPoint joinPoint){&#xA;        joinPoint.getTarget();                # 获取目标对象&#xA;        joinPoint.getSignature();        # 获取当前连接点的方法信息&#xA;        joinPoint.getArgs()[0];                # 获取当前连接点的第一个参数&#xA;        ..&#xA;    }&#xA;    public Goods Yxx(ProceedingJoinPoint joinPoint){&#xA;        Object object = joinPoint.proceed();        # 得到连接点的返回值&#xA;        ..&#xA;        return goods;                # 本切面返回的数据会作为切点返回的数据返回给调用它的函数&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;dao&#34;&gt;&#xA;  dao&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dao&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    1.xml文件中&#xA;    &amp;lt;!-- 配置C3P0连接池 --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;comboPooledDataSourceID&amp;quot; class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/spring&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;initialPoolSize&amp;quot; value=&amp;quot;60&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;acquireIncrement&amp;quot; value=&amp;quot;5&amp;quot;/&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;&#xA;        &amp;lt;!-- 配置JdbcTemplate --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;jdbcTemplateID&amp;quot; class=&amp;quot;org.springframework.jdbc.core.JdbcTemplate&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;comboPooledDataSourceID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;&#xA;        &amp;lt;!-- 配置UserDao --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;userDaoID&amp;quot; class=&amp;quot;dao.UserDao&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;jt&amp;quot; ref=&amp;quot;jdbcTemplateID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;    2.Dao中&#xA;        private JdbcTemplate jt;&#xA;        addUser()&#xA;            String sql = &amp;quot;&amp;quot;;&#xA;            Object [] params = {user.getUsername(),user.getPassword()}&#xA;            jt.update(sql,params);&#xA;            批量：&#xA;            for(int i = 0; i &amp;lt; ids.length; i++){&#xA;                sqls[i] = &amp;quot;&amp;quot;;&#xA;            }&#xA;            jt.batchUpdate(sqls);&#xA;            查询一个&#xA;        return (User)jt.queryForObject(sql,params,new RowMapper(){&#xA;                public Object mapRow(ResultSet rs,int rowNum){          # rs是查询出来的结果集,rowNum是结果集的行号,从0开始&#xA;                    Integer id = rs.getInt(&amp;quot;id&amp;quot;);&#xA;                    User user = new User(id);&#xA;                    return user;&#xA;                }&#xA;                });&#xA;            查询多个                # query方法把RowMapper帮助类中返回的user分别加入到list中，返回一个list&#xA;            list = jt.query(sql,new RowMapper(){&#xA;                    public Object mapRow()&#xA;                        ..&#xA;                        return bean;&#xA;                })&#xA;            分页&#xA;                            String sql = &amp;quot;select * from users limit ?,?&amp;quot;;&#xA;                            Object[] params = {0,3};&#xA;            jt.query(sql,params,new RowMapper(){&#xA;            记录&#xA;            jt.queryForInt(sql);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事务&#34;&gt;&#xA;  事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;TransactionInterceptor&#xA;    transactionManager          # 指定事务治理类&#xA;    transactionAttributes       # key方法名 value事务属性&#xA;注解&#xA;    @Transactional(propagation = Propagation.REQUIRED)&#xA;手写      # TransactionDefinition&#xA;    Public class BankServiceImpl implements BancService{&#xA;        Private BanckDao bankDao;&#xA;        private TransactionDefinition txDefinition;&#xA;        private PlatformTransactionManager txManager;&#xA;        public boolean transfer(Long fromId, Long toId, double amount) {&#xA;            TransactionStatus txStatus = txManager.getTransaction(txDefinition);&#xA;            boolean result = false;&#xA;            try {&#xA;                result = bankDao.transfer(fromId, toId, amount);&#xA;                txManager.commit(txStatus);&#xA;            } catch (Exception e) {&#xA;                result = false;&#xA;                txManager.rollback(txStatus);&#xA;                System.out.println(&amp;quot;Transfer Error!&amp;quot;);&#xA;            }&#xA;            return result;&#xA;        }&#xA;    }&#xA;手写      # TransactionTemplate&#xA;    public class BankServiceImpl implements BankService {&#xA;        private BankDao bankDao;&#xA;        private TransactionTemplate transactionTemplate;&#xA;        public boolean transfer(final Long fromId, final Long toId, final double amount) {&#xA;            return (Boolean) transactionTemplate.execute(new TransactionCallback(){&#xA;            public Object doInTransaction(TransactionStatus status) {&#xA;                Object result;&#xA;                try {&#xA;                    result = bankDao.transfer(fromId, toId, amount);&#xA;                } catch (Exception e) {&#xA;                    status.setRollbackOnly();&#xA;                    result = false;&#xA;                    System.out.println(&amp;quot;Transfer Error!&amp;quot;);&#xA;                }&#xA;                return result;&#xA;            }&#xA;            });&#xA;        }&#xA;    }&#xA;配置      # TransactionInterceptor&#xA;    &amp;lt;bean id=&amp;quot;transactionInterceptor&amp;quot; class=&amp;quot;org.springframework.transaction.interceptor.TransactionInterceptor&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;transactionManager&amp;quot; ref=&amp;quot;transactionManager&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;transactionAttributes&amp;quot;&amp;gt;&#xA;            &amp;lt;props&amp;gt;&#xA;                &amp;lt;prop key=&amp;quot;transfer&amp;quot;&amp;gt;PROPAGATION_REQUIRED&amp;lt;/prop&amp;gt;&#xA;            &amp;lt;/props&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;bankServiceTarget&amp;quot; class=&amp;quot;footmark.spring.core.tx.declare.origin.BankServiceImpl&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;bankDao&amp;quot; ref=&amp;quot;bankDao&amp;quot;/&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;bankService&amp;quot; class=&amp;quot;org.springframework.aop.framework.ProxyFactoryBean&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;target&amp;quot; ref=&amp;quot;bankServiceTarget&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;interceptorNames&amp;quot;&amp;gt;&#xA;            &amp;lt;list&amp;gt;&#xA;                &amp;lt;idref bean=&amp;quot;transactionInterceptor&amp;quot;/&amp;gt;&#xA;            &amp;lt;/list&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;配置      # TransactionProxyFactoryBean&#xA;    &amp;lt;bean id=&amp;quot;bankServiceTarget&amp;quot; class=&amp;quot;footmark.spring.core.tx.declare.classic.BankServiceImpl&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;bankDao&amp;quot; ref=&amp;quot;bankDao&amp;quot;/&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;bankService&amp;quot; class=&amp;quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;target&amp;quot; ref=&amp;quot;bankServiceTarget&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;transactionManager&amp;quot; ref=&amp;quot;transactionManager&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;transactionAttributes&amp;quot;&amp;gt;&#xA;            &amp;lt;props&amp;gt;&#xA;                &amp;lt;prop key=&amp;quot;transfer&amp;quot;&amp;gt;PROPAGATION_REQUIRED&amp;lt;/prop&amp;gt;&#xA;            &amp;lt;/props&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;配置      # tx空间&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;&#xA;        xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&#xA;        xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;&#xA;        xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;&#xA;        xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;&#xA;        xsi:schemaLocation=&amp;quot;&#xA;            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&#xA;            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&#xA;            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&#xA;            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;!--配置c3p0连接池--&amp;gt;&#xA;    &amp;lt;!-- 配置JdbcTemplate类 --&amp;gt;&#xA;    &amp;lt;!-- 配置Dao --&amp;gt;&#xA;    &amp;lt;!-- 配置jdbc事务管理器 --&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;dataSourceTransactionManagerID&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;comboPooledDataSourceID&amp;quot;/&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;&#xA;    &amp;lt;!-- 配置事务增强(服务对象) --&amp;gt;&#xA;    &amp;lt;tx:advice id=&amp;quot;txAdvice&amp;quot; transaction-manager=&amp;quot;dataSourceTransactionManagerID&amp;quot;&amp;gt;&#xA;    &amp;lt;tx:attribute&amp;gt;&#xA;        &amp;lt;tx:method name=&amp;quot;addUsers&amp;quot;                      # 可以用通配符&amp;quot;*users&amp;quot;&#xA;            propagation=&amp;quot;required&amp;quot;                  # 传播行为：事务开始、结束的时间。required 保证方法执行时事务已开始，事务开始时不创建，没有开始时创建&#xA;            isolation=&amp;quot;default&amp;quot;                     # 隔离级别&#xA;            timeout=&amp;quot;-1&amp;quot;                            # 事务超时,-1代表不超时，用数据库底层的配置&#xA;            rollback-for:&amp;quot;java.lang.Exception&amp;quot;      # 何时回滚&#xA;            read-only=&amp;quot;false&amp;quot;                       # 不只读&#xA;                # name 方法名的匹配模式&#xA;                # required : 外部存在事务，则加入外部事务，不存在则新建事务&#xA;                # requires_new : 总是新建事务&#xA;                # mandatory : 外部必须存在事务&#xA;                # never : 外部不能存在事务&#xA;                # supports : 外部存在则加入，不存在则不以事务方式运行&#xA;                # not_supported : 总是非事务&#xA;                # nested : 外部存在事务，嵌套执行，不存在则新建&#xA;                # no-rollback-for 以逗号分隔异常，这些异常不会导致事务回滚&#xA;                # rollback-for 导致事务回滚的异常&#xA;        /&amp;gt;&#xA;    &amp;lt;tx:attribute&amp;gt;&#xA;&#xA;    &amp;lt;!-- 配置AOP --&amp;gt;&#xA;    &amp;lt;aop:config&amp;gt;&#xA;        &amp;lt;aop:pointcut id=&amp;quot;xxxx&amp;quot; expression=&amp;quot;execution(public void *Users(..))&amp;quot;/&amp;gt;&#xA;        ##&#xA;        任意公共方法的执行：&#xA;        execution(public * *(..))&#xA;        任何一个以“set”开始的方法的执行：&#xA;        execution(* set*(..))&#xA;        AccountService 接口的任意方法的执行：&#xA;        execution(* com.xyz.service.AccountService.*(..))&#xA;        定义在service包里的任意方法的执行：&#xA;        execution(* com.xyz.service.*.*(..))&#xA;        定义在service包和所有子包里的任意类的任意方法的执行：&#xA;        execution(* com.xyz.service..*.*(..))&#xA;        定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：&#xA;        execution(* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))&amp;quot;)&#xA;&#xA;        &amp;lt;!-- 将事务代码切入点addUser()方法中，从而产生事务 --&amp;gt;&#xA;        &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot; pointcut-ref=&amp;quot;xxxx&amp;quot;/&amp;gt;&#xA;    &amp;lt;/aop:config&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-mybatis&#34;&gt;&#xA;  spring mybatis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mybatis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基础&#xA;    #与$&#xA;        #相当于解析成引号, 防止sql注入&#xA;        $变量引用, 不能防止sql注入，用于传入表名之类&#xA;    特点&#xA;        sql易维护，传参方便&#xA;        orm&#xA;    Mapper接口&#xA;        方法名与配置id相同&#xA;        输入输出参数类型对应定义的parameterType类型和resultType类型&#xA;        类路径是配置的namespace&#xA;    缓存&#xA;        # 基于PerpetualCache的HashMap&#xA;        一级缓存&#xA;            存在本地&#xA;            作用域为session, session flush后清空&#xA;        二级缓存&#xA;            可定义存储服务&#xA;            作用域为namespace&#xA;            配置&#xA;                &amp;lt;cache/&amp;gt;&#xA;                    readOnly=&amp;quot;true&amp;quot; 时，缓存实例单例，false时返回缓存拷贝&#xA;        更新&#xA;            create, update, delete后，作用域下所有select缓存clear&#xA;与hibernate区别&#xA;    都通过SessionFactoryBuilder从配置生成SessionFactory, 再生成Session&#xA;    都支持jdbc和jta&#xA;    mybatis可细致优化sql, hibernate移植性好&#xA;    mybatis学习成本低&#xA;    mybatis本身缓存不好，hibernate对象维护和缓存好&#xA;    hibernate dao层封开发简单(不用维护映射)，crud方便&#xA;使用&#xA;    编程&#xA;        创建SqlSessionFactory&#xA;        创建SqlSession&#xA;        执行数据库操作&#xA;        session.commit()&#xA;        session.close()&#xA;    导入ibatis jar包&#xA;    配置文件&#xA;        SqlMap.properties        # 属性名可以修改&#xA;            driver=oracle.jdbc.driver.OracleDriver&#xA;            url=jdbc:oracle:thin:@127.0.0.1:1521:orcl&#xA;            username=root&#xA;            password=root&#xA;        SqlMapConfig.xml                # 总配置文件&#xA;            &amp;lt;sqlMapConfig&amp;gt;&#xA;                &amp;lt;properties recource=&amp;quot;SqlMap.properties&amp;quot;/&amp;gt;&#xA;                &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;&amp;gt;&#xA;                        &amp;lt;dataSource type=&amp;quot;SIMPLE&amp;quot;&amp;gt;&#xA;                            &amp;lt;property value=&amp;quot;${driver}&amp;quot; name=&amp;quot;JDBC.Driver&amp;quot;/&amp;gt;&#xA;                            &amp;lt;property value=&amp;quot;${url}&amp;quot; name=&amp;quot;JDBC.ConnectionURL&amp;quot;/&amp;gt;&#xA;                            &amp;lt;property value=&amp;quot;${username}&amp;quot; name=&amp;quot;JDBC.Username&amp;quot;/&amp;gt;&#xA;                            &amp;lt;property value=&amp;quot;${password}&amp;quot; name=&amp;quot;JDBC.Password&amp;quot;/&amp;gt;&#xA;                        &amp;lt;/dataSource&amp;gt;&#xA;                    &amp;lt;sqlMap resource=&amp;quot;Student.xml&amp;quot;/&amp;gt;&#xA;                &amp;lt;/transactionManager&amp;gt;&#xA;            &amp;lt;/sqlMapConfig&amp;gt;&#xA;        Student.xml                                # 映射xml文件&#xA;            &amp;lt;sqlMap&amp;gt;&#xA;                &amp;lt;typeAlias alias=&amp;quot;Student&amp;quot; type=&amp;quot;com.Student&amp;quot;/&amp;gt;&#xA;                    &amp;lt;select id=&amp;quot;selectAllStudent&amp;quot; resultClass=&amp;quot;Student&amp;quot;&amp;gt;&#xA;                        select * from Student&#xA;                    &amp;lt;/select&amp;gt;&#xA;                &amp;lt;/typeAlias&amp;gt;&#xA;            &amp;lt;/sqlMap&amp;gt;&#xA;        辅助类Student.java                 # 要求有无参构造方法&#xA;            private sid = 0;&#xA;            private String name = null;&#xA;            private String major = null;&#xA;            private Date birth = null;&#xA;            private float score = 0;&#xA;    Xxx.java&#xA;        private static SqlMapClient sqlMapClient = null;&#xA;        static{&#xA;            Reader reader = Resources.getResourceAsReader(总配置文件);&#xA;            sqlMapClient = SqlMapClientBuilder.buildSqlMapClient(reader);&#xA;            reader.close();&#xA;        }&#xA;        public List&amp;lt;Student&amp;gt; queryAllStudent(){&#xA;            List&amp;lt;Student&amp;gt; studentList = sqlMapClient.queryForList(&amp;quot;selectAllStudent&amp;quot;);&#xA;            return studentList;&#xA;        }&#xA;        @Test&#xA;        public void testHere(){&#xA;            for(Student student: this.queryAllStudent()){&#xA;                System.out.println(student.getName);&#xA;            }&#xA;        }&#xA;配置&#xA;    sqlMapConfig.xml&#xA;        mybatis加载属性顺序&#xA;            properties中property中的属性&#xA;            properties中resource或url中的属性&#xA;            parameterType中传递一属性&#xA;                # properties中配的属性会影响到mapper.xml中${}的sql拼接，因为都是ognl&#xA;        配置标签&#xA;            properties&#xA;            settings&#xA;                # ibatis有性能优化的参数，mybatis会自动调优，不用设置了&#xA;            typeAliases&#xA;                # 针对parameterType和resultType指定的类型定义别名&#xA;                # java.lang.Integer在mybatis中默认别名为int&#xA;            typeHandlers&#xA;                # 类型处理器，jdbc类型和java类型的转换&#xA;                ## 一般mybatis提供的类型处理器够用了&#xA;            objectFactory&#xA;            plugins&#xA;            environments&#xA;            mappers&#xA;    mapper.xml&#xA;        内容&#xA;            #{}接收简单类型, pojo的ognl属性注入&#xA;            ${}是字符串的拼接&#xA;&#xA;        SELECT * FROM USER WHERE id=#{id}&#xA;        SELECT * FROM USER WHERE username LIKE &#39;%${value}%&#39;&#xA;            # sql 注入&#xA;    输入输出映射&#xA;        parameterType&#xA;            java类型&#xA;            hashmap&#xA;                # #{key}来取value&#xA;            pojo&#xA;            包装类型&#xA;        resultType&#xA;                # 指定一条数据的类型，在java方法的返回类型中list或pojo来体现数据条数&#xA;                # mybatis判断mapper代理中使用selectOne或者selectType&#xA;            pojo&#xA;                # 返回字段可以是别名，但要与pojo中的属性名相同&#xA;                ## 如果有记录返回但没有pojo中匹配的属性名对应，则直接不创建该对象&#xA;            java类型&#xA;                # 在返回结果只有一行一列时，可以是简单类型&#xA;            hashmap&#xA;                # key是字段的字，value是字段的值&#xA;                ## 多条数据时，list里面存hashmap&#xA;        resultMap&#xA;            # 查询出来的字段名与pojo属性名不一致&#xA;            定义resultMap&#xA;            使用resultMap&#xA;    动态sql&#xA;        &amp;lt;where&amp;gt;&#xA;        &amp;lt;if&amp;gt;&#xA;&#xA;        sql片段&amp;lt;sql&amp;gt;&#xA;&#xA;        &amp;lt;foreach&amp;gt;&#xA;    高级映射&#xA;    缓存&#xA;    逆向&#xA;        要求&#xA;            1. mapper.xml中namespace 写mapper接口&#xA;                &amp;lt;mapper namespace=&amp;quot;com.otr.tea.mapper.UserMapper&amp;quot;&amp;gt;&#xA;            2. mapper.java中方法名与mapper.xml的statementid一致&#xA;            3. mapper.java中方法的输入类型与mapper.xml中的parameterType一致&#xA;                # 由于传入的参数只有一个，所以用包装类型的pojo来传多个参数，不利于业务层的可扩展性&#xA;            4. mapper.java中方法的返回类型与mapper.xml中的resultType一致&#xA;        机制&#xA;            如果Mapper中返回类型为pojo, 则调用selectOne, 如果是List, 则调用selectList&#xA;api&#xA;    sqlSessionFactory&#xA;    sqlSession                        # 是线程不安全的，因为它的类中有数据和属性&#xA;                                    ＃ 是多例的，在方法中局部变量使用&#xA;        Executor                # 执行器操作数据库（基本执行器，缓存执行器）&#xA;    mapped statement                # 封装sql语句、输入参数、输出结果类型&#xA;&#xA;    例子&#xA;        InputStream is = Resources.getResourceAsStream(&amp;quot;SqlMapConfig.xml&amp;quot;);&#xA;            # Resources是mybatis提供的资源加载类&#xA;        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);&#xA;        SqlSession sqlSession = factory.openSession();&#xA;        User user = sqlSession.selectOne(&amp;quot;test.findUserById&amp;quot;, 1);&#xA;            ＃ selectList()&#xA;            # insert(&amp;quot;test.insertUser&amp;quot;, user)&#xA;            ## sqlSession.commit();&#xA;            ## user.getId() 会主键返回&#xA;            ### mysql中LAST_INSERT_ID()在insert语句后接着执行可以得到刚刚自成的id&#xA;        sqlSession.close();&#xA;案例&#xA;    返回id&#xA;        mysql&#xA;            &amp;lt;insert id=&amp;quot;insert&amp;quot; parameterType=&amp;quot;com.test.User&amp;quot; keyProperty=&amp;quot;userId&amp;quot; useGeneratedKeys=&amp;quot;true&amp;quot; &amp;gt;&#xA;        oracle&#xA;            &amp;lt;insert id=&amp;quot;insert&amp;quot; parameterType=&amp;quot;com.test.User&amp;quot;&amp;gt;&#xA;                &amp;lt;selectKey resultType=&amp;quot;INTEGER&amp;quot; order=&amp;quot;BEFORE&amp;quot; keyProperty=&amp;quot;userId&amp;quot;&amp;gt;&#xA;                    SELECT SEQ_USER.NEXTVAL as userId from DUAL&#xA;                &amp;lt;/selectKey&amp;gt;&#xA;&#xA;                insert into user (user_id, user_name, modified, state)&#xA;                values (#{userId,jdbcType=INTEGER}, #{userName,jdbcType=VARCHAR},&#xA;                #{modified,jdbcType=TIMESTAMP}, #{state,jdbcType=INTEGER})&#xA;            &amp;lt;/insert&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-struts2&#34;&gt;&#xA;  spring struts2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-struts2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    tomcat启动日志：没有整合时不能加载struts-plugin.xml（spring-struts-plugin.jar包中的配置文件 ）&#xA;    struts中struts-default中常量配置加载com.opensymphony.xword2.ObjectFactory类作为默认struts创建action的类&#xA;    加载后struts-plugin.xml 中 修改了常量为struts-spring-plugin中的类来创建struts的类，也就是整个struts2创建action类的类被更改了&#xA;&#xA;整合&#xA;    jar包 struts2/lib/struts2-spring-plugin-2.3.1.1.jar                        # 为了在struts的xml配置文件中的class找spring 的容器&#xA;    配置web.xml   # \samples\petclinic\war\WEB-INF\web.xml目录下有示例&#xA;                                            &#xA;        &amp;lt;listener&amp;gt;          # 监听器，web程序启动时加载spring bean&#xA;        &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&#xA;        &amp;lt;context-param&amp;gt;     # （可选）配置spring 配置文件的路径，&#xA;                            ## 从示例文件中查到，默认文件目录是/WEB-INF/applicationContext.xml(我们示例文件也是从源码/simple项目下的这个开头的文件中找的)&#xA;            &amp;lt;param-name&amp;gt;contextConfigLocation&#xA;            &amp;lt;param-value&amp;gt;/WEB-INF/classes/struts2/xxx.xml&#xA;    UserAction 中    # 不用值栈是因为通用性&#xA;    spring.xml        # action类由spring 产生&#xA;        &amp;lt;bean id=&amp;quot;userActionID&amp;quot; class=&amp;quot;&amp;quot; scope=&amp;quot;prototype&amp;quot;/&amp;gt;&#xA;    struts2的配置文件中，替换class属性为spring beanid，其它一样&#xA;总结&#xA;    spring的web配置是由下向上，一个个依赖注入的过程&#xA;        comboPooledDataSourceID -&amp;gt;&#xA;        localSessionFactoryBeanID -&amp;gt;&#xA;        hibernateTemplateID -&amp;gt;&#xA;        SysStaffDaoID -&amp;gt;&#xA;        SysStaffServiceID -&amp;gt;&#xA;        SysStaffActionID -&amp;gt;&#xA;        struts.xml配置中的&amp;lt;action class=&amp;quot;SysStaffActionID&amp;quot;&amp;gt;&#xA;    最后给Dao中的方法加入事务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-mvc&#34;&gt;&#xA;  spring mvc&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    DispatchServlet doService()捕获请求, doDispatch()用HandlerMapping映射url得到HandlerExcutionChain(执行链, 包括拦截器和handler)&#xA;    handler getHandlerAdapter得到适配器来处理handler, 返回ModelAndView&#xA;        # HandlerAdapter分三类: Servlet、Controller, HttpRequest&#xA;    DispatchServlet用ViewResolver(视图解析器)解析ModelAndView成View&#xA;        # ModelAndView是逻辑视图，DispatchServlet转化成视图View&#xA;    返回View&#xA;与struts2区别&#xA;    spring mvc方法对应请求, struts2是类&#xA;    spring mvc请求是方法调用，struts2创建Action实例&#xA;    spring mvc用aop处理请求，struts2用独有的拦截器(interceptor)&#xA;    spring mvc入口是servlet, struts2入口是filter&#xA;    spring mvc集成ajax(@ResponseBody), struts2需要插件&#xA;    spring mvc验证支持JSR303, struts2不支持&#xA;    spring mvc与spring无缝&#xA;    spring mvc不需要配置&#xA;注解&#xA;    @RequestMapping             # url映射&#xA;    @RequestBody                # 转换参数到对象&#xA;    @ResponseBody               # 返回对象转json&#xA;&#xA;    开启注解处理器&#xA;        springmvc.xml&#xA;            &amp;lt;mvc:annotation-driven&amp;gt;&#xA;乱码问题&#xA;    post&#xA;        web.xml中配置CharacterEncodingFilter&#xA;    get&#xA;        tomcat配置文件修改项目编码&#xA;        new String(Request.getParameter(&amp;quot;a&amp;quot;).getBytes(&amp;quot;ISO8859-1&amp;quot;), &amp;quot;utf-8&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;quartz定时器&#34;&gt;&#xA;  quartz:定时器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#quartz%e5%ae%9a%e6%97%b6%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;执行：ApplicationContext类加载后自动执行&#xA;导包：quartz-all.jar包 与  commons-collections.jar包 与 commons-logging.jar&#xA;xml配置：&#xA;    &amp;lt;!-- 任务类 ,其中有个叫execute的方法--&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;myTaskID&amp;quot; class=&amp;quot;jee.quartz.MyTask&amp;quot;/&amp;gt;&#xA;&#xA;    &amp;lt;!-- spring提供专用于定时任务类 --&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;methodInvokingJobDetailFactoryBeanID&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 要定时执行的实例的spring bean id --&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;targetObject&amp;quot;&amp;gt;&#xA;                &amp;lt;ref bean=&amp;quot;myTaskID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;!-- spring bean中定时执行的方法 --&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;targetMethod&amp;quot;&amp;gt;&#xA;                &amp;lt;value&amp;gt;execute&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;!-- spring提供专用于任务频率类，给上面的任务指定频率 --&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;cronTriggerBeanID&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.CronTriggerBean&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;jobDetail&amp;quot;&amp;gt;&#xA;                &amp;lt;ref bean=&amp;quot;methodInvokingJobDetailFactoryBeanID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;cronExpression&amp;quot;&amp;gt;&#xA;                &amp;lt;value&amp;gt;0 0/1 * * * ?&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;!-- spring提供的专用于任务频率工厂类 --&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;schedulerFactoryBeanID&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;triggers&amp;quot;&amp;gt;&#xA;            &amp;lt;ref bean=&amp;quot;cronTriggerBeanID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;任务频率cronTriggerBean的配置：&#xA;    cron解析器:&#xA;        反斜线（/）字符表示增量值。例如，在秒字段中“5/15”代表从第 5 秒开始，每 15 秒一次。&#xA;        问号（?）字符和字母 L 字符只有在月内日期和周内日期字段中可用。问号表示这个字段不包含&#xA;        具体值。&#xA;        所以，如果指定月内日期，可以在周内日期字段中插入“?”，表示周内日期值无关紧要。字母&#xA;        L 字符是 last 的缩写。放在月内日期字段中，表示安排在当月最后一天执行。在周内日期字&#xA;        段中，如果“L”单独存在，就等于“7”，否则代表当月内周内日期的最后一个实例。所以“0L”&#xA;        表示安排在当月的最后一个星期日执行。&#xA;        在月内日期字段中的字母（W）字符把执行安排在最靠近指定值的工作日。把“1W”放在月内&#xA;        日期字段中，表示把执行安排在当月的第一个工作日内。&#xA;        井号（#）字符为给定月份指定具体的工作日实例。把“MON#2”放在周内日期字段中，表示把任&#xA;        务安排在当月的第二个星期一。&#xA;        星号（*）字符是通配字符，表示该字段可以接受任何可能的值。&#xA;    顺序：秒 分 时 日 月 周 年（年可以忽略）&#xA;    例子&#xA;        0 0 10,14,16 * * ?                  每天上午10点，下午2点，4点&#xA;        0 0/30 9-17 * * ?            朝九晚五工作时间内每半小时&#xA;        0 0 12 ? * WED                          表示每个星期三中午12点&#xA;        0 0 12 * * ?                          每天中午12点触发&#xA;        0 15 10 ? * *                          每天上午10:15触发&#xA;        0 15 10 * * ?                          每天上午10:15触发&#xA;        0 15 10 * * ? *                  每天上午10:15触发&#xA;        0 15 10 * * ? 2013          2013年的每天上午10:15触发&#xA;        0 * 14 * * ?                          在每天下午2点到下午2:59期间的每1分钟触发&#xA;        0 0/5 14 * * ?                          在每天下午2点到下午2:55期间的每5分钟触发&#xA;        0 0/5 14,18 * * ?                  在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发&#xA;        0 0-5 14 * * ?                          在每天下午2点到下午2:05期间的每1分钟触发&#xA;        0 10,44 14 ? 3 WED                  每年三月的星期三的下午2:10和2:44触发&#xA;        0 15 10 ? * MON-FRI                周一至周五的上午10:15触发&#xA;        0 15 10 15 * ?                          每月15日上午10:15触发&#xA;        0 15 10 L * ?                            每月最后一日的上午10:15触发&#xA;        0 15 10 ? * 6L                    每月的最后一个星期五上午10:15触发&#xA;        0 15 10 ? * 6L 2014-2018        2014年至2018年的每月的最后一个星期五上午10:15触发&#xA;        0 15 10 ? * 6#3                        每月的第三个星期五上午10:15触发&#xA;        0/1 * * * * ?                        每秒钟触发一次&#xA;        0 0/1 * * * ?                        每分钟解发一次&#xA;        0 0 0/1 * * ?                        每小时解发一次&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;远程调用&#34;&gt;&#xA;  远程调用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9c%e7%a8%8b%e8%b0%83%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# rmi:remote message invoke&#xA;服务端&#xA;    1.自定义接口IServer,自定义抽象方法int rax(int)&#xA;    2.写接口实现类ServerImpl&#xA;    3.配置spring.xml 文件&#xA;        &amp;lt;!-- 服务端实现类 --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;serverImplID&amp;quot; class=&amp;quot;jee.server.ServerImpl&amp;quot;/&amp;gt;&#xA;        &amp;lt;!-- spring提供的专用于RMI服务端注册器 --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;rmiServiceExporterID&amp;quot; class=&amp;quot;org.springframework.remoting.rmi.RmiServiceExporter&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;serviceInterface&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;jee.server.IServer&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;service&amp;quot;&amp;gt;&#xA;                    &amp;lt;ref bean=&amp;quot;serverImplID&amp;quot;/&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;serviceName&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;XXXX&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;客户端&#xA;    配置spring.xml 文件&#xA;        &amp;lt;!-- spring提供专用于RMI远程服务代理工厂类 --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;rmiProxyFactoryBeanID&amp;quot; class=&amp;quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- 协议名://远程提供服务的IP地址:提供服务的端口/提供服务的名称 --&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;serviceUrl&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;rmi://127.0.0.1:1099/XXXX&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;serviceInterface&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;jee.client.IServer&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;执行：&#xA;    服务端加载 ApplicationContext类&#xA;    客户端&#xA;        加载 ApplicationContext类 ac&#xA;        ac.getBean方法中得到RmiProxyFactoryBean实际类型（可变类型）的实例，强转成服务端自定义的接口IServer的实现类（实现类由服务器决定）&#xA;        执行IServer实现类中的方法int rax(int)，实现了远程调用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;websocket&#34;&gt;&#xA;  websocket&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#websocket&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;handler&#xA;    extends TextWebSocketHandler&#xA;        @Override&#xA;        handleTextMessge()                      # 处理client.send()的数据&#xA;&#xA;        @Override&#xA;        afterConnectionEstablished(WebSocketSession)                    # 连接事件&#xA;&#xA;        @Override&#xA;        handleTransportError()                  # 出错事件&#xA;&#xA;        @Override&#xA;        afterConnectionClosed()                 # 断开事件&#xA;&#xA;        @Override&#xA;        supportsPartialMessages()               # 并行处理&#xA;config&#xA;    @EnableWebSocket&#xA;    implements WebSocketConfigurer&#xA;        @Override&#xA;        registerWebSocketHandlers()&#xA;            registry.addHandler(handler, &amp;quot;/ws&amp;quot;)                         # 路由handler&#xA;client&#xA;    extends WebSocketClient&#xA;        constructor(uri)&#xA;            super(new URI(uri))&#xA;&#xA;        @Override&#xA;        onOpen()&#xA;&#xA;        @Override&#xA;        onClose()&#xA;&#xA;        @Override&#xA;        onError()&#xA;&#xA;        @Override&#xA;        onMessage()&#xA;service&#xA;    init()&#xA;        client = new Client(&amp;quot;ws://127.0.0.1:8001/ws&amp;quot;)&#xA;        client.connectBlocking()&#xA;    send()&#xA;        while(!client.getReadyState().equals(ReadyState.OPEN)){&#xA;            log(&amp;quot;connecting&amp;quot;)&#xA;        }&#xA;        client.send(&amp;quot;&amp;quot;)&#xA;runner&#xA;    implements ApplicationRunner&#xA;        run()&#xA;            service.init()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-boot&#34;&gt;&#xA;  spring boot&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    减少配置, 习惯大于配置&#xA;    支持groovy, gradle&#xA;命令&#xA;    java -jar xxx.jar&#xA;        --server.port=8080                                      # --后内容，相当于application.yml设置&#xA;        --spring.profiles.active=two                            # 选择applicaton-two.yml配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;基础文件&#34;&gt;&#xA;  基础文件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;目录&#xA;    src&#xA;        main&#xA;            java&#xA;                com.outrun&#xA;                    XxxApplication&#xA;            resources&#xA;                static/&#xA;                templates/&#xA;                application.properties&#xA;                application.yml&#xA;            webapp&#xA;                WEB-INF&#xA;        test&#xA;            java&#xA;                com.outrun&#xA;                    XxxApplicationTests&#xA;    pom.xml&#xA;XxxApplication.java                                     # 程序入口&#xA;    @SpringBootApplication                              # 类，组合@Configuration, @EnableAutoConfiguration, @ComponentScan&#xA;        @EnableAutoConfiguration根据jar包依赖自动配置&#xA;        扫描该注解同级下级包的Bean&#xA;application.yml                                         # application.yml或application.properties, 放在src/main/resources或config目录下&#xA;pom.xml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;区分环境&#xA;    application-{profile}.properties                                    # profile比如是dev, test, prod&#xA;    设置spring.profiles.active=dev来区分&#xA;加载顺序                                                                 # 为了外部人员维护，可覆盖定义&#xA;    命令行&#xA;    SPRING_APPLICATION_JSON环境变量, json格式&#xA;    java:comp/env的JNDI属性&#xA;    java系统属性                                                         # System.getProperties()查看&#xA;    系统环境变量&#xA;    random.*配置的随机属性&#xA;    jar包外文件名, 如application-{profile}.properties&#xA;    jar包内文件名&#xA;    @Configuration注解类中，@PropertySource修改的属性&#xA;    SpringApplication.setDefaultProperties定义的内容&#xA;application.yml&#xA;    ---                                                 # ---分隔多个配置，这里相当于建立了application-two.yml文件&#xA;    spring:&#xA;        profiles: two&#xA;    ---&#xA;    spring:&#xA;        profiles&#xA;            active: dev                                 # 配置环境, 加载applicaton-dev.yml&#xA;        application:&#xA;            name: app1&#xA;pom.xml&#xA;    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;                          # 不用war包部署, 嵌入了tomcat, jar可服务&#xA;    &amp;lt;parent&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;             # 提供spring boot基础依赖和默认配置&#xA;        &amp;lt;relativePath/&amp;gt;                                 # 从仓库查找parent&#xA;    &amp;lt;/parent&amp;gt;&#xA;    &amp;lt;properties&amp;gt;&#xA;        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;&#xA;        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;&#xA;        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;&#xA;    &amp;lt;/properties&amp;gt;&#xA;    &amp;lt;dependencies&amp;gt;&#xA;    &amp;lt;/dependencies&amp;gt;&#xA;    &amp;lt;build&amp;gt;&#xA;        &amp;lt;plugins&amp;gt;&#xA;            &amp;lt;plugin&amp;gt;&#xA;                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;       # 方便启动停止应用, 如mvn spring-boot:run&#xA;            &amp;lt;/plugin&amp;gt;&#xA;        &amp;lt;/plugins&amp;gt;&#xA;    &amp;lt;/build&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;注解-1&#34;&gt;&#xA;  注解&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e8%a7%a3-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;@SpringBootApplication                      # spring boot 启动类&#xA;    组合了@Configuration, @EnableAutoConfiguration, @ComponentScan&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类&#34;&gt;&#xA;  类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ApplicationRunner                           # 继承该类，注解@Component, 随容器启动运行&#xA;    run()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;maven&#34;&gt;&#xA;  maven&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#maven&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;命令&#xA;    mvn spring-boot:run&#xA;pom.xml&#xA;    &amp;lt;plugin&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;       # 方便启动停止应用, 如mvn spring-boot:run&#xA;    &amp;lt;/plugin&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;组件&#34;&gt;&#xA;  组件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;starter POMs            # spring-boot-starter开头的组件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;子域&#34;&gt;&#xA;  子域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%90%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;namedcontextfactory&#34;&gt;&#xA;  NamedContextFactory&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#namedcontextfactory&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Spec1 implements NamedContextFactory.Specification {&#xA;    @Override&#xA;    public String getName(){}&#xA;    @Override&#xA;    public Class&amp;lt;?&amp;gt;[] getConfiguration(){}&#xA;}&#xA;public class MyFactory extends NamedContextFactory&amp;lt;Specification1&amp;gt; {&#xA;    public MyFactory(Class&amp;lt;?&amp;gt; clazz) {&#xA;        super(clazz, &amp;quot;my&amp;quot;, &amp;quot;my.name&amp;quot;)&#xA;    }&#xA;}&#xA;@Configuration&#xA;public class Config0 {&#xA;    @Bean&#xA;    Bean0 getBean(){&#xA;        return new Bean0()&#xA;    }&#xA;}&#xA;&#xA;parent = new AnnotationConfigApplicationContext()&#xA;parent.register(Config0.class)&#xA;parent.refresh()&#xA;factory = new MyFactory(Config00.class)&#xA;factory.setApplicationContext(parent) &#xA;&#xA;spec1 = new Spec1(&amp;quot;1&amp;quot;, new Class[]{Config1.class})&#xA;factory.setConfigurations(List.of(spec1))&#xA;factory.getInstance(&amp;quot;1&amp;quot;, Bean0.class)   // 子域共享&#xA;factory.getInstance(&amp;quot;1&amp;quot;, Bean00.class)  // 子域复制&#xA;factory.getInstance(&amp;quot;1&amp;quot;, Bean1.class)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring&#34;&gt;&#xA;  spring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;配置&#xA;    随机数用${random}&#xA;        ${random.value} 字符串&#xA;        ${random.int} int&#xA;        ${random.long} long&#xA;        ${random.int(10)} 10以内int&#xA;        ${random.int[10,20]} 10到20 int&#xA;    pom.xml&#xA;        &amp;lt;dependency&amp;gt;&#xA;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;            &amp;lt;artifactId&amp;gt;spring-boot-configuration-processor&amp;lt;/artifactId&amp;gt;&#xA;            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;&#xA;        &amp;lt;/dependency&amp;gt;&#xA;    application.yml&#xA;        aa&#xA;            bb: 1                                           # 可用properties类管理属性&#xA;        xxx: 1                                              # 自定义value&#xA;            配置文件中用&amp;quot;${xxx}&amp;quot;引用&#xA;            类中用@Value(&amp;quot;${xxx}&amp;quot;)注入到属性&#xA;            SpEL中用&amp;quot;#{xxx}&amp;quot;引用&#xA;    AaProperties.java&#xA;        @Component&#xA;        @ConfigurationProperties(prefix = &amp;quot;aa&amp;quot;)&#xA;        public class AaProperties {&#xA;            private String bb;&#xA;            ...getter和setter...&#xA;        }&#xA;    注解    &#xA;        @Configuration&#xA;        @PropertySource(value = &amp;quot;classpath:test.properties&amp;quot;)                    # 加载文件, 配合@ConfigurationProperties注入属性&#xA;        @EnableConfigurationProperties({ConfigBean.class, User.class})          # 加载bean, 配合@Autowired注入&#xA;基础&#xA;    注解&#xA;        @Value(&amp;quot;${xxx}&amp;quot;)&#xA;        @Autowired                                  # 装载bean&#xA;        @Bean                                       # 实例化Bean, 属性名为方法名&#xA;            @Bean&#xA;            public RestTemplate restTemplate() {&#xA;                return new RestTemplate();&#xA;            }&#xA;            相当于&#xA;            RestTemplate restTemplate = new RestTemplate();&#xA;        @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)                         # 生命周期&#xA;            singleton                               # 单例&#xA;            prototype                               # 多例&#xA;            request                                 # web程序ContextApplication用, 随请求创建&#xA;            session                                 # web程序ContextApplication用, 随session创建&#xA;            global session                          # porlet的global用, 其它用降级为session&#xA;        @EventListener(XxxEvent.class)              # 修饰方法, 外部publishEvent()时触发&#xA;实体&#xA;    注解&#xA;        @Entity                                     # 修饰bean类&#xA;        @Id                                         # id属性&#xA;        @GeneratedValue(strategy=GenerationType.AUTO)                           # 自增属性&#xA;        @Column(nullable = false, unique = true)&#xA;组件&#xA;    注解&#xA;        @Component&#xA;        @ConfigurationProperties(prefix = &amp;quot;my&amp;quot;)     # 注入properties对应名称的属性&#xA;dao&#xA;    注解&#xA;        @Repository                                 # 修饰类&#xA;service&#xA;    注解&#xA;        @Service                                    # 修饰类&#xA;        @PostConstruct                              # 修饰方法, 加载servlet时, init()前执行&#xA;        @PreDestroy                                 # 修饰方法, 销毁servlet时, destroy()后执行&#xA;controller&#xA;    注解&#xA;        @Controller                                 # 修饰类&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;测试&#34;&gt;&#xA;  测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;注解&#xA;    @Before&#xA;    @Test&#xA;    @RunWith(SpringRunner.class)                # 修饰类, 测试spring&#xA;    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)                 # 修饰类, 测试spring boot&#xA;    @LocalServerPort                            # 注入端口号&#xA;    @AutoConfigureMockMvc                       # 使用mockMvc, 用@Autowired注入MockMvc&#xA;    @WebAppConfiguration                                # 模拟ServletContext&#xA;XxxApplicationTests.java                        # junit测试&#xA;    @RunWith(SpringJUnit4ClassRunner.class)&#xA;    @SpringApplicationConfiguration(classes = XxxApplication.class)&#xA;    @WebAppConfiguration&#xA;    public class XxxApplicationTests {&#xA;        private MockMvc mvc;&#xA;        @Before&#xA;        public void setUp() throws Exception {&#xA;            mvc = MockMvcBuilders.standaloneSetup(new XxxController()).build();&#xA;        }&#xA;        @Test&#xA;        public void hello() throws Exception {&#xA;            mvc.perform(MockMvcRequestBuilders.get(&amp;quot;/hello&amp;quot;).accept(MediaType.APPLICATION_JSON))&#xA;                .addExpect(status().isOk())&#xA;                .addExpect(content().string(equalTo(&amp;quot;hello&amp;quot;)));&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数据库&#34;&gt;&#xA;  数据库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    spring-boot-starter-jdbc&#xA;    spring-boot-starter-data-jpa                            # spring data JPA&#xA;application.yml&#xA;    jpa:&#xA;        generate-ddl: false&#xA;        show-sql: true&#xA;        hibernate:&#xA;            ddl-auto: none                          # create时, 第一次create之后update&#xA;    datasource:&#xA;        platform: h2&#xA;        schema: classpath:schema.sql                # 建表&#xA;        data: classpath:data.sql                    # 数据&#xA;注解&#xA;    @Transactional                                  # 修饰方法，开启事务，或在事务中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;mybatis&#34;&gt;&#xA;  mybatis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mybatis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;!-- mybatis --&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;    &amp;lt;!-- mysql --&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;version&amp;gt;5.1.21&amp;lt;/version&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;application.yml&#xA;    spring:&#xA;        datasource:&#xA;            url: jdbc:mysql://127.0.0.1:3306/outrun?characterEncoding=UTF-8&#xA;            username: root&#xA;            password: asdf&#xA;            driver-class-name: com.mysql.jdbc.Driver&#xA;        jpa:&#xA;        hibernate:&#xA;            ddl-auto: update  # 新建连接必要&#xA;    mybatis:&#xA;        mapper-locations: classpath:mapper/*.xml        # 指定mapper.xml位置&#xA;&#xA;&#xA;mapper.xml                      # 用mbg生成&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;!DOCTYPE mapper PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;&#xA;    &amp;lt;mapper namespace=&amp;quot;com.outrun.erp.mapper.UserMapper&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;resultMap id=&amp;quot;BaseResultMap&amp;quot; type=&amp;quot;com.outrun.erp.entities.User&amp;quot;&amp;gt;&#xA;            &amp;lt;id column=&amp;quot;id&amp;quot; jdbcType=&amp;quot;BIGINT&amp;quot; property=&amp;quot;id&amp;quot; /&amp;gt;&#xA;            &amp;lt;result column=&amp;quot;name&amp;quot; jdbcType=&amp;quot;VARCHAR&amp;quot; property=&amp;quot;name&amp;quot; /&amp;gt;&#xA;        &amp;lt;/resultMap&amp;gt;&#xA;&#xA;        &amp;lt;select id=&amp;quot;selectUserById&amp;quot; parameterType=&amp;quot;long&amp;quot; resultMap=&amp;quot;UserMap&amp;quot;&amp;gt;&#xA;            SELECT name FROM user WHERE id=#{userId}&#xA;        &amp;lt;/select&amp;gt;&#xA;&#xA;        &amp;lt;insert id=&amp;quot;inserUser&amp;quot;&amp;gt;&#xA;            &amp;lt;selectKey keyProperty=&amp;quot;id&amp;quot; resultType=&amp;quot;int&amp;quot; order=&amp;quot;BEFORE&amp;quot;&amp;gt;&#xA;                select field1 from seq1&#xA;            &amp;lt;/selectKey&amp;gt;&#xA;        &amp;lt;/insert&amp;gt;&#xA;&#xA;        &amp;lt;sql id=&amp;quot;userColumns&amp;quot;&amp;gt;&#xA;            ${alias}.id, ${alias}.username&#xA;        &amp;lt;/sql&amp;gt;&#xA;        &amp;lt;select id=&amp;quot;selectColumns&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;&#xA;            select&#xA;                &amp;lt;include refid=&amp;quot;userColumns&amp;quot;&amp;gt;&amp;lt;property name=&amp;quot;alias&amp;quot; value=&amp;quot;tb1&amp;quot;/&amp;gt;&amp;lt;/include&amp;gt;&#xA;            from tb1&#xA;        &amp;lt;/select&amp;gt;&#xA;&#xA;        &amp;lt;select id=&amp;quot;dynamicSql&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;&#xA;            select * from user&#xA;            where state = 0&#xA;            &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;&#xA;                and title like #{title}&#xA;            &amp;lt;/if&amp;gt;&#xA;&#xA;            &amp;lt;choose&amp;gt;&#xA;                &amp;lt;when test=&amp;quot;title != null&amp;quot;&amp;gt;&#xA;                    and title like #{title}&#xA;                &amp;lt;/when&amp;gt;&#xA;                &amp;lt;when test=&amp;quot;author != null and author.name != null&amp;quot;&amp;gt;&#xA;                    and author_name like ${author.name}&#xA;                &amp;lt;/when&amp;gt;&#xA;                &amp;lt;otherwise&amp;gt;&#xA;                    and featured = 1&#xA;                &amp;lt;/otherwise&amp;gt;&#xA;            &amp;lt;/choose&amp;gt;&#xA;&#xA;            &amp;lt;foreach item=&amp;quot;item&amp;quot; index=&amp;quot;index&amp;quot; collection=&amp;quot;list&amp;quot; open=&amp;quot;(&amp;quot; separator=&amp;quot;,&amp;quot; close=&amp;quot;)&amp;quot;&amp;gt;&#xA;                #{item}&#xA;            &amp;lt;/foreach&amp;gt;&#xA;&#xA;            &amp;lt;trim prefix=&amp;quot;where&amp;quot; prefixOverrides=&amp;quot;and | or&amp;quot;&amp;gt;&#xA;                ...&#xA;            &amp;lt;/trim&amp;gt;&#xA;&#xA;            &amp;lt;bind name=&amp;quot;a&amp;quot; value=&amp;quot;&#39;%&#39; + _data.getTitle() + &#39;%&#39;&amp;quot; /&amp;gt;&#xA;            select * from blog&#xA;            where title like #{a}&#xA;        &amp;lt;/select&amp;gt;&#xA;&#xA;        &amp;lt;update&amp;gt;&#xA;            update User&#xA;                &amp;lt;set&amp;gt;&#xA;                    &amp;lt;if test=&amp;quot;username != null&amp;quot;&amp;gt;username=#{username},&amp;lt;/if&amp;gt;&#xA;                &amp;lt;/set&amp;gt;&#xA;        &amp;lt;/update&amp;gt;&#xA;&#xA;        &amp;lt;cache&amp;gt;                 # 该命名空间缓存&#xA;        &amp;lt;cache-ref&amp;gt;             # 引用其它命名空间缓存&#xA;        &amp;lt;delete&amp;gt;&#xA;        &amp;lt;resultMap&amp;gt;&#xA;            &amp;lt;constructor&amp;gt;       # 构造方法&#xA;                &amp;lt;idArg&amp;gt;         # id参数, 标记id帮助提高性能&#xA;                &amp;lt;arg&amp;gt;           # 普通参数&#xA;            &amp;lt;/constructor&amp;gt;&#xA;            &amp;lt;id&amp;gt;                # 标记id帮助提高性能&#xA;            &amp;lt;result&amp;gt;            # 普通字段&#xA;            &amp;lt;association&amp;gt;       # 关联&#xA;            &amp;lt;collection&amp;gt;        # 结构体&#xA;            &amp;lt;discriminator&amp;gt;     # 自动映射&#xA;        &amp;lt;/resultMap&amp;gt;&#xA;    &amp;lt;/mapper&amp;gt;&#xA;mapper/UserMapper&#xA;    @Mapper           # 如果扫描mapper.xml，不用加@Mapper&#xA;    public interface UserMapper {&#xA;        List&amp;lt;User&amp;gt; selectUserById(@Param(&amp;quot;userId&amp;quot;) long userId)&#xA;&#xA;        @Select(&amp;quot;select * from user&amp;quot;)&#xA;        List&amp;lt;User&amp;gt; findAll();&#xA;    }&#xA;entities/User&#xA;    public class User {&#xA;        private Integer id;&#xA;        private String name;&#xA;        ...getter, setter...&#xA;    }&#xA;注解&#xA;    @Table(name = &amp;quot;user&amp;quot;)                   # 修饰类，指定表&#xA;    @Id                                     # 修饰属性, 指定主键&#xA;    @Column(name = &amp;quot;name&amp;quot;)                  # 修饰属性, 指定字段&#xA;&#xA;    @Mapper                                 # 修饰类&#xA;    @Select(&amp;quot;select * from user&amp;quot;)           # 修饰方法&#xA;    @Param(&amp;quot;userId&amp;quot;)                        # 修饰参数&#xA;api&#xA;    SqlSessionFactory&#xA;        build&#xA;        openSession                         # 重载事务方法&#xA;    SqlSesion&#xA;        selectOne()&#xA;        selectList()&#xA;        selectMap()&#xA;        insert()&#xA;        update()&#xA;        delete()&#xA;        commit()&#xA;        rollback()&#xA;        clearCache()&#xA;        close()&#xA;    Mapper&#xA;        o-&amp;gt;&#xA;        @Insert(&amp;quot;insert into tb1(id, name) values(#{id}, #{name})&amp;quot;)&#xA;        @SelectKey(statement=&amp;quot;next value&amp;quot;, keyProperty=&amp;quot;id&amp;quot;, before=true, resultType=int.class)&#xA;        int insertTable1(String name)&#xA;    SQL&#xA;        INSERT_INTO()&#xA;        VALUES()&#xA;&#xA;        o-&amp;gt;&#xA;        new SQL(){{&#xA;            SELECT(&amp;quot;a.name&amp;quot;);&#xA;            SELECT(&amp;quot;a.age&amp;quot;);&#xA;            FROM(&amp;quot;tb1 a&amp;quot;);&#xA;            WHERE(&amp;quot;a.name like ?&amp;quot;);&#xA;        }}.toString()&#xA;    LogFactory&#xA;        useSlf4jLogging()&#xA;        useLog4jLogging()&#xA;        useStdOutLogging()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;web&#34;&gt;&#xA;  web&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 用的spring mvc&#xA;pom.xml&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                 # web模块, 有tomcat, spring mvc&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;            # 测试模块, 有JUnit, Hamcrest, Mockito&#xA;    &amp;lt;/dependency&amp;gt;&#xA;application.yml&#xA;    server&#xA;        port: 8080                                      # 默认8080&#xA;        servlet&#xA;            context-path: /hello                        # uri前缀&#xA;静态资源&#xA;    默认映射public, resources, static到/&#xA;注解&#xA;    控制器&#xA;        @RestController                             # 修饰类, 组合@Controller与@responseBody&#xA;        @RequestMapping(&amp;quot;/index&amp;quot;)                   # 修改类或方法, url&#xA;            @GetMapping(&amp;quot;/{id}&amp;quot;)                    # 相当于@RequestMapping(method=RequestMethod.GET)&#xA;            @PostMapping&#xA;            @PutMapping&#xA;            @DeleteMapping&#xA;            @PatchMapping&#xA;        @CrossOrigin                                # 修饰方法, 允许跨域&#xA;        @RequestBody                                # 修饰方法, 解析body到参数&#xA;        @PathVariable Long id                       # 修饰参数, 接收url参数&#xA;内置对象&#xA;    ServerProperties                                # 单例可@Autowired, 存端口之类属性&#xA;自实现&#xA;    XxxController.java&#xA;        @RestController&#xA;        public class HelloController {&#xA;            @RequestMapping(&amp;quot;/hello&amp;quot;)&#xA;            public String index() {&#xA;                return &amp;quot;hello&amp;quot;;&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;日志&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    logging:&#xA;        level:&#xA;            root: INFO&#xA;            org.hibernate: INFO&#xA;            org.hibernate.type.descriptor.sql.BasicBinder: TRACE&#xA;            org.hibernate.type.descriptor.sql.BasicExtractor: TRACE&#xA;注解&#xA;    @Slf4j                                      # 修饰类，其中可直接用log变量&#xA;    @EnableSwagger2                             # 修饰类&#xA;    @Api(tags = &amp;quot;&amp;quot;)                             # 修饰类, 文档&#xA;    @ApiModel(&amp;quot;&amp;quot;)                               # 修饰类&#xA;    @ApiModelProperty(&amp;quot;)                        # 修饰属性&#xA;    @ApiOperation(value=&amp;quot;&amp;quot;, notes=&amp;quot;&amp;quot;)           # 修改方法, 文档&#xA;    @ApiIgnore                                  # 修饰方法, 文档忽略&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jackson&#34;&gt;&#xA;  jackson&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jackson&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;注解&#xA;    @JsonInclude                                # 修饰类, 序列化时包含&#xA;        @JsonInclude(JsonInclude.Include.NON_EMPTY)                 # null或&amp;quot;&amp;quot;时不序列化&#xA;    @JsonIgnore                                 # 修饰属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;scheduled&#34;&gt;&#xA;  Scheduled&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#scheduled&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;scheduled&#xA;    注解&#xA;        @Scheduled                                  # 修饰方法, 定时调度&#xA;            @Scheduled(initialDelay = 1000, fixedRate = 1000)&#xA;    类&#xA;        @Configuration&#xA;        implements SchedulingConfigurer             # 配置类&#xA;            configureTasks(ScheduledTaskRegistrar)&#xA;                registrar.setScheduler(Executors.newScheduledThreadPool(2));    # worker池&#xA;async&#xA;    注解&#xA;        @Async                                      # 修饰方法, 异步调用 &#xA;    类&#xA;        implements AsyncUncaughtExceptionHandler    # 处理@Async异常&#xA;            @Override&#xA;            public void handleUncaughtException()&#xA;&#xA;        @Configuration&#xA;        @EnableAsync&#xA;        implements AsyncConfigurer&#xA;            @Bean&#xA;            @Override&#xA;            public Executor getAsyncExecutor()&#xA;&#xA;            @Override&#xA;            public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler()             # 处理无返回值＠Async方法异常&#xA;                return handler&#xA;    使用&#xA;    @Async&#xA;    Future&amp;lt;String&amp;gt; fetch(){&#xA;        return new AsyncResult&amp;lt;String&amp;gt;(&amp;quot;&amp;quot;)&#xA;    }&#xA;    future = fetch()&#xA;    try{&#xA;        future.get()&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;热部署&#34;&gt;&#xA;  热部署&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%83%ad%e9%83%a8%e7%bd%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;                                       # 热部署&#xA;    &amp;lt;/dependency&amp;gt;&#xA;application.yml&#xA;    spring:&#xA;        devtools:&#xA;        restart:&#xA;            enabled: true&#xA;            additional-paths: src/main/java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp&#34;&gt;&#xA;  jsp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;!-- servlet依赖. --&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;&#xA;    &amp;lt;!-- tomcat的支持.--&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;application.yml&#xA;    spring:&#xA;        mvc:&#xA;        view:&#xA;            prefix: /WEB-INF/views/&#xA;            suffix: .jsp&#xA;controller类&#xA;    @Controller&#xA;    public class XxxController {&#xA;        @RequestMapping(&amp;quot;/xxx&amp;quot;)&#xA;        public String xxx(Model m) {&#xA;            m.addAttribute(&amp;quot;a&amp;quot;, 1);&#xA;            return &amp;quot;view1&amp;quot;;&#xA;        }&#xA;    }&#xA;src/main/webapp/WEB-INF/views/view1.jsp&#xA;    &amp;lt;%@ page language=&amp;quot;java&amp;quot; contentType=&amp;quot;text/html; charset=utf-8&amp;quot; pageEncoding=&amp;quot;utf-8&amp;quot;%&amp;gt;&#xA;    jsp ${a}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;lombok&#34;&gt;&#xA;  lombok&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lombok&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;注解&#xA;    @Builder                            # 修饰类, 可build方式设置属性&#xA;    @Getter                             # 修饰类, 生成getter&#xA;    @Setter                             # 修饰类, 生成setter&#xA;    @ToString                           # 修饰类, 生成toString方法&#xA;    @Data                               # 修饰类, 注入getter, setter, toString&#xA;    @NoArgsConstructor                  # 修饰类, 生成无参构造方法&#xA;    @AllArgsContructor                  # 修饰类, 生成带所有参数的构造方法&#xA;    @RequiredArgsConstructor            # 修饰类, 生成带常量、@NotNull修饰变量参数的构造方法&#xA;        @RequiredArgsConstructor(onConstructor_ = @Autowired)               # 构造类时，自动对private final 属性@Autowire&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;remote-shell&#34;&gt;&#xA;  remote shell&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#remote-shell&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    spring-boot-starter-remote-shell&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;actuator&#34;&gt;&#xA;  actuator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#actuator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;原生端点&#xA;    应用配置类&#xA;        /autoconfig                                 # 自动化配置详情&#xA;            positiveMatches&#x9;                        # 成功&#xA;            negativeMatches&#xA;        /beans                                      # 所有bean&#xA;        /configprops                                # 属性&#xA;        /env                                        # 环境属性&#xA;        /mappings                                   # spring mvc映射关系&#xA;        /info                                       # 自定义信息，默认为空，用info前缀定义&#xA;    度量指标&#xA;        /metrics                                    # 程序信息，内存、线程、gc等&#xA;            nonheap.*                               # 非堆内存&#xA;            gauge.*                                 # http请求性能，如gauge.response表示上次延迟&#xA;            counter.*                               # 记录累计，如counter.status.200表示返回200的次数&#xA;        /metrics/{name}                             # 查看某项&#xA;            /metrics/mem.free&#xA;        /health                                     # 启动状态，磁盘空间&#xA;            DiskSpaceHealthIndicator                # 低磁盘空间&#xA;            DataSourceHealthIndicator               # DataSource连接是否可用&#xA;            MongoHealthIndicator&#xA;            RabbitHealthIndicator&#xA;            RedisHealthIndicator&#xA;            SolrHealthIndicator&#xA;        /dump                                       # 线程信息&#xA;        /trace                                      # 跟踪信息&#xA;    操作控制                                         # 用属性配置开启&#xA;        /shutdown                                   # 关闭端点&#xA;            通过endpoints.shutdown.enabled=true开启&#xA;自定义counter统计&#xA;    @Autowired&#xA;    private CounterService counterService;&#xA;    counterService.increment(&amp;quot;didispace.hello.count&amp;quot;)&#xA;自定义health检测器&#xA;    @Component&#xA;    public class RocketMQHealthIndicator implements HealthIndicator {&#xA;        private int check(){}&#xA;        @Override&#xA;        public Health health() {&#xA;            int errorCode = check();&#xA;            if (errorCode !=0) {&#xA;                return Health.down().withDetail(&amp;quot;Error Code&amp;quot;, errorCode).build();&#xA;                return Health.up().build();&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-boot-admin&#34;&gt;&#xA;  spring boot admin&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot-admin&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    spring:&#xA;        application:&#xA;            name: erp-admin-server&#xA;        boot:&#xA;            admin:&#xA;                routes:&#xA;                    endpoints: env,metrics,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream&#xA;    endpoints:&#xA;        health:&#xA;            sensitive: false&#xA;            enabled: true&#xA;        actuator:&#xA;            enabled: true&#xA;            sensitive: false&#xA;        beans:&#xA;            sensitive: false&#xA;            enabled: true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-initializer&#34;&gt;&#xA;  spring initializer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-initializer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    生成spring基础项目&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-security&#34;&gt;&#xA;  spring security&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-security&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;配置&#xA;    application.yml&#xA;        security:   &#xA;            basic:&#xA;                enabled: false                          # 禁用security&#xA;注解&#xA;    @EnableWebSecurity                                  # 修饰WebSecurityConfigurerAdapter, 开启web验证&#xA;    @EnableGlobalMethodSecurity(prePostEnabled = true)  # 修饰WebSecurityConfigurerAdapter, 开启方法验证&#xA;    @PreAuthorize                                       # 修饰controller方法&#xA;api&#xA;    Subject                                             # 主体数据结构, 如用户&#xA;    SecurityManager                                     # 安全管理器, 管理所有subject&#xA;    UserDetails&#xA;        getAuthorities()&#xA;        getUsername()&#xA;        getPassword()&#xA;        isAccountNonExpired()&#xA;        isAccountNonLocked()&#xA;        isCredentialsNonExpired()&#xA;        isEnabled()&#xA;    GrantedAuthority&#xA;        getAuthority()&#xA;    WebSecurityConfigurerAdapter&#xA;        configure(HttpSecurity)                         # 验证请求&#xA;        configure(AuthenticationManagerBuilder)         # 验证数据，需要授权服务配置AuthenticationManager&#xA;            userDetailService&#xA;            passwordEncoder&#xA;        authenticationManagerBean()                     # 指定管理bean&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-security-oauth2&#34;&gt;&#xA;  spring security oauth2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-security-oauth2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    spring-cloud-starter-oauth2&#xA;结构    &#xA;    OAuth2 Provider&#xA;        Authorization Service                           # 授权服务&#xA;        Resource Service                                # 资源服务&#xA;        Spring Security过滤器&#xA;            /oauth/authorize                            # 授权&#xA;            /oauth/token                                # 获取token&#xA;授权服务&#xA;    applicatoin.yml                                     # server&#xA;        security:   &#xA;            oauth2:&#xA;                resource:&#xA;                    filter-order: 3&#xA;    注解&#xA;        @EnableAuthorizationServer                      # 修饰AuthorizationServerConfigurerAdapter, 开启授权服务&#xA;    api&#xA;        AuthorizationServerConfigurerAdapter            # 授权服务配置&#xA;            configure(ClientDetailsServiceConfigurer)                           # 客户端信息&#xA;                clientId&#xA;                secret&#xA;                scope&#xA;                authorizedGrantTypes                    # password, refresh_token, client_credentials&#xA;                authorities                             # 具体权限&#xA;            configure(AuthorizationServerEndpointsConfigurer)                   # 使用token的服务&#xA;                authenticationManager                   # 密码认证&#xA;                    authenticate(Authentication)&#xA;                userDetailService                       # 获取用户数据&#xA;                    loadUserByUsername(String)&#xA;                authorizationCodeServices               # 验证码&#xA;                implicitGrantService&#xA;                tokenGranter&#xA;                tokenStore&#xA;                    InMemoryTokenStore&#xA;                    JdbcTokenStore&#xA;                    JwtTokenStore&#xA;            configure(AuthorizationServerSecurityConfigurer)                    # 使用token服务的安全策略, 授权服务与资源服务分离时配置&#xA;    接口&#xA;        Principal /users/current&#xA;    测试&#xA;        insert into user(username, password) values(&#39;outrun&#39;, &#39;$2a$10$l7.7AJEHtXukwUZiKAyVSO6lHJOyHhPxHvi7MHawe8SjlOKkCVbAe&#39;)&#xA;        curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf&#xA;        浏览器&#xA;            url: localhost:9016/uaa/oauth/token&#xA;            header&#xA;                &#39;Authorization&#39;: &#39;Basic &#39; + base64(&#39;erp-auth-resource:asdf&#39;)&#xA;            data&#xA;                username: &#39;outrun&#39;&#xA;                password: &#39;123456&#39;&#xA;                grant_type: &#39;password&#39;&#xA;资源服务&#xA;    application.yml                                     # client&#xA;        security:&#xA;            oauth2:&#xA;                resource:&#xA;                    user-info-uri: http://localhost:9016/uaa/users/current&#xA;                client:&#xA;                    clientId: erp-auth-resource&#xA;                    clientSecret: asdf&#xA;                    accessTokenUri: http://localhost:9016/uaa/oauth/token&#xA;                    grant-type: client_credentials,password&#xA;                    scope: server&#xA;    注解&#xA;        @EnableResourceServer                           # 修饰ResourceServerConfigurerAdapter, 开启资源服务&#xA;                                                        # 修饰AuthorizationServerConfigurerAdapter, 因为授权服务提供token获取和验证接口&#xA;        @PreAuthorize(&amp;quot;hasAuthority(&#39;ROLE_ADMIN&#39;))      # 修饰controller方法，验证权限&#xA;    api&#xA;        ResourceServerConfigurerAdapter                 # 资源服务配置&#xA;            configure(HttpSecurity)&#xA;                authorizeRequests                       # 请求放行&#xA;    测试&#xA;        curl -d &amp;quot;username=outrun&amp;amp;password=asdf&amp;quot; &amp;quot;localhost:9017/user/registry&amp;quot;&#xA;        insert into role values(1, &#39;ROLE_USER&#39;), (2, &#39;ROLE_ADMIN&#39;)&#xA;        insert into &#39;user_role&#39; values(user_id, 2)&#xA;        curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf&#xA;        curl -l -H &amp;quot;Authorization:Bearer 7df6669c-0c86-417b-827f-9a58297f57e5&amp;quot; -X GET &amp;quot;localhost:9017/hello&amp;quot;&#xA;客户端&#xA;    注解&#xA;        @EnableOAuth2Client                             # 修饰[Oauth2ClientConfig], 客户端&#xA;    api&#xA;        [Oauth2ClientConfig]                            # 客户端配置, 自定义类，名称任意&#xA;            ClientCredentialsResourceDetails            # bean, 资源信息&#xA;            RequestInterceptor                          # bean, 保存请求上下文&#xA;            OAuth2RestTemplate                          # bean, 用于向授权服务发送请求&#xA;表&#xA;    clientdetails&#xA;    oauth_access_token&#xA;    oauth_approvals&#xA;    oauth_client_details&#xA;    oauth_client_token&#xA;    oauth_code&#xA;    oauth_refresh_token&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-integration&#34;&gt;&#xA;  spring integration&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-integration&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 服务编排&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/tool/product/framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/tool/product/framework/</guid>
      <description>&lt;h1 id=&#34;博客框架&#34;&gt;&#xA;  博客框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%9a%e5%ae%a2%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cleaver&#34;&gt;&#xA;  cleaver&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cleaver&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 基于node幻灯片&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hexo&#34;&gt;&#xA;  hexo&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hexo&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    简单轻量，基于node的静态博客框架&#xA;    可以部署在自己node服务器上，也可以部署在github上&#xA;目录结构&#xA;    scaffolds                                        # 脚手架&#xA;    scripts                                            # 写文件的js, 扩展hexo功能&#xA;    source                                            # 存放博客正文内容&#xA;            _drafts                                    # 草稿箱&#xA;            _posts                                        # 文件箱&#xA;    themes                                            # 皮肤&#xA;    _config.yml                                        # 全局配置文件&#xA;    db.json                                            # 静态常量&#xA;使用&#xA;    npm install -g hexo&#xA;    hexo version&#xA;    hexo init nodejs-hexo&#xA;    cd nodejs-hexo &amp;amp;&amp;amp; hexo server&#xA;    hexo new 新博客                            # 产生 source/_posts/新博客.md&#xA;    hexo server                                        # 启动server&#xA;    hexo generate                                    # 静态化处理&#xA;    github中创建一个项目nodejs-hexo, 在_config.yml中找到deploy部分，设置github项目地址&#xA;    hexo deploy&#xA;            # 部署以后，分支是gh-pages, 这是github为web项目特别设置的分支&#xA;    上github，点settings找到github pages, 找到自己发布的站点&#xA;    无法访问静态资源&#xA;            设置域名&#xA;                    申请域名&#xA;                    dnspod 中 绑定ip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hugo&#34;&gt;&#xA;  hugo&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hugo&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;简介&#xA;    hugo由go编写，开源，特点为编译快&#xA;    本文基于hugo0.49&#xA;安装&#xA;    go install --tags extended&#xA;命令&#xA;    hugo&#xA;        help&#xA;        help server    # server代表任何子命令&#xA;场景&#xA;    发布&#xA;        hugo --theme=hyde --baseUrl=&amp;quot;https://outrunJ.github.io&amp;quot;&#xA;    生成站点&#xA;        hugo new site blog1 # 站点命令在blog1中执行&#xA;    生成文章&#xA;        hugo new about.md&#xA;        hugo new post/first.md&#xA;    本地服务器&#xA;        hugo server&#xA;            # 自带watch&#xA;            -s /path/to/codes&#xA;            --theme=hyde&#xA;            --buildDrafts&#xA;            -p 1315&#xA;                # 默认端口1313&#xA; 主题&#xA;    git clone https://github.com/spf13/hyde.git themes/hyde # 更多主题在https://themes.gohugo.io&#xA; 文章&#xA;    开头&#xA;        ---&#xA;        用YAML写内容&#xA;        --- # +++标记可写TOML&#xA;&#xA;        Description = &amp;quot;&amp;quot;&#xA;        Categories = [&amp;quot;a1&amp;quot;, &amp;quot;a2&amp;quot;]&#xA;        Tags = [&amp;quot;b1&amp;quot;,&amp;quot;b2&amp;quot;]&#xA;        draft = true    # 文章隐藏&#xA;        menu = &amp;quot;&amp;quot;&#xA;        title = &amp;quot;a&amp;quot; # 文章标题&#xA; 配置&#xA;    打开config.toml   # 可以是config.yaml、config.json&#xA;    baseURL = &amp;quot;&amp;quot;&#xA;    title = &amp;quot;&amp;quot;&#xA;    theme = &amp;quot;&amp;quot;&#xA;    [permalinks]&#xA;        post = &amp;quot;/:year/:month/:title/&amp;quot;  # 生成list页面&#xA;&#xA;    [taxonomies]&#xA;        category = &amp;quot;categories&amp;quot;&#xA;        tag = &amp;quot;tags&amp;quot;&#xA;&#xA;    [params]&#xA;        description = &amp;quot;&amp;quot;&#xA;        author = &amp;quot;&amp;quot;&#xA;&#xA;    ignoreFiles = []&#xA;&#xA;    [blackfriday]   # 设置markdown库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jekyll&#34;&gt;&#xA;  jekyll&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jekyll&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    ruby静态站点生成器，根据网页源码生成静态文档文件&#xA;    提供模板、变量、插件等功能&#xA;    生成的站点可以直接发布到github上&#xA;使用&#xA;    curl http://curl.haxx.se/ca/cacert.pem -o cacert.pem&#xA;        # 移动到ruby安装目录&#xA;    安装devkit&#xA;    gem install jekyll&#xA;    git clone https://github.com/plusjade/jekyll-bootstrap.git jekyll&#xA;        # 下载jekyll-bootstrap模版&#xA;    cd jekyll &amp;amp;&amp;amp; jekyll serve&#xA;    rake post title = &#39;Hello&#39;&#xA;        # 生成文章&#xA;        ## 编辑_posts下面生成的文章&#xA;    修改convertible.rb文件编码为utf-8&#xA;    jekyll serve&#xA;    发布到github&#xA;        github上创建新仓库&#xA;        git remote set-url origin git@新仓库&#xA;        git add .&#xA;        git commit -m &#39;new&#39;&#xA;        git push origin master&#xA;        git branch gh-pages&#xA;            # 新建一个分支，用于发布项目&#xA;        git checkout gh-pages&#xA;        修改_config.yml&#xA;            production_url: http://outrun.github.io&#xA;            BASE_PATH: /jekyll-demo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;在线服务&#34;&gt;&#xA;  在线服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e7%ba%bf%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;webide&#34;&gt;&#xA;  webIDE&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#webide&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;codebox&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;游戏&#34;&gt;&#xA;  游戏&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b8%b8%e6%88%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;框架&#xA;    pomelo&#xA;        # node.js上网易开源的实时性好的游戏类服务器&#xA;架构&#xA;    MySQL&#xA;        user_id_list&#xA;        club_id_list&#xA;    Redis&#xA;    Netty&#xA;        ProxyServer     # 交互客户端, 监听Redis Channel拿到BizServer列表， 代理请求到多个BizServer&#xA;            channelHandlerList&#xA;                Encoder&#xA;                Decoder&#xA;                内容长度限制&#xA;                WebSocket处理&#xA;                msgHandler&#xA;                客户端连接时动态添加handler&#xA;            msg带类型，区分handler, 据msg类型转发到bizServer&#xA;            每个用户存routerTable&#xA;        BizServer       &#xA;    Go + Protobuf + WebSocket&#xA;    Cocos Creator/白鹭/LayaBox&#xA;    Unity(C#)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;三方服务&#34;&gt;&#xA;  三方服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e6%96%b9%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;web&#34;&gt;&#xA;  web&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;aws&#xA;阿里云&#xA;青云&#xA;轻云&#xA;digital ocean&#xA;vultr&#xA;Linode&#xA;azure&#xA;    # 微软开放平台&#xA;gce&#xA;    # google compute engine&#xA;txCloud&#xA;    # 云柜，数据存储和计算&#xA;首都在线&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;paas&#34;&gt;&#xA;  paas&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#paas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;gae&#xA;    # google app engine&#xA;sae&#xA;    # sina app engine&#xA;heroku&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;dns&#34;&gt;&#xA;  dns&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dns&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;godaddy&#xA;万网&#xA;dnspod&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cdn&#34;&gt;&#xA;  cdn&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cdn&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;七牛&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pay&#34;&gt;&#xA;  pay&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pay&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;支付宝&#xA;易宝&#xA;财付通&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;idc&#34;&gt;&#xA;  idc&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#idc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# infomation data corporation, 互联网数据中心&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cti&#34;&gt;&#xA;  cti&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cti&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;天润&#xA;云之讯&#xA;容联&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;报表olap&#34;&gt;&#xA;  报表/olap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%a5%e8%a1%a8olap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;palo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;im&#34;&gt;&#xA;  im&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#im&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;环信&#xA;云片&#xA;jpush&#xA;im&#xA;sms.webchinese.cn&#xA;个推&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;safe&#34;&gt;&#xA;  safe&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#safe&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;1password&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;设备&#34;&gt;&#xA;  设备&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%be%e5%a4%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;京东叮咚&#xA;    # 智能音箱&#xA;萤石&#xA;    # 视频设备&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Apple</title>
      <link>https://runout.run/docs/tool/develop/apple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/tool/develop/apple/</guid>
      <description>&lt;h1 id=&#34;ipad&#34;&gt;&#xA;  ipad&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ipad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;操作&#xA;    下边向上(短)：桌面&#xA;    下边向上(停): dock&#xA;        dock拖app: 小窗、分屏&#xA;            小窗向边(短): 隐藏&#xA;            小窗向边(停): 分屏&#xA;            小窗向上：分离&#xA;    下角向内(短): 切app&#xA;    下角向内(停): app表&#xA;    右上角向下: 控制中心&#xA;    左上角向下：通知&#xA;    桌面向下: 搜索&#xA;    3指左右: app内切换&#xA;    4指左右：切app&#xA;    4指向内(短): 桌面&#xA;    4指向内(停): app表 &#xA;&#xA;    home一下：桌面&#xA;    home两下：app表&#xA;    截图、导出pdf: 主按键 + 电源键&#xA;&#xA;    键盘：两指缩小浮动&#xA;    分屏: 一指拉出dock, 一指拖出程序&#xA;siri&#xA;    问答: 笑话, 常识, 抛硬币&#xA;    safari: 搜索&#xA;    设置: 蓝牙,飞行模式&#xA;    时钟&#xA;        6点起床&#xA;        德国时间&#xA;        倒计时&#xA;    日历: 9点开会&#xA;    提醒：提醒和给妈妈打电话&#xA;    备忘录：记下我花了10块钱&#xA;    地图：回家路线&#xA;    打车&#xA;    打电话, 发信息&#xA;    照片&#xA;    体育：比赛消息&#xA;    音乐&#xA;    邮件&#xA;    天气&#xA;    计算器&#xA;    股票: xx涨了吗&#xA;    朋友：xx在哪里&#xA;    发微博&#xA;    指定xx: 打开trello发送a&#xA;    附近店&#xA;    相机：自拍模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;alfred&#34;&gt;&#xA;  alfred&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#alfred&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;搜索&#xA;    指定网站搜索&#xA;    文件&#xA;剪贴板&#xA;计算器&#xA;自定义脚本&#xA;    打字&#xA;    命令&#xA;    工作流&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;fantastical&#34;&gt;&#xA;  fantastical&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fantastical&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;个人总结&#xA;    名字 date 9th from 9.30p to 10.32p alert 30min&#xA;对象&#xA;    Account - Calendar Sets - Cals(Subscription+Interesting) + Item(Events + Tasks)&#xA;nlp&#xA;    语法&#xA;        事件 [with 人物] [at 地点] [at 日期时间] [on 日期] [from 日期时间] [to 日期时间] [of every 日期时间] 提醒 URL 日历&#xA;    日期&#xA;        特定&#xA;            日期&#xA;                11月1日     11/1    11.1&#xA;            星期&#xA;                周一        mon/tue/wed/tur/fri/sat/sun&#xA;        相对&#xA;            日期&#xA;                15天后      after 15 days&#xA;            星期&#xA;                下周一      next mon&#xA;        重复&#xA;            日期&#xA;                每月2号     every 2&#xA;            星期&#xA;                每周二      every tue&#xA;                每隔两周的周三      on wed every 2 weeks&#xA;            复合&#xA;                7月1日到8月1日之间的每个周一周二        on mons tues from 7/1 to 8/1&#xA;        区间&#xA;            12月17日到次年1月3日是寒假      寒假 12/17-1/3      12/17~1/3&#xA;    时间&#xA;        24小时制&#xA;            13&#xA;        12小时制&#xA;            下午一点        1p  1pm&#xA;        分钟&#xA;            下午一点半      13:30   1.30p&#xA;        默认&#xA;            早上8点         morning&#xA;            中午12点        noon&#xA;            下午5点         evening&#xA;            晚上8点         night&#xA;            半夜12点        midnight&#xA;        区间&#xA;            下午1点32到晚上7点47        1.32-7.47   1.32~7.47&#xA;    提醒&#xA;        提前2小时提醒       alert 2 hours&#xA;        提前5分钟提醒       alert 5 min&#xA;    URL&#xA;        在合适位置的url&#xA;    日历&#xA;        /Work       /w&#xA;        四个空格&#xA;    待办事项(reminder)&#xA;        开启&#xA;            todo、task、Remind、Remind me to开头&#xA;        独有语义&#xA;            11月27日晚上8点截止     due 11/27 8p        until 11/27 8p      by Thursday&#xA;            低 中 高        ! !! !!!&#xA;快捷键&#xA;    新建                command + n&#xA;    切换日程/待办事项   command + k&#xA;    保存                command + s&#xA;    删除                command + d&#xA;&#xA;    搜索                command + f&#xA;    详情                command + i&#xA;    显示事项            command + r&#xA;    定位到今天          command + t&#xA;    设置                command + ,&#xA;    切换全屏视图        command + shift + f&#xA;&#xA;操作&#xA;    新建页面滑动隐藏&#xA;    长按日期新建&#xA;    长按Item&#xA;        移动到Calendar&#xA;        颜色&#xA;&#xA;        复制/重建/剪切/删除&#xA;        建模板&#xA;        隐藏&#xA;&#xA;        邮件触发事件&#xA;    横划删除&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;mathstudio&#34;&gt;&#xA;  mathStudio&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mathstudio&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Basic Expressions&#xA;    1+2&#xA;    4*5&#xA;    6!&#xA;Algebra&#xA;    a*a+b&#xA;    Expand((a+b)^10)&#xA;    Apart( (x^2) / ( x^2 + 1)^2)&#xA;    Factor( x^4 + 5x^2 - 6 )&#xA;Solving Quadratic Equations&#xA;    Solve( x^2 + 5x + 6 = 0 )&#xA;    Solve(1,5,6)&#xA;Limits&#xA;    Limit()&#xA;Derivatives&#xA;    D(sin(x))&#xA;Integrals&#xA;    Integrate( x^2 + 3x - 6 )&#xA;Graphing&#xA;    Plot(sin(x))&#xA;Parametric Plots&#xA;    ParametricPlot(cos(u), sin(u))&#xA;Polar Plots&#xA;    PolarPlot(sin(2@theta))&#xA;Time Graphing&#xA;    Plot(sin(x + T))&#xA;Vector Fields&#xA;    VectorPlot(-y, x)&#xA;Multiple Plots&#xA;Minimum, Maximum and Zero Values&#xA;    Plot(sin(x), min=1)&#xA;List Plots&#xA;    ListPlot([1,2,3,4,5,4,3,8,6,8])&#xA;Regression Analysis&#xA;    LinearFit([1,4,9,5,7,5,4,2,9], [3,4,5,7,8,10,4,7,6])&#xA;    LinearFitModel()&#xA;    LinearFitPlot()&#xA;    QuadraticFitPlot()&#xA;    SinFitPlot()&#xA;3D Graphing&#xA;    Plot3D(2cos(x) * sin(y))&#xA;3D Parametric Plots&#xA;Sliders&#xA;    Slider(n, 1..50)&#xA;    Slider(a, 2, 10, 0.1)&#xA;Scripting&#xA;    one = 1&#xA;    two = 2&#xA;    one + two&#xA;    cube(x) = x^3&#xA;    cube(5)&#xA;    for [row, column] in data&#xA;    end&#xA;Lists&#xA;    1:100&#xA;    [1,2,3] * [4,5,6]&#xA;Matrices&#xA;    [[1,2], [3,4]] * [[5,6], [7,8]]&#xA;    Inverse([a,b], [c,d])&#xA;    Identity(5)&#xA;Units&#xA;    2@feet + 24@inches&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;working-copy&#34;&gt;&#xA;  Working Copy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#working-copy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;mac&#34;&gt;&#xA;  mac&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;操作&#xA;    四指&#xA;        向内：启动台&#xA;        向外：桌面&#xA;    三指&#xA;        左右：切桌面&#xA;        向上：app列表&#xA;        向下：expose(单程序多窗口)&#xA;    二指&#xA;        上下：滚动&#xA;        左右：前进后退&#xA;        右边：通知中心&#xA;        缩放,旋转&#xA;        点一下：菜单&#xA;        点二下：小缩放&#xA;    一指&#xA;        点一下：选中&#xA;        点二下：打开&#xA;        点一段：拖&#xA;        点二段：查询&#xA;快捷键&#xA;    系统：&#xA;        锁屏：control + command + q&#xA;        关屏：shift + control + 关机&#xA;        注销：shift + command + q &#xA;        睡眠：option + command + 关机&#xA;        强退：control + command + 关机&#xA;    程序坞： option + command + d&#xA;    调度中心：&#xA;        app列表: control + 上&#xA;        expose: control + 下&#xA;        左右桌面：control + 左右&#xA;        桌面：f11&#xA;    窗口：&#xA;        切换：command + tab&#xA;        程序内切换：command + `&#xA;        关闭：command + w&#xA;        退出：command + q&#xA;        强制退出：option + command + esc&#xA;        隐藏：command + h&#xA;        最大化: control + command + f&#xA;        最小化：command + m&#xA;        放大、缩小：command + +和-&#xA;        新标签：command + t&#xA;        新建: command + n&#xA;        打开：command + o&#xA;        保存：command + s&#xA;        另存为：shift + command + s&#xA;        刷新：command + r&#xA;        打印：command + p&#xA;        搜索：command + f&#xA;    文件： &#xA;        全选、复制、剪切、粘贴、撤销: command + a c x v z &#xA;        粘贴移到: option + command + v&#xA;        删除: command + return&#xA;    访达：&#xA;        预览：空格&#xA;        简介：command + i&#xA;    回收站：&#xA;        清空：shift + command + return&#xA;    截屏：&#xA;        整屏存文件：shift + command + 3&#xA;        区域存文件：shift + command + 4&#xA;        窗口区域：shift + command + 4 + 空格&#xA;        录屏：shift + command + 5&#xA;    输入法：control + 空格&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;brew&#xA;    update              # 更新brew&#xA;    search&#xA;    install&#xA;    remove&#xA;    upgrade&#xA;    tap                 # 安装扩展&#xA;    options             # 查看安装选项&#xA;    info&#xA;    home                # 访问包官网&#xA;    services&#xA;        list            # 查看已安装&#xA;        cleanup         # 清除无用配置&#xA;        restart         # 重启&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Jetbrains</title>
      <link>https://runout.run/docs/tool/develop/jetbrains/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/tool/develop/jetbrains/</guid>
      <description>&lt;h1 id=&#34;intellij-idea&#34;&gt;&#xA;  Intellij Idea&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#intellij-idea&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;注意&#xA;    Project 相当于workspace, module 相当于工程&#xA;注册&#xA;    服务器&#xA;        # 发布网站 http://idea.lanyus.com&#xA;        http://idea.qinxi1992.cn&#xA;        http://idea.lianghongbo.com/licens&#xA;        http://im.js.cn:8888&#xA;javaagent&#xA;    https://zhile.io/&#xA;&#xA;快捷键&#xA;    settings -&amp;gt; Keymap 设置eclipse&#xA;        alt + enter     # 改错&#xA;        shift shift     # 搜索跳转&#xA;    shift + f4          # 新窗口打开文件&#xA;类注释&#xA;    settings -&amp;gt; Editor -&amp;gt; File and Code Templates -&amp;gt; Includes -&amp;gt; File Header&#xA;       /**  &#xA;        *&#xA;        * @Description: ${Description}&#xA;        * @author: ShenWenqing&#xA;        * @date: Created on ${DATE} ${TIME}&#xA;        *&#xA;        */&#xA;alt + enter 可生成 serialVersionUID&#xA;    settings -&amp;gt; Inspections&#xA;        勾选 Serializable class without &#39;serialVersionUID&#39;&#xA;JDK&#xA;    Project Settings -&amp;gt; Project&#xA;    settings -&amp;gt; Build Tools&#xA;    settings -&amp;gt; Compilers&#xA;编码&#xA;    file -&amp;gt; settings -&amp;gt; appearence里use custom font设置中文字体&#xA;    file -&amp;gt; settings -&amp;gt; editor -&amp;gt; file encodings 三处utf-8&#xA;    idea安装目录/bin/idea.vmoptions和idea64.vmoptions,最后添加&#xA;        -Dfile.encoding=UTF-8&#xA;    .idea/encodings.xml里删除除了UTF-8的项&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;.env files supoort&#xA;.ignore&#xA;BinEd&#xA;EasyYapi&#xA;EnvFile&#xA;Extra Icons&#xA;File Expander&#xA;Free MyBatis plugin&#xA;GitToolBox&#xA;IdeaVim&#xA;jclasslib Bytecode Viewer&#xA;JMH Java Microbenchmark Harness&#xA;LeetCode Editor&#xA;Lua&#xA;MapStruct Support&#xA;Maven Helper&#xA;Presentation Assistant&#xA;Rainbow Brackets&#xA;Save Actions&#xA;Solarized Theme&#xA;Solarized Themes&#xA;SonarLint&#xA;Statistic&#xA;Tabnine AI Code Completion&#xA;EmmyLua&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;webstorm&#34;&gt;&#xA;  webstorm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#webstorm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;pycharm&#34;&gt;&#xA;  pycharm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pycharm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;goland&#34;&gt;&#xA;  goland&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#goland&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;clion&#34;&gt;&#xA;  clion&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#clion&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;phpcharm&#34;&gt;&#xA;  phpCharm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#phpcharm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>实物工具</title>
      <link>https://runout.run/docs/tool/physics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/tool/physics/</guid>
      <description>&lt;h1 id=&#34;hhkb-hybrid&#34;&gt;&#xA;  HHKB HyBrid&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hhkb-hybrid&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;生产日期 20210108&#xA;购买日期 202104&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;配对方式&#34;&gt;&#xA;  配对方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e5%af%b9%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;1.按Fn + q键进入配对模式。&#xA;2.再按Fn + z + ~ 键清空键盘配对信息,键盘自动关闭。&#xA;3.长按开关键重新打开键盘后按Fn + q键进入配对模式,再按Fn + Ctrl + 1/2/3/4指定一个序号。&#xA;4.然后关闭电脑蓝牙功能再打开进行搜索。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;切换&#34;&gt;&#xA;  切换&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%87%e6%8d%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Fn + Ctrl + 1/2/3/4&#xA;Fn + Ctrl + 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;swiftpoint-propoint&#34;&gt;&#xA;  Swiftpoint ProPoint&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#swiftpoint-propoint&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;blix-komfort-prima&#34;&gt;&#xA;  Blix Komfort Prima&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#blix-komfort-prima&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>测试规划</title>
      <link>https://runout.run/docs/architect/method/test_plan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/architect/method/test_plan/</guid>
      <description>&lt;h1 id=&#34;规划&#34;&gt;&#xA;  规划&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%84%e5%88%92&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;蓝图&#xA;    规范 &amp;amp; 稳定&#xA;        用例规范，测试方案规范，自动化代码规范，工单处理标准，提测准人/出标准，Bug规范&#xA;        线上异常监控，PPE环境监控，发布接管，线上问题对接，线上告警，自动巡检&#xA;    内容&#xA;        基础：功能测试，兼容性测试，性能测试，数据治理，安全测试，线上问题，环境治理，故障演练&#xA;        提效：API自动化，框架&amp;amp;测试代码自动生成，自动部署&amp;amp;持续集成，数据工厂，UI自动化，Doom引流&#xA;        赋能：测试用例开放，代码质量度量，story_QA，测试工具&amp;amp;平台开放，自由组装case场景，精准推荐&#xA;        探索：探索性测试，契约测试，AI技术赋能测试&#xA;    度量&#xA;        线上：发布次数，紧急发布/回滚，工单预警数，生产冒烟数，线上工单数，复盘数&#xA;        线下：代码质量数据，缺陷修复效率，Bug打回数据，自动化通过率，项目进度度量，Story owner度量&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;功能测试&#xA;    业务梳理：业务结构图，服务调用图，数据流，特殊逻辑时序图&#xA;    用例设计：模板化，框架化&#xA;安全测试&#xA;    清扫漏洞: 敏感信息，接口安全问题&#xA;    工具：BurpSuite, 自研代码安全扫描工具&#xA;    常态化: 下沉QA流程，研发流程加入&#xA;兼容性测试&#xA;    包括：App，H5，操作系统，Web浏览器，API&#xA;线上问题治理&#xA;    工具：工单系统&#xA;    线上反馈线上化：钉钉机器人接入，Bug自动转移&#xA;    数据沉淀及可视化&#xA;    FAQ&#xA;        运营自查：-&amp;gt;QA-&amp;gt;开发产品&#xA;        问题解决&#xA;            功能缺陷类: 开发解决-&amp;gt;QA-&amp;gt;运营&#xA;            答疑问：加入自查文档&#xA;            功能优化类：指派给产品&#xA;    问题规约&#xA;        宣导：线上群公告，线下组织文档操作和业务培训&#xA;        问题分类和定级&#xA;        1/5/30原则：1分钟感知，5分钟响应，30分钟解决&#xA;        FAQ持续转化输出&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;提效&#34;&gt;&#xA;  提效&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e6%95%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;API测试&#xA;    工具: Jenkins+Newman, JMeter, &#xA;    思想: 模块化，测试库，数据驱动，关键字驱动，BDD&#xA;    框架&#xA;        Jenkins+Python(UnitTest/Pytest, Requests, HTMLTestRunner/Allure) &#xA;        Jenkins+Java+Maven+JUnit/TestNG+HttpClient/RestAssured+ExtentReport/Allure&#xA;    框架思想&#xA;        框架分层解耦: 用例层，组件/业务层，API层，公共基础层&#xA;        数据分类处理: 公共数据，隔离数据，运行时数据&#xA;        多协议封装: 接口协议，接口定义及调用&#xA;        多环境处理: 发布流，框架管理(切换、可维护性可扩展性)&#xA;    结果自动验证&#xA;        框架扩展: Pytest&#xA;        对比策略&#xA;        数据库设计: 自动化用例nodeid，请求URL，运行环境，用例路径，request_id，请求体，cURL，Response&#xA;        对比引擎设计：JSONPath匹配对比策略&#xA;    API覆盖率统计&#xA;        分类&#xA;            白盒覆盖率: 代码&#xA;            灰盒覆盖率：接口&#xA;            黑盒覆盖率：需求&#xA;        实践&#xA;            分子：结合日志，生成RequestID扩展py.test&#xA;            分母：代码，文档系统&#xA;自动生成框架&#xA;    底层代码生成&#xA;        核心层&#xA;        逻辑封装层: 自动获取接口信息，建立模板机制，数据解析器，建立自动触发机制&#xA;        用例层: 用例自动转化代码(XMind SDK)&#xA;    冒烟代码生成&#xA;        步骤: 获取接口信息，拼装请求并验证&#xA;场景化改造&#xA;    Journey模式：用户角色为中心&#xA;    方案：梳理场景需求，实例化故事场景，转化为自动化验收代码&#xA;    框架设计： Actor&#xA;        复用基础层、API层: 公共基础层引入Actor为中心的设计模式&#xA;        组件层对基础层Actor写业务测试逻辑代码: 主要调用API层&#xA;        用例层不变&#xA;FSM场景化代码，动态组合&#xA;    FSM生成自动化用例&#xA;    步骤&#xA;        业务建模&#xA;        动态绘制流程图: Graphviz&#xA;        构建FSM转化器&#xA;            解析器: 节点函数，解析多叉树与节点内容&#xA;        用例组合&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;赋能&#34;&gt;&#xA;  赋能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b5%8b%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据工厂&#xA;    手工化&#xA;    脚本化: RESTful API转向SOA API&#xA;    平台化&#xA;    服务化&#xA;持续集成&#xA;    代码零库存管理: 代码尽早提交，feature分支尽早集成，功能尽早测试，代码尽早得到反馈&#xA;    工具：Doom, Sonar&#xA;    节点&#xA;        本地IDE: sonarLint, findbugs, P3C, checkstyle, unit test&#xA;        提交: fundbugs, P3C,checkstyle,unit test, 集成测试，安全检查，集成测试覆盖率，代码构建&#xA;        环境部署: 集成测试，全量代码质量检查&#xA;        pull rquest: 新增代码质量预览，测试覆盖率&#xA;        PRE: 验收测试&#xA;        PROD: 冒烟检查&#xA;    自动化&#xA;        feature分支合入时：接口自动化用例，增量代码扫描用例，流量回放用例&#xA;        环境部署：全量API自动化用例测试和流量引流测试&#xA;代码质量&#xA;    属性：清晰度，可维护性，注释，重构，充分测试，可扩展，效率&#xA;    内容：代码规范，持续集成，度量&#xA;    建设步骤：标准化，数据化，流程化&#xA;Story QA&#xA;    项目经理&#xA;        作用：培养大家的全局视野，锻炼大家的软性能力&#xA;        职责：记录技术方案，站会，汇报，验收，把控风险，协调，跟踪&#xA;    度量体系: 各维度打分&#xA;    工具化制度化&#xA;        奖惩：级别，措施&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;探索&#34;&gt;&#xA;  探索&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a2%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;流量回放&#xA;    工具：jvm-sandbox-repeater, RDebug, goreplay&#xA;    mock处理: DefaultMockStrategy, Parameter-MatchMockStrategy&#xA;契约测试&#xA;    微服务测试模式: 单元测试，接口测试，契约测试，集成测试&#xA;    特性：一致性，测试前移，覆盖API的各种调用场景&#xA;    实施：服务消费者，服务提供者，契约文件，契约验证&#xA;    相对mock有期望请求响应的契约内容&#xA;    框架：Pack，Srping Cloud Contract&#xA;探索性测试&#xA;    理念：边学习，边设计，边执行，持续优化&#xA;    全局探索性测试&#xA;        商业区: 核心特性&#xA;        娱乐区: 辅助功能&#xA;        旅馆区: 软件“休息”时要持续保持的功能&#xA;        历史区: 历史遗留功能，曾经经常出现的问题&#xA;        旅游区: 老用户不太使用，新用户着重使用&#xA;        破旧区: 对软件破坏来测试稳定性&#xA;    流程&#xA;        反馈收集，持续监控和跟踪&#xA;        客户/项目需求&#xA;        技术/测试设计&#xA;        技术/测试用例/代码评审&#xA;        单元/集成/系统测试&#xA;        上线&#xA;    思维&#xA;        策略模型: 质量标准、项目环境、产品元素 -&amp;gt; 测试技术 -&amp;gt; 观察到的产品质量&#xA;        基于测程的测试管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;管理&#34;&gt;&#xA;  管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;团队管理&#xA;    团队画像&#xA;        定格局&#xA;        团队文化：专业，高效，靠谱&#xA;        认识自我&#xA;        向心力&#xA;    技术分享&#xA;        方案&#xA;            课题制度：每人一领域&#xA;            学习形式：阶段性、周期性&#xA;            学习周期：每周以小组形式，一小组2人&#xA;            落地推行：有demo&#xA;    个人发展&#xA;        方向：抓住当下，关注自身本体，技术体系构建(横向、纵向)&#xA;        工作习惯：内容合理分配，多关注业界的思路及方案，总结反思&#xA;项目管理&#xA;    难点：掌控项目进度，合理协调资源，保证整体线上质量&#xA;    三部曲&#xA;        序幕&#xA;            仪式感：同步背景，熟悉相关人员，明确关键时间节点，理清各自边界及上下游依赖&#xA;            粮草：排期，数据准备及测试用例，环境资源 ，工具资源&#xA;        高潮&#xA;            把控进展：定期站会，同步进度风险预警，制定原则&#xA;            集成测试：重点跟进核心链路，小黑屋即时响应，每天测试报告&#xA;            线上质量：明确上线顺序、灰度、回滚策略，小规模集成测试，线上压测及演练&#xA;        终章&#xA;            线上灰度跟进&#xA;            项目总结&#xA;            文档沉淀&#xA;            沟通一致&#xA;            风险评估和预案&#xA;            技术改动&#xA;            工具化自动化&#xA;            用人不疑疑人不用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;纲领&#34;&gt;&#xA;  纲领&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%b2%e9%a2%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;代码门禁&#xA;    公共分支只能pull request，执行检验&#xA;        编译&#xA;        单元测试&#xA;        接口级别功能测试&#xA;        静态代码扫描&#xA;        人员检查&#xA;    优化门禁工具&#xA;        缩短时间&#xA;            10分钟内&#xA;            mariadb4j&#xA;            精准测试&#xA;        提高稳定性&#xA;            90%成功率&#xA;    更多用途&#xA;        Bug Jail不允许开发名单&#xA;        组件升级检查&#xA;测试的本质: 反馈&#xA;    测试演进&#xA;        平台建设&#xA;            自动化回归、造数&#xA;        质量监控&#xA;            线上监控报警、资损演练、红蓝对抗、线上引流&#xA;            基于风险的测试全方位深入&#xA;            智能化提速: 判断测试范围、测试用例范围&#xA;            API生成测试框架和代码&#xA;            专项测试平台使测试结果 可持续沉淀&#xA;            可视化质量看板&#xA;        赋能&#xA;            测试工具全员可运行&#xA;    质量反馈&#xA;        代码门禁的结果: 代码是否可接受&#xA;        功能回归结果: 是否推进到预发布&#xA;        预发布和灰度验证结果: 是否上线&#xA;    反馈能力：缩短反馈时间，降低成本，提高可信度&#xA;缩短反馈弧&#xA;    方面&#xA;        反馈前置等待时间&#xA;        反馈本身耗时&#xA;    方法&#xA;        持续集成&#xA;提升稳定性&#xA;    高频：持续打包，发布，证书和密钥更新，容灾演练，缩短反馈弧，变主动验证为被动&#xA;    隔离 &#xA;        TiP(Testing in Production)&#xA;        用完即抛&#xA;        不自动重跑&#xA;提升有效性&#xA;    防止注水&#xA;    测试测试代码&#xA;    变异测试和Bug注入&#xA;提升充分性&#xA;    用例自动生成&#xA;    业务覆盖率&#xA;从测到不测&#xA;    防错: Poka-yoke&#xA;        第一时间校验输入值&#xA;        线上线下权限隔离&#xA;        视觉辨识度&#xA;        代码写错：易混淆的类和方法&#xA;        事情没按正确的方式做&#xA;    静态代码分析和Bug自动识别&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;大促场景&#34;&gt;&#xA;  大促场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%a7%e4%bf%83%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;全链路压测&#xA;    全链路影子体系: 各中间件切流&#xA;    压测模型与施压能力&#xA;    常态化智能压测&#xA;全链路功能&#xA;    统一环境隔离：流量隔离，时间控制，预案开关推送&#xA;    全链路影子数据: 生成，使用&#xA;全民预演&#xA;预案开关：大促预案，日常预案&#xA;全链路预热: 系统预热，数据预热，预热场景编排&#xA;快速扩/缩容：水平，垂直&#xA;风险识别引擎压测&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;移动app场景&#34;&gt;&#xA;  移动App场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a7%bb%e5%8a%a8app%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;工具&#xA;    自动化工具&#xA;        云测平台&#xA;        框架&#xA;        用例生成&#xA;        数据Mock&#xA;    专项测试: 启动、崩溃、卡顿、发烫等&#xA;    稳定性测试: 智能化Monkey方案&#xA;        基于遗传算法&#xA;        基于用户操作&#xA;    兼容性测试&#xA;标准&#xA;线上保障&#xA;    监控&#xA;        监控方案：定义监控指标、监控方式、监控维度&#xA;        监控度量：版本趋势，版本对比，年度趋势，业务趋势&#xA;        告警分析&#xA;        异常监控&#xA;    性能分级与降级&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;大数据&#34;&gt;&#xA;  大数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%a7%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;测什么&#xA;    功能性验证&#xA;    数据更新的实时性&#xA;    数据请求响应的及时性&#xA;    算法的效果验证&#xA;    AI算法系统的线上稳定性&#xA;    工程效率方向&#xA;算法系统&#xA;工程系统&#xA;效果评估&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;ai系统&#34;&gt;&#xA;  AI系统&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ai%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;语音类&#xA;计算机视觉类&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;云计算&#34;&gt;&#xA;  云计算&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;专有云质量定义&#xA;高可用&#xA;性能容量&#xA;热升级&#xA;用户场景测试&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;金融类&#34;&gt;&#xA;  金融类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%91%e8%9e%8d%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;风险防控&#xA;资损风险防范&#xA;资损风险识别&#xA;资损风险应急&#xA;资损防控文化: 红蓝攻防，常态化演练&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;物流类&#34;&gt;&#xA;  物流类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%a9%e6%b5%81%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;通用技术&#xA;仓储实操机器人&#xA;末端IoT设备&#xA;全球化物流骨干网&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;安全生产&#34;&gt;&#xA;  安全生产&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e5%85%a8%e7%94%9f%e4%ba%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;资金安全&#xA;故障快恢&#xA;灰度发布&#xA;信息安全风险&#xA;突袭演练&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>程序调试</title>
      <link>https://runout.run/docs/tool/test/debug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/tool/test/debug/</guid>
      <description>&lt;h1 id=&#34;分析方向&#34;&gt;&#xA;  分析方向&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90%e6%96%b9%e5%90%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  cpu&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法调用&#xA;    调用栈时长比例&#xA;    录制时间内调用栈时长&#xA;火焰图(graph frames)&#xA;    宽度: 方法耗时&#xA;    高度: 调用栈深&#xA;    排序是按字母的，颜色是随机的&#xA;subsecond offset heat map&#xA;    x轴: 秒&#xA;    y轴: 一秒内各阶段&#xA;    z轴: 颜色深度标记events采样数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;对象&#xA;    对象个数、空间比例&#xA;    调用栈分配比例&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程协程&#34;&gt;&#xA;  线程/协程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;泄露&#xA;    I/O阻塞&#xA;    锁阻塞&#xA;    channel阻塞&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gc问题&#34;&gt;&#xA;  GC问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gc%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;少建对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;linux&#34;&gt;&#xA;  Linux&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;time&#xA;ftrace&#xA;perf_events&#xA;eBPF&#xA;SystemTap&#xA;LTTng&#xA;ktap&#xA;dtrace4linux&#xA;OEL DTrace&#xA;sysdig&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;java&#34;&gt;&#xA;  Java&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;visualvm&#34;&gt;&#xA;  VisualVM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#visualvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;jprofiler&#34;&gt;&#xA;  JProfiler&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jprofiler&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 收费, java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;perfino&#34;&gt;&#xA;  perfino&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#perfino&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 监测jvm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;yourkit&#34;&gt;&#xA;  YourKit&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#yourkit&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 收费, java, 有调用链&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-insight&#34;&gt;&#xA;  Spring Insight&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-insight&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# java spring&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;golang&#34;&gt;&#xA;  Golang&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#golang&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;go命令&#xA;    go tool pprof Xx.bin Xx.prof&#xA;        -inuse_space                # -inuse_space显示真正使用的内存&#xA;        -cpuprofile=cpu.prof&#xA;        -memprofile=mem.prof&#xA;        -blockprofile=block.prof&#xA;        -svg                        # 输出svg&#xA;&#xA;    go build&#xA;        -toolexec=&amp;quot;/usr/bin/time&amp;quot;   # -toolexec在每个命令加上前缀&#xA;        -toolexec=&amp;quot;perf stat&amp;quot;&#xA;        -gcflags=&#39;-memprofile=m.p&#39;&#xA;        -gcflags=&#39;-traceprofile=t.p&#39;&#xA;&#xA;    go test&#xA;        -blockprofile=b.p net/http&#xA;        -trace=t.p&#xA;    go tool trace Xx.bin t.p&#xA;    go-torch cpu.prof&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;环境变量&#xA;GODEBUG=gctrace=1&#xA;# 打印gc信息&#xA;http&#xA;import _ &amp;ldquo;net/http/pprof&amp;rdquo;&#xA;func main() {&#xA;log.Println(http.ListenAndServe(&amp;ldquo;localhost:3999&amp;rdquo;, nil))&#xA;}&lt;/p&gt;</description>
    </item>
    <item>
      <title>软考架构师</title>
      <link>https://runout.run/docs/cache/soft_arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/cache/soft_arch/</guid>
      <description>&lt;h1 id=&#34;计算机基础&#34;&gt;&#xA;  计算机基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;冯诺依曼&#xA;&#x9;输入、输出、存储器(中心)、运算器控制器(CPU)&#xA;硬件图&#xA;&#x9;主机(运算器、控制器、主存)&#xA;&#x9;存储器: 主存、辅存&#xA;&#x9;I/O设备&#xA;CPU&#xA;&#x9;指令: 操作码, 地址码&#xA;&#x9;运算器&#xA;&#x9;&#x9;ALU: 算逻运算&#xA;&#x9;&#x9;&#x9;PSW状态寄存器&#xA;&#x9;&#x9;&#x9;&#x9;ACC &#x9;&#x9;&#x9;MQ&#x9;&#x9;&#x9;&#x9;X&#xA;&#x9;&#x9;&#x9;加 &#x9;被加数、和&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;加数&#xA;&#x9;&#x9;&#x9;减&#x9;被减数、差&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;减数&#xA;&#x9;&#x9;&#x9;乘&#x9;乘积高位&#x9;&#x9;乘数、乘积低位&#x9;被乘数&#xA;&#x9;&#x9;&#x9;除&#x9;被除数、余数&#x9;商&#x9;&#x9;&#x9;&#x9;除数&#xA;&#x9;控制器&#xA;&#x9;&#x9;CU: 控制单元&#xA;&#x9;&#x9;&#x9;时序部件: 时钟控制&#xA;&#x9;&#x9;&#x9;ID: 指令译码器&#xA;&#x9;&#x9;&#x9;IR: 指令寄存器,即将执行的指令,查MAR&#xA;&#x9;&#x9;&#x9;PC: 程序计数器,下条指令地址&#xA;&#x9;存储体&#xA;&#x9;&#x9;MAR: 地址寄存器, 现在集成到了CPU&#xA;&#x9;&#x9;MDR: 数据寄存器, 指令存到IR&#xA;主存&#xA;&#x9;存储单元: 存1字节, 唯一地址用16进制数表示&#xA;&#x9;总线&#xA;&#x9;&#x9;地址总线: 长度表示n位二进制数地址数&#xA;&#x9;&#x9;数据总线: 长度表示一次处理多少位，叫作1个字的长度&#xA;存储器&#xA;&#x9;分类&#xA;&#x9;&#x9;位置&#xA;&#x9;&#x9;&#x9;内存(主存)&#xA;&#x9;&#x9;&#x9;外存(辅存)&#xA;&#x9;&#x9;材料&#xA;&#x9;&#x9;&#x9;半导体&#xA;&#x9;&#x9;&#x9;&#x9;静态: 双稳态触发器&#xA;&#x9;&#x9;&#x9;&#x9;动态: 依靠电容上的电荷存储，主存&#xA;&#x9;&#x9;&#x9;磁介质: 磁性材料的不同状态存储，外存&#xA;&#x9;&#x9;&#x9;光: 利用光斑、晶像的变化表示信息，外存&#xA;&#x9;&#x9;工作方式&#xA;&#x9;&#x9;&#x9;读/写RAM&#xA;&#x9;&#x9;&#x9;只读&#xA;&#x9;&#x9;&#x9;&#x9;固定ROM: 用户不可写&#xA;&#x9;&#x9;&#x9;&#x9;可编程PROM: 用户写1次&#xA;&#x9;&#x9;&#x9;&#x9;可擦除可编程EPROM: 可多次编程，紫外线擦除&#xA;&#x9;&#x9;&#x9;&#x9;电擦除可编程EEPROM: 可多次编程，电擦除&#xA;&#x9;&#x9;&#x9;&#x9;闪存: 接近EEPROM&#xA;&#x9;&#x9;访问方式&#xA;&#x9;&#x9;&#x9;按地址访问的&#xA;&#x9;&#x9;&#x9;按内容访问的&#xA;&#x9;&#x9;寻址方式&#xA;&#x9;&#x9;&#x9;随机RAM: 按地址访问任一单元，主存&#xA;&#x9;&#x9;&#x9;顺序SAM: 访问时按顺序查找目标地址，磁带&#xA;&#x9;&#x9;&#x9;直接DAM: 按照数据块所在位置访问，磁盘&#xA;&#x9;&#x9;&#x9;相联：按照内容进行访问，Cache&#xA;校验码&#xA;&#x9;类别&#xA;&#x9;&#x9;奇偶校验码&#xA;&#x9;&#x9;&#x9;只能发现奇数个位出错&#xA;&#x9;&#x9;海明码&#xA;&#x9;&#x9;&#x9;奇偶校验、分组校验&#xA;&#x9;&#x9;&#x9;n为数据位个数，求校验位个数k: 2^k &amp;gt;= n+k+1&#xA;&#x9;&#x9;CRC循环冗余校验码&#xA;&#x9;码距: 任意两个码字的最小距离&#xA;&#x9;&#x9;检测出e个误码，要求码距d&amp;gt;=e+1&#xA;&#x9;&#x9;纠正t个误码，要求码距d&amp;gt;=2t+1&#xA;指令&#xA;&#x9;指令周期&#xA;&#x9;执行&#xA;&#x9;&#x9;顺序执行&#xA;&#x9;&#x9;重叠执行&#xA;&#x9;&#x9;流水线&#xA;&#x9;&#x9;&#x9;建立时间: 第一条指令执行完毕时间&#xA;&#x9;&#x9;&#x9;流水线周期: 部件(取指、分析、执行)执行时间最长的一段&#xA;&#x9;&#x9;&#x9;全部执行完时间&#xA;&#x9;&#x9;&#x9;&#x9;理论公式: (t1+t2+...+tk) + (n-1)*t&#xA;&#x9;&#x9;&#x9;&#x9;实践公式: (k+n-1)*t&#xA;&#x9;&#x9;&#x9;吞吐率: 指令条数/执行时间&#xA;&#x9;&#x9;&#x9;最大吞吐率: 1/流水线周期时间&#xA;&#x9;&#x9;&#x9;加速比: 不使用流水线时间/使用流水线时间&#xA;高速缓存&#xA;&#x9;局部性原理&#xA;&#x9;&#x9;时间局部性: 经常使用&#xA;&#x9;&#x9;空间局部性: 相临空间内容&#xA;&#x9;架构&#xA;&#x9;&#x9;地址总线、数据总线&#xA;&#x9;&#x9;地址映射、变换机构&#xA;&#x9;&#x9;&#x9;直接映像: 放到cache第0页。简单，但不灵活，块冲突率高&#xA;&#x9;&#x9;&#x9;&#x9;离cpu近时用&#xA;&#x9;&#x9;&#x9;全相联映像: 灵活但变换复杂&#xA;&#x9;&#x9;&#x9;&#x9;离cpu远时用&#xA;&#x9;&#x9;&#x9;组相联映像: 组间直接映像, 主存区映射到cache页, 组内全相联映像。&#xA;&#x9;&#x9;&#x9;&#x9;离cpu近时用&#xA;&#x9;&#x9;主存装入或替换&#xA;&#x9;平均访问时间: ta=Hctc+(1-HC)tm&#xA;&#x9;写策略&#xA;&#x9;&#x9;写直达(write-through): 同步修改主存&#xA;&#x9;&#x9;写回法(write-back): cache被替换时写主存&#xA;&#x9;&#x9;标记法: 有效位1未修改,0时读主存&#xA;&#x9;替换算法&#xA;&#x9;&#x9;随机算法&#xA;&#x9;&#x9;先进先出(FIFO)&#xA;&#x9;&#x9;近期最少使用(LRU)&#xA;&#x9;&#x9;最不经常使用(LFU): 有时间窗口的LRU&#xA;磁盘存储器&#xA;&#x9;磁盘、磁头、磁道、扇区、数据块、柱面&#xA;&#x9;存取时间: 寻道时间 + 等待时间 + 读/写时间(可忽略)&#xA;计算机系统结构分类&#xA;&#x9;Flynn分类法&#xA;&#x9;&#x9;指令流: 执行的指令序列&#xA;&#x9;&#x9;数据流: 指令流调用的数据序列, 包括输入数据和中间结果&#xA;&#x9;Flynn类别&#xA;&#x9;&#x9;单指令流单数据流(SISD)&#xA;&#x9;&#x9;单指令流多数据流(SIMD)&#xA;&#x9;&#x9;多指令流单数据流(MISD): 少见&#xA;&#x9;&#x9;多指令流多数据流(MIMD)&#xA;&#x9;指令系统&#xA;&#x9;&#x9;复杂指令系统(CISC)&#xA;&#x9;&#x9;&#x9;指令多, 大概100-250条&#xA;&#x9;&#x9;&#x9;只有20%常用&#xA;&#x9;&#x9;&#x9;寻址方式多(5-20种)&#xA;&#x9;&#x9;&#x9;变长指令电路复杂&#xA;&#x9;&#x9;&#x9;直接交互主存速度慢&#xA;&#x9;&#x9;&#x9;用微程序而非硬布线逻辑电路控制&#xA;&#x9;&#x9;精简指令系统(RISC)&#xA;&#x9;&#x9;&#x9;指令数量少&#xA;&#x9;&#x9;&#x9;寻址方式少，通常只有寄存器寻址、立即数寻址、相对寻址&#xA;&#x9;&#x9;&#x9;指令长度固定&#xA;&#x9;&#x9;&#x9;硬布线逻辑控制为主&#xA;&#x9;&#x9;&#x9;流水线技术&#xA;&#x9;&#x9;&#x9;优化的编译器，编译简化&#xA;&#x9;&#x9;&#x9;交互CPU寄存器, 一般32个以上&#xA;总线&#xA;&#x9;位置分类&#xA;&#x9;&#x9;内部&#xA;&#x9;&#x9;外部&#xA;&#x9;功能分类&#xA;&#x9;&#x9;地址&#xA;&#x9;&#x9;数据&#xA;&#x9;&#x9;控制&#xA;&#x9;数据线多少分类&#xA;&#x9;&#x9;并行: 速率高，近距离传输(内部部件系统总线)&#xA;&#x9;&#x9;串行: 速率不高，长距离传输&#xA;磁盘阵列&#xA;&#x9;RAID 0: 无冗余无校验, 存储性能最高&#xA;&#x9;RAID 1: 磁盘镜像阵列&#xA;&#x9;RAID 2: 海明码纪错, 增加3个校验盘提供单纠错和双验错。大量数据时I/O性能高，应用少&#xA;&#x9;RAID 3、4: 奇偶校验码, 3采用位交叉, 4采用块交叉。3适用大型文件且I/O需求不频繁, 4适用大型文件读取&#xA;&#x9;RAID 5: 无独立校验盘，校验信息分布在组内所有盘上，用户实际空间是N-1块盘。大批量和小批量数据的读写性能好了，适用I/O需求频繁的应用。应用多&#xA;&#x9;RAID 6: 独立数据盘+2个独立的分布式校验盘，用户实际空间是N-2块。效率一般，应用少&#xA;&#x9;RAID 7: 独立存储计算机，带操作系统和管理工具&#xA;&#x9;RAID 10: RAID 1+0结合。RAID 0下挂RAID 1, 应用多&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;操作系统基础&#34;&gt;&#xA;  操作系统基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;处理机管理&#xA;&#x9;进程状态&#xA;&#x9;&#x9;三状态: 运行、就绪、阻塞&#xA;&#x9;&#x9;组成: 程序、数据、PCB(进程唯一标识)&#xA;&#x9;&#x9;&#x9;PCB结构&#xA;&#x9;&#x9;&#x9;&#x9;线性方式&#xA;&#x9;&#x9;&#x9;&#x9;链接方式&#xA;&#x9;&#x9;&#x9;&#x9;索引方式&#xA;&#x9;前驱图: 有向无循环图&#xA;&#x9;PV操作&#xA;&#x9;&#x9;加锁(P操作信号量-1, 可能锁别的进程), 信号量为0时产生临界区&#xA;&#x9;&#x9;解锁(V操作信号量+1, 发现信号量为负时唤醒别的进程)&#xA;&#x9;&#x9;同步问题&#xA;&#x9;&#x9;&#x9;缓冲区满时不写空时不读，每个时刻只能一个操作(存或取)&#xA;&#x9;&#x9;&#x9;关键操作前P，关键操作后V&#xA;&#x9;&#x9;&#x9;两个信号量,加互斥信号量&#xA;存储器管理&#xA;&#x9;逻辑地址、物理地址&#xA;&#x9;&#x9;静态重定位: 绝对地址=相对地址+程序存放的内存起始地址&#xA;&#x9;&#x9;&#x9;运行前确定映射关系&#xA;&#x9;&#x9;&#x9;装入后不能移动&#xA;&#x9;&#x9;&#x9;占用连续的内存空间&#xA;&#x9;&#x9;动态重定位: 绝对地址=重写位寄存器的值(BR)+逻辑地址寄存器的值(VR)。硬件加寄存器实现地址转换&#xA;&#x9;&#x9;&#x9;程序占用的内存空间可动态变化&#xA;&#x9;&#x9;&#x9;不要求连续的内存空间&#xA;&#x9;&#x9;&#x9;便于多进程共享代码&#xA;&#x9;存储管理&#xA;&#x9;&#x9;分区管理: 主存用户区划分区域，每个区域分配给一个用户，并限制用户只能在区域中&#xA;&#x9;&#x9;&#x9;固定分区: 空间浪费&#xA;&#x9;&#x9;&#x9;可变分区: 根据程序大小选择合适分区&#xA;&#x9;&#x9;&#x9;&#x9;首次适应算法&#xA;&#x9;&#x9;&#x9;&#x9;最佳适应算法&#xA;&#x9;&#x9;&#x9;&#x9;最差适应算法&#xA;&#x9;&#x9;&#x9;可重定位分区&#xA;&#x9;&#x9;分页管理&#xA;&#x9;&#x9;&#x9;逻辑地址&#xA;&#x9;&#x9;&#x9;&#x9;页号: 20位&#xA;&#x9;&#x9;&#x9;&#x9;页内地址: 12位&#xA;&#x9;&#x9;&#x9;物理地址&#xA;&#x9;&#x9;&#x9;&#x9;块号&#xA;&#x9;&#x9;&#x9;&#x9;块内地址: 等于页内地址&#xA;&#x9;&#x9;&#x9;页表&#xA;&#x9;&#x9;&#x9;&#x9;硬件生成&#xA;&#x9;&#x9;&#x9;&#x9;页起始地址、页长度&#xA;&#x9;&#x9;分段管理&#xA;&#x9;&#x9;&#x9;逻辑地址: 段号、段内地址&#xA;&#x9;&#x9;&#x9;物理地址&#xA;&#x9;&#x9;&#x9;段表: 基址、段长&#xA;&#x9;&#x9;段页式管理&#xA;&#x9;&#x9;&#x9;逻辑地址: 段号、页号、页内地址&#xA;&#x9;&#x9;&#x9;物理地址: &#xA;&#x9;&#x9;虚拟存储&#xA;&#x9;&#x9;&#x9;请求分页&#xA;&#x9;&#x9;&#x9;请求分段&#xA;&#x9;&#x9;&#x9;请求段页式&#xA;设备管理: 输入输出控制方式&#xA;&#x9;程序控制: 串行&#xA;&#x9;&#x9;无条件传送&#xA;&#x9;&#x9;程序查询&#xA;&#x9;中断: 并行&#xA;&#x9;DMA(直接内存访问): 设备访问内存，CPU不能访问内存&#xA;文件管理&#xA;&#x9;文件索引&#xA;&#x9;&#x9;一个节点占4字节&#xA;&#x9;&#x9;直接索引: 检索范围小&#xA;&#x9;&#x9;间接索引&#xA;&#x9;&#x9;&#x9;一级&#xA;&#x9;&#x9;&#x9;二级&#xA;&#x9;使用情况: bitmap标记&#xA;&#x9;&#x9;字长x字编号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;计算机网络基础&#34;&gt;&#xA;  计算机网络基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;OSI七层&#xA;&#x9;应用层&#xA;&#x9;&#x9;HTTP、Telnet、FTP、SMTP、NFS&#xA;&#x9;表示层&#xA;&#x9;&#x9;JPEG、ASCII、GIF、DES、MPEG&#xA;&#x9;会话层&#xA;&#x9;&#x9;RPC、SQL&#xA;&#x9;传输层&#xA;&#x9;&#x9;TCP、UDP、SPX&#xA;&#x9;网络层&#xA;&#x9;&#x9;IP、IPX、ICMP&#xA;&#x9;链路层&#xA;&#x9;&#x9;MAC(媒介访问层)、LLC(逻辑链路层)&#xA;&#x9;&#x9;IEEE802.3/.2、HDLC、PPP、ATM&#xA;&#x9;物理层&#xA;&#x9;&#x9;RS232、V.35、RJ-45、FDDI&#xA;IP协议&#xA;&#x9;IPV4: 32位&#xA;&#x9;&#x9;A类: 0开头: 1-126&#xA;&#x9;&#x9;B类: 10开头: 128-191&#xA;&#x9;&#x9;C类: 110开头: 192-223&#xA;&#x9;&#x9;D类: 1110开头: 224-239, 组播&#xA;&#x9;&#x9;E类: 1110开头: 240-255, 保留&#xA;&#x9;子网&#xA;&#x9;&#x9;三级IP地址: 子网号主机号中借出来&#xA;&#x9;&#x9;子网掩码&#xA;&#x9;&#x9;&#x9;A类地址的: 255.0.0.0&#xA;&#x9;&#x9;&#x9;B类地址的: 255.255.0.0&#xA;&#x9;&#x9;&#x9;C类地址的: 255.255.255.0&#xA;&#x9;IPV4数据报&#xA;&#x9;&#x9;版本&#xA;&#x9;&#x9;首部长度&#xA;&#x9;&#x9;区分服务&#xA;&#x9;&#x9;总长度: 2^16-1=65535字节&#xA;&#x9;&#x9;标识&#xA;&#x9;&#x9;标志: DF不分片, MF: 片未分完&#xA;&#x9;&#x9;片偏移&#xA;&#x9;&#x9;生存时间&#xA;&#x9;&#x9;协议&#xA;&#x9;&#x9;首部校验和&#xA;&#x9;&#x9;可选字段&#xA;&#x9;&#x9;填充: 达到4的倍数&#xA;&#x9;IPV6: 128位，共8段用:分开, 每段4个16进制数&#xA;&#x9;&#x9;支持单播/多播/组播/任播&#xA;&#x9;&#x9;支持自动配置&#xA;&#x9;IPV4过渡IPV6&#xA;&#x9;&#x9;双协议栈&#xA;&#x9;&#x9;遂道&#xA;&#x9;&#x9;NAT-PT&#xA;&#x9;IPV6数据报&#xA;&#x9;&#x9;版本&#xA;&#x9;&#x9;流量分类: 相当于区分服务&#xA;&#x9;&#x9;流标签&#xA;&#x9;&#x9;有效负载长度: 除基本首部外的字节数&#xA;&#x9;&#x9;下一头部: 相当于协议&#xA;&#x9;&#x9;跳数限制: 相当于生存时间&#xA;&#x9;TCP/UDP&#xA;&#x9;&#x9;TCP&#xA;&#x9;&#x9;&#x9;数据报标记序号&#xA;&#x9;&#x9;&#x9;确认、校验、定时器，重传&#xA;&#x9;&#x9;&#x9;窗口机制流量调整&#xA;&#x9;&#x9;TCP协议&#xA;&#x9;&#x9;&#x9;校验和: 校验所有数据&#xA;&#x9;&#x9;UDP&#xA;&#x9;&#x9;&#x9;无连接&#xA;&#x9;&#x9;&#x9;尽最大努力交付&#xA;&#x9;&#x9;&#x9;面向报文&#xA;&#x9;&#x9;&#x9;无拥塞控制&#xA;&#x9;&#x9;&#x9;支持1对1、1对多、多对1通信&#xA;&#x9;&#x9;&#x9;首部小，只有8字节。TCP20字节&#xA;&#x9;&#x9;UDP协议&#xA;&#x9;&#x9;&#x9;校验和: 不校验或校验头部&#xA;&#x9;网络设计&#xA;&#x9;&#x9;接入层: 收集用户信息如Ip、MAC、访问日志。管理功能如MAC地址、计费管理&#xA;&#x9;&#x9;汇聚层: 网络访问策略控制，数据包处理、过滤、寻址&#xA;&#x9;&#x9;核心层: 双机冗余热备份&#xA;&#x9;&#x9;出口层&#xA;&#x9;综合布线系统&#xA;&#x9;&#x9;工作区子系统: 插座&#xA;&#x9;&#x9;水平子系统: 楼层, 接入管理子系统&#xA;&#x9;&#x9;管理子系统&#xA;&#x9;&#x9;垂直(干线)子系统: 主设备间至各层管理间&#xA;&#x9;&#x9;设备间子系统: 连接跳线架及支撑硬件，防雷电，是中心单元&#xA;&#x9;&#x9;建筑群子系统: 楼间连线&#xA;域名和地址&#xA;&#x9;DNS: UDP协议&#xA;&#x9;&#x9;结构&#xA;&#x9;&#x9;&#x9;根: 用.表示&#xA;&#x9;&#x9;&#x9;顶级域: com, edu, gov&#xA;&#x9;&#x9;&#x9;二级域: baidu&#xA;&#x9;&#x9;&#x9;子域: 最多63个字符&#xA;&#x9;&#x9;&#x9;主机&#xA;域名&#xA;&#x9;服务器&#xA;&#x9;&#x9;主域名服务器: 本区域名解析&#xA;&#x9;&#x9;辅助域名服务器: 备份&#xA;&#x9;&#x9;缓存域名服务器: 缓存查询结果&#xA;&#x9;&#x9;转发域名服务器: 非本地缓存中没有的，先查自身缓存，没有时转发到指定域名服务器&#xA;&#x9;查询方式&#xA;&#x9;&#x9;递归&#xA;&#x9;&#x9;&#x9;本服务器解析名字&#xA;&#x9;&#x9;迭代&#xA;&#x9;&#x9;&#x9;问别的服务器&#xA;&#x9;设备&#xA;&#x9;&#x9;中继器: 物理层，信号再生和发送,只直到扩展传输距离的作用，个数有限(以太网4个)&#xA;&#x9;&#x9;网桥: 数据链路层, 物理地址转发，只能连接相同MAC层的网络&#xA;&#x9;&#x9;路由器: 网络层&#xA;&#x9;&#x9;网关: 4-7层&#xA;&#x9;&#x9;集线器: 多端口中继器&#xA;&#x9;&#x9;二层交换机: 数据链路层，传统交换机，多端口网桥&#xA;&#x9;&#x9;三层交换机: 网络层，带路由功能的二层交换机&#xA;&#x9;&#x9;多层交换机: 4-7层，带协议转换&#xA;&#x9;网络存储&#xA;&#x9;&#x9;DAS: 直接附加存储, 设备通过SCSI电缆直接连到服务器，无操作系统存储的操作依赖于服务器。也叫作SAS(服务器附加存储)&#xA;&#x9;&#x9;NAS: 网络附加存储, 不再通过I/O总线附属特定服务器，而是通过网络接口与网络直接相连，用户通过网络访问。专用的文件服务器，即插即用&#xA;&#x9;&#x9;SAN: 存储区域网络, 专用交换机连接磁盘阵列与服务器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据库基础&#34;&gt;&#xA;  数据库基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;结构&#xA;    开发人员: 三级模式，DBMS管理&#xA;        内模式: 内部视图, 只有一个&#xA;        概念模式: 概念视图, 公共视图, 只有一个&#xA;        外模式: 外部视图, 可以多个&#xA;    最终用户:&#xA;        单用户&#xA;        主从&#xA;        分布式&#xA;        客户-服务器&#xA;        浏览器-应用服务器/数据库服务器&#xA;独立性&#xA;&#x9;逻辑独立性: 数据的逻辑独立性&#xA;&#x9;&#x9;模式改变时，只改变映像&#xA;&#x9;物理独立性&#xA;&#x9;&#x9;存储结构改变，只改变映像&#xA;数据模型&#xA;&#x9;概念数据模型: E-R图&#xA;&#x9;基本数据模型: 计算机的观点来建模，用于DBMS实现&#xA;&#x9;&#x9;分类&#xA;&#x9;&#x9;&#x9;层次模型&#xA;&#x9;&#x9;&#x9;网状模型&#xA;&#x9;&#x9;&#x9;关系模型&#xA;&#x9;&#x9;&#x9;面向对象模型&#xA;&#x9;&#x9;关注&#xA;&#x9;&#x9;&#x9;数据结构&#xA;&#x9;&#x9;&#x9;数据操作&#xA;&#x9;&#x9;&#x9;数据约束条件&#xA;&#x9;&#x9;&#x9;&#x9;主属性非空&#xA;&#x9;&#x9;&#x9;&#x9;参照完整性: 外键，可以空但不能没有&#xA;&#x9;&#x9;&#x9;&#x9;用户定义完整性&#xA;概念&#xA;&#x9;关系: 表名&#xA;&#x9;元组: 记录&#xA;&#x9;属性: 列&#xA;&#x9;域: 取值范围&#xA;&#x9;关键字: 一组唯一标识元组的属性&#xA;&#x9;关系模式: 表结构&#xA;关系代数&#xA;&#x9;U: 并&#xA;&#x9;-: 差&#xA;&#x9;n: 交&#xA;&#x9;x: 笛卡尔积&#xA;&#x9;o: 选择, 取得符合条件的行&#xA;&#x9;π: 投影, 取得符合条件的列&#xA;&#x9;&amp;gt;&amp;lt;: 连接&#xA;&#x9;&#x9;等值连接: 笛卡尔积筛选属性相等的元组&#xA;&#x9;&#x9;自然连接: 等值连接去重复的列&#xA;&#x9;&#x9;外连接&#xA;&#x9;&#x9;&#x9;左外连接&#xA;&#x9;&#x9;&#x9;右外连接&#xA;&#x9;&#x9;&#x9;完全外连接 &#xA;函数依赖&#xA;&#x9;X-&amp;gt;Y&#xA;&#x9;&#x9;X函数确定Y&#xA;&#x9;&#x9;Y函数依赖于X&#xA;&#x9;平凡&#xA;&#x9;&#x9;X-&amp;gt;Y Y不包含于X，X-&amp;gt;Y非平凡函数依赖&#xA;&#x9;&#x9;X-&amp;gt;Y Y包含于X，X-&amp;gt;Y平凡函数依赖&#xA;&#x9;完全&#xA;&#x9;&#x9;完全函数依赖: 条件都用上, 完全依赖于主键&#xA;&#x9;&#x9;部分函数依赖: 条件过剩, 对主键有传递依赖&#xA;&#x9;&#x9;传递依赖 &#xA;&#x9;Armstrong公理&#xA;&#x9;&#x9;自反律: 内部包含的关系, Y属于X属于U，则X-&amp;gt;Y&#xA;&#x9;&#x9;增广律: X-&amp;gt;Y被F蕴含，则XZ-&amp;gt;YZ被F蕴含&#xA;&#x9;&#x9;传递律: 推导, X-&amp;gt;Y, Y-&amp;gt;Z, 则X-&amp;gt;Z&#xA;&#x9;&#x9;合并规则: X-&amp;gt;Y, X-&amp;gt;Z，则X-&amp;gt;YZ&#xA;&#x9;&#x9;伪传递规则: X-&amp;gt;Y, WY-&amp;gt;Z，则WX-&amp;gt;Z&#xA;&#x9;&#x9;分解规则: X-&amp;gt;Y, Z属于Y, 则X-&amp;gt;Z&#xA;&#x9;超键: 主键和其它键组合&#xA;&#x9;主键: 无多余属性&#xA;&#x9;候选键: 无多余属性可成为主键的键&#xA;&#x9;外键: 关联其它表主键&#xA;&#x9;主属性非主属性: 主键中的属性是主属性&#xA;&#x9;全码: 属性全是主键&#xA;规范化: 拆分表&#xA;&#x9;1NF: 每个属性(列)不可再分&#xA;&#x9;&#x9;不满足后果&#xA;&#x9;&#x9;&#x9;冗余大&#xA;&#x9;&#x9;&#x9;插入入异常、删除异常、修改异常&#xA;&#x9;2NF: 非主属性不完全依赖主键，即有对主键的部分依赖，不满足&#xA;&#x9;3NF: 有非主属性的传递依赖不完全依赖主键(比如依赖其它非主键属性)，不满足&#xA;&#x9;BC范式: 主键包含依赖的所有决定性因素(所有主属性)&#xA;&#x9;&#x9;不满足后果&#xA;&#x9;&#x9;&#x9;冗余大&#xA;&#x9;&#x9;&#x9;插入异常、删除异常&#xA;&#x9;&#x9;&#x9;修改复杂&#xA;&#x9;4NF: 没有多值属性&#xA;&#x9;5NF&#xA;&#x9;无损连接, 函数依赖性&#xA;设计&#xA;&#x9;规划阶段: 必要性、可行性&#xA;&#x9;需求分析: 产出需求规格说明书、数据字典&#xA;&#x9;&#x9;调查重点是&amp;quot;数据&amp;quot;、&amp;quot;处理&amp;quot;&#xA;&#x9;&#x9;数据字典: 数据项、数据流、数据存储、数据加工(结构化语言、判定数、判定表)&#xA;&#x9;概念设计: E-R图, 不依赖DBMS&#xA;&#x9;&#x9;局部E-R图，实体联系，消除冲突(属性冲突、结构冲突、命名冲突)成全局E-R图&#xA;&#x9;逻辑设计: 逻辑模型，产出关系模式&#xA;&#x9;&#x9;实体-&amp;gt;关系&#xA;&#x9;&#x9;属性-&amp;gt;属性&#xA;&#x9;&#x9;&#x9;复合属性、多值属性、派生属性、BLOB型属性、联系属性&#xA;&#x9;&#x9;关键字-&amp;gt;关键字&#xA;&#x9;物理设计: 建立物理模型, create table&#xA;反规范化&#xA;&#x9;增加冗余列、派生列&#xA;&#x9;重新组表&#xA;&#x9;分割表: 水平分割、垂直分割&#xA;事务管理ACID&#xA;&#x9;原子性Atomicity&#xA;&#x9;一致性Consistency&#xA;&#x9;隔离性Isolation&#xA;&#x9;持久性Durability&#xA;并发控制&#xA;    封锁&#xA;        排他锁(X)&#xA;        共享锁(S)&#xA;    协议&#xA;        一级: 加X锁&#xA;        二级: 加S锁，读完后释放&#xA;        三级: 加S锁，事务结束释放&#xA;        两段: 封锁阶段(扩展)加锁，释放阶段(收缩) 解锁&#xA;            可串行化，但可能死锁&#xA;分布式数据库&#xA;    特点&#xA;        分布性、统一性、透明性&#xA;    相对集中式数据库优点&#xA;        坚固性好&#xA;        可扩充性好&#xA;        可改善性能&#xA;        自治性好&#xA;    问题&#xA;        异构数据库集成复杂&#xA;    分布透明性&#xA;        分片透明: 透明性的最高层次&#xA;        位置透明: 用户需要了解分片，但不用了解存储场地&#xA;        局部数据透明: 需要了解分片和存储场地，不必了解局部场地的数据类型 &#xA;故障恢复&#xA;    事务故障: 系统扫描日志恢复&#xA;    系统故障&#xA;        正向扫描日志，已提交的redo, 未提交的undo&#xA;        撤销队列的事务撤销&#xA;        重做队列重做&#xA;    介质故障: 装入新副本，redo&#xA;    计算机病毒: 装入新副本，redo&#xA;检查点恢复&#xA;    建立检查点时刻所有正在执行的事务清单&#xA;    找到最后一个检查点, redo, undo&#xA;备份&#xA;    物理备份: 冷备、热备&#xA;    逻辑备份&#xA;备份类型&#xA;    完全备份&#xA;    增量备份: 需要恢复上次完全备份后的所有增量&#xA;    差异备份: 每次备份上次完全备份的差异&#xA; 数据仓库&#xA;    特点&#xA;        面向主题的、集成的、相对稳定的、反映历史变化的&#xA;        数据库是面向即时的&#xA;    建立 &#xA;        自顶向下&#xA;        自底向上&#xA;        混合法&#xA;数据挖掘&#xA;    流程&#xA;        问题定义，建立数据挖掘库，分析数据，调整数据，模型化，评价和解释&#xA;    方式&#xA;        关联分析，序列分析，分类分析，聚类分析，预测，时间序列&#xA;NoSQL&#xA;    ACID&#xA;    CAP&#xA;        Consistency&#xA;        Availability&#xA;        Partition tolerance&#xA;    BASE&#xA;        Basically available&#xA;        Soft state&#xA;        Eventually consistent&#xA;    类型&#xA;        键值&#xA;        列族: 关心的是属性列，适合分析&#xA;            列族，列限定符，行键，时间戳&#xA;        文档&#xA;        图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;专业知识&#34;&gt;&#xA;  专业知识&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%93%e4%b8%9a%e7%9f%a5%e8%af%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;软件工程&#34;&gt;&#xA;  软件工程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;历史&#xA;    1960年软件危机: 价格贵、质量差、不符合用户需求、文档不完整、可维护性差&#xA;    1946-1956: 程序设计时代&#xA;    1956-1968: 程序系统时代&#xA;    1968: 软件工程时代&#xA;过程&#xA;    需求分析: 效果图&#xA;        用例图&#xA;    软件设计&#xA;        类图&#xA;        活动图&#xA;        状态图&#xA;    软件实现&#xA;    软件交付&#xA;生命周期&#xA;    定义&#xA;        定义问题、可行性研究、需求分析&#xA;    开发&#xA;        概要设计、详细设计、编码、测试&#xA;    运维&#xA;        更正性维护、适应性维护、预防性维护、完善性维护&#xA;    消亡&#xA;        报废&#xA;        遗留系统&#xA;开发方法&#xA;    开发风范分类&#xA;        自顶向下&#xA;        自底向上&#xA;    性质分类&#xA;        形式化&#xA;            基于数学，一般用于一致性检查、类型检查、有效性验证、行为预测、设计求精验证&#xA;            包括: 有限状态机、Petri网、VDM语言、Z语言等&#xA;        非形式化&#xA;            结构化: 面向过程&#xA;&#x9;&#x9;&#x9;&#x9;结构化方法&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;设计&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;分析(SA, Structured Analysis)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;适用面向过程、数据流&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;数据流图DFD: 功能&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;数据流&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;存储和实体, 实体实体间必须经过加工。看输入输出是否缺失&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;分类: 写、读、输入、输出&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;加工&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;实现: 结构化语言、判定表、判定树&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;分类: 黑洞、奇迹、灰洞&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;数据存储&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;外部实体: 人、物品、其它系统&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;状态转换图STD: &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;数据字典&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;条目: 数据流、数据项、数据存储、基本加工&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;程序设计&#xA;&#x9;&#x9;&#x9;&#x9;特点&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;目标清晰&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;工作阶段化&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;文档规范&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;设计方法结构化&#xA;&#x9;&#x9;&#x9;&#x9;缺点&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;串行开发周期长&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;要求需求明确, 难以适应变化&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;很少考虑数据结构&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;要向上回溯所以要文档齐全&#xA;            面向对象&#xA;&#x9;&#x9;&#x9;&#x9;喷泉模型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;面向对象方法&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;步骤: 分析、设计、实现、维护、演化&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;特点&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;过程节点无间隙&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;迭代&#xA;&#x9;&#x9;&#x9;&#x9;V模型: 测试模型, 基准于瀑布模型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;编码: 单元测试&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;详细设计: 集成测试&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;概要设计: 系统测试&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;需求分析: 验收测试&#xA;&#x9;&#x9;&#x9;&#x9;实现: 对象标识、对象属性、对象方法、对象消息&#xA;&#x9;&#x9;&#x9;&#x9;分类: 面向对象分析OOA, 面向对象设计OOD, 面向对象程序设计OOP&#xA;&#x9;&#x9;&#x9;&#x9;方法&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Coad/Yourdon: OOA,OOD, 不需要表示法的转换&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Booch&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;开发模型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;静态模型: 逻辑模型(类图、对象图)，物理模型(模块图、进程图)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;动态模型: 状态图、顺序图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;OMT: 建模的思想&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;对象模型(对象图)，动态模型(状态图)，功能模型(DFD)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;OOSE&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;用例取代了DFD&#xA;&#x9;&#x9;&#x9;&#x9;分析&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;功能模型: 用例图(取代DFD数据流图)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;组成: 参与者、用例、通信关联&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;方法: &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;识别参与者(外部实体): 人、物、其它系统、时钟&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;合并需求获得用例 &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;细化用例描述: 用例名称、简要说明、事件流(主事件流、备选事件流)、非功能性需求、前置条件、后置条件、扩展点、优先级&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;调整用例模型: 用例间关系调整&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;包含关系(属于依赖关系): 基用例指向子用例&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;扩展关系(属于依赖关系): 扩展用例指向基用例&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;泛化关系(继承关系): 子用例指向父用例&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;行为模型: 活动图、顺序图、状态图(取代状态转换图)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;数据模型: 类图(取代ER图)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;步骤&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;定义概念类: 显而易见的类、明显无意义的类、不确定的类&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;发现类: 名词短语法&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;发现用例: 动词&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;确定类之间的关系: 形成领域模型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;关联&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;聚合、组合、&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;依赖、泛化、实现&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;为类添加职责&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;建立交互图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;设计&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;用例图表示需求&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;用例模型提炼领域模型，用例的实现用交互图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;领域模型和用例图形成类图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;包图和类图形成体系结构图&#xA;&#x9;&#x9;&#x9;构件(组件)化开发: 装配式思想&#xA;&#x9;&#x9;&#x9;&#x9;RAD快速应用开发; 基于瀑布模型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;步骤&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;规划&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;设计实现, 不断迭代&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;运行&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;不适合新技术, 因为适用性窄还好拆成熟构件&#xA;                UP/RUP统一过程模型: 基于面向对象，比较重型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;内容组织&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;核心工作过程&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;核心过程工作流&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;商业建模&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;需求&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;分析和设计&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;支持工作过程&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;测试&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;部署&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;配置和变更管理&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;项目管理&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;环境&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;时间组织&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;阶段&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;初始: 明确项目规模、评估项目风险、制定项目计划、阶段技术评审&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;细化: 确定架构、制定构建阶段计划、建立支持环境、选择构件、阶段技术评审&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;构建: 详细设计，编码、测试、集成&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;交付: 全面测试、补充文档、产品移交用户&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;迭代: 每个步骤都有迭代&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;思想&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;用例驱动&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;以架构为中心&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;迭代&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;增量&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;4+1视图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;逻辑视图: 类图、对象图、状态图、协作图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;进程(过程)视图: 活动图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;实现(开发)视图: 包图、组件图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;物理视图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;场景(用例视图)&#xA;&#x9;&#x9;&#x9;&#x9;连接件&#xA;&#x9;&#x9;&#x9;&#x9;构件和对象&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;构件: 包含对象可独立部署、是组装单元、没有外部可见状态&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;对象: 有唯一标志，具有外部可见状态，封装了自己的状态和行为&#xA;&#x9;&#x9;&#x9;&#x9;构件与类&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;构件不一定包含类，一个类只属于一个构件&#xA;&#x9;&#x9;&#x9;&#x9;构件间消息通过接口&#xA;            面向服务: 构件化开发发展而来&#xA;                SOA: 可跨平台&#xA;&#x9;&#x9;&#x9;&#x9;组成: ESB&#xA;&#x9;&#x9;&#x9;&#x9;SO方法&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;操作层&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;服务层: 操作分组&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;业务流程层: 服务编排&#xA;            原型法: 需求不明确时&#xA;                原型(演化)模型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;原型-&amp;gt;交流-&amp;gt;快速计划、构建、交付&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;优点&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;引导出高质量产品要求&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;缺点&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;用户接触未稳定功能，对开发失去信心&#xA;&#x9;&#x9;&#x9;&#x9;螺旋模型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;每一圈: 原型模型、瀑布模型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;有风险: 适用大项目复杂项目, 需要风险分析&#xA;&#x9;&#x9;&#x9;&#x9;功能划分&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;水平原型: 行为原型，用于界面&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;垂直原型: 结构化原型，用于复杂算法&#xA;&#x9;&#x9;&#x9;&#x9;结果划分&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;抛弃式: 探索式，解决需求不确定性&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;演化式: 逐步演化，用于易于升级和优化的场合&#xA;            敏捷: 小和快&#xA;&#x9;&#x9;&#x9;&#x9;特点&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;以人为本&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;与用户协作&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;面对面沟通&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;尽早发布增量&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;小而自主的团队&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;规模小的项目&#xA;                极限编程XP&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;特点&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;更短的周期，更早反馈&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;迭代的计划编制&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;测试先行, 自动测试来监控开发进度, 口头交流&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;团队紧密合作&#xA;                并列争求法Scrum&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;product backlog -&amp;gt; sprint backlog&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sprint周期4周&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;daily meeting&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;燃尽图&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;评审会&#xA;&#x9;&#x9;开发方法与开发模型&#xA;&#x9;&#x9;&#x9;开发方法为指导思想, 可以多模型&#xA;&#x9;&#x9;&#x9;开发模型为图形化表示，具体开发过程&#xA;    适用范围分类&#xA;        整体性方法&#xA;        局部性方法&#xA;过程管理&#xA;&#x9;人员、技术设备、过程&#xA;&#x9;能力成熟度模型CMM&#xA;&#x9;&#x9;初始级&#xA;&#x9;&#x9;可重复级: 有项目管理过程，对成、进度、功能跟踪&#xA;&#x9;&#x9;已定义级: 文档化、标准化，形成标准软件过程&#xA;&#x9;&#x9;已管理级: 可预测，软件过程和产品质量有度量标准&#xA;&#x9;&#x9;优化级: 持续改进&#xA;&#x9;能力成熟度模型集成CMMI&#xA;&#x9;&#x9;初始级&#xA;&#x9;&#x9;已管理级: 有监督和控制&#xA;&#x9;&#x9;已定义级: 更严谨更积极的管理&#xA;&#x9;&#x9;已量化级: 可预测性高&#xA;&#x9;&#x9;持续优化级: 过程与技术改进，关注整体绩效&#xA;&#x9;连续式模型&#xA;&#x9;&#x9;CL0未完成级: 未执行&#xA;&#x9;&#x9;CL1已执行级: 特定目标&#xA;&#x9;&#x9;CL2已管理级: 管理过程制度化 &#xA;&#x9;&#x9;CL3已定义级: 已定义过程的制度化&#xA;&#x9;&#x9;CL4定量管理级: 可定量管理的过程的制度化&#xA;&#x9;&#x9;CL5优化级: 使用量化(统计学)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;系统分析&#34;&gt;&#xA;  系统分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;初始需求 -&amp;gt; 逻辑模型，产出系统需求规格说明书&#xA;步骤&#xA;&#x9;详细调查: 收集资料、开调查会、个别访问、书面调查、抽样调查、现场观摩、参加业务实践&#xA;&#x9;现有系统分析: 获得物理模型，建立逻辑模型，建立新系统逻辑模型、推出新系统物理模型&#xA;&#x9;组织结构分析: 组织结构图，组织结构调查&#xA;&#x9;系统功能分析: 功能体系图，功能流程图&#xA;&#x9;业务流程分析: 价值链分析法，客户关系分析，供应链分析法，基于ERP的分析法，业务流程重组&#xA;&#x9;业务流程建模&#xA;&#x9;&#x9;建模方式&#xA;&#x9;&#x9;&#x9;自顶向下: 企业任务目标出发&#xA;&#x9;&#x9;&#x9;自底向上: 分析现有系统&#xA;&#x9;&#x9;描述方法&#xA;&#x9;&#x9;&#x9;形式化描述: 严谨可读性差&#xA;&#x9;&#x9;&#x9;图示化描述&#xA;&#x9;&#x9;建模方法&#xA;&#x9;&#x9;&#x9;标杆瞄准&#xA;&#x9;&#x9;&#x9;IDEF&#xA;&#x9;&#x9;&#x9;DEMO: 交互模型、业务流程模型、事务模型、行为模型、事实模型、互约束模型&#xA;&#x9;&#x9;&#x9;Petri: 流程&#xA;&#x9;&#x9;&#x9;业务流程建模语言(文本类和图元类): UML、BPEL(文本类)、BPML(文本类, BPMI补充了图元)、BPMN、XPDL(文本+图元)&#xA;&#x9;&#x9;&#x9;基于服务的BPM&#xA;&#x9;数据与数据流程分析&#xA;&#x9;&#x9;收集数据，分类编码排放&#xA;&#x9;&#x9;按业务流程自顶向下整理&#xA;&#x9;&#x9;分类&#xA;&#x9;&#x9;确定类型&#xA;&#x9;数据属性分析&#xA;&#x9;&#x9;静态分析: 类型、取值范围、业务量、哪些业务使用、重要程度紧急程度&#xA;&#x9;&#x9;动态分析: &#xA;&#x9;&#x9;&#x9;动态特征: 固定值属性、固定个体变动属性、随机变动属性&#xA;&#x9;存储分布&#xA;&#x9;流程分析: 与组织结构无关&#xA;&#x9;&#x9;组成: 输入、输出、流动、传递、处理、存储&#xA;&#x9;&#x9;步骤 &#xA;&#x9;&#x9;&#x9;收集输入报表、存储介质&#xA;&#x9;&#x9;&#x9;明确各处理过程的方法&#xA;&#x9;&#x9;&#x9;调查数据制作单位、报送单位、存储单位、发生频率、发生的高峰时间和高峰量&#xA;&#x9;&#x9;&#x9;数据类型、长度、取值范围&#xA;&#x9;结构化开发(SA)方法: 使用DFD&#xA;&#x9;面向对象(OO)方法: 使用对象交互，对象持久化&#xA;需求规格说明书&#xA;&#x9;设计阶段依据， 验收标准之一&#xA;结构化方法&#xA;&#x9;组成&#xA;&#x9;&#x9;结构化分析: 分解与抽象原则，数据流图, 系统逻辑模型&#xA;&#x9;&#x9;结构化设计: 模块独立性准则、软件结构优化准则&#xA;&#x9;&#x9;结构化程序设计: &#xA;&#x9;特点&#xA;&#x9;&#x9;不适合大型项目&#xA;&#x9;&#x9;要求需求清晰&#xA;结构化分析：数据流图，系统逻辑图、划清人机界限&#xA;    数据流图平衡: 数据流条数一致&#xA;        父图和子图&#xA;        子图内部&#xA;    数据字典&#xA;结构化设计: 系统结构、接口、数据、过程&#xA;    模块化&#xA;        外部特性: 接口和功能定义&#xA;        内部特性: 局部数据和程序代码&#xA;    注意点&#xA;        抽象化&#xA;            过程&#xA;            数据&#xA;            控制&#xA;        自顶向下&#xA;        信息隐蔽: 可修改性、可测试、可移植性&#xA;        模块独立&#xA;    模块原则&#xA;        模块大小适中&#xA;        扇入扇出要合理: 扇入大表示复用高，扇出大表示复杂高&#xA;        深度和宽度适当: 层数和每层的模块数&#xA;    内聚类型: 由高到低&#xA;        功能: 单一功能&#xA;        顺序: 元素相关顺序执行&#xA;        通信: 元素集中在一个数据结构的区域上&#xA;        过程: 元素相关，按次序执行&#xA;        瞬时: 在同一时间间隔内执行(如初始化)&#xA;        逻辑: 逻辑相关的一组任务&#xA;        偶然: 没有关系或松散关系的任务&#xA;    耦合类型: 由低到高&#xA;        非直接: 没有直接联系&#xA;        数据: 参数表传递简单数据&#xA;        标记: 数据结构的一部分借助接口传递&#xA;        控制: 传递的信息可以控制内部逻辑&#xA;        外部: 与软件外环境相关&#xA;        公共: 多模块引用同一全局数据区&#xA;        内容: 访问另一模块内部数据、不通过正常入口转到另一模块内部、代码重叠、一个模块多个入口&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;软件架构设计&#34;&gt;&#xA;  软件架构设计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;软件架构(体系结构)&#xA;    接入层&#xA;    网关层&#xA;    业务服务层&#xA;    支撑服务&#xA;    平台服务&#xA;    基础设施层&#xA;生命周期&#xA;    需求分析: 需求模型，软件架构模型（可追踪到需求模型）&#xA;    设计: 组成元素，体系结构描述语言ADL，4+1视图&#xA;    实现: 项目组织结构，配置管理，中间件，程序设计语言，逐步细化&#xA;    构件组装阶段、部署、后开发&#xA;基于架构的软件设计方法ABSD&#xA;    商业，功能(视角视图)，非功能(质量)&#xA;    体系结构开发模型&#xA;        需求: 需求获取，生成类图，对类进行分组，把类打包成构件，需求评审&#xA;        设计: 提出体系结构模型，映射构件，分析构件的相互作用，产生体系结构，设计评审&#xA;        文档化: 规格说明，质量设计说明书&#xA;        复审&#xA;        演化&#xA;三个基础&#xA;    功能的分解&#xA;    选择体系结构风格&#xA;    软件模板的使用&#xA;结构风格&#xA;    系统家族&#xA;        一个词汇表: 构件，连接件类型&#xA;        一组约束: 构件、连接件组合方式&#xA;    反映领域中众多系统共有的结构、语义特性&#xA;    数据流风格&#xA;        流动: 自由流动、近线性流动、有限循环流动&#xA;        类型&#xA;            批处理风格: 粒度大，顺序执行，完整传输, 延迟高，无并发&#xA;            管道过滤器风格(如编译器): 粒度小，增量传输, 实时, 可以并发&#xA;    调用返回风格&#xA;        类型&#xA;            主程序子程序(开发语言)&#xA;            面向对象&#xA;            层次&#xA;    独立构件风格&#xA;        进程通信: 点对点，异步同步，远程调用&#xA;        事件驱动: 隐式调用，分离的交互，一对多，基于事件触发器，异步&#xA;&#x9;虚拟机风格&#xA;&#x9;&#x9;解释器&#xA;&#x9;&#x9;基于规则的系统 &#xA;&#x9;仓库(数据共享)风格&#xA;&#x9;&#x9;数据库系统&#xA;&#x9;&#x9;黑板系统: 语音识别&#xA;&#x9;&#x9;超文本系统&#xA;&#x9;闭环(过程)控制: 数据流风格&#xA;&#x9;&#x9;空调，巡航系统&#xA;&#x9;C2风格: 层次架构风格&#xA;&#x9;&#x9;构件顶部底部都是连接件&#xA;特定领域软件体系结构DSSA&#xA;&#x9;层次&#xA;&#x9;&#x9;领域开发环境(领域架构师)&#xA;&#x9;&#x9;领域特定应用开发环境(应用工程师)&#xA;&#x9;&#x9;应用执行环境(操作员)&#xA;&#x9;过程&#xA;&#x9;&#x9;领域分析&#xA;&#x9;&#x9;领域设计&#xA;&#x9;&#x9;领域实现&#xA;&#x9;参与角色: 领域专家, 领域分析人员，领域设计人员，领域实现人员&#xA;二层及三层C/S架构风格&#xA;&#x9;二层：客户机，服务器&#xA;&#x9;三层: 表示层，功能层，数据层&#xA;&#x9;B/S&#xA;J2EE&#xA;&#x9;客户层：Applet&#xA;&#x9;Web层: Servlet&#xA;&#x9;业务逻辑层：EJB(Entity, Session, Message)&#xA;&#x9;持久层：ORM&#xA;多层架构优缺点&#xA;&#x9;优点&#xA;&#x9;&#x9;可以只关注某层&#xA;&#x9;&#x9;容易替换成新实现&#xA;&#x9;&#x9;降低层与无尾熊依赖&#xA;&#x9;&#x9;利于标准化&#xA;&#x9;&#x9;利于各层逻辑复用&#xA;&#x9;&#x9;扩展性强，不同层负责不同的层面&#xA;&#x9;&#x9;安全性高，用户只能通过逻辑层访问&#xA;&#x9;&#x9;项目结构更清楚，分工更明确，有利于后期的维护和升级&#xA;&#x9;缺点&#xA;&#x9;&#x9;严格的分层可能有性能问题&#xA;&#x9;&#x9;清晰的分层架构并不总容易&#xA;&#x9;MVP: View和Model没有交互，都通过Presenter&#xA;&#x9;MVVM: ViewModel双向绑定&#xA;SOA&#xA;&#x9;实现&#xA;&#x9;&#x9;注册中心，服务者，消费者&#xA;&#x9;&#x9;ESB&#xA;&#x9;&#x9;&#x9;作用&#xA;&#x9;&#x9;&#x9;&#x9;服务连接整合&#xA;&#x9;&#x9;&#x9;&#x9;描述服务元数据，服务注册管理&#xA;&#x9;&#x9;&#x9;&#x9;服务请求者提供者间传递数据, 并进行数据转换: 支持同步、异步&#xA;&#x9;&#x9;&#x9;&#x9;发现、路由、匹配、选择。安全支持、服务质量、可管理性、负载均衡&#xA;&#x9;&#x9;&#x9;技术&#xA;&#x9;&#x9;&#x9;&#x9;SOAP: 简单对象访问协议&#xA;&#x9;&#x9;&#x9;&#x9;WSDL: Web服务描述语言&#xA;&#x9;&#x9;&#x9;&#x9;UDDI: 统一描述、发现和集成&#xA;微服务&#xA;&#x9;分层&#xA;&#x9;&#x9;基础设施&#xA;&#x9;&#x9;平台服务&#xA;&#x9;&#x9;支撑服务&#xA;&#x9;&#x9;业务服务&#xA;&#x9;&#x9;网关层&#xA;&#x9;&#x9;接入层&#xA;质量属性&#xA;&#x9;特点&#xA;&#x9;&#x9;非功能性需求&#xA;&#x9;&#x9;不同的软件项目，关注不同的质量属性&#xA;&#x9;&#x9;质量属性之间可能 相互抑制   &#xA;&#x9;评价&#xA;&#x9;&#x9;性能:&#xA;&#x9;&#x9;&#x9;刺激源，刺激，制品，环境，响应，响应度量指标&#xA;&#x9;&#x9;&#x9;提升&#xA;&#x9;&#x9;&#x9;&#x9;资源需求&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;减少资源占用: 改进算法，减少计算开销&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;减少处理事件的数量: 控制事件到来的速率，控制采样频率&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;控制资源的使用: 限制执行时间，限制队列大小&#xA;&#x9;&#x9;&#x9;&#x9;资源管理&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;并发机制: 多核，多线程&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;增加资源&#xA;&#x9;&#x9;&#x9;&#x9;资源仲裁&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;先来先服务&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;固定优先级&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;动态优先：时限时间最早优先，轮转调度&#xA;&#x9;&#x9;可靠性：容错，健壮性&#xA;&#x9;&#x9;可用性&#xA;&#x9;&#x9;安全性&#xA;&#x9;&#x9;&#x9;提升&#xA;&#x9;&#x9;&#x9;&#x9;抵抗攻击 &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;身份验证，授权，维护数据机密性，维护数据完整性, 限制暴露，限制访问&#xA;&#x9;&#x9;&#x9;&#x9;检测攻击: 入侵检测&#xA;&#x9;&#x9;&#x9;&#x9;恢复: 恢复状态，识别攻击者&#xA;&#x9;&#x9;可修改性: 可维护性，可扩展性，结构重组，可移植性&#xA;&#x9;&#x9;&#x9;提升&#xA;&#x9;&#x9;&#x9;&#x9;局部化修改: 高内聚低耦合，预测变更，模块通用&#xA;&#x9;&#x9;&#x9;&#x9;防止连锁反应: 信息隐藏，维持现有接口，限制通信路径, 使用中介(数据、服务(桥接，工厂，代理))&#xA;&#x9;&#x9;&#x9;&#x9;推迟绑定时间: 运行时注册, 多态, 配置文件&#xA;&#x9;&#x9;功能性&#xA;&#x9;&#x9;可变性&#xA;&#x9;&#x9;互操作性&#xA;&#x9;质量场景组成部分: 可用性&#xA;&#x9;&#x9;刺激源: 故障(系统内部或外部)&#xA;&#x9;&#x9;刺激: 出错，系统崩溃&#xA;&#x9;&#x9;制品: 计算、存储、网络&#xA;&#x9;&#x9;环境: 正常，降级&#xA;&#x9;&#x9;响应&#xA;&#x9;&#x9;响应度量指标&#xA;&#x9;可用性提升&#xA;&#x9;&#x9;错误检测: 心跳, Ping/echo, 异常&#xA;&#x9;&#x9;错误恢复: 表决, 冗余, 检查点回滚, 下线, 事务&#xA;&#x9;&#x9;错误避免: 进程监控&#xA;&#x9;辅助条件&#xA;&#x9;&#x9;敏感点&#xA;&#x9;&#x9;权衡点&#xA;&#x9;&#x9;风险点&#xA;&#x9;架构评估&#xA;&#x9;&#x9;调查问卷/检查表&#xA;&#x9;&#x9;基于场景&#xA;&#x9;&#x9;&#x9;架构权衡分析法ATAM: 对质量属性做评价和折中&#xA;&#x9;&#x9;&#x9;&#x9;质量效应树&#xA;&#x9;&#x9;&#x9;&#x9;评估参与者: 评估小组，项目决策者，项目干系人&#xA;&#x9;&#x9;&#x9;&#x9;步骤&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;描述介绍阶段: 描述ATAM方法，描述业务动机，描述架构&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;调查分析阶段: 确定架构方法，生成质量属性效用树，分析架构方法&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;测试阶段: 讨论场景和对场景分级，分析架构方法&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;报告阶段: 讨论场景和对场景分级&#xA;&#x9;&#x9;&#x9;软件架构分析方法SAAM: 场景优先级分类&#xA;&#x9;&#x9;&#x9;成本收益分析方法CBAM&#xA;&#x9;&#x9;基于度量&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;系统设计&#34;&gt;&#xA;  系统设计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;&#x9;体系结构设计&#xA;&#x9;数据设计&#xA;&#x9;接口设计&#xA;&#x9;过程设计&#xA;结构化设计&#xA;&#x9;概要设计: 确定结构&#xA;&#x9;&#x9;模块: SC系统结构图&#xA;&#x9;&#x9;&#x9;模块，模块间调用关系与通信，模块间层次结构&#xA;&#x9;详细设计: 实现细节&#xA;&#x9;&#x9;流程设计&#xA;&#x9;&#x9;&#x9;程序流程图&#xA;&#x9;&#x9;&#x9;IPO图: 每个模块内部流程&#xA;&#x9;&#x9;&#x9;N-S图：五种控制结构(顺序型，选择型，while循环型，until循环型，多分支选择型)&#xA;&#x9;&#x9;&#x9;问题分析图PAD: 相对N-S图可以展示递归&#xA;&#x9;&#x9;&#x9;过程设计语言PDL: 伪代码&#xA;&#x9;&#x9;&#x9;判定表, 判定树&#xA;&#x9;&#x9;面向对象设计&#xA;面向对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;uml&#34;&gt;&#xA;  UML&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#uml&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;4种事务&#xA;&#x9;结构: 名词&#xA;&#x9;行为: 动词&#xA;&#x9;分组: 包&#xA;&#x9;注释: 注释&#xA;视图 &#xA;&#x9;用例图&#xA;&#x9;&#x9;参与者&#xA;&#x9;&#x9;用例: 基用例，子用例&#xA;&#x9;&#x9;边界&#xA;&#x9;&#x9;关系: 包含，扩展(基用例不一定执行子用例)，泛化&#xA;&#x9;类图&#xA;&#x9;&#x9;类：实体类(名词)，控制类(执行)，边界类(用户系统交互)&#xA;&#x9;&#x9;关系&#xA;&#x9;&#x9;&#x9;依赖&#xA;&#x9;&#x9;&#x9;泛化&#xA;&#x9;&#x9;&#x9;&#x9;多态&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;参数多态&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;包含多态: 用于子类型，需要运行时类型检查&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;强制多态: 编译时强行变类型&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;过载多态: 同名在不同上下文有不同类型&#xA;&#x9;&#x9;&#x9;关联: 双向，单向，自关联，多重关联&#xA;&#x9;&#x9;&#x9;&#x9;组合，聚合&#xA;&#x9;&#x9;&#x9;实现&#xA;&#x9;对象图&#xA;&#x9;交互图&#xA;&#x9;&#x9;序列图&#xA;&#x9;&#x9;通信图/协作图: 不强调时间&#xA;&#x9;状态图&#xA;&#x9;活动图&#xA;&#x9;构件图/组件图&#xA;&#x9;&#x9;部署构件: dll&#xA;&#x9;&#x9;工作产品构件: 源代码&#xA;&#x9;&#x9;执行构件: 执行后得到的构件&#xA;&#x9;组合结构图&#xA;&#x9;部署图&#xA;&#x9;包图&#xA;分类&#xA;&#x9;静态模型: 用例图，类图，对象图，构件图，部署图&#xA;&#x9;动态模型: 状态图，活动图，顺序图，协作图&#xA;设计模式: 类模式，对象模式&#xA;&#x9;创建型&#xA;&#x9;&#x9;工厂方法(类)&#xA;&#x9;&#x9;抽象工厂&#xA;&#x9;&#x9;建造者&#xA;&#x9;&#x9;原型&#xA;&#x9;&#x9;单例模式&#xA;&#x9;&#x9;适配器&#xA;&#x9;&#x9;桥接: 抽象与实现分离&#xA;&#x9;&#x9;组合&#xA;&#x9;&#x9;装饰&#xA;&#x9;&#x9;外观&#xA;&#x9;&#x9;享元&#xA;&#x9;&#x9;代理&#xA;&#x9;&#x9;责任链&#xA;&#x9;&#x9;解释器&#xA;&#x9;&#x9;模板方法&#xA;&#x9;&#x9;命令&#xA;&#x9;&#x9;迭代器&#xA;&#x9;&#x9;中介者&#xA;&#x9;&#x9;备忘录&#xA;&#x9;&#x9;观察者/发布订阅&#xA;&#x9;&#x9;状态&#xA;&#x9;&#x9;策略&#xA;&#x9;&#x9;访问者&#xA;&#x9;结构型&#xA;&#x9;行为型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;可靠性分析与设计&#34;&gt;&#xA;  可靠性分析与设计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e9%9d%a0%e6%80%a7%e5%88%86%e6%9e%90%e4%b8%8e%e8%ae%be%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;指标&#xA;&#x9;平均无故障时间MTTF&#xA;&#x9;平均故障修改时间MTTR&#xA;&#x9;平均故障间隔时间MTBF=MTTF+MTTR&#xA;串联系统&#xA;关联系统&#xA;冗余&#xA;&#x9;结构冗余: 硬件冗余，软件冗余&#xA;&#x9;&#x9;静态冗余: 三模冗余，多模冗余&#xA;&#x9;&#x9;&#x9;奇数个，表决器&#xA;&#x9;&#x9;动态冗余: 检测到错误用备用模块替代&#xA;&#x9;&#x9;混合冗余：先静态后动态&#xA;&#x9;信息冗余: 检错码，纠错码&#xA;&#x9;时间冗余: 重复执行&#xA;&#x9;冗余附加: 冗余资源&#xA;软件容错技术&#xA;&#x9;N版本程序设计：一种静态故障屏蔽，用前向恢复的策略&#xA;&#x9;&#x9;组，版本，表决器&#xA;&#x9;恢复块方法&#xA;&#x9;&#x9;主块，备用块&#xA;&#x9;防卫式程序设计&#xA;双机容错技术&#xA;&#x9;主设备，从设备, 故障切换&#xA;&#x9;服务器两块网卡，一块对外服务，一块与另外服务器连接&#xA;&#x9;方式&#xA;&#x9;&#x9;双机热备: 从设备不工作只监控&#xA;&#x9;&#x9;双机互备: 服务不同同时工作，可互相替代&#xA;&#x9;&#x9;双机双工: 服务相同集群方式工作&#xA;集群技术&#xA;&#x9;服务器组，对外网络，心跳信号，磁盘阵列&#xA;&#x9;类型&#xA;&#x9;&#x9;高性能计算集群&#xA;&#x9;&#x9;负载均衡集群: 集中式，分布式&#xA;&#x9;&#x9;高可用性集群&#xA;高并发下的高可用技术&#xA;&#x9;CDN&#xA;&#x9;负载均衡&#xA;&#x9;&#x9;HTTP: 重定向两次请求&#xA;&#x9;&#x9;DNS: 基于地理位置返回不同IP, 但可能缓存导致访问失败&#xA;&#x9;&#x9;NAT: 速度比反向代理快, 但大文件&#xA;&#x9;&#x9;反向代理&#xA;&#x9;负载均衡算法&#xA;&#x9;&#x9;轮询法&#xA;&#x9;&#x9;&#x9;优点：简单高效，易于水平扩展&#xA;&#x9;&#x9;&#x9;缺点：木桶原理，集群性能瓶颈于性能差的服务器&#xA;&#x9;&#x9;随机法&#xA;&#x9;&#x9;源地址hash法&#xA;&#x9;&#x9;&#x9;优点: 可干预请求方向&#xA;&#x9;&#x9;&#x9;缺点: 容易负载不均衡&#xA;&#x9;&#x9;加权轮询法&#xA;&#x9;&#x9;加权随机法&#xA;&#x9;&#x9;键值范围法&#xA;&#x9;&#x9;&#x9;优点：水平扩展容易&#xA;&#x9;&#x9;&#x9;缺点：容易负载不均衡&#xA;&#x9;&#x9;动态负载均衡&#xA;&#x9;&#x9;&#x9;最小连接数法&#xA;&#x9;&#x9;&#x9;&#x9;优点：根据节点状况实时变化 &#xA;&#x9;&#x9;&#x9;&#x9;缺点：提高了复杂度&#xA;&#x9;&#x9;&#x9;最快响应速度法&#xA;&#x9;&#x9;&#x9;观察模式法&#xA;性能评价指标&#xA;&#x9;计算机&#xA;&#x9;&#x9;主频/时钟频率&#xA;&#x9;&#x9;&#x9;外频*倍频&#xA;&#x9;&#x9;&#x9;主频的倒数: 脉冲/CPU时钟周期&#xA;&#x9;&#x9;机器周期: 若干时钟周期&#xA;&#x9;&#x9;指令周期：若干机器周期&#xA;&#x9;&#x9;CPI: 指令平均时钟周期&#xA;&#x9;&#x9;MIPS: 每秒百万条指令平均执行速度, 主频/CPI&#xA;&#x9;&#x9;阿姆达尔解决方案&#xA;&#x9;网络&#xA;&#x9;操作系统&#xA;&#x9;数据库管理系统&#xA;&#x9;Web服务器&#xA;性能评估方法&#xA;&#x9;时钟频率法&#xA;&#x9;指令执行速度法MIPS&#xA;&#x9;等效指令速度法&#xA;&#x9;数据处理速率法PDR&#xA;&#x9;综合理论性能法&#xA;&#x9;基准程序法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;软件测试&#34;&gt;&#xA;  软件测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bd%af%e4%bb%b6%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;测试目的：发现错误&#xA;测试类型&#xA;&#x9;动态&#xA;&#x9;&#x9;黑盒&#xA;&#x9;&#x9;&#x9;等价类划分: 等价的数据合并&#xA;&#x9;&#x9;&#x9;边值分析&#xA;&#x9;&#x9;&#x9;错误猜测&#xA;&#x9;&#x9;&#x9;因果图&#xA;&#x9;&#x9;&#x9;功能图&#xA;&#x9;&#x9;白盒&#xA;&#x9;&#x9;&#x9;基本路径&#xA;&#x9;&#x9;&#x9;循环覆盖&#xA;&#x9;&#x9;&#x9;&#x9;单循环，嵌套循环&#xA;&#x9;&#x9;&#x9;逻辑覆盖&#xA;&#x9;&#x9;&#x9;&#x9;语句覆盖，判定覆盖，条件覆盖，判定/条件覆盖，条件组合覆盖，点覆盖，边覆盖，路径覆盖&#xA;&#x9;&#x9;灰盒: 表征性现象，判断内部运行状态&#xA;&#x9;静态&#xA;&#x9;&#x9;桌前检查&#xA;&#x9;&#x9;代码审查&#xA;&#x9;&#x9;代码走查&#xA;测试阶段&#xA;&#x9;单元测试&#xA;&#x9;集成/组装/联合测试&#xA;&#x9;&#x9;概要设计阶段计划&#xA;&#x9;&#x9;自顶向下，自底向上，混合/三明治&#xA;&#x9;&#x9;冒烟/版本验证/提交测试&#xA;&#x9;确认测试&#xA;&#x9;&#x9;有效性测试, 需求分析阶段计划&#xA;&#x9;&#x9;类型：内部确认测试，Alpha测试，Beta测试，验收测试&#xA;&#x9;系统测试&#xA;&#x9;&#x9;软件，硬件，网络，外部支持硬件、软件、数据等系统元素结合&#xA;&#x9;&#x9;系统分析阶段(需求分析阶段)完成计划&#xA;&#x9;&#x9;包括：功能测试，健壮性测试，性能测试, 用户界面测试，安全性测试，安装与反安装测试&#xA;&#x9;&#x9;回归测试&#xA;性能测试&#xA;&#x9;目的&#xA;&#x9;&#x9;评估系统的能力，识别体系中的弱点，系统调优，检测软件中的问题，验证稳定性和可靠性&#xA;&#x9;分类&#xA;&#x9;&#x9;负载压力测试：超负荷情况&#xA;&#x9;&#x9;强度测试: 资源低的情况下运行情况&#xA;&#x9;&#x9;容量测试: 同时在线的最大用户数&#xA;&#x9;指标: 客户端，网络，服务器&#xA;第三方测试&#xA;面向对象测试&#xA;&#x9;层次&#xA;&#x9;&#x9;算法层&#xA;&#x9;&#x9;类层&#xA;&#x9;&#x9;模板层&#xA;&#x9;&#x9;系统层&#xA;&#x9;方案&#xA;&#x9;&#x9;逻辑覆盖&#xA;&#x9;&#x9;等价划分&#xA;&#x9;&#x9;边界值分析&#xA;&#x9;&#x9;错误推测&#xA;软件维护&#xA;&#x9;软件生命周期&#xA;&#x9;&#x9;规划&#xA;&#x9;&#x9;开发: 分析，设计，实施，验收&#xA;&#x9;&#x9;运维&#xA;&#x9;&#x9;解散/升级&#xA;&#x9;类型&#xA;&#x9;&#x9;改正性维护&#xA;&#x9;&#x9;适应性维护&#xA;&#x9;&#x9;完善性维护&#xA;&#x9;&#x9;预防性维护&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;安全性保密性设计&#34;&gt;&#xA;  安全性保密性设计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e5%85%a8%e6%80%a7%e4%bf%9d%e5%af%86%e6%80%a7%e8%ae%be%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;安全防范体系层次&#xA;&#x9;物理层&#xA;&#x9;系统层&#xA;&#x9;网络层&#xA;&#x9;应用层&#xA;&#x9;安全管理&#xA;数据加密&#xA;&#x9;对称加密: 分组密码，序列密码&#xA;&#x9;&#x9;DES: 分组密码, 3DES&#xA;&#x9;&#x9;IDEA: 明文密文64，密钥128&#xA;&#x9;非对称加密&#xA;&#x9;&#x9;RSA, 公私钥&#xA;&#x9;认证技术&#xA;&#x9;&#x9;确保发送者接收者的真实性，报文的完整性&#xA;&#x9;&#x9;数字签名&#xA;&#x9;&#x9;&#x9;非对称加密&#xA;&#x9;&#x9;&#x9;杂凑算法: 摘要(MD5), 安全散列算法(SHA)&#xA;&#x9;&#x9;&#x9;数字证书: X.509&#xA;&#x9;&#x9;&#x9;身份认证: 口令，动态口令，生物特征&#xA;&#x9;密钥管理体制&#xA;&#x9;&#x9;KMI密钥管理基础设施 &#xA;&#x9;&#x9;&#x9;适用于&#xA;&#x9;&#x9;&#x9;&#x9;开放网的PKI(公钥基础设施)&#xA;&#x9;&#x9;&#x9;&#x9;规模化专用网的SPK(种子化公钥)&#xA;&#x9;通信与网络安全&#xA;&#x9;&#x9;防火墙&#xA;&#x9;&#x9;&#x9;功能类型：包过滤型，电路级网关型，应用网关型，代理服务型，状态检测型，自适应代理型&#xA;&#x9;&#x9;&#x9;实现模式：宿主机模式，屏蔽主机模式，屏蔽子网模式&#xA;&#x9;&#x9;安全协议&#xA;&#x9;&#x9;&#x9;SSL&#xA;&#x9;&#x9;&#x9;HTTPS&#xA;&#x9;&#x9;&#x9;PGP: 邮件加密&#xA;&#x9;&#x9;&#x9;IPSec: 防止Sniffer、数据篡改、身份欺骗等应用层攻击、中间人攻击、拒绝服务攻击&#xA;&#x9;&#x9;入侵检测与入侵防护IDS&#xA;&#x9;&#x9;&#x9;基于数据源分类：基于主机的IDS, 基于网络的IDS&#xA;&#x9;&#x9;&#x9;基于检测方法：异常检测，误用检测&#xA;&#x9;&#x9;入侵防护系统IPS&#xA;&#x9;&#x9;访问控制&#xA;&#x9;&#x9;&#x9;自主访问控制DAC：ACL, 不能组上间接访问&#xA;&#x9;&#x9;&#x9;强制访问控制MAC &#xA;&#x9;&#x9;&#x9;基于角色的访问控制RBAC&#xA;&#x9;&#x9;&#x9;基于任务的访问控制TBAC&#xA;&#x9;&#x9;&#x9;基于对象的访问控制OBAC&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中间件&#34;&gt;&#xA;  中间件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e9%97%b4%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;功能&#xA;&#x9;客户机和之间的连接和通信&#xA;&#x9;提供应用层不同服务之间的互操作机制, 以及应用层与数据库之间的连接和控制机制&#xA;&#x9;提供多层架构的应用开发和运行平台，以及应用开发框架&#xA;&#x9;屏蔽硬件、操作系统、网络和数据库的差异&#xA;&#x9;负载均衡, 高可用&#xA;&#x9;通用的服务，避免重复工作&#xA;类型&#xA;&#x9;通信处理(消息)&#xA;&#x9;事务处理(交易)&#xA;&#x9;数据存取管理&#xA;&#x9;Web服务器&#xA;&#x9;安全&#xA;&#x9;跨平台和架构&#xA;&#x9;专用平台&#xA;&#x9;网络&#xA;应用服务器&#xA;&#x9;J2EE: 建立标准，控制构件生命周期&#xA;&#x9;&#x9;构件: 应用客户端、EJB、Servlets和JSP、Applet&#xA;&#x9;&#x9;构成：容器，组件，服务&#xA;&#x9;&#x9;分层&#xA;&#x9;&#x9;&#x9;表示层&#xA;&#x9;&#x9;&#x9;业务逻辑层(中间层、领域层)&#xA;&#x9;&#x9;&#x9;&#x9;实体Bean: 表映射到对象&#xA;&#x9;&#x9;&#x9;&#x9;会话Bean: 与客户端交互&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;有状态，无状态&#xA;&#x9;&#x9;&#x9;&#x9;消息驱动Bean&#xA;&#x9;&#x9;&#x9;数据访问层&#xA;&#x9;.NET&#xA;&#x9;&#x9;分层&#xA;&#x9;&#x9;&#x9;通用语言运行时CLR: 受控代码&#xA;&#x9;&#x9;&#x9;基础类库&#xA;&#x9;&#x9;&#x9;ADO.NET: XML支持, 数据缓冲区&#xA;&#x9;&#x9;&#x9;ASP.NET&#xA;&#x9;&#x9;&#x9;通用语言规范&#xA;企业应用集成EAI&#xA;&#x9;分类&#xA;&#x9;&#x9;应用集成&#xA;&#x9;&#x9;业务过程集成&#xA;&#x9;&#x9;数据集成: 单一数据库&#xA;&#x9;Java企业应用框架&#xA;&#x9;&#x9;MVC&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;进阶知识&#34;&gt;&#xA;  进阶知识&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e9%98%b6%e7%9f%a5%e8%af%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;信息系统基础&#34;&gt;&#xA;  信息系统基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%a1%e6%81%af%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;控制论：维纳&#xA;信息论：香农&#xA;认识论: 主观角度&#xA;质量属性：精确性，完整性，可靠性，及时性，经济性，可验证性，安全性&#xA;信息化&#xA;&#x9;层次：产品，企业，产业，国民经济，社会生活&#xA;&#x9;主体：全体社会成员&#xA;&#x9;空域：政治、经济、文化、军事、社会生活一切领域&#xA;&#x9;时域: 长期的过程&#xA;&#x9;资源是核心，信息技术应用是龙头，信息网络是基础，信息技术和产业是国家信息化建设基础，人才是关键，政策法规和标准规范是保障&#xA;战略纲要&#xA;&#x9;2017-2020：网信先行&#xA;&#x9;2025: 技术先进，产业发达，应用领先，网络安全&#xA;&#x9;21世纪中叶：网络强国，引领全球信息化发展&#xA;两化融合: 信息化和工业化&#xA;电子政务:&#xA;&#x9;G2G: 政府对政府&#xA;&#x9;G2B: 政府对企业&#xA;&#x9;G2C: 政府对公民&#xA;&#x9;G2E: 政府对公务员&#xA;电子商务&#xA;&#x9;发展&#xA;&#x9;&#x9;原始电子商务&#xA;&#x9;&#x9;现代电子商务：使用了EDI(电子数据交换)&#xA;&#x9;结构&#xA;&#x9;&#x9;网络&#xA;&#x9;&#x9;网络基础设施&#xA;&#x9;&#x9;多媒体内容和网络出版的基础设施&#xA;&#x9;&#x9;FAX, E-mail, EDI, HTTP&#xA;&#x9;&#x9;报文和信息传播的基础设施&#xA;&#x9;&#x9;目录服务、安全、认证、电子付款&#xA;&#x9;&#x9;商业服务的基础设施&#xA;&#x9;&#x9;电子商务应用&#xA;&#x9;类型&#xA;&#x9;&#x9;网络划分&#xA;&#x9;&#x9;&#x9;EDI(电子数据交换)商务&#xA;&#x9;&#x9;&#x9;Internet(互联网)商务&#xA;&#x9;&#x9;&#x9;Intranet(企业内部网)商务&#xA;&#x9;&#x9;&#x9;Extranet(企业外部网)商务&#xA;&#x9;&#x9;交易内容划分&#xA;&#x9;&#x9;&#x9;直接电子商务&#xA;&#x9;&#x9;&#x9;&#x9;无形商品&#xA;&#x9;&#x9;&#x9;&#x9;各种服务&#xA;&#x9;&#x9;&#x9;间接电子商务&#xA;&#x9;&#x9;&#x9;&#x9;有形商品&#xA;&#x9;&#x9;&#x9;&#x9;相关服务&#xA;&#x9;&#x9;交易对象规划&#xA;&#x9;&#x9;&#x9;O2O: 线上购买线下&#xA;&#x9;&#x9;&#x9;C2C: 淘宝&#xA;&#x9;&#x9;&#x9;B2C: 京东&#xA;&#x9;&#x9;&#x9;B2B&#xA;&#x9;&#x9;&#x9;&#x9;阶段: 电子数据交换(EDI), 基本的电子商务，电子交易集市，协同商务&#xA;&#x9;基本原则&#xA;&#x9;&#x9;企业主体，政府推动。统筹兼顾，虚实结合。着力创新，注重实效。规范发展，保障安全。&#xA;&#x9;支撑保障体系&#xA;企业信息化 &#xA;&#x9;大吃小变为快吃慢&#xA;&#x9;原则: 效益原则、一把手原则、中长期与短期建设相结合原则、规范化和标准化原则，以人为本原则&#xA;&#x9;&amp;quot;两网一站四库十二金&amp;quot;工程&#xA;&#x9;&#x9;政务内网(物理隔离)，政务外网(逻辑隔离)&#xA;&#x9;&#x9;中华人民共和国政府网站&#xA;&#x9;&#x9;基础信息库：人口库，法人库，资源地理，宏观经济&#xA;&#x9;&#x9;办公业务资源系统，宏观经济管理系统，金税，金审，金财，金融监管，金关，金盾，金保，金农，金水，金质&#xA;信息系统&#xA;&#x9;集成&#xA;&#x9;生命周期&#xA;&#x9;&#x9;立项&#xA;&#x9;&#x9;开发: 分析、设计、实施、验收&#xA;&#x9;&#x9;运维: 纠错性维护，适应性维护，预防性维护，完善性维护&#xA;&#x9;&#x9;消亡&#xA;IT服务管理ITSM&#xA;&#x9;低成本高质量，以服务为中心, 以客户为中心提供服务, 可准确计价&#xA;&#x9;原理：“二次转换”&#xA;&#x9;&#x9;梳理: 技术管理转化为流程管理&#xA;&#x9;&#x9;打包: 流程管理转化为服务管理&#xA;&#x9;服务级别管理SLA&#xA;&#x9;事件管理，问题管理&#xA;&#x9;监理：四控三管一协调&#xA;&#x9;&#x9;质量控制、进度控制、投资控制、变更控制&#xA;&#x9;&#x9;安全管理、合同管理、信息管理&#xA;&#x9;&#x9;项目组织协调&#xA;IT服务构成ITSS&#xA;&#x9;四要素PPTR&#xA;&#x9;&#x9;人员&#xA;&#x9;&#x9;过程&#xA;&#x9;&#x9;技术&#xA;&#x9;&#x9;资源&#xA;软件工程&#xA;&#x9;需求分析与定义&#xA;&#x9;&#x9;需求必须可以被验证&#xA;&#x9;&#x9;目标：检测和解决需求之间的冲突，发现系统的边界，详细描述系统需求&#xA;&#x9;软件设计&#xA;&#x9;软件测试&#xA;&#x9;配置管理&#xA;&#x9;&#x9;权限：Read, Check, Add, Destroy&#xA;&#x9;过程管理: 项目启动和范围定义，项目规划，项目实施、项目监控与评审、项目收发与关闭&#xA;&#x9;软件开发工具&#xA;&#x9;软件复用&#xA;&#x9;面向对象系统分析与设计&#xA;&#x9;&#x9;对象：标识、状态、行为&#xA;&#x9;UML&#xA;&#x9;&#x9;5种视图: 用例视图，逻辑视图，实现视图，过程视图，部署视图&#xA;应用集成技术&#xA;&#x9;数据仓库: 面向主题，集成的，相对稳定的，反映历史变化的&#xA;&#x9;WebService&#xA;&#x9;&#x9;不适合场景: 单机应用，局域网应用&#xA;&#x9;&#x9;适合场景: 跨防火墙，应用程序集成，B2B集成，软件重用&#xA;&#x9;软件中间件&#xA;&#x9;&#x9;数据库访问: ODBC, JDBC&#xA;&#x9;&#x9;远程过程调用RPC&#xA;&#x9;&#x9;面向消息中间件MOM: IBM的MQSeries&#xA;&#x9;&#x9;分布式对象中间件: OMG的CORBA, Java的RMI/EJB, Microsoft的DCOM&#xA;&#x9;&#x9;事务中间件: IBM/BEA的Tuxedo, JavaEE的EJB&#xA;网络技术&#xA;&#x9;OSI七层协议&#xA;&#x9;TCP/IP体系的四层协议：网络接口层，网际层，传输层，应用层&#xA;&#x9;网络分类&#xA;&#x9;&#x9;地理分类：局域网，城域网，广域网&#xA;&#x9;&#x9;链路传输控制技术：以太网(总线争用)，令牌网，FDDI网，ATM网(异步传输模式), 帧中继网，ISDN(综合业务数据网)&#xA;&#x9;&#x9;拓扑结构：总线型，星型，树型，环型，网状&#xA;&#x9;数据交换：电路交换，分组交换，ATM交换，全光交换，标记交换&#xA;&#x9;接入：光纤，同轴电缆，铜线，无线&#xA;&#x9;无线网络：无线个域网，无线局域网，无线城域网，蜂窝移动通信网&#xA;&#x9;存储技术&#xA;&#x9;&#x9;与个人计算机差异：多用户多任务&#xA;&#x9;&#x9;技术：DAS, NAS, SAN&#xA;&#x9;机房&#xA;&#x9;&#x9;综合布线系统&#xA;&#x9;&#x9;&#x9;6个子系统&#xA;&#x9;&#x9;分区: 主机区，存储器区，数据输入区，数据输出区，通信区，监控调度区&#xA;&#x9;&#x9;供电：双回路供电，三相五线制&#xA;&#x9;&#x9;接地方式: 交流工作接地，安全工作接地，直流工作接地，防雷接地&#xA;&#x9;&#x9;温湿度&#xA;&#x9;&#x9;&#x9;开机: &#xA;&#x9;&#x9;&#x9;&#x9;A级机房&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;温度: 夏季23度, 冬季20度&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;湿度: 45%-65%&#xA;&#x9;&#x9;&#x9;停机    &#xA;&#x9;RJ45接头需求量：m = nx4 + nx4x15%, m为总需求量，n为信息点总量，nx4x15%为富余量&#xA;&#x9;信息模块需求量：m = n + nx3%, m为总需求量，n为信息点总量，nx3%为富余量&#xA;&#x9;曲率半径&#xA;&#x9;&#x9;光缆30cm, 同轴粗电缆30cm, 同轴细电缆20cm&#xA;&#x9;暗敷管路&#xA;&#x9;&#x9;应直线为主&#xA;&#x9;&#x9;弯曲时曲率半径不小于管外径的6倍(暗管外径大于50mm，不小于10倍)&#xA;&#x9;&#x9;转弯夹角不小于90度，不应有两个以上弯曲(应设在弯管段落两端，长度不超过15m, 段落内不应有S形弯或U形弯)&#xA;&#x9;&#x9;段长超过20m，应装接头箱(接头盒或过渡盒)&#xA;&#x9;规划、设计和实施&#xA;&#x9;&#x9;局域网主要是交换以太网&#xA;&#x9;&#x9;拓扑结构考虑主要因素: 地理环境，传输介质，传输距离，可靠性&#xA;&#x9;&#x9;汇聚层是否存在，取决于网络规模的大小&#xA;&#x9;&#x9;网络通信设备选型：核心交换机选型，汇聚层/接入层交换机选型，远程接入与访问设备选型&#xA;&#x9;安全&#xA;&#x9;&#x9;要素: 机密性，完整性，可用性，可控性，可审查性&#xA;&#x9;&#x9;工作：制定安全策略，用户验证，加密，访问控制，审计，管理&#xA;&#x9;&#x9;典型网络攻击步骤：信息收集，试探寻找突破口，实施攻击，消防记录，保留访问权限&#xA;&#x9;&#x9;安全的5个等级：用户自主保护级，系统审计保护级, 安全标记保护级, 结构化保护级，访问验证保护级&#xA;&#x9;&#x9;基本属性：完整性，可用性，保密性，可控性，可靠性&#xA;&#x9;&#x9;活动: 定义策略，定义范围，风险评估，确定管理目标和管理措施，准备适用性申明&#xA;&#x9;&#x9;等级保护(破坏后): 定级，备案，安全建设整改，等级评测，安全检查&#xA;&#x9;&#x9;风险保护：秘密，机密，绝密&#xA;大数据&#xA;&#x9;特点5V: Volume(大量), Velocity(高速), Variety(多样), Value(价值), Veracity(真实性)&#xA;&#x9;5个环节: 数据准备，存储，计算，分析，知识展现&#xA;&#x9;关键技术: HDFS, HBase, MapReduce, Chukwa&#xA;云计算&#xA;&#x9;分层&#xA;&#x9;&#x9;设施层：供电，制冷，布线&#xA;&#x9;&#x9;资源层&#xA;&#x9;&#x9;&#x9;物理资源：服务器，存储设备，网络，数据库&#xA;&#x9;&#x9;&#x9;虚拟资源：虚拟主机，虚拟块/对象存储，虚拟网络&#xA;&#x9;&#x9;资源控制层&#xA;&#x9;&#x9;&#x9;分布式资源调度: 分布式算法，控制锁机制，消息队列&#xA;&#x9;&#x9;&#x9;资源管理: 虚拟机管理，分布式文件系统，分布式数据库&#xA;&#x9;&#x9;服务层&#xA;&#x9;&#x9;&#x9;IaaS: VDC, VDL&#xA;&#x9;&#x9;&#x9;PaaS: 开发环境，运行环境&#xA;&#x9;&#x9;&#x9;SaaS: CRM, OA&#xA;物联网&#xA;&#x9;分层&#xA;&#x9;&#x9;感知层: 物物之间信息传输&#xA;&#x9;&#x9;网络层: 标准化程序最高&#xA;&#x9;&#x9;应用层&#xA;&#x9;关键技术&#xA;&#x9;&#x9;感知层为关键&#xA;&#x9;&#x9;&#x9;产品和传感器(条码、RFID，传感器)自动化识别技术&#xA;&#x9;&#x9;&#x9;无线传输技术(WLAN, Bluetooth, ZigBee, UWB)&#xA;&#x9;&#x9;&#x9;自组织组网技术&#xA;&#x9;&#x9;&#x9;中间件技术&#xA;移动互联网: 移动通信网络+互联网内容和应用&#xA;&#x9;特征：接入移动性，时间碎片性，生活相关性，终端多样性&#xA;&#x9;关键技术: SOA Web2.0, HTML5, Android, iOS, Windows Phone&#xA;首席信息官CIO(IT行业可合并到CTO)&#xA;&#x9;业务专家，IT专家，管理专家&#xA;&#x9;职责&#xA;&#x9;&#x9;提供信息帮助企业决策&#xA;&#x9;&#x9;帮助企业制定中长期发展战略&#xA;&#x9;&#x9;有效管理IT部门&#xA;&#x9;&#x9;制定信息系统 发展规划&#xA;&#x9;&#x9;建立积极的IT文化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;##　项目管理&#xA;组成：项目开发计划，范围管理，进度管理，成本管理，软件配置管理，质量管理，人力资源管理，风险管理，信息文档管理&#xA;制约因素: 范围，进度，成本，质量&#xA;本质：认识本质，找出规律，有效管理&#xA;生命周期: 概念阶段，开发阶段，实施阶段，结束阶段&#xA;目标：成果性目标，约束性目标&#xA;开发计划&#xA;作用：展望未来，实施依据，确定团队成员和责任范围，促进团队交流，明确奋斗目标&#xA;内容：工作计划，人员组织计划，设备采购和资源供应计划，配置管理计划，进度计划，成本计划，质量计划，风险计划，文档计划，支持计划&#xA;监控：&#xA;设置里程碑&#xA;正规和非正规&#xA;事前控制，事中控制，事后控制&#xA;直接控制，间接控制&#xA;编制:&#xA;指南：引言，项目概述，实施计划，支持条件，专题计划要点&#xA;过程：逐渐求精&#xA;范围管理&#xA;产品范围(产品需求)，工作范围(工作计划)&#xA;范围管理计划4W1H&#xA;需求管理&#xA;收集需求&#xA;挖掘真实需求：显性利益，关系维护和交往，情感感受和信任&#xA;需求跟踪矩阵&#xA;从来源连接到可交付成果&#xA;用于验收&#xA;需求文件描述单一需求如何满足，用于生成范围说明书&#xA;范围说明书&#xA;工作分解结构WBS&#xA;词典&#xA;结果&#xA;范围确认：确认可交付成果&#xA;范围控制&#xA;范围变更的压力&#xA;范围蔓延&#xA;进度管理&#xA;内容&#xA;1谋: 规划进度管理&#xA;4备:&#xA;备定义出清单: 活动清单，里程碑清单&#xA;备排序出路线: 排列活动顺序&#xA;备资源出参数: 项目资源管理-估算活动资源&#xA;备历时出长短: 活动持续时间&#xA;2反复:&#xA;反复进行进度计划编制更新&#xA;反复进行进度控制与优化&#xA;进度管理计划&#xA;活动定义&#xA;活动清单&#xA;里程碑清单&#xA;活动排序&#xA;提前量滞后量&#xA;四种依赖关系&#xA;强制性依赖: 工作中固有的依赖&#xA;选择性依赖: 经验和编好定义，无必然规律&#xA;外部依赖: 项目组与项目组外&#xA;内部依赖: 项目活动之间&#xA;活动时间估算&#xA;三点估算PERT&#xA;进度计划&#xA;总时差&#xA;自由时差&#xA;浮动时间&#xA;关键路线&#xA;赶工(时间压缩)，快速跟进(改逻辑关系为并行)&#xA;资源平衡&#xA;资源平滑&#xA;进度控制&#xA;成本管理&#xA;包含：规划成本管理, 成本估算，制定预算，成本控制&#xA;概念&#xA;储备：应急储备(已知的未知, 估算阶段)，管理储备(无知, 预算阶段)&#xA;学习曲线&#xA;质量成本&#xA;成本估算&#xA;类比估算(自上而下)&#xA;自下而上&#xA;参数估算&#xA;成本预算&#xA;项目总预算 = 成本基线BAC(基础成本 + 应急储备金) + 管理储备&#xA;成本控制&#xA;挣值&#xA;实际成本(AC)，计划值(PV)，挣值(EV)&#xA;进度绩效, 成本绩效&#xA;配置管理&#xA;CMMI: 9部分&#xA;配置标识&#xA;确定配置项: 配置项命名，配置项描述&#xA;基线(里程碑): 功能基线，指派基线，产品基线; 发行基线，构造基线&#xA;建立配置管理系统&#xA;配置库：开发库，受控库，产品库&#xA;变更控制&#xA;变更控制系统&#xA;变更控制委员会CCB&#xA;变更控制流程&#xA;利用配置库实现变更控制&#xA;版本控制&#xA;配置审核&#xA;配置状态报告&#xA;质量管理&#xA;基础&#xA;核心概念&#xA;客户发现缺陷：代价最大&#xA;趋势和新兴实践&#xA;客户满意，持续改进，管理层责任，与供应商互利合作&#xA;概述&#xA;遵从组织质量体系QS&#xA;制定质量计划QP&#xA;实施质量管理QM, 包含QA&#xA;落实质量控制QC&#xA;坚持持续改进QI&#xA;ISO9000质量管理体系: 关注程序的高质量&#xA;八项原则&#xA;规划质量管理&#xA;质量管理体系&#xA;质量成本&#xA;一致性成本: 预防成本，评估成本&#xA;不一致性成本: 内部失败成本，外部失败成本&#xA;管理质量&#xA;质量报告&#xA;亲和图，因果图，流程图，直方图，帕累托图，矩阵图，散点图&#xA;控制质量&#xA;控制图&#xA;人力资源管理&#xA;规划资源管理&#xA;组织结构图和职位描述&#xA;责任分配矩阵RAM&#xA;估算活动资源&#xA;获取资源&#xA;资源日历&#xA;建设团队&#xA;一般成长规律BruceTuckmans模型：形成，震荡，规范，成熟，解散&#xA;权力类型：正式，惩罚，奖励，专家，参考&#xA;激励理论&#xA;马斯洛,需求层次5个：生理，安全，社会需求，尊重，自我实现&#xA;海兹伯格，激励理论：保健因素，激励因素&#xA;麦克格利格, X理论，Y理论&#xA;期望理论&#xA;Z理论&#xA;成就动机理论&#xA;冲突管理&#xA;管理学原理&#xA;彼得原理: 组织中每个人都可能朝不适合他的岗位发展&#xA;光环效应：一个人某方面好，往往被认为其他方面也好&#xA;墨菲定律&#xA;帕金森定律：无论给多少时间，事情总是要拖到最后一刻才能完成&#xA;布鲁克斯定律：为一个延误的项目增加人员，将导致更多的延误&#xA;手表定律：有两块手表且走时不相同, 就不知道时间了&#xA;KISS法则&#xA;黄金法则：你期望别人怎样对待你，你也要怎样对待别人&#xA;控制资源&#xA;风险管理&#xA;已知风险，未知风险&#xA;已知的已知风险：直接成本&#xA;已知的未知风险：应急储备&#xA;未知的未知风险：管理储备&#xA;概念&#xA;风险责任人，次生风险，残余风险，弹回计划，权变措施，风险承受力，风险临界值&#xA;概述&#xA;规则风险管理&#xA;识别风险: 风险登记册&#xA;实施定性风险分析: 优先级排序, 风险登记册&#xA;实施定量风险分析: 敏感性分析，龙卷风图，决策树分析，蒙特卡罗技术&#xA;规划风险应对&#xA;实施风险应对&#xA;监督风险&#xA;文档管理&#xA;质量等级&#xA;1级文档：最底限度文档&#xA;2级文档：内部文档&#xA;3级文档：工作文档&#xA;4级文档：正式文档&#xA;文档标准: 开发文档，产品文档，管理文档&#xA;测试报告&#xA;技术报告&#xA;开发总结报告&#xA;项目管理网络图&#xA;单代号网络图(工作在节点上)&#xA;双代号网络图(工作在线上)&#xA;关键路线&#xA;紧前工作, 紧后工作，虚工作&#xA;时标网络图&#xA;计算&#xA;最早开始，最迟开始，最早结束，最迟结束&#xA;总时差：不影响总工期, ls-es, lf-ef&#xA;自由时差: 不影响紧后工作, es-ef&#xA;施工&#xA;依次施工, 平行施工, 流水施工&#xA;压缩&#xA;有充足备用资源的工作&#xA;对质量和安全影响不大的工作&#xA;所需增加成本最少的工作&lt;/p&gt;</description>
    </item>
    <item>
      <title>这些年我做过的技术</title>
      <link>https://runout.run/docs/architect/summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/architect/summary/</guid>
      <description>&lt;p&gt;13年毕业以来，做技术有9年了。加上大学4年学计算机，已经13年的时间做技术了。虽然没什么成就，但也想学别人写出来看一看，起码也为自己的时间做一个交代。&lt;/p&gt;&#xA;&lt;h1 id=&#34;背景经历&#34;&gt;&#xA;  背景经历&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%83%8c%e6%99%af%e7%bb%8f%e5%8e%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2009年-2013年：上学幻想期。幻想的意思是，那时技术是学来玩的，大部分时间在搞Linux，安装各种多系统和发行版，配Conky, 配各种Compiz 3D桌面，安装各种攻击工具。还买了《深入Linux内核架构》、《鸟哥的Linux私房菜》、《Linux与UNIX Shell编程指南》、《算法导论》可惜最终基础没看多少，大概与牛人的差距就是从看不完这些书体现出来的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2013年-2015年: 入门乱学期。毕业后在C++与Java中做了Java。从此书变成了Java系列，还去学了Java线下课。可能天生的好奇心体现了出来，Java工作不久就用刚流行的Node.js改造了公司的消息推送程序，又学起了新兴的WebGL与Three.js。还改用Dell的平板装了Linux来开发。可能做的东西太过于玄幻，成为了公司的架构师。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2015年-2018年: 技术学习期。可能源于对各种技术的探索，走上了全栈开发的道路，用Node.js做起了Proxy和后端，全栈体系里用MongoDB做了业务库，并在前端不断寻求Web3D的应用，还扬言计算机交互必将从一维的Command和二维的Window发展到三维的3D界面，被打脸到现在。之后做了Golang的企业微服务，自我感觉到此才算学会了负起责任,真的承担了TeamLeader的责任与架构师工作，从追求各种代码的特性和代码的优雅，转到了追求设计的优雅，并开始系统研究各种中间件。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2018年-至今: 架构探索期。此期间的职位头衔是基础服务架构师、技术专家和架构师Manager。得益于知识的全面性和折腾的各种经验，主要做了几件事。一是从0到1的基础服务平台建设，二是解决中型SaaS系统开发维护中的各种问题，三是设计各种微服务系统并给咨询方出解决方案。技术方向一个是系统设计，另一个是折腾K8S和DevOps与测试的各种问题。折腾的方向似乎升级到了战略性，IoT、AI、湖仓一体、区块链、元宇宙。然后惊奇的发现技术栈竟然挺吻合，阻碍没想象中的大，大概得益于多年用Linux工作的基础和什么都折腾一下的经历。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;思维方式&#34;&gt;&#xA;  思维方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%9d%e7%bb%b4%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;业务经验很重要，各个行业的经验要小心全面的积累下来，甚至比技术更重要一些，因为它更贴近实用，也有更长久的不变性。&lt;/li&gt;&#xA;&lt;li&gt;技术实现方面设计是主题，可能设计能力是评价一个工程师最主要的方面，当然前提是有写可靠代码的能力。&lt;/li&gt;&#xA;&lt;li&gt;基础知识是演绎的关键，凡是别人说学这个有什么用的，一定要抓紧学一学。&lt;/li&gt;&#xA;&lt;li&gt;靠工具解决问题&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大型系统的提效，完善测试是关键。可能这就是所说的抓手，也是降本增效的着力点。它前边直接对应需求，后边促进运维体系和开发体系。并本身体现出系统质量。&lt;/li&gt;&#xA;&lt;li&gt;企业知识库是核心，体现知识的结构化和历史变化，降低了沟通成本并提供了信息一致性保障。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;持续关注业界解决方案，有渠道无遗漏的过重要信息，保持敏感性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;后记&#34;&gt;&#xA;  后记&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8e%e8%ae%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;互联网公司陷入增长瓶颈&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;但AI的应用发展日新月异&lt;/li&gt;&#xA;&lt;li&gt;其实元宇宙的概念很好的统一了现在科技应用的增长点，创造了需求&lt;/li&gt;&#xA;&lt;li&gt;当然马斯克代表的多行星发展的方向暂时与我没有关系&lt;/li&gt;&#xA;&lt;li&gt;量子计算似乎也有了可工业化的迹象&#xA;我首先要避免的是变成修蒸汽机的人&amp;ndash;只会解决曾经的问题。其次要成为完整的人，在技术外的场景也寻求人生的意义。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
