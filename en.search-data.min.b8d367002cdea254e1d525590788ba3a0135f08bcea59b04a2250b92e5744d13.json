[{"id":0,"href":"/posts/apple/","title":"苹果","section":"Posts","content":"伊甸的苹果、如今的苹果公司 其背后主使相同 其目的相同：创造一个本来不存在的产品，使人放不下 人放得下才得自在，放不下即达到了其它的目的，使人堕落 这个主使一直至力于渗透到人们生活中，在方方面面展示自己的标志、粉饰自己名号的形象 需要警惕 "},{"id":1,"href":"/posts/tech_dimension/","title":"科技交互升维","section":"Posts","content":" 内容形式 # DOS: 一维，按行做文字输入 Windows：二维，平台窗口 Reality：三维，模拟空间 展示形式 # 纸带：一维 显示器：二维 眼镜：三维 "},{"id":2,"href":"/posts/information/","title":"信息量","section":"Posts","content":" 随想 # 通常把认识到的时空称作4维(时间1+空间3)，即认为可观测到世界的所有信息量都在其中。 但世界的信息量不止于此，它的运作不可能是无故运动木偶般的3D动画，高维是必然存在的，是它在干预这个世界。 4维世界只是更高维世界驱动下的投影，所谓的现实世界只是可观测到的投影。 所以人本身就是高维存在的，它显然不是由4维时空驱动的。 我们从时间的维度观测，一个3维的球穿过2维的平面，它的投影是从无到有再从有到无，放大再缩小的圆。 那么递推一下，一个高维的“球”到3维的投影是什么样，可能是一个从无到有再从有到无，放大再缩小的球体。 同时，并不是所有的高维的实体，都会在3维世界产生投影，就像不是所有的3维球体，都要穿过某个2维的平面。 所以： 1 世界不是4维的，因为其背后实体是高维的，投影种类繁多不一定是4维可见，如因果、感受。 1 我们观测到的投影，其背后的实体是复杂的，它透露出的信息是引人深思的。 2 我们观测不到却能莫名感受到的，其实体也存在，只是它把信息量投影到了”感受“这个维度。 3 我们毫无体查的并非不存在，无知的边界远大于已知，”眼见为实“的观点是错误的。 4 不存在偶然现象，所谓的偶然，只是观测到的投影，从无到有出现，又从有到无消失了 "},{"id":3,"href":"/posts/note/","title":"整理笔记到github","section":"Posts","content":" 记笔记 # 由于从事软件行业，信息量大，所以养成了记笔记的习惯。 笔记可以按自己的格式和思路写自己需要的，也便于查看。网上的东西对自己来说比较杂乱。 自学的都记了下来了，工作上的少些。\n笔记变更史 # 一开始用的是linux论坛上推荐的一个工具，现在名字都忘了。 后来一直在用mybase，感觉不错，到现在有5年了。但有几个问题:\nlinux下容易打出乱码字符。 删除文档容易出bug。 格式不太好，版本7后用了html做内容，也会有些问题。 是本地数据库，没法在线备份，也不好分享。毕竟东西都放网上比较方便。 软件是收费的。（但开发者很良心，修改下软件配置就可以接着用，这个\u0026quot;bug\u0026quot;他们一直不修复） 一直在考虑有道云笔记，开始时它功能不全，没有用。现在功能不错了，我又不想用了。 因为我想自己做一个，容易满足自己的想法和维护。 除这些之外gitbook也可以考虑\nNotion的问题： 数据不能备份，数据不一定安全，不能定制化建站\n现在 # 这里是用了hugo和它的book主题，多谢它们的作者。 经过一段时间的整理，今天这个笔记可以用了，其它细节用到时再调整。\n"},{"id":4,"href":"/posts/first/","title":"博客原则","section":"Posts","content":" 博客原则 # 做有意义的分享 "},{"id":5,"href":"/docs/tool/linux/linux_program/","title":"LinuxProgram","section":"Linux","content":" 系统编程 # 进程通信 # 对象 ipc 种类 消息队列 共享内存 信号量 消息队列 错误处理 # curedump机制, 产生core文件 命令 ulimit 目录 /proc/[pid]/ fork # 介绍 子线程 epoll # 介绍 多路复用io接口，提高大量并发连接中只有少量活跃情况下系统cpu利用率 signals # 介绍 unix系统中出错时显示的错误码（通常是拼在最后） http://people.cs.pitt.edu/~alanjawi/cs449/code/shell/UnixSignals.htm SIGHUP\t1\tExit\tHangup SIGINT\t2\tExit\tInterrupt SIGQUIT\t3\tCore\tQuit SIGILL\t4\tCore\tIllegal Instruction SIGTRAP\t5\tCore\tTrace/Breakpoint Trap SIGABRT\t6\tCore\tAbort SIGEMT\t7\tCore\tEmulation Trap SIGFPE\t8\tCore\tArithmetic Exception SIGKILL\t9\tExit\tKilled SIGBUS\t10\tCore\tBus Error SIGSEGV\t11\tCore\tSegmentation Fault SIGSYS\t12\tCore\tBad System Call SIGPIPE\t13\tExit\tBroken Pipe SIGALRM\t14\tExit\tAlarm Clock SIGTERM\t15\tExit\tTerminated SIGUSR1\t16\tExit\tUser Signal 1 SIGUSR2\t17\tExit\tUser Signal 2 SIGCHLD\t18\tIgnore\tChild Status SIGPWR\t19\tIgnore\tPower Fail/Restart SIGWINCH\t20\tIgnore\tWindow Size Change SIGURG\t21\tIgnore\tUrgent Socket Condition SIGPOLL\t22\tIgnore\tSocket I/O Possible SIGSTOP\t23\tStop\tStopped (signal) SIGTSTP\t24\tStop\tStopped (user) SIGCONT\t25\tIgnore\tContinued SIGTTIN\t26\tStop\tStopped (tty input) SIGTTOU\t27\tStop\tStopped (tty output) SIGVTALRM\t28\tExit\tVirtual Timer Expired SIGPROF\t29\tExit\tProfiling Timer Expired SIGXCPU\t30\tCore\tCPU time limit exceeded SIGXFSZ\t31\tCore\tFile size limit exceeded SIGWAITING\t32\tIgnore\tAll LWPs blocked SIGLWP\t33\tIgnore\tVirtual Interprocessor Interrupt for Threads Library SIGAIO\t34\tIgnore\tAsynchronous I/O pf-kernel # 介绍 是linux kernel 的fork, pf代表post-factum, 是作者的nickname libev # libevent 介绍 是linux kernel 的fork, pf代表post-factum, 是作者的nickname "},{"id":6,"href":"/docs/tool/linux/scene/","title":"LinuxScene","section":"Linux","content":" 场景 # 路由 # 查路由表 ip ro route -n 改路由 route del -net 192.168.0.0 netmask 255.255.255.0 gw 10.146.81.117 转发 ip ro ad 192.168.0.0/24 via [主机ip] 主机配置 echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward # etc/sysctl.conf net.ipv4.ip_forward = 1 方案 # 高并发 # 查看当前TCP连接的状态和对应的连接数量： netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' # TIME_WAIT占用端口会影响后继新连接 初步优化（提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN攻击。） /etc/sysctl.conf net.ipv4.tcp_syncookies = 1 # 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 # 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 # 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭； net.ipv4.tcp_fin_timeout = 30 # 修改系統默认的 TIMEOUT 时间。 sysctl -p # 生效 大流量下的优化 # 如果你的连接数本身就很多，我们可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力 /etc/sysctl.conf net.ipv4.tcp_keepalive_time = 1200 # 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。 net.ipv4.ip_local_port_range = 10000 65000 # 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！） net.ipv4.tcp_max_syn_backlog = 8192 # 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。 net.ipv4.tcp_max_tw_buckets = 6000 # 表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默 认为180000，改为6000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。 其它参数说明 net.ipv4.tcp_max_syn_backlog = 65536 # 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。 net.core.netdev_max_backlog = 32768 # 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。 net.core.somaxconn = 32768 # web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。 net.core.wmem_default = 8388608 net.core.rmem_default = 8388608 net.core.rmem_max = 16777216 #最大socket读buffer,可参考的优化值:873200 net.core.wmem_max = 16777216 #最大socket写buffer,可参考的优化值:873200 net.ipv4.tcp_timestsmps = 0 # 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。 net.ipv4.tcp_synack_retries = 2 # 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。 net.ipv4.tcp_syn_retries = 2 # 在内核放弃建立连接之前发送SYN包的数量。 #net.ipv4.tcp_tw_len = 1 net.ipv4.tcp_tw_reuse = 1 # 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。 net.ipv4.tcp_wmem = 8192 436600 873200 # TCP写buffer,可参考的优化值: 8192 436600 873200 net.ipv4.tcp_rmem = 32768 436600 873200 # TCP读buffer,可参考的优化值: 32768 436600 873200 net.ipv4.tcp_mem = 94500000 91500000 92700000 # net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。 # net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。 # net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。 # 上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864 net.ipv4.tcp_max_orphans = 3276800 # 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。 # 如果超过这个数字，连接将即刻被复位并打印出警告信息。 # 这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值， # 更应该增加这个值(如果增加了内存之后)。 net.ipv4.tcp_fin_timeout = 30 #如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。 sysctl -w fs.file-max=12000000 sysctl -w fs.nr_open=11000000 /etc/security/limits.conf nofile=10000000 # 文件句柄数 "},{"id":7,"href":"/docs/tool/linux/linux_tool/","title":"LinuxTool","section":"Linux","content":" 辅助 # 快捷键 # ctrl alt f1/f2/... # 终端切换 帮助 # man -f # 简要介绍 -k # 通配搜索 whatis # man -f apropos # man -k 命令行 # clear pwd # 当前路径 bash -c # 执行命令字符串 set -o # 设置快捷键模式，默认emacs 快捷键 \u0026lt;Tab\u0026gt; bash补全 \u0026lt;C-c\u0026gt; 中断 \u0026lt;C-d\u0026gt; eof \u0026lt;C-tab\u0026gt; ls \u0026lt;C-l\u0026gt; clean \u0026lt;C-a\u0026gt; 移到行首 \u0026lt;C-e\u0026gt; 移到行尾 \u0026lt;C-u\u0026gt; 删除到行首 \u0026lt;C-k\u0026gt; 删除到行尾 \u0026lt;C-p\u0026gt; 上一个命令 \u0026lt;C-n\u0026gt; 下一个命令 \u0026lt;C-r\u0026gt; 查看历史 # \u0026lt;C-s\u0026gt; 向前查看历史 \u0026lt;C-s\u0026gt; 冻结 \u0026lt;C-q\u0026gt; 解冻 \u0026lt;C-t\u0026gt; 交换字符 \u0026lt;C-w\u0026gt; 删word \u0026lt;C-z\u0026gt; 暂停到后台 \u0026lt;C-\\\u0026gt; 中断 \u0026lt;C-/\u0026gt; 撤消 \u0026lt;C-_\u0026gt; 删除一行 \u0026lt;M-r\u0026gt; 取消历史变更 场景 禁用\u0026lt;C-s\u0026gt;\u0026lt;C-q\u0026gt;, 以使\u0026lt;C-s\u0026gt;变为向前查看历史 stty -ixon -ixoff stty STOP ^w # 把原\u0026lt;C-s\u0026gt;改成\u0026lt;C-w\u0026gt; zsh fish tmux session window pane ~/.tmux.conf 快捷键prefix \u0026lt;C-b\u0026gt; 系统 prefix ? # 帮助 : # 命令模式 [ # 复制模式 tmux kill-server source a session prefix d # 脱离 D # 选择脱离 r # 重绘 s # 选择 ~ # 信息历史 tmux ls attach a # 返回session -t name rename-session a switch -t a window prefix c # 新建 \u0026amp; # 关闭 , # 命名 . # 编号 w # 选择 [0-9] # 切换 n # 向后切换 p # 向前切换 l # 置换 f # 所有window查找 pane prefix \u0026quot; # 横分 % # 竖分 x # 关闭 ! # 移到新window 方向 # 切换 o # 切换到下一个 \u0026lt;C-o\u0026gt; # 向下旋转 \u0026lt;M-o\u0026gt; # 向上旋转 { # 向前置换 } # 向后转换 \u0026lt;C-方向\u0026gt; # 调整size \u0026lt;M-方向\u0026gt; # 5倍调整size 空格 # 切换布局 \u0026lt;M-[0-5]\u0026gt; # 选择布局 q # 显示编号 内置命令 source-file a screen -ls # 查看所有session -r # 进入id echo watch -n 1 -d netstat -ant # 监视 forturn # 随机名言 toilet # 彩虹字 cowsay # 牛说 source # 当前shell执行 figlet # 大写字 sl # 火车 cal 9 1752 # 打印日历 date +%Y/%m/%d/%H:%M bc maxima # 符号计算 factor # 分解质因数 expect # 为运行的脚本预填表单 o-\u0026gt; 结束 #!/usr/bin/expect spawn ssh outrun@192.168.1.103 expect \u0026quot;*password\u0026quot; send \u0026quot;asdf\\n\u0026quot; expect eof o-\u0026gt; 交互 #!/usr/bin/expect -f spawn sudo /usr/local/mysql/bin/mysqld_safe --user=mysql expect \u0026quot;*password:*\u0026quot; send -- \u0026quot;asdf\u0026quot; send -- \u0026quot;\\n\u0026quot; interact # interact留下交互, exit退出 o-\u0026gt; 后台执行 # 不要expect eof if [fork]!=0 exit disconnect script/scriptreply # 终端录制 script -t 2\u0026gt;timing.log -a output.log scriptreply timing.log output.log jobs # 后台作业 fg # 后台作业调度到前台 bg # 继续执行后台作业 nohup nohup *** \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 文字处理 # uniq # 删除重复列 cat file1 file2 # 上下拼接 paste file1 file2 # 左右拼接 -d '-' # 加分隔符 tac # 倒转行显示 wc # 统计行, 单词, 字符 grep -v grep # 过滤掉grep 常用 grep -nr --exclude-dir={.git, res, bin} 'a' . # 递归查找 xargs -d \u0026quot;\\t\u0026quot; # 定义分隔符 -t # -t打印执行的命令 -L 1 # 1行执行一次 -n 1 # 一次使用1项 -I arg1 sh -c 'echo arg1; mkdir arg1' # 执行多命令 --max-procs 0 # 并行执行，不限数量 常用 代码行数 find -name \u0026quot;*.go\u0026quot; -or -name \u0026quot;*.py\u0026quot; |xargs grep -v \u0026quot;^$\u0026quot; |wc -l 复制最近修改的文件 ls -rt | tail -4 | xargs -i cp -r {} ~/sdb/work/ryxWork/架构/ awk awk '{print $1}' awk '{cmd=\u0026quot;kubectl delete pvc \u0026quot;$1;system(cmd)}' # 按行执行命令 sed sed -i '1i\\new line' # 第一行前插入 常用 替换文本 sed -i \u0026quot;s/a/b/g\u0026quot; `grep -rl \u0026quot;a\u0026quot; ./` sort -r # reverse -n # 显示行号 more less iconv -l # 列出已知的编码 -f gbk -t utf-8 -c orig.txt -o tgt.txt # 转码 head -2 tail -2 -f paste file1 file2 # 合并两个文件或两栏内容 -d '+' # 分隔符 nano strings # 打印可打印字符 jq . a.json # 验证json格式 pv -qL 10 # 文件缓慢显示 aview # 图片文件化 媒体处理 # convert # 转换图片 convert a.jpg a.png # 转格式 -resize 1024x768 convert -resize a.jpg a1.jpg -sample 50%x50% # 缩略图 -rotate 270 # 顺时针旋转270度 -flip # 左右翻转 -paint 4 # 旋转角度 -draw # 加文字 convert -fill black -pointsize 60 -font helvetica -draw 'text 10,80 \u0026quot;A\u0026quot; ‘ a.jpg a1.jpg # 用黑色, 60磅, helvetica字体, 在位置10,80 写A -raise 5x5 # 右下增加 +raise 5x5 # 左上增加 -bordercolor red -border 5x5 # 红色边框 -mattecolor black -frame 5x5 # 黑色边框 -noise 3 # 油画 -monochrome # 噪声 -blur 80 # 高斯模糊 -flop # 底片 -negate # 黑白 -charcoal 2 # 炭笔 -spread 30 # 漩涡 -swirl 67 # 凸起 ffmpeg 系统 # 启动与任务 # grub /etc/default/grub # 设置文件 grub2-mkconfig -o /boot/grub2/grub.cfg # 使设置生效，update-grub 是debian下做的包装 upstart # 状态 waiting, starting, pre-start, spawned, post-start,running,pre-stop, stopping, killed, post-stop systemv systemd systemctl status daemon-reload # 修改service文件后重载 systemctl list-units # list known units systemctl list-unit-files # 已知的services systemctl list-sockets # list socket units ordered by the listening address systemctl enable NAME # 设置开机启动, 生成service脚本命令 systemctl disable NAME systemctl start NAME systemctl stop NAME systemctl restart NAME systemctl reload NAME service service start service restart service stop service status service --status-all chkconfig iptables on/off # 设置服务启动 --level 2345 iptables off # 查看各level服务状态 --list iptables at # 某时间运行一次 osmo # 计划任务软件 reap # 用于定时删除目录中文件，并打印日志 -h # 打印帮助信息 -t # 后台运行, 并设置时间间隔 -s # single 单次运行 cron 介绍 crond服务在systemd中被timer取代 使用 $ service crond start $ service crond stop $ service crond restart $ service crond reload # 重载配置 $ crontab crontest.cron # 添加定时任务。打印的文件在用户根目录下 $ crontab -l # 列出用户目前的crontab $ crontab -u # 设定某个用户的cron服务 $ crontab -r # 删除某个用户的cron服务 $ crontab -e # 编辑某个用户的cron服务 # crontab -u root -l 查看root的设置 /etc/crontab # 系统配置文件 /etc/cron.hourly /etc/cron.daily /etc/cron.weekly /etc/cron.monthly # 每小时、天、周、月执行的脚本 定时格式 M H D m d cmd M: 分钟（0-59）每分钟用*或者 */1表示 H: 小时（0-23） D: 天（1-31） m: 月（1-12） d: 一星期内的天（0~6，0为星期天） cmd: 如 ~/a.sh 例子 crontest.cron文件中 15,30,45,59 * * * * echo \u0026quot;aa..........\u0026quot; \u0026gt;\u0026gt; aa.txt # 每15分钟执行一次打印 0 */2 * * * date # 每两个小时 日志 # dmesg # 启动日志 rsyslog # 日志管理, syslog的实现, 在systemd中被systemd-journal取代 mcelog # machine check exception log journalctl # 日志查看 -x # 显示解释 -e # 显示到底部 -u # 指定unit名, 如kubelet --no-pager # 不输出到管道来分页 -f # 追加显示 -q # 只显示warn以上信息 --user-unit # 指定用户 --since \u0026quot;2018-03-26\u0026quot; --until \u0026quot;2018-03-26 03:00\u0026quot; 场景 journalctl -f --user-unit onedrive journalctl -xefu kubelet --no-pager 电源 # poweroff # 立即关机 shutdown -h now -h # 关机 -r # 重启 pm-suspend # 挂起电脑 halt 用户 # w # 在线用户名, 终端号, 登录时间, 空闲时间, 终端连接所有进程时间, 当前进程时间, 当前命令 id outrun # 用户信息 su 常用 切换登录 sudo -i su outrun sudo id # 用户信息, 所在组 passwd # 修改密码 useradd outrun # 创建用户 -g outrun # 指定组 -r # 是系统用户 -d /home/outrun # 指定登录目录 -u 544 # 指定id userdel -r user1 # 完全删除用户 groups user1 # 查看组 groupadd ftp # 创建组 usermod # 修改用户状态 -a -G root outrun # 加入组 -l newuser user1 # 改名 -L user1 # 锁定 -U user1 # 解锁 -d /home/ftp ftp # 改登录目录 -u 123 outrun # 修改id 内核 # uname -a # 查看版本 modprobe vboxdrv # 内核 lsmod # 显示当前系统加载的模块，如systemctl中start了的模块 dkms status 配置 # env # 查看所有环境变量 envsubst # 编译文件中环境变量 envsubst '${THREAD_NUM}' \u0026lt; decoder.conf.template \u0026gt; decoder.conf getent # 查看系统数据库中数据 group docker # 查看docker用户组 ulimit -s unlimited # 限制shell启动资源, 不限制堆栈大小 -a 显示各种限制 -u 10000 最大用户数 -n 102400 文件句柄数 -d unlimited 数据段长度 -m unlimited 内存大小 -t unlimited cpu时间 -v unlimited 虚拟内存 系统设备 # 接口查看 # lspci lsusb 显示器 # xrandr # 多显示器布局 -q # 列出所有屏幕 --verbose # 列出所有屏幕详情 --output eDP1 # 指定屏幕 --off # 禁用屏幕 --primary # 指定主显示器 --mode # 分辨率 --pos # 指定屏幕在背景板的位置, 根据各屏幕分辨率、位置算 --rotate # 旋转屏幕 normal left right inverted 声卡 # amixer set Master 100% # 调节音量 alsamixer # 调节声音 alsactl # 设置alsamixer store # 保存 restore # 加载 aplay -l /etc/asound.conf defaults.pcm.card 1 defaults.pcm.device 1 defaults.ctl.card 1 pactl 场景 默认声卡 pactl list short sources pactl list short sinks pactl set-default-source alsa_input.pci-0000_00_1b.0.analog-stereo pactl set-default-sink alsa_output.pci-0000_00_1b.0.analog-stereo 系统监控 # 综合监控 # uptime # 当前时间, 运行时间, 用户数, 系统负载 tload # 系统负载图(用字符画) top top -d 1 -p pid [,pid ...] htop 按键 h # 帮助 atop btop nmon glances netdata vmstat # 获得有关进程、swap、内存、cpu等系统信息 dstat # 定时收集系统信息 sar # 全面的系统活动情况 -u 3 5 # 查CPU负载, 3秒一次共5次 -d # 磁盘 -r # 内存 -W # SWAP -n DEV # 网络接口 -n SOCK # socket连接信息 -n TCP # TCP连接 -b # I/O速率 -q # 平均负载 lxtask # GUI监控CPU、内存 sysdig sysdig -c topprocs_cpu # 进程cpu top evt.cpu=0 # 只统计cpu0 topprocs_net # 进程带宽 top topprocs_file # 进程硬盘i/o top topfiles_bytes # 文件读写 top proc.name=httpd # 指定进程名 topfiles_time # 文件时间 top topprocs_errors # 进程error top topfiles_errors # 文件error top topscalls_time # 系统调用时间 top topscalls \u0026quot;evt.failed=true\u0026quot; # 系统调用出错 top topconns # 网络连接 top fdcount_by proc.name \u0026quot;fd.type=file\u0026quot; # 进程文件描述符 fdbytes_by fd.directory \u0026quot;fd.type=file\u0026quot; # 目录读写 top fd.filename \u0026quot;fd.directory=/tmp/\u0026quot; # /tmp目录文件 读写top fd.type # fd type i/o echo_fds \u0026quot;fd.filename=passwd\u0026quot; # 所有名为passwd文件的i/o stdout proc.name=bash # 进程标准输出 fileslower 1 # 文件i/o 大于1ms spy_users # 命令执行情况 -A # 只显示可读数据 -s 4096 # 指定 data buffer 字节 -r trace.scap # 指定trace file -pc # 详情 csysdig # 交互式工具 -vcontainers # 容器资源 -pc # 详情 内存 # slabtop # 内核片缓存信息 CPU # powertop # intel开发，找到高功率进程 mpstat # cpu统计信息 进程 # pidstat -p 434 # 进程使用资源的情况 -u 1 # CPU -r 1 # 内存 -d 1 # 磁盘 -w # 上下文切换 ps aux # 用在unix style中, BSD格式显示 ef # 用在system v style中, 标准格式显示 pstree # 进程关系 pwdx [pid] # 查看进程工作目录 ll /proc/[pid]/cwd pmap [pid] # 进程 kill 1024 -9 # 3 QUIT 退出(同ctrl + \\) # 1 HUP 终端断线 # 2 INT 中断(同ctrl + c) # 9 KILL 强制终止 # 15 TERM 终止 # 18 CONT 继续(与STOP相反, 同fg/bg) # 19 STOP 暂停(同ctrl + z) -l # 列出所有信号名称和编号 常用 删除名字的进程 ps -ef|grep -v \u0026quot;grep\u0026quot;|grep aurora/app.js |awk '{print $2}'| xargs kill -9 pkill Xorg # kill 所有包含 killall Xorg # kill 所有包含 xkill # 运行后 在xwindow点击kill窗口 网络 # 配置 # hostname nmtui # 设置网卡 nmcli # 设置网络连接 sudo nmcli c mod 'Wired connection 1' ipv4.never-default false # 解决manual ip不能设置路由的问题 wpa_supplicant iwlist # 列出无线网 iwconfig # 无线网卡设置 wifi-menu pppoe # 宽带 ifconfig 打开, 关闭网卡 ifconfig eth0 up ifconfig eth0 down 临时修改ip ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up # up表示立即激活 临时mac ifconfig enp0s20u6u3 hw ether 00:50:56:c0:00:02 虚拟网卡 ifconfig wlp7s0:1 ip netmask # 共用一个ip netctl # 配置网卡服务 route -n # 查看路由表 //添加到主机的路由 route add –host 192.168.168.110 dev eth0 route add –host 192.168.168.119 gw 192.168.168.1 //添加到网络的路由 route add –net IP netmask MASK eth0 route add –net IP netmask MASK gw IP route add –net IP/24 eth1 //添加默认网关 route add default gw IP //删除路由 route del –host 192.168.168.110 dev eth0 arp -n # 显示局域网 ip mac表 -s ip mac # 设置ip mac表 ip # 网卡与ip信息 添加路由 ip route add 10.146.81.0/24 via 10.146.81.29 配置ip段互斥的宿主机转发 服务器 ip link set up dev tun0 sysctl net.ipv4.ip_forward=1 /etc/sysctl.d/30-ipforward.conf net.ipv4.ip_forward=1 net.ipv6.conf.default.forwarding=1 net.ipv6.conf.all.forwarding=1 客户端 ip addr add 192.168.123.201/24 dev eth0 # 要转发的网段 ip link set up dev eth0 ip route add default via 192.168.123.100 dev eth0 # 服务器ip hostapd # 无线热点 yum install hostapd vi /etc/hostapd/hostapd.conf wpa_passphrase=asdfasdf ssid=myflowers interface=p3p1 yum install dhcp vi /etc/dhcp/dhcpd.conf option domain-name-servers 192.168.0.1,8.8.8.8; # 自己的dns提供商 option routers 192.168.0.42; # 本机ip option domain-name \u0026quot;mydhcp\u0026quot;; option domain-name-servers 192.168.0.1; log-facility local7; subnet 192.168.0.0 netmask 255.255.255.0 { range 192.168.0.160 192.168.0.170; option broadcast-address 192.168.0.255; } 测试工具 # ab # 压测 ab -c 10 -n 100 https://www.baidu.com/ # 10并发100次, url结尾要有/ mtr # myTrace, 合并ping与traceroute，默认发送ICMP包, 做持续探测, 避免节点波动的影响 traceroute # 做一次探测, 默认UDP包, 发包TTL值逐渐增大 -I # 使用ICMP包 ping telnet nslookup # 查域名ip dig # 域名解析 nmblookup -A ip # 查ip域名 nmap -sP ip/24 # 查看网内所有ip -p1-65535 # 扫描所有端口 常用 nmap 192.168.100.1/24 -p1-65535 nc # netcat, 功能全面 -U a.sock # 指定socket -v # 显示详情 -z # 只测试连通 -u # 使用udp o-\u0026gt; 测试udp端口 nc -vzu 127.0.0.1 1194 o-\u0026gt; 文件传输 nc -l -p 9999 | tar xf - tar cf - $(find . -name \u0026quot;*\u0026quot;) | nc -v 10.99.11.44 9999 rinetd # TCP端口转发 rinetd.conf 0.0.0.0 80 192.168.1.2 80 rinetd -c /etc/rinetd.conf simplehttp python -m SimpleHTTPServer 8080 请求工具 # curl curl -v # 详细头信息 curl -H \u0026quot;Cookie: foo=bar; baz=val\u0026quot; # 发送cookie curl -X post -k http://localhost:9090/a -H \u0026quot;Content-Type: text/plain\u0026quot; -d '{\u0026quot;name\u0026quot;: \u0026quot;a\u0026quot;}' # post请求 curl -O http://104.223.142.166/isu80 # 抓文件 wget -i filelist.txt # 下载一个文件中的所有url -x # 强制创建目录 -P # 目录prefix -r # 递归下载 -l # 最大递归深度, inf或0代表无限制 -k # 修改链接，指向本地文件 -p # 下载所有用于显示页面的资源, 如图片 -L # 只跟踪relative链接 -N # 只获取比本地新的文件 -np # 不追踪父目录 -m # 缩写-N -r -l inf --no-remove-listing --no-remove-listing # 不删除listing文件 常用 爬网站 wget -x -P curSite -r -l 100 -k -L -np http://nodeapi.ucdok.com/api/ 带cookie wget --post-data=\u0026quot;username=u1\u0026amp;password=asdf\u0026quot; --save-cookies=cookie --keep-session-cookies \u0026quot;http://www.abc.com/logging.php\u0026quot; wget -x -P curSite -r -l 1 -k -L -np --load-cookies=cookie --keep-session-cookies \u0026quot;https://www.abc.com/display/1\u0026quot; ssh ssh 10.1.10.2 -L 9901:localhost:5901 # 用ssh建tunnel访问内部端口 ssh -t -L 5900:localhost:5900 remote_host 'x11vnc -localhost -display :0' # 本机执行命令并端口映射 sshpass sshpass -p asdf ssh root@47.74.230.238 sshfs -o allow_other root@ip:~ /mnt # 挂载远程目录 scp a.txt root@ip:~ w3m # 命令行浏览器 vnc # 远程桌面 Virtual Network Computing 相关文章 linux 自带远程桌面--VNC服务配置说明 安装 yum install vnc* yum install *vnc-server* 启动 vncserver :1 登录 vncviewer # fedora 下gnome自带的vncviewer名为:Remote Desktop Viewer 输入192.168.0.62:1 # 实际端口号为5901, 如果服务号为2则为5902 或者浏览器java-plugin localhost:5801 # 需要安装java 监控 # iftop -n # 流量监控 ntop # 流量监控, web界面 # localhost:3000 -W 3001 # Loss%丢包率, Snt每秒包数, Last最近一次延迟, Avg平均值, Best最小值, Worst最大值, StDev标准差 -u # 使用udp包 --no-dns # 不对ip做域名反解析 -4 # 只用ipv4 -6 # 只用ipv6 结果 1,2,3,4 本地网络 5,6 运营商骨干网络 7,8,9,10 目标服务器本地网络 8 链路负载均衡 tcpdump -v # verbose输出 -vvv # 最详细输出 -n # 网络地址显示数字 -nn # ip和端口显示 -i # 指定网卡 -c 100 # 100条后退出 -w file1 # 保存到文件 -r file1 tcp # 从文件读取，指定tcp协议 -G 5 -w /opt/capfile-%Y_%m%d_%H%M_%S # 滚动日志 greater 200 # 报文字节大于200 host 192.168.0.1 # 包含ip port 80 # 包含端口 port !80 dst host 192.168.0.1 # 目标ip dst port 80 # 目标端口 src host src port net 192.168.0.1/32 # 包含网段 udp/tcp/icmp/igmp/arp # 指定协议 ip # ip协议 ip proto ospf # 类型为ospf的ip包 ip[9]=6 # ip包头第10字节为6（tcp协议） ether multicast # 二层类型为多播 ether src host 00:0c:29:9a:1f:4e # 二层mac 常用 tcpdump -i eth0 -vnn \\(src host 8.8.8.8 and port 80 \\) or \\(src host 10.10.10.10 and dst port 443\\) tcpdump -n tcp port 8383 -i lo and src host 183.14.132.117 iotop # 实时监视io p # 显示pid o # 只显示活跃 iostat # 负载情况 lsof -i:8080 # 列出当前系统打开的文件，必须root运行才准确 -i # 端口 -P # 显示端口号而非名称 -n # 显示ip而非域名 -i -n -P # 查看进程句柄数 nicstat # 网络流量统计 netstat -a # 显示所有 -n # 显示数字，而不是别名 -t # 仅显示tcp -u # 仅显示udp -p # 显示建立链接的程序名 -l # 仅列出listen的服务 -o # 显示timer, 如keepalive -antpu # 端口 tapestat # 磁带驱动器信息 ss # 端口，性能高 -l # listening 防火墙 # getenforce # 查看selinux状态 sestatus -v # 查看selinux状态 setenforce 0 # 临时关闭selinux 1 # 启用 ufw # ubuntu, 简化防火墙 iptables [-t 表] -命令 匹配 操作 参数 -t # 要操作的匹配表 命令 -P # 策略, INPUT等 -A # append, 添加 -I 1 # 在第2条前添加 -D 1 # delete, 删除 -R 1 # 替换 -L # list 显示 -n # 端口以数字显示 -v # verbose, 显示更多信息 -F # flush -X # 清除自定chain -Z # 清除统计数 规则 -p # 协议 -i # 指定网卡流入 -o # 指定网卡流出 -s # 来源ip, !表示排除 -d # 目标ip --sport # 源端口 --dport # 目标端口 -m # 使用模块, 会根据-p选择模块 动作 -j # 跳转 ACCEPT 四表(table) raw # 跟踪 mangle # 标记 nat # 修改ip、port filter # 过滤, 默认 五链(chain) PREROUTING FORWORD # INPUT前转发到POSTROUTING INPUT OUTPUT POSTROUTING 策略(policy) ACCEPT # 通过 REJECT # 拒绝，返回数据 返回数据包 ICMP port-unreachable ICMP echo-reply tcp-reset iptables -A INPUT -p TCP --dport 22 -j REJECT --reject-with ICMP echo-reply DROP # 丢弃 REDIRECT # 导向端口(PNAT) iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT--to-ports 8081 MASQUERADE # 改写来源ip为本机ip, 可指定目标端口范围 iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 21000-31000 LOG # 日志, 记在/var/log iptables -A INPUT -p tcp -j LOG --log-prefix \u0026quot;input packet\u0026quot; ULOG SNAT # 改写源地址, 只适用POSTROUTING iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 192.168.10.15-192.168.10.160:2100-3200 DNAT # 改写目标地址, 只适用POSTROUTING iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.10.1-192.168.10.10:80-100 TOS MIRROR # 对调源ip与目标ip后返回 QUEUE # 封包入队列待处理，实现功能如：计算联机费用 RETURN # 退出当前规则链, 返回主规则链 TTL MARK # 对包做标记数字 iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 22 规则(rule) # 自定义的条件 配置文件 /etc/sysconfig/iptables /usr/libexec/iptables/iptables.init save rules.v4 # 自定义配置 *filter :INPUT ACCEPT [186:19951] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [71:11164] -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT -A INPUT -p tcp -m tcp --dport 23 -j ACCEPT -A INPUT -p tcp -m tcp --dport 24 -j ACCEPT COMMIT 命令 systemctl enable iptables.service service iptables save service iptables restart iptables-restore \u0026lt; rules.v4 # 导入配置 案例 关iptables service iptables stop chkconfig iptables off 查看 iptables -L -n -v --line-numbers 查nat表 iptables -t nat -L flush, 生效 iptables -F service命令 service iptables save service iptables stop service iptables start service iptables restart 开机启动 /etc/network/if-pre-up.d/iptables iptables-restore \u0026lt; rules.v4 插入规则 iptables -I INPUT 2 -s 202.54.1.2 -j DROP 删除规则 iptables -D INPUT 4 开放所有input/output iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT 开放input/output tcp 22 iptables -A INPUT -p tcp --dport 22 -j ACCEPT iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT vpn转发 iptables -t nat -A POSTROUTING -s 192.168.252.0/24 -j SNAT --to-source 10.171.83.146 屏蔽私有地址 iptables -A INPUT -i eth1 -s 192.168.0.0/24 -j DROP iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP 屏蔽ip iptables -A INPUT -s 1.2.3.4 -j DROP iptables -A INPUT -s 192.168.0.0/24 -j DROP iptables -A OUTPUT -d 192.168.1.0/24 -j DROP iptables -A OUTPUT -o eth1 -d 192.168.1.0/24 -j DROP 屏蔽端口 iptables -A INPUT -p tcp -s 1.2.3.4 --dport 80 -j DROP iptables -A INPUT -i eth1 -p tcp -s 192.168.1.0/24 --dport 80 -j DROP 记录并屏蔽 iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j LOG --log-prefix \u0026quot;IP_SPOOF A: \u0026quot; iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP mac屏蔽 iptables -A INPUT -m mac --mac-source 00:0F:EA:91:04:08 -j DROP # *only accept traffic for TCP port # 8080 from mac 00:0F:EA:91:04:07 * ## iptables -A INPUT -p tcp --destination-port 22 -m mac --mac-source 00:0F:EA:91:04:07 -j ACCEPT 屏蔽icmp iptables -A INPUT -p icmp --icmp-type echo-request -j DROP iptables -A INPUT -i eth1 -p icmp --icmp-type echo-request -j DROP 开启范围端口 iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 7000:7010 -j ACCEPT 开启范围ip iptables -A INPUT -p tcp --destination-port 80 -m iprange --src-range 192.168.1.100-192.168.1.200 -j ACCEPT nat iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 123.4.5.100 # 改写来自192.168.1.0/24的包, 源ip为123.4.5.100 iptables -t nat -A PREROUTING -s 192.168.1.0/24 -i eth1 -j DNAT --to 123.4.5.100 # 改写来自192.168.1.0/24的包, 目标ip为123.4.5.100 iptables -t nat -A POSTROUTING -s 172.27.0.0/16 -d 10.0.0.1 -p tcp --dport 80 -j SNAT --to-source MASQUERADE # 改写来自172.27.0.0/16去向10.0.0.1:80的tcp包, 源ip为本机ip iptables -t nat -A PREROUTING -d 192.168.1.1 -p tcp --dport 80 -j DNAT --to-destination 10.0.0.1 # 改写去向192.168.1.1:80的tcp包, 目标ip为10.0.0.1 firewall systemctl start firewalld o-\u0026gt; ftp firewall-cmd --zone=public --add-port=20/tcp --permanent firewall-cmd --zone=public --add-port=21/tcp --permanent firewall-cmd --permanent --add-port=1000-2000/tcp firewall-cmd --complete-reload o-\u0026gt; 8080 firewall-cmd --query-port=8080/tcp --add-port=8080/tcp --permanent --zone=public --reload --get_active-zones --list-all --set-default-zone=public o-\u0026gt; firewall-cmd --permanent --remove-port=8080/tcp 存储 # 硬盘 # fdisk -l cfdisk sfdisk parted mkfs mkswap testdisk /dev/sdb1 e2fsck -a /dev/sdb1 # 修复ext2 ntfsfix -d -b /dev/sdb1 # 修复ntfs坏扇区和脏标记 fsck /dev/sda1 # 检查并修复 udisks --detach 设备编号 # 移除磁盘 mount /dev/sdb1 /mnt -o acl # 打开acl功能 -o loop x.iso # 挂载文件 -o iocharset=utf8 # 指定编码 -t vfat # 指定类型 umount -n # 执行umount却不写入 -l # lazy -f # force df -h # 已挂载分区列表 -T # 查看分区类型 blktrace # 磁盘访问情况 lsblk # 查看挂载的分区 lvs LVM逻辑卷的创建流程如下： 将一个磁盘或分区格式化为物理卷：pvcreate /dev/sdb1 将物理卷添加到一个卷组中：vgcreate linuxcast-vg /dev/sdb1 /dev/sdb2 基于卷组创建一个逻辑卷mylv：lvcreate -L 10G -n mylv linuxcast-vg 格式化逻辑卷：mkfs.ext4 /dev/linuxcast-vg/mylv 挂载使用：mount /dev/linuxcast-vg/mylv /mnt 逻辑卷查看命令： pvdisplay pvs vgdisplay vgs lvdisplay lvs 删除一个逻辑卷： lvremove /dev/linuxcast-vg/mylv 删除一个卷组： vgremove linuxcast-vg 删除一个物理卷： pvremove /dev/sda1 nfsiostat # nfs驱动器信息 cifsiostat # CIFS信息 growpart # 磁盘热扩容 文件操作 # fuser # 查看文件被谁使用 -u # 列出使用者用户名 -uk # 终止文件的所有进程 -n tcp 8080 # 列出端口的进程号 ldd /bin/ls # 查看可执行文件动态引用模块 rename 's/\\.bak$//' *.bak # 重命名 rm -rf touch -t 0712250000 file # 修改文件时间戳(YYMMDDhhmm) ls *[0-9]* -t # 时间排序 -R # 递归显示文件 -l # 详情 -S # 按大小排列 -r # reverse -h # 自动大小单位 -F # 加后缀标识类型 -Z # 显示文selinux状态 tree mkdir rmdir cd ~ - cp -r # 递归 -p # 带权限复制 -d # 保留链接 -a # -dpr mv whereis which find . maxdepth 1 -name \u0026quot;*.go\u0026quot; -type f -atime +100 # 100天未使用过的执行文件 -mtime -10 # 10天内创建或修改的文件 -exec chmod +x # 对找到的文件执行命令 -xdev # 忽略块设备 file # 探测文件类型 file 可执行文件 # 可查看是否静态编译 ln du -d 1 -h -s # 只返回汇总情况 -k # 统一单位 tar xf cfzv x.tar.gz x # 压缩 xfzv x.tar.gz # 解压 --exclude=/proc gzip x # 压缩 -d x # 解压 unzip 常用 unzip中转码 unzip -P “$(echo 中文 | iconv -f utf-8 -t gbk)” unzip-beta # 解压并转码中文 diff # 改变以匹配第二个文件 diff -y a b diff dir1 dir2 diff -uN a b \u0026gt; b.patch patch -p0 \u0026lt; b.patch patch -RE -p0 \u0026lt; b.patch diff -uNra a b \u0026gt; b.patch cd a patch -p1 \u0026lt; ../b.patch patch -RE -p1 \u0026lt; ../b.patch rsync -av --exclude=.git --exclude=logs/* ./* 192.168.0.14:/data/app/ext-marketing/ vimdiff a b mucommander # 跨平台文件管理软件 shred # 文件粉碎 rclone # 云存储同步 config # 配置向导 ls [name]: # 显示文件 lsd [name]: # 显示文件夹 copy a [name]:a # 上传 cleanup # 只保留最新版本 sync # 本地向远程同步 mount # 双向一致同步 fusermount -u /path/to/local/mount # umount rclone-browser # rclone GUI onedrive onedrive --resync 常用命令 systemctl --user enable onedrive systemctl --user start onedrive journalctl --user-unit onedrive -f 权限 # chmod ugo+rwx # u拥有者, g群组, o其他人, +添加, -删除, r读、w写、x执行 chmod a+rwx # a指所有人 chattr +i file # 改变属性 lsattr file chown -R outrun:outrun . chgrp -R outrun . getfacl # 查看一个文件的ACL设置 setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ... -b # 去掉所有acl设置 -m u:sudo:rwx filename # 配置用户权限 -m g:sudo:r-x filename # 配置组的权限 -x u:user1 filename # 删除一个ACL设置 -d -m g:sudo:rwx # 指定default chcon # 修改文件安全上下文 -R # 递归 -t # type -u # user -r # role --reference # 参照更新 chcon -R -t mysqld_db_t /data chcon -R --reference=/var/lib/mysql /data 功能软件 # 包管理 # snap list # 列已安装 info # 查看仓库所有版本 find # 搜索 install remove refresh # 更新 refresh all revert # 还原到上个版本 --revision # 指定版本 run # 运行命令 start # 运行service --enable # 开机启动 stop # 停止service save # 存配置快照 saved # 列出所有快照 rpm # 源 rpm fusion -i 安装 -e 卸载 -qa 查看安装的包名 -ql 包名, 查看安装的文件 -qc 包名, 查看软件的配置文件 pacman 命令 pacman\u0026lt;操作\u0026gt; [选项] [目标] 操作 -Q # 查询 -S # 安装 -R # 删除 -D # 数据库 -F # 文件 选项 选项-S, -R, -U -s 选项-S, -U 选项-Q -s # 搜索 -e # 明确指定的 -n # 本地的 -q # 静默 -i # 详情, 两个i显示备份文件和修改状态, 显示依赖 -l # 列出文件 -o # 显示拥有此文件的包名 选项-R -s # 递归 -c # 级联依赖此包的包 -n # 不记录备份信息 选项-S -s # 搜索 -y # 刷新, 两个y强制升级所有包数据库 -q # 静默 -u # 系统升级 -c # 清理, 一个c清理未安装包, 两个c清理所有cache 选项-D 选项-F 目标 常用 -Qeq | pacman -S - # 重新安装所有包 -S $(pacman -Qnq) # 重新安装所有包 -Ss ^ibus-* # 通配search -S $(pacman -Ssq fcitx*) # 通配安装 -R $(pacman -Qsq fcitx) # 通配删除 -Rcns plasma # 删除plasma -Rns # 删依赖并删配置 -Scc # 清除缓存 -Qii zsh # 包信息 -Ql zsh # 查看安装的文件 -Qo /bin/zsh # 查看文件属于的包 -Qdt # 查孤儿包 源 mirrors.163.com apt 源 阿里云mirror: https://developer.aliyun.com/mirror ubuntu sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list downgrade # 用于给pacman安装过后软件降级 yum list # 列出所有包 updates # 列可更新的包 installed # 列已安装 extras # 已安装但不在yum repository的包 search install remove info # 包详情 updates installed extras provides # 包文件 whatprovides 'bin/isstat' # 查看命令属性哪个包 history list redo 序号 # 重新做序号 undo 序号 # 恢复历史中执行的动作 groups list # 查看安装的组 设置代理 /etc/yum.conf proxy=http://XXX.XXX.XXX.XXX：XXXX 或 proxy=FTP://XXX.XXX.XXX.XXX:XXXX proxy_username=你的用户名 proxy_password=你的用户名的密码 编译用包 build-essential # yum中基本编译依赖包 yum install make cmake apr* autoconf automake curl-devel gcc gcc-c++ zlib-devel openssl openssl-devel pcre-devel gd kernel keyutils patch perl kernel-headers compat* mpfr cpp glibc libgomp libstdc++-devel ppl cloog-ppl keyutils-libs-devel libcom_err-devel libsepol-devel libselinux-devel krb5-devel zlib-devel libXpm* freetype libjpeg* libpng* php-common php-gd ncurses* libtool* libxml2 libxml2-devel patch freetype-devel ncurses-devel libmcrypt libtool flex pkgconfig libevent glib libgnomeui-devel dpkg # 管理deb包程序 -i # 安装 -r # 删除 pkgfile # 查看命令所需的包 编译 # :() { :|:\u0026amp; };: # fork bombmake make 注意 缩进只能用tab 命令 make make install make glide 条目里执行shell @echo $(shell $(SHELL_PATH)) o-\u0026gt; TESTS = test/*.js REPORTER = spec TIMEOUT = 10000 MOCHA_OPTS = test: @NODE_ENV=test ./node_modules/mocha/bin/mocha \\ --reporter $(REPORTER) \\ --timeout $(TIMEOUT) \\ $(MOCHA_OPTS) $(TESTS) test-cov @$(MAKE) test MOCHA_OPTS='--require blanket' REPORTER=html-cov \u0026gt; coverage.html test-all: test test-cov .PHONY: test o-\u0026gt; TESTS = $(shell ls -S `find test -type f -name \u0026quot;*.js\u0026quot; -print`) TESTTIMEOUT = 5000 MOCHA_OPTS = REPORTER = spec install: @$PYTHON=`which python2.6` NODE_ENV=test npm install test: @NODE_ENV=test ./node_modules/mocha/bin/mocha \\ --reporter $(REPORTER) \\ --timeout $(TIMEOUT) \\ $(MOCHA_OPTS) \\ $(TESTS) test-cov: @$(MAKE) test REPORTER=dot @$(MAKE) test MOCHA_OPTS='--require blanket' REPORTER=html-cov \u0026gt; coverage.html @$(MAKE) test MOCHA_OPTS='--require blanket' REPORTER=travis-cov reinstall: clean @$(MAKE) install clean: @rm -rf ./node_modules build: @./bin/combo views . .PHONY: test test-cov clean install reinstall cmake makepkg # 创建软件包 调试 # perf # 性能调优 strace # 跟踪系统调用 itrace # linux系统编程中跟踪进程的库函数调用 -S ./hello # 跟踪所有系统调用 dtrace # 应用程序动态跟踪 bpftrace # btrace2.0 gdb SystemTap # 内核动态探针 图形程序 # 桌面 # kde xfce gnome # 启动 .xinitrc exec gnome-session startx gnome3应用程序列表 /usr/share/applications 取消ctrl+alt+down/up gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-down \u0026quot;['']\u0026quot; gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-up \u0026quot;['']\u0026quot; gnome-shell alt + f2后输入lg gnome terminate ctrl + shift + c/v # 复制/粘贴 ctrl + shift + t/n # 打开新标签/新窗口 ctrl + w 或 alt + backspace # 删除最后的word ctrl + shift + w/q # 关闭当前term/所有term ctrl + shift + f/g/h # 搜索/搜索下一个/搜索上一个 ctrl + pageUp/pageDown # 切换标签 ctrl + shift + pageUp/pageDown # 移动标签 alt + 1/2/3/..../0 # 切换到第1/2/3/....../10个标签 系统快捷键 右键快捷键 shift + f10 i3 # 启动 .xinitrc exec i3 awesome # 启动 .xinitrc exec /usr/bin/awesome \u0026gt;\u0026gt; ~/.cache/awesome/stdout 2\u0026gt;\u0026gt; ~/.cache/awesome/stderr 命令 awesome awesome-client 配置 配置模板 /etc/xdg/awesome/rc.lua .config/awesome/rc.lua Variable definitions # 可定义布局优先级 Menu # 右键菜单 Wibar # 生成screen, 设壁纸 Mounse bindings # 鼠标键绑定函数 Key bindings # 快捷键 Rules # client规则, 如在哪个screen显示 Signals # client启动信号触发动作 自定义 API 文档地址 https://awesomewm.org/apidoc/ 快捷键简写 modkey # win键 Mod1 # alt gears # 工具组件 wibox # wibar widget layout beautiful # theme init(gears.filesystem.get_configuration_dir() .. \u0026quot;/themes/default/theme.lua\u0026quot;) # 主题 useless_gap = 5 # 窗口间隔 theme.lua文件 theme.wallpaper = \u0026quot;~/.config/awesome/themes/awesome-wallpaper.png\u0026quot; # 背景 naughty notify({ preset = naughty.config.presets.critical, title = \u0026quot;Oops, there were errors during startup!\u0026quot;, text = awesome.startup_errors }) menubar menu_gen hotkeys_popup awful layout tag({ \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;6\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;8\u0026quot;, \u0026quot;9\u0026quot; }, s, awful.layout.layouts[1]) key({ modkey }, \u0026quot;F12\u0026quot;, function () awful.spawn{ \u0026quot;xlock\u0026quot; } end) # 快捷键 awful.key({ \u0026quot;Mod1\u0026quot; }, \u0026quot;Escape\u0026quot;, function () awful.menu.menu_keys.down = { \u0026quot;Down\u0026quot;, \u0026quot;Alt_L\u0026quot; } awful.menu.clients({theme = { width = 250 }}, { keygrabber=true, coords={x=525, y=330} }) end), widget rules spawn(\u0026quot;firefox\u0026quot;, { tag = mouse.screen.selected_tag }) util.spawn_with_shell(\u0026quot;~/.config/awesome/autorun.sh\u0026quot;) # 随桌面启动脚本 autorun.sh #!/usr/bin/env bash # nothing to use function run { if ! pgrep $1 ; then $@\u0026amp; fi } if randr | grep -q 'eDP1 connected' ; then run xrandr --output VIRTUAL1 --off --output eDP1 --mode 1920x1080 --pos 0x720 --rotate normal --output DP1 --off --output DP2-1 --mode 2560x1080 --pos 3360x720 --rotate normal --output DP2-2 --off --output DP2-3 --off --output HDMI2 --off --output HDMI1 --primary --mode 2560x1440 --pos 1920x0 --rotate left --output DP2 --off fi run ibus-daemon -d -x run nm-applet 插件 revelation # 全局client shifty # 动态tag naughty # 通知 vicious # widgets obvious # widgets bashets # widgets 小程序 # cmatrix # 终端黑客帝国 screenfetch import # 截图 import a.png # 选取区域 -pause 3 -frame a.png # 截窗口, 延迟3秒(为了选定) xgamma -gamma .75 # 调整屏幕色值 display # 显示图片 display *.png # 幻灯片 -delay 5 # 5百分之秒切换 快捷键 空格 # 下一张 退格 # 上一张 h # 水平翻转 v # 垂直翻转 / # 顺时针翻转90度 \\ # 逆时针旋转90度 \u0026gt; # 放大 \u0026lt; # 缩小 f7 # 模糊 任务栏 # nm-applet # 联网 输入法 # fcitx ibus ibus-daemon -d -x -r # ibus后台运行 模拟 # wine winetricks # 安装wine的各种依赖 cabextract # microsoft cabinet获取工具 资源管理 # nautilus 快捷键 \u0026lt;Ctrl+L\u0026gt; # 路径编辑 \u0026lt;Ctrl+W\u0026gt; # 关闭tab \u0026lt;Ctrl+Shift+W\u0026gt; # 关闭所有tab \u0026lt;Ctrl+T\u0026gt; # 新建tab \u0026lt;F9\u0026gt; # 侧边栏 "},{"id":8,"href":"/docs/tool/ops/monitor/","title":"Monitor","section":"运维","content":" 基础 # 监控的方式 主动、被动、旁路（舆情） 监控类型 服务端监控、客户端监控 目标 全、块、准 指标 请求量、成功率、耗时 统计 # 指标 访问、访客 停留时长 跳出率 退出率 转化率 参与度 显示方式 选时间段 时序数据表 max、min、avg 埋点 通过可视化工具配置，非硬编码 第三方 友盟 百度移动 魔方 App Annie talking data 神策数据 物理机 # Load Average # 介绍 数字n表示n倍 cpu # Usage: 100% system user IO wait Saturation: 1.0core Max Core Usage: 1.0core Interrupts and Context Switches: 10k Processes: 10ops create(Forks) Runnable Blocked mem # Physical Memory: RAM(Random-Access Memory)存储器 used free buffers Virtual Memory 介绍 映射到RAM或Disk used available Swap Space used free Swap Activity swap in(read) swap out(write) disk # space 增长趋势 I/O Activity read(page in) write(page out) File Descriptors: 1Milion limit allocated I/O Latency: 5ms write read I/O Load: 3 write read network # traffic: MB/s inbound outbound Utillization Hourly: GB sent received Local Network Errors: 0ops transmit drop receive drop transmit errors TCP Retransmission segments retransmitted: 0ops retransmit ratio: 0% 应用监控 # Prometheus # 监控, go实现 Grafana # 监控 Zabbix # 分布式监控 Nagios # 监控 Ganglia Zenoss Open-falcon emq # mqtt broker, erlang开发, 管理控制台 APM # # Application Performance Management SkyWalking CAT Jaeger Pinpoint Zipkin Dapper # C# Mysql # 总览 Services: 38 Min MySQL Uptime: 20 hours Max MySQL Uptime: 2.4 years Total Current QPS: 3.4k ops Total InnoDB Buffer Pool Size: 431GiB Top Service Used Connections: 800 Top Service Used Connections: 80% Top Service Client Threads Connected: 60% Top Service Active Client Threads: 99% Top Service Threads Cached: 100% 单节点 # 总计 Uptime: 29 weeks Version: 5.7.26 Current QPS: 32 InnoDB Buffer Pool Size: 3GiB Buffer Pool Size of Total RAM: 10% Connections Connections Max Connections Max Used Connections Connections Aborted Connections Aborted Connects(attempts): 0 ops Aborted Clients(timeout): 0 ops Client Threads Clients Threads Activity Peak Threads Connected: 22 Peak Threads Running: 2 Thread Cache Thread Cache Size Threads Cached Threads Created Temporary Objects \u0026amp; Slow Queries Temporary Objects Created Tmp Tables: 5 Created Tmp Disk Tables: 0.3 Created Tmp Files: 0 Slow Queries: 0 ops Select Types \u0026amp; Sorts Select Types Select Scan: 14 ops Select Range: 4 ops Sorts Sort Rows: 1 ops Sort Scan: 0 ops Sort Range: 0 ops Table Locks \u0026amp; Questions Table Locks Immediate: 0.6 ops Table Locks Waited: 0 ops Questions: 32 Network Network Traffic Outbound: 70 KBs Inbound: 15 KBs Newtwork Usage Hourly Sent: 240 MiB Received: 52 MiB Memory System Memory: 31 GiB InnoDB Buffer Pool Data: 2 GiB InnoDB Log Buffer Size: 32 MiB Key Buffer Size: 8 MiB Query Cache Size: 1 MiB Command, Handlers, Processes Top Command Counters select: 25 set option: 4 rollback: 0.6 commit: 28 stmt_prepare: 28 stmt_execute: 28 stmt_close: 28 begin: 28 show variables: 0.2 alter_table: 0 delete: 0.2 insert: 3 replace: 0 update: 40 Top Command Counters Hourly: 100k Handlers read_md_next: 800ops write: 150ops read_key: 100ops read_next: 100ops external_lock: 60ops read_first: 13ops update: 2ops delete: 1ops read_prev: 0ops read_md: 0ops Transaction Handlers commit: 25ops rollback: 0.6 Process States idle: 20 other: 1 executing: 1 sending data: 1 statistics: 0 preparing: 0 init: 0 Query Cache Query Cache Memory query cache size: 1 MiB free memory: 1 MiB Query Cache Activity not cached: 25 queries in cache: 0 prunes: 0 Files and Tables File Openings: 0.2 Open Files: 65k Table Openings Open Cache Status Hits: 40ops Misses due to Overflows: 17 Misses: 16 Open Tables Table Open Cache: 2k Open Tables: 2k Table Definition Cache Table Definition Cache Size: 1k Open Table Definitions: 700 Opened Table Definitions: 0 Node Summary # 总计 Node Name Uptime: 1.4 years Load Average: 0.6 RAM: 32GiB Memory Available: 63% Virtual Memory: 48GiB Disk Space: 2.3TiB Min Space Available: 26% CPU Usage iowait: 28% user: 10% system: 2% CPU Saturation and Max Core Usage Normalized CPU Load: 0.8 Max Cpu Core Utilization: 30% Disk I/O and Swap Activity Disk Writes(page out): 30 MBs Disk Reads(page in): 30 MBs Swap Out(writes): 0 Network Traffic Outbound: 3MBs Inbound: 330 kBs InnoDB # 总计 Buffer Pool Size: 16GiB Buffer Pool Size of Total RAM: 52% Total Redo Log Space: 900 MiB Max Log Space Used Max Transaction History Length: 300k Data Bandwidth: 23MBs Fsync Rate: 40ops Row Lock Blocking: 0.02% Activity Row Reads: 20k Row Writes: 100 Read-Only Transactions: 0 Read-Write Transactions: 0 Transactions Information(RW): 0 Misc Transactions Information: 0 Storage Summary Tables: 1014 Data Buffer Pool Fit: 2% Avg Row Size: 900B Index Size Per Row: 700B Space Allocated: 900GiB Space Used: 900 GiB Data Length: 500 GiB Index Length: 400 GiB Estimated Rows: 600 Mil Indexing Overhead: 80% Free Space Percent: 0.4% Free: 4GiB Disk IO 总计 InnoDB Page Size: 16 KiB Avg Data Read Rq Size: 16 KiB Avg Data Write Rq Size: 20KiB Avg Log Write Rq Size: 4 KiB Data Written Per Fsync: 70 KiB Log Written Per Fsync: 20 KiB Data Read Per Row Read: 27B Data Written Per Row Written: 66 KiB Auto Extend Increment: 64MiB Double Write: ON Fast Shutdown: OFF Open Files: 2k File Use: 100% InnoDB Data I/O Data Reads: 37 ops Data Writes: 25 ops InnoDB Data Bandwidth Data Read: 10 MBs Data Written: 10 MBs InnoDB Log IO Log Written: 40 kBs Log Writes: 4 ops InnoDB FSyncs Data Fsyncs: 7 ops Log Fsyncs: 2 ops InnoDB Pending IO Pending Data Reads: 0 Pending Data Writes: 0 Pending Log Writes: 0 InnoDB Pending Fsyncs: 0 IO Objects Targets Bandwidth Targets Load Targets Read Targets Read Load Targets Write Targets Write Load Targets Read Latency IO Targtes Write Latency Reads by Page Type Writes by Page Type Buffer Pool 总计 Buffer Pool Size: 2GiB Buffer Pool Size of Total RAM NUMA Interleave Buffer Pool Activity: 215 ops BP Data BP Data Dirty BP Miss Ratio: 0.32% BP Write Buffering: 4 Pool Chunk Size: 128 MiB Buffer Pool Instances: 8 Buffer Pool Pages data: 120k free: 8k misc: 2k Buffer Pool Data data total: 2GiB Estimated Dirty Data Limit: 1GiB Data Dirty: 5MiB Buffer Pool Page Activity: Pages Read: 40 ops Pages Written: 20 ops Pages Created: 3 ops Buffer Pool Requests read requests: 10k ops wite requests: 200 ops Read-Ahead Pages Fetched by Linear Read Ahead: 3ops Paged Fetched by Read Ahead but Never Accessed: 0.01 ops Paged Fetched by Random Read Ahead: 0ops Buffer Pool LRU Sub-Chain Churn Buffer Pool - Replacement Management Checkpointing and Flushing Logging Locking Undo Space and Purging Page Operations Adaptive Hash Index Change Buffer Contention Misc Online Operations(MariaDB) Defragmentation Online DDL Overview # I/O Thread Running SQL Thread Running Read Only Connections Service Used Connections: 750 Service Aborted Connections: 15 Threads Service Client Threads Connected: 500 Service Active Client Threads: 25 Service Thread Cached: 55 Queries \u0026amp; Questions 总计 Top Service Queries: 9.3k ops Top Service Questions: 3k ops Top InnoDB I/O Data Reads: 99.9% Top InnoDB I/O Data Writes: 100% Top Data Fsyncs: 50% Top Service Queries: 2.5k Top Service Questions: 0.5k InnoDB I/O Top Service Data Reads: 2k rps Top Service Data Writes: 1.5k wps Top Service Data Fsyncs: 100 ops Temporary Objects Service Temporary Objects: 150 Top Service Selects Sorts Top Service Sorts: 50k Locks Top Service Table Locks: 3 ops Network 总计 Top Service Incoming Network Traffic: 10 MBs Top Service Outgoing Network Traffic: 30 MBs Service Incoming Network Traffic: 2 MBs Service Outgoing Network Traffic: 5 MBs Query Cache 总计 Top Service Used Query Cache: 99% Service Query Cache Size: 100 MiB Files 总计 Top Percentage of File Openings to Opened Files: 100% Top Percentage of Opened Files to the Limit: 0.25% Service File Openings: 250 Service Opened Files: 160 Table Openings 总计 Top Open Cache Miss Ratio: 85% Lowest Service Open Cache Hit Ratio: 60% Open and Cached Table Definitions 总计 Min Service Opened Table Definitions: 0 Top Service Opened Table Definitions: 230 ops Top Service Open Table Definitions 1.5k ops Top Open Table Definitions to Definition Cache: 100% Service Table Definition Cache: 1.5 KiB Service Opened Table Definitions: 210 ops Service Open Table Definitions: 1.4k 主从复制 # Replication Delay: 10 Binlogs Size: 10GiB Binlog Data Written Hourly Binlogs Count: 30 Binlog Cache Use Hourly: 300k Relay Log Space: 300MiB Relay Log Written Hourly Oracle # 状态: alive 活动会话(user) 进程计数 执行计数、提交计数、回滚计数 等待时间 并发等待: 200ms 提交等待: 50ms 应用等待: 50ms 网络等待: 10ms 系统I/O等待: 100ms 用户I/O等待: 1s 组态等待: 2ms scheduler等待: 500ms 表空间 表空间类型：持久、临时、重做 使用率 剩余空间: 100GB 资源利用率 branches cmtcallbk dml_locks enqueue_locks PostgreSQL # 总览 services个数 Active Connections Total Disk-Page Buffers: 32MiB Total Memory Size for Each Sort: 16MiB Total Shared Buffers: 128GiB Services Autovacuum: 100% Connections Top5 Service Connections: 600 Top5 Service Active Connections: 5 Service Idle Connections Service Active Connections Autovacuum Service Value: Yes Tuples 总计 Total: 170M ops Max Fetched: 6M ops Max Returned: 6M ops Max Inserted: 485 ops Max Updated: 560 ops Max Deleted: 371 ops Service Fetched Tuples Rate: 2M ops Service Returned Tuples Rate: 2M ops Service Inserted Tuples Rate: 100 ops Service Updated Tuples Rate: 100 ops Service Deleted Tuples Rate: 50 ops Transactions 总计 Total: 7.5k ops Max Commits: 270 ops Max Rollback: 0.2 ops Max Duration: 55 s Service Commits: 100 ops Service Rollbacks: 0.05 ops Service Duration of Active Transactions: 850 ms Service Duration of Other Transactions: 760 ms Temp Files 总计 Max Number of Temp Files: 17k Max Size of Temp Files: 178GiB Service Numbers: 17k Service Size: 178GiB Conflicts \u0026amp; Locks 总计 Total Locks: 6.5k Total Deadlocks: 0 Total Conflicts: 0 Service Locks: 100 Service Deadlocks: 0 Service Conflicts: 0 Cache Hit 总计 Min Cache Hit Ratio: 97% Max Cache Hit Ratio: 100% Service Lowest Cache Hit Ratio: 100% Canceled Queries Service Canceled Queries: 0 Blocks Operations 总计 Total Blocks Operations: 0 ops Max Blocks Writes: 0 ops Max Blocks Reads: 0 ops Servcie Blocks Reads: 0 ops Service Blocks Writes: 0 ops Buffers Operations 总计 Max Allocaetd Bufferes: 38 Service Allocated Buffers: 10 ops Service Fsync Calls by a Backend: 0 ops Service Written Directly by a Backend: 5 wps Service Written by the Background Writer: 0 wps Service Written During Checkpoints: 50 wps Checkpoint Stats 总计 Total Written Files to Disk: 140k Total Files Synchronization to Disk: 27 Service Files Synchronization to Disk: 0.1 ops Service Written Files to Disk: 400 wps "},{"id":9,"href":"/docs/architect/code/security/","title":"Security","section":"代码","content":" 服务器 # 木马 # 自变异木马 改变自身hash或将自身大量复制到不同目录, 后台运行，躲避清理 自删除 伪装成系统程序或绑定系统程序 检查 可疑进程 定时任务 启动项 /etc/init.d或service --status-all systemctl list-unit-files | grep enabled 经验 # libudev.so # 自变异，/bin/下生成随机名称命令, 启动后可远程执行命令，在/etc/init.d下创建自启动项，在/etc/crontab中添加定时任务 chmod 0000 /lib/libudev.so \u0026amp;\u0026amp; rm -rf /lib/libudev.so \u0026amp;\u0026amp; chattr +i /lib/ /etc/init.d下随机名称文件删除, /etc/rc{0,1,2,3,4,5,6,S}.d中的软链删除 /etc/crontab/gcc.sh删除 sed '/gcc.sh/d' /etc/crontab \u0026amp;\u0026amp; chmod 0000 /etc/crontab \u0026amp;\u0026amp; chattr +i /etc/crontab 删除定时任务 重启 chattr -i /lib /etc/crontab 恢复可写 DDoS # 防范方法 # 漏洞扫描 # DVWA # Damn Vulnerable Web Application，PHP + MySQL模拟Web漏洞 W3af # Web应用扫描, Python实现 OpenVAS # 扫描主机漏洞 网络隔离 # 内外网分离 登录跳板机 Web安全 # XSS # # 向网页注入代码 CSRF # # Cross-Site Request Forgery, 跨站请求伪造 SQL注入 # Hash Dos # 上传大Json Object, 利用Hash算法的伪随机性，制造Value不同但Hash碰撞的数据，耗尽CPU 上传文件脚本 # 伪造Content-Type上传静态资源，再URL访问执行 防范方法 # 验证码 # 根据滑动响应时间、拖拽速度、时间、位置、轨迹、重试次数来评估风险 信息存储 # 密码非明文保存，加salt 身份证号、手机号加\u0026quot;*\u0026quot; 联系方式显示与否用户自己配置 加密 # 对称加密 DES # 56位秘钥，已被AES取代 3DES # 做3次DES AES # 128、192、256位秘钥 Blowfish # 1到448位变长秘钥 非对称加密 RSA # DSA # 性能快于RSA，只能数字签名 ECDSA # 螺旋曲线加密算法 ECC # 256位ECC秘钥相当于3072位RSA秘钥 哈希算法 MD5 # 不再安全 SHA-1 # 不再安全 SHA-256 授权、认证 # RBAC、ABAC SSO OAuth2.0 OIDC # OpenId Connect，OAuth2上构建的身份认证 SAML # Security Assertion Markup Language 用于SSO，XML格式 定义了三个角色：委托人、身份提供者(IDP)、服务提供者(SP)。用户SP做访问控制 2FA # Two-factor authentication, 双因素认证 代码安全 # Java反序列化漏洞 # 用户输入直接反序列化，可利用Apache Commons Collections执行任意代码 数据安全 # 数据备份 # 问题定义与排查方法 # 基础 # 线上故障等级 P0 致命问题 P1 严重问题 P2 一般问题 P3 轻微问题 线上故障分类 外部依赖类 运营质量类 需求质量类 系统质量类 混沌工程 # 混沌工程画像 ApplicationData 进程Hang、Kill，启动异常，心跳异常，环境错误，包错误或损坏，配置错误、误删、获取超时 Data 系统单点，异步阻塞同步，依赖超时，依赖异常，业务线程池满，监控错误，OOM Runtime 负载均衡失效，缓存热点，缓存限流 Middleware 数据库热点，数据库宕机，数据同步延迟，数据库主备延迟，数据库连接满，数据库热点 OS CPU抢占，内存抢占，内存错乱，上下文切换 Virtualization 服务器宕机、假死，断电，超卖，混部 Storage 磁盘满、慢、坏，不可写，不可读 Networking 网络抖动、丢包、超时，网卡满，断网 工具 ChaosBlade Java # Idea Debugger Redis # MySQL # Using intersect 多余查询条件虽然命中索引，但会产生多余的索引查询使SQL变慢，应该使用唯一的单值索引 force index指定期望的索引 用count(*)不要count(1) use filesort可能会文件排序 Trace # Pinpoint记录 各开源协议 # GPL 介绍 GNU General Public License，GNU发布的通用协议，共3个版本，最新为GPLv3，Linux使用此协议 特点 发布的软件使用GPL的软件, 也要GPL LGPL 介绍 GNU Lesser General Public License，OpenOffice使用此协议 特点 类库引用可不开源，有代码修改要使用LGPL开源 AGPL 介绍 Affero General Public License。类似的协议有CPAL、OSL 特点 除发布的软件，提供服务的软件，也要AGPL BSD 介绍 Berkly Software Distribution 特点 可以自由修改，修改可再次闭源发布。只需要BSD许可协议文件，但不能使用原作者名义宣传 MPL 介绍 The Mozilla Public License 特点 可与其它授权的文件混合使用，新增代码可使用其它方式授权或闭源 使用MPL的部分，对MPL修改的部分，要MPL MIT 介绍 近1/3的开源 软件使用。如ssh, JQuery, Putty，XWindow 特点 类似BSD，可使用原作者名义推广 Apache2.0 介绍 软件有Android, Apache Web Server, Swift 特点 类似BSD，被修改的原始文件要著名版权 "},{"id":10,"href":"/docs/tool/develop/eclipse/","title":"Eclipse","section":"Develop","content":" 方案 # user library发布 项目右键 -\u0026gt; properties -\u0026gt; Deployment Assembly -\u0026gt; add -\u0026gt; javaBuild Path Entries中选择发布包 tomcat设置发布到外部 new server -\u0026gt; 直接finish 右键server -\u0026gt; open 修改server location -\u0026gt; use Tomcat installation 修改server location -\u0026gt; deploy path为webapps 修改TimeOuts -\u0026gt;所有时间为1200 java版本 window -\u0026gt; preferences -\u0026gt; java -\u0026gt; compiler window -\u0026gt; preferences -\u0026gt; java -\u0026gt; installed JREs 编码 general -\u0026gt; workspace Text file encoding general -\u0026gt; content types Text -\u0026gt; java source file defalt encoding输入UTF-8并点击update 快捷键 general -\u0026gt; editors -\u0026gt; keys content assist # 代码提示 word comletion # 代码补全 插件 # market place http://www.eclipse.org/mpc/ 在线网页 http://www.eclipse.org/mpc/archive.php 在线安装(luna) http://download.eclipse.org/mpc/releases/1.3.0/ yum eclipse-mpc subclipse yum eclipse-subclipse jdt java8 support help -\u0026gt; market place -\u0026gt; find: java 8 java 8 support for eclipse 在线安装(kepler) http://download.eclipse.org/eclipse/updates/4.3-P-builds/ 网站 http://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_For_Kepler m2e 在线 http://download.eclipse.org/technology/m2e/releases mvn项目 # 创建web 项目 maven project catalog: internal filter:webapp org.apache.maven.archetypes 项目右键 - new -\u0026gt; source folder src/main/java src/main/resources src/test/java src/test/resources # 可以在navigator中创建, 再: ## 项目右键 -\u0026gt; buildpath -\u0026gt; configure... -\u0026gt; source -\u0026gt; add folder添加以上4个source folder 修改 configure build path -\u0026gt; source 中2个source folder中的output folder src/main/java target/classes src/main/resources target/classes src/test/java target/test-classes src/test/resources target/test-classes 修改 configure build path -\u0026gt; libraries -\u0026gt; jre system library -\u0026gt; edit 右键 -\u0026gt; properties -\u0026gt;java compiler -\u0026gt; 1.8 项目右键 -\u0026gt; run as -\u0026gt; maven install #下载依赖包 右键 -\u0026gt; properties -\u0026gt; project facets -\u0026gt; convert to faceted from 选中 dynamic web module 选中 java 右边选择runtime 下面further configuration available content directory: src/main/webapp 勾选generate web.xml 右键 -\u0026gt; properties -\u0026gt; deployment assembly中配置文件发布路径 去掉test的目录 添加发布包maven dependencies 方案 修改项目名 o-\u0026gt; 修改project名 o-\u0026gt; 修改包名与test包名 o-\u0026gt; 修改配置文件, 类中的常量, (workspace配置文件[maven项目没有这些文件]) # ctrl + h 全局搜索(替换) o-\u0026gt; mvn clean o-\u0026gt; mvn install o-\u0026gt; preferences -\u0026gt; web project settings -\u0026gt; context root中修改项目名称 集成spring pom.xml中添加spring依赖 myEclipse # 假错误（problem view中删掉） 目录结构 /Common/中存储的是jar包与配置 plugins/存放插件 features/存放外观 /MyEclipse 10/中 dropins/配置自定义插件 调整format一行最大字符数 Java — Code Style — Formatter — Active profile — Edit — Line Wrapping — Maximum line width 修改，自定义alt + / 模板 包括@anthor 等等 Java — Editor — Templates 修改编码:window --\u0026gt; General --\u0026gt; Workspace Myeclipse --\u0026gt; files and editors 忽略校验:右键 --\u0026gt; myeclipse --\u0026gt; exclude from validation package Explor 中可以go into 和 up 缩小和扩大显示范围 鼠标右键 --\u0026gt;Run As --\u0026gt; Run Configuration --\u0026gt; Arguments --\u0026gt; Program Arguments 设置运行传入的参数 new 中可以生成测试文件 window --\u0026gt; preferences --\u0026gt; MyEclipse --\u0026gt; validation --\u0026gt; disableAll 取消验证 Package Explorer中什么也不显示（进入了已经关闭的包时） --\u0026gt; navigator --\u0026gt; open project 或者{workspaces}\\.metadata\\.plugins\\org.eclipse.ui.workbench\\workbench.xml文件中 搜索\u0026lt;input factoryID=\u0026quot;org.eclipse.ui.internal.model.ResourceFactory\u0026quot;，把path的值改为\u0026quot;/\u0026quot; 其它原因：window --\u0026gt; reset perspective Package Explorer 上的倒三角中：deselect working set struts2配置myeclipse编写xml文件时的提示 ## 约束文件的相对路径：struts-2.3.15.1\\src\\core\\src\\main\\resources\\struts2.0.dtd ## xml文件中声明的url：http://struts.apache.org/dtds/struts-2.0.dtd ## myeclipse中：window --\u0026gt; Preferences --\u0026gt; MyEclipse --\u0026gt; XML --\u0026gt; XML Catalog --\u0026gt; XML Catalog Entries 选中User Specified Entries --\u0026gt; 点击add ## Location中关联源码路径,Key Type 选择 URI,Key中写xml文件中声明的url 改变Package Explorer Vier中包的为分层显示方式： Package Explorer 视窗中 --\u0026gt; 点击倒三角 --\u0026gt; Package Presentation --\u0026gt; hierarchical ： 导入war文件： 新建webPorject --\u0026gt; File===》import==》General中选择Archive File --\u0026gt; Form archive file中选择要导入的项目.war -\u0026gt; 导入 ctrl + shift + t 关联源码快捷键 设置字体：eclipse preference--\u0026gt;Colors and Fonts--\u0026gt;basic--\u0026gt;Text Font--\u0026gt;edit 导入dtd/xsd约束文件:window -\u0026gt; preferences -\u0026gt; XmlCatalog -\u0026gt; add dtd直接导入文件就可以了,xsd要在添加时key的选项中补上文件名 自定义jar包library目录 项目 右键:building path -\u0026gt; addLiber-\u0026gt;user liber配置userLibery右键:building path -\u0026gt; addLiber-\u0026gt;user liber配置userLibery 只是作了外部的引用,workspace中没有包，但是别人导入时会搜索同名的userLibery自动进行配置 改javaee版本 1.修改项目中的javaee包 2.项目工程目录/settings/org.eclipse.wst.common.project.facet.core.xml/中修改javaee版本 在线安装svn Help -\u0026gt; install from site(Myeclipse2013) -\u0026gt; add -\u0026gt; url=http://subclipse.tigris.org/update_1.6.x 不选择 Subclipse -\u0026gt; Subclipse Integration for Mylyn 3.x , 其它全选 在线安装mylyn 同上，url(Myeclipse2013):http://download.eclipse.org/mylyn/snapshots/weekly 插件 # myeclipse 2013 安装svn help -\u0026gt; Install from Site -\u0026gt;add name : Svn Location : http://subclipse.tigris.org/update_1.6.x 或 http://subclipse.tigris.org/update 下一步 不要选择Subclipse选项下的Subclipse Integration for Mylyn 3.x(Optional) 一直下一步 本地安装svn插件 快捷键 # alt / ctrl shift f # 代码格式化 alt enter # 补全提示 f3 # 跳转到声明 f2 显示类或方法的全限定名 ctrl + h 多文件搜索 alt shift s alt shift z :surround with ctrl / ctrl shift / F5 F6 F7 ctrl alt 上下 alt 上下 alt shift x j ：运行 ctrl 1 显示错误红线的处理方法 ctrl t 显示继承关系 ctrl 左右 跳过单词 ctrl 上下滚屏 ctrl l 定位 输入时直接点分号就可以跳到最后 ctrl alt / 写过内容补全 字符串最后敲回车可以自动加入 + '\\n' \u0026quot;\u0026quot; ctrl shift T openType 查找类关系 ctrl shift R 查找资源文件 alt shift A 矩形操作 alt 左右 返回代码上一层，进入代码下一层 ctrl o 获得outline // TODO 标签 alt + shift + R 重构中的重命名 ctrl + shift + o 全局导包 ctrl + shift + m 局部导包 ctrl + shift + X 改为大写 ctrl + shift + g 查看方法被谁调用 ctrl + shift + h 输入类名，查看类继承关系 命令补全：syso main alt + / 代码抽取: alt + shift + M 代码自动生成get set alt + shift +s 代码自动生成 — 重写equals hashCode alt + shift + s Ctrl+1 快速修复(最经典的快捷键,就不用多说了) Ctrl+D: 删除当前行 Ctrl+Alt+↓ 复制当前行到下一行(复制增加) Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) Alt+↑ 当前行和上面一行交互位置(同上) Alt+← 前一个编辑的页面 Alt+→ 下一个编辑的页面(当然是针对上面那条来说了) Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性 Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后) Shift+Ctrl+Enter 在当前行插入空行(原理同上条) Ctrl+Q 定位到最后编辑的地方 Ctrl+L 定位在某行 (对于程序超过100的人就有福音了) Ctrl+M 最大化当前的Edit或View (再按则反之) Ctrl+/ 注释当前行,再按则取消注释 Ctrl+O 快速显示 OutLine Ctrl+T 快速显示当前类的继承结构 Ctrl+W 关闭当前Editer Ctrl+K 参照选中的Word快速定位到下一个 Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) Ctrl+/(小键盘) 折叠当前类中的所有代码 Ctrl+×(小键盘) 展开当前类中的所有代码 Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用 Alt+/来代替) Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没 有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了) Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) Ctrl+Shift+F4 关闭所有打开的Editer Ctrl+Shift+X 把当前选中的文本全部变味小写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Ctrl+Shift+F 格式化当前代码 Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反 之) 下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift 开头的了) Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力 ) Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能) Alt+Shift+I 合并变量(可能这样说有点不妥Inline) Alt+Shift+V 移动函数和变量(不怎么常用) Alt+Shift+Z 重构的后悔药(Undo) 编辑 作用域 功能 快捷键 全局 查找并替换 Ctrl+F 文本编辑器 查找上一个 Ctrl+Shift+K 文本编辑器 查找下一个 Ctrl+K 全局 撤销 Ctrl+Z 全局 复制 Ctrl+C 全局 恢复上一个选择 Alt+Shift+↓ 全局 剪切 Ctrl+X 全局 快速修正 Ctrl1+1 全局 内容辅助 Alt+/ 全局 全部选中 Ctrl+A 全局 删除 Delete 全局 上下文信息 Alt+？ Alt+Shift+? Ctrl+Shift+Space java编辑器 显示工具提示描述 F2 java编辑器 选择封装元素 Alt+Shift+↑ java编辑器 选择上一个元素 Alt+Shift+← java编辑器 选择下一个元素 Alt+Shift+→ 文本编辑器 增量查找 Ctrl+J 文本编辑器 增量逆向查找 Ctrl+Shift+J 全局 粘贴 Ctrl+V 全局 重做 Ctrl+Y 查看 作用域 功能 快捷键 全局 放大 Ctrl+= 全局 缩小 Ctrl+- 窗口 作用域 功能 快捷键 全局 激活编辑器 F12 全局 切换编辑器 Ctrl+Shift+W 全局 上一个编辑器 Ctrl+Shift+F6 全局 上一个视图 Ctrl+Shift+F7 全局 上一个透视图 Ctrl+Shift+F8 全局 下一个编辑器 Ctrl+F6 全局 下一个视图 Ctrl+F7 全局 下一个透视图 Ctrl+F8 文本编辑器 显示标尺上下文菜单 Ctrl+W 全局 显示视图菜单 Ctrl+F10 全局 显示系统菜单 Alt+- 导航 作用域 功能 快捷键 ｊａｖａ编辑器 打开结构 Ctrl+F3 全局 打开类型 Ctrl+Shift+T 全局 打开类型层次结构 F4 全局 打开外部ｊａｖａdoc Shift+F2 全局 打开资源 Ctrl+Shift+R 全局 后退历史记录 Alt+← 全局 前进历史记录 Alt+→ 全局 上一个 Ctrl+, 全局 下一个 Ctrl+. ｊａｖａ编辑器 显示大纲 Ctrl+O 全局 在层次结构中打开类型 Ctrl+Shift+H 全局 转至匹配的括号 Ctrl+Shift+P 全局 转至上一个编辑位置 Ctrl+Q ｊａｖａ编辑器 转至上一个成员 Ctrl+Shift+↑ ｊａｖａ编辑器 转至下一个成员 Ctrl+Shift+↓ 文本编辑器 转至行 Ctrl+L 搜索 作用域 功能 快捷键 全局 出现在文件中 Ctrl+Shift+U 全局 打开搜索对话框 Ctrl+H 全局 工作区中的声明 Ctrl+G 全局 工作区中的引用 Ctrl+Shift+G 文本编辑 作用域 功能 快捷键 文本编辑器 改写切换 Insert 文本编辑器 上滚行 Ctrl+↑ 文本编辑器 下滚行 Ctrl+↓ 文件 作用域 功能 快捷键 全局 保存 Ctrl+X Ctrl+S 全局 打印 Ctrl+P 全局 关闭 Ctrl+F4 全局 全部保存 Ctrl+Shift+S 全局 全部关闭 Ctrl+Shift+F4 全局 属性 Alt+Enter 全局 新建 Ctrl+N 项目 作用域 功能 快捷键 全局 全部构建 Ctrl+B 源代码 作用域 功能 快捷键 java编辑器 格式化 Ctrl+Shift+F java编辑器 取消注释 Ctrl+\\ java编辑器 注释 Ctrl+/ java编辑器 添加导入 Ctrl+Shift+M java编辑器 组织导入 Ctrl+Shift+O java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。 也可以使用Ctrl+1自动修正。 运行 作用域 功能 快捷键 全局 单步返回 F7 全局 单步跳过 F6 全局 单步跳入 F5 全局 单步跳入选择 Ctrl+F5 全局 调试上次启动 F11 全局 继续 F8 全局 使用过滤器单步执行 Shift+F5 全局 添加/去除断点 Ctrl+Shift+B 全局 显示 Ctrl+D 全局 运行上次启动 Ctrl+F11 全局 运行至行 Ctrl+R 全局 执行 Ctrl+U 重构 作用域 功能 快捷键 全局 撤销重构 Alt+Shift+Z 全局 抽取方法 Alt+Shift+M 全局 抽取局部变量 Alt+Shift+L 全局 内联 Alt+Shift+I 全局 移动 Alt+Shift+V 全局 重命名 Alt+Shift+R 全局 重做 Alt+Shift+Y jrebel # 介绍 热加载 使用: myeclipse根目录下配置自定义 插件 window -\u0026gt; preferences -\u0026gt; JRebel中关联jar包，设定自动部署时间 window -\u0026gt; preferences -\u0026gt; services -\u0026gt; tomcat -\u0026gt; tomcat6(可以配置是否启用jrebel和打印jrebel的日志)-\u0026gt;jdk 加上资源分配参数与tomcat要加载的jar包: -noverify -javaagent:D:\\(修改为自己的目录)\\jrebel.jar -Xmx512M -Xms512M -XX:MaxPermSize=1024m 项目右键jrebel生成reble.xml,其中配置rebel要管理的项目在tomcat中的路径 "},{"id":11,"href":"/docs/tool/develop/vim/","title":"VIM","section":"Develop","content":" 编译 # --with-features=tiny # 只包含最基本功能。small, normal, big, huge, :h feature-list查看 命令 # vim -u NONE -N # -u NONE 不加载配置文件和插件，并进入vi兼容模式 -u code/essential.vim # 加载指定配置文件 -N set nocompatible # 不进入vi兼容模式 --version # 可查看特性 mode # 普通模式 插入模式 可视模式 v/V # 面向字/面向行 可视模式 \u0026lt;C - v\u0026gt; # 面向块 可视模式 gv # 重选上次选区 o # 切换到选区的开头, 再按切换回尾端　替换模式 R 命令行模式(Ex命令) : # 可视模式中选定范围，切换到命令行时，自动输入range'\u0026lt;,'\u0026gt;代表选中区 操作符待决模式 # operator 与 motion之间的空闲时期 # 两个字符的operator, 字符间的空闲时期不是该模式，是命名空间，是普通模式的扩充 # 有了这个模式，能创建自定义映射项来激活或终结操作符待决模式，就可以自定义operator和motion 选择模式 # 类似windows中选中 \u0026lt;C - g\u0026gt;在可视和选择模式切换 历史 q: # 命令历史 q/ # 搜索历史 operate # 思想 {operator}{motion} {operator}{text-objects} shortcut key ctrl + c # 同Esc motions . # 重复前一次修改, 目标做到一键移动，一键执行。修改是指: 一个normal模式下的按键, 插入内容, \u0026lt;ESC\u0026gt;; 或一组normal模式下按键 K # 当前单词的:h 手册 ga # 当前字符的unicode码 Ex command # 可视模式下选中行, : 时前面有'\u0026lt;,'\u0026gt; 表示对选中的行执行操作 :h e 或 :help e # 查看e的帮助 vimtutor 查看教程 operator 查看operator map-operator 查看自定义operator omap-info 查看自定义motion digraphs-default digraphs digraphs-table 查看二合字符表 ex-cmd-index 查看所有Ex命令 vi-differences vim 相对vi的特性 :version # 查看版本和支持的功能 :! command # 执行某shell命令(CR返回) !! 执行前一个命令 r!command 执行结果插入当前位置 w!command 当前文件作为输入执行 :cd directory # 修改工作目录 :sh # 跳到shell, 再执行exit返回 :map bbc ia # 定义命令序列ia的别名为bbc :pwd # 显示当前目录 :normal A; # 执行普通模式命令A;, 添加分号到行尾 系统命令 :grep t * # 在当前所有文件中匹配t, 自动加-n参数(显示行号) :ls locate oper # motion ^/$/0/\u0026lt;home\u0026gt;/g_/h/l/j/k/w/W/e/E/b/B/ge/gE/gg/G/[[/]]/(/)/{/}/nH/M/nL/点鼠标 # 移动motion ge同b, 停在单词尾部 \u0026lt;home\u0026gt;同0, 到行开始, ^则到本行第一个字符 gg同[[，G同]]，10G跳到第10行 fx 移动到下一个x, F反向查找, tx 移动到x的前一个字符 nG 跳到第n行 f/F/t/T # 行搜索motion 重复查找(以相反方向重复搜索) ; # 重复移动上次f/F/t/T的字符 , # 撤销上次f/F/t/T移动 * # 查找当前词 nzz/nz- # 跳到指定行, 显示在屏幕中间/底部 zz 当前屏幕到中间 可视模式 $ # 块可视模式中，表示所有行尾 i/a # 块可视模式中有不同含义 operator 3G # 跳到第3行 /text　# 查找text，按n健查找下一个，按N健查找前一个。 ?text　# 查找text，反向查找，按n健查找下一个，按N健查找前一个。 *或# # # *相当于/，#相当于? g* 搜索子串 gd 同* 但跳到第一个匹配序列 % # 搜索对应括号 o-\u0026gt; marks `` # 跳回 `\u0026quot; 最后编辑的位置 `[ 最后修改的开始位置 `] 最后修改的结束位置 '. `. 跳到上次编辑位置 '' # 跳回到第一个非空白字符 marks # 显示系统全部书签 ma # mark当前光标位置为a，小写字母不同文件标记不同行, 大写字母全局标记，但webstorm中ideaVim不行 `a # 跳到a的位置 Ex command :10 # 跳到第10行, 同10G, 0位于第一行上方 :jumps # 输出能跳往的位置列表，可跳转多个文件 :$ # 文件结尾 :. # 当前位置 :% # 文件中的所有行 :'\u0026lt; # 选中区开始 :'\u0026gt; # 选中区结尾 :'m # 位置标记为m的行 :/\u0026lt;html\u0026gt;/,/\u0026lt;\\html\u0026gt;/ # 模式匹配范围 : 1+1, 5-1 # 开始向下偏移一行，结尾向上偏移一行 :vim[grep] abc test # 在test文件中grep匹配abc shortcut key \u0026lt;c - e\u0026gt;/y # 向下/上滚动一行 \u0026lt;c - d\u0026gt;/u # 向下/上滚动半屏 \u0026lt;c - f\u0026gt;/b # 向下/上滚动一屏 \u0026lt;c - i\u0026gt;/o # 到下个/上个跳动过的位置 edit oper # shortcut key \u0026lt;C - r\u0026gt; # 撤销的撤销 \u0026lt;C - a\u0026gt;/x # 数字增加/减少1, 对0开关数字进行八进制操作, 0x进行十进制操作。可以设置nrformats改变 插入模式/命令模式 \u0026lt;C - h\u0026gt; # 删除前一个字符 \u0026lt;C - w\u0026gt; # 命令模式可用，删除前一个单词 \u0026lt;C - u\u0026gt; # 命令模式可用，删至行首 \u0026lt;C - [\u0026gt; # 返回普通模式 \u0026lt;C - o\u0026gt; # 到插入-普通模式 \u0026lt;C - v\u0026gt; # 命令模式可用，插入编码对应的字符 065 # 两位的编码 u00bf # 超过3位的unicode码 非数字 # 直接插入, 如expandtab开启后插入tab \u0026lt;C - k\u0026gt;{char1}{char2} # 命令模式可用，插入以二合字母表示的字符 12 \u0026lt;\u0026lt; ?I \u0026lt;C - r\u0026gt;{register} # 命令模式可用，插入寄存器内容 补全 \u0026lt;C - n\u0026gt;/p # 自动补全下/上 \u0026lt;C - x\u0026gt; 接着按如下 \u0026lt;C - L\u0026gt; # 整行补全 \u0026lt;C - N\u0026gt; # 根据当前文件里关键字补全 \u0026lt;C - K\u0026gt; # 根据字典补全 \u0026lt;C - T\u0026gt; # 根据同义词字典补全 \u0026lt;C - I\u0026gt; # 根据头文件内关键字补全 \u0026lt;C - ]\u0026gt; # 根据标签补全 \u0026lt;C - F\u0026gt; # 补全文件名 \u0026lt;C - D\u0026gt; # 补全宏定义 \u0026lt;C - V\u0026gt; # 补全vim命令 \u0026lt;C - U\u0026gt; # 用户自定义补全方式 \u0026lt;C - S\u0026gt; # 拼写建议 operator # num + operator 来多次操作, 合并命令如A(同$a), 是为了普通模式下一个按键进行插入，这样能够在.命令中重复 @: # 重复Ex命令 \u0026amp; # 重复substitute命令 x/X # 删除当前字符/删除前一个字符， x等于dl，X 等于dh u/U # 撤销(Undo)/撤销对整行的操作 r/R # 替换一个字符/持续替换字符，tab是一个字符 gR # 一个tab由tabstop个字符才能替换 gr y/yy/Y # yank 复制/复制一行/同yy :y p/P # 粘贴/前面粘贴 :p a/A # s当前字符后插入 A同$a, 行尾插入 o/O # 向后插入行 o同A\u0026lt;CR\u0026gt; O同ko, 向前插入行 s/S # 替换当前字符/替换当前行 s同cl S同^C i/I # 当前字符前插入/行首插入 I同^i c/cc/C # 替换/替换一行/同cc :0,10c 与 :c C同c$ d/dd/D # 删除/删除一行/删到行尾 dd 同 :d 10d表示删除10行 D同d$ :0,10d 与 :d \u0026lt;\u0026lt;/\u0026gt;\u0026gt; 可视模式下 \u0026lt;/\u0026gt; 命令下 1\u0026gt;\u0026gt;2 表示从1行开始, 作用2行\u0026gt;\u0026gt;, 可以1\u0026gt;\u0026gt;\u0026gt;\u0026gt;2 1,2\u0026gt; 表示 1到2行\u0026gt;\u0026gt;, 可以1,2\u0026gt;\u0026gt; \u0026gt;G 缩进当前到最后一行 = # 自动缩进 == 自动缩进当前行 ! # 用外部命令过滤指定行 如!j, 自动进入命令模式, 选定了指定行进行! !!当前[count]行 J # 与下行合并 g # :[range]global/{pattern}/{command} global命令在[range]指定的文本范围内（缺省为整个文件）查找{pattern}，然后对匹配到的行执行命令{command}，如果希望对没匹配上的行执行命令，则使用global!或vglobal命令。 g/^/m 0 倒序文件行 g_ # 到本行最后一个不是blank字符的位置 gd # 智能跳到当前变量定义的位置 gu/gU # 转换到小写/大写, 如gUw gugu / guu / gUgU / gUU g~ # 大写转小写，小写转大写 g~g~ / g~~ 转换一行 可视模式下 U/u # 大写/小写 ex command :1,10 co 20 # 将1-10行插入到第20行之后。 :1,$ co $ 复制整个文件添加到尾部 :1, 10 m 20 # 第1-10行移动到第20行之后 :ab attr attribute # 缩写, 输入模式中输入attr,再输入非字母字符(空格, 点等)，自动补全 ab查看所有缩写 una/unab attr 取消缩写　:! # 执行外部命令 :[range]copy{address} /:t /:co # 复制range到address后, :t 2 表示复制当前行到第2行后 :[range]move{address} # 移动 :[range]join # 连接 :[range]delete[x] # 删除指定范围内的行到寄存器中 :[range]yank[x] # 复制 :[line]put[x] # 指定行后粘贴寄存器中内容 :[range]normal{commands} # 指定范围执行命令 :[range]print / p # 在vim下方回显指定行的内容 text-object i\u0026quot; \u0026quot; 表示 光标所在\u0026quot;\u0026quot;的内容 ' ` ) 表示 ()的内容 ( 同上 ] [ \u0026gt; \u0026lt; } { B 表示 {}的内容 t 表示 tag之间的内容，如\u0026lt;h2\u0026gt;aaaa\u0026lt;/h2\u0026gt; w 表示 光标所在word s 表示 光标所在句子 p 表示 段落 a\u0026quot; # 包括外围，命令同i 视图模式下 vit # 在可视模式下选中标签内容，如\u0026lt;a\u0026gt;xxx\u0026lt;/a\u0026gt;的xxx patterns oper # operator \u0026amp; # 重复:s上次执行的命令, 不包含g g\u0026amp; 全局重复:s上次的命令 n/N # 查找下一个/上一个 Ex command :[range]substitude/{pattern}/{string}/[flags] :s 用new替换old，替换当前行的第一个匹配 前面是正则, 用()分组，后面用\\1引用分组 :s/old/new/g 作用到整行 :%s/old/new/ 作用到每行第一个 :10,20 s/^/ /g 作用到10到20行的每一个 :%s/old/new/g 作用到全文 :s/old/new/gc 每次修改前询问 :[range]global/{pattern}/[cmd] :g 查找text的行执行命令,如:g/text/s/old/new/g v/text/command 查找到行不执行命令,其它行执行 :\u0026amp; # 同operator中\u0026amp; registers oper # register # 寄存器 :reg # 查看所有寄存器 或 :reg 1 查看寄存器1的内容 \u0026quot;0p # \u0026quot;0\u0026lt;operator\u0026gt; 粘贴寄存器0的内容 \u0026quot;0y 复制到寄存器0 :pu 0 # 同上 :pu! 0 同 \u0026quot;0P :y a # 复制当前行到\u0026quot;a寄存器 :5,10y m 复制5到10行到\u0026quot;m寄存器 分类 \u0026quot;\u0026quot; # unamed 缓存最后一次操作内容 \u0026quot;0 # numbered 范围0 - 9 。\u0026quot;0缓存最近一次复制的内容 \u0026quot;1到\u0026quot;9缓存最近9次删除的内容, \u0026quot;9向后则丢弃 第2次删除时，缓存1转存到缓存2, 新的删除内容存到缓存1 \u0026quot;- # small delete 缓存行内删除内容 \u0026quot;a # named 范围a - z 与 A - Z \u0026quot;: # read-only 如 \u0026quot;: 最近命令 \u0026quot;. 最近插入文本 \u0026quot;% 当前文件名 \u0026quot;# 当前交替文件名 \u0026quot;= # expression 用于执行表达式命令，只读 \u0026quot;* # selection and drop 如 \u0026quot;* \u0026quot;+ \u0026quot;~ 存取GUI选择文本，可用于与外部交互，要求系统剪切板(clipboard)可用 \u0026quot;_ # black hole 表示不缓存，干净删除 \u0026quot;/ # last search pattern 缓存最近的搜索模式 shortcut key \u0026lt;C - r\u0026gt;0 # 插入寄存器缓冲区内容, 原理是vim插入模式模拟打入 \u0026lt;C - p\u0026gt;0 # 保持格式不变 \u0026lt;C - r\u0026gt;=6 * 35\u0026lt;CR\u0026gt; # 计算结果 宏 qa ... q # 录制宏a，存到寄存器中，可以用\u0026quot;ap粘贴出来 @a # 运行宏a let @a = \u0026quot;\u0026quot; # 用let @a 在.vimrc设置文件中设置宏a 内置宏 : # 上次的Ex命令 file oper # shell $ vim file1 file2.. $ vimtutor # vim的教程 operator o-\u0026gt; 折叠 zf # 创建折叠 zf% 创建括号折叠 zf56G 创建从当前行起到56行代码的折叠 zo/zO # 展开当前/递归展开当前(folding open, z这个字母看上去比较像折叠的纸) zc/zC # 再折叠/递归再折叠(folding close) [z # 到折叠的开始处 z] # 到折叠的结束处 zk # 向上移动到前一个折叠的结束处 zd/zD # 删除当前光标下的折叠/嵌套删除折叠 o-\u0026gt; 文件对比 vim -d file1 file2 diffsplit file2 diffthis diffupdate [c # 跳到前一个不同点 ]c # 跳到后一个不同点 dp # 合并增加另一个 （diff put） do # 合并增加当前 （diff get） Ex command :help # 显示帮助, 同F1 帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回 :help tutor 显示vimtutor的教程 :help xx 显示某个帮助, 如help CTRL-[ :help 'number' 显示vim选项的帮助 :help \u0026lt;Esc\u0026gt; 显示特殊键的帮助 :help -t 显示vim启动参数的帮助 :help i_\u0026lt;Esc\u0026gt; 插入模式下Esc的帮助，某个模式下的帮助用 模式_主题的模式 :r/nr filename # 插入一个文件的内容/插入到第n行 :f # 显示当前文件状态 :.= # 打印当前行号 := 打印总行号 :open file # 新窗口打开文件 :saveas filename # 另存为并切换到文件 :tabnew # 新建标签页 :split file/:new # 屏幕分割 :vsplit 纵向打开窗口 :q # q! 强制退出 :w/:write # :w filename 写入新文件 :x # 有改动时保存并退出, 无改动只退出 ZZ :e/:edit # 重新打开文件, e! 放弃所有修改重新打开文件 e filename 当前窗口打开另一个文件 :bn/:bp # 切换上个/下个文件 :saveas \u0026lt;path/to/file\u0026gt; # 另存为到 \u0026lt;path/to/file\u0026gt; :!command # 执行shell命令，如 :!ls :!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。 :!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。 :suspend # 挂起vim，回到shell，命令fg返回vim。 :buffers/:ls # 缓冲区列表 :bprev # 上一缓冲区 :bnext # 下一缓冲区 o-\u0026gt; 多视窗 :vert # 横向打开 :vsplit # 横向打开 :split :prev # 上一个文件 :next # 下一个文件 :close # 最后一个窗口不能使用此命令，可以防止意外退出vim。 :only # 关闭所有窗口，只保留当前窗口 o-\u0026gt; 标签窗口 # 启动 Vim 时用 \u0026quot;vim -p filename ...\u0026quot; :tabe[dit] # 打开文件到标签 :tabnew # 在当前标签页之后打开带空窗口的新标签页。 :tabc[lose][!]{count} # 关闭当前标签页。 {}表示关闭第count个标签 :tabo[nly][!] # 关闭所有其它的标签页。 :tabn[ext] {count} # 切换到后面的标签页 :tabp[revious] {count} # 切换到前面的标签页 :tabr[ewind] # 回卷跳转 :tabfir[st] # 转到第一个标签页。 :tabl[ast] # 转到最后一个标签页。 :tabm[ove] [N] # 重排标签页 把当前标签页移到第 N 个标签页之后。用 0 使当前标签页成为首个标 签页。如果没有 N，当前标签页成为最后一个。 :tabs # 列出标签页和它们包含的窗口信息。 当前窗口显示 \u0026quot;\u0026gt;\u0026quot;。 修改过的缓冲区显示 \u0026quot;+\u0026quot;。 :tabd[o] {cmd} # 对每个标签页执行 {cmd} shortcut keys ctrl - z # 同 :suspend ctrl + g # 同 :f o-\u0026gt; 多视窗 ctrl + w + hljk ctrl + w + w # 跳到下一个 ctrl + w + p # 跳到前一个 settings # 设置文件 /etc/vimrc ~/.vimrc # vim的配置文件, 优先于.exrc ~/.exrc # vi的配置文件 命令 :set all # 打印所有set选项 nocompatible # 不设置vi兼容 ruler? # 查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看 shell :/usr/bin/sh # 使用SystemⅤ中的shell来执行vi中以！或 :!开头的shell命令 nrformts # 设置进制, \u0026lt;c - a\u0026gt; \u0026lt;c - x\u0026gt;时对八进制有用，如07 encoding=utf-8 # 程序显示编码 enc # 同上 fileencodings=ucs-bom,utf-8,cp936 # 设置读取文件支持的编码 fencs # 同上 fileencoding=utf-8 # 当前文件编码 fenc # 同上 termencoding=utf-8 # 设置终端编码 tenc # 同上 list # 显示非打印字符，如tab，空格，行尾等。 nolist # 取消显示非打印字符, 如果tab无法显示，请确定用 set lcs=tab:\u0026gt;- 命令设置了.vimrc文件 number # 显示行号 nu # 同上 nonumber # 不显示行号 nonu # 同上 reprot=2 # 用户做2行以上修改时显示统计信息 hlsearch # 设置查找高亮 hls # 同上 incsearch # 查找高亮所有(增量高亮) smartindent # 括号补全 sm # 同上 ignorecase # 查找时忽略大小写 ic # 同上 noignorecase # 查找时不忽略大小写 noic # 同上 expandtab # 存起来的文件, 用space替换tab shiftwidth=4 # 换行时缩进长度 sw # 同上 softtabstop=4 # 插入模式tab长度 tabstop=4 # 识别和显示tab时，转换成space的长度 autoindent # 启用自动缩进 ai # 同上 foldmethod=indent # 设置折叠 fdm # 同上 indent 缩进折叠 syntax 语法高亮折叠 expr 表达式定义折叠 diff 对没有更改的文本折叠 marker 对文中的标志折叠 :scriptnames # 脚本文件位置，如.vimrc文件、语法文件、plugin :syntax clear # 列出已经定义的语法项 clear 清除已定义的语法规则 case match 大小写敏感，int和Int将视为不同的语法元素 case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案 配置 inoremap \u0026lt;C-]\u0026gt; \u0026lt;C-X\u0026gt;\u0026lt;C-]\u0026gt; # 插入模式下映射 nnoremap # 在normal模式下映射 fileType plugin on # 激活内置插件, 检测文件类型 filetype on # 同上 plugins # netrw 介绍 自带插件 edit ./ # 查看目录树 Ex # 同上 Se # 下面弹出目录树 好用 Ve # 左面弹出目录树 好用 \u0026lt;cr\u0026gt; netrw 进入目录或读入文件 |netrw-cr| \u0026lt;del\u0026gt; netrw 试图删除文件/目录 |netrw-del| - netrw 往上走一层目录 |netrw--| a 在以下三种方式间切换: 正常显示，|netrw-a| 隐藏 (不显示匹配 g:netrw_list_hide 的文件) 和 显示 (只显示匹配 g:netrw_list_hide 的文件) c 使浏览中的目录成为当前目录 |netrw-c| d 建立目录 |netrw-d| D netrw 试图删除文件/目录 |netrw-D| i 在瘦、长、宽和树形的各种列表方式间切换 |netrw-i| \u0026lt;c-l\u0026gt; netrw 刷新目录列表 |netrw-ctrl-l| o 打开新浏览窗口，进入光标所在的目录。使用水平分割。|netrw-o| p 预览文件 |netrw-p| P 在前次使用的窗口里浏览 |netrw-P| r 反转排序顺序 |netrw-r| R 给指定的文件/目录换名 |netrw-R| s 选择排序方式: 按名字、时间或文件大小排序 |netrw-s| S 指定按名字排序的后缀优先级 |netrw-S| t 在新标签页里打开光标所在的文件/目录 |netrw-t| v 打开新浏览窗口，进入光标所在的目录。使用垂直分割。|netrw-v| ctags 将ec57w32.zip解压，在解压后文件夹中找到ctags.exe，将其复制到C:\\ProgramFiles\\Vim\\vim72下，并编辑_vimrc文件，添加以下内容： set tags=tags; set autochdir 打开cmd命令行，切换到你要查看的源代码的根目录处，运行 ctags -R 将会在此目录处生成一个tags文件。 用gvim打开一个代码文件，将光标放到某一函数名上，如下图的UpdateViewByPosNo()，按下\u0026quot;ctrl+]\u0026quot;，光标会自动跳转到定义处。按下\u0026quot;ctrl+T\u0026quot;会跳回到原来的位置。 变量、结构体、宏等等，都可以这样做。 当你的源文件有更新时，只能重新运行ctags -R命令，来更新tags文件。 taglist 将taglist_45.zip解压，解压后包含一个doc文件夹和一个plugin文件夹，将其中内容分别复制到C:\\Program Files\\Vim\\vim72下的doc及plugin中。 在_vimrc文件中加入以下内容： let Tlist_Show_One_File=1 let Tlist_Exit_OnlyWindow=1 用gvim打开代码文件（已生成过tags文件），:Tlist，TagList窗口即出现在左侧。 visual-star Qargs nerdTreeToggle 介绍 目录显示插件 方案 # 加分号 jA; j. 批量执行 选中多行, :normal . 批量前缀 选中多行, I 括起文字 ci\u0026quot; # 替换内容\u0026quot;\u0026quot; ca\u0026quot; # 替换所有 di\u0026quot; # 删除内容 cit # 替换标签 执行python 选中代码, :!python 缩进全文 gg=G 替换到\u0026quot; cf\u0026quot; esc \u0026lt;C-[\u0026gt; 目录窗口 :Sex console输出乱码 language messages utf-8 set termencoding=utf-8 设置文件编码 set encoding=utf-8 set fileencodings=utf-8,chinese,latin-1 "},{"id":12,"href":"/docs/tool/ops/docker/","title":"Docker","section":"运维","content":" 基础 # 介绍 基于linux LXC，可以实现虚拟化 优点 低成本、高利用率、充分灵活、动态调度 核心网的最终形态 目录 /var/lib/docker 配置 # 镜象网站 https://hub.docker.com/ 阿里云个人仓库 入口: cr.console.aliyun.com docker login -u 934260428@qq.com registry.cn-qingdao.aliyuncs.com docker tag java/device:1.0 registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0 docker push registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0 docker pull registry.cn-qingdao.aliyuncs.com/mrs-iot/device:1.0 /etc/sysconfig/docker # /etc/init.d/docker.conf OPTIONS='--selinux-enabled --log-driver=journald --insecure-registry 45.55.56.16:5000 --dns 8.8.8.8' DOCKER_CERT_PATH=/etc/docker 命令 # 常用系统命令 # systemctl daemon-reload systemctl restart docker docker # -h version login docker login -u outrun -p asdf search mysql # 搜索镜像 pull centos:7 # 下载镜像 centos:latest outrun11/test:nginx1 image ls pull rm images centos # 本地镜象列表 rmi centos:latest # 删除镜象 container run # 新建容器 --user root --name a --privileged --name # 显示名 -t # 伪tty, -i 交互的 -rm=true # 执行完后删除 -v /etc/:/opt/etc/ # 挂载本机/etc到容器/opt/etc, /etc/:/opt/etc/:ro 只读挂载, /etc/ 对外共享/etc -p 1234:80 # 端口映射本机1234端口到容器80 --volumes-from etc_share # 使用另一个容器对外共享的磁盘 -d # 后台运行 --link redis_server:redis # 连接容器的redis命令 -w /var/node # 当前工作目录 -e NODE_ENV='' # 环境变量 --net=bridge # 网络模式，bridge使用虚拟网桥docker0, host共享主机命名空间, container与已存在的一个容器共享命名空间, none关闭网络功能, overlay --name nsqd -p 4150:4150 nsqio/nsq /nsqd # 端口 -it centos /bin/bash # 启动容器, 执行bash b15 /bin/echo 'hello' # 启动容器 -it --rm=true --name=ls-volume -v /etc/:/opt/etc/ centos ls /opt/etc # 创建共享 -it -p 1337:1337 --name=etc_share -v /etc/ centos mkdir /etc/my_share \u0026amp;\u0026amp; /bin/sh -c \u0026quot;while true; do echo hello; sleep 1; done\u0026quot; # 持续运行 -it --rm=true --volumes-from etc_share --name=ls_etc centos ls /etc # 使用共享 exec # 已有容器中运行 -i -t ls start 026 # 启动已建立的容器, id可以只输入前几位 cp 026e:/docker/file /local/file stop 026 restart 026e attach 026 # 进入容器运行命令行, 可显示日志 kill 026e prune ps -a # 容器列表 rm # 移除容器 docker rm docker ps -aq # 移除所有未运行的容器 rm -f 026 build . # 用当前目录Dockerfile创建新镜像 -t=\u0026quot;nginx/test\u0026quot; # target --no-cache # 不用cache -f a.dockerfile # 指定文件 tag nginx/test:test1 outrun11/test:nginx1 # 远程docker基站创建repository, 名字test push outrun11/test:nginx1 logs beae3392 swarm # 一个或多个docker组成 init node # swarm节点 ls service # 运行于swarm的服务 create ls ps rm inspect # 详情 scale # 加减副本 update # 变更属性 logs # 查日志 system prune # 清理所有container, network, image, cache network # 网卡 ls rm prune # 删除全部未使用 inspect # 详情 create -d nat # 指定驱动 volume # 卷标, 默认挂载到/var/lib/docker/volumes create ls rm prune # 删除全部未使用 inspect stack # 单文件定义多服务 deploy ls ps rm 常用 docker inspect 45370 # 详情 --format \u0026quot;{{.State.Pid}}\u0026quot; docker login a.com -u outrun -p asdf docker build -t java/gateway:1.0 . docker push java/gateway:1.0 docker images|grep none|awk '{print $3}'|xargs docker rmi -f # 删除none镜像 docker image inspect 4de docker system prune -a docker exec -it -u root ef2 /bin/bash docker run --name gateway --rm -d java/gateway:1.0 docker run -it ubuntu docker restart ef2 docker logs -f -t ef2 docker status 45370 # 显示资源占用 docker save -o a.tar.gz a docker load \u0026lt; a.tar.gz nsenter # # 指定pid, 不需ssh进入容器运行shell docker inspect --format {{.State.Pid}} nginx nsenter -t4629 -n 场景 # 查看镜像内文件 docker run -it --entrypoint sh nginx:latest 查看/var/lib/docker/overlay2/id文件对应container docker ps -q | xargs docker inspect --format '{{.State.Pid}}, {{.Id}}, {{.Name}}, {{.GraphDriver.Data.WorkDir}}' | grep bff250 Dockerfile # 指令 FROM nginx # 基于镜像 MAINTAINER outrun # 指定维护者信息 EXPOSE 80 # 内部服务开启的端口 ENV NODE_ENV test # 环境变量 WORKDIR /src # 指定工作目录 COPY ./bin /data/a # 复制外部文件到内部 VOLUME [\u0026quot;/data/log\u0026quot;] # 创建挂载点 ENTRYPOINT [\u0026quot;/data/a/a\u0026quot;] # 启动命令，只有一个 CMD [\u0026quot;-config\u0026quot;, \u0026quot;config.toml\u0026quot;] # docker run 时运行 RUN echo 'test' # build过程中执行的命令 docker-compose # docker-compose -h # 帮助 -f # 指定模板 version up # 所有模板创建容器 -d # 后台 down # 删除容器、网络、卷、镜像 rm # 删除容器 create # 创建容器 stop # 停止容器 start # 启动容器 restart pause # 暂停容器 unpause kill # 强制停止容器 scale # 指定容器个数 ps # 列出所有容器 logs # 查日志 port # 显示容器映射端口 run # 容器中执行命令 exec config # 查看配置 build # (重)构建容器 pull # 拉依赖镜像 push # 推送镜像 配置 version: '3' services: dokuwiki: restart: always image: bitnami/dokuwiki:latest ports: - 8004:80 environment: - DOKUWIKI_FULL_NAME=outrun - DOKUWIKI_EMAIL=934260428@qq.com - DOKUWIKI_WIKI_NAME=Wiki - DOKUWIKI_USERNAME=outrun - DOKUWIKI_PASSWORD=asdfasdf volumes: - ./data:/bitnami # 本地:镜像 仓库 # habor # registry # htpasswd -Bbn outrun asdf \u0026gt; auth/htpasswd 客户端使用 /etc/docker/daemon.json {\u0026quot;insecure-registries\u0026quot;:[\u0026quot;127.0.0.1:5000\u0026quot;]} sudo systemctl daemon-reload sudo systemctl restart docker docker login 127.0.0.1:5000 docker tag java/device:1.0 127.0.0.1:5000/java/device:1.0 docker push 127.0.0.1:5000/java/device:1.0 curl --user outrun:asdf 127.0.0.1:5000/v2/_catalog # v2表示版本 registry:2 docker pull 127.0.0.1:5000/java/device:1.0 常用API curl --user outrun:asdf -X GET registry:5000/v2/_catalog # 列表 curl --user outrun:asdf -X GET registry:5000/v2/ubuntu/tags/list # tags curl --user outrun:asdf -X GET registry:5000/v2/ubuntu/manifests/latest # tag curl --user outrun:asdf -X GET -v --silent -H \u0026quot;Accept: application/vnd.docker.distribution.manifest.v2+json\u0026quot; registry:5000/v2/ubuntu/manifests/latest 2\u0026gt;\u0026amp;1 | grep Docker-Content-Digest | awk '{print ($3)}' # digest curl --user outrun:asdf -X DELETE -v --silent -H \u0026quot;Accept: application/vnd.docker.distribution.manifest.v2+json\u0026quot; registry:5000/v2/ubuntu/manifests/sha256:134c7fe821b9d359490cd009ce7ca322453f4f2d018623f849e580a89a685e5d # 删除 docker exec -it 4ebff4cdc646 /bin/registry garbage-collect /etc/docker/registry/config.yml # 删除后, 运行垃圾回收 方案 # 查容器pid docker container top ea1 docker inspect -f '{{.State.Pid}}' ea1 批量删除镜像 docker rmi $(docker image ls -a |grep jncloud |awk '{print $3}') 进入容器 docker exec -it mysql bash 制作镜像并运行 make docker build -t search:v1 . docker images docker run -p 50088:80 -d search:v1 docker ps -a docker logs ea1 docker rmi bc8 提交镜像到官方 docker -ps -a docker login docker commit d79 outrun11/node_pm2 # 把容器提交为镜像 docker images node_pm2 docker push outrun11/node_pm2 代理 /etc/systemd/system/docker.service.d/http-proxy.conf # 没有时创建 Environment=\u0026quot;HTTP_PROXY=http://127.0.0.1:8123\u0026quot; \u0026quot;HTTPS_PROXY=http://127.0.0.1:8123\u0026quot; \u0026quot;NO_PROXY=192.168.1.1,localhost\u0026quot; systemctl daemon-reload 换源 /etc/docker/daemon.json # 没有时创建 { \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://nmp74w3y.mirror.aliyuncs.com\u0026quot;] } systemctl daemon-reload systemctl restart docker 登录运行容器 docker exec -it --user root 8ce /bin/sh 工具 # harbor 企业级register镜像服务器 pipwork shell写的docker网格配置工具 "},{"id":13,"href":"/docs/tool/ops/k8s/","title":"Kubernetes","section":"运维","content":" 常用 # 查看 # 系统日志 journalctl -u kubelet | tail kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -nmdw 日志 kubectl logs -f --since=5m --all-containers=true -lapp=[svcName] -o wide kubectl get pod [podName] -o yaml kubectl get pods -nmdw-log -l app=logstash-logstash -w # 等待启动 kubectl describe pods [podName] kubectl rollout status deploy/[deployName] # 查升级记录 kubectl get events -njnc -oyaml --field-selector=type=Normal # Normal, Warning 查ns所有资源 kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -nairflow 查节点详情 kubectl get nodes -o json 查扩缩状态 kubectl rollout status deploy/[deployName] 查所有nodeport kubectl get svc --all-namespaces -o go-template='{{range .items}}{{range.spec.ports}}{{if .nodePort}}{{.nodePort}}{{\u0026quot;\\n\u0026quot;}}{{end}}{{end}}{{end}}' 操作 # 进容器 kubectl exec -it [podName] -- /bin/bash kubectl attach [podName] # 进入主进程IO 用busybox运行命令 kubectl run -it --image busybox -n [nameSpace] [name] --restart=Never --rm 监控 # kubectl top node -l app=app1 kubectl top pod -nmdw --containers kubectl describe PodMetrics p1 -njnc-dev 编辑 # kubectl apply -f a.yml envsubst \u0026lt; jnc.yml |kubectl apply -f - kubectl label ns jnc istio-injection=enabled --overwrite kubectl label ns jnc istio-injection- 亲和性 # kubectl get nodes --show-labels kubectl label nodes node1 deploy=mdw kubectl taint nodes node1 key=value:NoSchedule # NoSchedule、PreferNoSchedule、NoExecute 调试 # kubectl proxy --port=8080 \u0026amp; # 以非https形式暴露api kubectl debug a1 -it --image=yauritux/busybox-curl --share-processes --copy-to=a1-debug # 嫁接 kubectl run -it --rm test --image=a:0.1.0 --command -- /bin/bash # 改镜像命令 kubectl run -it --rm busybox1 --image=yauritux/busybox-curl -- /bin/bash # 同环境busybox kubectl cp dir1 ns1/po1:/dir1 -c c1 清理 # 删除Evicted/OutOfmemory pod kubectl get po -njnc-dev | grep OutOfmemory |awk '{print$1}' | tr '\\n' '' | xargs kubectl delete pod -njnc-dev 强制删除pod kubectl delete po -nmdw --force --grace-period=0 删除pv/pvc kubectl patch pv mdw-mysql-data -p '{\u0026quot;metadata\u0026quot;:{\u0026quot;finalizers\u0026quot;:null}}' 重建pv kubectl get pvc p1 -o yaml \u0026gt; a.yml 编辑a.yml kubectl apply -f a.yml 删除node kubectl drain node1 维护node不可调度与恢复 kubectl cordon node1 kubectl uncordon node1 强制删除ns kubectl get ns n1 -o json \u0026gt;tmp.json 删除finalizers列表 kubectl proxy curl -k -H \u0026quot;Content-Type: application/json\u0026quot; -X PUT --data-binary @tmp.json http://127.0.0.1:8001/api/v1/namespaces/n1/finalize 操作 # 升级镜像 kubectl set image deploy/[deployName] [imageName]=[imageName:Version] kubectl edit deploy/[deployName] 扩容 kubectl scale deployment [deployName] --replicas=3 kubectl patch deployment [deployName] -p '{\u0026quot;spec\u0026quot;:{\u0026quot;replicas\u0026quot;:3}}' 重启 kubectl rollout restart deploy xxx 回滚 kubectl rollout undo deploy xxx 打污点 kubectl taint nodes node1 key1=a:NoExecute # 添加 kubectl taint nodes --all key1- # 删除 打标签 kubectl label nodes node1 a=b 容器配置 # HTTPS openssl req -x509 -newkey rsa:4096 -sha256 -nodes -keyout tls.key -out tls.crt -subj \u0026quot;/CN=my-domain.com\u0026quot; kubectl create secret tls my-domain-com-tls --cert=tls.crt --key=tls.key --namespace=allure-docker-service ingress.yml spec: tls: - secretName: my-domain-com-tls hosts: - my-domain.com 部署.docker/config.json成secret kubectl create secret generic regcred --from-file=.dockerconfigjson=\u0026lt;path/to/.docker/config.json\u0026gt; --type=kubernetes.io/dockerconfigjson 配置私有仓库 kubectl delete secret local kubectl -n iot create secret docker-registry local1 \\ --docker-server=192.168.99.1:5000 \\ --docker-username=outrun \\ --docker-password=asdf \\ --docker-email=934260428@qq.com 连阿里云k8s kubectl config set-cluster mrs --server=https://106.14.49.217:6443 --certificate-authority=/home/outrun/scripts/work/mrs-k8s/crt --embed-certs=true kubectl config set-context 297351062922226746-cdf45d630b2284f8ab79bea186c161d9f --cluster=mrs --user=297351062922226746 --namespace=lora-app kubectl config use-context 297351062922226746-cdf45d630b2284f8ab79bea186c161d9f kubectl config set-credentials 297351062922226746 --user=297351062922226746 --client-key=/home/outrun/scripts/work/mrs-k8s/297351062922226746.key.pem --client-certificate=/home/outrun/scripts/work/mrs-k8s/297351062922226746.crt --embed-certs=true 集群配置 # 设置当前集群namespace kubectl config set-context $(kubectl config current-context) --namespace=default 配置DNS解析 kubectl edit configmap coredns -n kube-system apiVersion: v1 data: Corefile: | .:53 { errors hosts { 192.168.1.107 a.b.com } } kubectl rollout restart deploy coredns -n kube-system 文件目录 # /etc/kubernetes /etc/resolve.conf 命令 # kubeadm # kubeadm init kubectl # 全局参数 --help # -h --output=\u0026quot;jsonpath={.data.\\.dockerconfigjson}\u0026quot; --output=yaml --context=iot --namespace=iot --all-namespaces=true -n [namespace] --all # 如匹配所有deploy文件 Other Commands api-resources # 查所有resource namespace/ns endpoints/ep nodes/no configmap/cm replicationcontrollers/rc deployments/deploy statefulsets/sts service/svc ingresses/ing persistentvolumes/pv persistentvolumeclaims/pvc storageclasses/sc pods/po cronjobs/cj daemonset/ds # 每个node运行一个 certificatesigningrequests/csr # csr证书 api-versions # 所有可用的apiVersion config # 设置集群 config set current-context c1 plugin # 设置插件 version Basic Commands: create -f y1.yml expose # 修改端口 expose deployment/[deployName] --target-port=8080 --type=NodePort run run [deployName] --image=gcr.io/google-samples/hello-app:1.0 --port=8080 set # 更新配置 set image deploy/[deployName] *=image1:1.1 # 所有镜像更新为image1:1.1 explain # 查resource文档 pv get -o # 格式 yaml wide jsonpath='{.items[0].metadata.name}' -l app=a1 # select label -c gateway --show-labels --selector app=a1 --all-containers=true edit # 修改配置 edit ingress ingress1 delete --force --grace-period=0 Deploy Commands: rollout history deploy/deploy1 pause deploy/deploy1 restart resume deploy/deploy1 status undo deploy/deploy1 # 回滚到上一版本 scale scale deploy/deploy1 --replicas=1 autoscale autoscale deploy/deploy1 --min=1 --max=3 --cpu-percent=80 Cluster Management Commands: certificate approve [csrName] # 手动签发证书，/etc/kubernetes/ssl/* deny cluster-info # 集群信息 dump top # cpu 内存负载 node pod cordon [nodeName] # node不可调度 uncordon # node可调度 drain [nodeName] # 移除node taint # node污点 taint nodes node1 key1=val1:NoSchedule Troubleshooting and Debugging Commands: describe logs attach # 当前终端成为entrypoint exec -it device-7b8965d85d-xz4qm bash -it device-7b8965d85d-xz4qm --container device -- /bin/bash port-forward # 端口映射 port-forward [podName] 本地端口:pod端口 proxy # 映射ApiServer到本地端口 --port=8080 cp # copy容器文件 cp [namespaceName]/[podName]:[filePath] . auth can-i list pods # judge权限 reconcile -f rbac.yaml # 应用权限配置 --dry-run # 仅测试，列出变更 --remove-extra-subjects # 删除除外subject --remove-extra-permissions # 删除除外权限 debug # pod调试模式, alpha版功能，需要--feature-gates=\u0026quot;EphemeralContainers=true\u0026quot; -it pod1 --image=image1 # 排错工具镜像 --share-processes # 共享进程 --copy-to=pod1-debug Advanced Commands: diff diff -f a.yml # dry run 找出将实行的变更 apply # 升级 -f y1.yml -k overlays/ patch # 更新属性 patch deploy/deploy1 -p '{\u0026quot;spec\u0026quot;:{\u0026quot;unschedulable\u0026quot;:true}}' replace # 替换resource replace -f a.yml wait # 等待直到满足条件 -f a.yml --for=condition=Available --timeout=1h kustomize # 多环境部署的overlays补丁 kustomize [dir with kustomization.yml] Settings Commands: label label pods/pod1 a=b --overwrite # 覆盖更新 --resource-version=1 # 匹配没修改过的情况 annotate annotate pods/pod1 a='b' --overwrite completion # 生成终端命令补全配置 completion bash \u0026gt; /etc/bash_completion.d/kubectl Helm # 目录 charts/ Chart.yaml apiVersion: v1 appVersion: \u0026quot;1.0\u0026quot; description: A Helm chart for Kubernetes name: nginx-test version: 0.1.0 requirements.yaml requirements.lock values.yaml replicaCount: 1 templates/ _helpers.tpl deployment.yaml helm命令 查看 ls/list --all-namespaces get values a1 # 查看已部署的values变更 history a1 # 查看历史版本 get manifest a1 # 查看已安装模板 template # 查看编译后内容 --debug search repo a1 --versions 安装 repo update install [deployName] [packageName|packageFile|packagePath] -f values.yaml --values=values.yaml --set a=b upgrade # 热更新部署文件 --debug --dry-run # 只输出编译结果 -i # 没有时执行install --disable-openapi-validation uninstall 插件 plugin install --version master https://gitee.com/mirrors_sonatype-nexus-community/helm-nexus-push.git ls 运维 rollback a1 1 # 回滚到1版本 打包 create a1 lint --strict a1 # 校验 package a1 # 打包成a1-0.1.0.tgz 相关命令 minikube # docker login --username=934260428@qq.com registry.cn-hangzhou.aliyuncs.com 命令 minikube start --vm-driver=virtualbox \\ --memory=4096 \\ --cpus=2 \\ --log_dir=/home/outrun/logs \\ --insecure-registry=192.168.99.1:5000 \\ --insecure-registry=registry.cn-qingdao.aliyuncs.com \\ --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers --kubernetes-version v1.17.0 --docker-env=HTTP_PROXY=$HTTP_PROXY \\ --docker-env=HTTPS_PROXY=$HTTPS_PROXY \\ --docker-env=NO_PROXY=$NO_PROXY \\ --image-mirror-country=cn \\ --registry-mirror=https://registry.docker-cn.com \\ --extra-config=kubelet.MaxPods=5. # registry一定是minikube容器ip, 可用ifconfig查看 # --insecure-registry修改需要minikube delete stop delete status docker-env ip # 得到单机集群ip service -n iot mosquitto --url # 得到service的nodePort ssh dashboard addons list enable heapster enable ingress 服务 kube-system coredns etcd-minikube kube-addon-manager-minikube kube-proxy kube-scheduler-minikube nginx-ingress-controller storage-provisioner kubernetes-dashboard dashboard-metrics-scraper kubernetes-dashboard 平台 # HPE Container Platform OpenShift VMware VSphere Minikube Rancher KubeSphere Google Cloud Platform(GCP) "},{"id":14,"href":"/docs/db/mongodb/","title":"Mongodb","section":"数据库","content":" 特点 # 数据结构json(bson) 易写入，易修改 c++编写 分布式 介于关系数据库 和 非关系数据库之间 查询语句强 支持索引 bson格式 注意 # document不能大于4Mb 可以非安全模式异步马上成功 每个连接用队列存储命令 数据结构定义 # collection # 表 document # 记录 field(key, value) # 字段(field)与值(value) 与关系型数据库的区别 document中的field不要key俱全或一样 find()命令查询 bson的数据类型 # ＃bson 是json的扩展 # 增加了数据类型 # 把json数据转换成二进制码存到文件 null boolean undefined 数组 # 如{gps: [20, 56]} 32位和64位整数 # shell中不支持 ## node.js python java等高级语言的驱动中支持 64位浮点 # shell使用的全是这种类型, 如{x:3.14} utf-8 # 字符串类型 ObjectID Date # 如{x:new Date()} 正则 # 如{x:/uspcat/i} javascript块代码 # 如{x:function(){}} ## 相当于存储过程 内嵌文档 # 如{x: {xx: \u0026quot;a\u0026quot;}} 二进制 # shell中不能使用 ObjectId # 大小 12字节 显示为24个十六进制字符 # 空间换时间的思想 细节 前4字节是unix时间戳 后3字节集群machine hash 后2字节pid 后3字节inc自增计数器, 在前面都相等时全局自增 命名 # 数据库与集合名 不能是空字符串 特殊字符 ' (空格) , $ / \\ \\0 应该全小写 小于64字节 数据库名不与保留库名相同，如 admin, local, config 集合名 db-text合法，但不能db.db-text得到，要db.getCollection(\u0026quot;db-text\u0026quot;).text得到 # db-text 会认为是减法 ## 数据库名可以是db-text 可以a.b来命名来划分子集合 不能以system.开头命名 api # collection 增 save # 不存在时插入，存在时更新 # {$ref: 'user', $id: 1} 来保存引用 insert 删 remove('id': 'bar') # 删除一条数据 #remove()删除所有数据 drop() # 删除persons collection, 不释放文件空间 dropIndexes() # 删除所有索引 改 update(finder, updater, options或upser, multi) # $set # {age: {$gt: 18}, $isolated : 1} $isolated事务隔离该字段到本语句执行结束, does not work with sharded clusters findAndModify 查 findOne() find(finder, filter) # limit(3).skip(10).sort({name: -1, age: 1}) ## sort({$natural: 1}) 固定集合排序 # explain() 返回带统计信息的文档 ## 是否用到索引，耗时，需要扫描多少文件 # hint({}) 强制使用某索引查询 # null可以匹配null, 也可以匹配{$exists: false} # 正则可以匹配自身，也可以模式字符串 count() # document的条数 aggregate db # 默认存在的数据库admin, config, local sources # 从节点中设置的源collection help() persons.help() # 显示某集合的帮助 auth('username', 'pwd') # 切换用户 addUser() # addUser('admin', 'asdf') # addUser('readonly', 'asdf', true) listCommands() shutdownServer() eval() # 执行 stats() # 当前数据库的状态 ## 包括名称，collection数，索引数等 createCollection() # {'user', {capped: true, size: 100, max: 10}} ## 创建固定集合, 100字节, 文档数上限为10 ## 固定集合插入快，不能删除，无_id, 有尾部游标 getCollection(\u0026quot;persons\u0026quot;).text # 同db.persons dropDatabase() # 删除当前数据库 repairDatabase() # 释放空间 serverStatus() # 返回数据库的metrics 数据 serverStatus().metrics.cursor # 返回指针信息 ensureIndex({x: 1, y: -1}, {name: 'xy'}) # 建立x的升序, y的降序联合索引 # 只使用索引的前部, 即对x的查询可以用该索引 # {\u0026quot;gps\u0026quot;: '2d'} {'gps': '2dsphere'} ## 支持gps写成 [0, 0] {x: 0, y: 0} {latitude: 0, longitude: 0} 格式 # 可以索引内嵌文档 # {unique: true} 来建立唯一索引 # {dropDups: true} 将唯一索引中重复的文档都删掉 dropIndexes system indexes # 保留集合，索引 namespaces # 也包含索引信息 js insert({_id: 'fn', value: function() {}}) # 用db.eval('fn()') 执行 runCommand() # {'dropIndexes': 'col', 'index': 'ind'} # 可以返回命名执行的状态信息 {buildInfo: 1} {collStats: 'user'} {distinct: 'user', key: a, query: {b: 0}} {drop: 'user'} {dropDatabase: 1} {dropIndexes: 'user', index: 'ind'} {getLastError: 1} # 上次更新的作用信息 {getLastError: 1, w: 3} # 阻塞复制，有3个节点 {isMaster: 1} {findAndModify: 'user', query: {a: 0}, sort: {a: 1}, update: {$set: {a: 1}}} {listCommands: 1} {listDatabases: 1} {ping: 1} {renameCollection: 'user', to: 'user1'} {repairDatabase: 1} # 修复并压缩当前数据库 {serverStatus: 1} # globalLock: 全局写入锁占用了多少时间 # mem: 内存映射了多少数据 # indexCounters: B树磁盘检索(misses)和内存检索(hits)的次数 # backgroundFluhing: 后台做了多少次fsync及用的时间 # opcounters: 每种主要操作的次数 # asserts: 断言的次数 {convertToCapped: 'user', size: 100} # 转为固定集合 {fsync: 1, lock: 1} # 缓冲写入磁盘，并加写入锁。后可以直接复制磁盘数据来备份 # db.$cmd.sys.unlock.findOne() 解锁 # db.currentOp() 查看为空时已解锁 {resync: 1} # 从节点重新同步 {collMod: 'users', usePowerOf2Sizes: true} # 每次增大空间总是2的倍数，适用于常写的集合 rs isMaster slaveOk dcl help # 显示帮助 show dbs # 显示所有数据库 use mydb # 选择数据库(默认为test) ## 如果没有该数据库，则创建(插入第一条数据时实际创建) db # 显示当前数据库名 show collections # 查看当前数据库的collections db.eval() # 执行shell语法字符串 用户管理命令 use test # 选择需要添加用户的数据库 db.addUser('name','pwd') # 第三个参数代表是否只读 true代表是 , false代表否 ## db 代表本数据库，也就是test db.system.users.find() # 查看用户列表 db.auth('name','pwd') # 用户认证，反回１代表认证成功 db.removeUser('name') show users # 查看所有用户 # 注 权限生效需要mongod　以　-auth参数启动 admin数据库中的user是超级管理员 , 其他数据库中的user只限于本数据库 ttl(time to live) # mongodb每1分钟检查一次数据删除 db.log_events.ensureIndex({\u0026quot;createdAt\u0026quot;: 1}, {expireAfterSeconds: 3600 }) db.log_events.insert({ \u0026quot;createdAt\u0026quot;: new Date(), \u0026quot;logEvent\u0026quot;: 2, \u0026quot;logMessage\u0026quot;: \u0026quot;Success!\u0026quot; }) # 插入的这条数据在1小时后删除 db.log_events.ensureIndex({\u0026quot;expireAt\u0026quot;: 1}, {expireAfterSeconds: 0}) db.log_events.insert({ \u0026quot;expireAt\u0026quot;: new Date('July 22, 2013 14:00:00'), \u0026quot;logEvent\u0026quot;: 2, \u0026quot;logMessage\u0026quot;: \u0026quot;Success!\u0026quot; }) # 插入的这条数据在July 22, 2013 14:00:00删除 aggregate # mapReduce( function() {emit(this.cust_id, this.amount);}, # map function(key, values) {return Array.sum(values)}, # reduce { query: {status: 'A'}, # query out: 'order_totals' # output } ) distinct() count() group({ key: {a: 1}, # $keyf: function(x) {return x.category} 定义分组函数 cond: {a: {$lt: 3}}. $reduce: function(cur, result) {result.count += cur.count}, initial: {count: 0}, finalize: function (prev) {} }) # 返回的文档 {retval: [], count: 0, keys: 0, ok: 0} aggregate([ {$redact: {$cond: { if: {$eq: ['$level', 5]}, then: '$$PRUNE', else: '$$DESCEND' }}} {$match: {status: 'A'}}, {$geoNear: {...}}, {$project: {name: {$toUpper: '$_id'}, _id: 0}}, {$unwind: '$sizes'}, {$group: {_id: '$state', totalPop: {$sum: '$pop'}}}, {$skip: 10}, {$limit: 5}, {$sort: {age: -1}}, {$out: 'authors'} ]) 例子 o-\u0026gt; 得到tags数组的长度 db.users.aggregate([{ $group: { _id: '$username', tags_count: {$first: {$size: '$tags'}} } }]) db.users.aggregate([{ $project: { tags_count: {$size: '$tags'} } }]) expressions # $and $or $not $setEquals $setIntersection $setUnion $setDefference $setIsSubset $anyElementTrue $allElementsTrue $cmp $eq $gt $gte $lt $lte $ne $add $subtract $multiply $divide $mod $concat $substr $toLower $toUpper $strcasecmp $meta $size $map $let $literal $dayOfYear $dayOfMonth $dayOfWeek $year $month $week $hour $minute $second $millisecond $dateToString $cond $ifNull $sum $avg $first $last $max $min $push $addToSet $near $within $box $center 对象 # 全局函数 printjson connect('localhost:27017/mydb') # 连接另一个服务器 runProgram 对象类型 cursor hasNext() # 立即返回前100个数据与4Mb数据的较小者。取数据时直接读缓存 next() forEach 复制 # 复制 mongod --master --oplogSize 100 mongod --slave --source localhost:27017 # --source指定主节点 # --only 指定只复制特定的数据库 # --slavedelay 主从复制时的延时 # --fastsync 从节点是主节点快照时，加这个选项，同步速度快 # --autoresync 重新同步 # --oplogSize 主节点oplog的大小 db.sources.insert({host: 'localhost:27017'}) # 从节点设置主节点 副本集 # 没有主节点，集群自己选举主节点 # 数据太多从节点会自动停止同步 mongod --dbpath '/var/local/mongo1' --port 27017 --replSet rs0 # 三个实例replSet 名必叫 rs0 use admin rs.initiate({ _id: 'a', members: [{ _id: 1, host: 'localhost1:27017' }, { _id: 2, host: 'localhost1:27018' }] }) # 其中一台执行初始化 rs.add('localhost:27019') rs.status() db.getMongo().setSlaveOk() rs.isMaster() rs.conf() db.getReplicationInfo() db.printReplicationInfo() db.printSlaveReplicationInfo() use local db.addUser('name', 'pwd') # 复制认证时用 分片 # mongods --port 3000 --configdb localhost:27017 # 多个地址用,隔开 # 每个片都就是副本集 mongo localhost:3000/admin db.runCommand({addshard: 'localhost:27017‘, allowLocal: true}) # 在localhost上运行时, 要设allowLocal # 'a/localhost:27017' 让mongo知道这个片所在的副本集 db.runCommand({enablesharding: 'db1'}) db.runCommand({shardcollection: 'db1.user', key: {_id: 1}}) db.printShardingStatus() db.runCommand({removeshard: 'localhost:27017'}) shell # mongo 127.0.0.1:27017/admin # 启动sell , 默认数据库为test mongod –port 10000 –fork –logpath= logpath=/data/mongodb/log/mongodb.log -- logappend -- dbpath=/data/mongodb/data/db –config ~/.mongodb.conf # 启动服务 -auth开启身份验证 # --rest 开启http管理，其端口号比mongo端口号大1000 ## --nohttpinterface关闭http管理 # --bindip localhost 设置只能有某ip访问 # --noscripting 完全禁止服务端js执行 # --repair 启动并修复 # 不要发送SIGKILL信号关闭(kill -9), 应发送SIGINT或SIGTERM mongod --remove # 结束服务 // mongodb.conf port = 5586 fork = true logpath = mongodb.log mongodump --host 127.0.0.1 --port 27017 --out ./dir/name # 备份数据库 mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径 mongorestore --host 127.0.0.1 --port 27017 --directoryperdb ./dir/name # mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径 # --drop 是先删除现有的数据 mongoexport -d tank -c users -o /home/outrun/mongo # 导出整张表 ## mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 -f 字段 -q 条件导出 --csv -o 文件名 # mongoexport -d tank -c users --csv -f uid,name,sex -o tank/users.csv ## 导出表的部分字段 # mongoexport -d tank -c users -q '{uid:{$gt:1}}' -o tank/users.json ## 根据条件导出数据 mongoimport -d tank -c users --upsert tank/users.dat # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsert --drop 文件名 ## 还原整表导出的非csv文件, --upsert 表示插入或更新现有数据 # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsertFields 字段 --drop 文件名 ## 还原部分字段导出的文件, --upsertFields跟upsert一样 ## 如 mongoimport -d tank -c users --upsertFields uid,name,sex tank/users.dat # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --type 类型 --headerline --upsert --drop 文件名 ## 还原导出的csv文件 ## mongoimport -d tank -c users --type csv --headerline --file tank/users.csv mongofiles put foo.txt # 使用gridfs list get foo.txt search # 按文件名查找 delete foo.txt mongostat # 实时输出mongo状态 java client # 1.导入mongo-java-drver-2.9.3.jar 2.api Mongo m = new Mongo(\u0026quot;localhost\u0026quot;, 27017); DB db = m.getDB(\u0026quot;mydb\u0026quot;); boolean auth = db.authenticate(\u0026quot;root\u0026quot;, \u0026quot;root\u0026quot;.toCharArray()); System.out.println(\u0026quot;身份认证\u0026quot; + auth); // 获得所有数据库名 for (String s : m.getDatabaseNames()) { System.out.println(\u0026quot;db : \u0026quot; + s); } // 删除数据库 m.dropDatabase(\u0026quot;my_new_db\u0026quot;); // 获得collection列表 Set\u0026lt;String\u0026gt; colls = db.getCollectionNames(); for (String s : colls) { System.out.println(\u0026quot;collection : \u0026quot; + s); } // 获得一个collection DBCollection coll = db.getCollection(\u0026quot;testCollection\u0026quot;); // 创建document(包括内嵌文档) DBObject doc = new BasicDBObject().append(\u0026quot;appendField\u0026quot;, \u0026quot;appendField\u0026quot;); doc.put(\u0026quot;name\u0026quot;, \u0026quot;MongoDB\u0026quot;); doc.put(\u0026quot;type\u0026quot;, \u0026quot;database\u0026quot;); doc.put(\u0026quot;count\u0026quot;, 1); DBObject info = new BasicDBObject(); info.put(\u0026quot;x\u0026quot;, 203); info.put(\u0026quot;y\u0026quot;, 102); doc.put(\u0026quot;info\u0026quot;, info); // 插入文档 coll.insert(doc); // 查询文档 DBObject doc2 = coll.findOne(); System.out.println(doc2); // 统计文档数 long count = coll.getCount(); System.out.println(count); // 用游标遍历 DBCursor cursor = coll.find(); while (cursor.hasNext()) { DBObject object = cursor.next(); System.out.println(object); } // 查询 DBObject query = new BasicDBObject(); query.put(\u0026quot;i\u0026quot;, 71); cursor = coll.find(query); // 条件查询 query = new BasicDBObject(); query.put(\u0026quot;i\u0026quot;, new BasicDBObject(\u0026quot;$gt\u0026quot;, 50)); // i\u0026gt;50 cursor = coll.find(query); // 创建索引 coll.createIndex(new BasicDBObject(\u0026quot;i\u0026quot;, 1)); // 1代表升序 , -1是降序 // 查询索引 List\u0026lt;DBObject\u0026gt; list = coll.getIndexInfo(); for (DBObject index : list) { System.out.println(\u0026quot;索引 : \u0026quot; + index); } 类型 // 自动生成的唯一ID ObjectId id = new ObjectId(); System.out.println(id); "},{"id":15,"href":"/docs/db/postgresql/","title":"Postgre SQL","section":"数据库","content":" 命令 # initdb # 初始化数据库 --locale en_US.UTF-8 -D 'data' postgres # 启动数据库 -D 目录 -p 6543 pg_ctl start # 控制数据库: start, stop等 -D data -l a.log postmaster -D /data psql -d db1 -h localhost -p 5432 -U 用户名 -W # 强制要求验证密码 -f 导入sql命令文件, 或者在末尾加 \u0026lt; a.sql 来导入 -L 导出日志文件 o-\u0026gt; psql -U outrun -f pg.sql db1 # 导入数据 pg_dump # 导出数据库 -f # 指定文件 -U # 用户 -E UTF8 # 编码 -h localhost -n public # 指定schema -a # 只导数据，没有schema -F t # 压缩成tar o-\u0026gt; pg_dump -U outrun -f pg.sql db1 # 导出数据, -t tb1 导出表 pg_restore o-\u0026gt; pg_restore -U outrun -d db1 pg.tar # 导入压缩的数据 createdb # 创建数据库并指定 owner -hlocalhost -Upostgres -O 用户名 数据库名 dropdb -U user dbname 特色sql # 元命令 \\? # postgre命令 \\h # sql命令 \\l # 列出数据库 \\q # 退出 \\c 数据库名 # 切换数据库 \\d name # 查看序列、表、视图、索引 \\dS+ # 详情 \\du # 查看角色 \\dt # 查看所有表 \\dtS+ # 详情 \\ds # 查看序列 \\i a.sql # 执行sql文件 \\o a.log # 日志文件 \\password # 更换密码 \\x # 开启/关闭竖排显示 [sql] \\gdesc # 快速显示结果列名和类型 数据类型 serial # 4字节，自增序列 bigserial # 8字节 text default ''::text bigint default 0 # 8字节 smallint # 2字节 int, integer # 4字节 decimal # 变长, 声明精度，精确 numeric # 同上 float real # 4字节，变精度，不精确 double precision # 8字节，变精度，不精确 boolean default false text[] # text数组 date time timestamp with time zone interval bytea # 二进制 money uuid 约束 constraint user_id primary key (id) constraint user_m_id unique(m_id) constraint fk_b_id foreign key (b_id) references tbb(id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION dcl create database db1 owner outrun create user 'outrun' with password 'asdf' create role 用户名 with password '密码' login # 创建用户。role关键词可以省略 drop database db1 drop table tablename; alter database abc RENAME TO cba; alter database 数据库名 owner to 用户名 # 更改数据库 owner alter table tb add primary key (id) add foreign key(b_id) references tb(id) on update cascade on delete cascade add column c1 text alter column id type int using id::integer rename c1 to c2 drop constraint fk_b_id foreign key (b_id) references tbb(id) drop [column] name owner to outrun # 更改表 owner alter role 用户名 with login # 添加权限 password 'asdf' # with password 'asdf', 修改密码 VALID UNTIL 'JUL 7 14:00:00 2012 +8' # 设置角色有效期 login, superuser, createdb, createrole, replication, inherit grant all privileges on database 数据库名 to 用户名 # 授权数据库权限 ddl insert into tb(\u0026quot;desc\u0026quot;) values ('a'); 模糊查询 ~ # 匹配正则，大小写相关 除'a$' '^a'的正则都只适合pg_trgm的gin索引 ~* # 匹配正则，大小写无关 !~ # 不匹配该正则 !~* ~ '^a' like 'a%' ~ 'a$' ~ 'ab.c' like '%ab_c%' o-\u0026gt; 视图 CREATE VIEW myview AS SELECT city, temp_lo, temp_hi, prcp, date, location FROM weather, cities WHERE city = name; o-\u0026gt; 建表 create table dwh_timestamp_meta ( \u0026quot;id\u0026quot; serial NOT NULL, \u0026quot;id\u0026quot; serial primary key, \u0026quot;c_id\u0026quot; serial references cities(id), \u0026quot;mongo_document_name\u0026quot; text default ''::text, \u0026quot;last_update_time\u0026quot; bigint default 0, \u0026quot;execute_time\u0026quot; timestamp with time zone, constraint pk_id primary key(id) ) with ( oids=false ); o-\u0026gt; 序列 create table a( id bigint primary key ); create sequence a_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1; alter table a alter column id set default nextval('a_id_seq') 数据字典 # pg_roles # 角色信息 pg_database # 数据库信息 information_schema select column_name from information_schema.columns where table_schema='public' and table_name='ad'; # 表的所有列名 pg_stat_user_tables select relname from pg_stat_user_tables; # 所有表名 pg_stat_activity # 活动状态 SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE datname='garbage' AND pid\u0026lt;\u0026gt;pg_backend_pid(); # 查看数据库活动连接 配置 # 数据库目录 /usr/lib/systemd/system/postgresql.service jdbc driver : org.postgresql.Driver url : jdbc:postgresql://localhost:5432/postgres 初始用户名 : postgres 初始数据库 : postgres 存储过程 # drop function change_type1(); create or replace function change_type1() returns int as $body$ DECLARE r mongo_keys_type%rowtype; begin for r in select * from mongo_keys_type where type='number' loop EXECUTE 'alter table \u0026quot;' || r.\u0026quot;mongo_collection_name\u0026quot; || '\u0026quot; alter \u0026quot;' || r.\u0026quot;key\u0026quot; || '\u0026quot; type decimal'; END LOOP; return 0; end $body$ language 'plpgsql'; select change_type1() 案例 # 授权 grant all privileges on database 'db1' to 'outrun' alter role 'outrun' createdb alter role 'outrun' superuser 创建用户 create user 'outrun' with password 'asdf' create role 'outrun' createdb password 'asdf' login 修改密码 alter user 'outrun' with password 'asdf' "},{"id":16,"href":"/docs/pl/java/java_reactive/","title":"Java响应式编程","section":"Java","content":" Java响应式层级 # Level 0: Thread \u0026amp; Runnable (Java 1+) Level 1: ExecutorService, Callable, Future (Java 5+) Level 2: ForkJoinPool (Java 7+) Level 3: CompletableFuture (Java 8+) Level 4: reactive streams, Flow (Java 9+) Level 5: HTTP/2 client (Java 11+) Level 6: Reactive libraries (RxJava, Reactor) Level 7: Reactive services (Vert.x, Spring, Kafka) Flow # Flow.Publisher Flow.Subscriber Flow.Subscription # link publisher和subscriber Flow.Processor # subscriber和publisher的act ReactiveX # Flux Mono RxJava # 模型\tObservable Subscriber Reactor # Vert.x # AKKA # "},{"id":17,"href":"/docs/middleware/container/nginx/","title":"Nginx","section":"Container","content":" 基础 # 结构 一个主进程(root权限运行)和多个工作进程(普通权限运行) 优点 异步非阻塞 非常稳定 反向代理 后端服务io能力不高，nginx buffer http请求直到完整，再发送到后端。同样buffer响应 相对apache 轻量 apache阻塞 占资源低 模块化设计 社区活跃, bug少 多进程模型 使用epoll 多worker处理，业务阻塞时切换调度, 结束阻塞时分配 模块 handler filter upstream load-balance 功能 http 可以保持session， 相同的ip分配到同一个服务器上 缓存静态页面到内存，建立索引与自动索引 反向代理 负载均衡 模块化 过滤器 gzipping, byte ranges, chunked responses, SSI-filter 支持SSL与TLS SNI imap/pop3代理 命令 nginx -c /etc/nginx/nginx.conf nginx -s quit nginx -s stop nginx -s reload # 重载设置 ## service nginx reload nginx -v # 查看版本 ## -V nginx -t [-c nginx.conf] # 检查配置文件是否正确 nginx -h # 查看帮助 ## -? pkill -9 nginx kill -HUP `nginx.pid` # 平滑重启。尝试解析配置文件，成功时应用新配置(否则继续使用旧配置)，运行新的工作进程并从容关闭旧工作进程 ## 继续为当前连接客户提供服务 # 支持 QUIT TERM INT USR1(重新打开日志文件，切割日志时用) USR2(平滑升级可执行程序) WINCH(从容关闭工作进程) 配置 # http://nginx.org/en/docs/dirindex.html 域 main http server location worker_rlimit_nofile 51200; # worker最大打开文件数的限制, 不设时为系统限制 pid /var/run/nginx.pid; # nginx.pid文件中存储当前nginx主进程的pid 例子 user www-data; worker_processes 4; pid /run/nginx.pid; events { worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable \u0026quot;msie6\u0026quot;; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; ## # nginx-naxsi config ## # Uncomment it if you installed nginx-naxsi ## #include /etc/nginx/naxsi_core.rules; ## # nginx-passenger config ## # Uncomment it if you installed nginx-passenger ## #passenger_root /usr; #passenger_ruby /usr/bin/ruby; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } #mail { # # See sample authentication script at: # # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript # # # auth_http localhost/auth.php; # # pop3_capabilities \u0026quot;TOP\u0026quot; \u0026quot;USER\u0026quot;; # # imap_capabilities \u0026quot;IMAP4rev1\u0026quot; \u0026quot;UIDPLUS\u0026quot;; # # server { # listen localhost:110; # protocol pop3; # proxy on; # } # # server { # listen localhost:143; # protocol imap; # proxy on; # } #} o-\u0026gt; app.zlycare.com server { listen 80; listen [::]:80; server_name app-test.zlycare.com www.app-test.zlycare.com; # access log file access_log /home/zlycare/data/app-zlycare-com.log; location / { gzip on; default_type text/plain; charset utf-8; root /home/zlycare/app/zlydoc-cloud/public; index index.html; } } o-\u0026gt; web.zlycare.com server { listen 80; listen [::]:80; server_name web-test.zlycare.com www.web-test.zlycare.com; # access log file access_log /home/zlycare/data/web.zlycare.log; location / { proxy_pass http://127.0.0.1:8082; #proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } o-\u0026gt; sdk.com server { listen 80; server_name 10.162.201.58; # access log file access_log /home/zlycare/data/app-zlycare-com.log; location / { gzip on; default_type text/plain; charset utf-8; root /opt/sdk/nginx; index index.html; } } 代理 # nginx server{ resolver x.x.x.x; listen 82; location / { proxy_pass http://$http_host$request_uri; } } 不能有hostname, 必须有resolver, 即DNS服务器ip $http_host和$request_uri是nginx系统变量 用户机器 export http_proxy=http://nginx-ip:82 反向代理 # upstream backend { hash $consistent_key consistent server 192.168.61.1:9080 weight=1 server 192.168.61.1:9090 weight=2 } location / { proxy_pass http://backend set $consistent_key $arg_cat; # 从cat参数取值 if ($consistent_key = \u0026quot;\u0026quot;) { set $consistent_key $request_uri; } } 上游服务器, 权重越高分配越多 请求/时，代理到backend配置的上游服务器 负载均衡算法 round-robin(轮询) ip-hash ip_hash hash key/hash key consistent # hash和一致性hash hash $uri least_conn # 最小连接数服务器 least_time # 最小平均响应时间, 商业版 php # conf/nginx.conf server{ location / { proxy_pass http://127.0; proxy_redirect default; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $http_connection; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; } } default.conf server { listen 80; server_name epinkr.com www.epinkr.com; #server_name localhost; if ( $host != 'www.epinkr.com' ) { rewrite ^/(.*)$ http://www.epinkr.com/$1 permanent; } #root /home/qipin/deploy; index index.php index.html index.htm; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location = / { root /home/qipin/deploy; # index index.html index.htm; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root/index.php; include fastcgi_params; } location / { root /home/qipin/deploy; index index.html index.htm; } location /photo { root /home/qipin/data; # return 402; # rewrite ^\\/yuepin\\/(.*) /$1 last; } location ~ ^\\/(\\w+)\\/css\\/ { root /home/qipin/deploy; rewrite ^\\/(\\w+)\\/css\\/(.*) /css/$2 last; } location ~ ^\\/(\\w+)\\/img\\/ { root /home/qipin/deploy; rewrite ^\\/(\\w+)\\/img\\/(.*) /img/$2 last; } location ~ ^\\/(\\w+)\\/js\\/ { root /home/qipin/deploy; rewrite ^\\/(\\w+)\\/js\\/(.*) /js/$2 last; } location ~ ^\\/user\\/(\\w+)$ { root /home/qipin/deploy; # return 402; rewrite ^\\/user\\/(\\w+) /php/user/user_$1.php last; } location ~ ^\\/company\\/(\\w+)$ { root /home/qipin/deploy; # return 402; rewrite ^\\/company\\/(\\w+) /php/company/company_$1.php last; } location ~ ^\\/vendor\\/(\\w+)$ { root /home/qipin/deploy; # return 402; rewrite ^\\/vendor\\/(\\w+) /php/vendor/vendor_$1.php last; } location ~ ^\\/person\\/(\\w+)$ { root /home/qipin/deploy; # return 402; rewrite ^\\/person\\/(\\w+) /php/person/person_$1.php last; } location ~ ^\\/get\\/(\\w+)$ { root /home/qipin/deploy; # return 402; rewrite ^\\/get\\/(\\w+) /php/yp_$1.php last; } location ~ ^\\/(\\w+)$ { root /home/qipin/deploy; # return 402; rewrite ^\\/(\\w+)$ /php/$1.php last; } location ~ ^\\/php\\/(\\w*\\.php)$ { root /home/qipin/deploy; # return 403; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root/php/$1; include fastcgi_params; } location ~ ^\\/php\\/(\\w+)\\/(\\w*\\.php)$ { root /home/qipin/deploy; # return 403; # try_files $uri =404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root/php/$1/$2; include fastcgi_params; } #location /qipin/ { # root /home/qipin/deploy; # return 402; # index index.html; # rewrite ^\\/qipin\\/(.*) /$1 last; #} #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } ssl.conf #HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate /etc/nginx/cert.pem; # ssl_certificate_key /etc/nginx/cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root /usr/share/nginx/html; # index index.html index.htm; # } #} 插件 # HttpLimitReqModul 介绍 限制单个ip一段时间的连接数 http{ limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s; server { location { limit_req zone=allips burst=5 nodelay; } } } HttpLimitConnModul 介绍 限制单个ip的并发连接数 HttpLimitZoneModul 介绍 限制ip连接内存大小 http { limit_conn_zone $binary_remote_addr zone=namea:10m; # $binary_remote_addr 同一客户端ip地址 # 1.1.18前是limit_zone limit_conn_zone $server_name zone=nameb:10m; # $server_name 同一server的名字 server { location { limit_conn namea 20; limit_conn nameb 20; # 并发连接数 limit_rate 100k; # 下载速度 } } } "},{"id":18,"href":"/docs/middleware/container/nodejs/","title":"Nodejs","section":"Container","content":" 基础 # 特点 commonJS规范 javascript书写(v8引擎) js设计之初就可以运行在后端 v8 成熟的事件驱动模式 没有i/o库, 没有历史包袱 v8性能好 单线程 不用在意多线程状态同步(没有死锁, 没有上下文切换) 无法利用多核, 错误时应用退出，计算密集时无法调度 # child_process解决 事件驱动(event-driven), 回调 event loop [while(true)] -\u0026gt; watcher -\u0026gt; handles watcher产生事件后, event loop取到并执行其handle(回调函数) event loop每一周询问多个watcher是否有事件 event loop中没有watcher时进程退出 http模块就是启动了一个watcher,所以执行后进程不结束 其它watcher有 timer, fs, udp/req, process 不同操作系统中event driven的实现: windows: IOCP Linux: epoll Mac:kqueue 非阻塞io(non-blocking i/o model) io与数据处理分离（所以必须异步） 线程池结合event-driven实现 异步io go语言有协程(coroutine)而node.js没有，协程可以同步式编程 # 有第三方协程模块 promise(commonJs的规范, 其实现有whenJs, Q) # 书写难度降低 eventProxy # 朴灵 async/step commonJS 模块 var math = require('math') # 缓存优先，核心模块优先。依次找.js, .node, .json exports.add = function(){} 二进制 Buffer 字符集编码 I/O流 进程环境 文件 套接字 单元测试 web网关 包管理 package.json bin lib doc test 实现技术 libev的windows与linux接口实现 c++扩展 事件循环 # 生产者消费者模型 执行一次称为Tick 询问观察者(文件、网络等)是否有待处理事件, 有关联回调执行回调 # 观察者先idle, 再io, 再check 通过请求对象实现，绑定回调、运行参数、执行标志 层次 javascript v8 node libuv *nix/ windows # 分别编译 应用 I/O密集服务 cpu密集用c/c++扩展，用子进程 工具 # node --v8-options | grep harmony # 查看支持的es6特性 npm 介绍 cnpm是一个alibaba开发维护的，提供私有npm注册服务 -v # 版本 install # 安装，会执行package.json中scripts的勾子命令 -g uninstall config list # 查看项目的默认设置。registry属性指向npm官方资源位置 set registry http://192.168.1.20:7001 # 设置源 test # package.json中scripts的test o-\u0026gt; 搭建cnpm服务器 git clone https://github.com/cnpm/cnpmjs.org.git cd cnpmjs.org npm install npm -g # 升级npm的版本 npm install 创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码 config/index.js中注释bindingHost来对外网开放 node --harmony_generators dispatch.js # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问 o-\u0026gt; 使用私有库 npm install ape-algorithm --registry=http://192.168.1.20:7001 # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份 设置 ~/.npmrc registry=http://192.168.1.20:7001 # 淘宝翻墙库 https://registry.npm.taobao.org/ n node-gyp # 编译c/c++模块 nvm cnpm 介绍 cnpm是一个alibaba开发维护的，提供私有npm注册服务 安装 npm install cnpm # 可以像使用npm一样使用 cnpm sync gulp # npm 中发布的包在cnpm中有延时，可以用这个命令来手动同步 搭建cnpm服务器 git clone https://github.com/cnpm/cnpmjs.org.git cd cnpmjs.org npm install npm -g # 升级npm的版本 npm install 创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码 config/index.js中注释bindingHost来对外网开放 node --harmony_generators dispatch.js # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问 使用私有库 npm install ape-algorithm --registry=http://192.168.1.20:7001 # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份 项目设置私有库 npm config list # 查看项目的默认设置。registry属性指向npm官方资源位置 npm config set registry http://192.168.1.20:7001 用户设置私有库 // ~/.npmrc registry=http://192.168.1.20:7001 # 另外，淘宝翻墙库 https://registry.npm.taobao.org/ 调试 o-\u0026gt; 代码中插入断点 debugger; o-\u0026gt; 以debug模式运行 # debug模式运行时, help查看可用命令 node debug app.js 配置 # package.json name # 包名 description # 简介 version # 版本 keywords # 搜索关键词 maintainers # 维护者 contributors # 代码贡献者 bugs # 反馈bug的地址 licenses # 许可证 repositories # 托管代码地址 dependencies # 依赖包 homepage # 该包网站 os # 操作系统支持列表 cpu # cpu架构支持列表 engine # 支持的js引擎, 如ejs builtin # 内建在底层系统的哪些组件上 directories # 目录说明 implements # 实现了commonJS哪些规范 scripts # 脚本命令 preinstall install uninstall test author # 包作者 bin # 全局安装时，命令安装的位置 main # require()包时入口，默认找index devDependencies # 开发时需要的依赖 o-\u0026gt; { \u0026quot;name\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.1.0\u0026quot;, \u0026quot;keywords\u0026quot;: [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;], # npm search时用 \u0026quot;description\u0026quot;: \u0026quot;A testing package\u0026quot;, \u0026quot;os\u0026quot;: [\u0026quot;linux\u0026quot;, \u0026quot;darwin\u0026quot;], \u0026quot;author\u0026quot;: \u0026quot;outrun\u0026lt;outrun@mail.com\u0026gt;\u0026quot;, \u0026quot;dependencies\u0026quot;: { \u0026quot;express\u0026quot;: \u0026quot;^1.0.0\u0026quot;, \u0026quot;redis\u0026quot;: \u0026quot;\u0026gt;= 0.6.7\u0026quot; }, \u0026quot;devDependencies\u0026quot;: { \u0026quot;grunt\u0026quot;: \u0026quot;^0.4.5\u0026quot; }, \u0026quot;main\u0026quot;: \u0026quot;index\u0026quot;, \u0026quot;bin\u0026quot;: { \u0026quot;test\u0026quot;: \u0026quot;./bin/test.js\u0026quot; }, \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;node server.js\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;vows test/*.js\u0026quot;, # \u0026quot;grunt test\u0026quot; \u0026quot;mocha test\u0026quot; \u0026quot;make test\u0026quot; \u0026quot;make test-all\u0026quot; \u0026quot;preinstall\u0026quot;: \u0026quot;./configure\u0026quot;, \u0026quot;install\u0026quot;: \u0026quot;make \u0026amp;\u0026amp; make install\u0026quot;, \u0026quot;uninstall\u0026quot;: \u0026quot;\u0026quot; }, \u0026quot;engines\u0026quot;: { \u0026quot;node\u0026quot;: \u0026quot;5.0.0\u0026quot; } } api # 异步api # I/O操作api setTimeout() setInterval() 定时器插入观察者的红黑树中, tick时迭代定时器，如果超时就形成事件 # 如果前一个tick耗时大，定时会拖后 # 比较浪费性能 process.nextTick() 回调放入队列，下tick全部执行, 位于idle观察者 setImmediate() 回调放入链表, 每tick执行一个，位于check观察者，晚于idle 宿主对象 # global #全局对象 root # 指向自己 BLOBAL # 指向自己 setTimeout() setInterval() clearTimeout() clearInterval() process #当前进程 argv # 获得命令行参数数组 title # node version # v0.12.2 事件 process.on(\u0026quot;uncaughtException\u0026quot;,function(e){ console.log(\u0026quot;error:\u0026quot;+e); }); buffer 特点 node中buffer不属于v8, 使用c++扩展编写。所以可以使用高于1.4g的内存 一个元素一字节 8kb之内为小对象，slab机制分配内存, 先申请后分配。大于8kb的创建SlowBuffer对象 pool的实现方式 字符编码类型 # 默认编码UTF-8, 一个buffer只能有一个编码 ascii utf-8 utf-16le/ucs-2 base64 binary hex length write() # write(str, [offset], [length], [encoding]) toString() # toString([encoding], [start], [end]) isEncoding() # 指定编码是否支持转换 copy() # 复制自身到另一个buffer的某位置 buf.copy(buffer, 0) concat() #静态方法 concat(chunks, size) # chunks中为buffer数组, size为总大小 使用 new Buffer(100) new Buffer('a', 'UTF-8') console #控制台 log('',obj) console.log('[%s] listening on http://127.0.0.1:%d', app.setting.env, port) module Module.exports真正的接口，导出的是一个类型 exports是Module.exports的包装，导出的是Object类型的对象 promise # 0.11.x后加入的全局对象 使用 # 复制 var jadeTemplate = new Promise(function(resolve, reject) { fs.readFile(path.join(__dirname, 'views/article.jade'), function(err, data) { if (err) { reject(err.message); } else { resolve(data.toString()); } }); }); var localData = new Promise(function(resolve, reject) { fs.readFile(path.join(__dirname, 'static/shuffle.json'), function(err, data) { if (err) { reject(err.message); } else { resolve(JSON.parse(data.toString())); } }); }); Promise .all([jadeTemplate, localData]) .then(function(value) { console.log(jade.compile(value[0])(value[1])); }); 内置lib # http # 介绍 继承自net模块 EventEmitter实例 事件 服务端 connection request close checkContinue # 发送较大数据时，先发送Expect: 100-continue请求头，此时触发 connect upgrade # 要求升级连接协议时 clientError # 客户端触发error事件时触发 客户端 response socket # 建立连接时触发 connect # 响应200时触发 upgrade continue globalAgent # 重用http长连接，实际是个连接池，默认有5个并发 sockets # 连接数 requests # 处于等待状态的请求数 createServer(onRequest).listen(8888, func); # 创建服务器并启动 request req.setEncoding(\u0026quot;utf8\u0026quot;) var postData = \u0026quot;\u0026quot;; req.addListener(\u0026quot;data\u0026quot;, function(postDataChunk){ postData += postDataChunk; }); req.addListener(\u0026quot;end\u0026quot;, function(){ route(handle, pathname, res, postData); }); # 拼接post请求数据 req.rawBody # post来的原生数据 req.destroy() # 放弃请求，停止招收 response res.setHeader('WWW-Authenticate', 'Basic realm=\\\u0026quot;Tomcat Manager Application\\\u0026quot;') res.writeHead(200, {\u0026quot;Content-Type\u0026quot;: \u0026quot;text/html\u0026quot;}); # 调用setHeader多次，调用writeHead后才写入 res.write(\u0026quot;\u0026quot;); res.write(file,?\u0026quot;binary\u0026quot;);? res.end(); request(options, fn) # 发起客户端请求 # options中有 host, hostname, port, localAddress(使用本地的哪个网卡), socketPath(本地套接字文件路径), method, path, headers, auth(被计算成请求头的Authorization部分), agent(并发连接数，默认5) https # 介绍 nodejs 申请ca证书 访问端口为443 使用 express -e nodejs-https cd nodejs-https \u0026amp;\u0026amp; npm install git --version openssl version -a openssl genrsa -out privatekey.pem 1024 # 生成证书文件 openssl req -new -key privatekey.pem -out certrequest.csr # 通过私钥生成CSR证书签名 openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem # 通过私钥和证书签名生成证书文件 ## 这时生成了三个文件: certificate.pem, certrequest.csr, privatekey.pem ### 分别是: 证书文件, CSR证书签名, 私钥 ## 由于证书是自己创建的，没有经过第三方机构验证，用户访问时会出现警告提示 服务器 var https = require('https') , fs = require('fs'); var options = { key: fs.readFileSync('./privatekey.pem'), cert: fs.readFileSync('./certificate.pem') }; https.createServer(options, app).listen(3011, function(){ console.log('Https server listening on port: ' + 3011); }); 客户端 var options = { hostname: 'localhost', port: 8000, path: '/', method: 'GET', key: fs.readFileSync('./keys/client.key'), cert: fs.readFileSync('./keys/client.crt'), ca: [fs.readFileSync('./keys/ca.crt')] # 设置rejectUnauthorized: false 来忽略ca验证 } options.agent = new https.Agent(options) var req = https.request(options, function (res) { res.setEncoding('utf-8') res.on('data', function (d) { console.log(d) }) }) req.end() req.on('error', function(e){ console.log(e) }) net # 介绍 处理tcp请求 socket是EventEmitter的Stream实例 注意 默认开启Nagle, 会合并小数据成一个数据包延迟发送 socket.setNoDelay(true)关闭Nagle 并不是每次write都触发data事件, 关掉Nagle后，可能接收到多个小数据包后触发一次data 服务器事件 listening connection close error 连接事件 data end connect drain # 任意一端调用write时触发 error close timeout o-\u0026gt; 基本服务 # telnet来测试 var net = require('net') var server = net.createServer(function (socket) { socket.on('data', function (data) { socket.write('a') }) socket.on('end', function () { console.log('disconnected.') }) socket.write('welcome') }) server.listen(8124, function () { console.log('server bound') }) o-\u0026gt; 基本服务2 var server = net.createServer() server.on('connection', function (socket) {}) server.listen(8124) o-\u0026gt; 监听 server.listen('/tmp/echo.sock') # nc -U /tmp/echo.sock 来测试 o-\u0026gt; 客户端 var client = net.connect({port: 8124}, function () { console.log('client connected') client.write('a') }) client.on('data', function (data) { console.log(data.toString()) client.end() }) client.on('end', function() { console.log('disconnected.') }) o-\u0026gt; 客户端 var client = net.connect({path: '/tmp/echo.sock'}) o-\u0026gt; 管道 var server = net.createServer(function (socket) { socket.write('a') socket.pipe(socket) }) dgram # 介绍 处理udp socket是EventEmitter实例 o-\u0026gt; 服务 var dgram = require('dgram') var server = dgram.createSocket('udp4') server.on('message', function (msg, rinfo) { console.log(msg + 'from' + rinfo.address + ':' +) }) server.on('listening', function () { var address = server.address() console.log('listening ' + address.address + ':' + address.port) }) server.bind(41234) o-\u0026gt; 客户端 var message = new Buffer('a') var client = dgram.createSocket('udp4') client.send(message, 0, message.length, 41234, 'localhost', function (err, bytes) { client.close() }) events # 介绍 几乎所有对象的父类 使用 var events = require('events') , util = require('util'); function Obj(){events.EventEmitter.cal(this);} util.inherits(Obj, events.EventEmitter); # Obj.prototype.__proto__ = events.EventEmitter.prototype; Obj.prototype.write = function (data) {this.emit('data', data);}; var obj = new Obj(); obj.on('data', function (data) {console.log('Received data', data);}) # obj.once obj.write('hello'); setMaxListeners(0) # 侦听器过多不警告 path # os # 方法 totalmem freemem fs # fs.readFile(\u0026quot;tmp/test.png\u0026quot;, \u0026quot;binary\u0026quot;, function(error, file){ }); fs.writeFile('target.png', 'binary', function(err){ }) fs.exists(filePath, function(exists){ if(exists){} }) fs.unlink(filePath, function(err){ }) fs.renameSync(files.upload.path,?\u0026quot;/tmp/test.png\u0026quot;); # 写入文件(阻塞) o-\u0026gt; 流读写 var reader = fs.createReadStream('in.txt') # 第二个参数为设置, highWaterMark: 每次读取的size, encoding: 编码 var writer = fs.createWriteStream('out.txt') reader.on('data', function (chunk) { writer.write(chunk) }) reader.on('end', function() { writer.end() }) var reader = fs.createReadStream('in.txt') var writer = fs.createWriteStream('out.txt') reader.pipe(writer) sys # process # argv # 启动时参数 pid # 当前进程的pid once() once('SIGINT', function () {}) # ctrl + c memoryUsage() # 查看v8内存使用量 # 其中rrs是resident set size, 是常驻内存的部分，其他在swap或文件系统中 kill() # process.kill(pid[, signal]) on() # 事件触发 o-\u0026gt; process.on('SIGTERM', function () { console.log('Got a SIGTERM, exiting...') process.exit(1) }) o-\u0026gt; process.on('uncaughtException', function () { logger.error(err) process.send({act: 'suicide'}) # 向主进程发送信号 worker.close(function () { process.exit(1) }) setTimeout(function () { # 长连接断开需要时间较久, 超时自动退出 process.exit(1) }, 5000) }) module # exports parent stream # 介绍 继承EventEmitter, 处理文件之类的流 tls # 介绍 建立在tls/ssl上的加密tcp 使用openssl来构建证书和测试 o-\u0026gt; 服务器 var tls = require('tls') var fs = require('fs') var options = { key: fs.readFileSync('./keys/server.key'), cert: fs.readFileSync('./keys/server.crt'), requestCert: true, ca: [fs.readFileSync('./keys/ca.crt')] } var server = tls.createServer(options, function (stream) { console.log('server connected', stream.authorized ? 'authorized' : 'unauthorized') stream.write('welcome!\\n') stream.setEncoding('utf8') stream.pipe(stream) }) server.listen(8000, function () { console.log('server bound') }) o-\u0026gt; 客户端 var options = { key: fs.readFileSync('./keys/client.key'), cert: fs.readFileSync('./keys/client.crt'), ca: [fs.readFileSync('./keys/ca.crt')] } var stream = tls.connect(8000, options, function () { console.log('client connected', stream.authorized ? 'authorized' : 'unauthorized') # 证书是否通过 process.stdin.pipe(stream) }) stream.setEncoding('utf8') stream.on('data', function (data) { console.log(data) }) stream.on('end', function () { server.close() }) child_process # 介绍 可以创建新的node进程 spawn(command[, args][a options]) # command执行的命令 # args参数列表 options 环境变量对象, 包括7个属性 cwd 子进程当前工作目录 env 环境变量键值对 stdio 子进程stdio配置 customFds 子进程stdio使用的文件标示符 detached 进程组的主控制 uid 用户进程id 进程组id var du = child.spawn('du', ['-sh', '/disk1']); du.stdout.on('data', function(data){}) du.stderr.on('data', function(data){}) du.on('exit', function(code){}) exec('') # 对spawn的友好封装, 增加了shell命令解析 child.exec('cat *.js | ws', function(error, stdout, stderr){}) execFile(command[, args]) # 执行可执行文件，不解析args,防止了exec参数注入的风险 child.execFile('/bin/ls', ['-l', '.'], function(err, result){}) fork() # 同spawn, 但建立ipc(进程通信, inter-process communication) var n = child.fork('./son.js'); n.on('message', function(){ console.log('Main listen: ', m); }); n.send({hello: 'i am parent'}); // son.js process.on('message', function(m){ console.log('Son listen: ', m); }); process.send({hello: 'i am child'}); 子进程对象 send() # 发送消息和句柄，句柄可以是 ## net.Socket, net.Server, net.Native(c++层面的tcp套接字或IPC管道), dgram.Socket, dgram.Native kill() # 向子进程发送SIGTERM信号 事件 message error exit close disconnect o-\u0026gt; cpu核数worker o-\u0026gt; master.js var fork = require('child_process').fork var cpus = require('os').cpus() for (var i = 0; i \u0026lt; cpus.length; i++){ fork('./worker.js') } o-\u0026gt; worker.js var http = require('http') http.createServer(function(req, res){...}).listen(Math.round((1+Math.random()) * 1000), '127.0.0.1') o-\u0026gt; spawn var spawn = require('child_process').spawn free = spawn('free', ['-m']) free.stdout.on('data', function (data) {}) free.stderr.on('data', function (data) {}) free.on('exit', function (code, signal) {}) o-\u0026gt; fork # 需要至少30ms, 10M启动一个v8实例 var fork = require('child_process').fork var cpus = require('os').cpus() for (var i = 0; i \u0026lt; cpus.length; i++) { fork('./worker.js') } o-\u0026gt; 通信 # 只有子进程是node进程时才可以通信 var cp = require('child_process') var n = cp.fork(__dirname + '/sub.js') n.on('message', function (m) { console.log('PARENT got message: ', m) }) n.send({a: 1}) process.on('message', function (m) { console.log('CHILD got message:', m) }) process.send({b: 2}) o-\u0026gt; 句柄通信 # 节省了代理建立socket浪费的文件描述符 var child = require('child_process').fork('child.js') var server = require('net').createServer() server.on('connection', function (socket) { socket.end('handled by parent \\n') }) server.listen(1337, function () { child.send('server', server) }) // child.js process.on('message', function (m, server) { if (m === 'server') { server.on('connection', function (socket) { socket.end('handled by child \\n') }) } }) o-\u0026gt; 句柄负载http # 对描述符是抢占式的 var cp = require('child_process') var child1 = cp.fork('child.js') var child2 = cp.fork('child.js') var server = require('net').createServer() server.listen(1337, function () { child1.send('server', server) child2.send('server', server) server.close() }) // child.js var http = require('http') var server = http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}) res.end('handled by child, pid is ' + process.pid + '\\n') }) process.on('message', function (m, tcp) { if (m === 'server') { tcp.on('connection', function (socket) { server.emit('connection', socket) }) } }) cluster # 介绍 child_process和net模块的组合 cluster启动时，内部启动tcp服务器 fork()时，将tcp服务器socket文件描述符发给worker, 实现共享端口 isWorker 判断process.env是否值为NODE_UNIQUE_ID isMaster 判断cluster.isWorker 事件 fork # fork时 online # 工作进程创建好后 listening # 工作进程调listen()后 disconnect # 主进程和工作进程IPC通道断开后 exit # 所有工作进程退出后 setup # cluster.setupMaster()执行后 o-\u0026gt; cpu核数worker var cluster = require('cluster') cluster.setupMaster({ exec: \u0026quot;worker.js\u0026quot; }) var cpus = require('os').cpus() for (var i = 0; i \u0026lt; cpus.length; i++) { cluster.fork() } domain # 介绍 用于异步异常捕获 绑定方式 隐式绑定: 把domain上下文中定义的变量，自动绑定到domain对象 显式绑定: 把不是domain上下文中定义的变量，以代码的方式绑定到domain对象 members # 已加入domain对象的域定时器和事件发射器的数组 create() # 返回一个domain对象 run(fn) # 在domain上下文中执行一个函数，并隐式绑定所有事件、定时器和低级请求 add(emitter) # 显式的增加事件 remove(emitter) # 删除事件 bind(callback) # 以return为封闭callback函数　intercept(callback) # 同bind, 但返回第一个参数 enter() # 进入一个异步调用的上下文，绑定到domain exit() # 退出当前的domain, 切换到不同的链的异步调用的上下文中，对应domain.enter() dispose() # 释放一个domain对象，让node进程回收这部分资源 使用 var domain = require('domain'); function async_error(){ setTimeout(function(){ var r = Math.random() * 10; console.log('random num is ' + r); if(r \u0026gt; 5) throw new Error('Error: random num ' + r + ' \u0026gt; 5'); }, 10); } var d = domain.create(); d.on('error', function(err){ console.log(err); }); setInterval(function(){ d.run(async_err); }, 1000); 未绑定不捕获 代码 var domain = require('domain'); var EventEmitter = require('events').EventEmitter; var e = new EventEmitter(); var timer = setTimeout(function(){ e.emit('data'); }, 10); function next(){ e.once('data', function(){ throw new Error('Receive data error!'); }); } var d = domain.create(); d.on('error', function(err){ console.log(err); }); d.run(next); 原因 timer和e两个关键对象在初始化时都没有在domain范围内。当next函数中抛出异常时, 没有处于domain的包裹中 修改 ... d.add(e); d.add(timer); d.run(next); 外部lib # url # parse() pathname url.parse(req.url) url.parse(req.url, true) 会parse出query对象 querystring # parse() querystring.parse(url.parse(req.url).query) crypto # 介绍 加密并生成各种散列 利用openssl库来实现，提供openssl中一系列哈希方法，包括hmac, cipher, decipher, 签名和验证等方法的封装 使用 var crypto = require('crypto'); console.log(crypto.getHashes()); # 打印支持的所有hasp算法 node-gyp # 编译C++模块的编译工具 util # 使用 var util = require('util'); 方法 inherits(Sub, Base) # 对象间原型继承，Sub 仅继承Base原型中定义 的函数 inspect(obj) # 任意对象转换为字符串 log(string) # 带时间戳的log format('%s:%s', 'a', 'b', 'c') // 'a:b c' # format('%s:%s', 'a') // 'a:%s' # format(1, 2, 3) // '1 2 3' is系列 isArray(obj) isRegExp(obj) isDate(obj) isError(obj) isBoolean(obj) isNull(obj) isNullOrUndefined(obj) isNumber(obj) isString(obj) isSymbol(obj) isUndefined(obj) isObject(obj) isFunction(obj) isPrimitive(obj) # 是否基本类型 isBuffer(obj) deprecate(foo, 'foo() is deprecated, use bar() instead'); # 标记为过时, 调用foo()时显示后面的话 zlib # 介绍 提供压缩方法，如gzip 全局属性 # 介绍 并非挂在global下的属性，但可以直接使用 __dirname # 在任何模块内获取当前模块文件的绝对路径 __filename # 当前在执行的js文件路径 方案 # 异常捕获 process.on(\u0026quot;uncaughtException\u0026quot;,function(e){ logger.error(\u0026quot;error:\u0026quot;+e); }); process.on('unhandledRejection', function (err, p) { console.error(err.stack) }); "},{"id":19,"href":"/docs/middleware/distributed/spring_cloud/","title":"Spring Cloud","section":"支撑-分布式","content":" 亿级流量 # 流量接入层 # 二级域名 泛域名 A记录 dns解析 udp 向网关请求dns解析 httpDNS 用ip请求http服务, 返回域名解析的ip 因为用ip请求，适合app，不适合网页 lvs + keepalive # 多lvs时用dns负载 nginx openresty kong 动静分离 cdn dns动态域名解析 cdn分发服务 源服务拉取FastDFS CDN节点分发 WEB服务层 # webflux 不基于重量的servlet标准 基于netty Eureka # 使用 @EnableEurekaServer application.properties eureka.client.register-with-eureka=false # 是否注册自己 eureka.client.fetch-registry=false # 是否拉取eureka eureka.client.service-url.defaultZone=http://localhost:7900/eureka/ # 设置注册中心的URL eureka.instance.hostname=euk1.com spring.application.name=EurekeServer # eureka集群中各节点要同名 行为 register # 注册 renew # 通过心跳, 默认30s。三次失败删除实例 fetch registry # 拉注册的信息 cancel # 发取消请求，删除实例 time lag # 同步时间延迟 communication mechanism # 通讯机制，默认jersey和jackson 功能 唯一标识 # service id 主机名:application.name:端口 提供RestAPI, 可多终端接入 问题 一致性问题方案 Eureka间不同步，client向多个Eureka提交 Enreka间同步，Eureka强可用性弱一致性 基础 # 介绍 spring boot基础上构建，快速构建分布式系统, 全家桶 面向云环境架构(云原生) # 适合在docker和paas部署 功能 配置管理 服务发现 熔断 智能路由 微代理 控制总线 全局锁 决策竞选 分布式会话 集群状态管理 子项目 spring cloud netflix # 对netflix oss套件整合 eureka # 服务治理(注册、发现) hystrix # 容错管理 ribbon # 软负载均衡(客户端) feign # 基于hystrix和ribbon，服务调用组件 zuul # 网关，智能路由、访问过滤 archaius # 外部化配置 基础 spring cloud starters # 基础依赖, 高版本取消 spring cloud commons 服务 spring cloud consul # 封装consul(服务发现与配置, 与docker无缝) spring cloud cluster # 抽象zookeeper, redis, hazelcast, consul的选举算法和通用状态模式实现接口 spring cloud cloudfoundry # 与pivotal cloudfoundry整合 spring cloud aws # 整合aws spring cloud zookeeper # 整合zookeeper spring cloud cli # groovy中快速创建应用 spring cloud task # 任务 配置 spring cloud config # 应用配置外部化, 推送客户端配置, 支持git存储 消息 spring cloud bus # 消息总线，传播集群状态变化来触发动作，如刷新配置 spring cloud stream # 声明式发送、接收消息 监控 spring cloud sleuth # 跟踪 安全 spring cloud security # 应用安全控制, zuul代理中OAuth2中继器 测试 spring cloud contract # 契约测试, 可用groovy和yaml定义 版本 用命名不用版本号，因为有多子项目版本，易混淆 命名用伦敦地铁站用，字母表排序 缺点 难于追查框架问题 非二进制通信协议 适合中小团队 配置 # pom.xml \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;spring-cloud-common\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-provider-book\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-service-discovery\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-api-gateway\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-consumer-book\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-monitor-dashboard\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-aggregator\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-zipkin-server\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-admin-server\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;spring-cloud-config-server\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;Edgware.SR3\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;spring-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/libs-release\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;id\u0026gt;spring-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://repo.spring.io/libs-release\u0026lt;/url\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; application.yml spring: profiles: peer1 # bean的逻辑组 组件 # dependencyManagement spring-cloud-dependencies spring cloud spring boot # spring cloud eureka # 原理 生产者向eureka注册, 周期发送心跳(默认30s) eureka服务间同步注册信息 消费者请求地址，缓存本地 eurake接收生产者心跳超时, 设置为down, 推送状态到消费者 eurake短期down过多生产者，进入自我保护不再down 组件 spring-cloud-starter-[netflix-]eureka-server application.yml eureka: instance: hostname: localhost # 实例主机名 client: registerWithEureka: false # 当前服务不注册 fetchRegistry: false # 不获取注册信息 serviceUrl: # server地址 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ bootstrap.yml # 基础配置, 待拉取config 注解 @EnableEurekaServer # 修饰Application类 spring cloud ribbon # application.yml ribbon: eureka: enabled: false # 禁止从eureka获得注册列表 spring cloud hystrix # # 单个服务监控 hystrix dashboard 路径 /hystrix /hystrix.stream # 至少请求一次接口，才有数据 spring cloud turbine # # 多服务监控 application.yml turbine: aggregator: clusterConfig: default # 此监控器名 appConfig: erp-consumer-metadb, erp-consumer # 目标服务名 clusterNameExpression: new String(\u0026quot;default\u0026quot;) # 名称匹配表达式 路径 /turbine.stream spring cloud feign # application.yml feign: hystrix: enabled: true spring cloud zuul # # 默认会用ribbon负载均衡 application.yml zuul: prefix: /v1 routes: hiapi: path: /hiapi/** serviceId: erp-consumer-metadb # url: http://localhost:8762 # 这样写不会做负载均衡 # serviceId: hiapi-v1 ## 手动url负载均衡 # ribbon: # eureka: # enabled: false # hiapi-v1: # ribbon: # listOfServers: http://localhost:8762,http://localhost:8763 案例 过滤 import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE; @Component public class MyFilter extends ZuulFilter { private static Logger log = LoggerFactory.getLogger(MyFilter.class); @Override public String filterType() { return PRE_TYPE; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(\u0026quot;%s \u0026gt;\u0026gt;\u0026gt; %s\u0026quot;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(\u0026quot;token\u0026quot;); if (accessToken == null) { log.warn(\u0026quot;token is empty\u0026quot;); // // ctx.setSendZuulResponse(false); // ctx.setResponseStatusCode(401); // try { // ctx.getResponse().getWriter().write(\u0026quot;token is empty\u0026quot;); // }catch (Exception e){ // // } return null; } log.info(\u0026quot;ok\u0026quot;); return null; } } 熔断 @Component public class MyFallbackProvider implements ZuulFallbackProvider { @Override public String getRoute() { return \u0026quot;*\u0026quot;; } @Override public ClientHttpResponse fallbackResponse() { return new ClientHttpResponse() { @Override public HttpStatus getStatusCode() throws IOException { return HttpStatus.OK; } @Override public int getRawStatusCode() throws IOException { return 200; } @Override public String getStatusText() throws IOException { return \u0026quot;OK\u0026quot;; } @Override public void close() { } @Override public InputStream getBody() throws IOException { return new ByteArrayInputStream(\u0026quot;error, I'm the fallback\u0026quot;.getBytes()); } @Override public HttpHeaders getHeaders() { HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); return headers; } }; } } spring cloud config # config-server application.yml server: port: 9012 spring: application: name: erp-config-server cloud: config: server: native: search-locations: classpath:/shared # 读取路径 profiles: active: native # 本地读取 shared/config-client-dev.yml # 文件名为 [客户端服务名]-[profile变量] server: port: 9013 foo: foo version 1 地址 localhost:9012/config-client/dev # 查看分发给服务的配置 config-client spring: application: name: erp-config-client cloud: config: uri: http://localhost:9012 fail-fast: true profiles: active: dev 注解 @RefreshScope # 热更新 spring cloud bus # application.yml spring: rabbitmq: host: localhost port: 5672 username: outrun password: asdf publisher-confirms: true virtual-host: / management: security: enabled: false 路径 POST /bus/refresh # 从新拉配置, 其它服务也触发同步 ?destination=appName:*.* # 指定刷新服务名下实例 spring cloud stream # spring cloud sleuth # application.yml zipkin: base-url: http://localhost:9014 sleuth: sampler: percentage: 1.0 "},{"id":20,"href":"/docs/middleware/distributed/","title":"支撑-分布式","section":"中间件","content":" 名词 # Alb automaticLoopBack 自动回环，虚拟接口 sdn software defined network 软件定义网络 Serverless # knative # google开源，serverless标准化方案，基于kubernetes和istio 模块 build serving eventing ServiceMesh # Service Fabric # # 微软 Istio # #google IBM, lyft开源，基于envoy 组成 数据面板 控制面板 Knative # 介绍 管理kubernetes, Istio 模块 build serve config route event Traefik # # go实现，多后台如kubernetes, swarm, marathon, mesos Linkerd # # buoyant出品 Conduit # # 面向kubernetes轻量化mesh Fingle # # twitter出品 Envoy # # lyft出品 Nginmesh # # nginx推出 PaaS # # platform as a service CloudStack # # 托管在apache的开源、高可用、高扩展性的云计算平台 # 支持主流hypervisors # 一个开源云计算解决方案，可以加速iaaS的部署、管理、配置 CloudFoundry # # pivotal开源, 根据应用模板，动态生成很多tomcat, mysql, nosql, 动态控制这些实例的启停。 OpenStack # # 云操作系统，管理虚拟资源 Container Orchestration # 特性 dubbo spring cloud kubernetes 配置管理 - config kubernetes configMap 服务发现 zookeeper eureka, consul, zookeeper kubernetes services 负载均衡 自带 ribbon kubernetes services 网关 - zuul kubernetes services 分布式追踪 - spring cloud sleuth open tracing 容错 不完善 hystrix kubernetes health check 通信方式 rpc http, message 安全模块 - spring cloud security - 分布式日志 ELK EFK 任务管理 spring batch kubernetes jobs Kubernetes # # google开源的，borg的发展，在docker技术上，管理容器化应用 特点 不限语言 无侵入, 服务只写业务 适合微服务 # 调整服务副本数, 横向扩容 无缝迁移到公有云 # cluster ip实现不改配置迁移 自动化资源管理 服务发现，用dns解析服务名 内嵌负载均衡 部署实施 治理 监控 故障发现、自我修复 透明服务注册、发现 服务滚动升级、在线扩容, 根据负载自动扩容缩容 可扩展资源自动调度、多粒度资源配额 多层安全防护、准入 多租户 完善的工具 pod运行容器 etcd保存所有状态 架构 cluster master api server # 对外http rest接口, 管理资源对象(pod, RC, service)增删改查 controller manager # 管理控制器, node, pod, endpoint, namespace, serviceAccount, resourceQuota自动化管理 scheduler # 接收controller manager命令执行pod调度 etcd # 配置 node # 一master多node 特点 node宕机，pod调度到其它节点 pod # 一node几百个pod, 基本操作单元，代表一个运行进程，内部封装一个(或多个紧密相关的)容器。 特点 pod内通信高效，放密切相关服务进程 可以判断一组相关容器的状态(用pause) pause解决共享ip、容器通信、共享文件的问题 pod间通信用虚拟二层协议(flannel, openvswitch)实现 普通pod在etcd存储，再调度到某node实例化，静态pod在node中存储，在node实例化 对pod可进行资源(cpu,内存)限额 label # 标签，用标签选择器选择。key和value由用户指定，可附加到node, pod, service, rc等 pause容器 # 根容器，共享网络栈、挂载卷 docker/rocket # 容器 kubelet # master监视pod, 创建、修改、监控、删除 kube-proxy # 代理pod接口 fluentd # 日志收集、存储、查询 kube-dns # 服务dns解析 概念 service # 服务网关 特点 唯一名字 唯一虚拟ip(cluster ip, service ip, vip) # 可多端口，每端口有名字 提供远程服务 # 目前socket 应用到一组pod event # 探针检测失败记录，用于排查故障 rc # replication controller 副本数 筛选标签 pod模板 改变pod镜像版本，滚动升级 replica set # 1.2 rc升级, 支持基于集合的标签选择。被deployment使用 deployment # pod编排, rc升级 特点 查看pod部署进度 HPA # horizontal pod autoscaler, 自动扩容缩容 指标 cpu utilization percentage # 1分钟内利用率平均值 应用自定义指标(tps, qps) volume emptyDir hostPath gcePersistentDisk awsElasticBlockStore NFS persistent volume namespace annotation 动作 扩容 创建rc自动创建pod, 调度到合适的node pod定义 副本数 监控label # 筛选pod得到数量 命令 kubectl --help # 帮助, 各命令之后都可加 version cluster-info logs kubectl logs --tail=1000 appID1 # 查看日志 run exec kubectl exec -it appID1 /bin/sh # 交互命令进入app create -f mysql-rc.yaml # 创建rc -f mysql-svc.yaml # 创建service set image get rc # 查看rc pods pod -o wide # 显示详情，有node name o-\u0026gt; kubectl get pod -l app=app1 -o wide # 查看pod app状态 services svc # 查看service, 包含cluster ip nodes endpoints # service pod的ip:端口 deployments describe # 详情 node pods deployments expose label delete scale # pod扩容或缩容 --replicas=2 autoscale # 创建hpa对象 deployment rolling-update # pod滚动升级 rollout status undo apply # 应用配置 -f proxy kubelet kube-apiserver kube-proxy kube-scheduler kubeadm kube-controller-manager hyperkube apiextensions-apiserver mounter 镜像 kube-apiserver kube-controller-manager kube-scheduler kube-proxy pause etcd coredns 配置 用yaml或json定义 pod kind: Pod # 表明是Pod metadata: name: myweb # pod名 labels: name: myweb # 标签 Spring Cloud # Mesos # # twitter, apache开源的分布式资源管理框架, 两级调度器 Dubbo # 介绍 阿里开源，分布式服务框架，rpc方案，soa治理 功能 远程通讯 # 多协议，多种长连接nio框架封装 集群容错 # 负载均衡，容错，地址路由，动态配置 自动发现 # 注册中心 节点 容器(container) 提供者(provider) 消费者(consumer) 注册中心(registry) 监控中心(monitor) 调用关系 容器启动提供者 提供者注册 消费者订阅 注册中心返回地址列表, 长连接更新 消费者软负载均衡挑选列表中提供者 提供者和消费者累计调用次数和时间，定时发送到监控中心 容错机制 failover # 默认，失败自动切换 failfast # 立即报错，用于幂等写操作 failsafe # 忽略 failback # 定时重发 forking # 并行多个取最快(any) broadcast # 逐个多个，异常退出 连接方式 广播 # 不需要中心节点，适用开发测试, 地址段224.0.0.0 - 239.255.255.255 服务端配置 applicationContext-service.xml \u0026lt;dubbo:application name=”taotao-manager-service” /\u0026gt; \u0026lt;dubbo:registry address=”multicast://224.5.6.7:1234” /\u0026gt; \u0026lt;dubbo:protocol name=”dubbo” port=”20880” /\u0026gt; \u0026lt;dubbo:service interface=”com.taotao.manager.service.TestService” ref=”testServiceImpl” /\u0026gt; 客户端配置 springMVC.xml \u0026lt;dubbp:application name=”taotao-manager-web” /\u0026gt; \u0026lt;dubbo:registry address=”multicast://224.5.6.7:1234” /\u0026gt; \u0026lt;dubbo:service interface=”com.taotao.manager.service.TestService” id=”testService” timeout=”10000000” /\u0026gt; 直连 服务端配置 \u0026lt;dubbo:application name=”taotao-manager-service” /\u0026gt; \u0026lt;dubbo:registry address=”N/A” /\u0026gt; \u0026lt;dubbo:protocol name=”dubbo” port=”20880” /\u0026gt; \u0026lt;dubbo:service interface=”com.taotao.manager.service.TestService” ref=”testServiceImpl” /\u0026gt; applicationContext-service.xml 客户端配置 springMVC.xml \u0026lt;dubbp:application name=”taotao-manager-web” /\u0026gt; \u0026lt;dubbo:service interface=”com.taotao.manager.service.TestService” id=”testService” timeout=”10000000” /\u0026gt; 注册中心 zookeeper Dubbox # 介绍 当当网扩展Dubbo Netflix OSS # orleans # # .NET HSF # # high-speed service framework, 阿里出品， socket直连 特点 不增加中间点(稳定，高度可伸缩) 结构 注册服务信息，推送服务地址 基于osgi 组件 服务提供者 消费者 地址服务器 配置服务器 # 分布式配置 规则服务(diamond) # 设置(黑白名单，认证，权重，限流)与推送 NScale # # 可扩展容器，用node.js和docker实现 Armada # # python微服务 SOA # # 面向服务架构 service oriented architecture EAI # # Enterprise Application Integration 建立底层结构将异构应用集成 ESB # # Enterprise Service Bus 企业服务总线， 是连接中枢 RPC # # 远程过程调用 remote procedure call Thrift # CXF # 常识 自己内部整合spring(但是不耦合) 支持的协议 soap1.1/1.2 post/http restful http 使用 导入cxf包 方法1 # 不支持注解 String address=\u0026quot;http://localhost:8888/hello\u0026quot;; ServerFactoryBean factoryBean=new ServerFactoryBean(); factoryBean.setAddress(address); factoryBean.setServiceBean(new MyWS()); factoryBean.create(); 方法2 # 支持注解,wsdl文件中类型不再单独schema文件 ServerFactoryBean factoryBean = new JaxWsServerFactoryBean # java and xml web service 日志 # 记录握手信息(访问wsdl文件) ## 看日志记录得到 soap serverFactoryBean.getInInterceptors().add(new LoggingInInterceptor()); serverFactoryBean.getOutInterceptors().add(new LoggingOutInterceptor()); 整合spring o-\u0026gt; cxf2.4.4.jar/schemas/jaxws.xsd中找到命名空间\u0026quot;http://cxf.apache.org/jaxws\u0026quot; o-\u0026gt; 配置applicationContext.xml，加入cxf的命名空间http://cxf.apache.org/jaxws,schema地址为http://cxf.apache.org/schemas/jaxws.xsd。 并且在eclipse中配置schema约束文件的路径 # 该xsd约束文件的url地址用的是包地址,不规范 o-\u0026gt; applicationContext.xml中配置 \u0026lt;bean id=\u0026quot;studentService\u0026quot; class=\u0026quot;test.spring.StudentServiceImpl\u0026quot;/\u0026gt; # 用于：自身调用，被spring引用 \u0026lt;jaxws:server serviceClass=\u0026quot;test.spring.StudentService\u0026quot; address=\u0026quot;/student\u0026quot;\u0026gt; # address配置服务的名称即可(web.xml的servlet中配置了服务的实际访问地址) ## serviceClass配置的才是真正的服务，既然它是接口，那么webService注解也应该写在接口上 \u0026lt;jaxws:serviceBean\u0026gt; \u0026lt;ref bean=\u0026quot;studentService\u0026quot;/\u0026gt; \u0026lt;jaxws:inInterceptors\u0026gt; \u0026lt;bean class=\u0026quot;org.apache.cxf.interceptor.LoggingInInterceptor\u0026quot; /\u0026gt; \u0026lt;jaxws:outInterceptors\u0026gt; \u0026lt;bean class=\u0026quot;org.apache.cxf.interceptor.LoggingOutInterceptor\u0026quot; /\u0026gt; o-\u0026gt; web.xml中配置servlet \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springWS \u0026lt;servlet-class\u0026gt;org.apache.cxf.transport.servlet.CXFServlet # 在cxf-2.4.4.jar包中 \u0026lt;load-on-startup\u0026gt;1 \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springWS \u0026lt;url-pattern\u0026gt;/ws/* o-\u0026gt; web.xml中配置spring监听器 GRPC # Protobuf # # 通信协议 命令 protoc -I. -I-I$GOPATH/src --go_out=plugins=grpc:. * # -I import目录 protoc --grpc-gateway_out=. 插件 安装 # go build 出protoc-gen-go后，放入go/bin下 protoc-gen-go # 编译proto文件 protoc-gen-grpc-gateway # http服务 RMI # # java远程调用 remote method invocation Hessian # # 是caucho公司的开源协议,基于http Burlap # # caucho公房的开源协议,基于http HttpInvoker # # spring提供的协议，必须用spring Web Service # # soap通讯 粘合层 # 治理(服务发现) # Zookeeper # 介绍 google chubby的开源实现。用于服务发现 保证CP 分布式, hadoop中hbase的组件 fast paxos算法 # paxos存在活锁问题, fast paxos通过选举产生leader, 只有leader才能提交proposer 功能 配置维护 域名服务 分布式同步 组服务 分布式独享锁、选举、队列 流程 选举leader # 多种算法, leader有最高执行ID 同步数据 大多数机器得到响应follow leader exhibitor # supervisor for zk Eureka # # Netflix，保证AP Consul # # Apache，保证CA Etcd # # kubernetes用，保证CP 路由控制 # 负载均衡策略 随机、轮询、调用延迟判断、一致性哈希、粘滞连接 本地路由优先策略 优先JVM（injvm），优先相同物理机（innative） 配置方式 统一注册表、本地配置、动态下发 配置 # Spring Cloud Config # Diamond # # 淘宝 Archaius # # netflix Disconf # # 百度 QConf # # 360 任务 # Elastic-Job # # 当当网 Azkaban # # linkedin Spring Cloud Task # 跟踪 # zipkin # # twitter Opentracing # Hydra # # 京东 Spring Cloud Sleuth # 监控 # Spy.js # # webstorm用的监控工具 Alinode # # 朴灵写的运行时性能管理工具 OneAPM # # 监控node性能 功能 接口响应时间 数据库方法时间 外部服务时间 单请求的耗时比 容错 # Hystrix # 功能 服务线程隔离、信号量隔离 降级: 超时、资源不足 熔断: 自动降级、快速恢复 请求缓存、请求合并 代理 # Gearman # # 分布式计算, 把工作委派给其他机器 Hazelcast # # 基于内存的数据网格，用于分布式计算 Twemproxy # redis/memcache分片代理 高可用 # # high-availability linux 目标 reliability: 可靠性 availability: 可用性 serviceability: 可服务性 ras: remote access service(远程服务访问) 术语 节点(node): 唯一主节点，多个备用节点 资源(resource): 是节点可控制的实体，主节点发生故障时，可以被其它节点接管 例如: 磁盘分区 文件系统 ip地址 应用程序服务 nfs文件系统 事件(event): 集群中可能发生的事件 例如: 系统故障 网络连通故障 网卡故障 应用程序故障 动作(action): 事件发生时ha的响应方式 例如: 用shell 脚本对资源进行转移 心跳 # HeartBeat # 2.0模块 heartbeat: 节点间通信检测模块 ha-logd: 集群事件日志服务 CCM(Consensus CLuster Membership): 集群成员一致性管理模块 LRM(Local Resource Manager): 本地资源管理模块 Stonith Daemon: 使出现问题的节点从集群资源中脱离 CRM(Cluster Resource management): 集群资源管理模块 Cluster policy engine: 集群策略引擎 用于实现节点与资源之间的管理与依赖关系 Cluster transition engine: 集群转移引擎 3.0拆分之后的组成部分 Heartbeat: 负责节点之间的通信 Cluster Glue: 中间层，关联Heartbeat 与 Pacemaker,包含LRM 与 stonith Resource Agent: 控制服务启停，监控服务状态脚本集合，被LRM调用 Pacemaker: 也就是曾经的CRM，包含了更多的功能 管理接口: crm shell 一个使用ajax web 的web窗口 hb_gui图形工具 DRBD-MC, 一个基于java的工具 版本差异 与1.x相比，2.1.x版本变化 保留原来所有功能 自动监控资源 对各资源组进行独立监控 同时监控系统负载 自动切换到负载低的node上 Keepalived # vrrp # virtual router redundancy protocol 虚拟路由器冗余协议 # 解决静态路由出现的闪单点故障问题，它能够保证网络的不间断．稳定运行 负载 # # load balance 方法 dns轮循 java nio erlang语言 linux epoll bsd kqueue 消息队列、事件通知 c/c++下ace, boost.asio, libev(libevent) 服务器mina, jetty, node.js, netty java协程框架 quasar kilim Haproxy # 监控页面 /status Tengine # # 淘宝基于nginx修改，添加了功能 监控 /upstream_status OpenResty # # 淘宝改的nginx, lua工具 安装 yum install -y gcc gcc-c++ kernel-devel readline-devel pcre-devel openssl-devel openssl zlib zlib-devel pcre-devel wget openresty-1.9.15.1.tar.gz ./configure --prefix=/opt/openresty --with-pcre-jit --with-ipv6 --without-http_redis2_module --with-http_iconv_module -j2 make \u0026amp;\u0026amp; make install ln -s /opt/openresty/nginx/sbin/nginx /usr/sbin /opt/openresty/nginx/conf/nginx.conf Varnish # # 反向代理, http缓存 Traffic Server # # apache 缓存 Squid # 配置文件 /etc/squid/squid.conf 代理类型 普通代理 透明代理 反向代理 缓存 动态资源 静态资源 参考资料 squid 透明代理详解 配置 # squid.conf http_port 3128 # squid服务端口 icp_port 3130 # udp端口,用来接收和发送ICP消息 cache_dir ufs /var/spool/squid # 缓存目录, 写入方式有aufs与ufs两种,aufs使用大量线程异步进行磁盘i/o操作 cache_access_log /var/log/squid/access.log cache_log /var/log/squid/cache.log cache_store_log /var/log/squid/store.log pid_filename /var/run/squid.pid # 日志文件位置 #auth_param basic children 5 #auth_param basic realm Squid proxy-caching web server #auth_param basic credentialsttl 2 hours # 关闭认证，认证一般不需要 cache_effective_user squid cache_effective_group squid cache_mgr youraccount@your.e.mail # 设置squid用户及用户组、管理员账号 cache_mem 128 MB # 运行内存配置 cache_swap_low 90 cache_swap_high 95 maximum_object_size 4096 KB ＃ 与磁盘容量相关的配置，90、95为百分比，磁盘大时4096 KB可以改成32768 KB maximum_object_size_in_memory 8 KB ＃ 内存缓存资料大小 以下为定义acl(访问控制列表) ＃ 语法为:acl\u0026lt;acl\u0026gt; \u0026lt;acl名称\u0026gt; \u0026lt;acl类型\u0026gt; \u0026lt;配置的内容\u0026gt; acl All src 0/0 acl Manager proto cache_object acl Localhost src 127.0.0.1/32 acl Safe_ports port 80 21 443 563 70 210 280 488 591 777 1025-65535 acl SSL_ports 443 563 acl CONNECT method CONNECT acl MyNetwork src 192.168.0.0/16 以下为利用前面定义的acl,定义访问控制规则 http_access allow Manager Localhost http_access deny Manager http_access deny !Safe_ports http_access deny CONNECT SSL_ports http_access allow MyNetwork http_access deny All 例子: 禁止访问sina acl sina dstdomain .sina.com.cn .sina.com http_access deny sina 或 acl sina dst 58.63.236.26 58.63.236.27 58.63.236.28 58.63.236.29 58.63.236.30 58.63.236.31 58.63.236.32 58.63.236.33 58.63.236.34 58.63.236.35 58.63.236.36 58.63.236.37 58.63.236.38 58.63.236.39 58.63.236.49 58.63.236.50 http_access deny sina 或 acl sina dst www.sina.com.cn http_access deny sina 例子: 禁止来自某些ip的访问 acl zhang src 192.168.63.6/32 http_access deny zhang 例子: 禁止在某些时段访问 acl Working_hours MTWHF 08:00-17:00 http_access allow Working_hours http_access deny !Working_hours 例子: 禁止某个代理客户建立过多连接 acl OverConnLimit maxconn http_access deny OverConnLimit 定义与其它代理服务器的关系,语法: \u0026lt;cache_peer\u0026gt; \u0026lt;主机名称\u0026gt; \u0026lt;类别\u0026gt; \u0026lt;http_port\u0026gt; \u0026lt;icp_port\u0026gt; \u0026lt;其它参数\u0026gt; cache_peer 192.168.60.6 parent 4480 7 no-query default #设置与其它代理服务器的关系: \u0026lt;cache_peer_access\u0026gt; \u0026lt;上层 Proxy \u0026gt; \u0026lt;allow|deny\u0026gt; \u0026lt;acl名称\u0026gt; #cache_peer_access 192.168.60.6 allow aclxxx #cache_peer_access 192.168.60.6 deny !aclxxx coredump_dir /var/spool/squid # 崩溃存储目录 使用 step1 检查配置文件 squid -k parse step2 初始化cache 目录 squid -z(X) # X会显示过程 step3 启动squid service squid start 或 /usr/local/squid/sbin/squid -sD 停止squid squid -k shutdown 重新载入配置 squid -k reconfigure 滚动日志 squid -k rotate 案例 透明代理 step1 检查配置文件 squid -k parse step2 初始化cache 目录 squid -z(X) # X会显示过程 step3 启动squid service squid start 或 /usr/local/squid/sbin/squid -sD 停止squid squid -k shutdown 重新载入配置 squid -k reconfigure 滚动日志 squid -k rotate 代理 squid.conf http_port 3128 http_access allow all 或 http_port 3128 http_access deny all前面添加 acl 192.168.0.42 src 192.168.0.0/24 http_access allow 192.168.0.42 ＃ 192.168.0.42为允许的ip LVS # 介绍 第四层开始负载(可以建立到三层负载) 第四层负载 socket进必须连lvs 模式 tun # lvs负载均衡器将请求包发给物理服务器，后者将应答包直接发给用户 net # 请求和应答都经过lvs dr # 不要隧道结构的tun 使用 DR模式 centos6 yum install-y gcc gcc-c++ makepcre pcre-devel kernel-devel openssl-devel libnl-devel popt-devel modprobe -l |grep ipvs # 检查内核是否集成 echo \u0026quot;1\u0026quot; \u0026gt; /proc/sys/net/ipv4/ip_forward # 开启路由转发 安装ipvsadm http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz 安装keepalived http://www.keepalived.org/software/keepalived-1.2.7.tar.gz ./configure --prefix=/usr/local/keepalived cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/ cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ mkdir /etc/keepalived/ cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/ cp /usr/local/keepalived/sbin/keepalived /usr/sbin/ o-\u0026gt; 配置文件/etc/keepalived/keepalived.conf ! Configuration File forkeepalived global_defs { notification_email { test@sina.com #故障接受联系人 } notification_email_from admin@test.com #故障发送人 smtp_server 127.0.0.1 #本机发送邮件 smtp_connect_timeout 30 router_id LVS_MASTER #BACKUP上修改为LVS_BACKUP } vrrp_instance VI_1 { state MASTER #BACKUP上修改为BACKUP interface eth0 virtual_router_id 51 #虚拟路由标识，主从相同 priority 100 #BACKUP上修改为90 advert_int 1 authentication { auth_type PASS auth_pass 1111 #主从认证密码必须一致 } virtual_ipaddress { #Web虚拟IP（VTP） 172.0.0.10 } } virtual_server 172.0.0.10 80 { #定义虚拟IP和端口 delay_loop 6 #检查真实服务器时间，单位秒 lb_algo rr #设置负载调度算法，rr为轮训 lb_kind DR #设置LVS负载均衡DR模式 persistence_timeout 50 #同一IP的连接60秒内被分配到同一台真实服务器 protocol TCP #使用TCP协议检查realserver状态 real_server 172.0.0.13 80 { #第一个web服务器 weight 3 #节点权重值 TCP_CHECK { #健康检查方式 connect_timeout 3 #连接超时 nb_get_retry 3 #重试次数 delay_before_retry 3 #重试间隔/S } } real_server 172.0.0.14 80 { #第二个web服务器 weight 3 TCP_CHECK { connect_timeout 3 nb_get_retry 3 delay_before_retry 3 } } } service keepalived restart 启动脚本 /etc/init.d/real.sh #description : start realserver VIP=172.0.0.10 . /etc/init.d/functions case \u0026quot;$1\u0026quot; in start) /sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up echo \u0026quot;1\u0026quot; \u0026gt;/proc/sys/net/ipv4/conf/lo/arp_ignore echo \u0026quot;2\u0026quot; \u0026gt;/proc/sys/net/ipv4/conf/lo/arp_announce echo \u0026quot;1\u0026quot; \u0026gt;/proc/sys/net/ipv4/conf/all/arp_ignore echo \u0026quot;2\u0026quot; \u0026gt;/proc/sys/net/ipv4/conf/all/arp_announce echo \u0026quot;LVS RealServer Start OK\u0026quot; ;; stop) /sbin/ifconfig lo:0 down echo \u0026quot;0\u0026quot; \u0026gt;/proc/sys/net/ipv4/conf/lo/arp_ignore echo \u0026quot;0\u0026quot; \u0026gt;/proc/sys/net/ipv4/conf/lo/arp_announce echo \u0026quot;0\u0026quot; \u0026gt;/proc/sys/net/ipv4/conf/all/arp_ignore echo \u0026quot;0\u0026quot; \u0026gt;/proc/sys/net/ipv4/conf/all/arp_announce echo \u0026quot;LVS RealServer Stoped OK\u0026quot; ;; *) echo \u0026quot;Usage: $0 {start|stop}\u0026quot; exit 1 esac o-\u0026gt; 开机启动 chmod +x /etc/init.d/real.sh /etc/init.d/real.sh start echo \u0026quot;/etc/init.d/real.sh start\u0026quot; \u0026gt;\u0026gt; /etc/rc.local o-\u0026gt; 测试 service httpd start echo \u0026quot;1\u0026quot; \u0026gt; /var/www/html/index.html service iptables stop setenforce 0 # 关闭selinux o-\u0026gt; 其他命令 ipvsadm -ln # 集群中服务器ip信息 ip addr # 显示VIP当前绑定的服务器 tail -f /var/log/messages # 日志 数据库 # 读写分离 # MySQL主从复制 Haproxy + 多Slave DRBD + Heartbeat + MySQL MySQL Cluster 分片 # 问题 事务 Join 迁移 扩容 ID生成 分页 方案 事务补偿 # 数据对账：基于日志对比、同步标准数据源 分区 # MySQL机制分文件存储，客户端无感知 分表 # 客户端管理分表路由 分库 为什么 单库无法承接连接数时分库，MySQL单库5千万条，Oracle单库一亿条 策略 数值范围 取模 日期 框架 Sharding-JDBC TSharding 代理 Atlas MyCAT Vitess 分布式文件系统 # HDFS # 批量读写，高吞吐量，不适合小文件 FastDFS # 轻量级，适合小文件 一致性 # CAP 一致性 强一致性、弱一致性（秒级），最终一致性 可用性 分区容错性（网络故障） BASE Basically Available（基本可用），Soft state（软状态），Eventually consistent（最终一致性） 幂等性 分布式锁 # 算法 PAXOS Zab # Zookeeper使用 Raft # 三角色：Leader（领袖），Follower（群众），Candidtate（候选人） Gossip # Cassandra使用 实现方式 数据库 有单点问题 缓存 非阻塞性能好 有锁不释放问题 实现 RedLock setnx Memcached add Zookeeper 有序临时节点，集群透明解决单点问题，锁被释放，锁可重入 性能不如缓存，吞吐量随集群规模变大而下降 一致性哈希 # 扩容映射 分布式事务 # 分类 两阶段提交、多阶段提交 TCC事务 Atomikos # ID生成器 # Snowflake算法 # Twitter 41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器) MySQL自增ID + \u0026quot;REPLACE INTO XXX:SELECT LAST_INSERT_ID();\u0026quot; # Flicker MongoDB ObjectId 不能自增 UUID 无序，过长，影响检索性能 "},{"id":21,"href":"/docs/middleware/library_frontend/bootstrap/","title":"Bootstrap","section":"前端","content":" 介绍 # 在jquery基础上的组件框架 移动 # \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\u0026quot;\u0026gt; css # 全局 container # div, 唯一包裹容器 container-fluid # 占全部视口 栅格 # 必须放在row内 col-xs-1 # 适用于大于等于分界点的屏幕 ## 大于12的最后那个col另起一行排列 # xs \u0026lt; 768px 宽度, container 最大宽度: 自动 # sm \u0026gt;= 768px, 750px # md \u0026gt;= 992px, 970px # lg \u0026gt;= 1200px, 1170px col-md-offset-4 # 向右偏移4 col-md-pull-9 # 向后推9, 改变元素的顺序 col-md-push-3 o-\u0026gt; mixin make-row 如 .wrapper {.make-row();} make-xs-column make-sm-column-offset make-sm-column-push make-sm-column-pull 样式 # muted # 文本颜色 text-warning text-error text-info text-success text-left # 文本左对齐 text-center text-right text-justify text-nowrap text-lowercase text-uppercase text-capitalize bg-primary # p bg-success bg-info bg-warning bg-danger success # 状态类 # table行颜色, control-group div error danger warning info active has-warning # div元素 # 适用class: control-label, form-control, help-block has-error has-success has-feedback # div, pull-right # 任意元素向右浮动 pull-left navbar-right # 导航条中向右浮动 navbar-left clearfix # 清除浮动 initialism # 缩略语样式, abbr标签 small # small标签的样式 lead # p标签，突出显示 blockquote-reverse # blockquote标签使用, 内容右对齐 disabled # btn, input, 只disable样式 o-\u0026gt; 适用的class radio radio-inline checkbox checkbox-inline o-\u0026gt; 适用的标签 fieldset inline # 行内ul, checkbox center-block # 任意元素, 水平居中 show # 任意元素显示 hidden .sr-only # 任意元素, 辅助技术支持的文本, 隐藏当前元素 sr-only-focusable # 元素有焦点时显示出来 visible-xs-block # 只对xs屏幕可见 visible-xs-inline visible-xs-inline-block hidden-xs # 对xs屏隐藏 visible-print-block # 对打印机可见 visible-print-inline visible-print-inline-block hidden-print table # table # table样式 table-responsive # div元素，包裹table样式后，创建响应式表格，带有滚动条 table-striped # 斑马纹样式 table-bordered # 边框圆角 table-hover # 行悬停样式 table-condensed # 内补减半使更紧凑 form # form-search # form标签中添加，其中有input search-query # search中的input的样式 form-actions # div元素, 内部按钮自动缩进 form-inline # 行内表单 form-actions # div元素，按钮列表，和表单其它元素对齐 form-horizontal # 元素右对齐左浮动的表单 form-group # form中的div元素 form-control # input, textarea, select o-\u0026gt; 支持的input类型 text password datetime datetime-local date month time week number email url search tel color form-control-static # p标签，用来代input显示文本 control-group control-label controls input-group input-group-addon # span form-control # 同外 glyphicon-ok # input元素或input-group的div元素后的span, 添加input内的图标 # 联合使用 class: glyphicon, form-control-feedback; ## 属性 aria-hidden=\u0026quot;true\u0026quot; glyphicon-warning-sign glyphicon-remove checkbox # div, label radio # div, label checkbox-inline # div radio-inline # div controls # div元素，为input增加合适的间距, 浮动它们缩减空白，再清除浮动 controls-row # 排一行，增加合适间距 input-mini input-small input-medium input-large input-xlarge input-xxlarge input-sm # input, select, 高度 input-lg form-group-sm # class为form-group的div, 高度 form-group-lg input-prepend # 前缀input, 可与input-append组合 add-on # span标签 btn span2 # input标签 input-append input-block-level # 块级input uneditable-input # span元素模拟不可编辑input 小件 # btn # a, button, input btn-group # div标签 按钮下拉菜单 dropdown-toggle # 要赋加自定义属性data-toggle=\u0026quot;dropdown\u0026quot;来关联执行js dropdown-menu # ul标签 btn-primary # 按钮样式 btn-info btn-success btn-warning btn-danger btn-inverse btn-link btn-default btn-lg btn-sm btn-xs btn-block # 块级按钮 span1 # input元素, select元素 span2 span3 span4 span5 help-inline # span元素，帮助文本 help-block # span元素, 块显示帮助 img-rounded # img, 图片样式 img-circle img-polaroid img-responsive # img, 图片响应式 caret # span标签, 下箭头 close # button, 关闭图 list-unstyled # 无样式列表 dl-horizontal # dl列表水平描述 pre-scrollable # pre标签内容滚动 text-overflow # 截断改写数据, 可能会垂直显示 text-hide # h1, 将元素的文本内容替换为背景图 导航 # \u0026lt;div role=\u0026quot;navigation\u0026quot; # 如果作为导航条, 父元素加属性，或者用nav标签 \u0026lt;ul class=\u0026quot;nav nav-tabs\u0026quot; # nav-pills 改成胶囊样式 # nav-stacked 改成垂直 # nav-justified 自适应宽度 \u0026lt;li role=\u0026quot;presentation\u0026quot; class=\u0026quot;active\u0026quot; # disabled \u0026lt;li role=\u0026quot;presentation\u0026quot; class=\u0026quot;dropdown\u0026quot; \u0026lt;a class=\u0026quot;dropdown-toggle\u0026quot; role=\u0026quot;button\u0026quot; data-toggle=\u0026quot;dropdown\u0026quot; aria-haspopup=\u0026quot;true\u0026quot; aria-expanded=\u0026quot;false\u0026quot; \u0026lt;ul class=\u0026quot;dropdown-menu\u0026quot; \u0026lt;nav class=\u0026quot;navbar navbar-default\u0026quot; # 添加navbar-fixed-top可以冻结到顶部 ## 设置body{padding-top: 70px;}来使内容不被遮盖 ## navbar-fixed-bottom, 同样要设置padding-bottom ## navbar-static-top 向下滚动就消失 # navbar-inverse 反色 \u0026lt;div class=\u0026quot;container-fluid\u0026quot; \u0026lt;div class=\u0026quot;navbar-header\u0026quot; \u0026lt;a class=\u0026quot;navbar-brand\u0026quot; \u0026lt;img alt=\u0026quot;Brand\u0026quot; # 图标 \u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;navbar-toggle collapsed\u0026quot; data-toggle=\u0026quot;collapse\u0026quot; data-target=\u0026quot;#bs\u0026quot; aria-expanded=\u0026quot;false\u0026quot; \u0026lt;span class=\u0026quot;icon-bar\u0026quot; # 放隐藏菜单的 \u0026lt;span class=\u0026quot;icon-bar\u0026quot; \u0026lt;span class=\u0026quot;icon-bar\u0026quot; \u0026lt;a class=\u0026quot;navbar-brand\u0026quot; \u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;btn btn-default navbar-btn\u0026quot; # navbar-btn可以上按钮垂直居中 \u0026lt;p class=\u0026quot;navbar-text\u0026quot; \u0026lt;div class=\u0026quot;collapse navbar-collapse\u0026quot; id=\u0026quot;bs\u0026quot; \u0026lt;ul class=\u0026quot;nav navbar-nav\u0026quot; \u0026lt;li\u0026gt;\u0026lt;a \u0026lt;form class=\u0026quot;navbar-form navbar-left\u0026quot; role=\u0026quot;search\u0026quot; # navbar-form自动垂直对齐，折叠 # navbar-left 让正确对齐，由pull-left mixin而来 \u0026lt;div class=\u0026quot;form-group\u0026quot; \u0026lt;input class=\u0026quot;form-control\u0026quot; \u0026lt;button class=\u0026quot;btn btn-default\u0026quot; \u0026lt;ul class=\u0026quot;nav navbar-nav navbar-right\u0026quot; \u0026lt;p class=\u0026quot;navbar-text navbar-right\u0026quot; # 不支持多个navbar-right \u0026lt;a class=\u0026quot;navbar-link\u0026quot; \u0026lt;ol class=\u0026quot;breadcrumb\u0026quot; # 面包屑 \u0026lt;li \u0026lt;li class=\u0026quot;active\u0026quot; 图标 # icon-white # 反色为白色 fa-dashboard # 配合fa使用 fa-fw # 小左箭头 fa-lg 默认渲染 # \u0026lt;h1\u0026gt; ... \u0026lt;h6\u0026gt; \u0026lt;small\u0026gt; \u0026lt;p\u0026gt; \u0026lt;mark\u0026gt; \u0026lt;del\u0026gt; \u0026lt;s\u0026gt; \u0026lt;ins\u0026gt; \u0026lt;u\u0026gt; \u0026lt;small\u0026gt; \u0026lt;strong\u0026gt; \u0026lt;em\u0026gt; \u0026lt;abbr\u0026gt; \u0026lt;address\u0026gt; \u0026lt;blockquote\u0026gt; \u0026lt;p\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;cite\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt; \u0026lt;dd\u0026gt; \u0026lt;code\u0026gt; \u0026lt;kbd\u0026gt; \u0026lt;pre\u0026gt; \u0026lt;var\u0026gt; \u0026lt;samp\u0026gt; # 程序输出 属性 aria-label # input元素, 替代label aria-labelledby title # 辅助功能阅读 aria-describedby # input 辅助阅读 disabled readonly less # @baseFontSize @font-size-base # 全局font-size基准，计算出所有页面元素的margin, padding, line-height, 改变bootstrap默认样式 @baseLineHeight @line-height-base # 同上, line-height基准 案例 # \u0026lt;div class=\u0026quot;table-responsive\u0026quot;\u0026gt; \u0026lt;table class=\u0026quot;table table-striped table-bordered table-hover\u0026quot;\u0026gt; # table table-condensed 紧凑型表格 \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;标题 \u0026lt;tbody\u0026gt; \u0026lt;tr class=\u0026quot;active\u0026quot;\u0026gt; # success info warning danger \u0026lt;/div\u0026gt; 插件 # scrollspy 介绍 监测滚动到目前页面锚点 工具 # bootInit 介绍 检测bootstrap标签语法，不支持扩展插件 "},{"id":22,"href":"/docs/middleware/library_frontend/threejs/","title":"Threejs","section":"前端","content":" 介绍 # 协调程序加载项的类库 使用 # var preload = new createjs.LoadQueue(false, \u0026quot;assets/\u0026quot;); var plugin= { getPreloadHandlers: function(){ return{ types: [\u0026quot;image\u0026quot;], callback: function(src){ var id = src.toLowerCase().split(\u0026quot;/\u0026quot;).pop().split(\u0026quot;.\u0026quot;)[0]; var img = document.getElementById(id); return {tag: img}; } } } } preload.installPlugin(plugin); preload.loadManifest([ \u0026quot;Autumn.png\u0026quot;, \u0026quot;BlueBird.png\u0026quot;, \u0026quot;Nepal.jpg\u0026quot;, \u0026quot;Texas.jpg\u0026quot; ]); api # 涉及dom # 属性 window.innerWidth window.innerHeight 事件 window.addEventListener('resize', onWindowResize, false); function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); controls.handleResize(); } 三大组件 场景(scene) var scene = new THREE.Scene(); 相机(camera) var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); # 透视相机 渲染器(renderer) var renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); # domElement 是画布 render( scene, camera, renderTarget, forceClear ) ＃ renderTarget默认是前面设置的renderer size, forceClear自动清除(设置为false也会清除) 版本 THREE.VERSION renderer # 使用 THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); # 透视摄像机 camera.position.x = 0; camera.position.y = 0; camera.position.z = 600; # 相机位置 camera.up.x = 0; camera.up.y = 1; camera.up.z = 0; # 相机\u0026quot;上\u0026quot;的方向 camera.lookAt({x:0, y:0, z:0}); # 视野中心坐标 camera.setViewOffset(fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight) # 相机的有效显示部分 WebGLRenderer renderer = new THREE.WebGLRenderer({ antialias: false}); # 抗锯齿为false。true时显示更清晰，更耗cpu renderer.setClearColorHex( 0x000000, 1); renderer.setSize(window.innerWidth, window.innerHeight); # 设置渲染器的宽度和高度 renderer.autoClear = false; renderer.sortObjects = false; renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight); # 设置一个渲染目标 renderTarget.minFilter = THREE.LinearFilter; renderTarget.magFilter = THREE.NearestFilter; postBloom = new BloomEffect(renderer, renderTarget, window.innerWidth, window.innerHeight, 4); renderer.shadowMapEnabled = true; # 开启显示阴影 ## 要显示阴影，还要设置物体castShadow = true; receiveShadow = true; ## shadowMap是一张记录每个像素用于比较遮挡关系的texture renderer.shadowMapSoft = true; # 可以使阴影更加平滑，产生更少的锯齿 renderer.shadowCameraNear = 3; renderer.shadowCameraFar = camera.far; renderer.shadowCameraFov = 50; # 表示摄像机近平面、远平面、角度的值。在摄像机范围内的物体产生阴影 renderer.shadowMapBias = 0.0039; renderer.shadowMapDarkness = 0.5; # 表示阴影的透明度, 0是完全透明 renderer.shadowMapWidth = 512; renderer.shadowMapHeight = 512; # 指定阴影渲染面的大小 ## 根据shadermap原理，阴影需要先绘制在一个缓冲区中，再根据缓冲区计算阴影。这就是缓冲区的大小。 container = document.createElement('div'); document.body.appendChild(container); container.appendChild(renderer.domElement); camera # 使用 camera = new THREE.Camera(60, 1, 1, 6500); camera.position.z = -85; camera.position.y = 40; camera.aspect = window.innerWidth / window.innerHeight; cameraTarget = new THREE.Object3D(); # 相机目标 cameraTarget.position.y = 10; cameraTarget.position.z = 6000; camera.target = cameraTarget; camera.updateProjectionMatrix(); PerspectiveCamera THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); # 透视摄像机 camera.position.x = 0; camera.position.y = 0; camera.position.z = 600; # 相机位置 camera.up.x = 0; camera.up.y = 1; camera.up.z = 0; # 相机\u0026quot;上\u0026quot;的方向 camera.lookAt({x:0, y:0, z:0}); # 视野中心坐标 camera.setViewOffset(fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight) # 相机的有效显示部分 OrthographicCamera OrthographicCamera(left, right, top, bottom, near, far) # 左右上下远近 controls contorls = new THREE.FirstPersonControls(camera); contorls.movementSpeed = 20; # 移动速度 controls.lookSpeed = 0.05; # 转头速度 controls.lookVertical = true; # 是否允许抬头或低头 PathControls # 路径相机 controls = new THREE.PathControls(camera); controls.createDebugPath = true; # 是否显示轨道 ## scene.add(controls.debugPath)来添加显示 controls.waypoints = [[-500, 0, 0], [0, 200, 0], [500, 0, 0]]; # 路径的转折点，非转折点用插值来计算 controls.duration = 28; # 轨道的一头到另一头的运动时间(ms), 默认是10 * 1000 controls.useConstantSpeed =true; # 设置为匀速运行 controls.lookSpeed = 0.06; # 转头速度, 默认是0.005。数越大，转头越快 ##页面显示帧数越快, 转头越快 controls.lookVertical = true; # 是否可以上下转头 controls.lookHorizontal = true; # 是否可以左右转头 controls.verticalAngleMap = {srcRange: [0, 2 * Math.PI], dstRange:[1.1, 3.8]}; controls.horizontalAngleMap = {srcRange: [0, 2 * Math.PI], dstRange: [0.3, Math.PI - 0.3]}; controls.lon = 180; controls.init(); scene.add( controls.animationParent ); # 用THREE.js提供的Animation类来插值改变相机位置和方向 ## pathControls类中有initAnimationPath函数将动作转换为关键帧，存到了parentAnimation属性中 ### THREE.AnimationHandler中的add函数，把scene中的parentAnimation中的关键帧动作键入THREE.JS的动画引擎中。动画引擎会自动在关键帧之间插值，来决定关键帧中物体(如相机)的位置、大小、缩放等。 function render(){ controls.update(delta); THREE.AnimationHandler.update(delta); ### 让动画引擎动起来 } TrackballControls # 轨迹球相机 介绍 追踪相机, 轨迹球相机 作用 控制相机，左键旋转，右键平移，滚轮缩放 api THREE.TrackballControls = function (object, domElement) # object一般是传入相机这个变量 # domElement为在哪个div中监听鼠标事件, 默认为document controls = new THREE.TrackballControls(camera); # 传入相机作为参数来控制相机 controls.rotateSpeed = 5.0; # 旋转的速度 controls.zoomSpeed = 5; # 缩放的速度 controls.panSpeed = 2; # 平移的速度 controls.noZoom = false; # 不允许放大 controls.noPan = false; # 不允许右键摇镜头 controls.staticMoving = false; # 是否静态移动, false时移动镜头会有弹性 controls.dynamicDampingFactor = 0.3; # 阻力系数 ## 旋转时慢慢停下来是这个系数起作用 function animate(){ requestAnimationFrame(animate); controls.update(); # 完成更新相机属性的工作 rederer.render(scene, camera); stats.update(); } FlyControls # 飞行相机 FirstPersonControls # 第一人称相机 scene # 使用 scene = new THREE.Scene(); # 场景 scene.add(meshCube); scene.add(light); light # 使用 // light.position.x = x; light.position.set(0, 0, 300).normalize();; # 坐标, 向量化为1 scene.add(light); PointLight # 点光源 var light = new THREE.PointLight(0x00FF00); DirectionalLight # 方向光 var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125); # 0.125是颜色的密度, 和透明度差不多, 这里表示很淡很淡的白色 scene.add(dirLight) AmbientLight # 环境光 scene.add(new THREE.AmbientLight(0x111111)); SpotLight # 聚光灯 light = new THREE.SpotLight(0xffffff, 1.25); light.target.position.set(0, 0, 0); light.castShadow = true; # 显现阴影，默认不显现 ## 显现阴影还要对renderer进行设置 object # mesh # 使用 var mesh = THREE.Mesh(geometry, material); # mesh模型 mesh.position.x= x; mesh.rotation.x = rx; scene.add(meshCube); 方法 mesh1.addChild(mesh2) # mesh2加入mesh1, 组成一个Mesh api mesh.scale.multiplyScalar(0.35) # 让x y z方向缩放系数到原模型的0.35倍 line THREE.Line( geometry, material, THREE.LinePieces ); ＃ 线 scene.add(line); 例子 var line_material = new THREE.LineBasicMaterial({color: 0x303030}), geometry = new THREE.Geometry(), floor = -75, step = 25; for( var i = 0; i \u0026lt;= 40; i++){ geometry.vertices.push(new THREE.Vector3(-500, floor, i * step - 500)); geometry.vertices.push(new THREE.Vector3(500, floor, i * step - 500)); geometry.vertices.push(new THREE.Vector3(i * step - 500, floor,- 500)); geometry.vertices.push(new THREE.Vector3(i * step - 500, floor, 500)); } var line = new THREE.Line(geometry, line_material, THREE.LinePieces); scene.add(line); MorphAnimMesh 介绍 动画网格模型 包含几个动画帧(一极动画模型)，通过播放帧来看动画。 可以设置帧数，播放到哪一帧，顺播还是倒播。 THREE.MorphAnimMesh = function (geometry, material){ THREE.Mesh.call(this, geometry, material); # 调用基类构造函数 this.duration = 1000; # 完成所有帧的时间(milliseconds) this.mirroredLoop = false; # 表示镜像循环(是否循环播放) this.time = 0; # 当前播放时间 this.lastKeyframe = 0; # 上一帧 this.currentKeyframe = 0; # 当前播放的帧 this.direction = 1; # 表示从前向后播放, -1是从后向前 this.directionBackwards = false; # 是否倒播 this.setFrameRange(0, this.geometry.morphTargets.length - 1); # 设置最小帧和最大帧 ## 这里开始帧是0, 结束帧是 总帧数 - 1 } 方法 THREE.MorphAnimMesh.prototype.setDirectionForward = function(){ this.direction = 1; # 1是前进, -1是后退 this.directionBackwords = false; # false表示前进 } # 计算下一帧是哪一帧时，根据上面两个变量计算 THREE.MorphAnimMesh.prototype.setDirectionBackward THREE.MorphAnimMesh.prototype.setAnimationLabel = function(label, start, end){ if( !this.geometry.animations) this.geometry.animation = {}; this.geometry.animations[label] = {start: start, end: end}; } # 设置帧分组标签(为了给每组设置不同的播放速度) THREE.MorphAnimMesh.playAnimation('A', 33) # 播放标签为'A'的组动画，帧数(fps)为33帧/秒 THREE.MorphAnimMesh.prototype.updateAnimation = function(delta # delta表示实际浏览器每次刷新的间隔时间 # 作用: 主要更新lastKeyframe mesh组件 # geometry # 介绍 geometry表示形状 THREE.Geometry(); # 空几何体 geometry.vertices.push(p1); # p1是一个点 geometry.vertices.push(p2); geometry.colors.push( color1, color2 ); 属性 vertices # 顶点数组 colors morphColors # 加载json模型后存储颜色的地方 faces # 面数组 color faceVertexUvs # 面法线数组 方法 set # 设置纹理坐标 faceVertexUvs[0][2][0].set(0, 0) faceVertexUvs[0][2][1].set(0, 0) faceVertexUvs[0][2][2].set(0, 0) faceVertexUvs[0][2][3].set(0, 0) # 设置第2个面(顶面)的纹理坐标全部为0，这样就去掉了这个面的纹理坐标 # 第一维表示第几种纹理，第二维表示第几个面，第三维表示第几个顶点的纹理坐标 BufferGeometry 一般编程中 物体的形状可以用一个类Geometry来表示 物体顶点内容如果放到缓冲区中，可以new分配连续的内存 物体和内存是分离的 Tree.js中 物体和内存统一起来，形成了THREE.BufferGeometry THREE.BufferGeometry = Buffer + THREE.Geometry BufferGeometry是自由度最高的geometry类型 自由指定每个顶点的位置、颜色、法线(影响光照) Buffer就是将顶点位置数组、顶点颜色数组等放在一个缓冲区中，加快加载与运行速度。 Buffer的这些缓冲区存储在BufferGeometry的属性attributes集合对象里面 # attributes初始化时为空 this.attributes = {}; api var geometry = new THREE.BufferGeometry(); # THREE.BufferGeometry = function() IcosahedronGeometry 二十面体 radius = 200 geometry = new THREE.IcosahedronGeometry(radius, 1); faceIndices = ['a', 'b', 'c', 'd']; for(var i = 0; i \u0026lt; geometry.faces.length; i++){ f = geometry.faces[i]; # 得到第i个面 n = (f instanceof THREE.Face3) ? 3 : 4; # 判断每个面由几个点组成 # 每个点可以由f.a, f.b, f.c, f.d得到 for(var j = 0; j \u0026lt; n; j++){ vertexIndex = f[faceIndices[j]]; # 得到点在geometry中的索引 p = geometry.vertices[vertexIndex]; # 得到点 f.vertexColors[j] = color; # 给面的顶点赋值 ## 顶点默认颜色为白色 } } SphereGeometry var geometry = new THREE.SphereGeometry(70, 32, 16); # 70是半径, 32和16表示横向和纵向球体由多少线分割 BoxGeometry 介绍 原来的CubeGeometry 长立方体 THREE.CubeGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) # 参数分别表示x y z轴长度和分别在x y z轴上被分成了几份 CylinderGeometry 圆柱体 THREE.CylinderGeometry(100, 150, 400); PlaneGeometry # 平面 TextGeometry 介绍 可以从字体文件中生成字体几何体 THREE.TextGeometry = function(text, parameters) # text是要显示的文字 # parameters包括 ## size: \u0026lt;float\u0026gt; 字体大小, 如80号是小字体 ## height: \u0026lt;float\u0026gt; 厚度 ## curveSegments: \u0026lt;int\u0026gt; 一条曲线上点的数目, 越多越精细 ## font: \u0026lt;string\u0026gt; 使用字体的名称 ## weight: \u0026lt;string\u0026gt; `取值normal或bold, 如果字体中没有bold, 整个程序会崩溃 ## style: \u0026lt;string\u0026gt; 取值normal或italics(斜体), 没有italics也会崩溃 使用 在typeface上转换自己的字体 http://typeface.neocracy.org/fonts.html # 要求字体的签名是TrueType或OpenType # 在Convert Font页面选择要转换的字,可以加快转换,也减少生成js文件的大小 var text3d = new THREE.TextGeometry('要显示的字', { size: 120, height: 30, curveSegments: 3, font: 'simhei', face: 'simhei', weight: 'normal' }); material # 使用 THREE.LineBasicMaterial( parameters ); # 线材质 参数 Color：线条的颜色，用16进制来表示，默认的颜色是白色。 Linewidth：线条的宽度，默认时候1个单位宽度。 Linecap：线条两端的外观，默认是圆角端点，当线条较粗的时候才看得出效果，如果线条很细，那么你几乎看不出效果了。 Linejoin：两个线条的连接点处的外观，默认是“round”，表示圆角。 VertexColors：定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值。（如果关于插值不是很明白，可以QQ问我，QQ在前言中你一定能够找到，嘿嘿，虽然没有明确写出）。 Fog：定义材质的颜色是否受全局雾效的影响。 uniforms: 传入着色器中的固定变量, 如 { scale: {type: 'v2', value: new THREE.Vector2()} } THREE.MeshBasicMaterial({color: 0x00ff00}); # mesh材质 MeshBasicMaterial 介绍 是three.js中最基本的材质 功能 将mesh渲染成线框模式或平面模式 # 平面模式指表面渲染比较平整 api new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, # 标志为true时颜色A分量(alpha)才起作用 blending: THREE.AdditiveBlending # 混合方式, 对应OpenGL ES中不同混合方式。表示怎么与背景结合 ## OpenGL中有一个颜色缓冲区，存放每次渲染的颜色(目标颜色)，新颜色(源颜色)可以与它混合，形成最新的颜色。 ## 可以是THREE.NoBlending = 0 ### 不混合。直接用新颜色覆盖以前的颜色 ## THREE.NormalBlending = 1 ### 将源颜色与目标颜色通过透明度正常混合 ## THREE.AdditiveBlending = 2 ### 加法混合 ## THREE.SubtractiveBlending = 3 ### 减法混合 ## THREE.MultiplyBlending = 4 ### 乘法混合 ## THREE.CustomBlending = 5 ### 自定义混合 }); new THREE.MeshBasicMaterial({ color: 0xffaa00, wireframe: true }); new THREE.MeshBasicMaterial({ map: texture, transparent: true }); MeshNormalMaterial 只支持以THREE.FlatShading模式来渲染Mesh, 不支持将Mesh渲染为线框模式 MeshLambertMaterial 在灰暗或不光滑的表面产生的均匀散射而形成的材质类型。向各个方向均反射光线。如白纸 new THREE.MeshLambertMaterial({ color: 0xff6600, # 材质的颜色 ambient: 0xff2200, # 受环境光情况 envMap: textureCube, # 环境纹理，会将环境纹理映射到材质身上 combine: THREE.MixOperation, # 与环境材质之间的混合方式 reflectivity: 0.3 # 对反射光的反射系数 }) new THREE.MeshLambertMaterial({map:texture, transparent: true}) # 带透明的兰伯特材质, 可以看到球体另一边的颜色 new THREE.MeshLambertMaterial({color: 0xdddddd, shading: THREE.FlatShading}) # 灰色，非平滑 new THREE.MeshLambertMaterial({color: 0xdddddd, shading: THREE.SmoothShading}) # 灰色，平滑 new THREE.MeshLambertMaterial({color: 0x666666, emissive: 0xff0000, ambient: 0x000000, shading: THREE.SmoothShading}) # emissive表示自发光 MeshPhongMaterial 有明显高光区，适用于湿滑的，表面具有光泽的物体。如: 玻璃，水滴等 特点 会产生高光(球某一点在光线下特别亮) THREE.MeshPhongMaterial({ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.FloatShading}) THREE.MeshPhongMaterial({ambient:0x030303, color:0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading, map: texture, transparent: true}) THREE.MeshPhongMaterial({color: 0x000000, specular: 0x666666, emissive: 0xff0000, ambient: 0x000000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.9, transparent: true}) MeshDepthMaterial 支持一些尝试测试的效果 MeshFaceMaterial 面材质，它是一个材质数组。 有且仅有一个成员数组materials, 用来存放一组材质。 这组材质会被geometry的不同面所使用，来做到同一个物体不同面使用不同材质的效果。 每一个面使用什么材质由geometry中的索引决定 ShaderMaterial 使用 material = new THREE.ShaderMaterial({ uniforms: uniforms, # 一致变量数组，传递到两个着色器中使用 vertexShader: document.getElementById('vertexShader').textContent, # 顶点着色器的代码 fragmentShader: document.getElementById('fragmentShader').textContent # 片元着色器代码 }); uniforms = { time: {type: 'f', value: 1.0}, # 表示时间， f 代表浮点型 resolution: {type: 'v2', value: new THREE.Vector2() } # 表示浏览器窗口的宽度和高度，v2代表二维向量 } # 该一致变量在绘制过程中不会改变，在顶点shader与片元shader之间用相同名字来共享 ## 一致变量在不同图元中会改变 uniforms.resolution.value.x = window.innerWidth uniforms.time.value += 0.005 # 通过value改变uniforms中变量的值 texture # 例子 var geometry = new THREE.PlaneGeometry( 500, 300, 1, 1 ); geometry.vertices[0].uv = new THREE.Vector2(0,0); geometry.vertices[1].uv = new THREE.Vector2(2,0); geometry.vertices[2].uv = new THREE.Vector2(2,2); geometry.vertices[3].uv = new THREE.Vector2(0,2); # 平面有4个纹理坐标。由顶点的成员nv表示，nv是一个二维向量，对应到纹理坐标 var texture = THREE.ImageUtils.loadTexture(\u0026quot;textures/a.jpg\u0026quot;,null,function(t){}); var material = new THREE.MeshBasicMaterial({map:texture}); var mesh = new THREE.Mesh( geometry,material ); scene.add( mesh ); 例子2(canvas) var geometry = new THREE.CubeGeometry(150, 150, 150); texture = new THREE.Texture(canvas); # 默认情况下，纹理被均匀地分配到四边形的各个顶点上。 var material = new THREE.MeshBasicMaterial({map: texture}); texture.needsUpdate = true; # 如果canvas中有动画的话，要设置纹理更新。而且每requestAnimationFrame渲染一帧动画，都要对texture.needsUpdate设置一遍true。如果不更新，显示黑色正方体。 ## 黑色正方体原因: js异步运行,canvas绘制时钟需要时间, three.js已经开始渲染图形了，这时候canvas没有绘制完成，就显示材质本身的颜色。 mesh = new THREE.Mesh(geometry, material); scene.add(mesh); Mapping UVMapping Filter LinearFilter Wrapping RepeatWrapping Color # THREE.Color() THREE.Color( 0x444444 ); Vector3 # THREE.Vecotor3(4,8,9); THREE.Vector3(); point1.set(4,8,9); Quaternion # 介绍　四元组 api THREE.Quaternion = function(x, y, z, w){ this._x = x || 0; this._y = y || 0; this._z = z || 0; this._w = (w !== undefined) ? w : 1; } setFromAxisAngle: function(axis, angle) # Quaternion的静态方法 ## axis是向量，表示轴, angle表示弧度 ## 返回一个四元组 setFromEuler: function(euler, update) # 欧拉角转为四元组 setFromRotationMatrix: function(m) # 把矩阵转为欧拉角 fog # scene.fog = new THREE.Fog(0x999999, 0.1, 8000); THREE.Fog = function(hex, near, far) # hex为颜色, near是雾开始的地方, far是雾结束的地方 Object3D # new THREE.Object3D(); Ray # 介绍 一条射线 ray = new THREE.Ray(camera.position); # 传入起点 particle # particleSystem = new THREE.ParticleSystem(particles, material); 工具 # utils # ImageUtils loadTextureCube([\u0026quot;\u0026quot;, \u0026quot;\u0026quot;]); ShaderUtils var shader = lib[\u0026quot;cube\u0026quot;] UniformsUtils clone(shader.uniforms) GeometryUtils merge = function(geometry1, object2/* mesh | geometry */){ ... } # geometry1是合成后的对象，第二个是要合并的对象，如果是mesh，就取mesh中的geometry对象 filter # LinearFilter NearestFilter effect # BloomEffect postBloom = new BloomEffect(renderer, renderTarget, window.innerWidth, window.innerHeight, 4); helper # o-\u0026gt; 辅助对象一键打开或关闭 # 将所有辅助对象放到helps数组中 var help = []; helps.push(helper); helps.push(faceNormalsHelper); helps.push(vertexNormalsHelper); window.addEventListener('keydown', onKeyDown, false); function setVisible(visible){ for(var i = 0; i \u0026lt; helps.length; i++){ helps[i].visible = visible; } } function onKeyDown(event){ switch(event.keyCode){ case 65: /*A*/ setVisible(false); break; case 83: /*S*/ setVisible(true); break; } } GridHelper 介绍 网格辅助类, 绘制网格和网格线颜色 api THREE.GridHelper = function(size, step) # size定义网格正方形边长, step是间隔距离 使用 var helper = new THREE.GridHelper(200, 10); helper.setColors(0x0000ff, 0x808080); # 第一个是x y z轴颜色, 第二个是其它线条颜色 helper.position.y = -150; scene.add(helper); BoxHelper 介绍 长方体包围盒, 椭圆包围盒, 包围物体用于检查碰撞或辅助设计中表示选中 使用 var boxHelper = new THREE.BoxHelper(mesh); scene.add(boxHelper); FaceNormalsHelper 介绍 辅助画法线 api FaceNormalsHelper(object, size, hex, linewidth) 使用 var faceNormalsHelper = new THREE.FaceNormalsHelper(mesh, 10) VertexNormalsHelper 介绍 辅助画顶点法线 WireframeHelper 介绍 将模型转换为线框图 物件 # Mirror 介绍 模拟一个镜子, 放在那, 就反射它前面的景物 原理是一个平面, 上面的材质不断变化 o-\u0026gt; api THREE.Mirror = function(renderer, camera options) renderer是渲染器 camera最好是透视相机 options textureWidth textureHeight clipBias color debugMode o-\u0026gt; 使用 var planeGeo = new THREE.PlanneGeometry(100.1, 100.1); # 定义平面 groundMirror = new THREE.Mirror( # 定义镜面 renderer, camera, {clipBias: 0.003, textureWidth: WIDTH, textureHeight: HEIGHT, # 表示内存中生成纹理的大小, 最好和屏幕一样大, 否则有mosaic debugMode: true} # 开启调试模式会有辅助线 ); AnimationHandler # 介绍 主要负责动画的插值和播放 shader # EffectComposer 介绍 用于渲染复杂效果, 例如将一个场景作为纹理传入, 例如用着色器将场景某部分模糊或发光处理 原理是将画面在一个临时缓冲区先画出来,再将大量效果组合. 一般是用着色器来实现 使用 composer = new THREE.EffectComposer(render); # 可以是WEBGLRenderer或CanvasRenderer ## 第二个参数是renderTarget(渲染目标), 没有时默认生成一个 ### renderTarget是gpu的内部对象,用来暂存绘制结果 composer.addPass(new THREE.RenderPass(scene, camera)); # 第一个效果通常是RenderPass, 它将渲染结果放入效果链中 ## 将结果渲染到gpu的一个帧缓冲区(临时内存) ## pass中有enable成员变量, 只有为true时该pass才起作用 var effect = new THREE.ShaderPass(THREE.DotScreenShader); # DotScreenShader是examples/js/shaders中的一个 ## 它定义了一些一致变量, 每个帧循环操作它们来控制渲染效果 effect.uniforms['scale'].value = 4; composer.addPass(effect); var effect = new THREE.ShaderPass(THREE.RGBShiftShader); effect.uniforms['amount'].value = 0.0015; effect.renderToScreen = true; composer.addPass(effect); # 通过addPass加效果到效果链passes中 ## 添加顺序重要,后一个效果会作用于前一个效果 composer.render() # 用它替换render.render(scene, camera) ## 遍历所有通道, 可以传入参数delta, 表示帧与帧之间渡过的时间 api 方法 insertPass(pass, index) # 将某一个通道插入指定的位置 对象 WebGLRenderTarget(width, height, options) # width是缓冲区的宽度, height是缓冲区的高度, options是参数 RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) # overrideMaterial表示一种材质, 它会覆盖先前设置的材质 # clearColor表示每一次帧缓冲绘制前的底色. 用于清除上一次绘制结果 # clearAlpha是0或1, 表示清除透明色 ## this.enabled属性表示是否启用该pass 方法 render(renderer, writeBuffer, readBuffer, delta) DotScreenShader # 点阵屏效果, 就是报纸中点阵的印刷效果 RGBShiftShader # 变化颜色分量RGBA, 如A点的R值不显示, 而取B点的R值 ## angle表示偏移角度 ## amount表示AB的长度. 由于纹理坐标为0到1, 所以0.005会有很多像素 BloomPass(n) # 像素点膨胀模糊, 像墨水渗出 # n 是模糊的程度 FilmPass(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) # 依赖FilmShader.js. 整个场景灰白, 或像lcd荧光屏在屏幕上看到线条等屏幕效果 ## noiseIntensity 表示杂点的密度, 值越大杂点越多 ## scanlinesIntensity 是扫描线的密度, 值越大扫描线透明度越小 ## scanlinesCount 扫描线的数量 ## grayscale 如果true表示黑白显示 var effectFilm = new THREE.FilmPass(0.35, 0.75, 2048, false); effectFilm.renderToScreen = true; composer.addPass(effectFilm); projector # 介绍 包含各种矩阵 提供重要且简单的函数，进行二维和三维之间的转换 函数 this.unprojectVector = function(vector, camera) # 归一化空间中的点 ## 归一化是将(-1, -1, -1)到(1, 1, 1)中的某个点还原成三维中的某个点 # vector是需要归一化的那个点，要归一化成(-1, -1)到(1, 1)空间的点 ## z 是没有意义的，通常设置为1 # camera是当前相机，有了相机才能计算当前投影。 扩展 # 性能 # stats.js # 官网 https://github.com/mrdoob/stats.js 视图 # 点击切换 fps # 上一秒的帧数 ms # 一帧的毫秒数 使用 引入stats.js文件 init中 var stats = new Stats(); stats.setMode(1); // 0: fps, 1: ms // 将stats的界面对应左上角 stats.domElement.style.position = 'absolute'; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; document.body.appendChild( stats.domElement ); treeStart中 setInterval( function () { stats.begin(); // 你的每一帧的代码 stats.end(); }, 1000 / 60 ); 或 init中 stats = new Stats(); stats.domElement.style.position = 'absolute'; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; animation中 stats.update(); 动画引擎 # tween.js # 官网 https://github.com/sole 介绍 开源的缓动类 使用 引入tween.js initObject之后调用 function initTween() { new TWEEN.Tween( mesh.position) .to( { x: -400 }, 3000 ).repeat( Infinity ).start(); } animation中 requestAnimationFrame(animation); TWEEN.update(); 使用2(雾的far的缓动) scene.tween = new TWEEN.Tween(scene.fog, false) # 对scene.fog的属性进行操作 .to({far: 1500}, 6000) # 在6秒种内将scene.fog.far变为1500 .easing(TWEEN.Easing.Sinusoidal.EaseOut) .delay(6000) # 缓动在调用start()后，等待6秒执行 .onComplete(function(){ # 缓动执行完成后(far= 1500后)的回调函数 }).start(); scene.tweenBack = new TWEEN.Tween(scene.fog, false) .delay(2000) .to({far: 15000}, 10000) .easing(TWEEN.Easing.Sinusoidal.EaseOut); scene.tween.chain(scene.tweenBack); 使用3(相机的左右[-500, 500]摇动) # 缓动链 camera.tween = new TWEEN.Tween(camera.position, false) .to({x: 500}, 6000) .easing(TWEEN.Easing.Sinusoidal.EaseInOut) .start(); camera.tweenBack = new TWEEN.Tween(camera.position, false) .easing(TWEEN.Easing.Sinusoidal.EaseInOut) .to({x: -500}, 6000) camera.tween.chain(camera.tweenBack); camera.tweenBack.chain(camera.tween); # 两个动画彼此加入了自己的缓动链中，两个动画可以交替执行 TWEEN.Easing TWEEN.Easing.Sinusoidal.EaseOut # Sinusoidal是正弦曲线的缓动 Loader # VTKLoader var loader = new THREE.VTKLoader(); loader.addEventListener('load', function(event){ var geometry = event.content; var mesh = new THREE.Mesh(geometry, material); mesh.position.setY( - 0.09); scene.add(mesh); }); loader.load(\u0026quot;models/vtk/bunny.vtk\u0026quot;); JSONLoader THREE.JSONLoader.prototype.load = functiono(url, callback, texturePath) # url是json文件的地址 # callback在异步加载完后执行 # texturePath 纹理路径，没有这个参数时，在当前路径下寻找默认纹理。 BinaryLoader 使用 var loader = new THREE.BinaryLoader(true); document.body.appendChild(loader.statusDomElement); # 实时显示加载进度 THREE.BinaryLoader = function(showStatus){ THREE.Loader.call(this, showStatus); # showStatus表示是否显示进度条 } THREE.BinaryLoader.prototype.load = function(url, callback, texturePath, binaryPath) # url是js文件的路径 # callback 当url中数据加载完成后调用。callback中接收geometry作为参数 # texturePath 纹理路径，不指定默认放在url同文件夹下，或无纹理。 # binaryPath 二进制文件的路径，不指定时，根据url地址中的文件来加载。 ColladaLoader UTF8Loader 介绍 导入 google WebGL-Loader格式的高压缩文件 SceneLoader 介绍 导入各物体、变换层级、材质、纹理、相机、光源的统一js文件，其中有其它js的url引用 Controls # 见Camara Detector # if(! Detector.webgl) Detector.addGetWebGLMessage(); 命令 # convert_obj_three.py 介绍 转换obj文件为three.js二进制文件 python convert_boj_three.py -i alien2.obj -o alien2_bin.js -t binary 着色器 # 介绍 一种二进制码，在绘制场景之前做一些事。操作在显卡中进行 对每一个顶点或者片元执行一次着色器，这个操作并行执行 浏览器底层只支持着色器 three.js底层是着色器实现的，所以着色器能实现一些three.js无法实现的功能，并能提高three.js的性能 优势与性能 1. 处理大量数据能力。顶点着色器为每一个顶点确定位置，片元着色器为每个片元确定颜色，数据量非常庞大 # 一个3d游戏中，一帧几十万个三角形。显示器分辨率1280x1024, 有1310720个像素，每一帧由片元着色器处理。 ## 每个顶点位置与每个片元颜色几乎同时计算完成 webgl着色器分类 # 无论在opengl, openes, dx中，都分为顶点着色器和片元着色器 顶点着色器 对顶点进行操作，如 改变顶点的位置和大小 片元着色器 定义屏幕中各点的颜色 顶点之间的颜色也被一起处理了(插值) 顶点着色器 # 介绍 接收三维点坐标，处理为二维坐标并输出 THREE.ShaderMaterial用来定义着色器，着色器材质用着色器程序去控制几何体的顶点和颜色 内置变量 gl_Position three.js注入变量 postion # gl_Position = vec4(position, 1.0); uv 使用 \u0026lt;script id=\u0026quot;vertexShader\u0026quot; type=\u0026quot;x-shader/x-vertex\u0026quot;\u0026gt; # type只是通用标记为顶点着色器, 不起作用 void main(){ # 类似c语言, 着色器有一个main函数 ## 每个顶点在计算时，都会执行main函数 gl_Position = vec4(position, 1.0); # 将计算顶点最终位置的结果放在gl_Position中 ## 这个位置被称为设备归一化坐标 ## gl_Position是默认变量，不必声明就可用，gl_Position一定要赋值 ## 顶点着色器最主要作用就是给gl_Position赋值 # 作用: ## gl_Position 是相机投影之后的坐标 ## 顶点的位置传给position, 通过我们变换, 再赋值给gl_Position ## position中的值来源如mesh.vertices.push(new THREE.Vector3(x, -y, 0)) } \u0026lt;/script\u0026gt; 例子 void main(){ gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } # projectionMatrix是投影矩阵，modelViewMatrix是模型视图矩阵 片元着色器 # 介绍 一个片元对应一个像素，对其输出一个颜色值。 # 将顶点着色器输出的二维点坐标转化为待处理的像素并传递给片元着色器的过程，称为图元光栅化 颜色会受到光照, 阴影等影响, 所以片元着色器大多处理这些物理效果 内置变量 gl_FragColor # 输出的一个像素的颜色, vec4类型, 红 绿 蓝 透明 gl_FragCoord #只读变量,保存了片元相对窗口的坐标位置 ## x, y, z, 1/w 其中z表示片元深度, z越大越深 输入 varying0, varying1, .... , varyingn #用户自定义的易变变量 uniforms # 一致变量. 在js, 顶点着色器, 片元着色器中传递数据, 一次渲染中数据不变 临时变量 gl_Position # 当前片段(像素)的位置 gl_FrontFacing # 表示每个顶点的大小 gl_PointSize # 当前片段来自三角形的正面还是背面. 该变量只是为了节省性能 采样器 使用 \u0026lt;script id=\u0026quot;fragmentShader\u0026quot; type=\u0026quot;x-shader/x-fragment\u0026quot;\u0026gt; void main(){ gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); ＃ 表示片元颜色，是RGBA } \u0026lt;/script\u0026gt; 例子 uniform vec2 resolution; uniform float time; float a = 1.0, b = 1.0, c = 1.0; float t; void main (){ t = time; a = abs(sin(t)); b = abs(cos(t)); c = abs(sin(t) * cos(t)); gl_FragColor = vec4(vec3(a, b, c), 1.0); } 变量 # 变量分类 attributes(属性变量) # 保存顶点独有数据，如顶点的位置 attributes vec3 pos; uniform(一致变量) # 一帧渲染过程中保持不变，如光照方向 uniform vec3 a; varying(易变变量) # 比较容易变化的变量，用来在顶点着色器与片元着色器之间传递数据 varying vec3 a; 类型 vec2 # 二维变量 vec3 # 三维变量 vec4 mat4 sampler2D float 传递关系 attribute -\u0026gt; 顶点着色器 -\u0026gt; varying -\u0026gt; 图元光栅化 -\u0026gt; varying -\u0026gt; 片元着色器 -\u0026gt; gl_FragColor uniform -\u0026gt; 顶点着色器 -\u0026gt; gl_Position -\u0026gt; 图元光栅化 -\u0026gt; gl_Position -\u0026gt; 片元着色器 -\u0026gt; gl_FragColor 思路 # animate动画 # window.requestAnimationFrame(callback) # 返回id, 传给window.cancelAnimationFrame()取消该次动画 ## 原理 ### 传递浏览器回调函数，浏览器调用它更新画面。 #### 与setInterval()不同之处在于自动控制了时间。对方法调用进行了优化。页面失去选中时动画自动暂停。 ### 回调函数中　调用了requestAnimation(callback)来循环调用 ### 通常执行callback函数来开始动画 # 最原始的是window.setTimout()或者window.setInterval()来更新元素的位置 ## 更新频率要达到每秒60次 animation function threeStart() { initThree(); initCamera(); initScene(); initLight(); initObject(); animation(); } function animation() { //rend＋ erer.clear(); camera.position.x = camera.position.x + 1; renderer.render(scene, camera); requestAnimationFrame(animation); } 或 function animation() { mesh.position.x-=1; renderer.render(scene, camera); requestAnimationFrame(animation); } render function animate(){ for(var i = 0; i \u0026lt; apps.length; ++i){ apps[i].animate(); } requestAnimationFrame(animate); } function App(...){ this.animate = function(){ render(); stats.update(); } function render(){ camera.position.x += (mouseX - camera.position.x) * 0.05; camera.position.y += (-mouseY - camera.position.y) * 0.05; # 相机位置随鼠标移动 ## mouseX, mouseY为自定义的全局变量 camera.lookAt(scene.postion); renderer.render(scene, camera); } } render计算 var mouseX = 0, mouseY = 0; document.addEventListener('mousemove', onDocumentMouseMove, false); function onDocumentMouseMove(event){ mouseX = (event.clientX - windowHalfX); mouseY = (event.clientY - windowHalfY); } 相机旋转 围绕y轴, 半径1000的圆作圆周运动。 var timer = 0.0001 * Date.now(); # 用当前时间作弧度 camera.position.x = Math.cos(timer) * 1000; camera.position.z = Math.sin(timer) * 1000; camera.lookAt(scene.position); 自发光变化 material.emissive.setHSV(0.54, 1, 0.7 * (0.5 + 0.5 * Math.sin(35 * timer))); 引擎 组成 定义与初始化相机 定义与初始化场景 定义与初始化光 定义与初始化渲染器 定义与初始化性能监视器 定义鼠标事件, 窗口缩放事件 ele.addEventListener('mousedown', ...) ele.addEventListener('mouseup', ...) ele.addEventListener('mousemove', ...) window.addEventListener('resize', ...) 播放音乐 结构 # 定义App类 App类将相机，视图，灯光等场景代码封装，为了场景的代码的重用 # 场景重新new 例子1, 视口app function App( containerId, fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight ) 对象池 介绍 用过的对象保存起来，下次需要时重复使用。 减少频繁创建对象所造成的内存开销和cpu开销 自定义ObjectPool.js function ObjectPool(){ this.pool = new Array(); this.avail = new Array(); # 可用在pool中的索引，pool中对象不在使用，待再利用时放入avail中 } ObjectPool.prototype.createObject = function(){ return new Object(); } # 创建一个多态的对象(如一个豆径)，需要重载, ObjectPool.prototype.returnObject = function(poolId){ this.avail.push(poolId); } # 标记为可再利用 ObjectPool.prototype.getObject = function(){ if(this.avail.length ==0){ var o = this.createObject(); o.poolId = this.pool.length; this.pool.push(o); this.avail.push(o.poolId); } var poolId = this.avail.pop(); return this.pool[poolId]; } 控制 # resize window.addEventListener( 'resize', onWindowResize, false ); function onWindowResize( event ) { SCREEN_WIDTH = window.innerWidth; SCREEN_HEIGHT = window.innerHeight; renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT ); camera.aspect = 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT; camera.updateProjectionMatrix(); # 产生透视投影矩阵 } 鼠标射线 mouse = new THREE.Vector3(0, 0, 1); projector = new THREE.Projector(); ray = new THREE.Ray(camera.position); function onDocumentMouseMove(event){ mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; # 取得鼠标的位置，并将其转换为-1到1之间(归一化) ray.direction = projector.unprojectVector(mouse.clone(), camera); # 得到当前鼠标指向二维的点在程序三维中的位置 ray.direction.subSelf(camera.position).normalize(); # 鼠标所在的点送去相机所在的点，得到相机指向鼠标所在点的向量并规范化 intersects = ray.intersectObject(plane); # 计算射线与模型的相交点数组 } 场景 # 天空盒 两种实现 立方体内部贴纹理 椭球内部贴纹理 立方体天空盒 var r = 'textures/cube/Bridge2'; var urls = [r + 'posx.jpg', r + 'negx.jpg', r + 'posy.jpg', r + 'negy.jpg', r + 'posz.jpg', r + 'negz.jpg']; var textureCube = THREE.ImageUtils.loadTextureCube(urls); textureCube.format = THREE.RGBFormat; # 设置图片格式，此格式不需要透明度。节约内存又加快渲染速度 var shader = THREE.ShaderLib['cube']; # ShaderLib与three.js引擎的一个数组, 其中的cube存放的是立方体贴图的shader shader.uniforms['tCube'].value = textureCube; # 纹理给shader着色器 var material = new THREE.ShaderMaterial({ fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: shader.uniforms, depthWrite: false, side: THREE.BackSide }); # 用ShaderMaterial材质包装shader mesh = new THREE.Mesh(new THREE.CubeGeometry(100, 100, 100), 22, material); sceneCube.add(mesh); 性能 # 概要 3d设计的精髓在于性能优化 使用连续内存(如数组)将加速程序运行，不连续内存将增加读取时寻址的时间。 使用 $(document).ready( function(){ var container = document.getElementById(\u0026quot;container\u0026quot;); var app = new MineCraftApp(); app.init({container: container}); # container属性 表示最后渲染结果外层的div app.run(); } ); App 介绍 封装了three.js的一些基本操作, 如 创建渲染场景 创建相机 控制画布缩放 鼠标输入 对three.js进行了面向对象的封装，可以面向对象编程 函数 prototype.init(param) # 初始化 ## 参数是一个键值对对象 ## 一个WebGLRenderer渲染器 ## 一个场景 THREE.Scene() ## 一个透视投影 THREE.PerspectiveCamera ## 一个投影器 THREE.Projector() ## 一些鼠标键盘的操作 prototype.run = function(){ # 是渲染循环，会不断被调用 ## 调用每一个Sim.Object的update this.update(); this.renderer.render(this.scene, this.camera); var that = this; requestAnimationFrame(function(){that.run(); }); # run的帧循环 } prototype.addObject # 将Sim.Object对象加入场景中 prototype.removeObject # 将Sim.Object对象从场景移出 属性 renderer scene camera objects # 场景中的所有可视对象 Publisher 介绍 一个事件驱动模型 Sim.Publisher用于 记录事件 发送事件 处理事件 当事件发生时，它遍历注册的回调列表，调用每一个注册的函数 函数 prototype.subscribe = function(message, subscriber, callback) # 发起订阅 ## message表示事件名 ## 放callback函数的类 ## 事件发生时的执行回调函数 prototype.unsubscribe = function(message, subscriber, callback) # 取消订阅, 删除MessageTypes数组中事件名对就的链表中的一节点 ## message值为null, false, undefined时表示删除整个链表(不删除事件) prototype.publish = function(message) # 触发事件 属性 MessageTypes # 事件与其处理函数的集合 ## 形如 messageType['remove'] = [subscriber, callback] -\u0026gt; [subscriber, callback] ### 'remove'是事件名, subscriber是订阅者, callback是订阅者该事件的回调方法 ### -\u0026gt; 是链表的意思 Object 介绍 sim.js所有封装类的基类, 派生于Sim.Publisher 可以表示大多数对象(自定义的对象派生于它) 方法 prototype.setPosition # 设置object3D对象的位置 prototype.setScale prototype.setVisible prototype.update # 更新该对象和它的children ## 在每一次渲染循环时调用,用来产生自己的动画 prototype.addChild # 添加子对象, 如汽车添加轮子 prototype.removeChild 属性 object3D # 用于保存three.js中的Object3D对象 children 框架 # sim # 介绍 封装three.js大量重复工作 如设置渲染器，循环重绘，向场景添加Mesh等 physi.js # 介绍 基于three.js上构建的物理引擎 voxel.js # 介绍 像素方块游戏开发(minecraft) 例子(来自webgl中文网) # 16万个三角形 # 定义 o-\u0026gt; triangles = 160000 o-\u0026gt; 每个三角形有３个顶点, 一个顶点三个float表示，共triangles * 3 * 3个float # 用数组存放 o-\u0026gt; 每个顶点一个法向量，一个三角形３个法向量 赋值 o-\u0026gt; 所有三角形顶点应该在一个以原点为中心的正方体内 o-\u0026gt; 三角形的位置在正方体内随机分布 实现 var geometry = new THREE.BufferGeometry(); geometry.attributes = { index:{ itemSize: 1, array: new Uint16Array(triangles * 3), numItems: triangles * 3 }, # 索引 ## 每一个数组元素的聚会范围是[0, 65535],如果顶点数超过65535,必须通过geometry的offset成员来进一步设置偏移量。 ### 65535是16位整型 position: { itemSize: 3, array: new Float32Array(triangles * 3 * 3), numItems: triangles * 3 * 3 }, # 位置 normal:{ itemSize: 3, array: new Float32Array(triangle * 3 * 3), numItems: triangles * 3 * 3 }, # 法线 color: { itemSize: 3, # 一项目(元)由几个字节组成 array: new Float32Array(triangles * 3 * 3), # 实际存项目的内存数组 numItems: triangles * 3 * 3 # 有多少个项目 } # 颜色 } # Uint16Array分配指定个数的16位无符号整数，寝值为0 ## 如果内存紧张，无法分配时则引发异常 ## api uint16Array = new Uint16Array(length); ### uint16Array = new Uint16Array(array); # 位置，用Vector3来表示，共有triangles * 3个Vector3 ## 每个Vector3有x, y, z三个分量组成, 所以顶点需要triangles * 3 * 3个浮点数表示。 # 法线, 一个点对应一个法线, 由x, y, z三个float组成，所以需要triangles * 3 * 3个float # 颜色, 每个顶点一种颜色，颜色由R, G, B组成，所以需要triangles * 3 * 3个float var n = 800, n2 = n/2; # n是正方体的边长 # 为三角形顶点赋随机值，后计算每个顶点的法向量 ## positions数组每隔9个是一个三角形 ## normals数组每隔9个是一个三角形 # 随机生成颜色，赋给顶点 ## colors数组每隔9个是一个三角形 # 给geometry设置索引和偏移量 ## 索引对应到点，所以有triangles * 3个 ### 索引从0开始 # 将BufferGeometry和材质组成mesh 人物粒子 # 生成粒子 var vertices = geometry.vertices; var mesh = new THREE.ParticleSystem(geometry, new THREE.ParticleBasicMaterial({size: 3, color: c})); mesh.scale.x = mesh.scale.y = mesh.scale.z = scale; mesh.position.x = mesh.position.y = mesh.position.z = position; 渲染 render() mesh.geometry.verticesNeedUpdate = true; # 如果不刷新，渲染出来的顶点位置不会改变 renderer.clear(); composer.render(0.01); # composer为THREE.EffectComposer, 效果组合器 多视口 # viewport 注意 视口的坐标为归一化的坐标。左上角是(0, 0), 右下角是(1, 1) 阴影贴图 canvas画阴影 阴影纹理 var shadowTexture= new THREE.Texture(canvas); shadowTexture.needsUpdate = true; # 表示纹理是新纹理，在绘制的时候，需要更新到材质上 var shadowMaterial = new THREE.MeshBasicMaterial({map:shadowTexture}); 平面和线框同时显示 材质wireframe属性只有true和false,所以要创建2个不同材质的相同物体 THREE.SceneUtils.createMultiMaterialObject(geometry, materials) # 传递一个几何体和材质数组，几何体每一个材质组合成一个Mesh, 将Mesh加入组group对象中，返回组对象。 杰克与豆径 # 主要内容 天空盒 生长效果 树叶的生长 树干变形 音乐渲染控制生长 对象池 设计 鼠标操作 植物模型 plant 豆干，豆径(leaf3.js)，豆叶(leaf5.js) 豆径豆叶的材质 植物生长 阴天、晴天 天空材质 相机动画 音乐 \u0026lt;audio id=\u0026quot;audio\u0026quot; preload=\u0026quot;auto\u0026quot; loop\u0026gt; # 预加载音乐并循环播放 \u0026lt;source src=\u0026quot;a.mp3\u0026quot; type=\u0026quot;audio/mpeg\u0026quot;\u0026gt; \u0026lt;/audio\u0026gt; \u0026lt;script\u0026gt; audio = document.getElementById('audio'); audio.play(); \u0026lt;/script\u0026gt; 流动立方体 # 设计 从相机到鼠标发射射线, 与射线相交的点，就是选中物体的某个点 我的世界 # MineCraftApp = function(){ Sim.App.call(this); } MineCraftApp.prototype = new Sim.App(); MineCraftApp.prototype.init = function(param){ Sim.App.prototype.init.call(this, param); # 调用父类的init函数，在父类中初始化相机, 场景等类 # 性能监视器 # 天空盒 # 相机控制类 # 场景中的一个个小物体 } $(document).ready( function(){ var container = document.getElementById(\u0026quot;container\u0026quot;); var app = new MineCraftApp(); app.init({container: container}); # container属性 表示最后渲染结果外层的div app.run(); } ); 汽车换装 # 设计 汽车类 更换s汽车模型 更换汽车各部分颜色 两个相机 两个场景 三种光源 天空盒 渲染器 效率监听器 初始化各种材质 汽车类 veyron: { name: '布加迪威龙', url: 'obj/veyron/VeyronNoUv_bin.js', author: '布加迪威龙', init_rotation: [0, 0, 0], scale: 5.5, init_materials: 4, body_materials: [2], object: null, buttons: null, materials: null } 分形 # uniforms = { scale: {type: 'v2', value: new THREE.Vector2()}, c: {type: 'v2', value: new THREE.Vector2()} } material = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: document.getElementById('vertexShader').textContent, fragmentShader: document.getElementById('fragmentShader').textContent }); mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.0), material); # 用 2 * 2 的平面来覆盖浏览器窗口 function onWidowResize(event){ renderer.setSize(window.innerWidth, window.innerHeight); uniforms.scale.value.x = window.innerWidth / 2; uniforms.scale.value.y = window.innerHeight; } o-\u0026gt; 片元着色器中代码 uniform vec2 c; uniform vec2 scale; void main(void){ float R = (gl_FragCoord.x - scale.x) / scale.y; float I = (gl_FragCoord.y - scale.x) / scale.y; float R2 = R * R, I2 = I * I; int mm; for(int m =0; m \u0026lt; 255; m++){ I = (R + R) * I + c.y; R = R2 - I2 + c.x; R2 = R * R; I2 = I * I; mm = m; if(abs((I2) / (I + R)) \u0026gt; 10.) break; } if(mm == 254) gl_FragColor = vec4(0., 0., 0., 1.); else{ float a = float(mm); a = mod(a, 15.) / 5.; gl_FragColor = vec4(max(0., abs(a - 1.5) - .5)), max(0., 1. - abs(a - 1.)), max(0., 1. - abs(a - 2.)), 1.); } } 镜像分形 # 介绍 镜面反射场景 var mirrorMesh = new THREE.Mesh(planeGeo, groundMirror.material); # groundMirror.material是THREE.Mirror中定义的材质. 会在每次update(或者render)过程中变化 ## groundMirror.updateTextureMatrix() ## groundMirror.render() 要在update或render前重新渲染镜子的纹理. ### 多面镜子时, 如上一个个更新会有干扰, 要用下面代码更新 ### groundMirror.renderWithMirror(verticalMirror); ### verticalMirror.renderWithMirror(groundMirror); mirrorMesh.add(groundMirror); mirrorMesh.rotateX(-Math.PI / 2); scene.add(mirrorMesh); THREE.ShaderLib['mirror'] = { uniforms: { mirrorColor: { type: 'c', value: new THREE.Color(0x7F7F7F) }, mirrorSampler: {type: 't', value: null}, textureMatrix: {type: 'm4', value: new THREE.Matrix4()} }, vertexShader: [ 'uniform mat4 textureMatrix;', 'varying vec4 mirrorCoord;', 'void main() {', 'vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);', 'vec4 worldPosition = modelMatrix * vec4(position, 1.0);', 'mirrorCoord = textureMatrix * worldPosition;', 'gl_Position = projectionMatrix * mvPosition;', '}' ].join(''\\n), fragmentShader: [ 'uniform vec3 mirrorColor;', 'uniform sampler2D mirrorSampler;', 'varying vec4 mirrorCoord;', 'float blendOverlay(float base, float blend){', 'return (base \u0026lt; 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)));', '}', 'void main(){', 'vec4 color = texture2DProj(mirrorSampler, mirrorCoord);', 'color = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, mirrorColor.b), 1.0);', 'gl_FragColor = color;', '}' ].join('\\n') }; 文字 # 介绍 原理: 每个要显示的文字生成mesh 小地图 # 介绍 实现方式1, 在天空直接用正投影相机 # 实现简单,但渲染效果差,占很多cpu时间(重新绘制一次整个场景) 实现方式2, 用正投影相机, 但用画大地图的数据来绘制 # 小地图渲染用很少时间, 因为复杂模型都用小方块或图片代替了 o-\u0026gt; 实现 camera.lookAt(scene.position); camera2.lookA(scene.position); renderer2 = new THREE.CanvasRenderer(); # 两个WebGLRenderer位置重叠时,会渲染不正常(其中一个全黑) renderer2.setSize(200, 150); renderer.render(scene, camera); renderer2.render(scene, camera2); "},{"id":23,"href":"/docs/middleware/library_frontend/angular/","title":"Angular","section":"前端","content":" 介绍 # google发布 提倡SPA(Single Page Apps), 运行快，一次加载 mvvm 特点 # 前端mvc 双向数据绑定 指令和语义化标签 模块化工具 依赖注入 html模板 常用工具封装，如$http $cookies $location directive # 内置 ng-app # 声明app名, 在最外层 ng-submit # \u0026lt;form ng-submit=\u0026quot;submit()\u0026quot;\u0026gt; ng-controller ng-repeat # $index返回当前引用的元素序号，$first, $middle, $last 返回布尔值 ng-model # 绑定当前元素的值 ng-click ng-eventhandler=\u0026quot;expression\u0026quot;类的指令可以在所有浏览器中有相同的行为，angular将会屏蔽差异性 不会在全局命名空间中进行操作，指定的表达式只能访问元素控制器作用域范围内的函数和数据 ng-bind ng-change \u0026lt;form ng-submit=\u0026quot;aaFunc()\u0026quot;\u0026gt; # 会阻止浏览器默认的提交操作 ng-dblclick ng-show ng-hide ng-class # 可以是类名字符串，空格分隔，可以是类名数组，可以是类名到布尔值的映射 ng-class=\u0026quot;{true: 'active', false: 'inactive'}[isActive]\u0026quot; ng-class=\u0026quot;{'selected': isSelected, 'car': isCar}\u0026quot; ng-style # templete中写css不好维护 ng-src=\u0026quot;/images/cats/{{favoriteCat}}\u0026quot; # src，href属性中简单使用templete,由于浏览器优先并行加载图片和其它内容,angular没有机会拦截到数据绑定请求，所以无法运行 ng-href ng-options \u0026lt;select ng-model=\u0026quot;x\u0026quot; ng-options=\u0026quot;(m.a + ' - ' + m.b) group by m.c for (key, m) in opts\u0026quot;\u0026gt; 自定义 angular.module('CAT.TryDrt', []) .directive('hello', function(){ return { restrict: 'E', # E: element, A:attribute, C:class, M: comment template: '\u0026lt;div\u0026gt;Hello world\u0026lt;/div\u0026gt;', # 标签内容 replace: true # 表示替换原标签 } }); \u0026lt;hello\u0026gt;\u0026lt;/hello\u0026gt; controller # 使用 通过ng-controller router中绑定到动态加载的dom模板片段上 作用 初始化页面状态 通过$scope对象暴露数据模型给视图 监视模型变化，并采取相应动作 嵌套 原理是$scope的继承 templete # 使用范围 页面中 value、class、style属性 表达式 # 自定义的解释器而非eval执行 + - * / % == != \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= \u0026amp;\u0026amp; || ! \\^ \u0026amp; | $scope中暴露的函数 # 但不是视图的职责，也不利于测试 {} [] filter 使用 expression | filterName : parameter1 : parameter2 : ... 可以多次过滤, 11.2 | currency | number:0 会显示$11 currency # 数字过滤成美元 date number uppercase 自定义 homeModule.filter('titleCase', function(){ var titleCaseFilter = function (input){ var words = input.split(' '); for(var i = 0; i \u0026lt; words.length; i++){ words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1); } return words.join(' '); }; return titleCaseFilter; }) {{pageHeading | titleCase}} module # api angular module('todoApp', []) # 数组中传入依赖的外部模块名 controller('TodoListController', function(){ var todoList = this; todoList.todos = [{a:'a1'},{a:'a2'}]; todoList.addTode = function(){} }); value() service() config() factory('globalInterceptor', GlobalInterceptor) run() angular.ent($('.container')).scope().fetchDept() # 得到element的scope o-\u0026gt; 例子 angular.module('project', ['ngRoute', 'firebase']) .value('fbURL', 'https://ng-projects-list.firebaseio.com/') .service('fbRef', function(fbURL){return new Firebase(fbURL) }) .service('fbAuth', function...) .config(function($routeProvider){ var resolveProjects = { projects: function(Projects){ return ... } }; }) o-\u0026gt; xxxModule.config(function ($routeProvider) { $routeProvider .when('url', {controller: aController, templateUrl: '/path/to/template'}) .when(..) .otherwise(..); }) o-\u0026gt; someModule.config(function($routeProvider){ $routeProvider. when('url', {controller: aController, templateUrl: '/path/to/template'}). when(...) ... otherwise(...) }) 第三方module ngCookies ngAnimate 'ngWebSocket' angularJwt ngclipboard react.name 'flow' # 文件上传 'flowchart' # 流程图 ngTouch 'angular-carousel' # 图片轮换, 可移动端 FBAngular.name # 全屏 ngMaterial # 响应式布局 ngMdIcons # 图标 angularSocialshare # 社交分享 'pascalprecht.translate' # 国际化 'mdColorPicker' # 颜色选择器 'ngMaterialDateRangePicker' # 日期选择器 mdPickers # 日期选择器 ngSanitize # html过滤 vAccordion # 折叠菜单 'dndLists' # 拖拽 mdDataTable # 表格 fixedTableHeader # 表头固定 'material.components.expansionPanels' # 可扩展panel 'mdSteppers' # 步骤图 对象 # 内置 $rootScope # 全局作用域 $scope $scope.$watch 监控属性或函数 $watch(watchFn, watchAction, deepWatch) # angular的表达式(如$scope.xxx)或字符串，函数或表达式，布尔。返回一个函数，用来注销watcher # watch中的函数会翻倍执行，来检测模型中的变更已经被完整地进行了传播。会把所有被监控的属性都复制一份，再与当前值比较，看是否发生了变化。 ## 最多运行10次，如果10次中watchFn的值都发生变化，则可能有循环依赖。 ## Object.observe()会优化这一点，在支持此函数的地方自动使用它。 $watch($scope.totalCart, calculate) # totalCart是函数 $watch('items', calculate) # items是$scope.items数组 $watch(function(){ for($scope.items) $scope.bill.totalCartNum = total; }) # 如果监控多个属性可以 ## 监控这些属性连接起来的表达式 ## deepWatch这些属性的数组 $scope.$apply # 在所有绑定关系都获得刷新，所有变化都反映到了视图上时懒惰调用，angular定时提醒这个服务 # 自主修改dom后，只是在$apply中注册并不调用，如果想马上得到angular双向绑定后的结果，要手动调用$apply # 触发完digest循环后执行回调 $scope.$apply(function () {}) $scope.$digest # 只是触发digest循环 $scope.$digest() 服务 # 内置 $location $log $http $route $routeProvider $urlRouterProvider $stateProvider $locationProvider $timeout $parse var submitHandler = $parse(attrs.ngSubmit)(scope); submitHandler(); $q # node q, 并发控制 $injector # get注入的模块 创建服务 provider # 创建可配置的服务 factory # 创建不可配置的服务 service # 创建不可配置的服务，比较简单 浏览器插件 # Batarang # 调试 "},{"id":24,"href":"/docs/middleware/library_frontend/jquery/","title":"Jquery","section":"前端","content":" 对象命名方式 # var $a = $(\u0026quot;#inputID\u0026quot;); 选择器（选择多个时形成数组） # 基本选择器 $(\u0026quot;#inputID\u0026quot;); # id选择 $(\u0026quot;input\u0026quot;); // 标签名,默认获取第一个 # 标签名选择 $(\u0026quot;.className\u0026quot;); // 按样式名定位 # 样式名选择 $(\u0026quot;#div1ID,.myClass,p\u0026quot;); # 选择多个 $(\u0026quot;*\u0026quot;); # 所有元素 层级选择器 $(\u0026quot;form input\u0026quot;) # form所有后代元素中input元素的个数 $(\u0026quot;form\u0026gt;input\u0026quot;) # form子元素中input元素个数，不包括下层元素 $(\u0026quot;form+input\u0026quot;) # form同级并且下面的第一个input元素 $(\u0026quot;form~input\u0026quot;) # form同级并且下面的所有input元素 子元素选择器 # 只选择一个 $(\u0026quot;ul li:first\u0026quot;) # ul中第一个子元素li $(\u0026quot;ul li:last\u0026quot;) # ul中最后一个子元素li $(\u0026quot;input:not(:checked)\u0026quot;) # input标签中所有未选中的元素 $(\u0026quot;table tr:even\u0026quot;) # 表格的奇数行（索引号为偶数） $(\u0026quot;table tr:odd\u0026quot;) # 表格的偶数行（索引号为奇数） $(\u0026quot;table tr:eq(1)\u0026quot;) # table中索引号等于1的行 $(\u0026quot;table tr:gt(0)\u0026quot;) # table中索引号大于0的行（不包括0） $(\u0026quot;table tr:lt(2)\u0026quot;) # table中索引号小于2的行（不包括2） $(\u0026quot;:header\u0026quot;) # 匹配如 h1, h2, h3之类的标题元素 内容选择器 $(\u0026quot;div:contains('Join')\u0026quot;) # div 标签的html()中包含'Join'字符串的元素 $(\u0026quot;p:empty\u0026quot;) # p 标签的html()的内容为空的元素 $(\u0026quot;div:has(p)\u0026quot;) # div标签中包含p标签的该div标签 $(\u0026quot;p:parent\u0026quot;); # 非空的p标签元素，即p为父元素 可见性选择器 $(\u0026quot;tr:hidden\u0026quot;) # 查找隐藏的tr元素，如\u0026lt;tr style=\u0026quot;display:none\u0026quot;\u0026gt; \u0026lt;td\u0026gt;Value 1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; $(\u0026quot;tr:visible\u0026quot;) # 查找可见的tr元素 属性选择器 $(\u0026quot;div[id]\u0026quot;) # 含有id属性的div元素 $(\u0026quot;input[name='newsletter']\u0026quot;) # 所有name属性是newsletter的input元素 $(\u0026quot;input[name!='newsletter']\u0026quot;) # 所有name属性不是newsletter的input元素 $(\u0026quot;input[name^='news']\u0026quot;) # name以'news'开始的input元素 $(\u0026quot;input[name$='leter']\u0026quot;) # name 以'letter'结尾的input元素 $(\u0026quot;input[name*='news']\u0026quot;) # name包含'news'的input元素 $(\u0026quot;input[id][name$='leter']\u0026quot;) # 含有id属性，并且它的name属性是以\u0026quot;letter\u0026quot;结尾的input 元素 子元素选择器 $(\u0026quot;ul li:first-child\u0026quot;); # 匹配多个ul中的第一个子li元素的li元素集合 $(\u0026quot;ul li:last-child\u0026quot;); # 匹配多个ul中的最后一个子li元素的li元素集合 $(\u0026quot;ul li:nth-child(1)\u0026quot;); # 匹配多个ul中的第一个子li元素的li元素集合,注意：标记从1开始(eq 从0开始) $(\u0026quot;ul li:only-child\u0026quot;); # 匹配多个ul中的只有一个li元素的li元素集合 表单选择器 $(\u0026quot;:input\u0026quot;); # 所有input元素，包括select textarea button等 $(\u0026quot;:text\u0026quot;); # 所有文本框 $(\u0026quot;:password\u0026quot;); # 密码框 $(\u0026quot;:radio\u0026quot;); # 单选框 $(\u0026quot;:checkbox\u0026quot;); # 复选框 $(\u0026quot;:submit\u0026quot;); # 提交按钮 $(\u0026quot;:image\u0026quot;); # 有提交功能的图片 $(\u0026quot;:reset\u0026quot;); # 重置按钮 $(\u0026quot;:button\u0026quot;); # 按钮，包括\u0026lt;button\u0026gt;\u0026lt;/button\u0026gt; $(\u0026quot;:file\u0026quot;); # 文件域 $(\u0026quot;:input:hidden\u0026quot;); # 隐藏域 表单对象属性 $(\u0026quot;:input:enabled\u0026quot;); # 所有可用的input元素 $(\u0026quot;:input:disabled\u0026quot;) # 所有不可用的input元素 $(\u0026quot;:checkbox:checked\u0026quot;); # 所有已选中的checkbox(有checked属性的)元素 $(\u0026quot;:checkbox:not(:checked)\u0026quot;); 未选中的checkbox $(\u0026quot;:select option:selected\u0026quot;); # 所有已选中的option元素 基础函数 # 对象访问 size() # 同length,返回元素个数 length # 同size(),返回元素个数 get(index) # 取得一个匹配的元素,从0开始 each(function(){}); # 遍历调用该方法的元素数组中的元素，其中的this代表循环中的每一个元素 属性 val() # value属性的值，或option元素之间的值 val(\u0026quot;\u0026quot;) # 设置value的值 var([\u0026quot;Multiple2\u0026quot;, \u0026quot;Multiple3\u0026quot;]); # 设置select 下option的值 html() # 相当于innerHTML ,同样不支持xml attr(\u0026quot;\u0026quot;) # 查找属性 attr(\u0026quot;checked\u0026quot;,\u0026quot;checked\u0026quot;) # 设置checked属性的值为\u0026quot;checked\u0026quot; removeAttr(\u0026quot;align\u0026quot;); # 删除属性 样式类（css） addClass(\u0026quot;myClass\u0026quot;); # 添加 css 样式 removeClass(\u0026quot;myClass\u0026quot;); # 删除样式 toggleClass(\u0026quot;myClass\u0026quot;); # 切换样式，有变无，无变有 hasClass(\u0026quot;myClass\u0026quot;) # 返回是否有样式 筛选 # 过滤 eq(index) # 从0开始的第index元素 is(expr) # 判断元素中是否有符合expr的元素（如\u0026quot;form\u0026quot;），有则返回true,无则返回false first() # 第一个元素 last() # 最后一个元素 filter(expr) # 筛选出符合表达式的集合 has(expr) # 保留符合expr的元素，去掉不符合的 not(expr) # 删除符合expr的元素，与has相反 查找 find(\u0026quot;\u0026quot;); # 搜索所有与指定表达式匹配的后代元素 children() # 取得所有直接子元素，不包含后代 next() # 下一个同级兄弟 prev(); # 上一个同级兄弟 parent(\u0026quot;\u0026quot;) # 含着所有匹配元素的唯一父元素 ,可以用选择器筛选 parents(\u0026quot;p\u0026quot;) # $(\u0026quot;span\u0026quot;).parents(\u0026quot;p\u0026quot;) 每个span的所有是p元素的祖先元素 nextAll() # 之后所有同级兄弟 prevAll() # 之前所有同级兄弟 siblings() # 上下的所有同级兄弟 对象处理 replaceWith() # $(\u0026quot;p\u0026quot;).replaceWith(\u0026quot;\u0026lt;b\u0026gt;Paragraph. \u0026lt;/b\u0026gt;\u0026quot;); 替换p节点为自制的粗体节点 remove() # 自己删除自己 clone() # 复制自己 clone(true) 会复制行为 内部插入 append(content) # 元素内部之后添加元素，相当于appendChild() prepend(content) # 元素内部之前添加元素 外部插入 after(content) # 元素同级之后插入 before(content) # 元素同级之前插入 事件函数 # change(fn) # $(\u0026quot;select\u0026quot;).change(function(){}) dom 中的onchange事件，元素内容变化时触发 submit(fn) # $(\u0026quot;form\u0026quot;).submit(function(){}) 选中表单提交时触发，多用于简单检测输入 # 该事件函数中写return false;代表不提交表单 focus(fn) # $(\u0026quot;:text\u0026quot;).focus(); 将光标定位到input text表单中 select(fn) # 选中 如 $(function(){ $(\u0026quot;:text\u0026quot;).select(); $(\u0026quot;:text\u0026quot;).focus(); }) 页面加载时定位光标到input text文本域，并选中其中的文字 mouseover(fn) mouseout(fn) mousemove(function(e){}) # 鼠标移动时执行 ie 中已经定义参数，不用传递，直接用event，event.clientX,event.clientY分别得到鼠标的x,y坐标 keyup(fn) # ie 中 event.keyCode得到按键编码(firefox 中传递参数e,e.which得到按键编码) ready(fn) # $(document).ready(fn) 相当于window.load()事件，但可以写多个 css函数 # css(\u0026quot;background-color\u0026quot;,\u0026quot;red\u0026quot;); # 设置style属性 addClass(\u0026quot;myClass\u0026quot;) # 添加css样式 removeClass(\u0026quot;myClass\u0026quot;) # 删除样式 toggleClass(\u0026quot;myClass\u0026quot;) # 切换样式，有则删除，无则添加 hasClass(\u0026quot;myClass\u0026quot;) # 是否有样式，返回true或false 效果函数 # slideUp(speed,fn) # 向上滑动,如$(\u0026quot;div\u0026quot;).slideUp(200); slideToggle(speed,fn) # 滑上滑下切换,如$(\u0026quot;div\u0026quot;).slideToggle(200); show(speed,fn) # 元素从无到有动画显示出来 hide(speed,fn) # 元素从有到无隐藏起来 toggle(speed,fn) # 有则无，无则有隐藏、显示元素 fadeIn(speed,fn) # 淡入显示图片 fadeOut(speed,fn) # 淡出隐藏图片 animate(styles,speed,easing,callback) # 自定义动画。只有数字值可创建动画（比如 \u0026quot;margin:30px\u0026quot;） 工具函数 # $.trim(str) # 去除str字符串开头和结尾的空白 其它函数 # serialize() # 序列表单内容为字符串 ajax提交表单时可以 var sendData = $(\u0026quot;form\u0026quot;).serialize(); 给sendData赋值传递表单信息 特殊使用 # $(document) # 得到document区 ，可以定义事件，如$(document).mousemove(fn); $(document).ready(fn); 相当于$(fn) $(fn) # 相当于window.load ,在页面加载时执行，可以写多个，（而window.load只能一个生效，后面的会覆盖前面的） $(\u0026quot;\u0026lt;div id='2013'\u0026gt;ss\u0026lt;/idv\u0026gt;\u0026quot;); # 创建一个元素 与dom之间的转换 # var $input = $(inputElemenet); // 注意，没有双引号 var inputElement = $input.get(0); // jquery相当于存储了dom对象的数组 var inputElement = $input[0]; ajax # load(url) # $(\u0026quot;span\u0026quot;).css(\u0026quot;color\u0026quot;,\u0026quot;red\u0026quot;).load(url) 无参以get方式提交，返回的值直接作为\u0026lt;span\u0026gt;标签内的文本节点值 load(url,sendData); # 有参以post的方式提交 ## var sendData = {\u0026quot;username\u0026quot;:\u0026quot;user\u0026quot;,\u0026quot;password\u0026quot;:\u0026quot;psw\u0026quot;}; sendData的内容用json的语法写 load(url,sendData,function(backData,textStatus,ajax){}); # 加上处理返回值的函数,服务器返回数据时调用此函数 ## 其中backData是返回的字符串,textStatus是响应头状态码的值对应的信息（success代表200）,ajax是ajax引擎对象 ## \u0026lt;span\u0026gt;标签的文本节点的值仍会被改变 ## 可以只写一个参数：backData，参数的名字可以任意更改 $.get(url,sendData,function(backData,textStatus,ajax){}); # 用get方式提交ajax模拟的表单 $.post(url,sendData,function(backData,textStatus,ajax){}); # 用post方式提交ajax模拟的表单 响应头 content-type = \u0026quot;application/x-www-form-urlencoded\u0026quot; 会自动设置好 插件 # jquery提供 fixedtableheader tablesort tools ui hashchange 控制浏览器的前进后退到一个页面中(不必刷新) easing jquery的动画扩展, 比如动画执行的速度曲线 代码 icanhaz mustache 功能 fileupload treeview 文件 jquery.treeview.js # treeview插件简化板 jquery.treeview.edit.js # 可编辑的菜单 jquery.treeview.css # treeview可选使用的样式 使用 $(\u0026quot;#root\u0026quot;).treeview({ # $(\u0026quot;#root\u0026quot;)是顶层ul元素 /* 展开还是收起, 默认为false 展开*/ collapsed: true, /* 唯一的, 当前菜单打开的时候其他菜单收缩*/ unique: true, /*动态加载菜单（接收json数据）*/ url: \u0026quot;source.do\u0026quot; }); # 动态加载菜单时接收的数据格式为 [ { \u0026quot;text\u0026quot;: \u0026quot;1. Pre Lunch (120 min)\u0026quot;, \u0026quot;expanded\u0026quot;: true, \u0026quot;classes\u0026quot;: \u0026quot;important\u0026quot;, \u0026quot;children\u0026quot;: [ { \u0026quot;text\u0026quot;: \u0026quot;1.1 The State of the Powerdome (30 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;1.2 The Future of jQuery (30 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;1.2 jQuery UI - A step to richnessy (60 min)\u0026quot; } ] }, { \u0026quot;text\u0026quot;: \u0026quot;2. Lunch (60 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;3. After Lunch (120+ min)\u0026quot;, \u0026quot;children\u0026quot;: [ { \u0026quot;text\u0026quot;: \u0026quot;3.1 jQuery Calendar Success Story (20 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;3.2 jQuery and Ruby Web Frameworks (20 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;3.3 Hey, I Can Do That! (20 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;3.4 Taconite and Form (20 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;3.5 Server-side JavaScript with jQuery and AOLserver (20 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;3.6 The Onion: How to add features without adding features (20 min)\u0026quot;, \u0026quot;id\u0026quot;: \u0026quot;36\u0026quot;, \u0026quot;hasChildren\u0026quot;: true }, { \u0026quot;text\u0026quot;: \u0026quot;3.7 Visualizations with JavaScript and Canvas (20 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;3.8 ActiveDOM (20 min)\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;3.8 Growing jQuery (20 min)\u0026quot; } ] } ] # \u0026quot;expanded\u0026quot;: true 代表这个结点下的child是展开的。 # 返回的json字符串中的双引号必须是双引号。 ## 初次请求时传递数据 root=source,点击节点申请数据时传递id值，如3.6中有id为36，且hasChildren:true,点击后传递36，我们再据此返回相应json数据。 引入css文件，根据其中的样式对页面进行设置 validate 使用 验证写在\u0026lt;head\u0026gt;中时，要写在页面加载中（$(function{})） # 否则读取\u0026lt;head\u0026gt;时，页面还没有加载，没有表单 验证完成触发事件 失败事件：errorPlacement:function(error,element){} # error是错误消息，element是求救消息的js对象 成功事件：success:function(label){} # label是显示消息的js对象 远程验证：发送ajax请求到指定url # 自动传递验证名与验证值，ie中get请求调用浏览器缓存，所以用户回退字符时不提交。所以用post方式发送请求 ## 返回\u0026quot;true\u0026quot;表示成功，\u0026quot;false\u0026quot;表示失败 remote:{ url:\u0026quot;/outrun/servlet/JqueryValidateServlet\u0026quot;, type:\u0026quot;post\u0026quot; } 简单例子： $(\u0026quot;form\u0026quot;).validate({ debug:true, rules:{ name:{ required:true, rangelength:[6,12] }, }, messages:{ name:{ required:\u0026quot;用户名必填\u0026quot;, rangelength:$.format(\u0026quot;用户名长度必须在{0}-{1}之间\u0026quot;) }, } }); 兼容： 不同validate验证框架要求不同的jquery版本 validate1.5.2配jquery1.3 经验 默认情况是丢失焦点验证,如果验证失败则 在失败的文本框每次输入数据都会触发onkeyup 设置 onkeyup:false 样式 默认是class=\u0026quot;error\u0026quot;的样式，可以在页面中自定义.error{}样式取代，但是这样除了出错信息的样式修改外，用户输入信息的样式也会修改 错误信息是以添加\u0026lt;label\u0026gt;标签的形式显示的，所以可以添加\u0026lt;label\u0026gt;标签的样式，如form label{} acccordion 下拉菜单 autocomplete 自动补全(用索引库) password Vlidation 密码强度 prettdate 日期插件 message 消息框 报表 highcharts jscharts am charts 对象与属性 对象 # 静态创建 AmCharts.AmSerialChart() 序列图 属性 dataProvider 数据 # 接收json数据 categoryAxis 横坐标 属性 labelRotation 横坐标显示名角度 gridPosition 网格的起始位置,\u0026quot;start\u0026quot;表示开始处 dashLength 值为数字，网格中垂直线虚线程度 ，0代表实线 categoryField 横坐标显示名(dataProvider数据中的字段名) depth3D 3D图形深度 angle 3D图形角度(左上俯角) creditsPosition 未购买之前的商标位置，如\u0026quot;top-right\u0026quot;表示右上。 方法 write(\u0026quot;chartdiv\u0026quot;) # 要绘图div的id属性值 AmCharts.AmPieChart() 饼图 AmCharts.AmSerialChart() 雷达图 AmCharts.AmXYChart() 离散图 AmCharts.AmLegend() 图例 AmCharts.ValueAxis() 纵坐标 # 通过 AmCharts对象中图对象的addValueAxis()方法给图添加本属性 属性 title 纵坐标标题 dashLength 值为数字，网格中水平线虚线程度 ，0代表实线 AmCharts.AmGraph() 图形 # 通过 AmCharts对象中图对象的addGraph()方法给图添加本属性 属性 colorField 值为dataProvider提供数据中的字段名，表示数据在报表中的颜色 valueField 值为dataProvider提供数据中的字段名，表示占有数值的多少 balloonText 鼠标悬停时气球中的内容，用[[value]], [[description]], [[percents]], [[open]], [[category]] 等标记来引用数据 也可以用html标签，如： \u0026quot;\u0026lt;span style='font-size:14px'\u0026gt;[[category]]: \u0026lt;b\u0026gt;[[value]]\u0026lt;/b\u0026gt;\u0026lt;/span\u0026gt;\u0026quot; lineAlpha 0或1，代表数据图形是否有边界 fillAlpha 代表数据图形是否透明，0为透明 AmSerialChart中AGraph的属性 type 数据图形的形状，如\u0026quot;column\u0026quot;代表方块柱状图 AmCharts.ChartCursor() 光标 # 通过 AmCharts对象中图对象的addChartCursor()方法给图添加本属性 属性 cursorAlpha 0或1，是否显示鼠标跟随线 zoomable true或false 是否可以用鼠标选中来放大 categoryBalloonEnabled true或false 是否跟随鼠标显示横坐标种类名 方法2 # 动态创建 AmCharts.makeChart(\u0026quot;\u0026quot; , json); 参数1 : 要产生图形的div的id 参数2 : json格式的产生条件 type : 图形类型，如\u0026quot;pie\u0026quot; dataProvider : 图形数据 titleField : 需要显示的种类名对应在dataProvider中的字段名 valueField : 需要显示的权重对应在dataProvider中的字段名 legend : json数据，图例的产生条件 align : 对齐条件，如\u0026quot;center\u0026quot; markerType : 图例的形状，如\u0026quot;circle\u0026quot; 使用1 var chart; var chartData = [ { \u0026quot;country\u0026quot; : \u0026quot;USA\u0026quot;, \u0026quot;visits\u0026quot; : 4025, \u0026quot;color\u0026quot; : \u0026quot;#FF0F00\u0026quot; }, { \u0026quot;country\u0026quot; : \u0026quot;China\u0026quot;, \u0026quot;visits\u0026quot; : 1882, \u0026quot;color\u0026quot; : \u0026quot;#FF6600\u0026quot; } ]; AmCharts.ready(function() { // SERIAL CHART chart = new AmCharts.AmSerialChart(); chart.dataProvider = chartData; chart.categoryField = \u0026quot;country\u0026quot;; // the following two lines makes chart 3D chart.depth3D = 20; chart.angle = 30; // AXES // category var categoryAxis = chart.categoryAxis; categoryAxis.labelRotation = 0; categoryAxis.gridPosition = \u0026quot;start\u0026quot;; // value var valueAxis = new AmCharts.ValueAxis(); valueAxis.title = \u0026quot;Visitors\u0026quot;; chart.addValueAxis(valueAxis); // GRAPH var graph = new AmCharts.AmGraph(); graph.valueField = \u0026quot;visits\u0026quot;; graph.colorField = \u0026quot;color\u0026quot;; graph.balloonText = \u0026quot;\u0026lt;span style='font-size:14px'\u0026gt;[[category]]: \u0026lt;b\u0026gt;[[value]]\u0026lt;/b\u0026gt;\u0026lt;/span\u0026gt;\u0026quot;; graph.type = \u0026quot;column\u0026quot;; graph.lineAlpha = 0; graph.fillAlphas = 1; chart.addGraph(graph); // CURSOR var chartCursor = new AmCharts.ChartCursor(); chartCursor.cursorAlpha = 0; chartCursor.zoomable = false; chartCursor.categoryBalloonEnabled = false; chart.addChartCursor(chartCursor); chart.creditsPosition = \u0026quot;top-right\u0026quot;; // WRITE chart.write(\u0026quot;chartdiv\u0026quot;); }); 使用2 AmCharts.makeChart(\u0026quot;chartdiv\u0026quot;, { type: \u0026quot;pie\u0026quot;, dataProvider: [{ \u0026quot;country\u0026quot;: \u0026quot;Czech Republic\u0026quot;, \u0026quot;litres\u0026quot;: 156.9 }, { \u0026quot;country\u0026quot;: \u0026quot;Ireland\u0026quot;, \u0026quot;litres\u0026quot;: 131.1 }, { \u0026quot;country\u0026quot;: \u0026quot;Germany\u0026quot;, \u0026quot;litres\u0026quot;: 115.8 }, { \u0026quot;country\u0026quot;: \u0026quot;Australia\u0026quot;, \u0026quot;litres\u0026quot;: 109.9 }, { \u0026quot;country\u0026quot;: \u0026quot;Austria\u0026quot;, \u0026quot;litres\u0026quot;: 108.3 }, { \u0026quot;country\u0026quot;: \u0026quot;UK\u0026quot;, \u0026quot;litres\u0026quot;: 65 }, { \u0026quot;country\u0026quot;: \u0026quot;Belgium\u0026quot;, \u0026quot;litres\u0026quot;: 50 }], titleField: \u0026quot;country\u0026quot;, valueField: \u0026quot;litres\u0026quot;, balloonText: \u0026quot;[[title]]\u0026lt;br\u0026gt;\u0026lt;span style='font-size:14px'\u0026gt;\u0026lt;b\u0026gt;[[value]]\u0026lt;/b\u0026gt; ([[percents]]%)\u0026lt;/span\u0026gt;\u0026quot;, legend: { align: \u0026quot;center\u0026quot;, markerType: \u0026quot;circle\u0026quot; } }); 习惯 # 命名方式规律 jquery.插件名.功能名.js 存储 网站js/下 分子文件夹存放不同插件的文件 自定义 # 函数 jQuery.extend(object); # 直接调用 jQuery.fn.extend(object); # 对象调用 $.extend($.fn,{})或$fn.extend({}) 例子 $.extend({ max : function(a, b) { return a \u0026gt; b ? a : b; }, min : function(a, b) { return a \u0026lt; b ? a : b; } }); $.fn.extend({ max1 : function(a, b) { return a \u0026gt; b ? a : b; } }); $.extend($.fn, { min1 : function(a, b) { return a \u0026lt; b ? a : b; } }) alert($.max(1, 2)); alert($(\u0026quot;html\u0026quot;).max1(2, 1)); alert($(\u0026quot;html\u0026quot;).min1(1, 2)); 问题 # 页面中引用jquery 只能用\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;的形式，而不能用\u0026lt;script/\u0026gt;的形式 引用的src必须写相对路径 引用的\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;代码必须写在使用之前 webroot/web-inf/不能用相对路径访问webRoot/下的文件，所以不能包含jquery文件。所以要用${pageContext.request.contextPath}/来访问 jquery mobile # "},{"id":25,"href":"/docs/middleware/library_frontend/react/","title":"React","section":"前端","content":" 介绍 # facebook推出的用于build user interfaces 的类库 使用 # o-\u0026gt; webpack # webpack.config.js var webpack = require('webpack') module.exports = { devtool: 'inline-source-map', entry: ['webpack/hot/dev-server', __dirname + '/app/main.js'], output: { path: __dirname + '/build', filename: 'bundle.js' }, module: { loaders: [ { test: /\\.(js|jsx)$/, exclude: /node_modules/, loader: 'babel-loader', } ] }, plugins: [ new webpack.HotModuleReplacementPlugin(), new webpack.DefinePlugin({ 'process.env': { NODE_ENV: JSON.stringify('production') } }) ], devServer: { contentBase: __dirname + '/build', historyApiFallback: true, inline: true, port: 3031, } } # index.html \u0026lt;div id=\u0026quot;content\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026quot;bundle.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; o-\u0026gt; browser # index.html \u0026lt;script src=\u0026quot;build/react.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;build/react-dom.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;browser.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026quot;example\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026quot;text/babel\u0026quot;\u0026gt; ReactDOM.render( \u0026lt;h1\u0026gt;Hello\u0026lt;/h1\u0026gt; document.getElementById('example') ) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; api # ReactDOM render render( \u0026lt;h1\u0026gt;Hello\u0026lt;/h1\u0026gt; document.getElementById('example') ) React # createClass createClass({ getInitialState () {return {liked: false}}, handleClick(event) { this.setState({liked: !this.state.liked}) }, getDefaultProps () { # 设定属性默认值 return {title: 'Hello'} }, propTypes: { # 限定属性的类型 title: React.PropTypes.string,isRequired }, render () {return \u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt;} }) # createElement createElement('h1', {title: 'a'}, 'b') # Component class List extends React.Component{ constructor() {super()} render() {return ()} } this # 代表当前标签 props # 属性 children # 代表所有子节点的text # 没有子节点, 是undefined, 有一个子节点, 是Object, 多个子节点是array # React.Children来处理children refs # 获取dom state jsx 介绍 \u0026lt; 开头解析为html, { 开头解析为js 例子 # Profile.jsx import React from 'react'; export default Class Profile extends React.Component { constructor (props) { super(props) this.state = { list: [1,2,3], activeIndex: -1 } }, activate (index) { this.setState({activeIndex: index}) }, render () { const {list, activeIndex} = this.state const lis = list.map((item, index) =\u0026gt; { const cls = index === activeIndex ? 'active' : '' return ( \u0026lt;li key={index} className={cls} onClick={() =\u0026gt; this.activate(index)}\u0026gt;\u0026lt;/li\u0026gt; ) }) return (\u0026lt;ul\u0026gt;{lis}\u0026lt;/ul\u0026gt;) } } o-\u0026gt; \u0026lt;div\u0026gt; {/*注释*/} { names.map((name) =\u0026gt; {return \u0026lt;div\u0026gt;{name}\u0026lt;/div\u0026gt;}) } \u0026lt;/div\u0026gt; o-\u0026gt; ref \u0026lt;input ref=\u0026quot;domNam\u0026quot;\u0026gt; o-\u0026gt; 事件 \u0026lt;p onClick={this.handleClick}\u0026gt; o-\u0026gt; 属性 \u0026lt;Profile {...props} name='a'\u0026gt; # 后面的覆盖前面的 插件 # react-big-calendar 日历 工具 # JSXTransformer # 浏览器中引入，编译jsx https://babeljs.io/repl/ # 在线编译jsx "},{"id":26,"href":"/docs/architect/method/product_plan/","title":"产品规划","section":"Method","content":" 云服务 # 本质 批发转零售 帮助别人成功而成功 产品型转服务型 优势 轻，方便 全 可计算 现象 外包被淘汰 行业 OS of business 功能 产品功能，样板 开发体验，文档 组件收费，容量收费，节省的成本收费 数据直接做决策 分类 service # 基础服务 plugins # 基础服务组合 app # plugins组合 产业互联网 # 供应链 # 为什么 大厂核心 各节点(库存)周转 是什么 资源 -\u0026gt; 渠道 -\u0026gt; 用户 反馈用户真实需求 上游关注制造业 下游关注erp 批量(精), 个性化(敏) 物流, 资金流(现金流), 信息流 库存管理 应对变化(保质期) 求零库存 供应商 评级 物流, 成本 难点 打通 怎么样 成本、利用率 可靠性, 反应力, 柔性(补错) 感知、预测 赋能 重点 按时制造 难点 协调(协议) 步骤 单品上下游延伸 人工智能 # 优化、预测 拟合函数, 高阶微积分, 梯度下降 元宇宙 # 传媒营销 # 媒体 # 场景控制 3CAD character camera control art direction 特效 会场散射光束（博物馆） 雾中焦点的竖光（saber的剑） 画线的光点（最终幻想） 密集的星星，远近缩放，光圈(tree.js官网） 水滴带动整个屏幕的亮度(fate stay night) 蓝色光影交错（fate stay night） 秒针声强调时间(fate stay night) 单帧卡动画渲染气氛(fsn) 黑白画面到彩色画面(madlife 集锦[dream on]) 黑白画面彩色涟漪(冰果) 地面的雾影(fsn) 音乐重节拍时出现隐形单位/人(fsn) 转动的星空光点线加云(fsn结尾) 沙的立体塑型(秦时明月) 红辣椒的分镜 网站效果 图片向下拉，上面模糊小，下面清晰大，有一种震撼感 "},{"id":27,"href":"/docs/architect/manage/organize/people/","title":"人员","section":"组织","content":" 人, 事, 团队 # 人 业内口碑 成分 技能，素质，精神 行动 感性，理性，惯性 发展 上限 下限 成本 低成本召回 事 知原理 是什么，为什么，怎么样，拆解 事与团队 事造就团队，好团队不一定出好成果 团队 存在合理性 有目标，成员能力认可，成员感性认可 小精英团队，才能解决问题 分配事 因特质分配，如稳定，峰值，沟通 成果评价 产出判断 分配利益和荣耀 时间和代码量评价不了程序员的工作, 可以匿名互评(口碑) 团队提升 培训无意义，自觉成长 成员 项目经理 设计 开发 测试人员 运维 系统工程师 设计、实现产品 数据分析师 技术总监 架构师 权衡, 出方案 职工 # 态度 把握分寸 靠谱(事事有交代) 负责(顾全局) 主动 超出预期 负责态度, 提高团队效率，而非自己效率 # 严肃判断 沟通 及早沟通、同步 文档 \u0026gt; 邮件 \u0026gt; im \u0026gt; 电话 # 即时性相反 留响应时间, 同组 -\u0026gt; 跨组 -\u0026gt; 跨部门 -\u0026gt; 跨公司 明确通知人时, 邮件, im特殊指定 文档 周报 文档简单有计划，为节省向别人解释的时间 建设性意见(提选择题) 只交“产品”: 背景清晰, 扼要, 完整, 引入独有经验 工程师 # 本质 解决问题 普遍问题 技能: 工具使用(写工具), 表面学习, 笨办法, 不会读文档, 只会知识迁移 设计: 不知经典设计, 不知设计哲学, 不知目的, 无法反应需求, 没有品位, 读不懂设计 知识更新: 学不动, 基础差(用二手资料), 无认知体系(认为都是新东西), 重复学习无用知识 沟通: 不专业(不用专业名词), 不主动, 不沟通对方, 不抓重点, 思路不连贯, 阅历不足(不会写文档), 不问为什么 能力 特点 知识、经验、技能、协作 # (1+天赋)x知识x工程习惯 犯错(多做多错) 方法 抽象 # 设计就是从升维中拆分和简化 沉淀 # 没有沉淀的学习不好回顾修改, 像没有测试的代码 品位 优点，缺点 # 找潜质, 并非此长彼短，是两个维度,有一定抑制作用 创造力，纪律 勤奋，聪明 稳定，峰值 深度，速度 细节，大局 开发 考虑工作的复用性 加入项目，需要可对所有代码修改 善用工具 自己的事主动跟进 owner 自我负责, 自我驱动, 持续改进 能部署, 能手工排查问题，手工修复数据, 开发调试工具, 数据修复工具 模块职责单一, 明白当前负责和极限性能 能降级, 知道下游调用和降级影响。了解上游依赖和上游降级影响 配好log、监控、告警, 告警及时响应 架构师 # 场景/用例/问题 -\u0026gt; 方案/方案权衡 -\u0026gt; 落地路径 分级 初级 代码 命名：精确性、简单性、一致性、区别性、业务性 逻辑: 缩进、换行 代码体积: 行、方法、类 抽象能力 边界 中级 流量、并发等 高级 理解业务核心价值、业务实现方式 业务技术支撑方式 业务趋势 创始人 # 心态: 平常心 职责: 找到善于解决问题的人，做好善于定义问题的人 艺术家 # 岗位 # 项目经理(pm, project manager) 技术经理(tm, technical manager) 产品设计经理(pdm, product design manager) 运营经理(pom) 测试经理(qam) 客服经理(csm, customer success manager) 开发组长(tl, team leader) 架构师(pa) 开发工程师(de, development engineer) 数据库管理员(dba, database administrator) 系统管理员(sa) 界面设计师(ui, user interface) 用户体验设计师(ue, user experience) 产品运营师(po, product operator) 产品设计师(pd, product designer) 测试工程师(qa, quality assurance) 配置管理员(pcm) 发布员(pb) 软件过程专员(sqa, software quality assurance) 运维工程师(sre, site reliability engineer) 招聘 # 双向选择 精确率\u0026amp;召回率 方面 沟通 喜欢技术，逻辑能力, 编码能力, 设计能力 基本概念, 边界考虑充足, 进阶答案, 衍生问题的解决 是否有自己思考，对自己负责 "},{"id":28,"href":"/docs/architect/method/code_plan/","title":"代码规划","section":"Method","content":" 阻塞 # 阻塞(bio)指cpu等待io 非阻塞(nio)指调用io后立即返回，但要轮询事件状态 # 非阻塞指对cpu不阻塞，但业务线程阻塞 轮询(单线程) read 定时重复调用来检查 select 前后read, 中间select轮询检查文件描述符的事件状态 采用1024长度数组存储状态，只能同时检查1024个文件描述符 poll 前后read, 中间poll 用链表代替数组, 也避免了不必要的检查 epoll # linux 前后read, 中间epoll epoll检查不到事件，休眠epoll线程直到事件将它唤醒 kqueue # freeBSD中，类似epoll aio # async io, linux, 业务线程不阻塞 通过回调(信号)传递数据，不必像epoll线程(业务线程)阻塞等待 仅linux下有, 只O_DIRECT方式读取，不能利用系统缓存 IOCP # windows aio 模拟aio(io线程池) 业务线程的io操作, 起io线程, io线程完成通信到业务线程触发回调 库 glibc(有bug) libeio node.js的libuv封装 linux下自实现 windows下IOCP 事件 # 实现 回调 队列存事件, 单进程检测事件是否回调 库 libevent libev # bug比libevent少 工具 epoll(select, poll) libev(libevent) 并发并行 # 并发 多任务共享时间段, 类比: 任务队列 为什么并发 多任务能力 非阻塞 并行 多任务同时处理, 类比: 多核处理器 为什么并行 提高执行效率 分类 任务并行化 数据并行化 cpu交替任务 # EDSAC串行任务 协作式 # 可能独占，Windows3.1, Mac OS 9 抢占式 # 任务管理器强制中断，Windows95, Mac OS 9以后版本, Unix, Linux 竞态条件 三条件 两个处理共享变量 一个修改中 另一个介入 没有共享 Multics(1969年)进程共享内存 # Multics基于PL/I和汇编编写 UNICS(1970年)进程不共享内存 UNIX10年后，线程共享进程内存 actor模型(1973年), 不共享内存，传递消息，异步 # Erlang, Scala 共享内存但不修改 # haskell所有变量，c++ const变量, scala val变量, java immutable(private属性没有setter) 不介入修改 线程协作式 # ruby的Fibre, python/js的generator 不便介入标志 锁(有线程不检查锁，还是可以进入) # 1965年提出，1974年改良为monitor。加解锁时，要求对锁的检查和修改同时执行 死锁问题 无法组合锁，组合要加新锁 事务内存 # 临时创建版本对其修改，更新失败重新执行 硬件事务内存(1986年硬件安装lisp的LM-2) # 1986年cpu MIPS基于RISC简化指令成功，LM-2商业失败 软件事务内存(1995年论文), 2005年微软concurrent haskell论文 2004年IBM X10, 2006年Sun Fortress, 2007年Clojure, 2010年微软终止.NET软件事务内存 并行代码 编译代码顺序不确定，或执行顺序不确定 看一句代码的内部实现, 在其中执行了行为 go func () { x = make([]int, 10) }() x[9] = 1 业务并行解耦条件(满足幺半群性质) 封闭性 # 业务运算结果是业务 结合律 # 业务a、b的结果后与c执行，等同b、c的结果与a执行 单位元 # 恒等业务a与其它业务b执行，得b, 如reduce的初值 系统应用 并发能力 吞吐量(并行) I/O多路复用(epoll) cpu\u0026quot;多路复用\u0026quot;(进程、线程) cpu机制(多发射、流水线、超标量、超线程) 进程线程应用 cpu对任务的M:N处理 进程切换处理任务 线程(通信，并行) 实现(异步, 并发，并行) 写法 回调(监听器), 链式(promise)，同步(async) 事件处理器 调度方式: 单线程循环 协程 为什么用户实现协程 POSIX线程模型累赘 进程/线程 切换开销大 空间资源占用大 os调度对go模型不合理 go gc需要内存处理一致状态(所有线程停止), os调度时，因gc时间不确定，期间大量线程停止工作 # go调度器知道什么时候内存处于一致性状态(只需正在核上运行线程) 本质 用户态，寄存器+栈, 让出(协作而非抢占) 调度方式(线程模型) N:1 # N个用户空间线程运行在1个内核空间线程 上下文切换快 无法利用多核 1:1 # POSIX(pthread), java 利用多核 上下文切换慢，每次调度都在用户态和内核态间切换 M:N 任意内核模型管理任意goroutine 调度复杂性大 go M(machine)代表内核线程 G(goroutine)有自己的栈，程序计数器，调度信息(如正阻塞的channel) P(processor)调度上下文, $GOMAXPROCS设置数量 P中有G队列(runqueue, 队尾添加新G) 当前运行一个G, 到调度点时，队列弹出另一个G P周期检查全局G队列防止其中G饿死 P运行完，全局G队列拉取G P运行完，全局G队列空，从其它P拉取一半G P运行在M, M阻塞时P移到其它M, 阻塞M中保留阻塞的G 调度器创建足够多M跑P 阻塞M中G的syscall返回, M尝试偷一个P 没得到P时, 它的G加入全局G队列, M进线池睡眠 概念 过度竞争 过多线程尝试同时使用一个共享资源 同步 # 直接相互制约 实现 同步原语(如通道、锁)作用时，会刷处理器缓存到内存并提交，保证可见性 互斥 # 间接相互制约 竞态条件(race condition) 临界区 # 只能一线程访问的代码，如lock了的代码 监控模式 # 互斥锁, 函数, 变量 组合出临界区的模式, 使用了代理人(broker)(指锁) 异步 # 与同步相对。多线程是实现异步的一种手段 可见性 线程总可见到最后修改的数据, 脏读是反例 原子性 查看和修改同时发生 乱序执行 # java 中标记volatile的变量可以不乱序执行, 现多用原子变量 编译器或JVM的静态优化可以打乱代码执行顺序(java) 硬件可以通过乱序执行来优化性 死锁 # 多线程竞争资源而互相等待 条件 互斥 # 资源排他 不剥夺 # 资源不被外力剥夺 请求和保持条件 # 线程已保持一个资源，请求新资源。请求被阻塞而自己资源保持 循环等待 # 阻塞线程形成环 方案 锁按顺序获得 # a,b,c锁，要得c手中要有a, b # 使用锁的地方比较零散时，遵守此顺序变得不实际 # 可以用对象散列值作全局顺序减小死锁机率 阻塞加时限 # 外星方法中可能包含另一把锁，要避免在持锁时调用外星方法 活锁 # 多线程尝试绕开死锁而过分同步反复冲突 多线程 # 线程池 作用 重复利用, 降低资源消耗 提高响应速度，不等线程创建 可管理，线程是稀缺资源，统一分配，调优和监控，提高系统稳定性 锁 # 锁 公平锁 # FIFO取锁 非公平锁 # 每次直接占有 互斥锁(mutex) # 访问前加锁，访问后解锁 悲观锁 # 假设最坏，等所有线程释放成功 读加锁 乐观锁 # 假设最好，有冲突时重试 读不加锁，写时判断数据版本是否修改，再重试 读写锁(rwlock) # 竞争不激烈比互斥锁慢 读锁(共享锁) 写锁(互斥锁) 状态 读加锁状态 可多个线程占用 处理器缓存提交，数据可见 阻塞写线程 # 导致写线程抢占不到资源，所以有写线程时，阻塞后进入的读线程 写加锁状态 一次只有一个线程占用 阻塞所有线程 不加锁状态 自旋锁 spinlock 互斥锁改，自己进入循环等待状态(忙等) # 适合锁持有时间较短 RCU锁 Read-Copy Update 读写锁改，一个写线程，读线程无限制 实现垃圾回收器 写线程copy副本修改，向垃圾回收器注册callback以执行真正的修改 垃圾回收器收到信号，所有读线程结束，执行callback 可重入锁 # 互斥锁改，允许同一线程多次获得写锁 管程(monitor) 临界区(critical section) 内置锁、显示锁 # 指java的synchronized与Reentrantlock 信号量 进程, 线程间通知状态 CAS # # compare and swap，无锁算法(lock free), 非阻塞(non-blocking), 构成基本的乐观锁 # cpu实现的指令 3个操作数 # V的值为A时，原子更新成B，否则无操作。返回V的值 需要读写的内存位置V 进行比较的值A 拟写入的新值B 函数式 # 介绍 消除可变状态 概念 命令式语言中，求值顺序与源码的语句顺序紧密相关(有可能乱序执行) 函数式程序并不描述\u0026quot;如何求值以得到结果\u0026quot;，而是描述\u0026quot;结果应当是什么样的\u0026quot;。函数式编程中，如何安排求值顺序相对自由 引用透明性 # 任何调用函数的地方，都可以用函数运行结果来替换函数调用，而不会产生副作用 数据流式编程(dataflow programming) # (+ (+ 1 2) (+ 3 4))就是一个数据流，所有函数都可以用时执行 future模型 分离标识与状态 # 介绍 Clojure, 指令式编程和函数式编程混搭 clojure四种并发模型 vars (thread-local) atoms原子变量 agent代理 refs引用 与 ATM软件事务内存 actor模型 # 介绍 作为actor自己修改自己的数据，对外提供消息，处理对外消息 共享内存模型和分布式内存模型，适合解决地理分布型问题，强大的容错性 基于消息传递，侧重通道两端实体 每个actor有一个mailbox, mailbox中转消息 csp # 介绍 通信顺序进程(communicating sequential processes) 基于消息传递，侧重信息通道 数据级并行 # # 不可变数据, 观测不可变、实现不可变 lambda架构 # 介绍 综合MapReduce和流式处理的特点，处理大数据问题的架构 状态保持 # cookie 分域名, 客户端保存服务器定义数据, 请求时发送 session 服务器id数据，id下发到客户端 共享 # 同时多方案，动态切换 zookeeper切换环境变量与重启 # java中filter重写request getSession webSphere或JBoss可配置session复制或共享 # 不好扩展和移植 加密存cookie 服务 redis memorycache gemfire # 12306 认证 # 单点登录 sessionID存cookie, cookie禁用存头域 token 类型 access token # 标识唯一用户 user_id issue_time # token发放时间，单位秒 ttl # 有效时间，uint16,单位分钟 mask # int128, 按bit分组用户，用于批量封禁或其它功能 refresh token # 用来换access token，与access token同时发放 # 过期时间更长 实现 redis存储 token不要太长 常见问题 # CSRF # 介绍 跨域请求伪造(cross-site request forgery) client登录A, 本地生成cookie client登录B, B给执行js，带参数请求站点A 解决 token验证 # 加入自定义头域 验证Referer头域 XSS # 介绍 跨站脚本攻击(cross-site scripting, 易和css混淆，所以写成XSS), 渲染页面时脚本未转义 XSF # 介绍 跨站flash攻击(cross-site flash), actionScript加载第三方flash sql注入 # 介绍 拼装sql，参数插入sql逻辑 解决 sql预编译 1+N查询 # 介绍 先查出外键id集合, 再逐条id查关联表。orm易出的问题 解决 用 id IN (1,2,3) commit前自动合并sql 业务场景 # 关注/信箱 # 要求 user人数10w, 活跃1w。 大部分user关注1k人, 一部分大v被关注100w人。 每人每天发100条博文 user新博文数量提醒，消息标记已读 表 user user_followers user_followed user_posts(u_id, created_ts) user_messages(u_id, p_id, is_read) # 10w * 100条数据 / 天 定时任务拉取 user_followed拉u_id, user_posts表按时段拉id, 更新user_messages 优点 平均, 少次, 增量。 缺点 及时性中 每次对所有用户操作 数据 10w*1k*100条数据 / 天 发布时推送 有p_id, user_followers, 更新user_messages 优点 及时性高 缺点 计算集中, 可能高峰 数据 最高 100w*100条数据 / 次 10w*100次 / 天 messages处理 存部分messages 不活跃user不存message 在登录状态，定时拉取 优点 减少message 缺点 计算集中 数据 1k * N(N\u0026lt;100)条 / 次 1w * 1k * 100条数据 / 天 messages结构变化 u_id: [{p_id: uint, is_read: bool}] # 条数稳定为10w 用mongodb或redis 消息队列? 服务端存message状态，不能mq 如果客户端存状态，这就是个简单的mq问题 轻应用架构 # node.js + mongodb mysql 数据 # 数据迁移 # 去掉约束 排序（中断继续） 数据存储 # 缓存 queue + map # queue存储、限量, map查询，指向queue中元素 缓存 # queue + map # queue存储、限量, map查询，指向queue中元素 实时并发 # 异步方案 # node.js + mongodb tornado + celery + rabbitmq + 优先级 quartz 消息 # 功能 好友 单聊, 群聊 语音, 视频 im # 浏览器聊天(tcp, 不https) 协议 XMPP # 基于xml MQTT # 简单，但自己实现好友、群组 SIP # 复杂 私有协议 # 工作量大，扩展性差 go高并发实时消息推送 # 问题 长连接 # 支持多种协议(http、tcp) server push HTTP long polling(keep-alive) 基于TCP自定义 心跳侦测 高并发 #\u0026gt;= 10,000,000 C1000K 多种发送方式 单播: 点对点聊天 多播: 定点推送 广播: 全网推送 持久/非持久 准实时 # 200ms ~ 2s gc卡顿是大问题 客户端多样性 同帐号多端接入 网络变化 电信、联通切换 wifi, 4g, 3g 断线、重连、断线、重连 系统架构 组件 room # 接入客户端 分布式全对称 一个client一个goroutine 每个server一个channel存消息队列 book记录user与server映射 统一http server收消息并将消息路由到room和server manager掌控room的服务：内部单播、多播、广播 admin负责room进程管理 center # 运营人员从后台接入 提供操纵接口给应用服务器调用 restful 长时操作，有任务概念来管理 提供统计接口 register # room和center注册 key-value的map，value是struct 记录用户连到哪个room 记录在线时长等信息 hash算法定位register进程 不直接用redis是为了添加业务逻辑 saver # room和center调用 # 使用redis 分布式全对称 提供存储接口 采用encoding/gob编码格式的rpc idgenerator # saver和center调用 全局消息id生成器, int64 分布式，每个进程负责一块id区域 后台goroutine每隔一秒写一次磁盘，记录当前id 启动时跳过一段id，防止一秒内未写入磁盘的id重复生成 存储 redis 存核心数据 db_users: zset, 存各产品用户集合 db_slots: list, 存用户离线消息队列 db_buckets: dict, 存消息id -\u0026gt; 消息体 数据 16机器，标配24硬件线程, 64g内存 linux kernel 2.6.32 x86_64 单机80万并发连接 load 0.2 ~ 0.4 cpu 总使用率7%~10% 内存占用20g 目前接入1280万在线用户 2分钟一次gc, 停顿2秒，tip上提供了并行gc 15亿个心跳包/天 持续运行一个月无异常 直播 # 《关于直播，所有的技术细节都在这里了》 游戏 # 进程 gateway进程组 # 对外api function进程组 # 注册玩家全局信息 session进程组 # 玩家状态 dbserver进程组 # 数据 多word进程组 # 不同地图的信息、逻辑 "},{"id":29,"href":"/docs/basic/speach/","title":"演说","section":"基本功","content":" 要素 # 环境的设计 安全 规模小 改变被动传输为主动接受 交互、提问与思考 团队、竞争、奖励 控制场面 引导 "},{"id":30,"href":"/docs/architect/manage/organize/","title":"组织","section":"Manage","content":" 组织 # 系统划分与组织划分 康威定律 系统架构是公司组织架构的反映 按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本 沟通出现问题，考虑调整组织架构 在该拆分时拆分 为了简单 开发和运维分离 业务和基础架构分离 无状态和有状态分离 业务间乘法(正交)而非加法 # 升维的特点, 正交叠加 多层抽象, 不断隐去底层(约定大于配置) # 升维的特点, 抽象观察 管理 # 责任 # 提供 问题: 定义, 分解, 什么是问题, 前人如何处理 # 工程为解决问题 思考: 方向, 为了解决问题, 找到关键, 找到应学知识 # 创造性工作要思考 体系: 领域的体系, 领域体系形成原因, 为了高效思考和学习, 有体系的做事 参考: 参考书籍, 如何筛选, 如何搜索, 社区 不提供 知识点, 答案, 规定, 代码 分任务 出问题，写相关文档 砸需求，看弹性 任务列表: 难度, 优先级, 排期, 地平线目标, 现状, wishlist nice to have给新人 方法 # 人员 TeamLeader -\u0026gt; Owner 需求磨砺核心业务资产(事情成就精英团队，而非精英团队成就事) 问题定义 完成不动点需求 正交、简单(要求想清楚、灵活) 维护概念完整性、一致性(纯洁) 术语不变、不矛盾、不重叠 考虑上下游 代码问题 问题原因：开发的碎片化(重复的代码、由于不知道或怕改错) 解决方法 代码Review，集体评审 持续集成(*lint, CI/CD): 早合并、自动构建、测试 问题管理 需求池 优先级、排期、checklist、周update 文档知识库(Confluence, Notion) 问题追踪（Jira) 迭代(周冲刺, hackson) 产出评估角度 口碑、解决问题。 良心，内驱力 Owner, 鼓励设计、技术自由(开发人员诉求技术，厌倦业务) 效率第一: 加班是能力问题 时间，代码量 犯错问题: 总会犯错，多做多错 不能赶期，不怕delay 制度 # 模型 # 开发模型 # TDD(test-driven development) 先单元测试 BDD(behavior-driven development) TDD的变种, 重点描述行为 面向需求 组织上小而全 开发全栈减少沟通 设计上面向领域 迭代模型 # 极限编程（XP） # eXtreme Programming 4大价值 沟通：鼓励口头沟通，提高效率 简单：够用就好 反馈：及时反馈、通知相关人 勇气：拥抱变化，敢于重构 5个原则 快速反馈 简单性假设 逐步修改 提倡更改（小步快跑） 优质工作（质量是前提） 5个工作 阶段性冲刺 冲刺计划会议 每日站立会议 冲刺后review 回顾会议 结对编程 PDCA循环质量管理 Plan, Do, Check, Act FMEA 分析潜在的失效模式 工程模型 # 历史 程序设计阶段1946-1955 节省空间 软件设计阶段1956-1970 硬件发展，软件危机 软件工程阶段1970-今 组件化 瀑布模型 # # 每一次执行工作流的深度不同 可行性分析 实现会不会复杂，尽量简单 需求分析 分类 生存点 痒点 兴奋点 # 不会按时交付（只完成主要，然后延期，用户测试） 客户沟通，同类产品比较，行业标准 功能 正确, 可行, 必要, 有序, 明确, 一致 性能 完善, 简短 设计 先出成果再优化 任务分配(进度条) 命名标准 文档 可移植、可维护易扩展 排期 实现 测试 运维 螺旋模型 # # 边分析边开发边交付（一环一环向目标实现） 敏捷开发 项目面临的问题 人员流动 代码维护 种类 极限编程(xp) 特点 简易、交流、回馈 方法 解耦低速设备，提高响应速度 迭代 迭代周期 一个迭代周期中不新添加需求 一个迭代周期中包含多次迭代 一个阶段的结束称之为里程碑 初始化阶段增量 项目启动 建立业务模型 定义业务问题域 找出主要风险因素 定义项目需求的外延 创建业务问题域的相关说明文档 细代阶段增量 高层的分析与设计 建立项目的基础框架 监督主要的风险因素 制订达成项目目标的创建计划 构建阶段增量 代码及功能的实现 移交阶段增量 向用户发布产品 beta测试(alpha测试是内部测试， beta测试是用户测试) 执行性能调优，用户培训和接收测试 转型 # 流程 (2-4)周实地调研痛点 确定目标 要求: 领先、高效、高品质 列出实际问题 评估 cmmi(敏捷成熟度模型): 代码、架构、工具 实施变化 战略 试点团队(灰部应用于组织): 完成产品指标 工具功能 # 控制面板 项目 分配给我 活动日志 人员 团队 权限 项目 配置 事务 类型 布局 # 列表项，详细项 时间追踪 配置链接关系 优先级 解决方案 工作流 # 对不同项目和事务类型, 配置状态转换图 页面方案 # 对不同项目和事务类型，不同状态转换时，配置字段布局 自定义字段 # 对不同页面 权限 权限 角色、应用程序、组、用户、项目负责人、当前经办人、自定义字段值等 事务(issue) 状态 todo, 正在进行, done 打开, 已重新打开, 已解决, 已关闭 backlog, in review, selected for development, building, build broken waiting for support, respond to customer, escalate, cancel, canceled, done waiting for approval, work in progress [工作流状态] 类别 待办 正在进行 完成 无类别 名称 长篇故事(史诗) 故事 分类: 需求, 设计 验收条件 任务, 子任务, 缺陷, 新增功能, 改进 服务请求, 服务请求审批, 问题, 事件(系统中断) 订单 全局顺序 属性 经办人，报告人 优先级 highest, hign, medium, low, lowest 链接 clones is cloned by duplicates is duplicated by blocks is blocked by causes is caused by relates to csv导入 筛选器 未清, 我发起, 已完成, 最近 活动 评论, 历史, 工作日志 冲刺(sprint) 状态 待办, 进行, 完成 发布 版本 报告(report) 敏捷 燃耗图, 燃尽图, 版本报告, 长篇故事报告, 控制图，长篇故事燃尽图, 发布燃尽图 冲刺报告, 速率表 累积流程图 事务 饼图, 单次分组, 解决时间, 平均周期, 事务持续时间, 已创建已解决对比, 最新创建 预测 版本工作量, 人员工作量, 时间跟踪 其它 工作负荷 服务台(itsm) 分类 对内 对外 途径 邮件, 帮助中心, 小程序 队列 分类 状态workflow 经办人 客户 报告 系统 审计日志 "},{"id":31,"href":"/docs/basic/body/","title":"身体","section":"基本功","content":" 造型期 # 体态 高低肩 骨盆前倾 体能 心肺 变速有氧：4、6、8各2min， 30min以上 力量 核心训练 健身计划 # 目标 指导 FITT Frequency: 一周3-5次 Intensity: 有氧 心率: 123-142 无氧 动作 间歇 个数 重量 Time: 60min力量 + 30min有氧 Type: 热身 抗阻力训练 拉伸 阶段 适应期(1-2月) 心肺功能: 功率 核心力量 保护腰：呼吸 + 静态 内脂 力量训练 动作规范 蹲、推、拉、举、旋转 进阶期(2-3月) 消耗 \u0026gt; 摄入 七大肌肉群：胸、肩、背、腹、腿、臀、手臂 三分化、四分化 爆发力 "},{"id":32,"href":"/docs/architect/method/ops_plan/","title":"运维规划","section":"Method","content":" 指标 # 标准 ITIL(IT Infrastructure Library) ITSM(IT System Management) 目标 安全性 账号管理 漏洞修复 安全审计 可用性 服务监控 架构优化 冗余备份 预案演练 故障响应 运维成本 成本核算 服务选型 成本优化 运维效率 研发工作流支持 服务支持平台建设 运维自动化平台建设 工作方式 邮件申请开通 LDAP, VPN, 测试, 线上 监控 # "},{"id":33,"href":"/docs/architect/code/","title":"代码","section":"架构","content":" 人类认知原理 # 原理 模拟执行 负担 概念量 封装粒度大 多态、运行时多态、静态多态 临时状态 用工作流, 而非队列 日志(event)搜索/集中/回放 抽出权限层 非轻量级 胶水层厚 无稳定方案, 复用困难 流程长度 最好 单线程 # 不插入行为 上下文集中 this.scene.commit()集中状态转移时间线 单一方式 软件设计原则 # 统一原则 # 观念 KISS(keep it simple stupid) YAGNI(You Ain’t Gonna Need It) 取好名字占设计一半 约定大于配置 并发的世界，并发的软件 分布式的世界，分布式的软件 不可预测的世界，容错性强的软件 复杂的世界，简单的软件 代码即数据 物体上绑定行为数据 传递代码数据(函数一等公民) 防御性编程 接口前validator 启动时自检断言 异常处理 不可过度 设计 solid原则 单一职则(single responsibility) 一个类负责一个功能 开闭(open/closed) 对扩展开放，对修改关闭，如接口, 如数组扩展结构体状态 里氏替换原则(liskov substitution) 子类继承超类的所有 接口分离(interface segregation) 最小功能隔离 依赖反转(dependency inversion) 低层依赖高层, 具体依赖抽象 非侵入 # non-intrusion 将功能推入代码，而非代码拿到功能 代码实现接口，而非继承类 拆分 边界 正交 unix rules 模块化(modularity) # 模块由精心设计的接口连接 清晰化(clarity) # 可读性、可维护性 组合(composition) 分离(separation) 简单(simplicity) 节俭(parsimony) # 越小越好 透明(transparency) # log, tracing 鲁棒(robustness) 可展示(representation) # 逻辑简单，数据复杂 最小惊吓(least surprise) # 少打破用户预期 安静(silence) 修复(repair) # 产生足够报错 经济(economy) # 减少开发时间 生成(generation) # 避免手写, 用高阶抽象生成代码 优化(optimization) # 优化和收益平衡 分化(diversity) # 一开始设计不限制、优雅开放灵活 扩展(extensibility) # 协议可扩展 优化 需要时再优化，设计时考虑扩展性 dry(don't repeat yourself), 不可过度 找瓶颈 产出 设计清晰 选型简单 代码精炼 抽象优雅 代码风格 # 命名 包名类名为名词, 方法名为动词 参数、方法名称在上下文语义中合理 , 像写文章一样 横向代码单屏内分行 性能 避免嵌套循环，特别是数据库操作 结构 # 高内聚，低耦合 抽取方法 业务逻辑分层 框架无侵入性 技巧 注释驱动写复杂业务 自解释代码 安全 密码二次验证 离机锁屏 用户名、密码、ip、端口不提交 代码安全, 如sql注入, XSS 代码质量 # 代码 功能、结构、资源 非遗留代码 写了测试 改代码 bug 重构 # 只改结构 确定修改点 找出测试点 解依赖 伪/仿对象 接缝 全局函数 提取重写方法 宏预处理 替换连接的代码 对象 # 耦合对象不好初始化 子类化重写方法 接口提取 创建简化接口 创建简化类与对象，引用原对象 暴露静态方法 对象提取公共方法，只测公共方法 传方法参数 写测试 优化 # 只改资源 具体实现原则 # 数据结构 # 状态机解决流程问题 AST解决主义问题 面向对象(Object Oriented) # 特性 ooad # Object Oriented Analysis and Design ooa # analysis 建立针对业务问题域的清晰视图 列出核心任务 针对问题域建立公共词汇表 列出针对问题域的最佳解决方案 ood # design 细化类关系，明确可见性 增加属性 分配职责(方法) 消息驱动系统中消息传递方式 局部应用设计模式 类图时序图 oop # program 抽象: abstract 接口 无实现 可多重继承 抽象类 可以有私有方法变量 实现部分方法 封装: encapsulation # 数据和方法绑定 继承: inheritance 多态: polymorphism overload为编译时 override为运行时 关联: association # has a 双向关联 两个类互相知道对方公共属性和操作 单向关联（大多数） 一个类知道另一个类的公共属性和操作 聚合: aggregation a包含b, b可以不在a创建时创建 组合: composition 比聚合强，a包含b, b在a创建时创建 内聚与耦合: cohesion \u0026amp; coupling # 高内聚低耦合 依赖: dependency # use a 泛化: generalization # is a 泛型 函数式 # 数组 [1, 1, 3, 5, 5].reduce(function(x, y){ return x + y;}) [1, 4, 9].map(function(num){return num * 2;}) 高阶函数(higher-order function) 操作函数的函数, 接收函数作为参数, 返回函数 不完全函数(partial function) 一次调用拆成多次调用，每次调用返回一个函数，如f(1,2)(3,4)(5,6) # 每次调用叫做不完全调用(partial application) 不变式 循环不变式 用于形式化证明正确性 描述 有循环变量 算法初始、保持、终止时, 某特性不变, 如选择排序中, arr[0,...,j-1]一直有序 类(或数据类型)不变式 并发时, 不变的成员关系 如, 并发临界区(同时只能一个线程占用) cps(continuation passing style) 传入处理函数, 处理函数中传处理函数 curry f(1,2,3)改写成f(1).f(2).f(3) thunk 触发函数, 如 f(){_f(1)} "},{"id":34,"href":"/docs/architect/project/ddd/","title":"工程","section":"工程设计","content":" 介绍 # 介绍 Domain-driven Design 针对传统软件开发流程（分析-设计-编码）各阶段业务割裂问题，一开始定义好领域 目标 维护概念完整性(纯洁)，避免语义泄露和腐化 概念 # 领域（Domain） 界限上下文（Bounded Context） 领域模型（Domain Model） 领域通用语言 分层架构 展示层、应用层、领域层、基础设施层 最佳实践 关联尽量少、尽量单项、尽量降低整体复杂度 实体（Entity） 领域中的唯一标识，属性尽量少 值对象（Value Object） 没有唯一标识，属性值不变 领域服务（Domain Service） 协调多个领域对象，只有方法没有状态 应用层服务、领域层服务、基础层服务 聚合、聚合根（Aggregate, Aggregate Root） 聚合定义了一组有内聚关系的对象集合，聚合根是对聚合引用的唯一元素 修改聚合必须在事务级别 70%的聚合只有一个实体, 30%有2到3个实体。 只有一个实体时，实体就是聚合根。多实体时思考哪个对象有独立存在的意义，且可与外部直接交互 工厂（Factory） 工厂模式 仓储（Repository） 持久化到DB，管理对象 只对聚合设计仓储 建模 # 原则 # 简单、容易、清晰 使用不动点 领域专注 聚合内强一致，跨聚合最终一致 内部概念完整一致(unification) 术语不变、不矛盾、不重叠 数据模型（DO） # 失血 DO和DAO无业务逻辑，纯数据 贫血 持久化逻辑在DAO中 充血 service很薄，持久化的逻辑在DO中，无DAO或与DO双向依赖 肿胀 无service，全部逻辑放DO 分析设计 # 分析模型 # # 业务领域分析, 不考虑代码 问题 含意不完整，不可图形或文字表达，错误假设 会深入某细节 忽略某细节直到设计或实现, 如持久化、性能 目标 领域模型 架构设计 事件风暴 # 是开发建模，不是用户需求故事 准备 功能确认: 近期milestone 找正确的人: 领域专家, 前后端，架构师 引导者: 准备资料, 排程, 时间, 2/3时间预警 事件风暴 领域事件: 用户可感知状态 分支小组 -\u0026gt; 个人发散 -\u0026gt; 小组一致 -\u0026gt; 整体一致 # 不能一致表示准备不足 逻辑顺序 -\u0026gt; 最终流程 命令风暴 # 为什么, 分色 事件触发原因、方式 用户角色 读模型: 用户前置需求 写模型: 动词 描述 聚合 取名, 分职责 持续探索 领域模型一开始就结合编码设计 # 设计围绕模型, 模型受设计反馈改善 开发时意识到模型变更, 会保持完整性 每个开发在修改前需要了解模型 面向对象更易于建模, 过程化易于流程，如数学 重构 # 要求 设计灵活 使用经过验证的构造 目标 领域理解更深、更清晰 深刻(incisive)、深层(deep)的模型 技术的动机的代码转换 实现 小幅可控 基于测试 突破 新的概念或抽象 隐含的概念被凸显 倾听领域语言 过分复杂是因为关键点被替代 领域文献 # 深层视图 约束 # 表达不变量 过程(process) # 面向对象中的面向过程, 多个过程时用策略 规约 # 测试对象返回布尔值, 重构成对象而非写在application 战略建模 # # 形成上下文映射图 问题空间 领域 # 与公司组织关联 子域 # 最好对应一个限界上下文 核心域(core domain) # 项目动机, 公司核心竞争力, 尽量小, 最高优先级 通用子域(generic subdomain) # 作用于整个系统的支撑子域 支撑子域 # 重要非核心 集成 合作关系(partnership) # 同时成功失败 共享内核(shared kernel) # 小型内核, 持续集成功能 客户/供应(customer-supplier development) # 上下游 遵从(conformist) # 下游遵从上游 防腐层(anticorruption layer) # 翻译转换领域服务 开放主机服务(open host service) # 公开协议，子系统访问 发布语言(published language) # dsl, 通常与开放主机服务一起 分隔(separate way) # 声明无关联 大泥球(big ball of mud) # 已有纠缠的系统，隔离出来 解决方案空间 通用语言 一个限界上下文一个通用语言 清晰(概念无二义性), 简洁 # 如卖家和买家都叫用户，就是不清晰。如用type标记用户是卖家或买家，就是不简洁。所以直接用两个对象 限界上下文 # 条件的集合 目的 确保术语含义明确 切分规模, 易于保持领域纯洁 设定进化框架而非模块，包含模块 考虑因素 团队组织结构 应用特定部分惯例、物理表现 挑战 团队开发碎片化 # 写重复的代码，由于不知道或怕改错 持续集成 早合并 自动构建测试 # 检测不一致 模块 作用 降低模型规模复杂度 代码高内聚低耦合 设计 通信性内聚(communicational cohesion) 功能性内聚(functional cohesion) 每模块统一接口 名称反映深层理解 灵活性，进化性 上下文映射 # 领域间集成关系 模式 共享内核(shared kernel) # 为减少重复, 共享领域子集，多方测试 客户-供应商(customer-supplier) # 做反馈的需求, 需求测试, 自动化验收 顺从者 # 供应商不做需求, 客户用适配器对接组件 防腐层(anticorruption layer) # 双向领域模型转换器, 保持内部模型纯洁 从前 原始数据(api, db)无模型无语义的处理 实现 对外多门面(facade) 每个门面一个适配器(adapter) 适配器间用转换器(translator) 隔离通道(separate way) 开放主机服务(open host service) # 实现开放服务协议 提炼 # 多次重构后还很大 实现 分离基本概念和普通概念, 提炼核心域和子域 子域 使用第三方服务 外包 修改已有模型 六边形架构 领域模型简洁自治 对外适配器防腐, 保护限界上下文 # 如面向接口 消息, 内存, 数据库 soap, rest CQRS(command query responsibility segregationg) # 修改只记事件(日志), 查询时计算 查询方式 单数据库/读写分离，查询时计算事件 读写分离, 读库异步计算事件保存冗余, 读库负载均衡 战术建模 # # 组成限界上下文 领域 实体(entity) # 标识和延续性, 有id, 持续变化。 值对象(value object) # 无id, 只有属性, 最好不可变(可共享)。尽量建模值对象。可包含实体引用或值对象。 生命周期 聚合(aggregate) # 定义对象所有权和边界 简化 关联 # 可导航到的关联 1对1 # 对象引用 1对n # 包含集合 n对n # 删除关联，关系加约束或转换 目的 一致性 强化不变量 实现 聚合根(root) # 聚合根间是最终一致性 是个实体,有id 外部访问的唯一对象 向外传递副本 工厂(factory) # 在领域中没有定义, 但程序需要 目的 并非对象创建对象 对象创建存在自有知识 创建过程原子性 对已有持久化对象重建并修复 问题 外部访问根内对象，需关联不必要的根实体 实现 不用工厂 构造不复杂 不涉及其它对象 客户希望用策略创建 类是具体类型, 无层级 聚合根提供方法 单独工厂 # 违反了封装原则, 但保持了简单 资源库(repository) # 内存假象 目的 不关联根获取对象引用 不暴露细节, 会减少领域专注 防止代码扩散 减少变更修改 维护聚合封装性 容易的基础设施被滥用, 产生除聚合根外导航 实现 封装所有获取对象逻辑 基础设施, 全局可访问 不同对象不同策略访问、存储 # 领域与基础设施解耦 接口是领域模型, 实现像基础设施 参数筛选或规约(specification)筛选(筛选器) entity 介绍 entity即状态 应用开发即处理entity的表现 主从 主存储(可变) # 关键是选择主存储 多派生一致性好保障 派生表达业务的难易成度 只读派生(representation, 不可变) 多份存储, 一致性 派生, 合并, 转化 类型 东西(可变) # 单据叠加成东西, 东西叠加成东西 单据(可变) # 事件叠加成单据 事件(event, 不可变) 命令(command, 不可变) 视图(view model, 不可变) 子集(subset, 不可变) 视图(aggregation, 不可变) 表单(可变) # 是主存储 物理介质 OLTP(mysql) # 点查询 OLAP(clickHouse) # 范围查询 queue(kafka) # 顺序读, 低延迟 业务服务 # 业务逻辑, 像虚拟的表 分组entity主存储(BC, bounded context) 目的 分解 管理复杂度 系统 组织部门 实现内部一致性 概念, 数据 对主存储进行受控的修改 边界entity # 用于集成，不一定是主存储 形式 授权、binlog、工作流、视图数据、租户作为其它租户user 东西、单据、event 介质 queue, 带权限db, rpc虚拟表 触发 queue, ui, api 触发由worker托管, 输入是queue或rpc socket 粒度 分entity 分步骤 分entity字段 原则 BC尽可能少而大 关系 时间错开 外键关系 # BC挂载到BC, 如后台系统与计费系统的定价, 运营人员与服务系统的配置, 流程节点系统对流程的依赖 rpc, 数据库, 数据复制 报表关系 时效性高 一般做复制 # 所以边界entity是数据变更event 触发关系 # fire and forget 交棒关系 下游给上游command/event, 上游触发 上游实现降级 # 下游不可用时，安慰语 时间同时 accountable/responsible关系 # 负责人与实现人 原则 accountable尽量小 只调度 与responsible的边界entity是rpc虚拟表, 请求command, 返回event 补偿实现一致 # 如超卖 responsible提供自己界面 # accountable不控制 抢资源关系 锁服务 服务(service) # 无法划分对象的动作, 无状态。按功能分组, 多对象的连接点 可在application, domain, infrastructure 最终一致性建模 # In-Memory # 聚合根在内存，同步最新状态 事件溯源（Event Sourcing） # 没有CRUD，只有Append Event。数据不可变 对象最新状态通过事件溯源获得 Actor # 通过Mailbox取代调用，保证消息线性处理 EDA(Event-driven Architecture) # 节点只处理逻辑，节点间Event通信 是最终一致性的架构 CQRS # 介绍 Command Query Responsibility Seperation CQ接口分离、代码分离，分别设计 概念 项目结构 # 用户接口(user interface) 应用(application) # 尽可能小。数据验证，事务。故事, 表达出操作的事情 application service unit work presentation model 领域(domain) # 专注领域。准确定义业务对象 aggregate, entity, value object domain service, domain event 基础设施(infrastructure) # 辅助层 repository global support 项目文件 [ui] mall # 商城api [saleDomain] [application] mall.application # 分模块，讲述故事 CartService GetCart() BuyService Buy() mall.application.domainEventSubscribers # 订阅domain事件 [domain] mall.domain # 不大而全，要求刚好满足需求 cartModule entity CartItem aggregate Cart valueObject Product SellingPriceCart IDomainServices IRemoteServices # 访问远程资源接口 IUserService ISellingPriceService IRepositories # 仓储接口 ICartRepository mall.domain.events # 领域事件, 用于实现最终一致性 mall.domainService # 操作domain的无状态方法 ConfirmUserCartExistedDomainService [sellingPriceDomain] # 与saleDomain合作关系, sale请求sellingPrice定价 [appication] mall.application.SellingPrice dto CalculatedCartDTO mapper ValueObjectToDTO [domain] [infrastructure] mall.infrastructure # 通用类库 domainCore # mail.domain base方法 AggregateRoot Cart Entity CartItem ValueObject Product IUnitOfWork # 仓储事务 domainEventCore DomainEvent DomainEventBus DomainEventSubscriber IDomainEvent IDomainEventSubscriber mall.infrastructure.repositories # 仓储 CartSqlServerRepository mall.infrastructure.translators # 防腐层, 访问远程资源实现 user UserAdapter # 请求原始结果 UserService UserTranslator # 转换原始结果 模块结构 api: controller biz: 特异业务 manager converter core: 公用业务 model entity bo service repository common dal dataobject do dao mapper service facade dto: facade和controller用 service: 服务间api validate integration service shared dto: 项目内部公用 "},{"id":35,"href":"/docs/architect/project/","title":"工程设计","section":"架构","content":" 产品 # 愿景 定义产品的目的和原因，将到达的地点 ux 微交互 # 细节决定成败 RoadMap # 介绍 到达愿景的策略路径，提供一系列与产品战略相一致的战术步骤 为什么 简单、清晰的通讯文档 少的多的会议 健康的团队辩论：交付成果与目标联系起来 做出每个人都理解的产品决定，不再打击创意 高维度的概述 动态演变 要素 时间周期 时间区间，只定时间范围 big-view(product) 全局理解产品的未来, 交付顺序 统一视野(vision), 范围(scope)，时间期限(time line) pre-view(release) release中的产品功能, 和前几个迭代从backlog中要交付的工作项(item) now-view(iteration) 团队在一次迭代中要交付的需求(requirements) 优先级，留空间适应变化 项目事件 完成产品总体计划必要的工作项, 详尽且切合目的 分解目的，制定步骤 路标 关键工作项完成的时间节点(里程碑) 结果反馈：审视是否偏离，试验中改进 确定在每个时间范围内实现可衡量的结果。定义为目标关键结果(OKR)、关键性能指标(KPI) 种类 基于目标 current near term future 基于功能 5000新用户 步骤 确定目标 分解目标，穷尽事项，组织，优先级排序 使用优化框架 effort / impact impact / goal 卡洛斯模型? 注意 定义战略主题(名词)，抓住核心用户行为的本质、产品能力、竞争优势、技术改进 保持路线图战略，避免战术 每个计划阶段都考虑优先级, 每个目标、动作、发布、特性的价值可见性 始终在试验(ABE), 为了正确定义目标和后续特征 先做出有根据的猜测 测试 基于反馈迭代 业务 # 目标 降低人才素质需求 减少开发时间 分类 创造虚拟空间 自动化 辅助决策 思路 逻辑: 因果(演绎), 时间, 空间, 优先 方法: 5w2h(who, when, where, why, what, how, how much) 建模: 中心 # 调整抽象领域和层次(视问题决定) 自上而下 # 问题明确，展开 自下而上 # 内容分类、剪枝、归纳 分解 MECE(mutually exclusive collectively exhaustive) 正交 穷尽 经验 优秀的产品都有全局把控感(confluence, jira) 设计思想多源自: 操作系统、编译器、函数式 深入一线(面对客户) 思考全面, 全局 考虑需求本质，考虑上下游全局 想清楚再行动 过程 发掘(discovery) 价值定位(价值驱动) 客户体验梳理和设计 愿景 干系人 电梯演讲收敛 定义(define) 用户旅程，业务流程 事件风暴 -\u0026gt; 映射技术 -\u0026gt; 架构 设计(design) 总体 识别问题域, 归纳服务, 上下游关系 架构图, api, 技术栈 提升方向, 改进 迭代 价值/成本分布图 milestone演进 业务技术/需求拆解全景图(白板贴标) mvp(minimum viable product最小可行计划)迭代计划 开发(develop) 度量, 质量指标 工具选择, 规范 架构守护，治理 实施策略 交付 产品生命周期管理 目标, 资本 机会点-\u0026gt;需求 角度决定设计 找到不动点 如对cache的设计 业务角度 选择简单易用的缓存框架 有人会用，学习成本别太高 关注数据模型结构设计 缓存更新真麻烦 paas角度 声明式使用，配置文件设置 缓存对比，选择强大且稳定的 存取接口设计，方便易用 数据变动监听，自动刷新缓存 平台角度 缓存服务器集群方式 存储空间监控 命中率监控 避免缓存集中失效引起雪崩 不过度设计 # 不超出需求，不用复杂方式实现 # 少就是多，应一减再减。简单才能强大，也会提高性能和扩展性 范围减少 # 28原则，最小可行产品 设计减少 # 易理解，低成本，可扩展 实施减少 # 找开源-\u0026gt;找内部已实现-\u0026gt;找方案描述-\u0026gt;自己解决 二八定律 墨菲定律 事情不是表面看起来那么简单 事情都会比预计时间长 可能出错总会出错 如果你担心发生，它更可能发生 维护 设计时考虑扩展性 DID(design, implement, deploy)(设计20倍, 实现3-20倍, 部署1.5-3倍) 设计能够监控的应用 版本升降 # 代码仓库 业务 防重 # 重复提交，重复扣减，重复支付(异构系统无法防重，用退款处理) 防重key, 防重表 幂等 # 消息处理，第三方支付回调 流程要抽象 # 如工作流 状态与状态机 订单系统 # 状态多时用状态机驱动 正向状态(待付款、待发货、已发货、完成) 逆向状态(取消、退款) 状态轨迹 # 跟踪和记日志，可回溯 并发修改，状态变更有序，状态变更消息有序 前端 减少dns查找 # dns可能查多个域 减少对象 # 页面布局少，图片合并。对象不要过大，减少到浏览器并发连接数 后台系统操作可反馈 # 便于确认效果 文档和注释 设计架构 设计思想 数据字典/业务流程 现有问题 设计 # 分层做维度扩展 DDD # DODAF2.0 # 介绍 美国国防部（DOD） 项目立项和顶层架构间，建立跟踪机制 八种视图 全视图 数据与信息视图 标准视图 能力视图 作战视图 服务视图 系统视图 项目视图 业务组件化 基本的、唯一的、不重复的，可单独运行 项目 # 分层 # mv* mvc # view controller model, 单向循环 mvp # view presenter model, presenter双向交互 mvvm # view view-model model, view-model双向绑定 验证 异常层 # 封装每层异常为不同异常类 过滤层 监听器 日志 测试 "},{"id":36,"href":"/docs/tool/ops/","title":"运维","section":"工具","content":" 持续集成(CI/CD) # # Continuous Integration(持续集成), Continuous Delivery(持续部署) Jenkins 容器 # docker containerd 虚拟化 # vagrant # 自动化虚拟机配置 parallels desktop # 苹果 xen gnome boxes hyper-v # 微软 KVM # 介绍 kernel-based virtual machine, 使用linux自身的调度器进行管理,所以代码较少 # 又叫qemu-system或qemu-kvm 虚拟化需要硬件支持(如 intel VT技术或AMD V技术)，是基于硬件的完全虚拟化 原理 包含一个可加载的内核模块kvm.ko, 由于集成在linux内核中，比其他虚拟机软件高效 使用 检查系统是否支持硬件虚拟化 egrep '(vmx|svm)' --color=always /proc/cpuinfo VMware # 安装 安装后会创建两个虚拟网卡 设置 edit -\u0026gt; preferences -\u0026gt; Hot Keys 设置退出快捷键 网络连接方式 1.vm9自带的virtual network editor中选择桥接到有线网卡 2.vm -\u0026gt; setting -\u0026gt; network adapter选项设置 bridged（桥接）:与主机平等，可以设置为同一个网段相互访问 nat:通过虚拟网卡连接主机，共享网络 host-only:单机模式 VirtualBox # 网络连接 NAT Bridged Adapter Internal Host-only Adapter 虚拟机-\u0026gt;主机 √ √ × 默认不能，需设置 主机-\u0026gt;虚拟机 × √ × 默认不能，需设置 虚拟机-\u0026gt;其他主机 √ √ × 默认不能，需设置 其他主机-\u0026gt;虚拟机 × √ × 默认不能，需设置 虚拟机间 × √ 同网络可以 √ 方案 linux安装增强iso iso位置 /usr/share/virtualbox 编译环境 kernel-devel gcc 共享剪切板与拖拽文件 虚拟机启动后devices下设置 共享文件夹 linux下挂载 mount -t vboxsf 共享名 /mnt/share windows下挂载 我的电脑 右键 映射网络驱动器 clone clone 时选择更新mac,并在虚拟机中网络连接设置中重写mac与ip 配置主机间ssh免登录，远程ssh与所有主机免登录 PaaS # OpenStack DevOps # 自动化运维 # tty.js # 浏览器运行命令 jenkins # java实现的持续集成工具 saltstack # 部署, 自动化运维 puppet # 自动化运维 selenium # 自动化运维 chef Ansible # # python实现的自动化部署工具 模式 ad-hoc # 批量命令 playbook # 任务编排，执行yml文件 安装 pip install ansible 配置 优先级 export ANSIBLE_CONFIG=/etc/ansible.cfg ~/.ansible.cfg /etc/ansible.cfg ansible.cfg inventory = /etc/ansible/hosts library = /usr/share/ansible forks = 5 sudo_user = root remote_port = 22 host_key_checking = False timeout = 60 log_path = /var/log/ansible.log hosts [mysql_test] 192.168.0.1 192.168.0.2 命令 ansible 通配符 10.1.1.113 '*' all -m command # 执行命令 -a 'uptime' file # 操作文件 -a \u0026quot;dest=/tmp/t.sh mode=755 owner=root group=root\u0026quot; # 改属性 -a \u0026quot;src=/etc/resolv.conf dest=/tmp/resolv.conf state=link\u0026quot; # 软链接 -a \u0026quot;path=/tmp/resolv.conf state=absent\u0026quot; # 删除软连接 copy -a \u0026quot;src=/a.cfg dest=/tmp/a.cfg owner=root group=root mode=0644\u0026quot; cron # 定时任务 -a 'name=\u0026quot;custom job\u0026quot; minute=*/3 hour=* day=* month=* weekday=* job=\u0026quot;/usr/sbin/ntpdate 172.16.254.139\u0026quot;' group # 操作组 -a 'gid=2017 name=a' # 创建组 user # 操作用户 -a 'name=aaa groups=aaa state=present' # 创建用户 -a 'name=aaa groups=aaa remove=yes' # 删除用户 yum -a \u0026quot;state=present name=httpd\u0026quot; service -a 'name=httpd state=started enabled=yes' # 开机启动 ping script -a '/root/test.sh' shell -a 'ps aux|grep zabbix' raw # 同shell get_url -a 'url=http://10.1.1.116/a.ico dest=/tmp' # 下载 synchronize -a 'src=/root/a dest=/tmp/ compress=yes' # 推送 o-\u0026gt; 例子 ansible '*' -m command -a 'uptime' ansible-doc # 文档 ansible-galaxy # 上传/下载模块 ansible-playbook # 任务编排 ansible-pull # 拉配置 ansible-vault # 文件加密 ansible-console # REPL 资源管理 # 文档管理 # Confluence Git Wiki 版本 # mercurial # 简称hg，分布式版本控制系统，比git好 clearQuest # IBM Rational提供的缺陷及变更管理工具。它对软件缺陷或功能特性等任务记录提供跟踪管理。提供了查询定制和多种图表报表。 clearcase # 配置管理的工具，只是SCM管理工具其中的一种。是RATIONAL公司开发的配置管理工具 spm # 构建sea.js项目 bower # 构建前端 redmine Gradle # 介绍 基于dsl(Groovy)声明项目自动化构建 环境 命令 gradle -q # --quiet, 只显示error init --type pom # 转换maven项目 wrapper # 生成可独立运行的打包脚本gradlew和gradlew.bat 配置 build.gradle task hello { doLast { println 'Hello world!' } } task hello \u0026lt;\u0026lt; { println 'Hello world!' } buildscript{} allprojects{} subprojects{} settings.gradle rootProject.name = 'choice-scm' include 'choice-scm-dao' gradle.properties org.gradle.parallel=true # 开启并行编译 org.gradle.daemon=true # 守护线程，在第一次编译时开线程并保持 org.gradle.configureondemand=true # 用新的孵化模式，加快编译 org.gradle.caching=true # 启用缓存 org.gradle.warning.mode=none # 屏蔽warning org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=1g -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 Git # 目录结构 .git branches config # 存放版本库git地址 规定 HEAD # HEAD的版本号, HEAD^^ 表示HEAD之前两个的版本, HEAD~n 表示之前n个版本 buffered stage branch head # buffered表示当前修改所在的版本，stage是buffered中文件add之后到的版本，branch是stage commit后到的分支(版本)，head是远程仓库的最新版本 工作流程 fork + pull / merge request 更新代码 commit message, pr messsage 提交说明 pr是功能展示，前面加\u0026quot;WIP:\u0026quot; user.name, user.email用公司的 pr必需有人review, assign到人, 推动review pr不要大 命令 git [command] --help git help submodule 设置 config --global http.proxy 'http://127.0.0.1:8123' 仓库 clone checkout # 切换到分支。检出原有文件替换 -b # 创建并切换到分支 branch # 创建并切换到分支 -r # 指定操作远程分支 -r origin/dev -a # 本地远程所有分支 dev ef71 # 从ef71创建分支dev dev -d dev # 删除 -D dev # 强制删除 remote remove origin show # 显示仓库 prune origin # 删除远程没有而本地缓存的远程分支 add origin git@bitbucket.org:outrun/www2.git # 设置仓库 set-url origin git@github.com:outrun/jeky # 设置仓库url fetch # pull加merge pull origin master --allow-unrelated-histories # 本地有已存文件时，强行pull并检查冲突 merge dev # 合并dev到当前分支 --squash dev-bak # dev-bak改动写到stash push origin master -u origin master # 设定git push 默认参数 origin :dev # origin +dev:dev # 强制替换掉原来版本 commit # stage 提交到branch -a # 提交删改，忽略增加 -m # 注释 --amend # 合并到上次commit revert git commit -am 'revert' git revert revertid1 取消上次revert # ideaIDE操作 - local history - revert 示例 revert -m 1 ea1 # 舍弃最近一次commit rebase master # 相当于当前改动代码之前merge master reset --hard ea1 # 回退 stash # 暂存buffered list # 显示stash drop # 删除暂存 pop # 恢复并删除暂存 apply stash@{0} # 恢复暂存 tag -a tag1 # 添加tag1 -m 'a' # 注释 -d tag1 # 删除tag1 示例 git tag -a v1.0.1 -m 'a' e67 show tag1 # 查看tag1的信息 文件 add -A # 递归 mv a b # 重命名 rm # buffered和stage中都删除 --cached # 只删除git stage中文件, 不实际删 log # HEAD到指定版本号之前的log --oneline # 每个记录显示一行 --stat # 文件名差异 -p # 细节差异 -2 # 文件最近2次差异 reflog # 包括reset前的版本号 diff master dev # 对比分支差异，可指定到文件。默认对比buffered和stage的差异 --cached # 对比stage和branch的差异 ls-files -u # 显示冲突文件 -s # 显示标记为冲突已解决的文件 --stage # stage中的文件 submodule init # 初始化本地配置文件 update --init --recursive # 同步项目中的submodule 设置 .gitignore .git/config ~/.gitconfig [commit] template=/t.txt # 每次commit会打开模板 代理 git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' git config --global --unset http.proxy git config --global --unset https.proxy 子模块 .gitmodules [submodule \u0026quot;a\u0026quot;] path = a url = ssh://a.git git submodule update --init --recursive 方案 回退commit git reset --hard ea1 # 进行回退 git push -f # 强制提交 git clean -xdf # 一般配合git reset使用, 清除已有的改动 补充commit git commit --amend git push origin +a:a 合并commit git rebase -i cf7e875 # 合并Head到cf7e875 commit 修改rebase记录 pick xxxx s yyyy s zzzz git status # 查看冲突 git add . # 解决冲突提交 git rebase --continue 修改commit记录 远程回退 git revert id 忽略文件 git add 逆操作 git rm --cached a 远程保留，忽略本地 git update-index --assume-unchanged a 恢复 git update-index --no-assume-unchanged a 远程删除，忽略本地 git rm --cached a 恢复 git add -A a 远程不论，忽略本地 .gitignore 删本地分支 git branch -D test 删除远程分支 git push origin --delete test 或 git branch -r -d origin/test git push origin :test 恢复历史版本文件 git reset ba5798aff7778c95252b9e01e924dddb5811bcd7 courseModel.js git checkout -- courseModel.js git push origin +master:master # 提交回退版本到远程 查看修改的内容 git show # 与上个commit 比较 git whatchanged git log --stat --date=relative 删除历史 git filter-branch --force --index-filter 'git rm -r --cached --ignore-unmatch .idea' --prune-empty --tag-name-filter cat -- --all git push origin main --force rm -rf .git/refs/original/ git reflog expire --expire=now --all git gc --prune=now git gc --aggressive --prune=now 合并commit历史 git branch test-bak git reset --hard ea1 git merge --squash test-bak git push origin test -f git branch -D test-bak 打tag git tag # git tag -l 'v1.*' 通配查找 git tag -a v1.0 -m \u0026quot;a\u0026quot; # git tag -a v1.0 ba1 给commit打标签 git tag -a v1.0 -m \u0026quot;a\u0026quot; ea1 # 指定commit git show v1.0 git checkout v1.0 git push origin v1.0 # git push origin -tags 将本地所有标签提交 git tag -d v1.0 git push origin --delete tag v1.0 # git push origin :refs/tags/v1.0c 查tag的commit git show 1.4.1 git log --pretty=oneline 1.4.0 1.4.1 fork跨网站git git remote add upstream git@github.com:xuyuadmin/xxljob.git git fetch upstream git merge upstream/master --allow-unrelated-histories 文件损坏错误error object file is empty find .git/objects/ -type f -empty | xargs rm git fetch -p git fsck --full 统计某人代码 git log --author=\u0026quot;$(git config --get user.name)\u0026quot; --pretty=tformat: --numstat | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \u0026quot;added lines: %s removed lines : %s total lines: %s\\n\u0026quot;,add,subs,loc }' - 统计所有人代码 git log --format='%aN' | sort -u | while read name; do echo -en \u0026quot;$name\\t\u0026quot;; git log --author=\u0026quot;$name\u0026quot; --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \u0026quot;added lines: %s, removed lines: %s, total lines: %s\\n\u0026quot;, add, subs, loc }' -; done 共添加或修改行数 git log --stat|perl -ne 'END { print $c } $c += $1 if /(\\d+) insertions/' pr 介绍 fork与pull request fork后本地 git clone git@github.com:chenduo/auth.git git remote add upstream git@github.com:Meiqia/auth.git git merge upstream/main git push origin main 本地合并更新 git checkout master git fetch upstream # fetch远程仓库 git rebase upstream/master # 合并远程master git push git checkout branch1 git rebase master pr追加 git commit --amend # 更新本地的本次commit,不产生新的commit git push origin +branch1:branch1 # 使用本地的commit覆盖远程分支的有问题的commit 处理pr git fetch origin git checkout -b pr1 origin/pr1 git checkout master git merge --no-ff pr1 git reset --hard git revert -m 1 ea1 # 舍弃pr git commit -am 'revert' git revert revertid1 取消上次revert # intellji - local history - revert git push origin master 开发 提交 git pull eoecn dev # 等于git fetch加git merge git diff # buffer与HEAD的差异(不包括新建文件) git add -A . # 添加到stage git status # stage与HEAD的差异 git diff --cached/--stage # stage与HEAD的详细差异 git diff HEAD # buffer, stage与HEAD的详细差异 git commit -am 'a' git push origin dev 网站上点pull request 代码审查 git blame -L 60,60 [filename] git blame -L 60,60 --reverse 5534e1b4b..HEAD [filename] # 版本范围内某行代码提交记录 git show [commit id] github ssh -T git@github.com # 检查github ssh是否设置成功 插件 octotree # 树形显示 SVN # linux下移植的版本控制器 默认端口: 3690 ## 目录结构 conf:配置文件 db:数据库 hooks:勾子（自定义功能） locks:文件锁 ## 命令 ### 服务器 svn --version svnadmin create c:\\svn # 创建仓库 ## hooks勾子 locks锁 conf db svnserve -h svnserve -d -r c:\\svn # 启动服务(-d是后台运行，windows不支持，需要创建服务) ## --listen-port 3691 指定监听端口 windows 下注册服务 sc create 服务名 binPath= \u0026quot;d:/suversion/bin/svnserve --service -r c:\\svn\u0026quot; displayName= \u0026quot;显示名\u0026quot; # 注意双引号前面要有空格 sc delete 服务名 使用多个仓库 svnadmin create d:\\svn2 创建仓库以后 svnserve -d -r d:\\svn2 --listen-port 3691 配置用另一个服务端口启动该仓库 # svn默认启动端口是3690 svn://192.168.10.3:3691 来访问该仓库 #### 客户端 添加项目 svn add test/ svn ci -m \u0026quot;first\u0026quot; # svn commit -m \u0026quot;fisrt\u0026quot; ## ci是checkin 检出 svn checkout svn://192.168.0.2/framework 显示所有分支(目录) svn ls svn://192.168.0.2/fr --verbose 创建分支 svn copy svn://192.168.0.2/repo/trunk/ svn://192.168.0.2/repo/branches/try-sth -m 'make branch try-sth' # 注意trunk后面要有/ 更换本地分支 svn switch svn://192.168.0.2/repo/branches/try-sth ## 配置 conf/svnserve.conf anon-access = read # 匿名用户权限 auth-access = write # 登录用户权限 # write权限包括read权限 ＃ none没有验证无权限(匿名权限) password-db = passwd # 加载conf/passwd文件（中的用户帐户） authz-db = authz ＃开启权限控制 同目录authz文件中配置权限 [/] # 对根目录设置权限 * = r # 所有人都可读 outrun = rw # 配置所有版本库只读，outrun可读可写 @admin = rw # @组名 对组进行引用 realm = aa # 认证域名称, 本svn路径为 svn://192.168.0.2/aa conf/authz conf/passwd [groups] admin = outrun 例子 authz [groups] admin = a1, a2 [/] @admin = rw a3 = rw * = r passwd [users] a1 = 123 a2 = 123 a3 = 123 svnserve.conf [general] anon-access = none auth-access = write password-db = passwd authz-db = authz realm = trunk force-username-case = none ## 工具 tortoiseSVN 下载 右键 svn checkout 选择版本 下载 (show log 查看日志) 上传 第一次提交 右键 tor.../import svn://192.168.10.188 # 输入用户名、密码登录 第二次提交 右键 commit 还原 右键 tor.../Revert 还原其中的文件 多人 右键 svn update ,更新另一个人提交的文件内容 新建文件的提交 tor../add 或 commit的时候选择该文件 tor./Repo-browser，浏览仓库 加锁文件 # 只有自己在不提交更改的前提下才可以解锁 tor../get lock # 不会改变版本 tor../release lock # 解锁,但是新下载的工程不可以再解锁，如果删除原工程则无法解锁 冲突 当前版本已经有人修改后commit的话提示版本已经过时 update:下载所有版本，右键 tor../edit conflicts -\u0026gt; mark as resolved确定解决 # 避免冲突：减少公共修改时间，重写前更新 使用经验 TortoiseSVN -\u0026gt; Setting -\u0026gt; Saved Data 可以清空自动登录 svn的myeclipse插件： # eclipse6中不能用，eclipse7每次报错，能用，eclipse8报错一次，能用 eclipse10不报错 1.复制插件文件夹features与plugins到/myeclipse 10/dropins/文件夹中 2.创建目录/myeclipse 10/my_plugin/svn/ 复制插件文件夹features与plugins到/myeclipse 10/my_plugin/svn/文件夹中 /myeclipse 10/dropins/添加svn.link文件 ，内容为:path=my_plugin\\\\svn # 这里写相对路径 3.使用：重启myeclipse,弹出确认窗口（也可以从window -\u0026gt; show view中找到svn的视图） 项目：右键-\u0026gt;share project 上传项目到svn(bug 第一次只上传空文件夹,再右键Team/提交 时上传项目文件) 再右键就可以对该项目进行一系列的操作了 导入项目：file -\u0026gt; import -\u0026gt; svn rapidsvn Ant # 功能 js压缩 自动发布 build.xml 示例 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project default=\u0026quot;execute\u0026quot;\u0026gt; \u0026lt;target name=\u0026quot;compile\u0026quot;\u0026gt; \u0026lt;javac destdir=\u0026quot;.\u0026quot; srcdir=\u0026quot;.\u0026quot;/\u0026gt; \u0026lt;/target\u0026gt; \u0026lt;target name=\u0026quot;execute\u0026quot; depends=\u0026quot;compile\u0026quot;\u0026gt; \u0026lt;java classpath=\u0026quot;.\u0026quot; classname=\u0026quot;HelloWorld\u0026quot;/\u0026gt; \u0026lt;/target\u0026gt; \u0026lt;/project\u0026gt; Maven # 仓库 mvnrepository.com 依赖范围 compile # 默认,对编译、测试、运行有效 test # 对测试有效 runtime # 对测试和运行有效 provided # 编译和测试有效 system # 本地仓库 import 源 阿里云maven: https://maven.aliyun.com/mvn/view mvn # 相当于mvn compile 全局 -version # 版本 -e # 错误详情 help:describe # help插件的describe -Dplugin=help # 显示help插件的详情 -Dfull # 显示完整参数 help:effective-pom # 显示默认设置 生成 archetype:create # 创建java项目 -DgroupId=com.outrun -DartifactId=erp -Dversion=0.0.1-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp # 指定模板为webapp archetype:generate # 向导创建项目 site # 产生html文档 source:jar # 源码打包 generate-sources # 生成源码, 如xdoclet eclipse:eclipse # 生成或转化成eclipse工程 eclipse:clean # 清除eclipse设置 idea:idea # 生成idea项目 install # compile, package后， 保存到本地仓库 -X # 显示依赖 -Dmaven.test.skip=true # 跳过测试 -rf 模块名 # 从指定模块从新开始 执行 validate # 项目验证 verify # 验证包 compile # 编译 exec:java # 编译完成后，执行java main方法 test-compile # 编译测试代码 test # 运行测试 -skipping # 跳过 compile # 不编译 test-compile # 不编译测试 integration-test # 集成测试 package # 打包 -Dmaven.test.skip=true # 跳过单元测试，不编译 -DskipTests # 跳过单元测试，编译 clean # 清除编译 install-U # 强制更新 package # 编译成jar包 deploy # install后, 上传 jar:jar # 打jar包 插件 jetty:run # 引入jetty-plugin后, 运行jetty tomcat:run 分析 dependency:list # 列出依赖 dependency:tree # 列出依赖树 dependency:analyze # 依赖分析, 未使用的做标记 dependency:resolve # 列出已解决的依赖 dependency:sources # 下载源码 dependency:copy-dependencies # 得到jar包 常用 分析包依赖 mvn dependency:tree -Dverbose -Dincludes=org.apache.commons:commons-lang3 清理打包文件 mvn clean package -DskipTests idea工具 打包了带main方法的jar不能引用 在父项目运行mvn package, model中运行会找不到其它model model运行前先mvn package 手动添加依赖 mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc7 -Dversion=12.1.0.2 -Dpackaging=jar -Dfile=ojdbc7.jar 配置 \u0026lt;groupId\u0026gt; # 包名 \u0026lt;artifactId\u0026gt; # 项目名 \u0026lt;version\u0026gt; \u0026lt;packaging\u0026gt; # 打包方式, war, jar \u0026lt;parent\u0026gt; # 父模块 \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;Dalston.RELEASE\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; # 子模块继承 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt; \u0026lt;artifactId\u0026gt; \u0026lt;version\u0026gt; LATEST ${spring-cloud.version} #引用properties中定义的变量 \u0026lt;scope\u0026gt; # 何时使用 compile provided # 类似compile runtime test system \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependenciesManager\u0026gt; # 子模块不继承, 继承时需要声明 \u0026lt;dependencies\u0026gt; \u0026lt;/dependenciesManager\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt; \u0026lt;artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 插件 介绍 按顺序执行，完成maven生命周期 无配置时调默认插件 生命周期(lifecycle)顺序 clean # 清除target目录 resources # 复制resources下文件到target/classes complie # 包含resources, 编译java下文件到target/classes testResources # 复制test/resources下文件到target/test-classes testCompile # 包含testResources, 编译test/java下文件到target/test-classes test # 包含resources, compile, testResources, testCompile, test package jar # 打包class文件, 配置文件, 不打包lib install maven-clean-plugin maven-resources-plugin \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-resources\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;validate\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-resources\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.outputDirectory}\u0026lt;/outputDirectory\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/${deploy.env}/applicationContext.xml\u0026lt;/directory\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt;WEB-INF/*.*\u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;inherited\u0026gt;\u0026lt;/inherited\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; maven-compiler-plugin maven-surefire-plugin # 对应test, 单元测试 maven-dependency-plugin # 打包lib maven-jar-plugin \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;classpathPrefix\u0026gt;lib/\u0026lt;/classpathPrefix\u0026gt; \u0026lt;mainClass\u0026gt;com.xxx.xxxService\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; # 单独打包lib \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.10\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-dependencies\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/lib\u0026lt;/outputDirectory\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; maven-assembly-plugin # 打包lib, 有bug缺失spring xds文件, 同级jar会冲突 \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;com.xxx.xxxService\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;make-assembly\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; maven-shade-plugin # 打包lib, 同级jar会冲突, 提示SF,DSA,RSA冲突，排除META-INF相关文件 \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.3\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;shade\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;filters\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;artifact\u0026gt;*:*\u0026lt;/artifact\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt;META-INF/*.SF\u0026lt;/exclude\u0026gt; \u0026lt;exclude\u0026gt;META-INF/*.DSA\u0026lt;/exclude\u0026gt; \u0026lt;exclude\u0026gt;META-INF/*.RSA\u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;/filters\u0026gt; \u0026lt;transformers\u0026gt; \u0026lt;transformer implementation=\u0026quot;org.apache.maven.plugins.shade.resource.AppendingTransformer\u0026quot;\u0026gt; \u0026lt;resource\u0026gt;META-INF/spring.handlers\u0026lt;/resource\u0026gt; \u0026lt;/transformer\u0026gt; \u0026lt;transformer implementation=\u0026quot;org.apache.maven.plugins.shade.resource.AppendingTransformer\u0026quot;\u0026gt; \u0026lt;resource\u0026gt;META-INF/spring.schemas\u0026lt;/resource\u0026gt; \u0026lt;/transformer\u0026gt; \u0026lt;transformer implementation=\u0026quot;org.apache.maven.plugins.shade.resource.AppendingTransformer\u0026quot;\u0026gt; \u0026lt;resource\u0026gt;META-INF/spring.tooling\u0026lt;/resource\u0026gt; \u0026lt;/transformer\u0026gt; \u0026lt;transformer implementation=\u0026quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\u0026quot;\u0026gt; \u0026lt;mainClass\u0026gt;com.xxx.xxxInvoke\u0026lt;/mainClass\u0026gt; \u0026lt;/transformer\u0026gt; \u0026lt;/transformers\u0026gt; \u0026lt;minimizeJar\u0026gt;true\u0026lt;/minimizeJar\u0026gt; \u0026lt;shadedArtifactAttached\u0026gt;true\u0026lt;/shadedArtifactAttached\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; maven-install-plugin spring-boot-maven-plugin gradle-maven-plugin protobuf-maven-plugin build-helper-maven-plugin # 用于指定自定义目录 dockerfile-maven-plugin # root用户直接打包到docker images \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;com.spotify\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dockerfile-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.10\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;repository\u0026gt;${project.artifactId}\u0026lt;/repository\u0026gt; \u0026lt;contextDirectory\u0026gt;./\u0026lt;/contextDirectory\u0026gt; \u0026lt;tag\u0026gt;${project.version}\u0026lt;/tag\u0026gt; \u0026lt;buildArgs\u0026gt; \u0026lt;JAR_FILE\u0026gt;mqtt/target/*.jar\u0026lt;/JAR_FILE\u0026gt; \u0026lt;/buildArgs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; ./Dockerfile FROM primetoninc/jdk:1.8 #ADD mqtt/target/*.jar app.jar ARG JAR_FILE COPY ${JAR_FILE} /opt/app.jar ENTRYPOINT [\u0026quot;java\u0026quot;, \u0026quot;-jar\u0026quot;, \u0026quot;/app.jar\u0026quot;] mvn package dockerfile:build 方案 新项目安装 mvn clean install -DskipTests mvn install -rf :模块名 -DskipTests # 指定模块开始 ojdbc14本地加载 ＃ oracle是收费的，所以不能直接下载到驱动 o-\u0026gt; mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=ojdbc14-10.2.0.4.0.jar o-\u0026gt; 把ojdbc14-10.2.0.4.0.jar复制到目录下: /home/outrun/.m2/repository/com/oracle/ojdbc14/10.2.0.4.0/ o-\u0026gt; /home/outrun/.m2/repository/com/oracle/ojdbc14/下会产生maven-metadata-local.xml文件存放maven引入依赖 o-\u0026gt; 项目中引入本地依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ojdbc14\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;10.2.0.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 代理 复制$M2_HOME/conf/settings.xml到.m2/ settings.xml \u0026lt;proxies\u0026gt; \u0026lt;proxy\u0026gt; \u0026lt;id\u0026gt;my-proxy\u0026lt;/id\u0026gt; \u0026lt;active\u0026gt;true\u0026lt;/active\u0026gt; \u0026lt;protocol\u0026gt;http\u0026lt;/protocol\u0026gt; \u0026lt;host\u0026gt;localhost\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8123\u0026lt;/port\u0026gt; \u0026lt;!-- \u0026lt;username\u0026gt;admin\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt; \u0026lt;nonProxyHosts\u0026gt;repository.mycom.com|*.google.com\u0026lt;/nonProxyHosts\u0026gt; --\u0026gt; \u0026lt;/proxy\u0026gt; \u0026lt;/proxies\u0026gt; 代码 # github bitBucket gitee.com # 码云 sentry # 产品error tracing gerrit # code review 工具 coverallx # github上项目的coverage测试覆盖率条目由它提供服务 circleCI # github代码测试 travis-ci # 利用github hook测试 fitness # 自动单元测试 coverity # 代码静态检查 www.webpagetest.org # 测试网站性能 GitLab # 仓库 # Nexus # # maven, npm, go, docker, yum等 JFrog # # 全语言二进制仓库 CMDB # # configuration management database Bt-Panel # # 宝塔面板，服务器运维面板 JumpServer # # 跳板机 功能 # 认证 # SSH（Secure Shell） # 特点 1.加密和压缩：http与ftp都是明文传输 2.ssh有很多子协议，实现不同功能：如sftp,scp 3.端口:22 配置 修改ip地址： 有虚拟机时：先设置虚拟机的连接方式是桥接 图形界面直接修改（或重启到root用户的图形界面修改） 命令修改 /etc/network/interfaces auto eth0 iface eth0 inet static address ip地址 netmask 子网掩码 gateway 网关 broadcast 广播地址 dns-nameservers DNS 重启网络服务：/etc/init.d/networking restart， /etc/ssh/sshd_config PasswordAuthentication no # 关闭密码登录 PermitRootLogin no # 关闭root登录 命令 ssh outrun@10.1.1.1 # -p 22 端口 # PubkeyAuthentication=no 不公钥登录 免登录 ssh-keygen -t rsa # 一直回车，生成~/.ssh/id_rsa 与 id_rsa.pub两个文件 ssh-copy-id -i 192.168.56.11 # 这样就可以免登录访问192.168.56.11了 ## ssh-copy-id -i localhost　免登录自己 或 把A机下的1中生成的id_rsa.pub的内容复制到B机下，在B机的.ssh/authorized_keys文件里，这样可以多个主机对B机进行免登录 sshpass 介绍 命令行密码登录 命令 sshpass -p zlycare@123 ssh zlycare@10.162.201.58 OpenVPN # 安装 yum install openvpn easy-rsa lzo lzo-devel openssl openssl-devel -y 或编译安装openvpn mkdir –p /usr/local/openvpn \u0026amp;\u0026amp; cd /usr/local/openvpn/ ./configure --with-lzo-headers=/usr/local/include --with-lzo-lib=/usr/local/lib make make install 生成证书 目标 服务器: ca.crt、server.key、server.crt、dh.pem 客户端: ca.crt、client.key、client.crt 查找模板 find / -name \u0026quot;vars.example\u0026quot; -type f # vars文件 find / -name \u0026quot;server.conf\u0026quot; -type f # server.conf文件 进入目录easy-rsa cd /usr/local/openvpn/openvpn-2.0.9/easy-rsa/2.0/ cd /usr/share/easy-rsa/3.0.3/ 设置vars cp vars.example vars vars文件 set_var KEY_COUNTRY=\u0026quot;CN\u0026quot; set_var KEY_PROVINCE=\u0026quot;BJ\u0026quot; set_var KEY_CITY=\u0026quot;Beijing\u0026quot; set_var KEY_ORG=\u0026quot;linux\u0026quot; set_var KEY_EMAIL=\u0026quot;test@example.net\u0026quot; # set_var EASYRSA_NS_SUPPORT \u0026quot;yes\u0026quot; # 客户端配置ns-cert-type server时配置 生成server文件 # 配置文件在/etc/easy-rsa或 .../openvpn/easy-rsa rm -rf pki ./easyrsa init-pki # pki目录 ./easyrsa build-ca nopass # 回车过, 生成ca.crt ./easyrsa gen-req vpnserver nopass # 回车过, 生成vpnserver.key, vpnserver.req(密钥对、证书请求文件) ./easyrsa sign server vpnserver # 生成vpnserver.crt(ca.crt与vpnserver.req签名) ./easyrsa gen-dh # 生成dh.pem(diffie hellman) cp -r ../3.0.3/ ~ 生成client文件 rm -rf pki ./easyrsa init-pki ./easyrsa gen-req client nopass # 回车过, 生成client.key, client.req cp pki/reqs/client.req ~/3.0.3/pki/reqs/ cp pki/private/client.key ~/3.0.3/pki/private/ cd ~/3.0.3 ./easyrsa sign client client # 生成client.crt(ca.crt与client.req签名) 移动server文件到openvpn配置目录 cp pki/{ca.crt,dh.pem} /etc/openvpn/server/ cp pki/private/vpnserver.key /etc/openvpn/server/ cp pki/issued/vpnserver.crt /etc/openvpn/server/ cp server.conf /etc/openvpn/server 下载client文件 pki/ca.crt pki/private/client.key pki/issued/client.crt server.conf cp -p ../../sample-config-files/server.conf /etc/openvpn o-\u0026gt; server.conf ;local 172.21.223.196 port 1194 proto udp dev tun ca /etc/openvpn/ca.crt cert /etc/openvpn/server.crt key /etc/openvpn/server.key dh /etc/openvpn/dh1024.pem server 192.168.200.0 255.255.255.0 ifconfig-pool-persist ipp.txt ;client-config-dir \u0026quot;C:\\\\Program Files\\\\OpenVPN\\\\ccd\u0026quot; # 支持TLS client push \u0026quot;route 0.0.0.0 0.0.0.0\u0026quot; keepalive 10 120 cipher AES-256-CBC comp-lzo # 减少带宽 persist-key persist-tun status openvpn-status.log log /var/log/openvpn.log verb 3 explicit-exit-notify 1 # 只能udp协议使用 sudo openvpn --config /etc/openvpn/server.conf --daemon netstat -anulp | grep 1194 linux配置 iptables vim /etc/sysctl.conf net.ipv4.ip_forward = 1 # 开启路由转发 sysctl -p iptables -t nat -A POSTROUTING -s 192.168.200.0/24 -j SNAT --to-source 45.55.56.16 firewall firewall-cmd --add-service=openvpn --zone=public --permanent firewall-cmd --reload client配置 o-\u0026gt; client.ovpn client dev tun proto udp remote 45.55.56.16 1194 resolv-retry infinite nobind ca ca.crt cert client.crt key client.key ;ns-cert-type server cipher AES-256-CBC comp-lzo persist-key persist-tun verb 3 mute 20 sudo openvpn --config client.ovpn # --user outrun # --auth-nocache # askpass pass.txt 放密码到文件 o-\u0026gt; 免密码连接 #!/usr/bin/expect -f spawn sudo openvpn --config /home/outrun/.openvpn/meiqia-vpn-ldap.ovpn # match_max 100000 expect \u0026quot;*?assword*:*\u0026quot; send -- \u0026quot;1234\\n\u0026quot; expect \u0026quot;*Username:*\u0026quot; send -- \u0026quot;outrun\\n\u0026quot; expect \u0026quot;*Password:*\u0026quot; expect \u0026quot;#\u0026quot; 案例 代理http上网 # tcp连接国内服务器会被reset server.conf dev tap proto tcp push \u0026quot;redirect-gateway def1 bypass-dhcp\u0026quot; push \u0026quot;dhcp-option DNS 114.114.114.114\u0026quot; push \u0026quot;dhcp-option DNS 8.8.8.8\u0026quot; client-to-client ;explicit-exit-notify 1 client.ovpn dev tap proto tcp 改成用户名密码认证 服务器 server.conf auth-user-pass-verify /etc/openvpn/server/checkpsw.sh via-env verify-client-cert none username-as-common-name tls-auth /etc/openvpn/server/ta.key 0 script-security 3 checkpsw.sh #!/bin/sh PASSFILE=\u0026quot;/etc/openvpn/server/user/psw-file\u0026quot; LOG_FILE=\u0026quot;/etc/openvpn/server/log/openvpn-password.log\u0026quot; TIME_STAMP=`date \u0026quot;+%Y-%m-%d %T\u0026quot;` if [ ! -r \u0026quot;${PASSFILE}\u0026quot; ]; then echo \u0026quot;${TIME_STAMP}: Could not open password file \\\u0026quot;${PASSFILE}\\\u0026quot; for reading.\u0026quot; \u0026gt;\u0026gt; ${LOG_FILE} exit 1 fi CORRECT_PASSWORD=`awk '!/^;/\u0026amp;\u0026amp;!/^#/\u0026amp;\u0026amp;$1==\u0026quot;'${username}'\u0026quot;{print $2;exit}' ${PASSFILE}` if [ \u0026quot;${CORRECT_PASSWORD}\u0026quot; = \u0026quot;\u0026quot; ]; then echo \u0026quot;${TIME_STAMP}: User does not exist: username=\\\u0026quot;${username}\\\u0026quot;, password=\\\u0026quot;${password}\\\u0026quot;.\u0026quot; \u0026gt;\u0026gt; ${LOG_FILE} exit 1 fi if [ \u0026quot;${password}\u0026quot; = \u0026quot;${CORRECT_PASSWORD}\u0026quot; ]; then echo \u0026quot;${TIME_STAMP}: Successful authentication: username=\\\u0026quot;${username}\\\u0026quot;.\u0026quot; \u0026gt;\u0026gt; ${LOG_FILE} exit 0 fi echo \u0026quot;${TIME_STAMP}: Incorrect password: username=\\\u0026quot;${username}\\\u0026quot;, password=\\\u0026quot;${password}\\\u0026quot;.\u0026quot; \u0026gt;\u0026gt; ${LOG_FILE} exit 1 chmod 645 checkpsw.sh mkdir user mkdir log user/psw-file outrun asdfasdf openvpn --genkey --secret ta.key 客户端 下载ta.key client.ovpn ;cert client.crt ;key client.key auth-user-pass tls-auth ta.key 1 Shadowsocks # 安装 sudo yum -y install epel-release sudo yum -y install python-pip sudo pip install --upgrade pip sudo pip install shadowsocks 服务器 server.json { \u0026quot;server\u0026quot;:\u0026quot;0.0.0.0\u0026quot;, \u0026quot;server_port\u0026quot;:443, \u0026quot;local_address\u0026quot;:\u0026quot;127.0.0.1\u0026quot;, \u0026quot;local_port\u0026quot;:1080, \u0026quot;password\u0026quot;:\u0026quot;asdfasdf\u0026quot;, \u0026quot;timeout\u0026quot;:300, \u0026quot;method\u0026quot;:\u0026quot;aes-256-cfb\u0026quot;, \u0026quot;fast_open\u0026quot;:false, \u0026quot;workers\u0026quot;:5 } ssserver -c server.json -d start 中继代理 client.json { \u0026quot;server\u0026quot;:\u0026quot;47.74.230.238\u0026quot;, \u0026quot;server_port\u0026quot;:443, \u0026quot;local_address\u0026quot;: \u0026quot;127.0.0.1\u0026quot;, \u0026quot;local_port\u0026quot;:1080, \u0026quot;password\u0026quot;:\u0026quot;asdfasdf\u0026quot;, \u0026quot;timeout\u0026quot;:300, \u0026quot;method\u0026quot;:\u0026quot;aes-256-cfb\u0026quot; } sslocal -c client.json 协议转换 安装polipo /etc/polipo/config logSyslog = false logFile = \u0026quot;/var/log/polipo/polipo.log\u0026quot; socksParentProxy = \u0026quot;127.0.0.1:1080\u0026quot; socksProxyType = socks5 chunkHighMark = 50331648 objectHighMark = 16384 serverMaxSlots = 64 serverSlots = 16 serverSlots1 = 32 proxyAddress = \u0026quot;0.0.0.0\u0026quot; proxyPort = 8123 polipo -c /etc/polipo/config 客户端 switchOmega SOCKS5 127.0.0.1 1080 http 127.0.0.1 8123 环境变量 export http_proxy=http://127.0.0.1:8123 export https_proxy=http://127.0.0.1:8123 OpenDJ # 介绍 open source directory services for the java platform LDAPv3的认证系统 OpenSSL # 使用 openssl genrsa -out server.key 1024 # 生成私钥 openssl rsa -in server.key -pubout -out server.pem # 生成公钥 openssl req -new -key ca.key -out ca.csr # 通过私钥生成csr(certificate signing request, 证书签名请求)文件 openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt # 通过csr生成自签名ca证书，用来颁发证书 openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt # 向自己的ca机构申请签名，需要ca.crt, ca.key, server.csr, 得到带有CA签名证书。用来给客户端验证公钥属于该域名 # 客户端发起安全连接前会获取服务器端的证书, 并通过ca证书验证服务器端证书的真伪，并对服务器名称, IP地址等进行验证 openssl s_client -connect 127.0.0.1:8000 # 测试证书是否正常 应用控制 # Forever # openvpn --config openvpn.conf # 连接 ## --user outrun ## --auth-nocache # askpass pass.txt 放密码到文件 Supervisor # 介绍 监视重启 命令 supervisord # 启动后台服务 supervisorctl status # 查看所有 update # 重载配置 reload # start stop restart start all stop all restart all 配置 /etc/supervisor/supervisord.conf [include] files = /etc/supervisor/conf.d/*.conf /etc/supervisor/conf.d/app.conf [program:tri] command=/data/apps/tri/bin/tri --config /data/apps/tri/conf/config.tri.toml directory=/data/apps/tri autostart=true autorestart=true startsecs=10 startretries=3 stdout_logfile=/data/logs/supervisor/tri/access.log stdout_logfile_maxbytes=100MB stdout_logfile_backups=20 stderr_logfile=/data/logs/supervisor/tri/stderr.log stderr_logfile_maxbytes=100MB stderr_logfile_backups=2 environment=ASPNETCORE_ENVIRONMENT=Production # 环境变量 user=root # 执行的用户 PM2 # 介绍 带有负载均衡功能的node应用进程管理器 内建负载均衡(使用node cluster模块) 后台运行 热重载 停止不稳定进程，如无限循环 安装 npm install -g pm2 命令 pm2 start app.js pm2 stop pm2 restart pm2 status pm2 info 1 pm2 logs 1 个人操作 # Ngrok # # 内网穿透 VSFTP # 介绍 默认端口21 用户 匿名用户 默认为ftp或anonymous 目录在/var/ftp 只能下载不能上传 本地用户 用户名和密码与本地用户相同 目录为该用户的登录目录 虚拟用户 文件配置名字和密码 要生成认证文件 文件 /usr/sbin/vsftpd # 主程序 /etc /rc.d/init.d/vsftpd # initd启动脚本 /vsftpd.conf # 主配置 /vsftpd.ftpusers # 用户黑名单, 一行一名字 /vsftpd.user_list # 用户黑/白名单, 一行一名字 /pam.d/vsftpd # pam认证文件 /var /ftp # 匿名用户主目录 /ftp/pub # 匿名用户的下载目录 默认用户与组 用户 adduser -d /var/ftp -g ftp -s /sbin/nologin ftp 组 ftp 命令 systemctl start vsftpd 最小可用配置 /etc/vsftpd.conf listen=YES local_enable=YES xferlog_enable=YES connect_from_port_20=YES pam_service_name=vsftpd seccomp_sandbox=NO # Enable upload by local user. write_enable=YES # Enable read by anonymous user (without username and password). secure_chroot_dir=/var/empty anonymous_enable=YES anon_root=/srv/ftp no_anon_password=YES 使用 /etc/vsftpd.conf anonymous_enable=YES # 允许匿名用户 local_enable=YES # linux用户可登录, 虚拟用户可登录 write_enable=YES # 可写 local_umask=022 # user文件权限, 默认077 dirmessage_enable=YES # 显示目录信息 xferlog_enable=NO # 记录上传/下载日志 connect_from_port_20=YES # 确保用20端口传输 ls_recurse_enable=NO # 允许ls -R allow_writeable_chroot=NO listen=NO listen_ipv6=YES # 包含ipv4,和listen只能有一个YES pam_service_name=vsftpd local_root=/home/outrun/Downloads # linux用户默认目录。会先登录到用户目录，再切换到这里 ftp_username=ftp # 匿名用户名，默认ftp tcp_wrappers=NO # 结合tcp_wrapper限制ip登录 /etc /hosts.allow # 允许地址 /hosts.deny # 拒绝地址 useradd -d /home/ftp ftp mkdir /home/ftp \u0026amp;\u0026amp; chown ftp /home/ftp \u0026amp;\u0026amp; chgrp ftp /home/ftp systemctl restart vsftpd 打开tcp, udp端口21, 20 用户 匿名登录 /etc/vsftpd/vsftpd.conf anonymous_enable=YES anon_root=/home/outrun/Downloads # 匿名用户默认目录 anon_upload_enable=YES # 匿名可写，要求write_enable=YES anon_mkdir_write_enable=YES # 匿名创建文件夹 anon_other_write_enable=YES # 匿名可删除、重命名 anon_umask=000 # 如创建077文件，anon_umask=022时，则为055 chmod 777 dir1 本地用户登录 /etc/vsftpd/vsftpd.conf anonymous_enable=NO userlist_enable=YES userlist_deny=YES # YES时user_list为黑名单 userlist_file=/etc/vsftpd/user_list chroot_local_user=YES # 默认可以chroot到用户home。YES时, chroot_list_file指定黑名单 chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_file # 名单用户只能访问自己home allow_writeable_chroot=YES # 不限制chroot目录可写 /etc/vsftpd/ftpusers /etc/vsftpd/user_list 注释root 虚拟用户 SimpleHTTPServer # pythom -m SimpleHTTPServer 8080 Pyshark # 介绍 包嗅探 项目用工具 # 知识库 # confluence # 收费 NextCloud # 私有网盘 tiddlyWiki # 可在线定义目录树 github # 用wiki页面 gitbook mediaWiki # 维基百科样式，只有单页目录树 dokuWiki # 只有网站地图 xwiki # 目录树, acl 语雀 hdwiki # 百科, 已停更 notion # 任务管理 minidoc # 原smartWiki(php), 改成golang开发的minidoc 有道云笔记 幕布 石墨 etherpad.org # 在线协作无缝编辑 dropbox # 文档协作 坚果云 # 文档协作 网盘 # google drive 百度云 沟通 # Mattermost # 开源 team # 微软, 聊天 slack # 聊天 hipChat # Atlassian, 聊天 企业微信 钉钉 倍洽 飞书 瀑布IM 邮件 # gmail 阿里云邮箱 腾讯企业邮 zoho 网易企业邮 原型 # zeplin # 设计和前端协同工具 蓝湖 # 免费 团队协作 # jira # 进度管理跟踪, 敏捷开发 microsoft Project # 瀑布式开发 rational # IBM, 进度管理 teambition # 进度管理 basecamp # 进度管理 testlink # 测试收集, 进度管理 redmine # 开源, ror开发, 项目管理, 把成员、任务、文档、讨论等资源整合在一起。支持git, svn, cvs等 youtrack # jetbrains, 项目管理 禅道 # 项目管理, 开源 trac # wiki, issue tapd # 腾讯项目管理 优势 打通企业微信 功能 worktile # microsoft项目管理 notion 明道云 云之家 eteams 今目标 tower masterlab # 开源 openProject # 开源 peerProject # 开源 trello # 进度管理 代码管理 # github gitee coding bitbucket gitea # 开源 gitlab gogs # 开源 测试 # semaphore codeClimate 文档 # swagger 镜像 # harbor nexus 部署 # drone Travis-CI CircleCI GitLab-CI 集群 # kuboard prometheus grafana zabbix 日志 # ElasticStack "},{"id":37,"href":"/docs/architect/strategy/ai/","title":"AI","section":"战略性技术","content":" 基础 # 模型的作用 调模型参数自动做特征工程 交互 用户数据 -\u0026gt; 向量化 -\u0026gt; 向量 -\u0026gt; 模型 -\u0026gt; 输出 算法分类 离线: 复杂模型 在线: 时间短 框架 # tensorflow # 神经网络计算 convnet.js # js深度学习 scikit-learn # python机器学习 特征工程 # 向量化, 量化才能优化, bitmap存储(位数即维数) one-hot: 太长，无序，歧义 业务导向存储 分段标识，如年龄区间[0,1,0,0] 需要经验及产品设计 模型 # 分类 传统模型 速度快 深度模型 业务复杂, 数据量大时用 模型 线性回归 逻辑回归 朴素贝叶斯 支撑向量机 用户画像 # 在Hive中存 场景 # 聊天机器人 类型 QA机器人 闲聊机器人 任务机器人: AIOps 场景机器人 实现类型 基于检索 基于生成模型 语音识别 知识图谱 生物特征识别 AIoT AITest 视频行为分析 "},{"id":38,"href":"/docs/architect/strategy/iot/","title":"IoT","section":"战略性技术","content":" 场景 # 展示 # dashboard 在线设备 消息量 规则引擎消息流转次数 运维大盘 产品品类 地区排名 指标趋势 设备在线率 设备排行 事件数 事件类型 停用时长 延迟 设备管理 # 接入 多协议: MQTT、CoAP、HTTP 多平台(设备端代码): c、node.js、java 多网络: 2/3/4G、NB-IoT、LoRa 多地域 通信 双向通信 稳定 安全 影子缓存 # 设备与应用解耦, 网络不稳定时增加可靠性 安全 认证(一机一密) 传输: TLS 权限: 设备权限 规则引擎 数据流转 M2M(machine to machine) # 设备间通信 数据结构化存储 数据计算: 函数计算、流式计算、大规模计算 数据mq转发 联动触发 管理 生命周期: 注册、分组、拓扑、标签、状态、数据采集、禁用删除 模型 数据标准化: 属性、事件、服务 存储结构化 远程 设备调试 实物 模拟 维护 指令 固件升级 下发配置 监控 日志 实时数据 通知 数据分析 # 流计算实时分析 可视化 三维设备关联 二维(地图)分布, 实况， 搜索 数据源适配 产业 # 车联网、智能家居、穿戴、媒体内容分发、环境监测、智慧农业 开发服务 # Studio 开发 web 移动 自动化服务 设备 产品 # 软硬分离的桥梁 设备开发 -\u0026gt; 设备模拟(在线写c, js) -\u0026gt; 软件开发 配置(使用移动端) 运营运维 后台 监控 插件开发 服务编排 Studio OS # 高性能、极简开发、云端一体、丰富组件、安全防护 项目生成 领域模板 插件选择 技术 # AIoT 边缘计算 # 优势 就近计算 实时 离线运行 快速编程 降低成本 功能 视频设备sdk 边缘算法容器(接入方案) 视频智能 视频算法容器 驱动 websocket、modbus、lightSensor、light、opcua 网络 # 协议 NB-IoT Narrow Band Internet of Things 物理层/数据链路层, 蜂窝网络上，消耗和带宽低 场景 Standalone Guard-band In-band LoRa Long Range LoRaWAN 物理层/数据链路层 CoAP Constrained Application Protocol 资源紧张的设备 MQTT Message Queue Telemetry Transport 低电量低带宽, 提供数据传输QoS, 可传任意类型数据, 有Session MQTT-SN MQTT for Sensor Network MQTT协议的传感器版本 LwM2M Lightweight Machine-To-Machine 轻量级RESTful ZigBee SigFox eMTC 被NT-IoT取代 DDS AMQP XMPP JMS 网关 凭证 无线 设备 # 统一网关 框架 # # Internet of Things Kaa SiteWhere # tomcat, mongodb, hbase, influxdb, grafana ThingSpeak # matlab可视化 DeviceHive # 开源, docker, k8s, es, spark, cassandra, kafka Zetta Thinger.io wso2 "},{"id":39,"href":"/docs/architect/strategy/meta/","title":"IoT","section":"战略性技术","content":" 转变 # 网页向虚拟世界转变 开发者创建向用户创建转变 游戏即服务到游戏即平台 特点 # 是一个框架，代表多技术发展结合点 实时流媒体，VR/AR UGC 多人社交游戏，跨平台交互 游戏作为社交媒体的趋势 硬件、网络基础设施、可视化、空间计算、人工智能 加密货币 各游戏的数字化打通, 跨平台无边界 内容变现 UGC增长 NFT数字所有权 人与人、人与社会的关系重构 不同世界IP融合 数字人自定义身份 数字世界和现实世界的融合 虚实结合 一体世界 技术 # 扩展现实 数字孪生 区块链 物联网 VR/AR/MR/XR 云可扩展性 人工智能生成内容 脑机接口 边缘计算 机构 # 《元宇宙生态系统信息图》 入口类 Roblox The Sandbox Decentraland Hadean 世纪华通(打造平台): LiveTopia、强化训练号 中手游(打造IP): 仙剑无宇宙 元境(云游戏) 技术类 Nvdia: Omniverse数字工厂 Unity: 元宇宙工厂 钱包 Metamask Coinbase Wallet Bitski WalletConnect Venly Fortmatic 引擎 Unity 互联网 Meta 微软: IVAS 应用领域 # 游戏 我的世界 GTA5 动物森友会 第二人生 Roblox VRChat 商业模式 # 虚拟活动：虚拟音乐会、讲座 NFT: 非同质化代币、持久性数字物品 Play-to-Earn Play-to-Collect Pay-to-Socialize 市场营销 # 原生植入广告 "},{"id":40,"href":"/docs/architect/strategy/middle_platform/","title":"中台","section":"战略性技术","content":" 业务中台 # 权限 # 类型 ACL(access control list) # 访问权限列表 RBAC(role base access control) # 基于角色的访问控制 ABAC(attribute base access control) # 基于属性(计算属性)的访问控制 DAC(discretionary access control) # 自主访问控制 主体对所属对象有全部控制权 主体执行的程序权限相同 主体权限可分配给其它用户 MAC(mandatory access control) # 强制访问控制 管理分配权限，主体不能改变 主体只能访问他的对象，也不能写低级别对象 成员 user role group 访问权限 权限1: 游客，用户，rememberMe 权限2: uri前缀(功能模块) 权限3: uri后缀(静态资源过滤) 判断位置: 过滤器中 资源权限 权限: kind:part1:part2... 判断位置: 渲染数据前 数据权限 资源层级 权限: 2 判断位置: 进方法前 单表 权限: 表名:列名:值 判断位置: 写sql前 方法权限 权限: 方法域:方法名 判断位置: 进方法前 性能 grantTable缓存u_id, res_id关系 审批 # 模板 准入规则 起始、终止节点 节点, 节点成员, 替换成员, 节点事件(脚本), 跳转公式 审批流程 创建, 状态查询 审批 海 # type # 记录类型 property # 类型动作, 关联到节点, 记录进出节点的动作。如对成员可读、可写, 记录负责人，对记录执行脚本, 记录回收计划 model # 模式 节点树、一个激活 节点 节点组 两节点方向 成员 节点成员1对多 成员分组(group, role)也是成员 记录 节点记录1对1 流转 # 记录按规则在节点流转, 指定某些节点, 或某些记录。动作流程短路 motion # 一次动作，如新建，移动，删除。 规则 # 该次动作对记录的验证 fomula # 计算motion次序 历史 # 动作历史 权限 kind # pass或 type、model、property、节点、节点from, 节点to 的任意组合 access # 分不同kind划分具体权限, 如(节点from, 节点to)kind的转移权限 pass权限 # 如创建type, 创建model, 某节点所有权限等 计划 # 定时或周期的流转 适配器boss # action # 存http地址，参数名，验证器 code # 业务，如用户套餐 mode: get/post/put/delete # 如获得套餐，添加套餐，修改套餐，删除套餐 ctx # 参数map, action调用前后修改 next # 下个触发action history_action # action调用历史 suite # 带参action, thunk待触发 price # 标价 tag # 用作商品分类 order # 用户关联到suite, 计费 category # 生成action模板 apps/plugins # 由category生成, 多个带形参(如app_id)action, 封装成的模板。添加实例填入实参 role permission # action code type # action, suite等 access # crud和其它自定义权限 工作流 # 本质 状态管理 工作流重流程轻数据，业务重数据轻流程。工作流修改数据，数据触发工作流 标准 BPMN # omg制定 workflow XPDL # WfMC制定, xml, 复杂 思路 # 模型驱动架构(MDA) petri nets 有限状态机(FSM) # 并行(流水线)状态机 活动图 # JBoss使用 事件过程驱动链(EPC) 微内核 # 安全性高, 降耦合 已有实现 开源 yawl, jbpm, activiti, osworkflow, jboss, shark, obe 商业 aws, salesforce, sap等 分层 外设层 # 交互协议 网关(WAPI) 交互代理 # 网关与内核通信形式 引擎 # engine specification, case net netRunner continueIfPossible # 遍历task, fire task, condition task join, split # and所有, xor只一个, or规则 workitem flow persisting gateway 引擎运行服务 # 为引擎提供服务, 如解析流程定义、流程实例存储、参与者(workItem)解析、脚本计算、事件监听等 扩展实现 支撑 组织模型适配 人工task实现人工接口 流程实例存储 执行器中嵌入 其它应用适配 # 如邮件 内核获取环境资源 执行器定义扩展 应用适配扩展接口 操作流程定义 任务分配 辅助 条件验证 # 可以有外部验证器 分支时判断 事件处理/function处理 抽象的客户操作 # 如退回、跳转等 增强 自定义策略(workItem), 如代理人处理、工作日历(任务期限) 工作项分配、执行、提交 事件监听 超时处理 订阅应用事件, 应用时间触发器 基础组件 数据中台 # "},{"id":41,"href":"/docs/architect/method/advice_plan/","title":"咨询规划","section":"Method","content":" Presentation # 指导思想: 成于结构，臻于对话 PPT画页 画的是冰山一角 类似手持卡片 类似左右脑: 逻辑+展示 具体内容 思维导图 维度筛选，MECE不重不漏 空姐现象 共知的事情特色讲，去掉已知部分 卖钻讲孔 电梯法则 告知全局，步骤清晰，回顾小结 递进逻辑：信息，分析，方法 目录 首页效应 目录，章节页，总结页 视觉 图形代替文字: 缩小了看一看 标题附主题语: 有兴趣有信息量 讲 替画重点（提示语如: 请注意，提问） 细讲：页只写观点，串联起来讲，只有30%内容重合 心态 注意力放在观众那边 沟通合作而非防御 房间有更聪明的人 数字化转型 # 什么是数字化，有什么用 发展 信息化: 烟囱式，信息/数据孤岛，管理/运营孤岛 互联网化 互联互通: 0边际成本互联互通，云计算-\u0026gt;雾计算 大数据化 数据互联: 互联一切-\u0026gt;一切互联，跨界应用 数据资源: 核心要素/资产，第一权利 数智化 人工智能：大数据-\u0026gt;大知识, 人类设计-\u0026gt;自动学习，替代与超越 计算智能-\u0026gt;感知智能-\u0026gt;认知智能 三位一体：(互联网+大数据+人工智能)+ Any 数字孪生、元宇宙 互联网+ 信息传递边际成本趋向于0 连接机制革命 任意两个资源(人或物)0边际成本互联互通: 信息0边际成本 传播机制: 线性、金字塔式-\u0026gt;非线性、网状、几何级、病毒式 带来什么 数字科技三位一体：(互联网+大数据+人工智能)+ 边际革命：0边际成本效应，边际成本递减，边际收益递增 数智：可知、可达、可控、可预测，程度剧变、实现边际成本剧变 量变-\u0026gt;质变（工具革命-\u0026gt;革命的工具） 局部改善-\u0026gt;全面优化-\u0026gt;全面重构 技术应用-\u0026gt;业务优化-\u0026gt;全面变革 农业时代，工业时代，数字时代，造物时代 为什么数字化转型 企业处境 各行各业先后 总量短缺-\u0026gt;结构过剩，卖方市场-\u0026gt;买方市场，存量经济的争夺内卷加剧 成熟稳定期-\u0026gt;跃迁剧变期 各行各业被迫转型：不断重新分工、重新分利 产业链 重构/(替代+重构) 战略问题 不是未来做什么，是做什么有未来 提高打鱼技术但鱼没有了 不要战术勤奋战略懒惰, 战术成功战略失败 不是选择题是必答题 什么是企业/产业数字化 IBA+经济 电子商贸，流通 不是虚拟经济，是实体经济的全新形态 IBA+交易 渠道体系革命 线上渠道为主，主导线上线下一体化 终端(触点)为王 与用户空间时间距离不断缩短 一切皆终端，终端多样化-\u0026gt;场景碎片化(场景嵌入)-\u0026gt;新旧场景兴衰 泛在智能交互，泛在智能感应(不断向生产环节渗透) 交易边际成本大幅下降, 交易可能性边界急剧膨胀，资源配置能力与利用效率极大提高 产业链重构：M2B2C, M2C, P2P 野蛮营销-\u0026gt;精准营销-\u0026gt;智能匹配 产品变渠道，产品渠道一体化 智能产品-\u0026gt;触点+服务与生态体系 产品成为持续服务的载体 制造业服务业化 智能化，机器体系对人的脑力及体力的强助力、替代、超越 精细化、高度集成化 去人化、极致自动化 柔性化，按需生产、柔性制造能力 IBA+生产 业务跨界与跃迁：供应链资源，数据资源，新“物种”(产品) 低碳、低能耗、低消耗: 自然资源稀缺性下降 IBA+交易+生产 交易生产一体化 由需到供，按需生产，按需服务，按需研发，按需投资，0库存 非标-\u0026gt;标准化-\u0026gt;去标准化(个性化生产) 卖产品-\u0026gt;卖生产服务，制造业服务业化 延展到整个国民经济生态体系，有计划的市场经济 数据驱动，智能决策 平台化+极致专业化分工 企业(管理与产权)形态、雇佣形态的演变 管控型-\u0026gt;交易型/平台型 企业人员规模缩小，企业边界模糊 企业、资本与劳动者关系演变 数字化转型 数字经济质跃工业经济 数字经济系统 经济环境: 人类经济活动(分工协作)的基础条件(信息不对称性，资源稀缺性)发生剧变 经济活动: 交易和生产的边际成本大幅下降，经济活动的效率大幅上升，经济活动的可能性边界急剧膨胀 从根本上超越工业经济 数字化经济含义 交易、生产：0边际成本 边际革命：人类逐步进入0边际成本时代 边际成本递减-\u0026gt;0边际成本-\u0026gt;边际成本为负 结果变成原因，逼近转型升级 数字化转型升级 以数字科技为应用手段，持续推进业务变革、组织变革 经济的数字化转型升级: 以数字科技应用为手段，推进经济模式、经济形态持续转型升级 企业数字化转型升级：以数字科技应用为手段，推进企业营销模式、服务模式、管理模式、生产模式、决策模式、商业模式、产权模式等持续转型升级 鸿沟：科技\u0026lt;-\u0026gt;业务 可能性(无限)-\u0026gt;现实性(有限) 科技-\u0026gt;技术应用(产品/模式/制度创新变革)-\u0026gt;业务问题-\u0026gt;科技应用创新不足是制约转型升级、创新发展的关键瓶颈 问题导向，需求拉动 科技应用价值问题：经济效益是检验科技领先的唯一标准 科技应用方向问题：0到0的创新比0到1的创新更关键 科技应用的路径问题：并非都是\u0026quot;富家子\u0026quot;\u0026quot;优等生\u0026quot; 转型是什么 三个层次 新赛道(局部): 新技术、新产品、新兴产业链 新形态(普遍): 新业态、新模式、新型产业链 新经济(全面): 新生态、新格局 企业：全面转型或K型经济 可行方法 你是谁：业务现状 你想变成谁 动因与目标(短期、长期) 问题导向与需求分析 你能变成谁 基础条件与既有资源 信息化数字化的基础 你如何变成谁 (周而复始)设计-\u0026gt;建设-\u0026gt;运营(业务+系统)-\u0026gt;跟踪与评估 得客户资源者得天下 流量-\u0026gt;留量 客户资源：客户数据+客户关系+客户渠道 以更低边际成本掌控更大的客户资源 谁掌握完备的客户资源 如何掌握完备的客户资源 未来已临 划时代的技术都是试金石 与时代赛跑 实施 本质 数字驱动的用户中心观, 不是业务中心观 增长三角：规模、分工、效率 思维: 大数据、区块链 用户价值: 一个框架: 价值创造，用户挖掘，用户数据，个性化服务，差异化用户保留 一个目标: 每个用户\u0026quot;精耕细作\u0026quot; 一个重点: 数字化全链路管理，全场景营销, 全渠道服务 价值网络: 一个核心 商业模式 Costco\u0026quot;复利高墙\u0026quot; 差异化价值、服务对象、盈利模式+核心能力 数字化会员：精准预测，精准选品，自有品牌 供应链 问题：牛鞭效应，不确定效应 解决：基于数据观察趋势，不预测趋势 增长飞轮 数字化加速技术分层分化, 技术模块化 运营卓越: 上游核心技术，下游用户亲密 数智化转型 # 技术：人工智能，区块链，云计算，大数据，边缘计算 管理：科学管理-\u0026gt;人本管理-\u0026gt;精益管理-\u0026gt;价值共生 重塑思维 战略转型方向 管理变革 商业模式 重塑领导力 数字化营销 # 4P: 产品、价格、渠道、推广 4C： 消费者(Consumer)、成本(Cost)、便利(Convenience)、沟通(Communication) 4R: 关联(Relevance), 反应(Reacton), 关系(Relationship), 报酬(Reward) Marketing Jungle: 及时性、社会性、精准性、方便性 CIDR Contact: 全渠道(全场景): 在商，在家，在途 Identify: 二维码，小程序，人脸，Beacon Data: 数据标签(分级分群) Reaction 大数据营销 3V: 数量(Volume)、速率(Velocity)、多样(Variety) 维度 身份象征: 年龄、身高、性别、居住地 生活风格: 朝九晚五、泡吧达人、工作狂 消费行为: 购买时间、购买方式、促销敏感 社交行为：意见领袖、意见跟随者 商品偏好：咖啡达人、面包达人 RFM: 最近消费、消费频率、消费金额 升级：金字塔(二八原则) 挽留 精准营销：相关分析、逻辑回归分析、购物栏分析、标签群体聚类分析 私域 进(获客) 线下：自然来客、地推 会员裂变 大数据：探针法、数据交换法、WiFi法 产品为王 线上引流：SEO, SEM/关键字投放, ASO, CPS(按销售付费), DSP(跨平台), Banner, 嵌入代码/挂件，微信/社交/短视频 活(激活) 不删: 电子会员、交互平台、创造场景 关卡：产生兴趣、激发欲望、消除顾虑(七天免费)、立刻行动 粘(粘性) RFM分群 R: 最近一次消费 F: 消费频次 M: 消费金额 增加粘性: 次数带动，品类带动，场景带动 值(客户价值) CLV=贡献价值 - (取得成本+维系成本) 荐(裂变) 原因: 创造价值 获客 方法 分享, 红包，IP,亲子，团购, 朋友 移动营销 优势：实时在线、高效传递、多媒体负载、瞬间反应 特色4I: 个性化(I)、互动(Interactive)、分众识别(Individual Identification)、实时信息(Instant Message) 设备：二维码、App、小程序、穿戴技术 MAC Address: 基地台，路径 Beason: 室内 DSP: 标签种植 限制：隐私侵犯、推送用APP未打开、设备更换 七个瞬间 场景: 时间地点，和谁一起，当前感觉，需要什么; 和上次一样 位置距离: 地理定位，地理围栏，地理征地 时间 实用性产品(效率): 早上 享乐型产品(心情): 下午 天气 影响心情 预防性框架 轨迹 社会: 和谁一起 拥挤度 社交媒体 pay media, earned media, owned media 社群 粉丝: 目的 企业：目的 方式 找兴趣, 嬴关注 造品牌, 聚粉丝 场景思维 围绕产品 围绕时间 围绕特定事件 内容营销 步骤 任务规划：对象、目的、场景 阶段性目标：粉丝数、活跃度、互动数、观看数、展示数、流量数据 内容创意：起承转合, story board 标题、价值(有趣、有利)、为什么转发(显示一手信息、表达立场、自娱娱人) 确定渠道: 对象，内容类型，流量机制 评估学习 内容策略 热点性内容 即时性内容 生活故事内容 方案或学习性(生活小贴士) 连载性内容 促销性内容 全流程整合 交易平台: 微商、微店(企业内店、第三方平台)、微商城 分润机制: 入会条件、会员等级、推荐提成、等级折扣 企业管理 # 战略 目标：使命，愿景 分层 企业层面战略 业务单元层面战略（竞争战略） 职能层面战略 管理 战略分析阶段 战略选择阶段 战略评价阶段 战略实施阶段 战略控制阶段 优化咨询 # 问题 客户反馈 单体应用 模块耦合程度 微服务划分与边界 单节点数据库 查询崩溃 IoT控制 命令超时失败, 响应慢 出错业务处理 发现问题 现有代码逻辑梳理 通过链路追踪，找性能瓶颈 SQL平台建设，发现数据库性能问题，优化SQL 服务器节点监控，应用监控，数据库监控 解决问题 代码 纯代码优化：N+1调用，事务问题 逻辑优化：订单失败，复杂业务流程优化 发布流程优化CI/CD 中间件优化：优雅停机，灰度方案节点打标，全链路日志 性能优化：业务并行处理，业务异步处理 数据库 不合理调用治理：批量更新，大事务， 慢SQL治理 数据库备份：主从优化，定时备份 配置调优 架构 高可用：服务发现，分布式 业务缓存优化，减少数据库调用：热点数据，对象缓存，多级缓存 分布式任务平台：分片执行 任务中心：批量平台 稳定性 告警平台 异常告警(空指针，接口调用成功率) 监控告警(服务器使用率) 业务告警(下单失败) 限流熔断 网关限流，业务限流，接口限流，外部调用限流 业务平滑处理 运营工具 业务数据多维分析 "},{"id":42,"href":"/docs/architect/method/architect/","title":"服务治理","section":"Method","content":" 原则 # 高并发 高可用 高可靠 SLA(service level agreement)制定(吞吐量、响应时间、可用性、降级方案) 容量规划(流量、容量) 监控报警(机器负载、响应时间、可用率) tracing 应急预案(容灾、降级、限流、隔离、切流量、可回滚) 成本 经济学原理 比较优势 服务器类型 分工协作 组合 货币解耦 MQ 规模效益 集群 高可用 # 负载均衡 # 流量切换 # 某服务器挂了 DNS切换 httpDNS # app配置，绕过运营商localDNS lvs/haproxy # 切换故障的nginx nginx # 切换故障应用 限流 # 思路 恶意请求流量只访问cache 穿透到应用的流量用nginx limit 恶意ip nginx deny 降级 # 开关集中化管理, 推送开关配置 开关前置 # nginx层做开关 可降级读服务 # 只读本地缓存、只读分布式缓存、只读默认数据 业务降级 # 部分业务异步，处理高优先级，分配流量保障系统可用 隔离 # 线程隔离 进程隔离 集群隔离 机房隔离 读写隔离 动静隔离 爬虫隔离 热点隔离 资源隔离 回滚 # 事务 代码库 部署版本 数据版本 静态资源版本 超时与重试 # 压测与预案 # 线下、线上 高并发 # 缓存 # 客户端 浏览器缓存 # Pragma, Expires, Cache-control ajax app缓存 # 大促时更新静态资源, 地图 客户端网络 # 代理服务器缓存 广域网 代理服务器(如CDN) 推送 或 拉取(回源) 镜像服务器 P2P 源站 接入层缓存 # 如页面缓存，用redis url重写 一致性哈希 proxy_cache # 内存/SSD缓存内容 proxy_cache_lock # 一段时间的回源合并成一个 shared_dict # lua, 重启缓存不丢失 应用层缓存 # 如搜索，建议物品等 堆内缓存 堆外缓存 # local redis cache 分布式缓存(接入层后) redis集群 # 异步化写入, lua-resty-lock(非阻塞锁) 对象缓存 # db和应用间的查询结果集 静态化, 伪静态化 服务器操作系统缓存 连接池线程池 # 异步化 # 队列 # 作用 服务解耦 异步处理 流量削峰/缓冲 # 如促销期 问题 丢失/失败 # 持久化，日志，报警, 数据校对修正(worker扫库) 重复 # 业务上防重 例子 redis扣库存-\u0026gt;记录日志-\u0026gt;同步worker-\u0026gt;DB 消息总线可扩展 # x扩展不行，y扩展用专用总线(降低了灵活性), z扩展根据客户 减少拥挤 # 消息划分价值 扩容 # 无状态 # 应用无状态，配置有状态 尽可能浏览器端维护会话 分布式缓存放状态 拆分 # 加法组合，乘法功能 # 项目死于1到10，或10到100，因为解耦不够，无法重构 业务拆分 功能细分 读写 # 读缓存，写分库分表，聚合数据 AOP # 如CDN 模块 # 代码特征，如基础模块分库分表，数据库连接池 数据异构 例子 聚合数据表(一般KV存储) # 数据闭环(不依赖其它服务) 历史归档 并发化 选择工具 数据库 # rdb, nosql, hadoop 防火墙 # 墙需要的东西 日志 # 采集分析 用同品牌设备 慎用第三方 容错 隔离 # 不同步调用，限制异步调用(数量和超时)，能迅速发现故障 不单点 # 一切都出故障 不系统串联 功能支持启用禁用 # 实现wire on/wire off框架 服务方法 # 成本分析 # # autonomy.design 表现 一个需求拉很多人，代码写进来就删不掉了 通用功能要么多种实现，要么参数过多 线上问题难定位，本地做不了有意义的测试，反馈周期特别长 本质 减少沟通 autonomy(自治): 减少沟通，功能可以删掉 问题: 产品从整体效果出发，开发从实现出发 依赖倒置 UI插槽, 服务集成 实现(服务) 编译时: 模板、函数替换 运行时: 组合对象、组合函数 实现(UI) 编译时: 页面模板替换, 显式组合与隐式组合 运行时: Vue插槽 feedback(反馈): 故障定位，测试反馈，发版反馈，用户反馈无响应 控制边界 进程 跨进程调用监控: 基础设施完善 OS强制配额、安全性: 基础设施好 内存隔离 函数 caller/callee索引: 同步调用栈、异步调用链、组件树 问题: 日志多，负责模糊 插件 控制变更 多进程 多进程部署 多租户 多变种 配置中心下发开关 consistency(一致性): 工具复用 用户可见的一致性: UI/UE设计，前端落地 autonomy: 上层业务推动 问题: 依赖修改要慎重 feedback: QA, KPI 拆分 组合关系 加法 乘法 一致性复用 扩展方式 # 服务化发展 进程内服务 单机远程服务 集群手动注册服务(nginx负载多实例) 自动注册和发现服务(zookeeper) 服务分组/隔离/路由 服务治理(限流/黑白名单) AKF扩展立方 x轴 横向复制 # 复制服务或db, 瓶颈：内存缓存、特有数据 y轴 面向功能、服务、资源拆分 # 微服务 动词拆分 # 登录、搜索、推荐等 名词拆分 # 目录、库存、账户等 z轴 拆相近东西 # 数据分片(大小客户、地区、新旧等) 横向扩展 # 复制服务或数据分散负载，纵向扩展是升级设备 使用经济型系统 扩展数据中心 # 三实时站点备份: a(0.5b, 0.5c), b(0.5a, 0.5c), c(0.5a,0.5b), 尽量分散 使用云 微服务 # 单体应用问题 复杂: 模块多, 边界模糊, 依赖关系不清晰, 代码质量不统一 技术债务: 不坏不修 部署频率低: 迭代要部署整个应用，部署时间长，风险高。修复问题慢, 易出错 可靠性差: 某bug导致整个应用崩溃 扩展性差 阻碍技术更新 特征 服务组件化 按业务组织团队 负责的态度, 不再是交付给维护者 粗粒度通信, http(二进制协议)或消息总线 去中心化治理 去中心化管理数据 基础设施自动化 容错设计 演进式设计 原则 单一职责 自洽 轻量级通信 服务粒度: 边界(DDD中的界限上下文) 持续发布 工具链，自动化 契约 架构守护 灰度替换 *aaS SaaS(software as a service) PaaS(platform as a service) aPaaS(application PaaS) # 简单配置产生任意需求的application saPaaS(specific aPaaS) # 领域定制的aPaaS GaPaaS(generator of aPaaS) # 脚手架，产生定制的aPaaS 云原生 # 介绍 cloud navtive, Pivotal 2013年提出 12-Factor 1 基准代码(code base) 一份代码，多份部署 2 依赖(dependences) 显式声明依赖 3 配置(config) 配置存储于环境变量中 环境变量粒度足够小，相对独立 4 后端服务(backing services) 后端服务作为附加资源, 与第三方服务不区别对待 5 分离构建、发布、运行(build, release, run) 构建: 代码转化到可执行包 发布: 可执行包结合配置 运行: 选定发布版本，按计划启动 6 进程(process) 多个无状态进程运行 7 端口(port binding) 网络服务通过端口绑定提供服务 完全自我加载不依赖网络服务器 8 并发(concurrency) 进程作为一等公民 通过进程模型扩展并发 9 易处理(disposability) 进程快速启动、优雅终止可最大化健壮性 追求最小启动时间, 收到SIGTERM优雅终止，突然死亡时保持健壮 10 环境等价(dev/prod parity) 开发环境等价线上环境 11 日志(logs) 日志作为事件流 应用本身使用stdout事件流，不考虑存储输出流，不管理日志 12 管理进程(admin processes) 管理进程不常驻, 一次性运行 使用同样环境、代码版本、配置、依赖隔离, 避免同步问题 提供REPL shell使一次性脚本变简单 Service Mesh # 处于 TCP/IP 之上的抽象层 Serverless # 只写业务代码，不关心服务器运行状态 BaaS # Backend as a Service FaaS # Functions as a Service "},{"id":43,"href":"/docs/architect/","title":"架构","section":"Docs","content":" 要求 # \u0026quot;我这辈子收到的最好的职业建议是在日本实习时， 一位长者跟我说的：年轻人最重要的是建立好的自己名声。这里的名声不是指沽名钓誉。而是每一篇论文，每一次演讲，每份交接给同事的工作，凡是给别人看的东西，都要在能力范围内做到至善至美。慢慢养成习惯，就会越做越好。凡事糊弄人的人，是走不远的。\u0026quot; 要求归纳 # 个人 责任心，抗压力 技术与产品 专业知识，设计指导关键模块 项目规划，架构前瞻性，风险管理，文档 人员管理 部门结构，人员职责 培养与考核 内部工具 开发运维 测试 销售目标 营销团队组建及管理 销售方案，品牌方案 市场调研 目标，考核，监督 招聘人员要求 # 不是我负责的，态度也要积极 项目经历是否有帮助 人员稳定性 代码不挖坑 沟通总结能力(micheal) 工时制度管理 "},{"id":44,"href":"/docs/architect/strategy/ai/map/","title":"知识图谱","section":"AI","content":" 与深度学习区别 # 深度学习是显性模型，知识图谱是隐性模型 场景：人脸识别；语音助手 目前进展: 在一些任务上已超过人类；知识量超过人类，推理不如人类 任务范围：面向具体任务，难以迁移；广泛适用于不同任务 可解释性：较难解释；可解释性强 数据量：海量训练数据；海量知识数据 未来趋势：深度融合 历史 # 2010年: 微软构建Satori、Probase 2012年: 谷歌X实验室识别\u0026quot;猫\u0026quot;, 发布Google Knowledge Graph 2013年：百度布局 2015年：阿里布局 2016年：亚马逊布局 特点 # 视觉思维 关联 推理 结构识别 降维 概念图 网络模型 潜在领域寻迹 领域 # 宇宙图谱 绘图学 陆地地图 天体图 生物图谱 轨迹 旅行商 虚拟世界搜索 信息觅食，过程建模 应用 # 内容理解 篇章理解 推荐场景 路径推荐 知识融入推荐 广告 召回排序 智能营销 画像 用户画像 产品画像 场景画像 库 概念库 语义本体库 规则库 建模分析 分词、词性标注、命名实体识别 句法分析、语义表示、概念发现 用户打标、场景打标、产品打标 语义匹配、指代消解、主题模型 搜索理解 语义搜索 演化分析 场景化搜索 路径召回 对话理解 商家 智能化商家运营 商业大脑 商业分析 可解释性 图谱路径推荐理由 知识融入生成推荐理由 实体卡片 资源聚合 内容分发 产业链图谱 用户画像 高管画像 价格图谱 债券风险预警 中小企业风控图谱 营销获客图谱 产品与工艺创新研发 安全质量 供应链 社会关系图谱 交易关系图谱 网络图谱 时空关系图谱 任务自动化 维度：可发现、可移接、可推理 自动化：自动数据结构化、流程自动化、业务服务化、服务开放化 推理 本体推理 概念补全 商品品类上下位发现 同质类目/属性项/属性值识别，新类目发现 实体识别与分类 关系抽取 实体对齐 实体链接 商品分类、增量商品分类、商品标题 常识推理 关系推理与链接预测 规则学习 百科知识发现 商品对齐 可比价同款规则挖掘 知识问答 知识增强学习 知识融入语言预训练 人货匹配 网络安全 专家系统-\u0026gt;感知智能-\u0026gt;认识智能-\u0026gt;决策智能 流程 # 数据爬取 数据爬取平台 知识获取 实体识别 概念、关系、属性抽取 标签挖掘 情感分析 知识融合：概念层融合，数据层融合 知识建模: 概念上下位关系生成、概念属性识别、规则建模、事件建模、时空建模 多元异构数据 非结构化文档 半结构化数据 结构化知识 抽取模块 基于规则 基于模板 基于模型 经典模型: PCNN、BiLSTM 预训练模型: BERT、摩天 预/后处理 先验知识库: 规则库、领域词表、模板库、黑白名单 数据集构建：人工标注、远程标注、数据集管理 知识融合 Schema对齐(异构转同构) 数据清洗 实体对齐(去重，消岐) 属性择优 知识关联 规则推理 建边模型 存储检索 图引擎 图存储引擎 图学习引擎 图查询引擎 优化 KV库 索引库 控制和数据分离 Schema压缩 知识计算 知识补全 知识推理 知识统计与图挖掘 知识图谱金字塔 文本(text)-\u0026gt;标签(label、tag)-\u0026gt;表格(table)-\u0026gt;图(graph)-\u0026gt;模式(schema)-\u0026gt;本体(ontology)-\u0026gt;规则(rule) 技术 计算：Spark 中间存储：HIVE 检索：ES 监控体系 知识管理系统 框架 # Spark HIVE ES 工具 # CiteSpace Jigsaw Carrot iOpener "},{"id":45,"href":"/docs/basic/computer/principle/","title":"支撑-原理","section":"Computer","content":" 主机 # cpu # 介绍 单cpu串行工作，前任务完成，后任务才开始 # 串行不适合图形处理(多点，线，面要同时乘投影矩阵) cpu把大量空间和电量分配给控制器和缓存，不能集成太多计算单元 cpu内存通过cpu总线连接, cpu总线与pci总线通过主桥(北桥)连接 gpu在pci总线上 控制逻辑在cpu中运行, 生成渲染数据, 到内存, 再到显存显卡计算。 内存到显存数据传输最花费时间。 原理 处理单元(processing unit) 算术逻辑单元(arithmetic logic unit) 处理寄存器(processor register) 控制单元(control unit) 指令寄存器(instruction register) 程序计数器(program counter) 指令集架构(ISA, instruction set architecture) # 机器码易兼容, 软件易编程, 易升级cpu 精简指令集RISC(reduced instruction set computing) 复杂指令集CISC(complex instruction set computer) 时钟频率(clock speed) 生产 生产线散热决定生存率，决定cpu型号 多级缓存 L1, L2, L3, L4 虚拟化 虚拟机监视器(VMM, virtual machine monitors) 分类 指令流的重数分类 SI(single instruction stream)单指令流 MI(multiple instruction stream)多指令流 操作数流的重数分类 SD(single data stream)单数据流 MD(multiple data stream)多数据流 SISD 串行计算机 SIMD 阵列机(多处理单元) MISD 很少 MIMD 多处理机 多计算机 硬件并行 位级(bit-level): 32位, 64位计算机 指令级(instruction-level) # 处理器内部并行度很高 流水线 指令分步骤(指令流), 每步专门部件处理 多指令流并行, 部件不空闲等待单指令流结束 六级流水线步骤 取指(FI), 译码(DI), 计算操作数地址(CO), 取操作数(FO), 执行指令(EI), 写操作数(WO) 多发射(超标量) 一时钟周期处理多指令 超线程 模拟多个逻辑线程 乱序执行 猜测执行 数据级 向量体系结构、图形处理器 单指令多数据(SIMD)架构 线程级 # 紧耦合硬件模型中开发数据级或任务级并行，线程间有交互 请求级 # OS或程序耦合任务间并行 程序并行 数据级(DLP, data-level parallel) 任务级(TLP, task-level parallel) # 多处理器, 超线程, 虽只有4个核，但可用核返回8 内存 共享内存模型 分布式内存模型 进程: 独有内存 线程: 共享进程内存(地址空间、文件描述符) 一个进程下的轻量进程 POSIX线程api是对已有unix进程模型扩展, 与进程多方面类似 自己的信号掩码 cpu affinity(倾向在某cpu尽量长时间运行) cgroups 进程调度 # 等级 高级调度(High-Level Scheduling) 作业调度, 后备作业调入内存运行 低级调度(Low-Level Scheduling) 进程调度, 就绪队列中某进程获得cpu 中级调度(Intermediate-Level Scheduling) 虚拟存储器引入, 内外存对换区进行进程对换 方式 非剥夺方式 处理机分配给某进程后一直运行下去,直到阻塞时,才分配处理机到另一个进程 剥夺方式 进程运行时,系统基于某种原则,剥夺分配给它的处理机. 采用算法 先进先出算法 批处理系统用. 总把处理机分配给最先进队的进程, 将一直执行下去,直到阻塞 短进程优先(SCBF Shortest CPU Burst First) 批处理系统用. 从就绪队列中选出下一个cpu执行期最短的进程,分配处理机 轮转法 分时系统中,都采用时间片轮转法 gpu # 介绍 gpu控制单元少, 计算单元多 显卡在pci总线上 原理 数据级并行 单条指令并行应用于数据集(SIMD) CUDA(compute unified device architecutre) # nvidia推出的通用并行计算架构 多网格(grid)组织，每网格多(512-1536)线程块 线程块线程相同指令地址, 通过共享存储器(shared memory)和栅栏(barrier)块内通信 不同块不通信，粗粒度并行 同块通信，细粒度并行 内存 # 原理 虚拟内存(virtual memory) 页表(page table) 控制寄存器(control register) CR3保存页目录表内存基地址 4级页表(PML4) 转换检测缓冲区(TLB, translation lookaside buffer) dma # direct memory access 不依赖cpu的内存存取 栈 申请方式: 系统自动分配 申请响应: 栈剩余空间小于申请空间, 报overflow 申请大小限制: 栈是向低地址扩展的连续内存，线顶地址和最大容量是系统编译时预设的，windows下为2M(或1M), 申请超过剩余空间报overflow 申请效率: 系统分配，速度快 存储内容: 函数调用时，函数调用语句的下一条指令的地址进栈，然后是参数(C中由右向左), 然后是局部变量。调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向开始保存的函数下一指令，继续运行 数据结构: 满足后进先出的数据结构 堆 申请方式: 程序手动申请 申请响应: os有记录空闲内存地址的链表，申请时遍历链表，寻找第一个空间大于申请空间的堆结点，该结点从空闲结点删除，节点分配给程序。自动将多余部分重新放入空闲链表 申请大小限制：堆是向高地址扩展的不连续内存，系统用链表存储空闲内存地址。受限于有效虚拟内存 申请效率: 慢，容易产生内存碎片 存储内容: 堆头部一个字节存放堆的大小。内容由程序员安排 数据结构: 满足优先队列的数据结构(第1个元素有最高优先权) 网络 # ABR(area border router)：区域边界路由器 子网隔离 状态 # cookie # 介绍 cookie的弊端 数据在客户端可以被修改，所以不能存重要数据 cookie中字段太多会影响传输效率 请求头 set-cookie # 规定cookie的格式为name = value 响应 path # cookie发送的相对路径 expires和maxAge # expires是UTC时间, maxAge是cookie多久后过期 ## 不设置这两个时产生的是session cookie, 它是transient的，用户关闭浏览器时清除。一般用来保存session_id secure # true时, cookie在HTTP中是无效的, 在HTTPS中才有效 httpOnly # 通知浏览器不允许脚本操作document.cookie。一般都应设置为true, 可以避免被xss攻击拿到cookie 签名( 信息摘要算法) 原user='alsotang' 现user=sha1('my_secret' + 'alsotang') === 'xxxx...xxx' session # 介绍 session通过cookie中存放session_id来实现 可以存放在 1. 内存 2. cookie本身 # 不用担心集群的状态共享问题，安全性可以遵照最佳实践来，也是有保证的，最大的弊端在于增大了数据量传输。有受到回放攻击的危险 3. redis或memcached等缓存 # 常用 4. 数据库中 OSI分层 # 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 数据链路层 # 分层 数据链路层分为两层 llc上层子层 # Logical Link Control 逻辑链路控制。 mac下层子层 # Media Access Control 介质访问控制层 帧(frame)传输 网络驱动程序成型帧, 网卡发送到网线上，到达目的机器，以网络驱动程序解析 协议 以太网 令牌环 HDLC 帧中继 ISDN ATM IEEE 802.11 FDDI PPP mac Media Access Control mac帧结构 单位 字节 帧类型/长度（TYPE/LEN）： 该字段的值大于1500时，表示上层数据使用的协议类型。例如0x0806表示ARP请求或应答，0x0800表示IP协议。 该字段的值小于1500时表示以太网数据的长度，上层携带LLC-PDU。 帧校验FCS： 以太网采用32位CRC冗余校验。 llc Logical Link Control llc-pdu结构 pdu : 协议数据单元 dsap : 目标服务访问点 ssap : 源服务访问点 控制位 : 三种 arp Address Resolution Protocol # arp属于中间层，为ip层服务协议 arp帧结构 arp协议的分组格式 arp在windows命令提示行下的命令 arp -a 查看arp缓存表中的内容 arp -d 清空arp缓存表 网络层 # 数据包 接收 # 一般情况下，网络上所有的机器都可以“听”到通过的流量, 但对不属于自己的数据包则不予响应 ## 网卡到混杂模式，可以捕获网络上所有的数据包和帧 广播包 可达到局域网中的所有机器 单播包 到达处于同一碰撞域中的机器 协议 IP Internet Protocol 网际协议 ICMP Internet Control Message Protocol internet控制报文 IGMP Internet Group Management Protocol internet群组管理协议 IPX BGP Border Gateway Protocol 边界网关协议 OSPF Open Shortest Path First 开放式最短路径优先 RIP Routing Information Protocol 选路信息协议 IGRP EIGRP ARP RARP Reverse Address Resolution Protocol 反向地址解析协议 X.25 NAPT Network Address Port Translation 网络地址端口转换 ASBR Autonomous System Border Router 自治系统边界路由器 icmp Internet Control Message Protocol # Internet控制报文协议 是ip层的子协议 封装 报文格式 主要报文类型 时间戳报文举例 重定向报文举例 igmp Internet Group Management Protocol # Internet组管理协议 报文格式 8位IGMP类型 8位响应时间 16位检验和 32位组地址(D类IP地址)） ospf Open Shortest Path First # 开放式最短路径优先。是一种典型的链路状态路由协议。 ## 采用OSPF的路由器彼此交换并保存整个网络的链路信息，从而掌握全网的拓扑结构，独立计算路由。 报文 版本 类型 报文长度 路由器标识符 区域标识符 检验和 鉴别类型 鉴别 鉴别 OSPF报文（有五种类型） 问候(Hello)报文：发现及维持邻居关系，选举DR、BDR。 数据库描述(Database Description)报文：描述本地LSDB的情况。 链路状态请求(Link State Request)报文：向对端请求本端没有或对端更新的LSA。 链路状态更新(Link State Update)报文：向对方更新LSA。 链路状态确认(Link State Acknowledgment)报文：收到LSU报文后，进行确认。 bgp 介绍　border gateway protocol 边界网关协议\nip # Internet Protocol # ip地址是互联网主机的唯一标识 ip地址分类 A类 : 0.0.0.0 \u0026ndash; 127.255.255.255 (0段和127段不使用) B类 : 128.0.0.0 \u0026ndash; 191.255.255.255 C类 : 192.0.0.0 \u0026ndash; 223.255.255.255 D类 : 224.0.0.0 \u0026ndash; 239.255.255.255 E类 : 240.0.0.0 \u0026ndash; 254.255.255.255\n特殊ip地址 主机地址全0 : 作为网络本身的标识 , 称为网地址 主机地址全1 : 广播地址 ， 称为直接广播地址 32位全1 : 称为受限广播地址 内部地址 10.0.0.0 -- 10.255.255.255 : 一个A类 172.16.0.0 -- 172.32.255.255 : 16个B类 192.168.0.0 -- 192.168.255.255 : 256个C类 子网 # 把ip划分为网络地址和主机地址 作用 便于网络管理、提高系统性能 子网掩码 # 同ip地址一样长 ， 不分离部分为1，分离部分为0 知道子网掩码后算出 网络地址 广播地址 地址范围 本网有几台主机 ip数据报文格式 ip分片 # 一个MTU（链路层）较大的网络传输到MTU较小的网络过程中，将一个较大的数据包分为几个较小的数据包来传输。 利用PING命令中的参数–l 可以设置数据部分的字节数 抓包 # sniffer(嗅探器) # 网络层 # 硬件sniffer称为 协议分析仪 原理 利用Ethernet特性, 把nic(网络适配卡，一般为以太网卡), 设为promiscuous(混杂) 几乎能得到任何以太网上传送的数据包 需求 windows BPF linux socket-packet root权限来激活内核支持的Bpfilter(伪设备) 限制 只能抓取同物理网段的包，即与监听的目标中间不能有路由或其他屏蔽广播包的设备 # 对一般拨号上网的用户来说, 不可能利用sniffer窃听其他人通信内容 数据包内容的过滤有一定难度 分类 软件 硬件 举例 NetXray, Packetboy, Net monitor 应用场景 攻陷一台主机后，安装sniffer, 侦听同网段数据包，存到log文件(通常是包含username或password的包)，截获其他主机密码后，登入这台主机。 # 属于第M层攻击，即 在攻击者已经进入了目标系统的情况下 ## 也可以截获金融信息 传输层 # 协议 TCP Transmission Control Protocol 传输控制协议 UDP User Datagram Protocol 用户数据报协议 RTP SCTP SPX ATP IL rts/cts 视频数据传输 udp User Datagram Protocol 封装 报文 有伪首部的报文 # 伪首部只是单纯为了做校验用的 校验和的计算方法 # UDP“检验和”是一个端到端的“检验和”，包括UDP首部、UDP伪首部和UDP数据。 ## UDP12字节的伪首部是为了计算“校验和”而设置的，不参与网络传输。 tcp Transmission Control protocol 报文格式 三次握手 ACK : Acknowledgement SEQ : Sequence SYN : Synchronous 断开连接 FIN : Final d.o.s(denial of service)攻击 # ddos(distributed denial of service) socket socket可以基于tcp或udp 一个socket对应系统中一个端口 # 操作系统中可用端口65535, 所以只能有65535个socket连接 ssl ssl加密(消息, node模块) 非对称生成公私钥(慢) 对称传数据(快) 会话层 # udp传输 netBIOS Network Basic Input Output System # 网络基本输入输出系统 由ibm开发 ## 定义了一种软件接口以及在应用程序和连接介质之间提供通信接口的标准方法。 wins Windows Internet Name Server # Windows网际名字服务 WINS为NetBIOS名字提供名字注册、更新、释放和转换服务， ## 这些服务允许WINS服务器维护一个将NetBIOS名链接到IP地址的动态数据库，大大减轻了对网络交通的负担。 smb/cifs smb Sever Message Block # 服务信息块协议 , 用于计算机间共享文件系统、打印机和其他资源。 cifs Common Internet File System） # 通用互联网文件系统。 ## 微软将原有的几乎没有多少技术文档的SMB协议进行整理， 重新命名为CIFS ## 成为Internet上计算机之间相互共享数据的一种标准。 表示层 # 协议 XDR ASN.1 SMB AFP NCP 应用层 # 协议 HTTP Hypertext transfer protocol 超文本传输协议 HSTS HTTP Strict Transport Security HTTP安全传输 DNS Domain Name System 域名系统 SMTP SNMP FTP File Transfer Protocol 文件传输协议 Telnet SIP SSH NFS Network File System 网络文件系统 RTSP XMPP SIP Whois ENRP DHCP Dynamic Host Configuration Protocol 动态主机配置 BOOTP Bootstrap Protocol 自举协议 tcp传输 # telnet telnet # 一个简单的远程终端协议。用户可以通过TCP连接登录到远程的一个主机上，好象使用远程主机一样。 采用客户机/服务器计算模式。在本地系统上运行TELNET客户机进程，在远程主机上运行TELNET服务器进程。 用于远程管理一台主机 命令 \u0026gt;telnet 192.168.1.200 \u0026gt;Login: group1_1 \u0026gt;Password: group1_1 \u0026gt;按“CTRL+]”回到telnet提示符下 \u0026gt;quit 退出telnet ftp File Transfer Protocol 一个客户机/服务器系统。 端口 : 20或21 # 21用于控制，20传输数据流 smtp simple mail transfer protocol # SMTP协议的最大特点是简单，它规定了发送程序和接收程序之间的命令和应答格式。 基于DNS中的邮件交换（MX）记录路由电子邮件。 通过用户代理程序（UA）完成邮件的编辑、收取和阅读等功能；通过邮件传输代理程序（MTA）将邮件传送到目的地。 传输协议 tcp 常用命令 HELO \u0026lt;domain\u0026gt; \u0026lt;CRLF\u0026gt; MAIL FROM：\u0026lt;邮件地址\u0026gt;\u0026lt;CRLF\u0026gt; RCPT TO：\u0026lt;邮件地址\u0026gt;\u0026lt;CRLF\u0026gt; DATA \u0026lt;CRLF\u0026gt;邮件内容，以＜CRLF＞.＜CRLF＞标识数据的结尾; REST \u0026lt;CRLF\u0026gt;退出/复位当前的邮件传输QUIT \u0026lt;CRLF\u0026gt;关闭传输; pop Post Office Protocol # 邮局协议 是一个脱机协议，它是一个具有存储转发功能的中间服务器。 采用客户/服务器工作模式。 传输协议 tcp 功能 允许本地检索邮件服务器上的邮件 命令 USER \u0026lt;用户邮件地址\u0026gt;指出用户正在连接的邮箱; PASS \u0026lt;口令\u0026gt;输入邮箱的口令; STAT请求服务器发回关于邮箱的统计资料; LIST\u0026lt;邮件编号\u0026gt;返回邮件数量和每个邮件的大小; RETR\u0026lt;邮件编号\u0026gt;返回由参数标识的邮件的文本; DELE\u0026lt;邮件编号\u0026gt;删除邮件编号; QUIT退出; imap Internet Mail Access Protocol # 交互邮件访问协议 ， 本地对邮件服务器中的邮件进行管理 端口 : 143 rtmp 介绍　adobe专利, flash支持, http-flv 介绍　开源流式传输协议，优于RTMP hls 介绍　http live streaming 苹果创建, 延迟较高 html5原生支持 m3u8扩展名，里面封装ts小视频 http # 1.0与1.1区别 扩展性 1.1消息中增加版本号 1.1增加OPTIONS方法 1.1增加Upgrade头域, 客户端使服务器知道它支持的其它备用通信协议 缓存 1.0使用Expire头域判断资源的fresh或stale，使用条件请求(conditional request)判断资源是否仍有效 1.1加了新特性，当缓存对象的Age超过Expire时变为stale对象, cache不是直接抛弃stale对象，而是与源服务器进行重新激活(revalidation) 带宽 1.0中只能下载全部文档 1.1请求消息引入range头域，只请求资源某个部分。响应消息Content-Range头域声明这部分对象的偏移值和长度。 返回范围内容时，响应码为206(Partial Content)，可防止Cache误以为是完整对象 1.1新状态码100(Continue), 事先发送只带头域的请求，服务器因权限拒绝就返回401(Unauthorized)，服务器接收就返回100。避免发送完整请求浪费带宽 1.0不支持状态码100, 可加入Expect请求头, 值设置为100-continue 压缩传送的数据，Content-Encoding是对消息端到端(end-to-end)的编码，可能是资源在服务器上的固有格式(如jpeg图片格式)。请求头加入Accept-Encoding头域，通知服务器客户端能够解码的方式 长连接 1.0只有短连接,请求后立即断开TCP连接。多数网页请求流量小，一次TCP连接很少通过slow-start区，带宽利用率低 1.1支持长连接(persistent connection), 和请求的流水线(Pipelining)处理。 数据传完不发RST包，不四次握手，等待同域名继续用这个通道。 在一个TCP连接上传送多个HTTP请求和响应。 允许客户端不等待上一次请求结果返回，就发出下一次请求。服务端必须按照接收到客户端请求的顺序返回响应结果。 消息传递 1.1引入Chunkedtransfer-coding, 发送方将消息分割，每块附上长度，最后用零长块作为结束标志。允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来过载 结束块之后，再传递一个拖尾(trailer)，包含传递完所有块计算出的头域 1.0有个Content-MD5头域，计算它需要发送方缓冲整个消息。Content-Length需要计算整个消息的大小 Host头域 1.0认为每台服务器有唯一绑定的ip，实际一台物理服务器可以存在多个虚拟主机(Multi-homed Web Servers)，共享一个ip 1.1请求和响应消息都应支持Host头域, 请求消息中没有Host头域会报错(400 Bad Request)。 错误提示 1.0只定义了16个状态响应码 1.1引入Warning头域，增加对错误或警告的描述 1.1新增了24个状态响应码 2.0 二进制分帧 流(stream), 虚拟通道，有id 消息(message), 逻辑上的http请求, 多帧组成 帧(frame), 8字节首部, 首部放headers帧，request body放data帧 多路复用 # request用id标记 1.1前面请求阻塞后面阻塞 帧在一个链接并行交错发送 全双工 请求优先级 每个流带有31bit优先值, 0最高 # 服务器不支持时，可能阻塞低优先级 首部压缩 key小写 首部表渐进更新, 相同不发送 服务器推送 请求定义首部，响应即发数据 对一请求发多响应 流量控制 针对每一跳, 非端到端 针对窗口，即接收方广播接收字节数 目前只能控制data帧, 保证重要帧不阻塞 状态码 200 OK 301 Moved Permanently 永久移除 302 Found 重定向 400 Bad Request 请求有语法错误 401 Unauthorized 请求未经授权 403 Forbidden 拒绝服务 404 Not Found 资源不存在 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理请求 409 Conflict 请求资源与资源当前状态冲突 410 Gone 资源永久性删除 http/1.1 请求动作 get 数据在url, 最多1024字节(各浏览器实现有差异,受操作系统限制) post options # 返回服务器支持的所有http请求方法 head # 同get, 但不传回文本部分 put # 同post, 但是idempotent的，后面相同的请求会覆盖前面的请求,服务器状态会被crawler修改 delete # 请求删除被请求的资源 trace # 回显服务器收到的请求 connect # 预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器） patch # 给服务器资源打补丁 缓存头 response.setHeader(\u0026quot;pragma\u0026quot;, \u0026quot;no-cache\u0026quot;); # http1.0设置不缓存的参数 response.setHeader(\u0026quot;cache-control\u0026quot;, \u0026quot;no-cache\u0026quot;); # http1.1设置不缓存的参数，只用这个就可以了 response.setHeader(\u0026quot;expires\u0026quot;, \u0026quot;0\u0026quot;); # 支持缓存时，设置缓存有效时间。不支持缓存时，无效 # \u0026lt;meta http-equiv=\u0026quot;pragma\u0026quot; content=\u0026quot;no-cache\u0026quot;\u0026gt; jsp页面中的meta设置方式：jboss可以解析,tomcat不支持【只能服务器设置】 ## post方式不缓存时提示页面过期，刷新后重新提交请求。get方式不缓存时则会直接重新提交请求 ## 缓存的配置只对ie浏览器有效。面对未知编程(浏览器兼容，flex可以解决浏览器兼容问题【flash页面】) # cache-control=no-store 端口 httpd 80 ssh 22 telnet 23 ftp 21/20 smtp 25 pop2 109 pop3 110 pop3s 995 imap 143 irc 194 https 443 who 513(udp) login 513(tcp) whoami 565 svn 3690 vnc 5901/5801 5902/5802 ... mysql 3306 mycat 3128 报文 request消息头(请求头) Accept:text/html,image/*,*/* Accept-Charset:ISO-8859-1 Accept-Encoding:gzip,compress Accept-Language:en-us,zh-cn Host:www.itcast.cn:80 If-Modified-Since:Tue,11 Jul 2000 18:23:51 GMT Referer:http://www.itcast.cn/index.jsp User-Agent:Mozilla/4.0(compatible; MSIE 5.5; Windows NT 5.0)x Cookie Connection: close/Keep-Alive Date: Tue, 11 Jul 2000 18:23:51 GMT response消息头（响应头） HTTP/1.1 200 OK Server: Microsoft-IIS/5.0 Date: Thu, 13 Jul 2000 05:46:53 GMT Content-Length: 2991 Content-Type: text/html; charset=GB2312 Content-Encoding:gzip Content-Language: zh-cn Cache-control: private Location:http://www.itcast.cn/index.jsp Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT Refresh: 1; url=http://www.itcast.cn Content-Disposition: attachment; filename=aaa.zip # 设置响应类型是下载文件，文件名是aaa.zip # inline 表示在浏览器中显示,非w3c标准，像innerHTML一样。但是主流浏览器都支持。 ## appllication/octet-stream 表示任意二进制文件（有的浏览器也会解析成文件下载，但是没有指定文件名） ## attachment;filename=文件名 附件，文件下载 Transfer-Encoding: chunked //标记以分块传输 Set-Cookie:SS=QQ=5Lb_nQ; path=/search Expires: -1 Cache-Control: no-cache Pragma: no-cache udp传输 # dns domain name system 分类 位于最右端的域称为顶级域。接下来是二级域名和三级域名。如www.jlu.edu.cn 端口 53 过程 本机缓冲区 -\u0026gt; 本地域名服务器(缓冲区与数据库) -\u0026gt; 其它域名服务器 报文格式 Queries 命令 windows下命令提示行 正向解析 nslookup 域名 反向解析 nslookup -qt=ptr ip地址 # ptr Pointer Recore 指针记录 ## 是电子邮件系统中的一种数据类型，被互联网标准文件RFC1035所定义。 ## 与其相对应的是A记录、地址记录。二者组成邮件交换记录。 ## A记录解析名字到地址，而PTR记录解析地址到名字。 ## 另外两个与ptr平行的参数为mx和a 或 nslookup set q=ptr ip地址 ldns dhcp Dynamic Host Configuration Protocol 基于 客户端/服务器模式 报文 操作代码(1字节) 硬件类型(1字节) 硬件长度(1字节) 跳数(1字节) 事务ID(4字节) 秒 (2字节) 标志 (2字节) 客户端IP地址 (4字节) 您(客户端)的IP地址 (4字节) 服务器IP地址 (4字节) 网关IP地址 (4字节) 客户端硬件地址 (16字节) 服务器名 ( 64字节) 引导文件名 (128字节) 选项 (64字节) rip Routing Information Protocol # 路由信息协议 RIP通过广播UDP报文来交换路由信息，默认每30秒发送一次路由信息更新报文。 RIP提供跳跃计数(hop count)作为尺度来衡量路由距离 跳跃计数是一个数据报到达目标设备所必须经过的路由器的数目。 RIP最多支持的跳数为15，即在源和目的网间所要经过的最多路由器的数目为15， 跳数16表示不可达。 RIP协议的特点： 1．仅和相邻路由器交换信息。 2．交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 3．按固定的时间间隔交换路由信息，例如:每隔 30 秒。 4. 设置一个180秒地超时时间。如果180秒没有任何更新信息，路由的跳数设为16。 snmp Simple Network Management Protocol # 简单网络管理协议 ， 使网络管理员能够管理网络效能,发现并解决网络问题以及规划网络增长。 ## 通过SNMP接收随机消息及事件报告网络管理系统获知网络出现问题。 端口 : 161 rtp 介绍 real-time transport protocol 传输流媒体 udp传输, 实时性好 rtcp 介绍 RTP Control Protocol 交互控制RTP传输 radius 介绍 拨号认证用的AAA协议 coap 介绍 constrained application protocol 请求、响应, 非长连接。REST, 有url, POST, GET, PUT, DELETE 二进制格式, 最小长度4B 订阅观察, 接收通知 支持可靠传输、数据重传、块传输, 确保到达 支持ip多播 mqtt # 介绍 消息队列遥测传输(message queuing telemetry transport) 针对硬件性能低、网络状态差的远程设备, 如卫星链路通信 需要一个消息中间件 qos级别 # quality of service 尽力转发(best effort service) # 没有保障 区分服务(differentiated service) # soft qos优先级 确保服务(guaranteed service) # hard qos专有带宽 电话 # cti computer telephony integration computer telecommunication integration 计算机技术应用到电话系统中，识别信令信息进行处理，传送预定录音文件 转接来话，处理传真，电子邮件等 分布式服务 # 定理 CAP定理 # 当面临分区的时候，必须在一致性和可用性之间权衡 一致性Consistency 可用性Availability 分区容错性Partition tolerance BASE # 解决CAP 基本可用(basic available) 软状态(soft state) 最终一致性(eventually consistent) 架构 服务网格 容器调度编排 容器runtime 基础设施 # 云服务器 分层 服务 对外网关 服务容器 # 如aws, k8s, mesos 通讯能力 # http/1.1 http/2 grpc tcp 配置(分布式) 部署 版本控制 网关 访问策略/认证(auth) 细粒度权限控制 智能路由 服务治理(注册,发现) 区域感知、load balance 容错: 故障切换、熔断、故障注入测试 流量拆分和推出 监控 metrics(api统计, cpu、内存、时长、平均、缓存命中等) 调用链跟踪(tracing) 日志 健康检查和告警 服务网可视化 对外 授权(OAuth2) 安全传输协议(tls) 限流(quota) # 网络数据、api调用 一致性 # 分布式事务 # TCC # # Try Confirm Cancel 队列 # # 同步数据用队列传输 两阶段提交 # 过程 表决(voting) 同意或取消 提交(commit) 提交或取消 问题 所有节点同步阻塞 协调者单点故障 协调者commit中网络故障, 部分节点未提交 三阶段提交 # 过程 # 每步引入超时 询问(can commit) 锁资源(pre commit) 提交(do commit) 高可用(high available) # 负载均衡与反向代理 # 外网dns做gslb(全局负载均衡) # 有缓存，切换时间长 分配最近ip和容错 内网dns 负载均衡关注点 上游服务器配置 负载均衡算法 失败重试机制 服务器心跳检查 反向代理 对响应结果缓存、压缩 分层 七层: HTTP, 端口、协议、主机名、url。流量有限制。 四层: tcp, ip + 端口 二层: 改报文目标mac 方法 轮询 # 有缓存，没有重试 naproxy 七层 nginx 七层 1.9后支持tcp四层负载 OpenResty 热点非热点流量分离，正常流量与爬虫流量分离 lvs 软件四层 DR: 改写报文目标MAC到上游服务器,上游直接响应到客户端。要求和上游服务器在同一子网 f5 硬件四层 隔离 # 限流 # 降级 # 超时与重试 # 回滚 # 压测 # 高并发(high concurrency) # 应用级缓存 # http缓存 # 多级缓存 # 连接池线程池 # 异步并发 # 扩容 # 队列 # 大数据 # lambda架构 # 实时大数据, stream使用 批处理层 实时处理层 服务层 sharing-nothing # cpu之间不共享内存和磁盘 "},{"id":46,"href":"/docs/architect/strategy/meta/media/","title":"媒体","section":"IoT","content":" 原理 # 硬件 # CRT cathode ray tube 阴极射线管显示器 随机扫描方式 光栅扫描方式 DPU distributed processing unit 分散处理单元 标准 # Core Graphics System CGI(computer graphics interface) # 与设备无关的方法，方便的直接控制图形设备 CGM(computer graphics metafile) # 设备无关的主义定义图形文件格式 GKS(graphics kernal system) # 应用程序与图形输入输出设备之间的功能接口 PHIGS(programmer's hierarchical interactive graphics system) # 为3d设计的工具库 GL(graphics library) # 广泛应用的标准图形程序库 算法 # 基元的显示 直线扫描转换 DDA 中点画线法 Bresenham画线 圆的扫描转换 中点画圆 Bresenham 区域填充 种子填充 多边形扫描转换 图形变换 二维图形变换 二维视见变换 三维图形变换 投影 平行正交 平行斜交 透视投影 裁剪 直线段裁剪算法 Cohen-Sutherland算法 中点分割算法 梁友栋-Barsky算法 多边形裁剪Sutherland-Hodgman算法 三维图形裁剪 梁友栋-Barsky算法 曲线和曲面 概念 插值 逼近 参数连续性 几何连续性 光顺(smoothness) Hermite插值曲线多项式 Coons曲面 Bezier曲线和曲面 B样条曲线和曲面 图形运算 交点计算 多边形表面交线计算 平面中的凸壳算法 Graham扫描 Jarvis行进 包含与重叠 凸多边形 多边形的三角剖分 形体的表示 概念 图形信息 几何信息 拓扑信息 非图形信息 颜色 亮度 质量 体积 二维 边界 拆线逼近曲线 选点 共线性 三点转角阈值 带树法 图形的四叉树表示法 三维 几何元素 点 边 环(有序有向边) 面 体 体素 一组单元实体: 长方体、圆柱体、圆锥体、球体 扫描体 代数半空间定义的形体 线框图 顶点表、边表、面表 边界表示法 实体 CSG(constructive solid geometry), 指任意复杂形体都可用的体素组合 特征表示 Brep表示 八叉树(四叉树的推广) 分形 规则分形 # 严格自相似性的分形 Von Koch算法 Julia集和Mandelbrot集 消除隐藏线和隐藏面 线面比较法消除隐藏线 浮动水平线消除曲面隐藏线 深度排序算法(优先级算法) 画家算法(深度优先级表法) z一缓冲算法(深度缓冲算法) 扫描线算法消除隐藏面 区域分割算法消除隐藏面 BSP(binary space partitioning)树算法判别物体可见性 八叉树算法消除隐藏面 光线投射算法找到可见面 # 对包含曲面(特别球面的场景效率高) 真实感 漫反射及光源照明 照明效应 漫射照明 具体光源照明的照射效应、透射效应 漫反射、镜面反射 环境光 漫反射 镜面反射与Phong模型 光的衰减 多边形网的明暗处理 常数明暗法 亮度插值明暗法(Gouraund着色) 法向量插值明暗法(Phong着色) 阴影 纹理(texture) 整体光 透射光亮度模拟 Whitted光照模型(以Phong为基础) 光线跟踪 # 适用光滑表面 包围盒 空间分割成网格单元 辐射度方法 # 描述封闭环境中的能量交换 # 可模拟彩色渗透现象 色彩模型 颜色 色彩(Hue) 色饱和度(Saturation) 明度(Brightness) CIE(国际照明委员会)色度图(红绿蓝) 混合系统 面向硬件 RGB 红绿蓝加色系统 CMY 青、品红、黄着色系统 彩色印刷、胶卷等非发光显示体中采用 面向用户 HSV(Hue, saturation, value) # 六棱锥模型 # 可与RGB空间互相转化 HLS(Hue, lightness, saturation)双六棱锥模型 2d # 分形 # 介绍 Fractal 具有自相似性质的多个形状 大的部分由小的部分组成，小的部分像大的部分 用递归算法模拟 Mandelbrot Set 介绍 分形领域最著名的科学家 本华.曼德博 曼德博集合常常由 z^2 + c定义 3d # 术语 # 顶点(vertexs): 图元(primitives, entity, 图素, 实体): 顶点组合为图元 片元(fragments, 片段): 图元裁剪、颜色、纹理、坐标转换等后合成片元 像素(pixels) 硬件 # cpu与gpu 特点 cpu串行运算，电量分配给控制器和缓存，没有太多计算单元 97, 98年 nvidia 出品 nvidia系列显卡，并行计算。gpu控制单元少，计算单元多 构造 cpu通过cpu总线连接内存，cpu总线和pci总线通过主桥(北桥)连接，pci总线连接显卡 webgl中大量控制逻辑用js编写cpu执行，交给gpu渲染。要渲染的数据从内存传入显存，再由显卡计算 最耗时的是内存到显存之前的数据传输 模型 # mesh模型 无数三角形面组成的物体（可帖上纹理）。 概念 3d模型由顶点(vertex)组成，顶点连成三角形或四边形，再组成复杂的立体模型 网格模型 加载过程 ajax下载文件 解析成Mesh模型 显示在场景中 三角形 # 渲染效率最高 顶点 Vertex 正反面 顶点顺时针排列为正面 法线 Normal 正面指向，垂直于面的矢量 作用 法线与入射光角度越小，该点光线越强 顶点法线 Vertex Normal 过顶点的矢量 作用 高洛德着色(Gouraud Shading) 中计算光照和纹理效果。 生成平滑的棱时，令顶点法线和相邻多平面法线保持等角 生成棱时顶点法线为点所在平面的法线(可多个), 这样在面连接处形成突出的边缘。 google 3d模型库 sketchup.google.com/3dwarehouse/ vtk vtk DataFile Version 3.0 # 4.0已经出来，3.0广泛使用 vtk output # 一般不改变 ASCII # 使用标准ASCII码， 也可以写binary DATASET POLYDATA # 表示多边形面集，面由点组成 ## POLYDATA是数据类型, 可以是STRUCTED_POINTS, STRUCTURED_GRID, UNSTRUCTURED_GRID, POLYDATA, FIELD等。POLYDATA表示三角形或四边形数据。 POINTS 35947 float # 表示该模型由35947个点组成，坐标分量是浮点型 ## 这行的后面是35947 * 3个float型数字。每三个数字表示一个点 POLYGONS 69451 277804 # POLYGONS是关键字, 69451表示模型有69451个多边形 ## 后面行的 3 21216 21215 20399中3表示每个多边形三个顶点。每一行是一个多边形面。21216 21215 20399表示在POINTS 35947 float段中的索引。 ## 277804表示整个POLYGONS占据的数组的长度，计算公式是69451 * 4 = 277804, 乘数4是3 21216 21215 20399这组元素的长度。用于计算存储空间 CELL_DATA 69451 # 表示面的个数，和POLYGONS上定义的面个数一致。 POINT_DATA 35947 # 表示点的个数, 和POINTS中定义的点个数一致。 贴图 立方体环境贴图(Cubic Environment Mapping) # 简称立方体贴图 介绍 一个纹理包含了包围物体场景的图像数据。x, y, z轴正负方向各一张图片，首尾相连。 计算 # 旋转的三种工具 矩阵 用来与点相乘，改变点的位置 欧拉角 三个轴的旋转角度(Yaw[z], Pitch[y], Roll[x])来表示几何体的旋转 欧拉角很容易转换为矩阵。使用欧拉角更形象一些 四元组 四元组 介绍 表示任何一个方向上的轴，和围绕这个轴旋转的弧度 可方便地与欧拉角和矩阵之间通过公式转换 三维投影 三维空间中的点变为二维屏幕上的点是投影运算 # 二维空间变到三维空间是反投影运算 ## 如鼠标从二维到三维的反投影 三维布尔运算 渲染 # 工具 # flash 3d max blender ps unity3d wirefusion maya rhino illustrator gimp "},{"id":47,"href":"/docs/pl/principle/","title":"程序语言原理","section":"程序语言","content":" 基础 # 注意 比较语言，共通处(抽象的元知识)是要点 在历史上判断设计者意图 # 利于了解知道的根基 不同规则，只在特点语言中合理 # 如0在ruby为真 历史 EDSAC # 1949，纸带 FORTRAN # 1954, 中缀表达式, 运算符优先级、结合性 FORTH # 1958, 没有语法，后缀表达式，语法树 LISP # 1958, 括号，前缀表达式，语法树 语法 引入优先级和左右结合 规则不冲突是困难的 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; # c++的语法缺陷, \u0026gt;\u0026gt;是位运算，必须加空格 结构化 # 60年代 if # 汇编是判断再向后跳代码, if使可读性好 while # 可读了反复执行的if for # 可读了数值渐增的while foreach # 可读了集合遍历 函数 作用 便于理解 # 组织划分部门 便于再利用 # 再利用无代码成本 用了跳转命令和返回命令 # 从记录函数前后地址到函数记录返回地址 栈记录多级调用 # 解决多级调用返回地址被覆盖问题 递归 # 处理嵌套数据结构时，代码的嵌套结构 错误处理 历史 UNIVACI # 1950, 溢出时中断(interrupt)跳转到000 COBOL # 1959, 两种类型错误，用两关键字处理 PL/I # 1964 先定义出错处理代码。编程时引入on语句goto到处理代码, 不检查返回值 可定义新错误类型, 可用signal condition主动出错 john goodenough # 1975，论文 程序员可能忘处理异常、在不正确位置处理、处理不正确类型异常 应该声明可能抛出的异常、将可能出错结构括起来的语句结构 CLU # 1975, begin ... end 后 except 错误类型, 再写错误处理语句 C++ # 1983, 1984-1989多次讨论，try{}catch{}, throw抛异常(没用raise和signal, 因为它们已经使用了) Windows NT 3.1 # 1993, 使用finally Java # 1995, 引入finally D # 2001, 作用域守护取代finally, 写在初始化语句后面scope(exit) unlock(m) 方式 返回值 # 遗漏错误，可读性下降 异常处理 # 函数多出口 必执行代码 # 成对操作无遗漏，不使用goto执行同段代码 finally # java, ruby, python 析构函数 # c++, RAII(资源获取即初始化, resource acquisition is initialization) 何时使用异常 # 有不同的规则。缺少参数，js不抛异常。数据越界，js返回undefined, ruby返回nil 出错立刻抛异常 # 错误优先(fail first), 早发现问题 异常传递 # 一层层函数向上传递，都无处理时程序异常退出 上层函数不了解下层异常细节 不了解下层调用不能捕获全部异常 # java用检查型异常解决, 但很麻烦 取名 编号到取名 # 对照表实现, 变量名或函数名 实现 整个程序共用一个对照表 # perl无声明变量, 全局作用域、全局变量 # 1994 javascript 解决冲突 更长变量名 作用域 动态作用域 # 1991 perl4 local变量 # 1958 lisp 之前存变量原值，之后用原值覆盖变量 中间函数调用时，变量不是原值, 要看调用前所有代码 # 全局污染 静态作用域 # 1975 scheme，调用时建专用对照表(属于调用而非函数)，查找变量更优先。 # 又叫字面作用域(lexical scope), 因为和字面范围一致 # 1991 perl5 my变量 # 1991 python # 1994 javascript val变量 # 1995 ruby python 内置作用域 # 语言提供，如js的全局对象作用域 全局作用域 # 当前文件字面 局部作用域 # 函数 赋值即定义 嵌套函数直接找全局作用域，不字面上找外部函数作用域 # 2.0问题, 2001年2.1修复 不能改变外部变量 # 2006年3.0 nonlocal声明为外部变量 类型 比特列标记类型，解释成不同数据 整数 excess-3(加三码) # UNIVACI, 4位表示0到9 二进制 # 1983, 任天堂计算机8位表示整数。目前32位和64位表示整数 八进制(3位切分), 十六进制(4位切分) 实数 单独记小数点左移位数 # 定点数，不好实现和计算。 银行用加三码和定点数 前位段表示数，后位段表示小数点位置 # 浮点数，也可表示大整数 IEEE 754 # 有误差 第一位符号 中8位是指数(-127-128), 负向左移正向右移，-127代表0, 128代表无限大 后23位是尾数，从左到右代表1/2, 1/4, 1/8... 二-十进制码 # 用二进制表示十进制，加三码是一种，无误差 发展 变量名表示类型 # FORTRAN, I-N开头表示整数，其它表示浮点数 声明类型 隐式类型转换 # 整数+浮点数，FORTRAN出错，c都转换为浮点数, 整数除法舍弃小数 ML(1973年)中, 整数除法用x div y, 小数除法用 x / y python3.0(2008年)中, 不带舍去除法用 x / y, 带舍去除法用 x // y 用户定义类型 # c中的结构体, c++中函数成为类型，用户实现的类型称为类 类型即功能 # 访问控制(公开、非公开) 接口 # 不包含实现细节的类型 异常成为类型 # CLU和Java 类型实现所有功能 # 未实现。类型一致，功能就成立，没有bug 类型不能表达的：数据处理时间，处理用内存，是否可以在线程中操作等 总称型(部分可变类型) # 类型为参数创建类型，c++的模板，java的泛型，haskell的类型构造器 动态类型 # 类型信息和数值看作整体, 静态类型把变量名、内存地址、内存里的内容类型作为整体 内存中同等类型对待，其中再细分类型 灵活，运行时确定类型，但不能执行前编译检查bug 类型推导 # 最早OCaml和Haskell这类ML语言擅长，现Scala等语言也越来越多 目标是证明程序没有bug 容器 语言中用语不共通 # haskell列表是链表，不可变，元组是放不同类型的列表 数组、链表 字典(散列、关联数组) # 字典散列或树实现 树 字符串 字符集和字符编码 # 有的认为就按效率特异化编码，有的认为应标准化 摩斯码 # 长短组合 博多码 # 5位一字符，先通知字符种类 EDSAC # 5位一字符，shift切换，内容和博多码不同。用5孔纸带 ASCII # 7位 EBCDIC # IBM，8位 ISO-xxx # 区域化 魔术注释符 # 告诉语言处理器编码，特殊记号事先写明 unicode # 统一 字符串 c语言一字符8位，定义字符为ASCII或EBCDIC。字符串不知长度，nul字符终止，没nul时可能内存中越界读取 pascal一字符8位，带长度 java一字符16位, 定义字符为unicode python2 ASCII码环境下，字符当作ASCII码，可以自动转换成unicode python3中\u0026quot;\u0026quot;是unicode码, b\u0026quot;\u0026quot;是字节列串，要显示转换类型，否则报错 ruby一字符8位，追加编码信息 面向对象 # 不同语言中面向对象意义不同 # goto因强大让人困惑，退出历史。面向对象、Trait也有这因素 两种立场 c++, 类是用户自定义类型，Simula语言的继承机制是关键 smalltalk, 类让人痛苦，不要继承，不同状态对象传消息来通信 历史 # ALGOL产生model思想(1958年), Simula , Smalltalk, C++, Java 类在大部分语言中不是不可或缺的 Java: 类是部件，将其组装就是程序设计 归集方法和建模的发展 # 围绕实现多实例问题 强关联元素分组存放，便于理解 module # 关联函数集中, 1978年Modula-2引入, python, ruby叫模块，java, perl叫包 初始化散列, 再作为参数传入包中函数，函数修改散列 包提供初始化函数, 返回散列, 该函数成为构造函数(java叫工厂方法)。但使用包函数都要传入散列 bless函数(perl)绑定包和散列产生blessed hash对象，它的方法对应包方法, curry了散列做参数 包的初始化函数自己绑定, 返回blessed hash对象 变量和函数放入散列 # js对象 函数放入散列 # 函数成为一等公民(first class citizen)，可赋值给变量。FORTRAN66中字符串还不是一等公民 # first-class function的思想来自Scheme语言 函数中通过this隐式获取自身做散列 # perl中显示获得散列 创建构造函数，返回以上散列。但返回的散列上都定义了新的函数 把函数单独放置在包或对象, 使用时很麻烦 引入原型概念,对象变量查找作用域在原型链中扩展 # 这里是委托方式的原型，也可以在实例化时通过负责来实现。原型变更的处理，不同语言有差异 # prototype-based的思想来自Self语言 定义new f()运算, 函数f的原型是以上散列，多个new的新对象共享了散列的函数 新对象原型指向函数f的原型 以新对象为this,执行f 闭包(closure) # 维持内部作用域状态的函数, 作用域呈封闭状态 类 分类/分组 # 1965年ALGOL提出 用户定义类型 # 1979年c++, 参考Simula 最初c语言结构体 声明和定义类方法 # Smalltalk方法调用是传送消息，调未定义方法是否出错由该类决定 作用 # 成为一种模具 生成器 # module和散列只有该作用 可行操作的功能说明(类型、泛型) 代码再利用的单位(继承) 继承 实现策略 父类实现一般化, 子类是父类的专门化 共享部分提取 # 子类不是父类的一种, 函数思想考虑问题 差异实现 # 覆盖变更部分，为了再利用使实现更轻松，不倾向使用 问题 多层级问题 向上不好找方法定义 修改方法时，向下影响子类 # 如动态作用域问题 里氏替换原则 # 1987年提出，对父类成立的条件，一定对子类成立。为了维护父子关系间的一致性，继承是is-a关系 实际编程中，子类功能增加常打破里氏替换原则，无论是在开始设计上避免还是在开发中放弃继承都很麻烦 多重继承 # 东西常常不属于一个分类,java禁止多重继承 问题 多父类成员名冲突 委托(delegation) # 聚合(aggregation)，咨询(consultation), 不用多重继承，把原父类对象作为子类成员,后发展出依赖注入 接口多重继承 # Java引入，php5(2004年)引入 按顺序搜索 深度优先 # python2.1, 菱形继承中，第一层父类的值会覆盖第二层右边父类的值 C3线性化 # 1996年提出，python2.3, perl6默认, 对类编号，子类先于父类检查, 优先检查先书写的类 混入式处理(mix-in) # 扁平成新类, 该类不能创建实例，python XxxMixIn类， ruby类单一继承，模块混入 Trait # 2002年Trait论文，Squeak最早引入, scala, perl6的Roll, php5.4, ruby2.0的mix method 类作用：创建实例(要求全面, 大的类),再利用单元(小的类)冲突 把再利用单元特别化 ruby模块混入名称冲突时, 使用最后的模块, Trait会报错 # Smalltalk的Squeak处理器可取方法别名，可指定不参与冲突 scala声明创建实例需要的方法, 另一Trait声明提供的方法，组合匹配后可创建实例 对Trait改写定义新的Trait(继承), Trait组合成新Trait 原理 # gc # garbage collector 为什么gc 减少编程工作量 减少内存泄露 安全性 定位 引用计数器(reference counting, java1.1废弃) # 给每个对象设置计数器，有引用+1, 失效-1 不能解决循环引用问题 # A, B互相引用不回收 计数器修改开销大 根搜索算法(使用) # 从GC Roots对象起点，向下搜索，路径成为Reference Chain, 不可达对象不可用 GC Roots包括 虚拟机栈(栈帧中本地变量表)中的引用对象 方法区域中的类静态引用对象 方法区域中常量引用对象 本地方法栈JNI(native方法)引用的对象 回收算法 标记-清除(mark-sweep) # DVM(Dalvik Virtual Machine, 安卓用)使用的算法 # 效率不高，清除后产生大量不连续空间 标记所有要回收的对象 清除标记对象 复制(copying) # 实现简单，效率高。内存利用率不高 # 用于新生代，两块比例8:1 内存分成相等两块，使用其中一块 回收时，存活对象复制到另一块，这块整个清理掉 标记-整理(mark-compact) # 适合老年代 把存活对象往内存一端移动 回收边界外内存 分代收集(generational collection) 新生代用复制算法 老年代用标记-整理算法 4种引用类型回收 # java强引用、软引用、弱引用、虚引用 方法区回收 废弃的常量 # 看引用计数 无用的类 实例都已经回收 加载该类的ClassLoader已回收 该类的class对象没有被引用，无法反射该类的方法 异步编程 # 事件 # 高阶函数的优势 解耦业务逻辑 问题 异常处理 # 不能同步catch 回调嵌套过深 单线程模型中，业务处理阻塞全局 异步转同步 实现 事件发布订阅 回调函数事件化(钩子机制) cps: continuation-passing style 在函数式编程中, 多传一个参数k明确控制continuation promise/deferred # promise/A, promise/B, promise/D模型 # promise在外部暴露接口(可变部分), deferred在内部维护状态(不可变部分) 状态 未完成，完成，失败 方向只能未完成-\u0026gt;完成, 未完成-\u0026gt;失败 状态转化不能更改 api then() done() all() # 所有成功成功，一失败失败 any() 流程控制库 尾触发 # 传next()函数 async库(node.js) series() # 串行 parallel() # 并行 waterfall() # 串行传结果 auto() # 计算依赖顺序执行 bagpipe库(node.js) # 限制并发, 任务可排队或拒绝, 超时控制 编译 # # 流程 词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成，表格管理，错误处理 语义分析 -\u0026gt; 类型检查/推导 -\u0026gt; 代码优化 -\u0026gt; 机器码生成 # 中间数据结构, 比如AST 预处理，连接程序，装入程序，调试程序 # 文法 G = (Vn, Vt, S, P) # 终极符号, 非终级符号, 一个特殊非终级符号，产生式 类型 短语(0), 对应图灵机(TM) 上下文相关(1), 对应线性有界自动机(LBA) 上下文无关(2), 对应下推自动机(PDA) 线性文法、正则文法、正规文法，对应有限自动机(FA) # 无法控制自返数 # 状态机(FA) 确定状态机(DFA) 非确定状态机(NFA) # 同状态可多种转移 DFA与NFA互相转换 # 词法分析 状态转换矩阵法 # 语法分析 # 源代码读入、解析成语法树 自顶向下 # 最左推导建立语法树 # first集，follow集，predict集 不回溯方法 递归下降 LL(1) # 从左输入符号、产生左推导、每次读一个字符。LL(k)特例 自底向上 # 从左读, 从右向前归约 简单优先关系 # 运算符优先关系矩阵 LR(k) # 从左输入，最右推导 LR(0) # 只看栈顶状态，有分析动作冲突 SLR(1) # LR(0)加向前看展望符，不能分析所有文法 LR(1) # LR(0)的每个推导加一个向前搜索符，状态太多 LALR(1) # LR(1)中同向前搜索符的状态合并 # 语义分析 抽象语法树 符号表 # 动态规划记录变量的综合信息 局部化处理 # 压栈变量作用域 # 中间代码生成 后缀式(逆波兰式) 三地址 # 操作符两变量地址，结果地址 四元式操作符 # 地址加，赋值，过程调用，类型转换，算术、逻辑、关系运算的存储 语法制导 # 中间代码产生式后拼上语义程序，在语法分析中遇到动作马上处理 类型检查 下标变量 # 如数组下标，同上全用四元式表示 # 中间代码优化 常量表达式 a = 1, b = 2, c = a + b, 则只记c = 3 公共表达式 a = b * c, d = b * c, 则只记a 循环不变式外提 while k \u0026lt; 0 do b * c, 则b * c外提只计算一次 基本块 # 一块语句要么全执行，要么全不执行 消减运算强度 如加法代替乘法 复写传播 a = b, 后a, b不再变值，用a替代b 无用代码消除 数学优化（恒等变换） 如a + 0 = a, a * 1 = a, a ^ 2 = a * a, a / 1 = a, 0 / a = 0 窥孔优化 对目标代码中短指令序列局部改进，如删除重复，控制流优化，代数化简，使用特殊指令等 全局优化 对整个程序控制流和数据分析再优化，如常量表达式全局优化 # 运行时时空管理 内存划分 存储 引用的库的代码 目标代码 静态变量 栈区 # 函数调用，中断现场 堆区 存储策略 静态分配 #编译时分配固定存储单元 动态分配 栈 堆 活动记录 保存局部变量，中间结果，临时变量，过程调用，控制信息等 专用寄存器 调用链 # 保存下一个调用的起始地址 动态链 # 保存前一个调用的起始地址 访问环境 # 记录闭包起始地址 display表 # 过程需要的所有非局部数据所在的过程活动记录的起始地址 全局display表 静态链 # 指向外层过程的活动记录的地址地址 # 目标代码生成 生成的语言 机器语言 可重定位的机器语言 # 由连接器装配后生成机器语言 # 多数用这种，如c语言 汇编语言 指令选择 虚拟机 寄存器分配 四元式翻译 "},{"id":48,"href":"/docs/tool/product/enterprise_system/","title":"企业级系统","section":"工具","content":" ERP # # Enterprise Resources Planning, 企业资源计划 CMS # # Content Management System grav # 开源cms wordpress # # php dedecms # # 织梦cms, SEO优化 帝国cms # # SEO优化 phpcms # phpwind # # 开源, 社区管理系统 drupal # # 开源, cms 工作流 # activiti # 5,6已暂停维护，7叫作Activiti Cloud BPM flowable # activiti继任 YAML # 工作流 bossa # 工作流引擎 azkaban # 开源oa JBPM # # 常识 适用对象：业务逻辑不复杂，业务流程会变化 # s2sh适合业务逻辑复杂，但是业务流程不会变化的项目 jbpm封装hibernate 包含对象 模型 实例（由活动组成，包括活动、箭头等） 任务（需要人办理的活动） # 使用 myeclipse添加jbpm xml画图插件 MyEclipse -\u0026gt; MyEclipse Configuration Center -\u0026gt; Software -\u0026gt; Browse Software(add site) -\u0026gt; add from archive file找到jbpm-gpd-site.zip,取名为jbpm4.4 -\u0026gt; Browse Software(Personal Sites -\u0026gt; jbpm4.4下8个选项)右键add to Profile -\u0026gt; 右下角apply changes -\u0026gt; 重启myeclipse -\u0026gt; 新建文件中找到新建jbpm xml文件 画图 test.jpdl.xml文件用jbpm工具打开 打开Properties视图 配置 jbpm.hibernate.cfg.xml # mysql方言要配置InnoDB的方言（因为jbpm建表时对表指定了type=InnoDB约束） 配置hibernate的5个映射文件（导入的jbpm.jar包中有） \u0026lt;mapping resource=\u0026quot;jbpm.repository.hbm.xml\u0026quot; /\u0026gt; \u0026lt;mapping resource=\u0026quot;jbpm.execution.hbm.xml\u0026quot; /\u0026gt; \u0026lt;mapping resource=\u0026quot;jbpm.history.hbm.xml\u0026quot; /\u0026gt; \u0026lt;mapping resource=\u0026quot;jbpm.task.hbm.xml\u0026quot; /\u0026gt; \u0026lt;mapping resource=\u0026quot;jbpm.identity.hbm.xml\u0026quot; /\u0026gt; jbpm.cfg.xml: api hibernate的api:org.hibernate.cfg.Configuration() .configure(\u0026quot;jbpm.hibernate.cfg.xml\u0026quot;).buildSessionFactory();进行hibernate配置文件加载测试 delete_deployment # 有实例时不能删除 # 级联删除时出现constraintViolationException的原因： ## jbpm4.4下载包中/install/src/db/create/下有创建jbpm各个数据库时用到的sql文件 ##　如果是mysql数据库，其中表有type=InnoDB约束。该约束的方言类为hibernate-core.jar包下/org.hibernate.dialect.MySQLInnoDBDialect的类文件 ## ，在hibernate的配置文件中配置该方言就可以解决问题 # 表结构 表 模型 jbpm4_deployment jbpm4_lob jbpm4_deployprop 实例 jbpm4_execution jbpm4_hist_procinst jbpm4_task jbpm4_hist_task 活动 jbpm4_hist_actinst 变量 jbpm4_variable id关联 规则引擎(BRMS) # 概念 组成 知识库(Knowledge base) 既定事实(Fact base) 推理机(Rule Engine) Drools # JBoss开发, 基于RETE算法 OpenRules OpenLexicon MES # # Manufacturing Execution System ITSM # # IT service management sap salesforce servicenow workday # hr平台 GIS # ide skylive arcGIS mapInfo mapGIS superMap webglobe arcpy MES # # manufacturing execution system, 制造生产过程执行系统 WMS # # warehouse management system, 仓库管理系统 OMS # # 订单管理系统 TMS # # 物流管理系统 CMP # # campaign management platform, 营销活动管理平台 商城 # nopCommerce # .net开源电商 ecshop # 开源, 商城系统, 微信商城 HRP # # Hospital Resource Planning, 医院资源规划 "},{"id":49,"href":"/docs/architect/project/frontend/","title":"前端","section":"工程设计","content":" 组件化Layout # layout service # 缓存layout到redis crud layout功能 layout对象 index # 缩略信息 plugins components table layout # 组合方式 水平，垂直，tab "},{"id":50,"href":"/docs/middleware/library_frontend/","title":"前端","section":"中间件","content":" 基础 # AJAX # Asynchronous JavaScript and XML 特点 异步，提升了用户体验 局部刷新 优化传输，减少了数据和带宽 客户端运行，承担服务器压力 XMLHttpRequest # IE5首次引入 readyState 0 未初始化, 1 正在加载, 2 已加载, 3 交互中, 4 完成 status # 服务器http状态码 responseXML # 响应结果，表示为xml responseText # 响应结果，表示为串 open(\u0026quot;method\u0026quot;, url) send() abort() # 停止当前请求 创建 new ActiveXObject() # IE new XMLHttpRequest() # firefox callback种类 onSuccess onFailure onUninitialized onLoading onLoaded onInteractive onComplete onException jsonp 来源 js在浏览器有同源策略(Same-Origin Policy), 只访问同一域下文件 \u0026lt;script\u0026gt;标签没有同源策略限制 原理 编程时 客户端注册callback f(), 名字传给服务器 跨域服务器以文本方式写js函数, 并构造应传的json数据, 函数中调用f(json) 运行时 动态添加\u0026lt;script\u0026gt;标签, 请求跨域服务器的js函数 开发框架 # 模块化 # bower browserify require.js mod.js # 百度模块化开发工具 curl.js # amd load sea.js when # amd 加载 测试 # vConsole # APP HTML页面显示console按钮，打印请求参数 bigpipe # 介绍 facebook的页面异步加载框架 不同于ajax的http调用，需要更多的网线连接。bigpipe与当前页面共用http连接 使用 前端 \u0026lt;script src=\u0026quot;jquery.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;underscore.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;bigpipe.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026quot;body\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026quot;text/template\u0026quot; id=\u0026quot;tpl_body\u0026quot;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;%=articles%\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var bigpipe = new Bigpipe() bigpipe.ready('articles', function(data) { $('#body').html(_.render($('#tpl_body').html(), {articles: data})) }) \u0026lt;/script\u0026gt; 服务器端 app.get('/profile', function (req, res) { if (!cache[layout]) { cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8') } res.writeHead(200, {'Content-Type': 'text/html'}) res.write(render(complie(cache[layout]))) ep.all('users', 'articles', function () { res.end() }) ep.fail(function(err) { res.end() }) db.getData('sql1', function (err, data) { data = err ? {} : data res.write('\u0026lt;script\u0026gt;bigpipe.set(\u0026quot;articles\u0026quot;, ' + JSON.stringify(data) + ');\u0026lt;/script\u0026gt;') }) }) nodejs使用 'use strict' var BigPipe = require('bigpipe'); var bigpipe = BigPipe.createServer(8080, { pagelets: __dirname + '/pagelets', # 页面路径 dist: __dirname + '/dist' # 静态资源路径 }); o-\u0026gt; 开启https var bigpipe = BigPipe.createServer(443, { key: fs.readFileSync(__dirname + '/ssl.key', 'utf-8'), cert: fs.readFileSync(__dirname + '/ssl.cert', 'utf-8') }); o-\u0026gt; 嫁接 var server = require('http').createServer(), BigPipe = require('bigpipe'); var bigpipe = new BIgPipe(server, {options}); bigpipe.listen(8080, function listening(){ console.log('listening on port 8080.'); }); bigpipe.define('../pagelets', function done(err){ }); # 合并pagelets, 结束后调用done o-\u0026gt; AMD 方式define，与链式编程 bigpipe.define([Pagelet1, Pagelet2, Pagelet3], function done(err){ }).define('../more/pagelets', function done(err){}); # bigpipe.before来添加中间件, remove来删除中间件, disable、enable来跳过和重新启用中间件 # bigpipe.use来引用插件 api BigPipe所有组件继承EventEmitter interface 功能 pagelets var Pagelet = require('bigpipe').Pagelet; # var Pagelet = require('pagelet'); Pagelet.extend({ js: 'client.js', css: 'sidebar.styl', view: 'templ.jade', name: 'sidebar‘, // 唯一路由路径 get: function get(){ // 接收get请求时的业务逻辑 } }).on(module); # 自动写 module.export部分来导出 # traverse方法自动调用来递归找additional child pagelets, 要手动指定名称时手动调用 脚手架 # yeoman # google和外部贡献团队合作开发，通过grunt和bower包装一个易用的工作流。由yo(脚手架), grunt(构建), bower(包管理)三部分组成 webpack # # 介绍 模块打包 # 命令 npm i -g webpack npm i css-loader style-loader webpack ./entry.js bundle.js # --progress # --colors # --watch # --module-bind ## jade, 'css=style!css' webpack ./entry.js bundle.js --module-bind 'css=style!css' webpack # use webpack.config.js npm i webpack-dev-server -g webpack-dev-server # --progress --colors # --hot 热部署 # 启动一个express在8080端口 # 配置 # webpack.config.js var webpack = require('webpack') var merge = require('webpack-merge') var path = require('path') var HtmlwebpackPlugin = require('html-webpack-plugin') var ROOT_PATH = path.resolve(__dirname) var APP_PATH = path.resolve(ROOT_PATH, 'app') var BUILD_PATH = path.resolve(ROOT_PATH, 'build') var baseWebpackConfig = { entry: { app: path.resolve(APP_PATH, 'app.jsx') }, output: { path: BUILD_PATH, filename: '[name].js', chunkFilename: '[id].chunk.js', publicPath: '/', # 浏览器路径 }, devtool: 'eval-source-map', devServer: { contentBase: path.resolve(ROOT_PATH, 'build') , historyApiFallback: true, inline: true, port: 3031 } resolve: { extensions: ['', '.js', '.vue', 'jsx'], # 这样可以在js import 中加载扩展名 fallback: [path.join(__dirname, '../node_modules')], alias: { 'src': path.resolve(__dirname, '../src'), 'assets': path.resolve(_dirname, '../src/assets'), 'components': path.resolve(__dirname, '../src/components') } }, resolveLoader: { fallback: [path.join(__dirname, '../node_modules')] }, module: { preLoaders: [ { test: /\\.jsx?$/, loaders: ['eslint'], include: APP_PATH } ] loaders: [ { test: /\\.vue$/, loader: 'vue' }, { test: /\\.js$/, loader: 'babel', include: projectRoot, exclude: /node_modules/ }, { test: /\\.json$/, loader: 'json' }, { test: /\\.html$/, loader: 'vue-html' }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url', query: { limit: 10000, name: path.posix.join('static', 'img/[name].[hash:7].[ext]') } }, { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url', query: { limit: 10000, name: path.posix.join('static', 'fonts/[name].[hash:7].[ext]') } } ] }, plugins: [ new HtmlwebpackPlugin({title: 'a'}) ] } module.exports = merge(baseWebpackConfig, { }) # 插件 内置 # 通过webpack.BannerPlugin获得 bannerPlugin htmlWebpackPlugin hotModuleReplacement grunt # 介绍 压缩js代码 合并js文件 单元测试 js代码检查 监控文件修改重启任务 命令 grunt dist # 重新生成dist目录，将编译后的css,js放入 grunt watch # 监测less源码文件改动，自动重新编译为css grunt test # 运行测试用例 grunt docs # 编译并测试 grunt 重新构建所有内容并运行测试用例 安装 # grunt模块以grunt-contrib-开头 npm i -g grunt grunt-init grunt-cli 例子 o-\u0026gt; // Gruntfile.js module.exports = function (grunt) { grunt.loadNpmTasks('grunt-contrib-clean') grunt.loadNpmTasks('grunt-contrib-concat') grunt.loadNpmTasks('grunt-contrib-jshint') grunt.loadNpmTasks('grunt-contrib-uglify') grunt.loadNpmTasks('grunt-replace') grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), jshint: { all: { src: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'], options: { jshintrc: 'jshint.json' } } }, clean: ['lib'], concat: { htmlhint: { src: ['src/core.js', 'src/reporter.js', 'src/htmlparser.js', 'src/rules/*.js'], dest: 'lib/htmlhint.js' } }, uglify: { htmlhint: { options: { banner: 'a', beautify: { ascii_only: true } }, files: { 'lib/\u0026lt;%= pkg.name %\u0026gt;.js': ['\u0026lt;%= concat.htmlhint.dest %\u0026gt;'] } } }, relace: { htmlhint: { files: {'lib/htmlhint.js': 'lib/htmlhint.js'}, options: { prefix: '@', variables: { 'VERSION': '\u0026lt;%= pkg.version %\u0026gt;' } } } } }) grunt.registerTask('dev', ['jshint', 'concat']) grunt.registerTask('default', ['jshint', 'clean', 'concat', 'uglify', 'replace']) } gulp # 介绍 自动化构建项目工具 使用 安装 npm install --global gulp # npm install --save-dev gulp // gulpfile.js 在项目根目录 var gulp = require('gulp'); gulp.task('default', function () { // 默认任务代码 }) 命令 shell\u0026gt; gulp # gulp \u0026lt;task\u0026gt; \u0026lt;othertask\u0026gt; 插件 gulp-dom-src 合并src, 改写html gulp-if gulp-useref gulp-usemin gulp-htmlreplace google-closure-compiler gulp-add-src gulp-autoprefixer gulp-changed gulp-clean gulp-clean-css gulp-concat gulp-concat-css gulp-consolidate gulp-html-replace # 替换html内容 gulp-htmlmin gulp-imagemin gulp-less gulp-make-css-url-version gulp-minify-css gulp-rev-append gulp-uglify fis # 介绍 npm的形式发布 百度前端工具框架，为前端开发提供底层架构 所有js文件都用模块书写，一个文件一个模块 F.module(name, function(require, exports){}, deps); 安装 npm install -g fis 命令 fis install # 安装模块 fis release # 编译和发布, -h 查看帮助 ## 默认会调整资源引用的相对路径到绝对路径 ### 不想对路径做调整，可以使用spt工具https://github.com/fouber/spt ## --optimize 或 -o 压缩。--md5对不同静态资源生成版本，也可以配置时间戳 ## --dest 或 -d。指定项目发布配置，在执行编译后发布。可以远程发布、发布多个 ## --pack 开启打包处理 ## -omp 简化 --optimize --md5 --pack ## --watch 或 -w 自动监听文件修改，自动编译 ### 该监视考虑了各种嵌入关系, a.css中嵌入了b.css, b修改时会重构这两个文件 ### --live 或 -L 。在-w基础上实现，监视到修改后自动刷新浏览器页面 fis server start # 启动本地调试服务器 ## -p [port] 指定新端口 ## --type node 如果没有java, php环境，指定用node环境启动 fis server stop fis server open # 查看默认产出目录 配置 o-\u0026gt; fis.config.set('pack', { 'pkg/lib.js': [ '/lib/mod.js', '/modules/underscore/**.js', 'modules/backbone/**.js' ] }); # 文件合并成lib.js，但是不替换页面中的静态资源引用 ## 为了替换引用，使用fis的后端静态资源管理来加载引用，或者用fis-postpackager-simple插件 o-\u0026gt; fis.config.set('roadmap.path', [{ reg: '**.css', useSprite: true }]); # 为所有样式资源开启csssprites, 该插件在fis中内置 fis.config.set('settings.spriter.csssprites.margin', 20); # 设置图片合并间距 ## 要在要合并的图片引用路径后面加?__sprite来标识 ## 被合并图片中的小图, background-position来分图的情况也支持 组件 yogurt 基于express 的nodejs框架 fis-plus fis + php + smarty gois fis + go + margini jello fis + java + velocity pure 纯前端框架 插件 fis-postpackager-simple 介绍 fis-plus和yogurt不需要 安装 npm install -g fis-postpackager-simple 配置 // fis-conf.js fis.config.set('modules.postpackager', 'simple'); # 打包时自动更改静态资源引用 fis.config.set('settings.postpackager.simple.autoCombine', true) # 开启按页面自动合并css, js文件 fis-parser-less 介绍 less模板 npm install -g fis-parser-less 配置 fis.config.set('modules.parser.less', 'less'); # 'modules.parser.less'表示后缀名less的文件，'less'表示用fis-parser-less编译 fis.config.set('roadmap.ext.less', css) # 将less文件编译为css 写法 # jquery prototype $() # 简写document.getElementById() $F() # 返回表单 $A() # 参数转成数组对象 mootools # 浏览器原生对象扩展 underscore # 函数式 underscore-contrib # 扩展underscore ramda # 函数式，较正确 lodash # 函数式 functional javascript bilby # 函数式库，包含dispatch, 蹦床, monadic, validator等 allong.es # 提供函数组合子 sweet # 支持宏 zepto # 小型jquery kissy # 小型jquery rxjs # 微软开发，将异步流捕获成值的库 tangram # 百度前端工具集 qwrap # 360前端工具集 解释器 # typescript # 扩展语言 coffeescript # 扩展语言 system.js 介绍 一个垫片库, 浏览器端l加载es6模块、AMD模块、CommonJS模块 到es5。内部调用traceur \u0026lt;script src='system.js'\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; System.import('./app').then(function(m) { # app.js是一个es6模块 m.f() }) \u0026lt;/script\u0026gt; traceur 介绍 在线转换，将ES6代码编译为ES5 使用 npm install -g traceur traceur /path/es6 # 运行ES6文件 traceur --script /path/es6 --out /path/es5 # 转换 babel 使用 npm install -g babel-cli npm install --save babel-core babel-preset-es2015 // .babelrc { \u0026quot;presets\u0026quot;: [\u0026quot;es2015\u0026quot;], \u0026quot;env\u0026quot;: { \u0026quot;dev\u0026quot;: { # 在NODE_ENV=dev时使用特性 \u0026quot;presets\u0026quot;: [\u0026quot;react-hmre\u0026quot;] } } } babel-node babel es6.js # babel es6.js -o es5.js # babel -d build source -s ## -s 是产生source-map 插件 babel-preset-react-hmre # react热加载 .babelrc中配置 \u0026quot;react-hmre\u0026quot; transpiler 介绍 google的es6模块加载转为CommonJS或AMD模块加载的工具 使用 npm install -g es6-module-transpiler compile-modules convert es6.js es5.js # compile-modules convert -o out.js file1.js 数据绑定 # mobx # 状态管理，应用(ui, 数据, 服务器)状态可自动获得 终端 # 跨平台 # atom electron node-webkit atom-shell nw.js polymer # 构建在底层的html扩展，构建跨desktop, mobile等平台的web应用 mpx # 小程序框架 wepy # 小程序 taro # 生成多端 chameleon uniapp # vue到多端 mpvue # vue小程序 megalo # vue小程序 运行时跨平台 # 微信小程序 华为快应用 react native rax weex fuse nativeScript tabris android # 结构 applications: 如browser application framework(相当于api): 如window manager libraries(库): 如openGL,SQLite runtime(运行环境): core libraries + Dalvik VM linux kernel(系统api): 如wifi Driver android sdk 命令 platform-tools/adb adb install *.apk # 当前模拟器中安 装软件 adb remount adb shell su # 当前模拟器中执 行linux命令 tools/emulator-arm @test # 启动一个模拟器 框架 atlas # 阿里开源的android native容器化组件框架 webview litho # 声明式ui jetpack compose # 声明式ui ios # componentKit # 声明式ui 功能 # 格式 # uglifyjs2 # 序列化 模板 # 介绍 引擎的一个优点就是可以直接把数据渲染到js中使用 优点 可以把动态页面的模板缓存起来，第一次请求之后，只需要更新数据 # 应该可以后端nginx缓存静态模板来提高性能 velocity # java模板 ejs hogan.js handlebars # 写法类似anglarjs模板 jstl # java模板 less # css模板 stylus # css模板 swig # {% autoescape true %} {{ myvar }} {% endautoescape %} {% block body %} ... {% endblock %} {% if false %} {% elseif true%} {% else %} {% endif %} {% extends \u0026quot;./layout.html\u0026quot; %} {% filter uppercase %} oh hi, {{ name }} {% endfilter %} # =\u0026gt; OH HI, PAUL {% filter replace(\u0026quot;.\u0026quot;, \u0026quot;!\u0026quot;, 'g\u0026quot;) %} Hi. My name is Paul. {% endfilter %} # =\u0026gt; Hi! My name is Paul! {% for x in obj %} {% if loop.first %}\u0026lt;ul\u0026gt;{% endif %} \u0026lt;li\u0026gt;{{ loop.index }} - {{ loop.key }}: {{ x }}\u0026lt;/li\u0026gt; {% if loop.last %}\u0026lt;/ul\u0026gt;{% endif %} {% endfor %} {% for key, val in arr|reverse %} {{ key }} -- {{ val }} {% endfor %} {% import './formmacros.html' as forms %} {{ form.input(\u0026quot;text\u0026quot;, \u0026quot;name\u0026quot;) }} # =\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot;\u0026gt; {% import \u0026quot;../shared/tags.html\u0026quot; as tags%} {{ tags.stylesheet('global')}} // =\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/global.css\u0026quot;\u0026gt; {% include \u0026quot;./partial.html\u0026quot; %} {% include \u0026quot;./partial.html\u0026quot; with my_obj only%} {% include \u0026quot;/this/file/does/not/exist\u0026quot; ignore missing%} {% macro input(type, name, id, label, value, error)%} \u0026lt;label for=\u0026quot;{{ name }}\u0026quot;\u0026gt;{{ label }}\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;{{ type }}\u0026quot; name=\u0026quot;{{ name }}\u0026quot; id=\u0026quot;{{ id }}\u0026quot; value=\u0026quot;{{ value }}\u0026quot; {% if error%} class=\u0026quot;error\u0026quot; {% endif %}\u0026gt; {% endmacro %} {{ input(\u0026quot;text\u0026quot;, \u0026quot;fname\u0026quot;, \u0026quot;fname\u0026quot;, \u0026quot;First Name\u0026quot;, fname.value, fname.errors) }} {% extends \u0026quot;./foo.html\u0026quot; %} {% block content %} My content {% parent %} {% endblock %} {% raw %}{{ foobar }}{% endraw %} {% set foo = \u0026quot;anything!\u0026quot;%} {{ foo }} {% spaceless %} {% for num in foo %} \u0026lt;li\u0026gt;{{ loop.index }}\u0026lt;/li\u0026gt; {% endfor %} {% endspaceless %} # 除去空白 显示 # highcharts nvd3.js # svg报表 echarts d3 # 介绍 数据可视化, 使用svg, css3 使用 node npm install d3 // var d3 = require('d3'), jsdom = require('jsdom'); var document = jsdom.jsdom(), svg = d3.select(document.body).append('svg'); web \u0026lt;script src=\u0026quot;//d3js.org/d3.v3.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;d3.version\u0026lt;/script\u0026gt; d3对象 // 选择器 event mouse select selectAll selection touch touches // 过渡 ease # ease对象 timer flush interpolate # interpolate对象 interpolateArray interpolateHcl interpolateHsl interpolateLab interpolateNumber interpolateObject interpolateRgb interpolateRound interpolateString interpolateTransform interpolateZoom interpolators transition // 数组 ascending bisectLeft bisector bisectRight bisect descending deviation entries extent keys map max mean median merge min nest pairs permute quantile range set shuffle sum transpose values variance zip // 数学 random transform // 请求 csv html json text tsv xhr xml // 格式化 format formatPrefix requote round // 本地化 locale // 颜色 hcl hsl lab rgb // 命名空间 ns // 内部 dispatch functor rebind // 比例尺 scale // 时间 time // 布局 layout // 地理 geo // 几何 geom // 行为 behavior 效果 # touch.js # 触摸 move.js # div运动 swiper # 滑动效果 cordova # 访问原生设备，如摄像头、麦克风等 egret.js # 使用TypeScript的HTML5开发引擎, 一套完整的HTML5游戏开发解决方案 tweenMax # 扩展TweenLite, 用于制作html5动画 juliusjs # 语音识别 babylon # microsoft webgl框架 cubicVR # 高性能webgl框架, paladin游戏引擎的一部分 scenejs # webgl模型 glge # webgl框架 pose # mvvm react-motion # mvvm react-transition-group # mvvm 视频 # ezuikit # 萤石sdk, 直播, 监控, 支持多平台 应用框架 # 显示 # bootstrap flutter # google移动端框架, 声明式ui extjs 介绍 2.0之前是免费的，但有内在泄漏总是 GPLv3版本后收费 Sencha 1.是ExtJS、jQTouch(一个用于手机浏览器的jquery插件) 以及 Raphael（一个网页上绘制矢量图形的js库） 三个项目合并而成的一个开源项目。 2.Sencha Touch 是全球领先的应用程序开发框架，其设计旨在充分 利用HTML5、CSS3 和Javascript 来实现最高级别的功能、灵活性和优化。 Sencha Touch 是针对下一代具有触摸屏设备的跨平台框架。 jquery ui dojo # 语法较难用 easy ui 文件 jquery.js easyui.js easyui-lang-zh_CN.js easyui.css icon.css layui # 模块化ui mini ui # 收费 wijmo # 收费 dwz # 卖文档 vaadin # apache webkit foundation # 响应式，移动优先 boilerplate # h5模板 meteor # 融合前后端, 后端node knockout # mvvm, 利于单页应用 jingle # 手机 ionic # angular手机框架 framework7 # ios(兼容android)组件 mui # 手机 zui # 手机，类bootstrap frozenui # 手机 数据可视化 # highcharts chart.js # api不好用 three.js d3 # 太底层, 概念已陈旧 mapbox # 地图 echarts # 开源 recharts # 新出现 v-charts # vue+echarts, 饿了么开发 superset # apache antv # 蚂蚁金服, 图表丰富 thingJS # 3d建模 cityBuilder # 3d建模 dataV # 收费, 阿里 sugar # 收费, 百度 云图 # 收费, 腾讯 fineReport # 收费, 帆软, 大屏 tableau # 收费, 大屏 easyV # 收费, 袋鼠云 gitDataV # https://github.com/HongqingCao/GitDataV 富应用 # react angular # google开发, mvvm ng(core module)包含的核心组件 directive # 指令 ngClick ngInclude ngRepeat service # 服务, 依赖注入后使用 $compile $http $location filter # 过滤器，转换模板数据 filter date currency lowercase function # 函数 angular.copy() angular.equals() angular.element() 组件 ngRoute # url后#地址(hash) 来实现单面路由 使用 引入angular-route.js 依赖注入ngRoute模块 服务 $routeParams # 解析路由参数 $route # 构建url, view, controller的关系 $routeProvider # 配置 指令 ngView # 路由模板插入视图 ngAnimate # 动画效果 使用 引入angular-animate.js 注入ngAnimate 服务 $animate # 触发 css动画 # 用nganimate结构定义，通过引用css到html模板触发 js动画 # 用module.animation注册，通过引用css到html模板触发 ngResource # 动画 ngMock # 动画 ngTouch # 触摸 ngAria # 帮助制作自定义模块 ngCookies riot ember vue \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; {{ message }} \u0026lt;/div\u0026gt; var app = new Vue({ el: '#app', data: { message: \u0026quot;hi\u0026quot; }, created: function () {} }) backbone 效果 # three.js createjs # # easeljs 介绍 处理canvas 使用 var stage = new createjs.Stage(\u0026quot;canvasName\u0026quot;); stage.x = 100; stage.y = 100; var text = new createjs.Text(\u0026quot;Hello\u0026quot;, \u0026quot;36px Arial\u0026quot;, \u0026quot;#777\u0026quot;); stage.addChild(text); stage.update(); # tweenjs 介绍 处理动画调整和js属性 使用 var circle = new createjs.Shape(); circle.graphics.beginFill(\u0026quot;#FF0000\u0026quot;).drawCircle(0, 0, 50); stage.addChild(circle); createjs.Tween.get(circle, {loop: true}) .wait(1000) .to({scaleX: 0.2, scaleY: 0.2}) .wait(1000) .to({scaleX:1, scaleY:1}, 1000, createjs.Ease.bounceInOut) createjs.Ticker.setFPS(20); createjs.Ticker.addEventListener(\u0026quot;tick\u0026quot;, stage); # soundjs 介绍 简化处理音频 使用 var displayStatus; displayStatus = document.getElementById(\u0026quot;status\u0026quot;); var src = \u0026quot;1.mp3\u0026quot;; createjs.Sound.alternateExtensions = [\u0026quot;mp3\u0026quot;]; createjs.Sound.addEventListener(\u0026quot;fileload\u0026quot;, playSound()); createjs.Sound.registerSound(src); displayStatus.innerHTML = \u0026quot;Waiting for load to complete\u0026quot;; function playSound(event){ soundIntance = createjs.Sound.play(event.src); displayStatus.innerHTML = \u0026quot;Playing source: \u0026quot; + event.src; } # preloadjs 介绍 协调程序加载项的类库 使用 var preload = new createjs.LoadQueue(false, \u0026quot;assets/\u0026quot;); var plugin= { getPreloadHandlers: function(){ return{ types: [\u0026quot;image\u0026quot;], callback: function(src){ var id = src.toLowerCase().split(\u0026quot;/\u0026quot;).pop().split(\u0026quot;.\u0026quot;)[0]; var img = document.getElementById(id); return {tag: img}; } } } } preload.installPlugin(plugin); preload.loadManifest([ \u0026quot;Autumn.png\u0026quot;, \u0026quot;BlueBird.png\u0026quot;, \u0026quot;Nepal.jpg\u0026quot;, \u0026quot;Texas.jpg\u0026quot; ]); 游戏 # cocos2dx # 跨平台游戏 "},{"id":51,"href":"/docs/misc/","title":"杂项","section":"Docs","content":" 面试题 # 带笔记本 # 算法 # 目标 写bug free算法 o-\u0026gt; 链表反转 递归、非递归 o-\u0026gt; ArrayList, ThreeMap, HashMap 的原理和模拟 o-\u0026gt; 灵活运用栈与队列 o-\u0026gt; 9大排序代码，时间复杂度与空间复杂度，优缺点 o-\u0026gt; 矩阵加法、减法、乘法、100个矩阵乘法与最优结合次序 o-\u0026gt; 邻接表、邻接矩阵、深搜、广搜、拓扑排序、最短路径、最小生成树 o-\u0026gt; 单链表有没有超过5个字符的回文子串 o-\u0026gt; 单链表最长回文子串 o-\u0026gt; 浮点数组(会相等)二分查找 o-\u0026gt; 任意大整数类型,至少支持乘法 o-\u0026gt; 100内素数 o-\u0026gt; 随机填充100内整数不重复 o-\u0026gt; 找字符串第一个无重复字符, 统计字符重复次数 o-\u0026gt; 第n个斐波那契数 o-\u0026gt; 递增数组，求和为m的两数 o-\u0026gt; 1元两瓶水, 两空瓶一瓶水, n元几瓶水 o-\u0026gt; 无序数组，第k大数 o-\u0026gt; 二维数组用0,1填充, 1有障碍, 任意两点最短路径、步数 o-\u0026gt; 重量不同多个小球，合并用力为重量和。两两合并到剩一个，总用力最小。写代码求最优 Book # 《错误之书：改变你一生的9个秘密》 # 错误之一：活在别人为你设定的剧本里 错误之二：任由他人决定你的价值 错误之三：凡事总爱找借口 每一个借口背后都隐藏着通信成功的大门 错误之四：结交错误的朋友 远离说“不”的人、怀疑论者和负能量的人，多结交鼓励者、激励者和成功人士 错误之五：不愿走出舒适圈 胜利者其实一直在“自找苦吃”。 领袖们会不断地走出舒适圈，寻求突破。 平庸本就是享尽舒适的最终结局。 错误之六：让暂时的挫折变成永久的失败 不要让一时的现状决定 了你未来的命运。 一旦你给自己贴上负面标签，挫折就会变得异样复杂。 成功人士会将一时的失败视作能往成功之路的阶梯。 错误之七：放任自己，随波逐流 独树一帜，也就意味着不断超越自我 独树一帜既是真实的自我 错误之八：认为获得成功的途径是有限的 世上的机会是无限的，人的潜能也是无止境的。 我们唯一要担心的就是思维的限度。 错误之九：挥霍光阴，不加珍惜 每日的忧虑背后隐藏着时间的馈赠。抛开忧虑，珍惜当下。 《七个习惯》 # 一、主动 二、以终为始 三、第一原理 四、双赢 五、共情 六、1+1\u0026gt;2 七、更新 英语 # 发音 # spelling and numbers Acronym ibM, miT, ph.D mbA lA iQ revP ciA fbI coD soS xyZ Spelling boX cooK wiLsoN sentence stress with descriptive phrases It's SHORT. It's a short NAIL It's CHOCOLATE. It's a chocolate CAKE. contrasting description and a set phrase It's a short NAIL. It's a FINGERnail It's a chocolate CAKE. It's a PANcake T,D,S or Z + Y T + Y = CH what's your name can't you do it? actually don't you like it? wouldn't you? havent' you? no, not yet. I'll let you know can i get you a frink? we thought you weren't coming I'll bet you ten bucks he forgot 洒悠然国遥？ D + Y = J did you see it? how did you like it? could you tell? where did you send your check? what did your family think? we followed your instructions S + Y = SH yes, you are bless you! press your hands together can you dress yourself you can pass your exams this year I'll try to guess your age let him gas your car for you Z + Y = ZH how's your rfamily? how was your trip? Who's your friend? Where's your mon When's your birthday? She says you're OK Who does your hair? casual visual usual version vision The American T T is T at the beginning of a word or in a stressed syllable T is D in the middle of a word T is held at the end of a word T is held before N T is silent after N with lax vowels 缩写 # gtd get things done lgtm looks good to me "},{"id":52,"href":"/docs/architect/method/project_plan/","title":"项目规划","section":"Method","content":" 平台服务 # aPaaS # # platform as a service，介于IaaS和SaaS中间 将软件研发的平台做为服务，以SaaS的模式交付 组件化支撑和驱动 # 组件的发展决定paas广度，组件的聚合决定paas深度 # 对内固守组件边界，对外暴露标准接口 分层 平台组件 基础业务 # 不可见，影响全局，通用业务逻辑，对性能很敏感 业务 组件 设计 # 自描述的，这样就在设计和开发上解耦 确定边界 定义标准接口 确定核心功能 规范异常处理 开发 # 像开发dsl一样,来评判核心逻辑和接口，抽象度高 技术评审 定义接口 # 面向接口开发，也称为BDD dubbo、grpc等 restful 接口设计 标准化 说明 服务路由 版本管理 授权管理 核心理念 # 体现在 服务、工具、模型、规范 开放 而非 封闭 合作 而非 限制 共享 而非 替代 重点关注 基础业务 组织架构和用户组 审批流 权限 通用模型 透明分布式缓存模型 分布式存储模型 分布式事务模型 效率工具 数据迁移工具 缓存配置工具 SaaS # aws线上云 微服务 + gRPC + k8s + Istio Golang + TypeScript + Python TiDB 行为分析 # 埋点 # 架构 数据采集 客户端采集 服务器采集 业务系统 第三方渠道 数据治理 ETL 实时ID mapping 元数据管理 数据质量管理: 数据校验, 实时导入监控，异常报警，debug数据查询，用户关联校验，数据质量看板 数据仓库 数据模型：Event, User, Item内容 实时导入系统 存储引擎、查询引擎 数据智能 特征工程 特征选择 模型训练: 深度学习, 自然语言处理，时序预测，GBDT/LR, AutoML 模型可视化 在线服务 工具 采集: SDK(JS, Android, iOS, 小程序，服务端，全埋点), ID Mapping, 归因链路 实施工具: 事件管理，变量管理，命名工具，埋点SLA配置, 预警配置，session管理，生命周期管理，tag管理，测试工具，ABTest工具 分析工具: 事件分析，漏斗分析，分布分析，留存分析，数据看板，热图分析，归因分析，自定义SQL查询, API管理，广告和活动效果监测 实现方式 代码埋点 全埋点、可视化全埋点（圈选） 规范 结构与命名清晰 方便历史版本对比 每个埋点数据质量负责到人（开发、测试、数据负责人） 数据统一管理 尽量用工具自动化 企业中台 # 数据 租户 用户 micro service 每个service监控 每个service不单点 单功能拆分，边界明确 service间只依赖sdk(好莱坞法则)，通过服务总线发现 servcie无状态接入 分类 内部服务 internal # 内外服务用互相转化 文件上传 图像处理 数据挖掘 报表 外部服务 external # 流控、质量监控、多链路备用、降级方案 邮件 短信 推送 cti 企业信息校验 业务服务 transaction 审批流 工作流 登录 海 核心服务 core 租户id服务 检索服务 报表服务 监控服务 k8s 服务总线 支持服务 supportive 文档 测试环境 沙盒同步 插件服务 plugin 集成服务 integration 事务服务 finance CPQ ERP saas基础 计费 用户管理 联动 导入企业数据 调用aws或aliyun，提供webhook 服务的sdk 多语言sdk 降级 ha apm 服务监控 # 用于发现问题、追查事故、评估缩容或扩容、评估降级 日志 接口 # 调用服务提供的监控接口 系统 # 容器提供 apm # 客户端采样 可达性 # 由通用监控完成 工程 打包docker镜像 服务升级 灰度发布与AB test 提供api版本接口供客户端查询 服务总线 管理服务状态、位置 本地生活 # 服务与功能\n"},{"id":53,"href":"/docs/middleware/","title":"中间件","section":"Docs","content":" 容器服务 # tomcat # ## 介绍 tomcat从7开始默认就是nio的 ## 配置 bin/startup.bat set JAVA_HOME= # 设置tomcat运行jdk context.xml \u0026lt;Loader delegate=\u0026quot;true\u0026quot;/\u0026gt; # true表示使用java加载器的代理模式 ## false代表永远先在Web应用程序中寻找 web.xml Content-Type: text/x-zim-wiki Wiki-Format: zim 0.4 Creation-Date: 2013-08-04T19:40:08+08:00 ====== web.xml文件 ====== Created Sunday 04 August 2013 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1 \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt; \u0026lt;param-value\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt; \u0026lt;filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt; \u0026lt;url-pattern\u0026gt; \u0026lt;mime-mapping\u0026gt; \u0026lt;extension\u0026gt;bmp \u0026lt;mime-type\u0026gt;image/bmp \u0026lt;error-page\u0026gt; \u0026lt;exception-type\u0026gt;异常类的完全限定名 /\u0026lt;error-code\u0026gt;错误码 \u0026lt;location\u0026gt;以“/”开头的错误处理页面路径 ## 启动顺序 web.xml中配置的启动顺序 监听器 过滤器 servlet load-on-startup属性值越小越先启动 tomcat的加载过程： # 分析启动日志得到 启动http协议 启动catalina 启动servlet引擎 加载xml配置文件 初始化日志配置 初始化ContextListener 初始化SessionListener 部署web项目 spring监听器，加载xml配置(开始spring自己的日志记录) 实例化bean 初始化c3p0连接池的记录显示 初始化LocalSessionFactoryBean的记录显示 application监听器(监听器按配置顺序启动) struts过滤器，加载xml配置(开始struts自己的日志记录) struts-default.xml 根据其中配置的bean属性加载类，并记录了日志 struts-plugin.xml # 里面有加载spring-struts-plugin包 初始化struts-spring 集成 struts.xml ## 目录 LICENSE NOTICE RELEASE-NOTES RUNNING.txt bin bootstrap.jar commons-daemon.jar tomcat-juli.jar tomcat-native.tar.gz commons-daemon-native.tar.gz catalina.bat shutdown.bat startup.bat cpappend.bat digest.bat setclasspath.bat tool-wrapper.bat version.bat catalina.sh shutdown.sh startup.sh digest.sh setclasspath.sh tool-wrapper.sh version.sh catalina-tasks.xml conf catalina.policy catalina.properties logging.properties context.xml server.xml tomcat-users.xml web.xml Catalina localhost host-manager.xml manager.xml lib annotations-api.jar catalina.jar catalina-ant.jar catalina-ha.jar catalina-tribes.jar el-api.jar jasper.jar jasper-el.jar jasper-jdt.jar jsp-api.jar servlet-api.jar tomcat-coyote.jar tomcat-dbcp.jar tomcat-i18n-es.jar tomcat-i18n-fr.jar tomcat-i18n-ja.jar log catalina.2013-07-28.log等等 webapps ROOT WEB-INF web.xml docs examples manager host-manager tmp work 发布 conf/server.xml 中8080端口 位置 \u0026lt;Context path=\u0026quot;/bbs\u0026quot; reloadable=\u0026quot;true\u0026quot; docBase=\u0026quot;E:\\workspace\\bbs\u0026quot; workDir=\u0026quot;E:\\workspace\\bbs\\work\u0026quot; /\u0026gt; 发布war文件： localhost:8080 -\u0026gt; tomcat manager -\u0026gt; WAR file to deploy netty # 介绍 JBOSS提供，由Trustin Lee开发，比mina晚 java开源框架 对比java nio java原生nio有bug(epoll bug)且编写困难, 网络可靠性自己处理 netty设计优雅，使用方便，高性能、稳定 原理 基于socket的数据流处理 # socket数据流不是a queue of packets , 而是a queue of bytes, 所以分次传输的数据会成为a bunch of bytes 例子 Handler ChannelHandler ChannelOutboundHandler ChannelOutboundHandlerAdapter # 可作Encoder MessageToByteEncoder ChannelInboundHandler # 提供可重写的事件 ChannelInboundHandlerAdapter ByteToMessageDecoder # easy to deal with fragmentation issue 事件 decode(ctx, in, out) # 内部处理过数据，堆积到了buffer(in) ## out中add了数据, 表示decode成功，则执行后抛弃in中数据 # decode会被循环调用直到有一次out中没有add东西 ReplayingDecoder 事件 channelRead() # 从client接收到数据时调用，数据的类型是ByteBuf ## ByteBuf是 reference-counted object ## 必须用ReferenceCountUtil.release(msg)或((ByteBuf) msg).release()来明确释放 exceptionCaught() # 当抛出Throwable对象时调用 channelActive() # as soon as a connection is established 方法 handlerAdded() handlerRemoved() ByteBuf 方法 buf.writeBytes(m) # 将m[ByteBuf]中的数据 cumulate into buf[ 定长的ByteBuf, 如ctx.alloc().buffer(4) ] isReadable() # 返回ByteBuf中data的长度 ChannelHandlerContext # 用于触发一些i/o事件 方法 write(msg) # msg在flush后自动realease write(msg, promise) # promise是ChannelPromise的对象，用来标记msg是否确切地写入到管道中 flush() writeAndFlush(msg) # 返回ChannelFuture alloc() # 分配缓冲区来包含数据 ByteBufAllocator buffer(4) # 返回存放32-bit Integer的ByteBuf Server EventLoopGroup NioEventLoopGroup # 多线程 i/o eventloop 方法 shutdownGracefully() # 返回Funture类来通知group是否完全关闭并且所有group的channels都关闭 ServerBootstrap # 建server的帮助类，链式编程 ## 可以直接用Channel来建server 方法 group(bossGroup, workerGroup) # boss接收连接，worker处理boss中的连接 group(workerGroup) # 只有一个参数时，该group即作boss也作worker channel(NioServerSocketChannel.class) # 用来接收连接的channel的类型 channel(NioSocketChannel.class) # create client-side channel childHandler(channelInitializer) # 新接收的channel总执行本handler ## 只有workerGroup时不用 option(ChannelOption.SO_BACKLOG, 128) # channel实现的参数 childOption(channelOption.SO_KEEPALIVE, true) # option设置boss, childOption设置worker ## 在只有workerGroup时不用childOption,因为它没有parent bind(port) # 开始接收连接，返回的是ChannelFuture ## 绑定网卡上的所有port端口，可以bind多次到不同的端口 ChannelInitializer # 帮助设置channel, 如设置channel的pipeline中的handler 实例 new　ChannelInitializer\u0026lt;SocketChannel\u0026gt;(){ @Override public void initChannel(SocketChannel ch) throws Exception{ ch.pipeline().addLast(new DiyHandler()); } } ChannelFuture 方法 sync() channel() # 返回Channel addListener(channelFutureListener) Channel closeFuture() # 返回ChannelFuture ChannelFutureListener 实例 new ChannelFutureListener(){ // 当请求结束时通知 @Override public void operationComplete(ChannelFuture future){ assert f == future; ctx.close(); } } client Bootstrap # for non-server channels such as a client-side or connectionless channel connect(host, port) netty-tcnative # 介绍 tomcat native 的分支 特点 简化本地库的分配和连接 可以maven配置dependency 提供openssl的支持 jetty # # 是开源的servlet容器，基于java, 可以给jsp和servlet提供运行环境 # jetty容器可以实例化成一个对象，迅速为一些独立运行(stand-alone)的java应用提供网络和web连接 apache # # http容器，可容纳php, python。一请求一线程 安装 pacman -S apache mkdir /srv/http chown http:http /srv/http 编译安装 ./configure --prefix=/全路径/install_path --with-apxs2=/全路径/apxs # 模块 make make install 命令 httpd -f # 指定配置 -t # 配置检查 -k start restart graceful stop graceful-stop apachectl graceful # 重载配置 -f /全路径/httpd.conf # 指定配置 -t # 配置检查 配置 /etc/httpd/conf/httpd.conf DocumentRoot \u0026quot;/srv/http\u0026quot; # 项目路径 Listen # 端口 案例 php docker解决 lighttpd # meteor # # 包装node ringojs # # jvm上commonJs规范的服务器 mina # apache提供， 由Trustin Lee开发，比netty更早 tomcat native # # 基于apr(apache portable runtime)技术，让tomcat在操作系统级别的交互上做的更好 tinyHttpd # resin # # 收费, 类似tomcat的java容器，性能提升 uwsgi # # 一个web服务器，实现了wsgi, uwsgi, http等协议 weblogic # # oracle was # # ibm服务器 gunicon # # python wsgi http server node.js # OpenResty # # 基于Nginx扩展 Tengine # # 基于Nginx扩展 数据库访问 # Druid # Sharding JDBC # 缓存 # 缓存失效策略 FIFO(First Input First Output) LRU(Least Recently Used) LFU(Least Frequently Used) 客户端缓存 # Header Cache-Control: no-cache, no-store, max-age=0, must-revalidate Vary: Accept-Encoding Vary: Origin Vary: Access-Control-Request-Method Vary: Access-Control-Request-Headers Vary: Origin Vary: Access-Control-Request-Method Vary: Access-Control-Request-Headers 本地缓存 # Ehcache 堆内、堆外、磁盘三级缓存，可按容量制定缓存策略 可按时间、次数制定过期策略 Guava Cache 堆内缓存 Nginx本地缓存 Nginx PageSpeed插件 缓存服务 # HTTP Nuster 基于HAProxy的HTTP缓存服务器 Varnish 3台Varnish代替12台Squid Squid Memcached Redis Tair 配置、服务发现 # Apollo # # 支持推、拉模式更新 Eureka # Nacos # RPC # Dubbo # Thrift # gRPC # 消息队列 # 消息重发 状态表记录消息状态 pulsar # # 雅虎开源, 存储和服务分离，高可用存储, 支持流 rabbitMQ # 介绍 erlang开发, 重量级 支持协议多，AMQP、XMPP、SMTP、STOMP Broker构架 # 消息在中心队列排队 install yum install rabbitmq-server 命令 添加用户: rabbitmqctl add_user rainbird password 添加权限: rabbitmqctl set_permissions -p \u0026quot;/\u0026quot; rainbird \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot; 删除测试用户: rabbitmqctl delete_user guest 原理 虚拟主机 virtual host: 用户通过虚拟主机进行权限控制(如禁止A组访问B组的交换机) ＃ 默认虚拟主机为\u0026quot;/\u0026quot; 队列 queue: 由生产者(producers)通过程序建立，再通过消费者(consuming)连接取走 消息: 路由键 routing key 交换机 exchange: 负责把消息放入队列 绑定 binding(路由规则): 如指明交换机中具有路由键\u0026quot;X\u0026quot;的消息要到名为\u0026quot;Y\u0026quot;的队列中去 # 如果同一个键对应多个队列，则复制后分别发送 功能 持久化 队列和交换机创建时指定标志durable,指定队列和交换机重启生重建 ＃ 如果绑定了durable的队列和durable的交换机，该绑定自动保留 ＃ non-durable的交换机与durable的队列不能绑定 ＃ 一但创建durable标志，不能修改 消息发布到交换机时，指定标志Delivery Mode=2,这样消息会持久化 使用(原文http://adamlu.net/rabbitmq/tutorial-one-python) 安装python 与插件支持 pip python-pip git python-pika rabbitmq-server start send.py #!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') channel.basic_publish(exchange='', routing_key='hello', body='Hello World!') print \u0026quot; [x] Sent 'Hello World!'\u0026quot; connection.close() receive.py #!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') print ' [*] Waiting for messages. To exit press CTRL+C' def callback(ch, method, properties, body): print \u0026quot; [x] Received %r\u0026quot; % (body,) channel.basic_consume(callback, queue='hello', no_ack=True) channel.start_consuming() jafka # 介绍 基于kafka, 快速持久化(O(1)时间开销) 高吞吐，一台普通服务器 100k/s 完全分布式，Broker, Producer, Consumer原生支持分布式，自动负载均衡 支持hadoop并行加载 kafka # 介绍 apache子项目，scala语言编写, 发布订阅队列 相对activeMQ轻量 特点 push/pull队列架构，适合异构集群 分布式, 高吞吐率, 易扩展 支持数据并行到hadoop 分区有序 批量压缩, 零拷贝, 内存缓冲, 磁盘顺序写入 可持久化 工具 manager # 监控 nsq # 介绍 go 工具 admin # 监控 memcacheQ # zeroMQ # activeMQ # 介绍 apache子项目, 类似zeroMQ 通信方式 点到点 不成功时保存在服务端 发布订阅 不成功消息丢失 beanstalkd # mqtt # # 最早由ibm提供的，二进制消息的mq emqttd # 介绍 mqtt broker apollo # 介绍 apache mqtt broker metaq # # 阿里mq 定时任务 # Cron # XXL Job # quartz # # java作业调度 配置applicationContext_job.xml job # 任务内容 jobDetail # 调度方案 trigger # 时间 scheduler # jobDetail和trigger的容器 状态监控 # 用日志表记录 运行中 JobListener监听器 暂停中 scheduler.pauseTrigger() 等待中 创建job时 celery # # python rundeck # # java 存储服务 # 存储的概念和术语 scsi: 小型计算机系统接口(Small Computer System Interface) fc: 光纤通道(Fibre channel) das: 直连式存储(Direct-Attached Storage) nas: 网络接入存储(Network-Attached Storage) san: 存储区域网络(Storage Area Network) 连接设备: 路由, 光纤交换机, 集线器(hub) 接口: scsi fc 通信协议: ip scsi iscsi # # internet scsi 优点 可以网络传输 服务器数量无限 在线扩容．动态部署 架构 控制器架构: 专用数据传输芯片．专用RAID数据校验芯片．专用高性能cache缓存和专用嵌入式系统平台 iscsi连接桥架构: 前端协议转换设备(硬件) 后端存储(scsi磁盘阵列．fc存储设备) pc架构 存储设备搭建在pc服务器上，通过软件管理成iscsi, 通过网卡传输数据 实现 以太网卡 + initiator软件 toe网卡 + initiator软件 iscsi HBA卡 iscsi系统组成 iscsi initiator 或　iscsi hba iscsi target 以太网交换机 一台或多台服务器 fastdfs # # 开源分布式文件系统 cdn # 介绍 流量不大时带宽比cdn便宜, 流量大时cdn便宜。 界限为250Mbps左右，价格在9k/month 价格 50TB/月 100TB/月 阿里云 3.8w/月 6.9w/月 盛大云 9k/月 1.7w/月 网宿 蓝汛 AWS S3 # 命令 aws s3 cp --recursive bin s3://meiqia/crm-module/search/bin # 级联复制 sync s3://meiqia/crm-module/search/bin bin # 下载 rm --recursive s3://meiqia/crm-module/search # 级联删除 网关 # Zuul # Spring Cloud Gateway # Kong # # 基于OpenResty 日志 # ELK # # elasticsearch, logstash, kibana FileBeat 命令 filebeat --environment systemd -c /etc/filebeat/filebeat.yml --path.home /usr/share/filebeat --path.config /etc/filebeat --path.data /var/lib/filebeat --path.logs /var/log/filebeat log.io # DNS服务 # Nscd # DNS本地缓存 实时计算 # 阿里云Flink 集群 计算单元 vertex拓扑 名词 DataHub源表 RDS维表 RDS结果表 "},{"id":54,"href":"/docs/middleware/library/","title":"小功能","section":"中间件","content":" 名词 # dom 文档对象模型 dao 数据访问对象 ucs unicode character set utf ucs Transformation Format bmp Basic Multilingual plane bom Byte Order Mark asp Active Server Pages iis Internet Information services validate code 验证码 tld tag library description jsp java server page xsd XML Schemas Definition suffix 后缀 ide Integrated Development Environment RIA Rich internet Applications 富互联网应用（富客户端）C/S架构是胖客户端，B/S架构是瘦客户端。比如 flash就是ria(其它如js, SilverLight，unity3d，flash3d,adobe air,HTML5/css3，adobe Flex等) JPA Java Persistence API java持久层api JDBC Java DataBase Connectivity DHTML DynamicHTML cvs Concurrent Version System svn subversion uml UnifiedModelingLanguage AJAX Asynchronous JavaScript and XML bnf 命令书写格式规范: 巴科斯范式 desc description capacity 容量 component 组件 association 联合 aggregation 聚合 composition 组合 alpha 开端 inherit 继承 dhtml dynamic html ,是 html css 客户端script 不是规范，是现有技术、标准的整合运用 css Cascading Style Sheet 级联样式表 associated 交互的 perspective 视图 adapter 适配器 jit just in time (compilation) webdav Web-based Distributed Authoring and Versioning Web 分布式创作和版本管理 (WebDAV) 扩展了 HTTP/1.1 协议，允许客户端发布、锁定和管理 Web 上的资源 CMS Content Management System 内容管理系统 它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。 constraint 约束 JSON javascript object notation(标记) OGNL Object-Graph Navigation Language 对象图导航语言 jmf java media frame java 媒体框架 是一个jar 包 dwr Direct Web Remoting 是一个ajax框架。它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数，就像它就在浏览器里一样。 CXF apache的 Celtix + XFire,用于实现 web services的发布的使用 oa Office Automation 办公自动化 dml data manipulation language 数据操作语言 ddl data definition language 数据定义语言 dcl data control language 数据控制语言 ioc inversion of control 控制反转（spring） di dependence injection 依赖注入 （spring） crud 增加(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete) ssh Secure Shell,由IETF制定，为建立在应用层和传输层基础上的安全协议。 pojo pure old java object oop object oriented programming aop aspect oriented programming 面向切面编程 hdfs Hierarchical Data Format 层次型资料格式（分布式存储） ftp File Transfer Protocol ssl Secure Sockets Layer 安全套接层。端口40 tls Transport Layer Security 传输层安全(ssl的继任者) https Hypertext Transfer Protocol Secure 应用ssl作为应用层子层对数据进行压缩与解压。端口443 jsf JavaServer Faces 是sun开发的web框架，相当于ssh(spring + struts + hibernate) sns Social Network Services 社会性网络服务 uml Unified modeling language 统一建模语言 jta java transaction api (hibernate中) java事务处理api asm Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。 汇编语言(Assembly Language)的扩展名 jsr Java Specification Requests 是Java规范请求，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。jsr303:基于注解的java bean 验证 dto data transfer object 数据传输对象 antlr another tool for language recognition 一个开源的语法分析器 soap simple object access protocol 简单对象访问协议 uefi unified extensible firmware interface 统一可扩展固件接口 sso single sign on 单点登录 erp enterprise resource plan 企业资源计划 sap Systems Applications and Products in Data Procession 企业系列软件(全世界排名第一的erp软件) ssi Server Side Include 服务器端嵌入 jmx Java Management Extensions java管理扩展，是一个为应用程序、设备、系统等植入管理功能的框架。 jaas Java Authentication Authorization Service Java验证和授权API jca(J2C， J2CA) Java Connector Architecture java连接器架构 jms Java Message Service java消息服务，用于在两个应用程序之间，或分布式系统中发送消息 jaf JavaBeans Activation Framework JAF是一个专用的数据处理框架，它用于封装数据，并为应用程序提供访问和操作数据的接口。JAF的主要作用在于让java应用程序知道如何对一个数据源进行查看、编辑和打印等操作。 jta Java Transaction API Java事务API,和jts为J2EE平台提供了分布式事务服务 jts Java Transaction Service java事务服务 scm Supply chain management 一种集成的管理思想和方法，执行供应商到最终用户的物流计划控制职能 ctr click-through-rate 网络广告 ioc/di inversion of control/ dependency injection o2o online to offline 网站提供平台, 用户线下交易 cas central authentication service 单点登录 foobar FTP Operation Over Big Address Records(RFC1545文档)ftp命令列表 modular 模块化 enumeration 计数 navigate 导航 fragment 碎片 posix 可移植的 intersection 截断 categories 类别 encounter 遭遇 recursion 递归 evaluate 评价 indent 缩进 collation 校对 schema 模式、图表 generate 生成 Presentation 描述 hierarchical 垂直分层 stereotype 策略 numerous 许多 KISS keep it simple, stupid cross-origin 跨域 CORS Cross-Origin Resourse Sharing NIH not invented here 自己造轮子 mis management information system crm customer relationship management erp enterprise resource planning webRTC web Real-Time Communication 库 # 日志 # log4j # java logback # log4j后续版本 slf4j # java log4js # js 格式|模板 # moment # js格式化时间 iconv # nodejs调用c++ libiconv库来转码 iconv-lite # nodejs实现的转码，比调用c++ 的iconv更高效 poi # java 文件处理 jFreeChart # java图表库 jackson # java json序列化 json-smart # java json xstream # java xml序列化 pango2 # 国际化模板 snakeyaml # java yaml js-beautify # js, html格式化 xmlbeans # java xml joda-time # java日期 dom4j # java dom 生成|压缩|加密|计算特征 # simhash # google 文档hash pygments # python 生成高亮html mako # python 模板 jinja2 # python 模板 freemarker # java 模板 proguard # java 混淆 snappy # google java 压缩 jbcrypt # java加密, scrypt更强 客户端|邮件 # javamail # java mail nodemailer # node mail mailapi # java mail c3p0 # java rds 连接池 dbcp # java rds 连接池 druid # java rds 连接池。可监控sql执行性能，记sql日志 jdbc # java rds client dbutil hibernate ef # .net orm NHibernate # .net orm peewee # python orm node-mysql mongoose httpClient # java http request # js http superagent # js http mybatis hsqldb # java内置, 单文件/内存数据库 mqttv # java mqtt客户端 libthrift # java thrift kafka-clients 领域语言 # lex # 生成词法分析程序 yacc # 生成自底向上语法分析程序 antlr 图形 # ccap # 基于c++的图形CImg库，就是一个CImg.h文件 canvas # node canvas tesseract # node 验证码 运维控制 # later # nodejs corntab glob # nodejs 匹配获得文件 rd # node 遍历文件 commander # node制作命令 mkdirp # node 递归makedir fs-extra # node扩展fs包 testcontainers # java, 运行docker jOptSimple # java, 命令解析 协议 # spring-websocket # java httpcore-nio # java grpc-context # java 高可用 | 性能 # retry # js retry ehcache # 缓存 tagg # node线程池 cluster # node单机集群 fiber # node协程 driud # 连接池，阿里开源 akka # # scala并发、分布式、容错工具 使用 system = ActorSystem.create(\u0026quot;hello\u0026quot;) system.actorOf() ## 前端 ### dwr 介绍 java函数通过ajax映射到前端js调用 使用 ajax框架 1.导入jar包 dwr.jar 2.web-inf/下的配置文件 web.xml文件 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dwr-invoker\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.directwebremoting.servlet.DwrServlet\u0026lt;/servlet-class\u0026gt; # 固定写法 \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;debug\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;scriptCompressed\u0026lt;/param-name\u0026gt; # 允许在javascript中执行 \u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; # web工程启动时加载 \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dwr-invoker\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/dwr/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; dwr.xml文件 \u0026lt;dwr\u0026gt; \u0026lt;allow\u0026gt; \u0026lt;create creator=\u0026quot;new\u0026quot; javascript=\u0026quot;DWRUserAccess\u0026quot;\u0026gt; # 生成js文件的名（页面中引用） \u0026lt;param name=\u0026quot;class\u0026quot; value=\u0026quot;outrun.dwr.DWRUserAccess\u0026quot; /\u0026gt; # 曝露的类 \u0026lt;/create\u0026gt; \u0026lt;convert converter=\u0026quot;bean\u0026quot; match=\u0026quot;outrun.dwr.User\u0026quot; /\u0026gt; # 注册实体类，可以在js中进行实例化 \u0026lt;/allow\u0026gt; \u0026lt;/dwr\u0026gt; 3.写outrun.dwr.DWRUserAccess中的方法 4.页面调用 test.html \u0026lt;script src=\u0026quot;/outrun/dwr/engine.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;/outrun/dwr/util.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;/outrun/dwr/interface/DWRUserAccess.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;SCRIPT LANGUAGE=\u0026quot;JavaScript\u0026quot;\u0026gt; DWRUserAccess.方法(参数,执行完运行的js函数) # 参数可以是一个map,如 var userMap = {}; userMap.id = regForm.id.value; userMap.password = regForm.password.value; userMap.name = regForm.name.value; userMap.email = regForm.email.value; DWRUserAccess.save(userMap, saveFun); # 其中的regForm是页面中的表单（的name属性,dom支持直接使用名字引用表单） \u0026lt;/SCRIPT\u0026gt; 开发 # 脚手架 # spring boot # drapWizard # # java，类spring boot 写法 # traits-decorator # js mixin q # js 流程控制 co # js generator to async async # js 流程控制 thunkify # js函数Thunk化, 确保回调调用一次 step # async轻量库 wind # js定义的宏 streamline # 基于源代码编译来实现流程控制简化 eventproxy # js event回调 spring # java ioc guice # google的java ioc轻量框架 castle # .net ioc spring.net # .net ioc anko # go 代码解释器 antlr # java dsl aopalliance # java aop ejb # 特点 分布式，j2ee一部分 组成 会话bean(session) 实体bean(entity) 消息驱动bean(message driven) 语言增强 # guava # # google工具集 maven \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 组件 o-\u0026gt; 增强 Optional # null处理 Preconditions # 准入检查 Ordering Throwables o-\u0026gt; 集合 Multiset # 存重复元素 Multimap # 多值 BiMap # 双向映射 Table # 两键一值 Range # 连续值 o-\u0026gt; 字符串 Joiner Spilter CharMatcher CaseFormat o-\u0026gt; 类型 Objects Bytes Shorts Ints Longs Floats Doubles Chars Booleans o-\u0026gt; 数学 IntMath LongMath BigIntegerMath o-\u0026gt; 高可用 LoadingCache # 堆内缓存 接口 # luavit # lua实现, 类node scotty # haskell webapi # .net meteor.js # 基于node.js + mongodb的网站开发平台，把这个基础构架延伸到浏览器端, 本地和远程数据通过DDP(Distributed Data Protocol)协议传输 restify # 基于nodejs的rest应用框架，去掉express中的 template, render等功能, 提供DTrace功能，方便调试 ssh # java spring site # spring整合 tapestry # 基于servlet的mvc框架 jersey # java restful服务 naga # java nio echo # go beego # go gorilla # go gin # go，类express iris # go, fasthttp的一种实现 tornado # python nio web.py twisted # event driven flask django bottle # python wsgi rails # ruby的web mvc开发框架 ror # ror(ruby on rails) sinatra # 微型web grape # 运行在rack或rails/sinatra配合使用的restful风格的ruby微框架 yii # php laravel # php codelgniter # php RESTful # connect # 介绍 nodejs处理http中req、res的中间件框架 中间件分类 pre-request用来改写request原始数据 request/response功能各异 post-response全局异常处理，改写response数据等 内置中间件介绍 logger csrf compress # gzip压缩 basicAuth # basic认证 body parser # 请求内容解析 json urlencoded # application/x-www-form-urlencode请求解析 multipart # multipart/form-data请求解析 timeout cookieParser session cookieSession methodOverride # http伪造 responseTime # 计算响应时间 staticCache # 缓存 directory # 目录列表 vhost # 虚拟二级域名映射 favicon limit # 请求内容大小限制 query # url解析 errorHandler # 错误处理 使用 var connect = require('connect'); var app = connect() .use(connect.logger('dev')) .use(function(req, res){ res.end('hello world\\n'); }) .listen(3000); express # 安装 npm install -g express-generator npm install express -d # g代表安装到NODE_PATH的lib里面, d代表关联套件一起安装 cookie-parser 使用 var cookieParser = require('cookie-parser'); app.use(cookieParser()); JSON.stringify(req.cookies); req.cookies.yourCookie cookie-session 使用 var cookieSession = require('cookie-session'); app.use(cookieSession()) req.session = null express-session options可选参数 name # 表示cookie中保存session的字段名称，默认为connect.sid store # session的存储方式，默认存放在内存中，也有redis、mongodb、等模块支持 secret # 设置secrect来计算hash放在cookie中产生signedCookie，来防篡改 genid # 规定产生一个新的session_id时所用的函数，默认用uid2这个包 rolling # 每个请求都重新设置一个cookie，默认为false resave # 即使session没有被修改，也保存session的值 使用 var session = require('express-session'); app.use(session(options)); connect-redis 使用 var express = require('express'); var session = require('express-session'); var redisStore = require('connect-redis')(session); app.use(session({ store: new redisStore(), secret: 'somesecrettoken' })); serve-static # 静态文件 passport 介绍 登录验证中间件 支持connect express sails等web框架 支持Basic, Digest, OAuth(1.0和2.0的三种实现), Bearer等 安装 npm i passport npm i passport-local o-\u0026gt; 配置 var express = require('express'); var cookieParser = require('cookie-parser'); var session = require('express-session'); var flash = require('express-flash'); var passport = require('passport'); ... app.use(cookieParser()); app.use(session({...})); app.use(passport.initialize()); app.use(passport.session()); app.use(flash()) passport.serializeUser(function (user, done) { done(null, user.id) }) passport.deserializeUser(function (id, done) { User.findById(id, function (err, user) { done(err, user) }) }) app.post('/login', passport.authenticate('local', { # passport.authenticate是个登录中间件，通过就走后面回调，否则返回401 # local是自定义的名称 successRedirect: '/', failureRedirect: '/login', failureFlash: true, }, function (req, res) { res.redirect('/users/' + req.user.username) })) app.post('/login', passport.authenticate('local', function(err, user, info) { if (err) return next(err) if (!user) { req.flash('errors', {msg: info.message}) return res.redirect('/login') } req.logIn(user, function (err) {}) })(req, res, next)) app.get('/logout', function(req, res) { req.logout() res.redirect('/') }) app.get('/user', isAuthenticated, getUser) var isAuthenticated = function (req, res, next) { if (req.isAuthenticated()) { return next() } res.redirect('/login') } o-\u0026gt; local验证 var LocalStrategy = require('passport-local').Strategy passport.use(new LocalStrategy( function(username, password, done) { User.findOne({username: username}, function(err, user) { if (err) {return done (err)} if (!user) {return done(null, false, {message: 'no user'})} if (!user.validPassword(password)) {...} return done(null, user) }) } )) o-\u0026gt; usernameField passport.use(new LocalStrategy({ usernameField: 'email', passwordField: 'passwd' }, function (username, password, done) {...} )) o-\u0026gt; OAuth 介绍 第三方登录协议 三个步骤 1. 获取未授权的request token 2. 获取用户授权的request token 3. 用授权的request token换取access token 使用 网页上申请开发github应用 npm install passport-github # 安装passport的github扩展 // app.js passport.use(new GithubStrategy({ // 增加github认证策略 clientID: 'XXXX', clientSecret: 'YYYY', // 已从github上申请 callbackURL: 'http://localhost:3000/auth/github/callback' }, function(accessToken, refreshToken, profile, done){ done(null, profile); })); // 定义路由 app.all('/github', isLoggedIn); app.get('/github', user.github); app.get('/auth/github', passport.authenticate('github', {scope: 'email'})); app.get('/auth/github/callback', passport.authenticate('github', { successRedirect: '/github', failureRedirect: '/' })); kraken 介绍 基于express之上的基于设置结构化代码工具 功能 post请求_csrf验证 基本用法 'use strict' var express = require('express'), kraken = require('kraken-js'); var app = express(); app.use(kraken()); app.listen(8000); koa # 介绍 express原班人马打造的，更小，更健壮，更有表现力的web框架 免除重复繁琐的回调函数嵌套，提高错误处理效率 不绑定任何中间件，只是提供一个轻量优雅的函数库 \u0026gt;=node0.11.16 配置 app.name # 应用名称 app.env # 执行环境，默认是NODE_ENV 或 'development' app.proxy # 决定哪些proxy header被加到信任列表中 app.subdomainOffset # 被忽略的.subdomains列表 app.jsonSpaces # 输出json时是否填充空格 app.outputErrors # 是否输出错误堆栈(err.stack)到stderr(app.env是'test'时，此值为false) 使用 $ npm install koa $ node --harmony app.js # 必需使用harmony模式运行程序 var koa = require('koa'); var app = koa(); app.use(function *(){ this.body = 'Hello World'; }); # function* 声明的generator function支持yield ## yield是ES6定义的新语法 app.listen(3000); 使用(downstream \u0026amp; upstream) var koa = require('koa'); var app = koa(); // x-response-time app.use(function *(next){ // (1) 进入路由 var start = new Date; yield next; // (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间 var ms = new Date - start; this.set('X-Response-Time', ms + 'ms'); // (6) 返回 this.body }); // logger app.use(function *(next){ // (2) 进入 logger 中间件 var start = new Date; yield next; // (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间 var ms = new Date - start; console.log('%s %s - %s', this.method, this.url, ms); }); // response app.use(function *(){ // (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream this.body = 'Hello World'; }); app.listen(3000); this request header headers url accepts response header headers status cookies set('name', 'tobi', {signed: true}) signed expires path domain secure httpOnly get type length path method state throw assert app use listen callback keys context db 中间件 koa-router trie-router route basic-auth etag compose static static-cache session compress csrf logger mount send error 实时 # sockjs # node websock postal # nodejs 在内存上构建的发布订阅框架 pusher # 发布订阅模式socketio框架 juggernaut # 基于socketio datachannel.io # 基于socket.io和html5 webRTC的实时聊天室框架 faye-websocket-node # 扩展faye项目开发的websocket的一个实现, 非常简单，而且不依赖其他库 websocket-node # 一个简单的websocket库，支持draft-10及之前的各种版本, 支持同样是node的c/s交互模式 ejabberd # 基于erlang/OTP 的xmpp im 开源框架 singalR # .net sock服务 nsq # go openfire # java, 性能较差, 最多单机10w并发 webrtc # c++实现的web视频聊天 socket.io # # 介绍 socket.io: 基于任何浏览器, mobile设备的\u0026quot;webSocket\u0026quot; # 安装 npm install socket.io # 使用 var socketIo = require('socket.io'); socketIo.listen(app).on('connection', function (socket) { # require('socket.io')(app); ## var io = require('socket.io')(80); socket.emit('news', { hello: 'world' }); socket.on('my other event', function (data) { console.log(data); }); }); # api server io.on('connection', function(socket){}); io.on('disconnect', function(){}); socket.on('message', function(msg){}); client-js socket = io.connect(url); socket.on('', function(json){}); socket.send(json); io on('connection', function(socket){}); # disconnect socket on('disconnect', function(){ }); socket.on('say to someone', function(id, msg){ socket.broadcast.to(id).emit('my message', msg); }); # Socket#id为内部指定的 遍历用户 var roster = io.sockets.clients('chatroom'); roster.forEach(function(client){ console.log('Username: ' + client.nickname); }); // 1.0之前版本可用 # 方案 namespace server var nsp = io.of('/my-namespace'); Onsp.emit('hi', 'everyone!'); # ns广播 client var socket = io('/my-namespace'); room server socket.join('some room'); io.to('some room').emit('some event'): # room广播 socket.leave('some room'); # 子模块 socket.io-redis 介绍 用于从外部发消息，与socket.io-emitter一起使用 使用 var io = require('socket.io')(3000); var redis = require('socket.io-redis'); io.adapter(redis({ host: 'localhost', port: 6379 })); socket.io-emitter 介绍 用于从外部发消息，与socket.io-redis一起使用 使用 var io = require('socket.io-emitter')(); io.emit('time', new Date); socket.io-client 介绍 用于创建客户端来连接socket.io 使用 var iocl = require('socket.io-client'); var socket = iocl.connect('127.0.0.1:5555'); socket.on('connect', function(){ }); 展示 # titles # java apache的标签库 spring mvc # struts2 # # 基础 介绍 struts1和WebWork的发展 引入值栈的概念 # 一次请求的参数和处理数据放在一个map结构中 原理 基于拦截器, 解耦servlet, 再提供自己的拦截器(interceptor)操作数据, 反射调用业务类 FilterDispatcher通过配置文件来映射设置请求地址与处理类 ActionMapper判断请求是否struts处理 ActionProxy扩展实现方式(如web service) ConfigurationManager对应struts.xml配置文件 ActionInvocation执行Action与拦截器 Action处理请求，封装数据 # Action是非单例的，效率低 过滤器与拦截器 过滤器基于回调，拦截器基于反射 过滤器依赖servlet, 拦截器在struts中处理action # 思想 Action类中的无侵入设计（新技术中不出现旧技术）：map代替了作用域 ActionContext actionContext = actionContext.getContext() actionContext.getApplication() actionContext.getSession() 好处 map是java中的api，不出现旧技术 测试方便（ servlet不能测试，只能发布测试） # 注意：Action类中用到作用域map的方法也不能测试 # 结构 apps: 例子程序 docs:帮助文件 lib:程序包 src:源码 # 使用 要求 jdk5 jsp2 servlet api2.4 导入核心的8个包 struts2-core-2.3.1.1.jar # struts的过滤器 xwork-core-2.3.1.1.jar # 验证工具 freemarker-2.3.18.jar # 标签 javassist-3.11.0.GA.jar # 动态代理 commons-fileupload-1.2.2.jar commons-io-2.0.1.jar # 文件处理 commons-lang-2.5.jar # 基础包 ognl-3.0.3.jar # 表达式语言 web.xml文件中配置过滤器 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;struts\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;struts\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 写jsp页面，get或post路径为struts2的名称空间、扩展名，被配置的struts2过滤器处理 写Action类（继承ActionSupport类） 配置src/struts.xml文件与src/struts.properties文件，映射类、方法等到请求路径，映射返回字符串到任何方式 # 核心包：8个 struts2-core-2.3.1.1.jar # struts的过滤器 xwork-core-2.3.1.1.jar # 验证工具 freemarker-2.3.18.jar # 标签 javassist-3.11.0.GA.jar # 动态代理 commons-fileupload-1.2.2.jar commons-io-2.0.1.jar # 文件处理 commons-lang-2.5.jar # 基础包 ognl-3.0.3.jar # 表达式语言 # 配置 struts2以包的形式管理action 包名必须唯一，包里的每个action唯一 使用步骤 导入lib包 写jsp 编写Action方法 web.xml中配置 \u0026lt;filter-class\u0026gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter \u0026lt;url-pattern\u0026gt;/* ../xx_struts.xml中配置请求响应 src/struts.xml 中引入配置文件 \u0026lt;include file=\u0026quot;cn/itcast/javaee/cal/cal_struts.xml\u0026quot;/\u0026gt; 配置文件（配置包）路径 重要路径：4个 1./struts-default.xml[框架] # 是框架自带的abstract包（包括上传，下载，验证等），继承它以后可以用其中的功能 2./org/apache/struts2/default.properties[框架] 3.src/struts.xml # 必有 4.src/struts.properties # 可选 验证返回消息的配置文件 struts2-core-2.3.1.1.jar包中的 /org/apache/struts2/struts-messages.properties文件 xml 中配置的简化 * o-\u0026gt; 只能在name 中写*_* 等 o-\u0026gt; 引用第一个* 用{1} 引用第二个用{2} 以此类推 类路径 com.opensymphony.xwork2.ActionSupport 默认关联到的类 处理请求的扩展名配置 # 扩展名配置只有一个会生效 1./org/apache/struts2/default.properties struts.action.extension=action,, # 框架中初始的默认扩展名，最后的','代表了无扩展名 2.src/struts.xml中 \u0026lt;constant name=\u0026quot;struts.action.extension\u0026quot; value=\u0026quot;do,,\u0026quot;\u0026gt; # 必需配置 3.src/struts.properties中 struts.action.extension=xx,yy # 选择配置，优先级高 默认配置 struts2内置了请求字符串与基本类型的相互转换，不用手工转换 /org/apache/struts2/default.properties文件中 struts.i18n.encoding=UTF-8 # post方式请求响应的编码方式 ## get方式的没有默认值，需要自己转码 struts.action.extension=action,, # 框架中初始的默认扩展名,最后的','代表了无扩展名 每个\u0026lt;package\u0026gt;标签中配置 \u0026lt;interceptor-ref name=\u0026quot;defaultStack\u0026quot;\u0026gt;\u0026lt;/interceptor-ref\u0026gt; 为默认的拦截器 src/struts.xml配置文件 src/struts.properties配置文件 # 原理流程 请求/qq.action -\u0026gt; StrutsPreparedAndExecuteFilter（核心过滤器）-\u0026gt; 匹配扩展名 -\u0026gt; 匹配命名空间 #（ 全限定名：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.class） -\u0026gt; src/struts.xml -\u0026gt; name class method -\u0026gt; name type 内容 -\u0026gt; 响应 -\u0026gt; 拦截器 -\u0026gt; ConfigAction类 # 1.部署时读取src/struts.xml和src/struts.properties文件，形成JavaBean对象 # 两个文件同时存在时src/struts.properties文件为准 ## 2.请求/*路径时，StrutsPreparedAndExecuteFilter过滤 ## 3.获取JavaBean中的actionName ,actionClass, actionMethod, 执行方法 ## 4.执行的返回值与resultName, resultType, resultContent进行比较 ## 5.按resultType类型返回resultContent（路径和内容） # 缺点 8个jar包，慢，servlet 快 配置繁琐 # 编码 struts2默认编码方式:utf-8 返回的图片相对路径中有中文时设置tomcat tomcat/conf/server.xml \u0026lt;Connector port=\u0026quot;8080\u0026quot; .. URIEncoding=\u0026quot;utf-8\u0026quot;/\u0026gt; 这时点击下载的请求路径中有中文时在以post方式提交 ,struts自动转码。若以get方式提交，需要在Action类的相应的get方法中转换url编码（iso8859-1）到u8 原理 改了tomcat的内部编码以后，struts中的编码是u8，放在session 中，jsp支持u8,解释后发送的html中的编码没问题，查看没问题。 下载post发送请求，浏览器请求的是url编码的u8,struts中也是u8执行下载 如果不改编码，struts 中是u8,如果以List方式放入session的话,session存储的是u8 如果直接放入数据的话,session中存储的是8859-1,jsp取出数据需要转码为u8并设置自己的编码是u8,再发送给浏览器。 浏览器这时获取图片正常,post方式提交的是u8,经过tomcat转换为8859-1,struts中自动转换编码到u8 如果是以get方式提交请求，get中的中文在浏览器时进行url编码到8859-1,经过tomcat，再到struts,struts不对get方式的请自动进行转码 向action类中注入参数时是8859-1编码,需要手动在action类中的属性的get方法中进行8859-1到u8的转码操作 # 内置对象 struts中的6个内置对象 # request请求进入struts中时创建，request请求结束时销毁。 requestMap sessionMap applicationMap parameters attr # page -\u0026gt; request -\u0026gt; session -\u0026gt; application 的顺序查找 valueStack # 定义实例变量，直接放入valueStack的 list（栈） 中,map（值）很少向内存储数据 # 定义的实例变量必须提供相应的get方法,否则ognl标签中取其数据时没有方法调用，就得不到它的值 # list 中的值优先访问 ，但是map 中的值起决定作用 # map中存放着一个大map,其中注入了所有页面的请求信息 # requestMap sessionMap applicationMap 并不是真正的域对象，但最后通过拦截器放入到域对象中 # 异常处理 配置src/strut.xml 文件 \u0026lt;global-results\u0026gt; 全局结果（用来跳转全局异常等） \u0026lt;global-exception-mappings\u0026gt; 全局异常 \u0026lt;exception-mapping result=\u0026quot;nullJsp\u0026quot; exception=\u0026quot;java.lang.NullPointerException\u0026quot; /\u0026gt; # \u0026lt;action\u0026gt;标签中的局部异常 ## \u0026lt;action\u0026gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为\u0026quot;nullJsp\u0026quot;的字符串交给本\u0026lt;action\u0026gt;标签中相应的\u0026lt;result\u0026gt;标签来处理 处理机制 o-\u0026gt; 多个异常时走子异常，父异常被忽略 o-\u0026gt; 先处理小范围异常，大范围忽略 o-\u0026gt; 如果异常没有处理，抛出到web服务器处理,web.xml的\u0026lt;error-page\u0026gt;\u0026lt;error-code\u0026gt;\u0026lt;location\u0026gt; 全局异常 xml文件中 \u0026lt;global-results\u0026gt; \u0026lt;result name=\u0026quot;error\u0026quot;\u0026gt; /error.jsp \u0026lt;/result\u0026gt; \u0026lt;/global-results\u0026gt; \u0026lt;global-exception-mappings\u0026gt; \u0026lt;exception-mapping result=\u0026quot;error\u0026quot; exception=\u0026quot;java.lang.Exception\u0026quot;/\u0026gt; \u0026lt;/global-exception-mappings\u0026gt; error.jsp页面中 \u0026lt;%@ taglib prefix=\u0026quot;s\u0026quot; uri=\u0026quot;/struts-tags\u0026quot; %\u0026gt; 异常信息：\u0026lt;s:property value=\u0026quot;exception.message\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; 详细信息：\u0026lt;s:property value=\u0026quot;exceptionStack\u0026quot;/\u0026gt;\u0026lt;br/\u0026gt; # 转递方式 chain # action类之间转发 dispatcher # 转发到jsp freemarker httpheader redirect # 重定向到页面 redirectAction # action 类之间重定向 stream # 返回 InputStream流 velocity xslt plainText # Action类 注意 1.所有Action类都要继承ActionSupport类，否则execute方法返回的字符串不会回到struts拦截器再根据xml文件的配置进行转发 2.action类是非单例的。 # 所有多实例的对象全部是因为有私有属性，否则全部应该是单例的 3.action类放在栈的顶端，用于注入数据 传统方式得到request,response,servletContext,pageContext ServletActionContext.getPageContext() HttpServletRequest request = ServletActionContext.getRequest() ServletActionContext.getResponse() ServletActionContext.getServletContext(); 优势 实现与servlet的解耦 验证 验证分类 前台验证：javascript等 后台验证：服务器 struts2验证 后台验证 1.代码式验证 2.声明式验证:xml文件 ActionContext类 调用方法 ActionContext actionContext = ActionContext.getContext(); 得到内置对象 # 这几种得到作用域的方法均可以得到作用域中原有的值，也可以放入值 request actionContext.put(\u0026quot;\u0026quot;,\u0026quot;\u0026quot;); application Map\u0026lt;String,Object\u0026gt; applicationMap = actionContext.getApplication(); session Map\u0026lt;String,Object\u0026gt; sessionMap = actionContext.getSession(); # 或 actionContext.get(\u0026quot;session\u0026quot;)得到，因为actionContext中存储着大map parameters Map\u0026lt;String,Object\u0026gt; parametersMap = actionContext.getParameters(); valueStack ValueStack valueStack = actionContext.getValueStack() valueStack.getRoot() # 得到当前值栈的顺序 参数 1.action类中可以直接创建属性与其get方法得到客户端get方法或post表单请求的参数(由struts2自动注入) 2.action类中可以创建 JavaBean的属性来接收struts注入的参数，这时用户请求的参数名字要写成JavaBean名.JavaBean中的属性名（这样struts2会自动调用JavaBean的set方法来注入其中相应的参数 ） ## BaseAction 作用 权限管理 存放常驻内存数据 抽取常用的方法 # web.xml配置 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;struts2\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt; org.apache.struts2.dispatcher.FilterDispatcher \u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;struts.action.extension\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;do\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;struts2\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.json\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; # 设置全局过滤器，并且修改过滤扩展名 # default.properties src/struts.properties配置文件 struts.custom.i18n.resources=struts # 使自己的普通配置生效。如：/org/apache/struts2/struts-messages.properties文件的 ## struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} \u0026quot;{1}\u0026quot; \u0026quot;{2}\u0026quot; {3} 属性，\u0026quot;{1}\u0026quot; \u0026quot;{2}\u0026quot; \u0026quot;{3}\u0026quot;是显示消息的占位符 ## struts.action.extension=action,,可以不配置 # 由于只加载properties文件，所以省略.properties ## =后面的是相对于src目录的文件 # ognl标签 注意 # jquery中不能定位ognl标签，而要用标签自己生成的id定位（看源码得到） 使用： \u0026lt;%@ taglib uri=\u0026quot;/struts-tags\u0026quot; prefix=\u0026quot;s\u0026quot; %\u0026gt; tld映射文件路径 struts2-core-2.3.1.1.jar包中 /META-INF/struts-tags.tld '#'出现的地方 o-\u0026gt; 除ValueStack 之外的所有struts内置对象的取值前面都要加 o-\u0026gt; 取JavaBean中的属性时要加 '#'，如\u0026quot;#user.username\u0026quot;,ValueStack中也不例外 o-\u0026gt; 构造Map对象，Map：#{'male':'[男]','female':'[女]'}，构造radio和select标签，如 # \u0026lt;s:radio list=\u0026quot;#{'male':'aa','bb':'cc'}\u0026quot; name=\u0026quot;gender2\u0026quot; /\u0026gt; o-\u0026gt; 迭代数组或list集合 集合的投影：userList.{username} 集合的过滤：userList.{?#this.age\u0026gt;22} 主题与模板 主题：为多个模板提供风格 struts2-core-2.3.1.1.jar包中 template中的四个主题 archive # 其中是.vm文件，其它是.ftl文件。vm与ftl是两种视图技术 ajax # 除此之外其它都不支持ajax simple xhtml xhtml # 默认主题,default.properties配置文件中定义 css_xhtml simple 修改主题 1.struts.properties 中修改 struts.ui.theme=simple # 针对当前webapp 2.\u0026lt;s:form theme=\u0026quot;xhtml\u0026quot;\u0026gt; # 只针对当前表单 3.\u0026lt;s:textfield name=\u0026quot;username\u0026quot; theme=\u0026quot;simple\u0026quot;\u0026gt; # 修改某个标签的属性 模板：为标签提供样式 做模板的技术freemarker ognl标签的优点：自动排版、验证数据回显、国际化 所有标签： 逻辑标签 对 Map 集合的迭代： \u0026lt;s:iterator value=\u0026quot;#session.fileMap\u0026quot; var=\u0026quot;entry\u0026quot; status=\u0026quot;stat\u0026quot;\u0026gt; \u0026lt;s:property value=\u0026quot;#entry.key\u0026quot;/\u0026gt; \u0026lt;s:if test=\u0026quot;#stat.count%4==0\u0026quot;\u0026gt;\u0026lt;/s:if\u0026gt; \u0026lt;/s:iterator\u0026gt; 对 List 集合的迭代 List\u0026lt;User\u0026gt; userList 普通迭代 \u0026lt;s:iterator var=\u0026quot;user\u0026quot; value=\u0026quot;userList\u0026quot;\u0026gt; # 投影语法List\u0026lt;user\u0026gt;中的所有username \u0026lt;s:property value=\u0026quot;#user.username\u0026quot;/\u0026gt; 投影语法 \u0026lt;s:iterator var=\u0026quot;username\u0026quot; value=\u0026quot;userList.{username}\u0026quot;\u0026gt; \u0026lt;s:property/\u0026gt; # 这里不用写属性value=\u0026quot;username\u0026quot;就可以对page域中的username进行显示 过滤语法 \u0026lt;s:iterator var=\u0026quot;user\u0026quot; value=\u0026quot;userList.{?#this.age\u0026gt;9}\u0026quot;\u0026gt; # this代表当前被迭代的元素 ?#是所有 ^#是第一个 $#是最后一个 ?#...[0]按标记取 \u0026lt;s:property value=\u0026quot;#user.username\u0026quot; /\u0026gt; 显示标签（UI标签） 普通字符串中使用ognl jsp中用%{} xml中用${} 例如 jsp中：\u0026lt;s:textfield label=\u0026quot;%{#attr.testValueStack}\u0026quot;/\u0026gt; xml中：\u0026lt;param name=\u0026quot;min\u0026quot;\u0026gt;4000\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;${min}\u0026lt;/message\u0026gt; 普通信息 \u0026lt;s:text name=\u0026quot;\u0026quot;/\u0026gt; 输出值 迭代器中 \u0026lt;s:property/\u0026gt; # 直接输出被迭代的内容（简单） \u0026lt;s:property value=\u0026quot;aa\u0026quot;/\u0026gt; \u0026lt;s:property value=\u0026quot;#aa\u0026quot;/\u0026gt; 普通 \u0026lt;s:property value=\u0026quot;username\u0026quot;/\u0026gt; # 输出标签,得到valueStack中属性 \u0026lt;s:property value=\u0026quot;#request.name\u0026quot;/\u0026gt; # 得到request域对象中的值 # request #session #application #parameters #attr # '#attr'优先级：page,request,valueStack,session,application 显示验证拦截器的验证信息集合中的数据： \u0026lt;s:fielderror/\u0026gt; # 显示所有错误信息 \u0026lt;s:fielderror fieldName=\u0026quot;\u0026quot;/\u0026gt; # 显示验证返回的错误信息 单选 \u0026lt;s:radio list=\u0026quot;#{'male':'男','female':'女'}\u0026quot; name=\u0026quot;gender2\u0026quot; value='男'\u0026gt; # 自动加class id \u0026lt;label for=\u0026quot;gender2male\u0026quot;\u0026gt;等 # list键值对中male是实际值,男是显示值 # name是\u0026lt;input radio \u0026gt;的name属性 # value中是选中的项 多选 \u0026lt;s:select multiple=\u0026quot;true\u0026quot; list=\u0026quot;#{'bj':'北京','sh':'上海','gz':'广州'}\u0026quot; name=\u0026quot;select1\u0026quot; value=\u0026quot;{'sh','bj'}\u0026quot;/\u0026gt; 表单 # 在ognl的标签中， struts的验证消息自动回显，不用加\u0026lt;s:fielderror/\u0026gt;标签 \u0026lt;s:form action=\u0026quot;\u0026quot;\u0026gt; # 默认中加上了 method=\u0026quot;post\u0026quot; action中加上了当前网站了contextPath路径 \u0026lt;s:textfield label=\u0026quot;用户名\u0026quot; name=\u0026quot;username\u0026quot; /\u0026gt; \u0026lt;s:password label=\u0026quot;密码\u0026quot; name=\u0026quot;password\u0026quot; /\u0026gt; \u0026lt;s:submit value=\u0026quot;登录\u0026quot; /\u0026gt; 国际化 # 国际化一般放在整个网站的最后写 ##　伪国际化：将不同语言的页面放在不同文件夹中分别访问 # 国际化是通过i18n拦截器实现的 1.创建国际化信息文件 message_zh_CH.properties # 基名_语言名_国家名.properties username=xxx password=xxxx submit=xx message_en_US.properties .. message.properties # 默认的显示语言 # 找伊拉克没有的话找本地区语言，本地语言没有的话找其它(默认的或美国等) 2.struts.properties中引入国际化配置的属性文件 struts.custom,i18n.resources=struts2/tag/i18n/message # 从src文件夹路径开始，只写基名 3.验证消息国际化 message.properties文件中配置属性validationRequiredUsername=用户名错误 validation.xml文件中 \u0026lt;message key=\u0026quot;validationRequiredUsername\u0026quot;\u0026gt;\u0026lt;/message\u0026gt; 4.jsp文件中用key属性代替 label属性(或其它在页面上显示信息的属性),key中写国际化信息文件中的key \u0026lt;s:form action=\u0026quot;taglogin\u0026quot;\u0026gt; \u0026lt;s:textfield key=\u0026quot;username\u0026quot; name=\u0026quot;username\u0026quot; /\u0026gt; \u0026lt;s:password key=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; /\u0026gt; \u0026lt;s:submit key=\u0026quot;submit\u0026quot;/\u0026gt; \u0026lt;/s:form\u0026gt; 5.普通信息的国际化 message.properties中配置属性 normalMessage:普通信息 jsp中\u0026lt;s:text name=\u0026quot;normalMessage\u0026quot;/\u0026gt; 6.测试 intername选项 -- 语言 改地区访问 xml文件中的ognl标签 o-\u0026gt; ${aa} 1.调用转到该标签类的getAa()方法得到aa的值替换${aa} 2.本标签中name=\u0026quot;aa\u0026quot;的标签的文本节点的内容 o-\u0026gt; {1}{2}{3}..{n} 匹配本标签中name=\u0026quot;*a*\u0026quot; 中的第n个‘*’,用于通配传递过来的参数的一部分的值 # ognl表达式 ognl 开源，java写的免费标签,是struts2特有的 xml文件中 ${Xxx} 取值栈中栈中的东西，如action类中的属性 ${#Xxx} 取值栈中值的东西，如request,session域中的数据（其实就是老师说的内置对象【valueStack就是值栈】） jsp文件中 \u0026lt;s:iterator value=\u0026quot;#session.fileMap\u0026quot; var=\u0026quot;entry\u0026quot; status=\u0026quot;stat\u0026quot;\u0026gt; \u0026lt;s:property value=\u0026quot;#entry.key\u0026quot;/\u0026gt; \u0026lt;s:if test=\u0026quot;#stat.count%4==0\u0026quot;\u0026gt;\u0026lt;/s:if\u0026gt; \u0026lt;/s:iterator\u0026gt; # strut.xml配置 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE struts PUBLIC \u0026quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\u0026quot; \u0026quot;http://struts.apache.org/dtds/struts-2.0.dtd\u0026quot;\u0026gt; \u0026lt;struts\u0026gt; \u0026lt;constant name=\u0026quot;\u0026quot; value=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/constant\u0026gt; \u0026lt;include file=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/include\u0026gt; \u0026lt;package name=\u0026quot;\u0026quot;\u0026gt; \u0026lt;interceptors\u0026gt; \u0026lt;interceptor name=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/interceptor\u0026gt; \u0026lt;interceptor-stack name=\u0026quot;\u0026quot;\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/interceptor-ref\u0026gt; \u0026lt;/interceptor-stack\u0026gt; \u0026lt;/interceptors\u0026gt; \u0026lt;default-interceptor-ref name=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/default-interceptor-ref\u0026gt; \u0026lt;global-results\u0026gt; \u0026lt;result name=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/global-results\u0026gt; \u0026lt;global-exception-mappings\u0026gt; \u0026lt;exception-mapping result=\u0026quot;\u0026quot; exception=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;/global-exception-mappings\u0026gt; \u0026lt;action name=\u0026quot;\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/param\u0026gt; \u0026lt;result\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result name=\u0026quot;input\u0026quot;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;exception-mapping result=\u0026quot;\u0026quot; exception=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/interceptor-ref\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/package\u0026gt; \u0026lt;/struts\u0026gt; 设置 \u0026lt;constant name=\u0026quot;struts.devMode\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; # 开启debug模式 # debug模式，不用重启调试(添加新的方法要重启，方法中改代码不用重启) \u0026lt;constant name=\u0026quot;struts.i18n.encoding\u0026quot; value=\u0026quot;utf-8\u0026quot;/\u0026gt; # 配置struts的编码 \u0026lt;constant name=\u0026quot;struts.configuration.xml.reload\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; # 配置本属性，可以使得改动struts配置文件不用重启应用服务器 \u0026lt;constant name=\u0026quot;struts.multipart.saveDir\u0026quot; value=\u0026quot;/upload\u0026quot;/\u0026gt; # 配置上传存储路径 \u0026lt;constant name=\u0026quot;struts.action.extension\u0026quot; value=\u0026quot;action,do\u0026quot; /\u0026gt; # 配置过滤路径 详细解释 o-\u0026gt; 存放路径src/ o-\u0026gt; 可以在struts-2.3.15.1的src\\apps\\blank\\src\\main\\resources\\struts.xml中参考配置文件 o-\u0026gt; \u0026lt;include file=\u0026quot;struts2/cal/cal_struts.xml\u0026quot;/\u0026gt;标签包含其它路径的xml配置文件 #　被include的文件不能再include其它文件 o-\u0026gt; \u0026lt;constant name=\u0026quot;struts.action.extension\u0026quot; value=\u0026quot;do,,\u0026quot;\u0026gt; 默认值 default.properties中配置了默扩展名：struts.action.extension=action,, # 配置匹配到框架处理的扩展名，空逗号代表匹配没有扩展名 o-\u0026gt; \u0026lt;package name=\u0026quot;xxPackage\u0026quot; extends=\u0026quot;struts-default\u0026quot; namespace=\u0026quot;/xx/\u0026quot;\u0026gt; 默认值 namespace=\u0026quot;/\u0026quot; extends=\u0026quot;struts-default\u0026quot; # 不可省略 # name是包的唯一标识，不可以写路径 ## namespace 访问路径如/xx/a.do会匹配到该包执行其中的映射，按照域命名空间链的方式匹配，如： /xx/yy/a.do也会匹配到该包，但是它优先匹配到/xx/yy的命名空间 /a.do 不会匹配到该包 注意：匹配/sys/*的名称空间是/sys 而非 /sys/ ## struts的包有抽象包，普通包两种，通过继承可以加入包内容，相当于复制、粘贴 ## 继承的包是struts-default，其路径是/struts-default.xml ## ，它定义了核心的bean和拦截器 o-\u0026gt; \u0026lt;interceptors\u0026gt; \u0026lt;interceptor name=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot;/\u0026gt; \u0026lt;interceptor-stack name=\u0026quot;\u0026quot;\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;/\u0026quot;\u0026gt; # 定义拦截器、定义拦截器栈（加入拦截器） ## 拦截器栈中可以加栈 o-\u0026gt; \u0026lt;default-interceptor-ref name=\u0026quot;\u0026quot;\u0026gt; 默认拦截器（可以用于验证用户登录） o-\u0026gt; \u0026lt;global-results\u0026gt; 全局结果（用来跳转全局异常等） o-\u0026gt; \u0026lt;global-exception-mappings\u0026gt; 全局异常 o-\u0026gt; \u0026lt;action name=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot; method=\u0026quot;\u0026quot;\u0026gt; 默认值 class=\u0026quot;com.opensymphony.xwork2.ActionSupport\u0026quot; method=\u0026quot;execute\u0026quot; # name=\u0026quot;aa\u0026quot;时 .../aa.do的请求匹配到该方法执行 ## class 是类字节码路径，method是其中的方法名 o-\u0026gt; \u0026lt;param name=\u0026quot;aaa\u0026quot;\u0026gt;bbb\u0026lt;/param\u0026gt; 调用 \u0026lt;action\u0026gt;标签中对象的实例的方法：setAaa(\u0026quot;bbb\u0026quot;); o-\u0026gt; \u0026lt;result name=\u0026quot;\u0026quot; type=\u0026quot;\u0026quot;\u0026gt;/ok.jsp 默认值 name=\u0026quot;success\u0026quot; type=\u0026quot;dispatcher\u0026quot; # name=\u0026quot;success\u0026quot;时，映射的method返回\u0026quot;success\u0026quot;时进入该result处理 ## type是返回方式 ，如dispatcher redirect等 type的返回类型 dispatcher : 转发到jsp页面 redirect : 重定向到 jsp html 等页面 chain : Action 类之间的转发 redirectAction : Action 类之间的重定向 stream : 以 inputStream 的数据类型返回 stream的参数 # 可以从struts-default.xml文件中对应的stream参数对应的类的源码中查看其中的set方法找到要写参数的名称 \u0026lt;param name=\u0026quot;contentType\u0026quot;\u0026gt;image/pjpeg\u0026lt;/param\u0026gt; # 下载文件的类型 另外如text/html; charset=utf-8返回给ajax异步数据 \u0026lt;param name=\u0026quot;bufferSize\u0026quot;\u0026gt;2048\u0026lt;/param\u0026gt; # 缓冲byte[]的大小，单位字节 \u0026lt;param name=\u0026quot;contentDisposition\u0026quot;\u0026gt;attachment;filename=${uuidFileName}\u0026lt;/param\u0026gt; # 设置下载响应头，只的下载时才设置。${uuidFileName}是一个OGNL表达式 \u0026lt;param name=\u0026quot;inputName\u0026quot;\u0026gt;imageStream\u0026lt;/param\u0026gt; # 框架调用传递给result标签结果字符串的对象中的getImageStream()方法，来获取InputStream流对象 # 返回stream类型不指定返回的路径 ## 标签间的内容：/ok.jsp 是响应的路径 o-\u0026gt; \u0026lt;result name=\u0026quot;input\u0026quot; type=\u0026quot;\u0026quot;\u0026gt;/ok.jsp type中的参数 # 可以从struts-default.xml配置文件中查到 dispatcher # 转发 redirect # 重定向 chain # Action类之间转发，需要加参数，参数的名字 ## ：struts-default.xml文件中找到\u0026quot;chain\u0026quot;对应的类，按快捷键ctrl + shift + T 关联类的源码文件，查找set方法改名即可 \u0026lt;param name=\u0026quot;actionName\u0026quot;\u0026gt;to\u0026lt;/param\u0026gt; # action标签的 name属性值 \u0026lt;param name=\u0026quot;namespace\u0026quot;\u0026gt;/\u0026lt;/param\u0026gt; # action的名称空间 redirectAction # Action类之间重定向 # 各种拦截器不通过时默认的返回input，同时向request作用域中加入了相关错误信息供struts2的jsp标签进行显示 ## 处理 返回值是input的返回信息跳转，就是处理拦截器拦截后的信息跳转 o-\u0026gt; \u0026lt;exception-mapping result=\u0026quot;nullJsp\u0026quot; exception=\u0026quot;java.lang.NullPointerException\u0026quot; /\u0026gt; # \u0026lt;action\u0026gt;标签中的局部异常 ## \u0026lt;action\u0026gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为\u0026quot;nullJsp\u0026quot;的字符串交给本\u0026lt;action\u0026gt;标签中相应的\u0026lt;result\u0026gt;标签来处理 o-\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;loginInterceptor\u0026quot;/\u0026gt; 默认值 name=\u0026quot;defaultStack\u0026quot; # 指定在本\u0026lt;action\u0026gt;标签中使用的拦截器或拦截器栈 ## 当指定了拦截器或拦截器栈以后，默认的defaultStack将会没有,此时defaultStack中的18个拦截器将不再执行 使用：OGNL对象图导航语言对标签中的路径进行动态设置 # 验证 struts2验证 1.代码式: validate(),validateXxx()方法 # 单个验证与全部验证都存在时先单个验证，再全部验证，验证信息都加入验证信息集合 2.声明式: Action类名-validation.xml Action类名-\u0026lt;action标签的name属性\u0026gt;-validation.xml # 单个验证与全部验证都存在时先全部验证，再单个验证，验证信息都加入验证信息集合 # 先声明验证，后代码验证 参数驱动 1.属性驱动: action中用属性收集表单参数 2.模型驱动: javaBean收集参数 代码式（属性驱动）： 步骤 1.需要验证的Action类 继承 ActionSupport 类 # ActionSupport 类 实现了Validateable接口，该接口是验证接口 2.写验证方法 1\u0026gt; public void validate() # 方法重写（通用验证方法，本类中的所有其它方法执行前都执行） 2\u0026gt; public void validateXxxMethod() # 或者自定义专用验证方法 xxxMethod为要验证的方法名，首字母要大写 # 注意，通用、专用验证方法同时存在时，先执行专用验证方法，再执行通用验证方法 ## ，但是通用验证方法的错误消息无法加入到返回的错误集合中 3\u0026gt; this.addFieldError(\u0026quot;password\u0026quot;,\u0026quot;密码必填\u0026quot;); # 验证方法中添加错误信息到错误信息集合 ## addFieldError(\u0026quot;\u0026quot;,\u0026quot;\u0026quot;)是从ActionSupport父类中继承的方法 3.jsp文件中通过验证标签： \u0026lt;%@ taglib uri=\u0026quot;/struts-tags\u0026quot; prefix=\u0026quot;s\u0026quot;%\u0026gt; \u0026lt;s:fielderror/\u0026gt; # 显示所有错误信息 \u0026lt;s:fielderror fieldName=\u0026quot;password\u0026quot;/\u0026gt; 显示验证出错信息 4.xml配置 \u0026lt;!-- 验证错误信息处理 --\u0026gt; \u0026lt;result name=\u0026quot;input\u0026quot; type=\u0026quot;dispatcher\u0026quot;\u0026gt; /error.jsp \u0026lt;/result\u0026gt; # 写在需要验证的方法对应的标签中，验证错误时验证方法会优先返回\u0026quot;input\u0026quot;字符串 声明式（属性驱动）： 1.验证Action类继承ActionSupport 2.验证Action类目录下配置文件 Action类名-validation.xml Action类名-\u0026lt;action标签的name属性\u0026gt;-validation.xml # 放入此名字的配置文件就相当于加了验证，不需要做其它事情 ## ，相当于分别向Actioin类中加入了validate()validateXxx()方法进行了相应验证 文件内容 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE validators PUBLIC \u0026quot;-//Apache Struts//XWork Validator 1.0.3//EN\u0026quot; \u0026quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd\u0026quot;\u0026gt; \u0026lt;validators\u0026gt; \u0026lt;field name=\u0026quot;username\u0026quot;\u0026gt; # 要验证的属性 \u0026lt;field-validator type=\u0026quot;requiredstring\u0026quot;\u0026gt; \u0026lt;message\u0026gt;用户名必填\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;field-validator type=\u0026quot;regex\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;expression\u0026quot;\u0026gt;^[\\u3447-\\uFA29]+$\u0026lt;/param\u0026gt; \u0026lt;message\u0026gt;UserAction2-validation==\u0026gt;必须写中文\u0026lt;/message\u0026gt; \u0026lt;/field-validator\u0026gt; \u0026lt;/validators\u0026gt; # xml文件的头在 xwork-core-2.3.1.1.jar包的 xwork-validator-1.0.3.dtd中复制 ## 关联约束在 \\struts-2.3.15.1\\src\\xwork-core\\src\\main\\resources\\xwork-validator-1.0.3.dtd文件 ## \u0026lt;field-validator type=\u0026quot;\u0026quot;\u0026gt;的约束类型在xwork-core-2.3.1.1.jar包的 /com/opensymphony/xwork2/validator/validators/default.xml文件中 # 16个规则 ## type=\u0026quot;regex\u0026quot;相当于调用了default.xml文件中配置的 ## RegexFieldValidator类的 setExpression方法 3.jsp文件中通过验证标签（同上） 4.xml配置（同上） # 出错信息 1.验证文件名写错，无提示，不验证 2.\u0026lt;field-validator type=\u0026quot;\u0026quot;\u0026gt;写错，有明显提示 2.\u0026lt;field name=\u0026quot;salaryy\u0026quot;\u0026gt;写错，获取的salaryy为空。 声明式（模型驱动） 1.创建bean对象，bean对象中封装属性 2.验证Action类继承ActionSupport类，声明bean对象实例 3.action类同目录 中 ：Action类名-\u0026lt;action标签的name属性\u0026gt;-validation.xml # \u0026lt;field-validator type=\u0026quot;visitor\u0026quot;\u0026gt; # bean类同目录中：bean类名-validation.xml配置验证文件 4.jsp文件请求参数改为：action类中bean对象名.bean对象封装的属性名。用\u0026lt;s:fielderror/\u0026gt;标签得到返回的错误信息 5.xml配置（同上） 原理 StrutsPreparedAndExecuteFilter 1.注入参数 setUsername() setPassword() 2.验证方法：validate()或validateXxx() 验证配置文件中验证：Action类名-validation.xml 3.转发：根据验证成功或失败返回消息 验证集合无错误消息成功Action --\u0026gt; execute或同签名的方法 验证集合有错误消息失败\u0026lt;result name = \u0026quot;input\u0026quot; type=\u0026quot;dispatcher\u0026quot; register.jsp/login.jsp # 过滤器 StrutsPrepareAndExecuteFilter 中查看Dispathcer类，从中找到配置struts-default.xml,struts-plugin.xml,struts.xml值的属性DEFAULT_CONFIGURATION_PATHS 查找引用该属性的方法为init_TraditionalXmlConfigurations 查看引用该方法的方法为init 回头看StrutsPrepareAndExecuteFilter中初始化dispatcher对象的方法initDispatcher 其中调用了dispatcher.init();方法来配置dispatcher 由此可以知道struts在启动时加载了struts-default.xml,struts-plugin.xml,struts.xml配置文件 # 拦截器 struts-core-2.3.1.1.jar包中的 struts-default.xml文件中 定义了32个interceptor（拦截器） i18n # 国际化 token # 表单重复提交 validation # 验证 params # 参数拦截器,向Action类中注入参数 cookie interceptor-tack # 拦截栈 # 拦截栈中的拦截器的先后顺序有影响 basicStack defaultStack # 每个http请求都会经过该拦截栈 ## 其中的18个拦截器, \u0026lt;default-interceptor-ref\u0026gt;中定义 原理 拦截器仿照过滤器建立，内部实现原理是完全相同的 执行流程 拦截器构构造函数 -\u0026gt; action构造函数 -\u0026gt; 拦截器1 in -\u0026gt; 拦截器2 in -\u0026gt; demo -\u0026gt; 拦截器2 out -\u0026gt; 拦截器1 out exception拦截器最先进，最后出 自定义拦截器 1.定义Action类，继承Interceptor接口，重写生命周期方法 public LoginInterceptor() { } public void destroy() { } public void init() { } public String intercept(ActionInvocation invocation) { } 2.配置struts.xml文件 1\u0026gt; 定义拦截器、拦截器栈 \u0026lt;interceptors\u0026gt; \u0026lt;interceptor name=\u0026quot;loginInterceptor\u0026quot; class=\u0026quot;interceptor.LoginInterceptor\u0026quot;/\u0026gt; \u0026lt;interceptor name=\u0026quot;roleInterceptor\u0026quot; class=\u0026quot;interceptor.RoleInterceptor\u0026quot;/\u0026gt; \u0026lt;interceptor-stack name=\u0026quot;crmStack\u0026quot;\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;loginInterceptor\u0026quot;\u0026gt;\u0026lt;/interceptor-ref\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;roleInterceptor\u0026quot;\u0026gt;\u0026lt;/interceptor-ref\u0026gt; \u0026lt;/interceptor-stack\u0026gt; \u0026lt;/interceptors\u0026gt; 2\u0026gt; \u0026lt;action\u0026gt;标签中声明用到的拦截器或拦截器栈 \u0026lt;interceptor-ref name=\u0026quot;loginInterceptor\u0026quot; /\u0026gt; # 此时默认的defaultStack拦截器栈会被替代掉 自定义方法过滤拦截器 # MethodFilterInterceptor继承AbstractInterceptor继承Interceptor，前两个是struts自己实现的自己的包装类 ## 原理：自己实现intercept方法，实现对方法名的过滤。如果符合通过条件，则执行自己的doIntercept方法。所以要求用户重写doIntercept方法实现业务逻辑 \u0026lt;interceptor name=\u0026quot;aloginInterceptor\u0026quot; class=\u0026quot;cn.it.shop.interceptor.AloginInterceptor\u0026quot;\u0026gt; \u0026lt;param name=\u0026quot;excludeMethods\u0026quot;\u0026gt;*$\u0026lt;/param\u0026gt; # 除了*$匹配的方法都执行此拦截器 ## includeMethods为包含匹配的方法执行拦截器 \u0026lt;/interceptor\u0026gt; 生命周期 部署时初始化，每次符合\u0026lt;action\u0026gt;的请求时，执行拦截器 拦截器Action 类 o-\u0026gt; 继承Interceptor 接口 o-\u0026gt; 重写生命周期方法 String intercept(ActionInvocation invocation)方法中调用 invocation.invoke() 放行 invocation.getAction()得到当前的Action类 invocation.getStack()得到值栈中的栈 # invocation用于调试18个拦截器 具体拦截器 struts-default.xml 文件中定义了32种拦截器 alias autowiring chain conversionError cookie clearSession createSession debugging execAndWait exception fileUpload # 只用来验证已经注入的文件是否合格，合格则通过，不合格则不执行action类中对应请求的方法 i18n logger modelDriven # 用于检查action类是否实现ModelDriven\u0026lt;T\u0026gt;接口，然后调用getModel()方法注入得到的对象到栈的项端。 scopedModelDriven params # 注入参数用，包括注入文件（级联注入文件的ContentType与FileName） actionMappingParams prepare staticParams scope servletConfig # 向自定义的实现RequestAware等接口的Action类（一般是BaseAction类）中注入request等相应的map对象 timer token # 防止重复提交 tokenSession validation # 验证 workflow store checkbox profiling roles annotationWorkflow multiselect 数据传递 o-\u0026gt; 拦截器不会向其它拦截器中注入参数，所以自定义拦截器中了参数要从request中获取 o-\u0026gt; 如果想 显式的引用了自己的拦截栈，默认的拦截栈就不引用了，要自己引用，其中的注入参数拦截器向action类中注入参数 技巧 \u0026lt;interceptor-stack name=\u0026quot;defaultStack\u0026quot;\u0026gt; # 对defaultStack进行替换，在它前面添加自定义的拦截器 \u0026lt;interceptor-ref name=\u0026quot;aloginInterceptor\u0026quot;/\u0026gt; \u0026lt;interceptor-ref name=\u0026quot;defaultStack\u0026quot;/\u0026gt; 拦截器中的ActionInvocation对象 可以得到ActionContext # 文件处理 ## 上传 struts2文件上传步骤 1.编写jsp文件 1\u0026gt; post方式提交 2\u0026gt; \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;file1\u0026quot;/\u0026gt; 要添加name属性 3\u0026gt; post表单上传的编码方式是enctype=\u0026quot;multipart/formdata\u0026quot; 2.创建Action类，不必继承任何类(但是如果不继承ActionSupport类的话，拦截器将不会返回提示消息) 1\u0026gt; 定义参数 # 如果不接收上传文件名字符串数组而从文件对象中获取文件名的话，得到的文件名将会是乱码 private File[] image; # 字段名 private String[] imageContentType; # 文件类型 private String[] imageFileName; # 文件名 private String uploadPath; # 前三个参数可以不是数组，在 struts-default.xml配置文件fileUpload拦截器对应的源码中可以找到定义规则： \u0026lt;li\u0026gt;[File Name] : File - the actual File\u0026lt;/li\u0026gt; \u0026lt;p/\u0026gt; \u0026lt;li\u0026gt;[FileName]ContentType : String - the content type of the file\u0026lt;/li\u0026gt; \u0026lt;p/\u0026gt;\u0026lt;li\u0026gt;[File Name]FileName : String - the actual name of the file uploaded(not the HTML name)\u0026lt;/li\u0026gt; # uploadPath是我们自定义的配置文件中注入过来的文件存储位置 2\u0026gt; 写execute方法保存文件到路径，返回成功消息 3.Action类的配置文件，include到src/struts.xml文件中 1\u0026gt; \u0026lt;action\u0026gt;标签中配置name=\u0026quot;input\u0026quot;的标签\u0026lt;result\u0026gt;来返回出错消息 2\u0026gt; \u0026lt;action\u0026gt;标签中用param标签注入文件存储路径：uploadPath 底层执行setUploadPath()方法 3\u0026gt; \u0026lt;action\u0026gt;标签中通过\u0026lt;interceptor-ref name=\u0026quot;fileUpload\u0026quot;\u0026gt;标签对上传文件进行参数上的限定 1\u0026gt; \u0026lt;param name=\u0026quot;maximumSize\u0026quot;\u0026gt; 单个文件的最大尺寸(字节) 2\u0026gt; \u0026lt;param name=\u0026quot;allowedExtensions\u0026quot;\u0026gt; 文件扩展名 3\u0026gt; \u0026lt;param name=\u0026quot;allowedTypes\u0026quot;\u0026gt; 文件实际类型，如image/jpeg，可从tomcat配置文件web.xml中查找 4.配置返回消息的信息 ：src/struts.properties文件中 struts.custom.i18n.resources=struts # 解锁自/org/apache/struts2/default.properties总配置文件 # 加载自己，=后面是参照src/目录的相对路径 ，省略掉.properties扩展名 struts.multipart.maxSize=2097152 # 解锁自/org/apache/struts2/default.properties总配置文件 # 设置上传文件总量的大小 struts.messages.error.file.too.large=\\u6587\\u4EF6\\u592A\\u5927\\: {0} \u0026quot;{1}\u0026quot; \u0026quot;{2}\u0026quot; {3} struts.messages.error.content.type.not.allowed=\\u6587\\u4EF6\\u7C7B\\u578B\\u4E0D\\u6B63\\u786E\\: {0} \u0026quot;{1}\u0026quot; \u0026quot;{2}\u0026quot; {3} struts.messages.error.file.extension.not.allowed=\\u6269\\u5C55\\u540D\\u4E0D\\u6B63\\u786E\\: {0} \u0026quot;{1}\u0026quot; \u0026quot;{2}\u0026quot; {3} # 覆盖/org/apache/struts2/default.properties总配置文件的响应消息,=后面是中文的unicode编码的iso8859-1的表示形式，通过视图可以直接配置，也可以用java/bin目录下的native2ascii.exe工具进行转码 多文件上传 出现有多个文件共同上传时，文件拦截器会出现一错全错的情况，这时我们利用struts的一个 小bug---文件拦截不成功也调用action类的setXxx方法传入文件，从set函数中对文件进行筛选和转存 这时文件拦截器已经形同虚设，一点作用也不起了。 原理过程 1.上传请求经过struts2的过滤器匹配扩展名 2.按src/struts.xml文件中声明的配置包映射的名称空间映射到配置包 3.根据action标签的name属性匹配名称空间与扩展名之间的“文件名”,映射到该action标签 1\u0026gt; 经过多层拦截器 2\u0026gt; 用param标签注入文件存储路径 3\u0026gt; 通过\u0026lt;interceptor-ref name=\u0026quot;fileUpload\u0026quot;\u0026gt;标签对上传文件进行参数上的限定 2\u0026gt; 执行action标签对应类的方法，该方法返回的返回的字符串进行响应 默认配置 1.defaultStack拦截栈中的fileUpload拦截器进行处理 2.default.properties配置文件中 对multipart的上传方式进行了配置 struts.multipart.parser=jakarta # struts使用了第三方的jakerta来给上传文件解码 struts.multipart.saveDir= # 缓存文件的临时目录，不填默认是 ## work/catalina/localhost/web工程名/upload_.....00000..tmp struts.multipart.maxSize=2097152 # 默认支持的上传文件的大小 (字节，2m)，是总大小 3.多数服务器自己删除缓存文件 ## 下载 用传递类型为stream 来返回要下载的文件 写法 \u0026lt;result name=\u0026quot;success\u0026quot; type=\u0026quot;stream\u0026quot;\u0026gt; \u0026lt;!-- 下载文件的类型 --\u0026gt; \u0026lt;param name=\u0026quot;contentType\u0026quot;\u0026gt;image/pjpeg\u0026lt;/param\u0026gt; \u0026lt;!-- byte[]的大小，单位字节 --\u0026gt; \u0026lt;param name=\u0026quot;bufferSize\u0026quot;\u0026gt;2048\u0026lt;/param\u0026gt; \u0026lt;!-- 设置下载响应头，${uuidFileName}是一个OGNL表达式，不是EL表达式 --\u0026gt; \u0026lt;param name=\u0026quot;contentDisposition\u0026quot;\u0026gt;attachment;filename=${uuidFileName}\u0026lt;/param\u0026gt; \u0026lt;!-- 框架调用getXxx()方法，来获取InputStream流对象 --\u0026gt; \u0026lt;param name=\u0026quot;inputName\u0026quot;\u0026gt;imageStream\u0026lt;/param\u0026gt; \u0026lt;/result\u0026gt; # 与其它同样，要注入的参数从stream类型对应的类中可以进行查看 显示与下载的编码问题 o-\u0026gt; 设置tomcat/conf/server.xml \u0026lt;Connector port=\u0026quot;8080\u0026quot; .. URIEncoding=\u0026quot;utf-8\u0026quot;/\u0026gt; o-\u0026gt; 提交下载请求用post方式，struts框架自动给post请求编码解码 数据 # 日志 # scribe facebook出品 特点 支持nfs存储 结构 scribe agent 向scribe发送数据 scribe 接收数据，不同topic 的数据发送给不同的store中 存储系统(store) file, buffer, network, bucket, null, thriftfile, multi chukwa # apache出品，hadoop系列产品 flume cloudera出品 特点 可靠性(节点故障时，日志传送到其他节点) 三种级别 end-to-end 发送前写磁盘，成功时删除 store on failure 失败返回时写磁盘 best effort 不确认数据是否成功 可扩展性 agent collector storage三层架构，每层可扩展。 agent: 将数据源数据发送给collector collector: 将多个agent数据汇总后, 加载到storage中 storge: 存储系统, 可以是file, hdfs, hive, hbase等 agent collector 由master统一 logstash # 分布式日志收集，需结合kafka 爬虫 # cheerio # node解析html，如jquery scrapy-redis # python 分布式爬虫框架 phantomjs # js浏览器模拟框架 分析 # pandas # python数据分析 计算 # druid # apache 特点 分布式, 扩展性强 高可用，可回滚 内存, 时序数据库 亚秒级OLAP, 实时分析 多租户 spark stream hadoop 搜索 # 分类 垂直搜索引擎 针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。 通用搜索引擎 通过关键字的方式实现的，是语义上的搜索，返回的结果倾向于知识成果，比如文章，论文，新闻等 通用搜索引擎的信息量大、查询不准确、深度不够 通用搜索引擎的海量信息无序化 部分 １.索引 ２.分词 ３.搜索 compass # 基于lucene nutch # 基于lucene sunspot # 基于Rsolr，以dsl结构用ruby调solr sphinx # 基于sql的全文检索引擎 lucene # # 原理 block k-d tree 倒排索引 词典 排序数组 # 为了二分查找 # 实现简单，性能差 哈希表 # 性能好，占内存大 跳跃表 # 内存小且可调节, 模糊查询不好 B/B+树 # 磁盘索引 ，更新方便，检索慢 trie树 # 效率与字符串长度有关，只适合做英文词典 dat # 可做中文词典，内存占用小 fst # 共享前缀，内存占用小，要求输入有序，不易更新 内存存前缀索引、磁盘存后缀词块 倒排表 正向文件 # 行式存储，原始文档 doc-values # 列式存储，文档号到值的映射 文件指纹 # 概念 index # 一个倒排表，对应一个目录 segment # index的存储单元，包含多个文档 document # 创建单位 field # 文档里的键值对 term # 分词后的字符串 analyzer tokenizer # 切分文本到索引单元 tokenfilter # 对token预处理 # 常识 特性 索引 高亮 命中率排序 分词 与数据库的区别：数据库注重存储、全文检索注重查询 其它搜索：多媒体搜索 索引库(文件夹 或 内存中)： 只存储了商品的基本信息 索引库与数据库定时同步 索引库 -\u0026gt; document -\u0026gt; field # field是键值对,值只能存数据 同步 IndexWriter:addDocumnet(),delteDocument(),updateDocument() 查询 IndexSearch:search(),get() Field的内部结构 # 不存不索引会报错 Store:控制此Field字段是否存储到索引库中 Index:是否建立索引（索引不区分大小写,过滤词不创建索引） NO:不建立索引，可以通过field的key查到，但是不能通过关键字查询到 NOT_ANALYZED:建立索引，但是不分词 ANALYZEd:建立索引又分词 # 使用到的对象 Directory Analyzer TokenStream tokenStream = analyzer.tokenStream(\u0026quot;eldName\u0026quot;,new StringReader(\u0026quot;测试字符串\u0026quot;)) while(tokenStream.incrementToken()){ TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class); System.out.println(termAttribute.term()); } # 使用分词器测试分词 Document add(Field) document = indexSearcher.doc(ScoreDoc) get(String) # 通过key查找value IndexWriter IndexWriter(directory,analyzer,MaxFieldLength.LIMITED); # LIMITED限定Field的数量(源码中规定默认值) addDocument(Document) commit() close() # 自带commit() rollback() IndexSearcher QueryParser QueryParser(Version.LUCENE_30,\u0026quot;name\u0026quot;,analyzer) Query query = parser.parse(用户传递的字符串); query = parser.parseMultiField(String [], 用户传递的字符串); TopDocs topDocs = indexSearcher.search(query, 10); # 10是期望的结果数 ## 最终查询到的结果数是：期望结果数与实际结果数的最小值 totalHits # 命中的结果数 ScoreDoc ScoreDoc [] scoreDocs = topDocs.scoreDocs; scoreDoc.score # 命中率积分 scoreDoc.doc # 命中文档编号，该编号由lucene自动生成 Term # 索引项 Term(\u0026quot;field中的key\u0026quot;,\u0026quot;field中value解析出的关键字\u0026quot;) # 索引的结构 Term(\u0026quot;key\u0026quot;,\u0026quot;value\u0026quot;)[0,3,4] # key 为对应的field中的\u0026quot;key\u0026quot;,value对应的是解析field的\u0026quot;value\u0026quot;出的关键字 ## []中的内容为匹配的文档编号，该编号为系统自动生成的 # 注意 lucene创建索引时field的key都可以重复，没有主键方面的限制。但是实际应用时要求我们为document有唯一的标识“主键”field,便于对每个document进行更新与删除 # 使用 包：IKAnalyzer,lucence-analyzer(英文分词，不需要),memory,core,highlighter 工具：lukeAll 用来查看索引库 添加、查询、删除、修改 抽取配置类（构造方法私有化） Configuration 维护了directory与analyzer DocumentUtil goodsToDocument(Goods) documentToGoods(Document) LuceneUtil 维护了indexWriter与indexSearcher 注意 1.indexWriter在static代码块中初始化 2.getIndexWriter LuceneService 用indexWriter与indexSearcher处理业务逻辑 添加 indexWriter.addDocument(Document) indexWriter.rollback() 删除 indexWriter.deleteDocument(Term) indexWriter.optimize() # 删除document的时候同步索引库，没有设置的话只是删除document，但是索引中还是可以查到 更新 indexWriter.updateDocument(Term,Document) indexWriter.optimize() # 更新是先删除再添加（所以如果updateDocument(Term,Document)中匹配多个Document时，会出现删除了多个Document,而添加了一个Document的情况） 查询 QueryParser parser = new QueryParser(Version.LUCENE_30, \u0026quot;field中的key\u0026quot;, analyzer); Query query = IKQueryParser.parseMultiField(new String[]{\u0026quot;name\u0026quot;,\u0026quot;remark\u0026quot;}, \u0026quot;ee\u0026quot;); # 多字段查询，IKAnalyzer特有 #　多字段查询到的第二个字段的结果，在转换高管时（调用getBestFragment时）只会对该方法指定的一个字段进行匹配，如果该字段不匹配时（但是第二个字段匹配），则会返回空。 ## 针对这一个bug,在getBestFragment处理匹配的结果返回空时，不使用空而直接返回没有高亮的字符串即可。 parser.parse(用户传递的字符串); TopDocs topDocs = indexSearcher.search(query, 3); # 3是期望结果数 ScoreDoc [] scoreDocs = topDocs.scoreDocs; Document document = indexSearcher.doc(scoreDoc.doc); scoreDoc.doc得到文档编号 分页查询： 传递当前页码与一页记录数 利用topDocs.totalHits得到总记录数 查询本页与前面所有页的期望数据量，然后只截取本页的文档编号，得到document并返回数据 # 分词器 IKAnalyzer 配置文件 src/IKAnalyzer.cfg.xml中配置 \u0026lt;properties\u0026gt; \u0026lt;entry key=\u0026quot;ext_dict\u0026quot;\u0026gt;/mydict.dic\u0026lt;/entry\u0026gt; # 配置自己的字典（不分词） \u0026lt;entry key=\u0026quot;ext_stopwords\u0026quot;\u0026gt;/ext_stopword.dic\u0026lt;/entry\u0026gt; # 配置跳过的字 \u0026lt;/properties\u0026gt; Query query = IKQueryParser.parse(\u0026quot;name\u0026quot;,name); # IKAnalyzer特有 # 排序 Directory directory = FSDirectory.open(new File(\u0026quot;d:/lucene\u0026quot;)); IndexSearcher indexSearcher = new IndexSearcher(directory); Query query = IKQueryParser.parse(\u0026quot;name\u0026quot;,\u0026quot;cc\u0026quot;); Sort sort = new Sort(new SortField(\u0026quot;id\u0026quot;, SortField.INT,true)); # 这里可以排序多个字段 # 参数1：\u0026quot;id\u0026quot;是排序的field字段,参数2：是字段内容的类型,参数3 true代表降序排列 ## 此时命中率不再计算（因为不按命中率排序） ## 排序的field必须建立索引 indexSearcher.search(query, null,10,sort); 高亮 导入包:highlight与memory Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(\u0026quot;\u0026lt;font color='red'\u0026quot;,\u0026quot;\u0026lt;/font\u0026gt;\u0026quot;),new QueryScorer(query)); highlighter.setTextFragmenter(new SimpleFragmenter(10)); # 限制字符长度 .. String result = highlighter.getBastFragment(analyzer,\u0026quot;name\u0026quot;,doc.get(\u0026quot;name\u0026quot;)); # 返回高亮处理字符串 ## 参数1：解析用户输入词的分词器,参数2：是要查询的field的key(没有用)，参数3：field的value solr # 介绍 基于lucene 搜索服务器，http请求提交和返回xml 功能 丰富了查询语言 实现可配置、可扩展 优化了性能 提供了管理界面 缓存功能 垂直搜索 高亮 data schema定义字段 elasticsearch # 介绍 基于lucene 性能 第一次查秒级响应(5-10秒)，放到文件系统缓存(filesystem cache) 再查命令缓存毫秒级响应 # 热点数据要预热 文件系统缓存(内存中分配)和数据量同样大，才有效率 # 冷热分离 分页，会查前面所有数据 # 用scroll api, 快照 + 游标 权限 # shiro # 功能 认证 授权 加密 会话管理 Web集成 缓存 组件 Subject # 当前用户,绑定到SecurityManager SecurityManager # 门面模式，管理组件 Realms # 连接认证数据(用户、角色、权限) Authenticator # 认证principals和credentials Authorizer # 校验权限 SessionManager # 异构客户端 控制方式 url 注解 代码 页面标签 模块 Authenticator # SecurityManager继承Authenticator public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException; permission 概念 subject resource permission role 隐式角色 显示角色 配置 shiro.ini [users] zhang=123, role1, role2 # 用户名=密码, 角色1, 角色2 判断角色 o-\u0026gt; subject.hasRole(\u0026quot;admin\u0026quot;); o-\u0026gt; @RequiresRoles(\u0026quot;admin\u0026quot;) @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND) # 表示当前Subject需要角色admin和user。 o-\u0026gt; \u0026lt;shiro:hasRole name=\u0026quot;admin\u0026quot;\u0026gt;\u0026lt;/shiro:hasRole\u0026gt; 权限注解 @RequiresAuthentication # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。 @RequiresUser # 表示当前Subject已经身份验证或者通过记住我登录的。 @RequiresGuest # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。 @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR) # 表示当前Subject需要权限user:a或user:b。 credential 散列 String str = \u0026quot;hello\u0026quot;; String salt = \u0026quot;123\u0026quot;; //内部使用MessageDigest String simpleHash 密码生成工具 //输入明文密码得到密文密码 String encryptPassword(Object plaintextPassword) throws IllegalArgumentException; //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密） boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info); filter NameableFilter ＃根据名字找到相应的拦截器实例 OncePerRequestFilter # 控制开启、关闭拦截器实例 ShiroFilter # 安全控制 AdviceFilter # aop preHandle # 前置增强 postHandle # 后置增强 afterCompletion # 后置最终增强(异常也执行，相当于finally的概念) PathMatchingFilter # 匹配请求路径 AccessControlFilter # 允许或拒绝访问，拒绝时如何处理 jsp标签 \u0026lt;%@taglib prefix=\u0026quot;shiro\u0026quot; uri=\u0026quot;http://shiro.apache.org/tags\u0026quot; %\u0026gt; \u0026lt;shiro:guest\u0026gt; 欢迎游客访问，\u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/login.jsp\u0026quot;\u0026gt;登录\u0026lt;/a\u0026gt; \u0026lt;/shiro:guest\u0026gt; \u0026lt;shiro:user\u0026gt; 欢迎[\u0026lt;shiro:principal/\u0026gt;]登录，\u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/logout\u0026quot;\u0026gt;退出\u0026lt;/a\u0026gt; \u0026lt;/shiro:user\u0026gt; # 用户已经身份验证/记住我登录后显示相应的信息。 \u0026lt;shiro:authenticated\u0026gt; 用户[\u0026lt;shiro:principal/\u0026gt;]已身份验证通过 \u0026lt;/shiro:authenticated\u0026gt; # 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。 \u0026lt;shiro:notAuthenticated\u0026gt; 未身份验证（包括记住我） \u0026lt;/shiro:notAuthenticated\u0026gt; # 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证。 \u0026lt;shiro: principal/\u0026gt; # 显示用户身份信息，默认调用Subject.getPrincipal()获取 \u0026lt;shiro:principal type=\u0026quot;java.lang.String\u0026quot;/\u0026gt; \u0026lt;shiro:principal property=\u0026quot;username\u0026quot;/\u0026gt; \u0026lt;shiro:hasRole name=\u0026quot;admin\u0026quot;\u0026gt; 用户[\u0026lt;shiro:principal/\u0026gt;]拥有角色admin\u0026lt;br/\u0026gt; \u0026lt;/shiro:hasRole\u0026gt; \u0026lt;shiro:hasAnyRoles name=\u0026quot;admin,user\u0026quot;\u0026gt; 用户[\u0026lt;shiro:principal/\u0026gt;]拥有角色admin或user\u0026lt;br/\u0026gt; \u0026lt;/shiro:hasAnyRoles\u0026gt; \u0026lt;shiro:lacksRole name=\u0026quot;abc\u0026quot;\u0026gt; 用户[\u0026lt;shiro:principal/\u0026gt;]没有角色abc\u0026lt;br/\u0026gt; \u0026lt;/shiro:lacksRole\u0026gt; # 如果当前Subject没有角色将显示body体内容。 \u0026lt;shiro:hasPermission name=\u0026quot;user:create\u0026quot;\u0026gt; 用户[\u0026lt;shiro:principal/\u0026gt;]拥有权限user:create\u0026lt;br/\u0026gt; \u0026lt;/shiro:hasPermission\u0026gt; \u0026lt;shiro:lacksPermission name=\u0026quot;org:create\u0026quot;\u0026gt; 用户[\u0026lt;shiro:principal/\u0026gt;]没有权限org:create\u0026lt;br/\u0026gt; \u0026lt;/shiro:lacksPermission\u0026gt; session 得到会话 login(\u0026quot;classpath:shiro.ini\u0026quot;, \u0026quot;zhang\u0026quot;, \u0026quot;123\u0026quot;); Subject subject = SecurityUtils.getSubject(); Session session = subject.getSession(); api Session getId() getHost() # 调用HostAuthenticationToken.getHost(), 得到主机地址 getTimeout() setTimeout(1000) getStartTimestamp() setLastAccessTime() touch() # 更新会话最后访问时间 stop() # 销毁会话, Subject.logout()与HttpSession.invalidate()会自动调用该api setAttribute(\u0026quot;key\u0026quot;, \u0026quot;123\u0026quot;) getAttribute(\u0026quot;key\u0026quot;) removeAttribute(\u0026quot;key\u0026quot;) SecurityManager Session start(SessionContext context) Session getSession(SessionKey key) throws SessionException WebSessionManager boolean isServletContainerSessions(); # 是否使用Servlet容器的会话 ValidatingSessionManager void validateSessions(); # 验证所有会话是否过期 cache 接口 Cach\u0026lt;K, V\u0026gt; CacheManager CacheManagerAware ini配置 userRealm.cachingEnabled # 启用缓存，默认false userRealm.authenticationCachingEnabled # 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false userRealm.authenticationCacheName # 缓存AuthenticationInfo信息的缓存名称 userRealm. authorizationCachingEnabled # 启用授权缓存，即缓存AuthorizationInfo信息，默认false userRealm. authorizationCacheName # 缓存AuthorizationInfo信息的缓存名称 securityManager.realms=$userRealm cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml securityManager.cacheManager=$cacheManager sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager securityManager.sessionManager=$sessionManager rememberme ssl o-\u0026gt; keytool -genkey -keystore \u0026quot;D:\\localhost.keystore\u0026quot; -alias localhost -keyalg RSA # jdk自带的生成证书工具(包含证书/公钥/私钥） o-\u0026gt; 设置tomcat server.xml \u0026lt;Connector port=\u0026quot;8443\u0026quot; protocol=\u0026quot;HTTP/1.1\u0026quot; SSLEnabled=\u0026quot;true\u0026quot; maxThreads=\u0026quot;150\u0026quot; scheme=\u0026quot;https\u0026quot; secure=\u0026quot;true\u0026quot; clientAuth=\u0026quot;false\u0026quot; sslProtocol=\u0026quot;TLS\u0026quot; keystoreFile=\u0026quot;D:\\localhost.keystore\u0026quot; keystorePass=\u0026quot;123456\u0026quot;/\u0026gt; o-\u0026gt; jasig cas api Subject: 主体, 如用户 SecurityManager: 安全管理器, 管理subject Realm: 权限数据域 授权 对象流程 Subject.isPermitted -\u0026gt; SecurityManager -\u0026gt; Authorizer 对象 ModularRealmAuthorizer # 多realm授权 PermissionResolver # 解析权限字符串到Permission实例 RolePermissionResolver # 从角色得到权限集合 配置 参数 filterChainDefinitions rest：比如/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user：method] ,其中method为post，get，delete等。 port：比如/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal：//serverName：8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。 perms：比如/admins/user/**=perms[user：add：*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，比如/admins/user/**=perms[\u0026quot;user：add：*,user：modify：*\u0026quot;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。 roles：比如/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，比如/admins/user/**=roles[\u0026quot;admin,guest\u0026quot;],每个参数通过才算通过，相当于hasAllRoles()方法。 anon：比如/admins/**=anon 没有参数，表示可以匿名使用。 authc：比如/admins/user/**=authc表示需要认证才能使用，没有参数 authcBasic：比如/admins/user/**=authcBasic没有参数表示httpBasic认证 ssl：比如/admins/user/**=ssl没有参数，表示安全的url请求，协议为https user：比如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查 # remember me可登录 分布式 # redisson # 介绍 使用redis外部存储，实现分布式功能 "},{"id":55,"href":"/docs/pl/haskell/","title":"Haskell","section":"程序语言","content":" 介绍 # 源于ML 标准化的、纯函数式编程语言 非限定性语义和强静态类型 作为其他语言设计新功能时的样板，如Python的lambda标记语句 工具 # 检索函数用http://www.Haskell.org/hoogle 单词 # polymorphism # 多态 monomorphic # 单态 风格 # point free style sum' xs = foldl (+) 0 xs sum' = foldl (+) 0 注意 # 使用缩进代替括号，但也可用括号 文件扩展名 # # 文件中不用let定义变量, # 变量赋值两次会报错, 这意味着代码顺序不重要 hs 内置变量 # pi 模块 # :m Data.Char Data.Map # 加载模块 chr # chr :: Int -\u0026gt; Char ord # ord :: Char -\u0026gt; Int toUpper toLower import Data.Char # 导入到全局命名空间 import Data.List (nub, sort) import Data.List hiding (nub) import qualified Data.Map as M # 这样其中命名冲突的filter, null函数，只能用Data.Map.filter或M.filter方式调用 可用模块 prelude # 默认载入的模块 Data Char List Map Set 自定义模块 module Geometry.Sphere (sphereVolume , sphereArea , Shape(..) # 导出类型和其所有构造子 ) where sphereVolum :: Float -\u0026gt; Float sphereVolum radius = (4.0 / 3.0) * pi * (radius ^ 3) 命令函数 # :load # 加载模块 :load a.hs :l :cd # 切换工作目录 :cd c:\\a :reload # 重载所有模块 :r :type :type 'H' :t :info # 查看一个typeclass有哪些instance和subclass # 类型的信息、函数的类型声明 :k # 查看kind :k Int # Int :: * :k Maybe # Maybe :: * -\u0026gt; * 操作符 # % # 分号 \u0026amp;\u0026amp; || ++ # 字符串拼接 /= # 不等 do # 动作的combine, do 是\u0026gt;\u0026gt;=的语法糖, 用来连接一系列动作 \u0026lt;- # name \u0026lt;- getLine, 存到变量 # 除了程序的最后一行用来作返回值，其它语句都可以用 \u0026lt;- 表达式 # # 表达式可以随处安放 if x \u0026lt; 0 then -1 else if x \u0026gt; 0 then 1 else 0 case x of 0 -\u0026gt; 1 1 -\u0026gt; 5 _ -\u0026gt; (-1) let a = 1 # 局部绑定, in可省略则定义到全局 twice_a = 2 * a in (a + twice_a, a - twice_a) let boot x y z = x * y + z in boot 3 4 2 I/O action # # 在main中 I/O action才被执行 # return () 语句产生I/O action, do接着执行 # 执行后会打印结果，结果为()时不打印 main = do _ \u0026lt;- putStrLn \u0026quot;a\u0026quot; name \u0026lt;- getLine putStrLn (name) 类型表示 # Eq a =\u0026gt; a -\u0026gt; a -\u0026gt; Bool # =\u0026gt; 前面是类型约束, 后面表示传入两个同类型参数，返回Bool类型 变量 # let pi = 3.14 # 变量不可变，但可重复定义 (-1) # 负数一般加小括号 let r = 25 :: Double # 默认猜测是Integer # monomorphish restriction(单一同态限定)原理，可以指定polymorphic(多态) ## let r = 25 :: Num a =\u0026gt; a True, False # 类型为 Bool \u0026quot;abc\u0026quot; # 类型为[char], 与'a':'b':'c':[] a = \u0026quot;aaa\u0026quot; :: String # 得到一个String, 与[char]同样使用 LT, GT, EQ 函数 # # 函数名与参数，参数与参数之间有空格隔开 # 函数比运算符先结合 let area r = pi * r ^ 2 # 定义函数, area 2 area (-2) let area2 r = area r let first (x, y) = x # 接收元组 uppercase, lowercase :: String -\u0026gt; String # 指定函数类型 分段定义 # 编译成case语句 f 0 = 1 f 1 = 5 f _ = -1 函数合成调用 square (f 1) (square . f) 1 (\\xs -\u0026gt; length xs \u0026gt; 15) # lambda表达式 # lambda可以用模式匹配，但使用不了多个模式 列表 # # 列表，类型必须相同。 # 列表都由[]追加得到，逗号是语法糖 let n = [1, 2] [1..20] # range浮点数不精确 take 20 [1,2..] [2,4..20] ['a'..'z'] 0:n # 得到追加列表[0, 1, 2]， 头部追加叫作consing, cons是constructor # -1:0:n [[1], [2]] n !! 1 # 取元素 l1 \u0026gt; l2 # 元素依次比较 [x*2 | x \u0026lt;- [1..10], x*2 \u0026gt;= 12] # list comprehension boomBangs xs = [if x \u0026lt; 10 then \u0026quot;BOOM!\u0026quot; else \u0026quot;BANG!\u0026quot; | x \u0026lt;-xs, odd x] [x*y | x \u0026lt;-[1,2], y \u0026lt;-[3,4]] # 聚合得[3,4,6,8] length' xs = sum [1 | _ \u0026lt;- xs] xxs = [[1,2], [3,4]] [[x | x \u0026lt;- xs, even x] | xs \u0026lt;- xxs] [(a,b,c) | c \u0026lt;- [1..10], b \u0026lt;- [1..c], a \u0026lt;- [1..b], a^2 + b^2 = c ^2] [a + b | (a,b) \u0026lt;- xs] # list comprehension中的模式匹配 模式匹配 x:xs x:y:z:xs 元组 # # 类型可不同，不能单元素。2元组叫pairs, 3元组叫triples, n元组叫n-tuple # 元组不可变 # 元组的类型由长度和其中的类型决定, (\u0026quot;a\u0026quot;, 1)与(1, \u0026quot;a\u0026quot;)是不同的类型，所以[(\u0026quot;a\u0026quot;, 1), (2, \u0026quot;b\u0026quot;)]是错误的 (True, 1) ((1,2), True) monad # o-\u0026gt; do doGuessing num = do putStrLn \u0026quot;Enter your guess:\u0026quot; guess \u0026lt;- getLine if (read guess) \u0026lt; num then do putStrLn \u0026quot;Too low\u0026quot; doGuessing num else if (read guess) \u0026gt; num then do putStrLn \u0026quot;Too high\u0026quot; doGuessing num else putStrLn \u0026quot;You Win\u0026quot; # 只有一个动作时，可省略do o-\u0026gt; do doGuessing num = do putStrLn \u0026quot;Enter your guess:\u0026quot; guess \u0026lt;- getLine case compare (read guess) num of LT -\u0026gt; do putStrLn \u0026quot;Too low\u0026quot; GT -\u0026gt; do putStrLn \u0026quot;Too high\u0026quot; EQ -\u0026gt; putStrLn \u0026quot;You Win\u0026quot; o-\u0026gt; functor applicative monad class Functor f where fmap :: (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b class Functor f =\u0026gt; Applicative f where pure :: a -\u0026gt; f a () :: f (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b class Applicative m =\u0026gt; Monad m where return :: a -\u0026gt; m a (\u0026gt;\u0026gt;=) :: m a -\u0026gt; (a -\u0026gt; m b) -\u0026gt; m b (\u0026gt;\u0026gt;) :: m a -\u0026gt; m b -\u0026gt; m b x \u0026gt;\u0026gt; y = x \u0026gt;\u0026gt;= \\_ -\u0026gt; y fail :: String -\u0026gt; m a fail msg = error msg instance Functor Maybe where fmap func (Just x) = Just (func x) fmap func Nothing = Nothing instance Applicative Maybe where pure = Just Nothing _ = Nothing (Just func) something = fmap func something instance Monad Maybe where return = Just Nothing \u0026gt;\u0026gt;= func = Nothing Just x \u0026gt;\u0026gt;= func = func x 内置函数 # prelude $ # 函数调用符，优先级最低。而空格是最高优先级 # $右结合。而空格左结合 # 等价于在右而写一对括号 . # f . g = \\x -\u0026gt; f (g x) # 函数组合 main # main :: IO () main = do signum # 根据数字返回 -1, 0, 1 not id # identity unlines unlines [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;] # 成为 \u0026quot;a\\nb\\n\u0026quot; unwords unwords [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;] # 成为 \u0026quot;a b\u0026quot; show # 接受各种类型，转换为String, 再转义打印 read read \u0026quot;5\u0026quot; :: Int read \u0026quot;5\u0026quot; - 2 read \u0026quot;[1,2,3]\u0026quot; ++ [4] reads # 读取失败返回[]而不报错 negate # 取反数字 abs # 绝对值 length # 列表的长度, [a] -\u0026gt; Int , a在这里是一个type variable, 以小写字母开头(具体类型都大写开头)。 map compare # 返回 LT, GT, EQ其中一个 min max compare # 返回LT, GT, EQ \u0026quot;Abc\u0026quot; `compare` \u0026quot;Zyx\u0026quot; mod # 取模 odd # 奇数 even # 偶数 succ # 取Enum的后继 pred # 取Enum的前置 minBound # 取Bound下限 maxBound substract # 减 head tail # 除第一个 last init # 除最后一个 null # 检查list是否空 reverse # list反转 take take 1 [1,2,3] takeWhile # 取list值，直到某条件 drop drop 1 [1,2,3] maximum # list中最大元素 minimun # list中最小元素 sum # list和 product # list积 elem # 判断元素是否在list中 4 `elem` [3,4,5] cycle take 7 (cycle [1,2,3]) # [1,2,3,1,2,3,1] repeat repeat 5 replicate replicate 3 10 # [10, 10, 10] fst (1, 2) # 只适合2元组 snd (1, 2) # 只适合2元组 zip # zip3, zip4 ... zip7 zip [1,2,3] [4,5,6] # [(1,4), (2,5), (3,6)] zipWith # zipWith1 ... zipWith7 zipWith (\\x y -\u0026gt; x + y) [1,2] [3,4] # [4,6] fromIntegral # 返回更通用的数字类型 error \u0026quot;\u0026quot; # 抛错 flip # 翻转两个参数调用 map filter foldl foldl (\\acc x -\u0026gt; acc + x) 0 xs foldr foldr (\\x acc -\u0026gt; f x : acc) [] xs foldl1 # 以第一个元素为初始值，空list报错 foldr1 foldl' # foldl的strict版 foldr' scanl # 返回累加过程的list scanr scanl1 scanr1 o-\u0026gt; I/O action # 只有在main中执行 # 类型为 IO a putStrLn # 只接受String，不转义打印，加换行符 # putStrLn :: String -\u0026gt; IO () , 表示接收String, 是IO动作, 结果类型是()。表示是一个\u0026quot;IO monad\u0026quot;动作 putStr # 由putChar递归定义，边界条件是空字符串 putChar print # 打印Show typeclass的值 getLine # 控制台读一行 # getLine :: IO String name \u0026lt;- getLine getChar sequence # 顺序执行I/O action mapM mapM print [1,2,3] # 对list元素执行sequence f mapM_ # 同mapM，不打印[(),()] getContents # 读直到 eof (ctrl + d) interact # 用函数处理输入，返回到输出 Data.List # 每个元素存在thunk中 \\ # 差集 [1..3] \\\\ [2] # [1,3] \u0026quot;Im a big baby\u0026quot; \\\\ \u0026quot;big\u0026quot; # \u0026quot;Im a baby\u0026quot; union intersection insert # 插入一个元素到可排序list相对位置 nub # 去重复元素,常用Set转换取代,提高很多效率 map # 导出到了prelude filter # 导出到了prelude intersperse intersperse '.' \u0026quot;abc\u0026quot; # \u0026quot;a.b.c\u0026quot; intercalate # 同intersperse, 但插入list transpose # 二元list列为行 foldl' # fold的严格版，直接计算出中间值，而非用惰性\u0026quot;承诺\u0026quot;塞满堆栈 foldl1' concat # 移除一级嵌套 concatMap # 先map再concat concatMap (replicate 2) [1..3] # [1,1,2,2,3,3] and # list中全true返回true and $ map (\u0026gt;4) [5,6,7,8] or any iterate # 无限迭代值到函数，结果形成list take 10 $ iterate (*2) 1 splitAt # 断开list, 返回二元组 splitAt 3 \u0026quot;abcdef\u0026quot; # (\u0026quot;abc\u0026quot;, \u0026quot;def\u0026quot;) takeWhile # 取元素，直到不符合条件 dropWhile span # 同takeWhile, 不过返回分割list的二元组 break # 同span, 但在条件首次为true时断开 sort # list元素要求Ord类型，排序list group # 合并相邻并相等的list元素 inits # init递归调用自身 inits \u0026quot;abc\u0026quot; # [\u0026quot;\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot;, \u0026quot;abc\u0026quot;] tails # tail递归调用自身 tails \u0026quot;abc\u0026quot; # [\u0026quot;abc\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;\u0026quot;] isInfixOf # list中搜索子list, 有则返回true \u0026quot;cat\u0026quot; `isInfixOf` \u0026quot;im a cat\u0026quot; isPrefixOf # 是否以某list开头 isSuffixOf # 是否以某list结尾 elem # 是否包含某元素 notElem partition # 条件划分list为二元组 partition (`elem` ['A'..'Z']) \u0026quot;AbCD\u0026quot; # (\u0026quot;ACD\u0026quot;, \u0026quot;b\u0026quot;) find # 条件查找list, 返回第一个符合元素的Maybe值 elemIndex # 返回elem第一个元素的索引的Maybe值 elemIndices # 返回所有匹配索引的list findIndex findIndices lines # 字符串分行到list unlines words # 字符串分词到list unwords delete # 删除list中第一个匹配元素 delete 'h' \u0026quot;hha\u0026quot; # \u0026quot;ha\u0026quot; replace lookup # 用a查找[('a', 'b')]中的b genericLength # 换Int类型为Num类型 genericTake genericDrop genericSplitAt genericIndex genericReplicate nubBy # 传递函数判断相等性，取代== deleteBy unionBy intersectBy groupBy sortBy insertBy maximumBy minimumBy Data.Monoid Monoid Product Sum Any All Data.Foldable foldr foldl foldr1 foldl1 Data.Function on ((==) `on` (\u0026gt; 0)) # 判断相等性，等价于 (\\x y -\u0026gt; (x \u0026gt; 0) == (y \u0026gt; 0)) (compare `on` length) # 判断大小 Data.Char isControl # 是否控制字符 isSpace # 包括空格, tab, 换行等 isLower isUpper isAlpha # 是否字母 isAlphaNum # 字母或数字 isPrint # 可打印 isDigit isOctDigit isHexDigit isLetter # 同isAlpha isMark # unicode注音字符 isNumber isPunctuation # 是否标点符号 isSymbol # 货币符号 isSeperater # unicode空格或分隔符 isAscii # unicode 前128位 isLatin1 # unicode 前256位 isAsciiUpper isAsciiLower GeneralCategory # 得到字符的分类，一共31类, 属于Eq类型 generalCategory ' ' # Space toUpper toLower toTitle digitToInt # 数字，大小写字母list 转成 int list intToDigit ord char Data.Map # 用avl树实现 fromList # 重复键会忽略，要求key有相等性和排序性 fromListWith # 重复键给函数处理 toList empty # 返回空map insert insert 3 10 map insertWith # 已包含键时函数处理 null # 检查map是否空 size # 返回map的大小 singleton singleton 3, 9 # fromList [(3,9)] lookup member # key 是否在map中 map filter keys elems Data.Set # 要求元素可排序，自动排序、唯一 # 用avl树实现 fromList intersection difference # 存在于第一集合而不在第二集合的元素 union null size member empty singleton insert delete isSubsetOf # 子集 fromList [1,2] isSubsetOf fromList [1,2] isProperSubsetOf # 真子集 filter map Data.ByteString # strict bytestring # Empty相当于[], cons相当于: Data.ByteString.Lazy # 每个元素存在chunk中，每个chunk 64k，每个chunk相当于一个strict bytestring # cons在chunk不满的时候会新建chunk, cons'是strick版的cons, 会填充chunk pack # pack :: [Word8] -\u0026gt; ByteString pack [80,81] unpack fromChunks # 转换strick bytestring 到lazy toChunks # lazy转strick Data.Ratio Control.Applicative Applicative class (Functor f) =\u0026gt; Applicative f where pure :: a -\u0026gt; fa (\u0026lt;*\u0026gt;) :: f (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b f \u0026lt;$\u0026gt; x = fmap f x ZipList ZipList3 ZipList7 getZipList liftA2 liftA2 f x y = f \u0026lt;$\u0026gt; x \u0026lt;*\u0026gt; y sequenceA Control.Monad when # Bool true时，返回后面的I/O action, 否则return () forever # 不断执行后面的I/O action forever $ do putStr \u0026quot;a\u0026quot; forM # 同mapM, 但两个参数顺序相反 liftM # monad中的fmap liftM2 liftM3 liftM4 liftM5 `ap` # monad中的\u0026lt;*\u0026gt; join join :: (Monad m) =\u0026gt; m (m a) -\u0026gt; m a join mm = do m \u0026lt;- mm m filterM foldM Control.Monad.State State newtype State s a = State {runState :: s -\u0026gt; (a, s)} get put Control.Monad.Error System.IO openFile # openFile :: FilePath -\u0026gt; IOMode -\u0026gt; IO Handle # data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode do handle = openFile \u0026quot;a.txt\u0026quot; ReadMode contents \u0026lt;- hGetContents handle putStr contents hClose handle withFile # withFile :: FilePath -\u0026gt; IOMode -\u0026gt; (Handle -\u0026gt; IO a) -\u0026gt; IO a # 处理完关掉 withFile \u0026quot;a.txt\u0026quot; ReadMode (\\handle -\u0026gt; do contents \u0026lt;- hGetContents handle putStr contents) readFile # readFile :: FilePath -\u0026gt; IO String do contents \u0026lt;- readFile \u0026quot;a.txt\u0026quot; putStr contents wirteFile # writeFile :: FilePath -\u0026gt; String -\u0026gt; IO () do writeFile \u0026quot;a.txt\u0026quot; contents appendFile hSetBuffering # 读binary file时的buffer，默认是系统值 # data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int) hSetBuffering handle $ BlockBuffering (Just 2048) hFlush # 写入时自动Flush openTempFile (tempName, tempHandle) \u0026lt;- openTempFile \u0026quot;.\u0026quot; \u0026quot;temp\u0026quot; hGetContents hClose hGetLine hPusStr hPutStrLn hGetChar System.IO.Error catch # catch :: IO a -\u0026gt; (IOError -\u0026gt; IO a) -\u0026gt; IO a toTry `catch` handler handler e | isDoesNotExistError e = case ioeGetFileName e of Just path -\u0026gt; putStrLn $ \u0026quot;a\u0026quot; ++ path Nothing -\u0026gt; putStrLn \u0026quot;b\u0026quot; | otherwise = ioError e isDoesNotExistError isAlreadyExistsError isFullError isEOFError isIllegalOperation isPermissionError isUserError ioeGetFileName # ioeGetFileName :: IOError -\u0026gt; Maybe FilePath ioError # 丢出接到的error System.Directory removeFile removeFile \u0026quot;a.txt\u0026quot; renameFile renameFile tempName \u0026quot;a.txt\u0026quot; copyFile doesFileExist System.Environment getArgs getProgName System.Random mkStdGen # mkStdGen :: Int -\u0026gt; StdGen getStdGen # IO类型, 得到系统启动时的global generator newStdGen # 把现有的random generator分成两个新的generators, 其中一个指定成新的，返回另一个 random # random :: (RandomGen g, Random a) = g -\u0026gt; (a, g) random (mkStdGen 100) :: (Int, StdGen) randoms take 5 $ randoms (mkStdGen 11) :: [Int] randomR # 区间random randomR (1,6) (mkStdGen 2) randomRs take 10 $ randomRs ('a', 'z') (mkStdGen 3) :: [Char] 函数 # o-\u0026gt; 模式匹配 # case的语法糖 # 对构造子匹配，如 8 'a' : [] factorial :: (Integral a) =\u0026gt; a -\u0026gt; a factorial 0 = 1 factorial n = n * factorial (n - 1) addVectors :: (Num a) =\u0026gt; (a, a) -\u0026gt; (a, a) -\u0026gt; (a, a) addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) first :: (a, b, c) -\u0026gt; a first (x, _, _) = x tell :: (Show a) =\u0026gt; [a] -\u0026gt; String tell [] = \u0026quot;\u0026quot; tell [x: []] = \u0026quot;\u0026quot; tell [x:y:[]] = \u0026quot;\u0026quot; tell [x:y:_] = \u0026quot;too long, the first is \u0026quot; ++ show x ++ \u0026quot; and the second is \u0026quot; ++ show y length' :: (Num b) =\u0026gt; [a] -\u0026gt; b length' [] = 0 length' (_:xs) = 1 + length' xs capital :: String -\u0026gt; String capital \u0026quot;\u0026quot; = \u0026quot;\u0026quot; capital all@(x:xs) = \u0026quot;The first letter of \u0026quot; ++ all ++ \u0026quot; is \u0026quot; ++ [x] # @是as模式 o-\u0026gt; guard bmiTell :: (RealFloat a) =\u0026gt; a -\u0026gt; String bmiTell weight height | bmi \u0026lt;= skinny = \u0026quot;You're underweight\u0026quot; | bmi \u0026lt;= normal = \u0026quot;You're supposedly normal\u0026quot; | bmi \u0026lt;= fat = \u0026quot;You're fat\u0026quot; | otherwise = \u0026quot;You're a whale\u0026quot; where bmi = weight / height ^ 2 (skinny, normal, fat) = (18.5, 25.0, 30.0) # where是语法结构，不是表达式 calcBmis :: (RealFloat a) =\u0026gt; [(a, a)] -\u0026gt; [a] calcBmis xs = [bmi w h | (w, h) \u0026lt;- xs, let bmi = w / h ^ 2] myCompare :: (Ord a) =\u0026gt; a -\u0026gt; a -\u0026gt; Ordering a `myCompare` b | a \u0026gt; b = GT | a == b = EQ | otherwise = LT o-\u0026gt; quicksort quicksort :: (Ord a) =\u0026gt; [a] -\u0026gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort (filter (\u0026lt;=x) xs) biggerSorted = quicksort [a | a \u0026lt;- xs, a \u0026gt; x] in smallerSorted ++ [x] ++ biggerSorted o-\u0026gt; curry compareWithHundred :: (Num a, ord a) =\u0026gt; a -\u0026gt; Ordering compareWithHundred = compare 100 divideByTen :: (Floating a) =\u0026gt; a -\u0026gt; a divideByTen = (/10) # 中缀函数用括号来不完全调用 # 但(-4)表示负4, (substract 4)来表示减4函数 o-\u0026gt; 高阶函数 applyTwice :: (a -\u0026gt; a) -\u0026gt; a -\u0026gt; a applyTwice f x = f (f x) o-\u0026gt; lambda addThree :: (Num a) =\u0026gt; a -\u0026gt; a -\u0026gt; a -\u0026gt; a addThree = \\x -\u0026gt; \\y -\u0026gt; \\z -\u0026gt; x + y + z o-\u0026gt; $ 做数据函数 map ($ 3) [(4+), (10*), (^2), sqrt] 类型 # 类型 Int # 有界整数 Integer # 无界整数 Float # 单精度浮点数 Double Bool Char Maybe [] () a # type variables 类型约束 Eq # 可判断相等性的类型，可用 == 或 /= 判断 # 只除函数 Ord #可比较大小的类型, 必定是Eq # 只除函数 Ordering # 只有GT, EQ, LT Show # 可用字符串表示的类型 # 只除函数 Read # 与Show相反 Enum # 连续的类型，有后继子(successer)和前置子(predecesor), 分别通过succ函数和pred函数得到 # 可以[1..2]构造list # 包含 (), Bool, Char, Ordering, Int, Integer, Float, Double Bounded # 有上限和下限 # 如果Tuple中都属于Bounded, 那么这个Tuple属于Bounded Num # 数字特征 Integral # 整数 Floating # 浮点，包含Float和Double 构造类型 data Bool = False | True deriving (Ord) # Bool是构造的类型, False为值构造子，值可以用:t查看其类型 # 值构造子可以用于模式匹配 # 这里值构造子是没有参数的，叫作nullary # False在True前，所以比较时True比False大 data Point = Point Float Float deriving (Show) # 值构造子可以与类型同名 data Shape = Circle Point Float | Rectangle Point Point deriving (Show) # 派生自Show, 就可show值成字符串 data Person = Person {firstName :: String , lastName :: String } deriving (Show) # Record Syntax, 同 Person String String, 但自动生成同名的取值函数，show显示也改变 let p = Person {firstName=\u0026quot;aa\u0026quot;, lastName=\u0026quot;bb\u0026quot;} tellPerson :: Person -\u0026gt; String tellPerson (Person {firstName = a, lastName = b}) = a ++ b newtype CharList = CharList {getCharList :: [Char]} deriving {Eq, Show} # newtype将现有类型包成新类型，只能定义单一值构造子，且其只能有一个字段。并将包裹和解开的成本都去掉 类型构造子 # data声明中不能加类型约束 data Maybe a = Nothing | Just a data Car a b = Car { company :: a , year :: b } deriving (Show) tellCar :: (Show a) =\u0026gt; Car String a -\u0026gt; String 类型别名 type String = [Char] type AssocList k v = [(k,v)] # 别名类型构造子 type IntMap = Map Int # 不全调用得到不全类型构造子, 同 type intMap v = Map Int v infixr infixr 5 :-: # 定义中缀构造子, 5是优先级, :-:是符号 # 默认left-associative infixr 5 .++ (.++) :: List a -\u0026gt; List a -\u0026gt; List a Empty .++ ys = ys (x :-: xs) .++ ys = x :-: (xs .++ ys) recursive data structures data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord) typeclass class Eq a where (==) :: a -\u0026gt; a -\u0026gt; Bool (/=) :: a -\u0026gt; a -\u0026gt; Bool x == y = not (x /= y) x /= y = not (x == y) # 只需要instance一个定义就好，这个定义叫minimal complete definition data TrafficLight = Red | Yellow | Green instance Eq TrafficLight where Red == Red = True Green == Green = True Yellow == Yellow = True _ == _ = False instance Show TrafficLight where show Red = \u0026quot;Red light\u0026quot; show Yellow = \u0026quot;Yellow light\u0026quot; show Green = \u0026quot;Green light\u0026quot; class (Eq a) =\u0026gt; Num a where # Num 是 Eq 的 subclass, 要是Num必是Eq instance (Eq m) =\u0026gt; Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False o-\u0026gt; Either data Either a b = Left a | Right a deriving (Eq, Ord, Read, Show) o-\u0026gt; Tree data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) o-\u0026gt; YesNo class YesNo a where yesno :: a -\u0026gt; Bool instance YesNo Int where yesno 0 = False yesno _ = True o-\u0026gt; Functor class Functor f where # map over fmap :: (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b instance Functor Maybe where # 接收构造子而非类型 fmap f (Just x) = Just (f x) fmap f Nothing = Nothing instance Functor (Either a) where # parital apply Either, Either a 是个类型构造子 fmap f (Right x) = Right (f x) fmap f (Left x) = Left x instance Functor ((-\u0026gt;) r) where # 对函数的functor fmap f g = (\\x -\u0026gt; f (g x)) 命令 # ghci set prompt \u0026quot;ghci\u0026gt; \u0026quot; # 设置显示的提示符 ghc ghc --make a.hs runhaskell ghc-pkg list # 列出已安装的软件包 玄学 # o-\u0026gt; :{ data X = X a :: Int -\u0026gt; Int a x = x + 3 :} "},{"id":56,"href":"/docs/pl/markup_language/html/","title":"Html","section":"Markup Language","content":" 事件 # blur change click dblclick focus keydown keypress keyup load mousedown mousemove mouseout mouseover mouseup reset select submit unload Abort # 中断图片下载时激发 AfterPrint # 打印文档后激发 AfterUpdate # 传送完数据 BeforeCopy # 复制到剪贴板前 BeforeCut # 剪切到剪贴板前 BeforeEditFocus BeforePaste BeforePrint BeforeUnload BeforeUpdate Bounce CellChange CtextMenu Copy Cut DataAvailable DatasetChanged DatasetComplete Drag DragDrop DragEnd DragEnter DragLeave DragOver DragStart Drop Error ErrorUpdate FilterChange Finish Help LoseCapture Move Paste PropertyChange ReadyStateChange Resize RowEnter RowExit RowsDelete RowsInserted Scroll SelectStart Start Stop 标签 # \u0026lt;var\u0026gt; # 标识常量 \u0026lt;samp\u0026gt; # 标识输出内容的样式 \u0026lt;pre\u0026gt; # 代码块 \u0026lt;code\u0026gt; # 一段代码 属性 # 全局属性 # 配置所有元素共有行为 accesskey # 快捷键 ## 需要按alt + 指定的键 class contenteditable # 内容是否可修改, 如p标签 contextmenu # 定义右键菜单，未实现 dir # 文字对齐方式 draggable dropzone hidden id lang spellcheck style tabindex # tab键切换元素的顺序 title 浏览器特性 # 视频播放 支持vaapi, chrome 加上--enable-vaapi参数可以开启硬件加速解码 方案 # 标签 \u0026lt;input\u0026gt;表单 单选框 \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;name\u0026quot; checked value=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; name=\u0026quot;name\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt; 下拉框 \u0026lt;select id=\u0026quot;mySelect\u0026quot; size=10 multiple\u0026gt; # 长度等于10 ，多选 \u0026lt;option selected=\u0026quot;selected\u0026quot;\u0026gt;Apple\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;Orange\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 勾选框 \u0026lt;input type=\u0026quot;checkbox\u0026quot; name=\u0026quot;\u0026quot; /\u0026gt; 按钮 \u0026lt;input type=\u0026quot;button\u0026quot;/\u0026gt; \u0026lt;button\u0026gt; # \u0026lt;button\u0026gt;\u0026lt;img src=\u0026quot;\u0026quot;\u0026gt;搜索\u0026lt;/button\u0026gt; button之间可以加图片 \u0026lt;table\u0026gt;表格 \u0026lt;caption\u0026gt; # 标题 \u0026lt;thead\u0026gt; \u0026lt;th\u0026gt; \u0026lt;td\u0026gt;\u0026lt;td\u0026gt; \u0026lt;/th\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tfoot\u0026gt; 属性 \u0026lt;tr style=\u0026quot;display: none;\u0026quot;\u0026gt; # 设置属性为隐藏 \u0026lt;form\u0026gt;表单 enctype属性 application/x-www-form-urlencoded(默认) # 在发送编码所有字符（空格转换为 \u0026quot;+\u0026quot; 加号，特殊符号转换为 ASCII HEX 值） multipart/form-data # 不对字符进行编码，在上传文件时使用 text/plain # 空格转换为+，但是不对特殊字符进行编码 \u0026lt;hr\u0026gt;分割线 字体 \u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt; ... \u0026lt;h6\u0026gt;\u0026lt;h6\u0026gt;标题标签对 \u0026lt;b\u0026gt;粗体\u0026lt;/b\u0026gt;\u0026lt;i\u0026gt;斜体\u0026lt;/i\u0026gt;\u0026lt;u\u0026gt;下划线\u0026lt;/u\u0026gt;\u0026lt;tt\u0026gt;打字机风格\u0026lt;/tt\u0026gt;\u0026lt;cite\u0026gt;引用\u0026lt;/cite\u0026gt;\u0026lt;em\u0026gt;强调（斜体粗体）\u0026lt;/em\u0026gt;\u0026lt;strong\u0026gt;重要（黑体加粗体）\u0026lt;/strong\u0026gt; \u0026lt;sub\u0026gt;下标\u0026lt;/sub\u0026gt;\u0026lt;sup\u0026gt;上标\u0026lt;/sup\u0026gt; \u0026lt;font size =-7到+7 coler = 颜色\u0026gt;\u0026lt;/font\u0026gt; \u0026lt;img src=\u0026quot;\u0026quot;/\u0026gt;图片 属性 alt # 规定图像的替代文本 border width height \u0026lt;span\u0026gt;与 \u0026lt;div\u0026gt; \u0026lt;span\u0026gt; 在CSS定义中属于一个行内元素,在行内定义一个区域，也就是一行内可以被 \u0026lt;span\u0026gt; 划分成好几个区域 ，从而实现某种特定效果。 \u0026lt;span\u0026gt; 本身没有任何属性。 \u0026lt;div\u0026gt; 在CSS定义中属于一个块级元素 \u0026lt;div\u0026gt; 可以包含段落、标题、表格甚至其它部分。 这使DIV便于建立不同集成的类，如章节、摘要或备注。在页面效果上，使用 \u0026lt;div\u0026gt; 会自动换行，使用 \u0026lt;span\u0026gt; 就会保持同行。 \u0026lt;span\u0026gt;没有内边距 \u0026lt;label\u0026gt;标签 标记通常以下面两种方式中的一种来和表单控件相联系：将表单控件作为标记标签的内容，这样的就是隐式形式 ，或者为 \u0026lt;label\u0026gt; 标签下的 for 属性命名一个目标表单 id，这样就是显式形式。 例如，在 XHTML 中： 显式的联系： \u0026lt;label for=\u0026quot;SSN\u0026quot;\u0026gt;Social Security Number:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;SocSecNum\u0026quot; id=\u0026quot;SSn\u0026quot; /\u0026gt; 隐式的联系： \u0026lt;label\u0026gt;Date of Birth: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;DofB\u0026quot; /\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;head\u0026gt;标签 \u0026lt;base\u0026gt; 标签为页面上的所有链接规定默认地址或默认目标。 \u0026lt;meta http-equiv=\u0026quot;pragma\u0026quot; content=\u0026quot;no-cache\u0026quot;\u0026gt; 定义响应信息头 \u0026lt;meta name=\u0026quot;keywrods\u0026quot; content=\u0026quot;keyword1,keyword2\u0026quot;\u0026gt; 关键字 ＜meta name=\u0026quot;description\u0026quot; content=\u0026quot;This page is about the meaning of science, education,culture.\u0026quot;＞ 网站主要内容 ＜meta name=\u0026quot;robots\u0026quot; content=\u0026quot;none\u0026quot;＞ 机器人索引 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 ＜meta name=\u0026quot;author\u0026quot; content=\u0026quot;outrun\u0026quot;＞ 作者 \u0026lt;marquee behavior = \u0026quot;alternate\u0026quot;\u0026gt; 文字行为 # alternate为来回滚动 \u0026lt;font size = 30 color = \u0026quot;red\u0026quot;\u0026gt;www.it315.org\u0026lt;/font\u0026gt;\u0026lt;/marquee\u0026gt; \u0026lt;marquee behavior = \u0026quot;slide\u0026quot; \u0026quot;scroll\u0026quot; \u0026quot;alternate\u0026quot; direction=\u0026quot;up\u0026quot;\u0026quot;down\u0026quot;\u0026quot;left\u0026quot;\u0026quot;right\u0026quot;\u0026gt;你好\u0026lt;/marquee\u0026gt; \u0026lt;nobr\u0026gt; 标签之间的文字在浏览器中不换行显示 \u0026lt;NOBR\u0026gt;这里是一行不该换行的文本 . . . 这是文本行的结尾。\u0026lt;/NOBR\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt; 标签之间的文字在浏览器中换行显示 \u0026lt;blockquote\u0026gt;\u0026lt;/blockquote\u0026gt;缩进 条目标签 \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt; \u0026lt;dd\u0026gt; \u0026lt;/dd\u0026gt; \u0026lt;/dt\u0026gt; \u0026lt;/dl\u0026gt;显示条目 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt;数字标签列表 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;圆点标签列表 \u0026lt;a\u0026gt;标签 发送邮件 \u0026lt;a href = \u0026quot;mailto:admin@it315.org?subject=咨询\u0026quot;\u0026gt;我要留言\u0026lt;/a\u0026gt; 如：mailto:zxx@it315.org?cc=dreamdu@sina.com\u0026amp;subject=Feedback\u0026amp;body=how%20are%20you # subject body cc 等用url参数拼接的方式拼接 %20代表空格 subject= 是标题 body= 是邮件内容 CC=是抄送 BCC=是暗送 新窗口 \u0026lt;a target=\u0026quot;_blank\u0026quot; href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;\u0026quot;/\u0026gt;\u0026lt;/a\u0026gt;打开新窗口 属性 \u0026lt;a name =\u0026quot;mark1\u0026quot;/\u0026gt; \u0026lt;a href=\u0026quot;text.html#mark1\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;定位 \u0026lt;a href=\u0026quot;#\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;打开自己 \u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;打开目录 \u0026lt;map\u0026gt;\u0026lt;/map\u0026gt;定义热点映射4 \u0026lt;area\u0026gt;\u0026lt;/area\u0026gt;来说明 属性shape形状，coords坐标，href或nohref，target赖志明浏览器的哪个窗口或帧中显示 \u0026lt;img\u0026gt;标签中增加名为usemap的属性来指定图像被用做图像地图，其设置值为图像热点名称 如\u0026lt;img src=\u0026quot;\u0026quot; usemap=\u0026quot;#mymap\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;logo.gir\u0026quot; border=0 usemap=\u0026quot;#mymap\u0026quot;\u0026gt; \u0026lt;map name=mymap\u0026gt; \u0026lt;area shape=\u0026quot;rect\u0026quot; coords=\u0026quot;0,0,50,50\u0026quot; href=\u0026quot;\u0026quot;\u0026gt; 左上和右下坐标 shape的属性值 rect poly circle \u0026lt;/map\u0026gt; \u0026lt;embed\u0026gt;\u0026lt;/embed\u0026gt;标签 添加swf类型flash元素 scale=\u0026quot;noscale\u0026quot; # 没有比例缩放 wmode=\u0026quot;transparent\u0026quot; # 背景透明 样式 小图标 \u0026lt;link rel=\u0026quot;Shortcut Icon\u0026quot; href=\u0026quot;../imgs/favicon48.ico\u0026quot;\u0026gt; # 网页小图标 \u0026lt;link rel=\u0026quot;Bookmark\u0026quot; href=\u0026quot;../imgs/favicon48.ico\u0026quot;\u0026gt; # 收藏夹小图标 行为 url标准 基准url + 相对 url = 完整url http://www.it315.org/index.html#section2%E5%AE%9A%E4%BD%8D%E5%88%B0section2 url中空格必须转换为+ url中用字符的当前字符集编码在内存中的十六进制格式表示，并在每个字节前加上% 如果确信特殊字符不会引起冲突，也可以直接传递给服务器，如汉字。也可以一部分编码，一部分不编码，如中\u0026amp;国 就是 中%26国 文件下载 超链接post提交 \u0026lt;form action=\u0026quot;${pageContext.request.contextPath }/downloadFile\u0026quot; method=\u0026quot;post\u0026quot; enctype=\u0026quot;application/x-www-form-urlencoded\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;uuidFileName\u0026quot; value=\u0026quot;\u0026quot; /\u0026gt; \u0026lt;a href=\u0026quot;#\u0026quot; onclick=\u0026quot;download('${fileName}')\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function download(fileName) { $(\u0026quot;:hidden\u0026quot;).val(fileName); document.forms[0].submit(); } \u0026lt;/script\u0026gt; 根目录 \u0026lt;head\u0026gt; \u0026lt;base href=\u0026quot;http://www.w3school.com.cn/i/\u0026quot; target=\u0026quot;_blank\u0026quot; /\u0026gt; # href必选, target可选 ## js中的相对目录也起作用 \u0026lt;/head\u0026gt; frameset frameset的例子 \u0026lt;frameset rows=\u0026quot;70,*\u0026quot; cols=\u0026quot;*\u0026quot; frameborder=\u0026quot;no\u0026quot; border=\u0026quot;0\u0026quot; framespacing=\u0026quot;0\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;head.html\u0026quot; name=\u0026quot;topFrame\u0026quot; scrolling=\u0026quot;No\u0026quot; noresize=\u0026quot;noresize\u0026quot; id=\u0026quot;topFrame\u0026quot; /\u0026gt; \u0026lt;frameset cols=\u0026quot;193,*\u0026quot; frameborder=\u0026quot;no\u0026quot; border=\u0026quot;0\u0026quot; framespacing=\u0026quot;0\u0026quot;\u0026gt; \u0026lt;frame src=\u0026quot;left.html\u0026quot; scrolling=\u0026quot;No\u0026quot; noresize=\u0026quot;noresize\u0026quot; id=\u0026quot;leftFrame\u0026quot; /\u0026gt; \u0026lt;frame src=\u0026quot;main.html\u0026quot; name=\u0026quot;mainFrame\u0026quot; id=\u0026quot;mainFrame\u0026quot; /\u0026gt; \u0026lt;/frameset\u0026gt; \u0026lt;/frameset\u0026gt; # 在head.html 中的标签中添加链接 ## \u0026lt;a href=\u0026quot;/a.html\u0026quot; target=\u0026quot;mainFrame\u0026quot;\u0026gt;Frame main.html\u0026lt;/a\u0026gt; ## 就可以使name 为 mainFrame的\u0026lt;frame\u0026gt;窗体刷新 # 在src属性后面添加#name，可以跳转到指定名子的框架 ## \u0026lt;frame src=\u0026quot;/example/html/link.html#C10\u0026quot;\u0026gt;跳转到link.html页面的：\u0026lt;a name=\u0026quot;C10\u0026quot;\u0026gt;\u0026lt;h2\u0026gt;Chapter 10\u0026lt;/h2\u0026gt;\u0026lt;/a\u0026gt;位置 ## 也可以在a标签中设置跳转\u0026lt;a href=\u0026quot;/example/html/link.html#C10\u0026quot; target=\u0026quot;showframe\u0026quot;\u0026gt;带有锚的链接\u0026lt;/a\u0026gt; 内联框架：iframe 的例子 \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function changeUrl(vPageName){ var vIfr=document.getElementById(\u0026quot;ifrObj\u0026quot;); vIfr.src=vPageName+\u0026quot;.asp\u0026quot;; } \u0026lt;/script\u0026gt; \u0026lt;iframe id=\u0026quot;ifrObj\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;a href=\u0026quot;javascript:changeUrl('2')\u0026quot;\u0026gt;a\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;javascript:changeUrl('3')\u0026quot;\u0026gt;b\u0026lt;/a\u0026gt; svg # 介绍 scalable vector graphics, 可缩放矢量图形 使用xml格式定义图像 由w3c定制 例子 \u0026lt;svg xmlns=\u0026quot;http://www.w3.org/2000/svg\u0026quot; version=\u0026quot;1.1\u0026quot;\u0026gt; \u0026lt;rect width=\u0026quot;300\u0026quot; height=\u0026quot;100\u0026quot; style=\u0026quot;fill:rgb(0, 0, 255); stroke-width:1; stroke:rgb(0, 0, 0)\u0026quot;\u0026gt;\u0026lt;/rect\u0026gt; # 矩形 \u0026lt;/svg\u0026gt; 滤镜 "},{"id":57,"href":"/docs/pl/markup_language/css/","title":"Css","section":"Markup Language","content":" 基础 # # cascading style sheet 层级匹配 不同级 1. style属性 2. style标签 3. link标签 4. 浏览器中用户自定义样式表 5. 浏览器默认样式 # 浏览器对每个元素定义了默认的样式表 !important color: black !important 同级 # 评估得出最特殊的样式, 评分相同时，使用最后的 1. id值的数目 2. 其它属性和伪类的数目 3. 元素名和伪元素的数目 继承 部分元素继承父元素样式 外观继承 布局不继承 inherit # 指明使用父元素样式 border: inherit 三种引入方式 内联式 \u0026lt;div style=\u0026quot;color:#000;\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 嵌入式 \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; div {color:#000;} \u0026lt;/style\u0026gt; 引用式 \u0026lt;link href=\u0026quot;css.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; /\u0026gt; @ @charset \u0026quot;UTF-8\u0026quot; # 默认UTF-8, 在import前 @import \u0026quot;styles.css\u0026quot; # 静态引用, 效率比\u0026lt;link\u0026gt;标签慢 单位 # 颜色 名称, 如silver, gray 0xffffff rgb(112, 128, 144) rgb(112, 128, 114, 0.4) hsl(120, 100%, 22%) # 色相(hue), 饱和度(saturation), 明度(lightness) hsl(120, 100%, 22%, 0.4) 长度 绝对单位 # 只有在打印和设计文档时才用绝对单位 cm pt # 磅 in # 英寸 mm pc # pica 等于12磅 相对长度 em # 元素字号 ex # 元素字体的'x高度'，字体基线到中线的距离，一般与x的高度相当，大致等于0.5em rem # 根元素(html元素)字号 px # css像素，假定了设备的分辨率为96dpi, 是1英寸的1/96(windows系统标准像素密度, 其它平台浏览器自己转换), css在定义中px是相对单位，但浏览器实现中全是绝对单位 % # 不是所有元素都可以用, 不同属性中%定义不同，如font-size挂钩继承的font-size值, width挂钩元素包含块的宽度 算式 # css3 未得到广泛支持 width: calc(80% - 20px); 角度 deg # 度, 0 - 360 grad # 百分度 0 - 400 rad # 弧度 0 - 6.28 turn # 圆周 1 turn = 360 deg 时间 s ms 选择器 # * # 所有元素 \u0026lt;type\u0026gt; # 标签 .\u0026lt;class\u0026gt; # 样式 #\u0026lt;id\u0026gt; # id [attr] # 属性, 如[title] {} [attr=\u0026quot;val\u0026quot;] [attr^=\u0026quot;val\u0026quot;] # 以val开头 [attr$=\u0026quot;val\u0026quot;] [attr*=\u0026quot;val\u0026quot;] # 包含val [attr~=\u0026quot;val\u0026quot;] # 属性多值有val, 空格隔开 [class~=\u0026quot;class2\u0026quot;] {} [attr|=\u0026quot;val\u0026quot;] # 属性多值有val, - 隔开 [lang |=\u0026quot;en\u0026quot;] \u0026lt;selector\u0026gt;, \u0026lt;selector\u0026gt; # 同时匹配 \u0026lt;selector\u0026gt; \u0026lt;selector\u0026gt; # 后代 \u0026lt;selector\u0026gt; \u0026gt; \u0026lt;selector\u0026gt; # 直接后代 \u0026lt;selector\u0026gt; + \u0026lt;selector\u0026gt; # p 之后的第一个兄弟a \u0026lt;selector\u0026gt; ~ \u0026lt;selector\u0026gt; # p 之后所有兄弟a o-\u0026gt; 伪元素 # 直接使用匹配所有 ::first-line # 块级元素文本首行 ::first-letter # 块级元素文本首字母 :before # 之前插入内容 {content: 'a'} :after # 之后插入内容 o-\u0026gt; 伪类 # 直接使用匹配所有 :root # 文档根元素, 总是返回html元素 :first-child # 第一子元素 p \u0026gt; span: first-child , p 下面第一个span元素 :last-child :only-child # 只有一个子元素的该元素 :only-of-type # 同上但指定类型，直接使用时会匹配更多，因为很多某类型的唯一元素 :nth-child(n) # body \u0026gt; :nth-child(2) :nth-last-child(n) :nth-of-type(n) :nth-last-of-type(n) o-\u0026gt; UI 伪类 :enabled # 已启用的元素 :disabled # 禁用的元素 :checked # 选中的单选或复选按钮 :default # 默认的元素, 如 \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;, 常和outline属性一起使用 :valid # 输入验证有效的元素 :invalid :in-range # 范围内的input元素, 未广泛支持 :out-of-range :required # 允许使用required属性的input元素 :optional # 非required o-\u0026gt; 动态伪类 :link # 未访问的a元素 :visited # 已访问过的a元素 :hover :active # 当前激活的元素(鼠标按下) :focus # 获得焦点的元素 :not(\u0026lt;selector\u0026gt;) # a:not([href*=\u0026quot;apress\u0026quot;]) :empty # 无子元素的元素 :lang(\u0026lt;language\u0026gt;) # lang属性为指定值 :lang(en) 匹配 \u0026lt;a lang=\u0026quot;en-us\u0026quot;\u0026gt; :target # url hash(片段标识符) 定向id所在的元素 例子 o-\u0026gt; span.class2 {} o-\u0026gt; body \u0026gt; * \u0026gt; span, tr \u0026gt; th {} o-\u0026gt; 计数器 body {counter-reset: paracount;} p:before { content: counter(paracount) \u0026quot; \u0026quot;; counter-increment: paracount; # counter-increment: paracount 2; 可以增加2 } o-\u0026gt; :checked + span 属性 # 布局 # position # 默认static, top等属性不起作用 static absolute fixed # fixed滚动固定 relative left right top bottom z-index columns # 列数和列宽的简写属性 column-count # 多列布局的列数 column-fill # 列间内容分布方式 column-gap # 列间隔 column-rule # 列间规则的简写属性 column-rule-color column-rule-style column-rule-width column-span # 元素跨列数 column-width flex-align # 弹性盒子布局, 未实现 flex-direction flex-order flex-pack -webkit-box-align # 内容高度小于容器高度时 # start(顶边放置), end(底边放置), center(中间放置), baseline, stretch(拉伸元素) -webkit-box-flex # 元素可伸缩性 -webkit-box-pack # 元素伸缩到最大尺寸(max-width)时怎么做 # start(左边放置), end(右边放置), center(中间放置), justify(平均分配到各个元素间) -webkit-box-direction # 内部盒子排列顺序 例子 o-\u0026gt; 多列布局 column-count: 3; column-fill: balance; column-rule: medium solid black; column-gap: 1.5em; column-width: 10em; o-\u0026gt; 弹性盒 #container { display: -webkit-box; -webkit-box-direction: reverse; -webkit-box-align: end; -webkit-box-pack: justify; } #first {-webkit-box-flex: 3;} #second {-webkit-box-flex: 1;} o-\u0026gt; css表格 #table {display: table;} div.row {display: table-row;} p {display: table-cell;} 盒模型 # box-sizing # 尺寸样式(如width, height)应用到哪部分 # content-box, padding-box, border-box, margin-box display inline # 显示为文本行中的字 inline时，忽略width, height, margin属性 block # 显示为段落, 在垂直方向有所区别 inline-block # 显示为文本行, 整体作为inline, 但内部作为block, 这样认width, height, margin属性 list-item # 显示为列表项 run-in # 类型取决于周围元素 包含display:block元素，就是block 兄弟都是block时，为inline 其它都为block compact # 为块或标记盒(类list-item), 一般不支持 flexbox # 弹性盒布局用 -webkit-box table # 表格布局用 inline-table table-caption # 类似caption table-row-group # 类似tbody table-header-group # 类似thead table-footer-group # 类似tfoot table-row # 类似tr table-column-group # 类似colgroup table-column # 类似col table-cell # 类似td ruby # ruby注释的文本布局用 ruby-base ruby-text ruby-base-group ruby-text-group none # 元素不可见，不占空间 float # 元素左边界或右边界移动到包含块或另一个浮动盒的边界。其余inline部分流式环绕 left, right, none clear # 左右边界不能挨着另外浮动元素 left, right, both, none padding padding-bottom padding-left padding-right padding-top margin margin-bottom margin-left margin-right margin-top height # 长度或百分比 width max-height max-width min-height min-width overflow auto # 同scroll, 但自动加滚动条 hidden # 剪掉 on-content # 移除内容, 已废弃 on-display # 隐藏内容, 已废弃 scroll, visible # 溢出 overflow-x overflow-y visibility # 元素可见性 collapse # 不可见，不占据空间, 只能用在表相关内容，如tr, td hidden # 不可见，占据空间 visible 边框 # border # border: 30px dashed #000 border-width # 可以是长度值, 百分比, thin, medium, thick border-width: 15px 5px 15px 5px border-style none 默认 dashed 破折线 dotted 圆点 double 双线 groove 槽线 inset 内嵌效果 outset 外凸效果 ridge 脊线 solid 实线 border-style: solid dotted dashed double 定义了上、右、下、左的样式 border-style: none的时候，边框其它属性无意义 border-color blue rgb(25%, 35%, 45%) #909090 red; border-image # 不广泛支持 border-image-outset border-image-repeat stretch 拉伸 repeat 平铺 round 不截断下拉伸 space不截断下图片间保留间距平铺 border-image-slice border-image-source border-image-width o-\u0026gt; -webkit-border-image, -moz-border-image, -o-border-image border-image: url(a.png) 30 / 50px round repeat; 九宫格切分长度都为30, 宽度为50, 横round, 竖repeat border-left border-left-style border-left-color border-left-width border-right border-right-color border-right-style border-right-width border-top border-top-style border-top-color border-top-width border-top-left-radius border-top-left-radius: 20px 15px; x半径20, y半径15 border-top-right-radius border-bottom border-bottom-style border-bottom-width border-bottom-color border-bottom-left-radius border-bottom-right-radius border-radius border-radius: 20px / 15px; border-radius: 50% 20px 25% 5em / 25% 15px 40px 55% box-shadow box-shadow: hoffset voffset blur spread color inset 水平偏移量, 正向右，负向左。垂直偏移量，正向下，负向上。模糊值。阴影延伸半径，正向各方向延伸，负缩小。颜色。内嵌阴影 可设置多组阴影，用, 隔开 outline # 轮廓不属于页面，不影响布局, \u0026lt;颜色\u0026gt; \u0026lt;样式\u0026gt; \u0026lt;宽度\u0026gt; outline-color outline-offset # 距元素边框边缘的偏移量 outline-style # 同border-style outline-width # 同border-width 背景 # # 不继承 background # background: \u0026lt;background-color\u0026gt; \u0026lt;background-position\u0026gt; \u0026lt;background-size\u0026gt; \u0026lt;background-repeat\u0026gt; \u0026lt;background-origin\u0026gt; \u0026lt;background--clip\u0026gt; \u0026lt;background-attachment\u0026gt; \u0026lt;background-image\u0026gt; background-attachment # 背景附着方式 fixed 固定到视窗上, 不随文字滚动 local 随文字滚动 scroll 固定到元素上(使用浏览器的滚动条), 不随文字滚动 background-color # 原点在border外边缘 函数 linear-gradient(transparent, rgba(0, 0, 0, 0.1) 20%, rgba(0, 0, 0, 0.5) 65%, rgba(0, 0, 0, 0.66)) # 线性渐变 background-image # 原点在padding外边缘，也就是border内边缘 background-image: url(\u0026quot;bg.jpg\u0026quot;) background-position # 起始位置, 可以是长度, top, left, right ,bottom, center, 第一个值控制垂直位置, 第二个值控制水平位置 0px 0px # 左上偏移0, 0 right ？ # 位置在右边显示 left ？ # 位置在左连显示(默认) ？ bottom center center # 位置在中间显示、内容从中间开始显示(默认) ? top # 内容从上开始显示 background-repeat no-repeat repeat 水平和垂直同时平铺 repeat-x 水平平铺 repeat-y space 水平或垂直平铺, 统一间距,不截断, round 水平或垂直拉伸, 不截断 background-size # 可以长度值或百分比 contain 等比缩放, 宽高适应匹配, 不超出容器 cover 等比缩放, 宽高最大适应匹配, 可超出容器 auto 本身尺寸显示 background-origin # 定位显示原点 border-box 边框盒子内 padding-box 内边距盒子内 content-box 内容盒子内 background-clip # 裁剪, 属性同上 色彩 # opacity color # 前景颜色 rgba(255, 255, 255, 0.7) user-select # 用户不可选择 filter # 滤镜效果, ie8 或之前使用 filter:alpha(opacity=50)，同opacity: .5 文本 # text-decoration # node时 a标签没有下划线 text-indent # 首行缩进 text-align start 语言的起始边界，可能是右 end, left, right, center, justify text-justify # text-align: justify时来指定规则 auto none 禁用文本对齐 inter-word 空白在单词之间 inter-ideograph 中日韩 inter-cluster 泰 distribute, kashida 草体 text-transform # 转换大小写 none, capitalize, uppercase, lowercase text-decoration # 文本装饰 none, underlinenone, overline, line-through, blink text-shadow # 文本阴影, \u0026lt;h-shadow\u0026gt; \u0026lt;v-shadow\u0026gt; \u0026lt;blur\u0026gt; \u0026lt;color\u0026gt;, 水平偏移, 垂直偏移, 模糊程度, 颜色 direction # 文本对齐 ltr, rtl word-spacing # 词间距 letter-spacing # 字母间距 white-space normal 空白被压缩，文本行自动换行 nowrap 空白压缩，文本行不换行 pre 空白不压缩, 换行符换行 pre-line 空白压缩，自动换行或换行符换行 pre-wrap 空白不压缩, 自动换行或换行符换行 line-height # 行高, 百分比，长度 word-wrap # 行超距单词截断 normal 溢出 break-word @font-face # 指定web字体, woff得到最广泛支持, 在@font-face中定义，font-family中使用 @font-face { font-family: 'MyFont'; font-style: normal; font-weight: normal; src: url('http://a/MyFont.woff') } font # \u0026lt;font-style\u0026gt; \u0026lt;font-variant\u0026gt; \u0026lt;font-weight\u0026gt; \u0026lt;font-size\u0026gt; \u0026lt;font-family\u0026gt; 简写属性 font-family # serif, sans-serif, monospace, cursive, fantasy font-family: MyFont, cursive font-style # normal, italic, oblique font-variant # normal, small-caps font-weight # bold, bolder, lighter font-size xx-small 浏览器决定的大小 x-small, small, medium, large, x-large, xx-large smaller 相对父元素字体的大小 larger, \u0026lt;length\u0026gt;, \u0026lt;%\u0026gt; 列表样式 # list-style # \u0026lt;list-style-type\u0026gt; \u0026lt;list-style-position\u0026gt; \u0026lt;list-style-image\u0026gt; list-style-type # 列表项前标记 none, box, check, circle, diamond, disc, dash, square, decimal, binary, lower-alpha, upper-alpha list-style-image # 图片作为列表标记 list-style-position # 相对于内容框的位置 inside 内容框内部 outside 外部 vertical-align # 垂直对齐（文字不行） cursor auto ：标准光标 default ：标准箭头 hand ：手形光标 wait ：等待光标 text ：I形光标 vertical-text ：水平I形光标 no-drop ：不可拖动光标 not-allowed ：无效光标 help ：?帮助光标 all-scroll ：三角方向标 move ：移动标 crosshair ：十字标 pointer e-resize n-resize nw-resize w-resize s-resize se-resize sw-resize ne-resize 表格样式 # border-collapse # 相邻单元格边框样式 separate 默认，重复画框 collapse 合并边框 border-spacing # 相邻单元格边框距离 table-layout # 单元格行列的算法规则 auto fixed 由表格自身样式和每列width属性决定布局[无则设等间距]，由第一行决定列宽，以下行内容自动换行 caption-side # 表格标题的位置 top, bottom empty-cells # 是否显示表格中空单元格 hide 计数器 # counter-reset # 用于有序列表 counter-increment 动画 # 介绍 本质是增强过渡 @keyframes 指定一个以上关键帧 只在过程中有效，动画结束后即使仍hover, 也返回初始状态 animation 动画，动画完后回到初始状态。想停留在结束状态用过渡。 可以用在初始布局中 通过keyframe显式控制， 可重用 \u0026lt;animation-name\u0026gt; \u0026lt;animation-duration\u0026gt; \u0026lt;animation-timing-function\u0026gt; \u0026lt;animation-delay\u0026gt; \u0026lt;animation-iteration-count\u0026gt; 只是模拟属性值改变来实现动画，动画结束后属性无变化 可以应用到页面的初始布局中去，而transform只能应用在动作上 animation-delay # 延迟，可以指定多个值，对应transition-property中的多个属性 animation-direction # 重复播放时播放方向 normal 每次向前播放 alternate 先向前，再反向，相当于animation-iteration-count: 2 animation-duration # 持续时间, 可多值 animation-iteration-count # 循环次数 infinite # 无休止交替播放 animation-name # 关键帧集合名称，可多个 animation-play-state # 动画状态, js中ele.style.webkitAnimationPlayState = 'paused' paused # 停止 playing # 开始播放 animation-timing-function # 关键帧时间插值函数 normal # 每次重复向前播放 alternate # 先向前播放，再反向播放，相当于animation-iteration-count: 2 transform # 变换，动画结束后属性有变化 -moz-transform: rotate(-45deg) scaleX(1.2) # 逆时针旋转45度, 延x轴缩放到1.2倍 函数 translate # 水平、垂直或两个方向 平衡。长度，百分比 translateX translateY scale # 数 scaleX scaleY rotate # 角度 skew # 倾斜, 角度 skewX skewY matrix # 6个参数。自定义变换, 由于z缩放未被实现，后两个参数省略 transform-origin # 变换的起点，默认是元素中心点 transform-origin right top; 长度，百分比，left center right, top center, bottom transition # \u0026lt;transition-property\u0026gt; \u0026lt;transition-duration\u0026gt; \u0026lt;transition-timing-function\u0026gt; \u0026lt;transition-delay\u0026gt;, 可以作为初始状态，也可以过渡 transition-delay # 开始之间延迟时间, ms transition-duration # 持续时间, ms transition-property # 应用过渡的多个属性 transition-timing-function # 时间函数 ease 默认 linear ease-in ease-out ease-in-out cubic-bezier 指定自定义曲线 o-\u0026gt; -webkit- transition: .2s background-cololr transition: .2s all 示例 o-\u0026gt; 过渡 #banana { font-size: large; border: medium solid black; -webkit-transition-delay: 10ms; -webkit-transition-duration: 250ms; # 反向过渡 } #banana:hover { font-size: x-large; border: medium solid white background-color: green; color: white; padding: 4px; -webkit-transition-delay: 100ms; -webkit-transition-property: background-color, color, padding, font-size, border; -webkit-transition-duration: 500ms; -webkit-transition-timing-function: linear; } o-\u0026gt; 动画 #banana:hover { -webkit-animation-delay: 100ms; -webkit-animation-duration: 500ms; -webkit-animation-iteration-count: infinite; -webkit-animation-timing-function: linear; -webkit-animation-name: 'GrowShrink'; -webkit-animation-direction: alternate; } @-webkit-keyframes GrowShrink { from { # 可以用0%替代 font-size: xx-small; background-color: red; } 50% { # 定义了变化的速率，可以用0%, 100%代替from和to子句 background-color: yellow; padding: 1px; } to { # 可以用100%替代 font-size: x-large; border: medium solid white; background-color: green; color: white; padding: 4px; } } o-\u0026gt; 变换 #banana { -moz-transform: rotate(-45deg) scale(1.2); -moz-transform-origin: right top; } 典型问题 # 垂直居中 line-height .content { height: 100px; line-height: 100px; } vertical-align .wrapper {display: table;} .cell { display: table-cell; vertical-align: middle; } position .wrapper {position: relative} .content { left: 50%; top: 50%; transform: translate(-50%, -50%) } position .content { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; } float填充一半 .floater { float: left; height: 50%; margin-bottom: -120px; } .content { clear: both; height: 240px; position: relative; } 图标切分 background-image: url(/base/icons.png); background-repeat: no-repeat; background-position: -910px -74px; 内部元素自动高度 .parent { overflow: hidden; } .parent .children { overflow: hidden; } 工具 # stylus # css扩展语言, 创建富有表现力的css, 比less更强大, 类似jquery的css引擎, 支持node.js compass # 编译到css，是sass的toolkit, 是用ruby开发的 blueprint # css框架 sass # css扩展语言 caniuse.com # 在线浏览器兼容性测试 modernizr.com # 测试特性支持是否到位 less # 介绍 less于css如jquery于js 安装使用 npm install -g less 命令 lessc styles.less \u0026gt; styles.css # 编译 # -x 压缩 --clean-css 更复杂的压缩 语法 模板 {% %} 变量 @color: #4D926F; #header{ color: @color } h2{ color: @color } "},{"id":58,"href":"/docs/pl/elixir/","title":"Elixir","section":"程序语言","content":" 介绍 # 跑在erlang虚拟机上 与erlang相同，actor称作进程, 是比线程更轻量的概念 使用 # o-\u0026gt; 元组 {:foo, \u0026quot;this\u0026quot;, 42} # 三元组 o-\u0026gt; actor defmodule Talker do def loop do receive do {:greet, name, age} -\u0026gt; IO.puts(\u0026quot;Hello #{name}\u0026quot;) {:shutdown} -\u0026gt; exit(:normal) end loop end end pid = spawn(\u0026amp;Talker.loop/0) send(pid, {:greet, \u0026quot;Huey\u0026quot;, 16}) sleep(1000) Process.flag(:trap_exit, true) pid = spawn_link(\u0026amp;Takler.loop/0) send(pid, {:shutdown}) receive do {:EXIT, ^pid, reason} -\u0026gt; IO.puts(\u0026quot;Talker has exited (#{reason})\u0026quot;) end o-\u0026gt; 有状态的actor # 递归 defmodule Counter do def start(count) do spawn(__MODULE__, :loop, [count]) # 伪变量__MODULE__, 是当前模块的名字 end def next(counter) do send(counter, {:next}) end def loop(count) do receive do {:next} -\u0026gt; IO.puts(\u0026quot;Current count: #{count}\u0026quot;) loop(count + 1) end end end counter = spawn(Counter, :loop, [1]) send(counter, {:next}) counter = Countre.start(42) Counter.next(counter) "},{"id":59,"href":"/docs/pl/go/","title":"Go","section":"程序语言","content":" 基础 # 特点 易工程化 简单性而不方便性，避免工程复杂性乘法增长 # 某部分变复杂，增加其他部分的复杂性(功能、选项、配置) 没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储 类型系统，无类型风格 自然方式工作 不显式初始化和隐式构造函数 集合直接持有元素 标准库避免配置和解释 # 自带电池 项目结构简单 编译检查代码格式 csp(communicating sequential process)并发，变长栈运行轻量线程 编译为本地机器码 # 像c一样，所以又叫类c语言 编译快 引用包名在头 包依赖有向无环，可独立和并行编译 目标文件包含依赖包信息 强静态类型 有gc 变长栈，最小2kb, 最大1GB 大厂支持 历史 2007年设计，受影响于Alef(CSP系列), Oberon-2(ALGOL60, Modula-2系列), C # 目的解决google许多复杂性激增的软件系统 2009年发布, 作者是Robert Griesemer, Rob Pike, Ken Thompson 2012年1.0 并发编程特点 语言层面关键字 例程 流程控制: csp # channel为一等公民 通信方式: promise-future, channel, event 高效调度模型(调度器，资源占用小) O(1)的调度 一进程可支撑上百万例程,5kib/goroutine的开销, 变长栈存goroutine 编译 CGO_ENABLED=0 # 静态链接，不跨平台 初始化 包级别初始化在main前 局部变量在函数执行时 配置 GOROOT # go安装目录 GOPATH # 包目录, 默认要有go的bin目录 GOBIN # 当前bin目录 GO15VENDOREXPERIMENT # 依赖目录 GOOS # 指定操作系统, 如android, linux, darwin, windows GOARCH # 处理器架构，如amd64, 386, arm 命令 # go help importpath # 说明 指定代码托管网站版本协议 gopath # vendor怎么使用 list # go list 说明 version env # 打印go环境信息 run # 编译并运行 -race # 检查运行中的竞态冲突并报告 build # 库被舍弃，main包编译成二进制执行文件, 会检测mod go build gopl.io go build x.go -race -i # 编译到指定位置 install # 编译安装, 会检测mod clean # 清理build产生的文件 -c # 清理.test文件 -i # 清理生成的可执行文件 -r # 包括依赖包的结果文件 doc 命令 go doc go/build 包 go doc html/template 包成员 go doc time.Since 方法 go doc http.ListenAndServe fmt # 代码格式化 get # 下载依赖, 默认目录是GOPATH下的pkg。下载后自动install go get gopl.io/... # ...通配 get gopl.io@2 # 指定mod版本号 -u # 更新到mod最新版本 -v # 查看进度 list # 列出指定代码包的信息 go list ... # ...通配 go list ...xml... -json hash # 输出json格式完整信息 -f # 使用go模板 fix # 升级旧代码成新版本代码 vet # 检查静态错误 test # go test -cover -args -config config_it.toml -test.run \u0026quot;TestA\u0026quot; # 执行当前目录下所有_test.go结尾的文件 -race -file # 可省略，测试单个文件, 如go test test_a.go a.go a.pb.go ## 测试单个文件需要引入原文件 -args # 运行时参数 -run TestFoo # 正则表达式匹配方法，NONE表示不匹配。如\u0026quot;^TestFoo\u0026quot;, \u0026quot;F|F1\u0026quot; -test.run \u0026quot;TestCreate\u0026quot; # 同上 -v # 每个测试用例的名称和时间 -bench=\u0026quot;.*\u0026quot; # 正则匹配benchmark测试函数 -benchmem # 显示benchmark测试时内存分配 --cpuprofile=cpu.prof # 生成cpu分析文件，使用多个标记时(如cpu, mem), 一个类别会覆盖另一个。性能剖析启用时, go test不丢弃其临时可执行文件 --blockprofile=block.out # 生成阻塞分析文件 --memprofile=mem.prof # 生成内存分析文件 -c # 生成可执行的二进制文件，名为x.test，它用来生成状态图 -cover # 显示覆盖语句汇总信息 -coverprofile=c.out # 生成日志文件c.out，记录语句覆盖信息 -covermode=count # 语句覆盖信息不用bool而用count累加 tool cover # 测试覆盖率工具使用方法 go tool cover -html=c.out # html分析c.out pprof # 交互式访问概要文件 go tool pprof module1.test cpu.prof # 性能测试状态图, 参数是可执行文件和剖析日志 -test # 文本格式 -nodecount=10 # 限制输出10行 -web # 渲染有向图web显示 fix # 同go fix vet # 同go vet cgo # 生成能够调用c语言代码的go源码文件 compile -help # 可传给编译器的参数 mod init packageName1 # 生成go.mod download # 下载mod tidy # 下载缺少，删除多余 edit # 编辑go.mod graph # 打印依赖图 vendor # 复制依赖到vendor verify # 验证mod why # 打印依赖原因 godoc # 提供html页面 -http=:6060 # 运行本地帮助网站 -analysis=type # 提供静态分析结果 -analysis=pointer gofmt golint # 检查风格 常用 # go mod 配置 环境变量 GO111MODULE off # 总关闭 on # 总开启 auto # 默认，有go.mod开启 路径 $GOPATH/pkg/mod # 保存多版本依赖, 被多项目引用 go.mod # 被go命令维护, 融入了go命令的各个模块 go.sum # 记录lock 依赖加载顺序 最新release tag 最新commit 命令 go mod vendor 代理 go env -w GOPROXY=https://goproxy.cn,direct 包升级 go list -m -u all # 检查可以升级的package go get -u need-upgrade-package # 升级 性能测试 go test -bench=. --cpuprofile=cpu.prof --memprofile=mem.prof -config ../conf/config_lc.toml -test.run TestCreateType 覆盖率 go test -cover -args -config config.toml -test.run \u0026quot;TestCreate\u0026quot; 性能分析 go tool pprof service.test cpu.prof go-torch -b cpu.prof 包管理 go list -m -u all # 列可升级包 go list -u need-upgrade-package # 升级可升级包 go get -u # 升级所有依赖 工具 # glide # 介绍 包管理 目录 glide.yaml glide.lock main.go subpackages vendor 命令 glide init # 扫描代码目录，创建glide.yaml文件，记录所有依赖 删除glide.yaml中自己项目本身 get # 安装并更新glide.yaml --all-dependencies -s -v github.com/go-redis/redis#5.0.0 # --all-dependencies会更新subpackages update # 下载和更新glide.yaml中的所有依赖，放到vendor下 # 递归更新 install # 依据glide.lock与glide.yaml文件安装特定版本 # glide.lock与glide.yaml不同步时，发出警告 up # 更新依赖树，重建glide.lock文件 name # 查看glide.yaml中依赖名称 list # 依赖列表 help --version glide.yaml package: . import: - package: github.com/go-redis/redis version: 5.0.0 repo:git@github.com:go-redis/redis 常见问题 o-\u0026gt; cannot detect vcs glide.lock或vendor依赖旧版本 清理glide.lock和vendor, 检查glide.yaml旧版本 glide.yaml子目录处理不完善 subpackages: - cloudsql glide mirror找不到包 glide mirror set a a --vcs git # 改~/.glide/mirrors.yaml文件 o-\u0026gt; does not appear to be a git repository 加速服务没有项目 o-\u0026gt; glide up依赖不是最新 ~/.glide/cache中缓存了旧版本 o-\u0026gt; cannot find package \u0026quot;.\u0026quot; in glide对非git协议自有域名处理歧义，子目录分析不准确 清理缓存 ~/.glide/cache/src/包名 ~/.glide/cache/info/包名 glide.yaml添加repo重定向及subpackages package: github.com/grpc-ecosystem/grpc-gateway repo: git@github.com:grpc-ecosystem/grpc-gateway.git subpackages: - internal govendor # 介绍 包管理 使用 go get -u -v github.com/kardianos/govendor godev # # 依赖管理 gv # # 依赖管理 gvt # # 依赖管理 gvm # # 版本管理 命令 gvm install go1.5 use go1.5 list listall implode # 删除所有go版本和gvm本身 gore # # repl go-torch # # 性能火焰图 go-torch -b cpu.prof gf # -v/version -h/help init build gen # 生成模块 gen dao run swagger pack get docker mod update 语法 # 包 # 路径引用，命名空间 不能循环依赖 main包 # 入口包, 产生可执行文件，也可当库导入 main() # 入口函数 包名最好匹配目录名 # 导入路径的最后一段 import 逐行import或import(多行) import 别名 包路径 import \u0026quot;gopkg.in/yaml.v2\u0026quot; 忽略.v2, 包名为yaml import _ \u0026quot;image/png\u0026quot; 空导入 可导入相对目录，以.或..开头 var和const 逐行或var(多行), const(多行) 包文件函数 init # 文件在编译前排序，按依赖顺序和文件名，也是init的调用顺序。init不能调用和引用 包依赖排序依次初始化 工作空间 src bin # 编译后的执行文件 pkg # 编译后的包, 重复使用加快编译 vendor目录放本地依赖 文档注释影响编译 // +build linux darwin # linux和darwin才编译 // +build ignore # 任何时候都不编译 内部包 # 路径有internal的包, 只能被父目录导入 net/http/internal/chunked 注释 //或/**/ package前写文档注释，可出现在任何文件中，但一个包约定一个 doc.go约定为包的扩展文档注释 命名 字母或下划线开头，区分大小写, 不能用关键字 关键字: break, default, func, interface, select, case, defer, go, map, struct, chan, else goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return, var 首字母大小写决定可见性，大写表示其是导出的 go倾向短名称, 驼峰式命名, 缩写全大写或小写 操作符 优先级: * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ # 可加=, 如*= + - | ^ # 可加=, 如*= == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= # 基本类型都可比较 \u0026amp;\u0026amp; || + - # 一元取正负 % # 只能整数，符号与被除数一致 / # 整数除，去小数部分。溢出高位丢弃 \u0026amp; | ^ \u0026amp;^ # 按位独立 \u0026amp;^ # and not(位清空)右边1清左边为0 \u0026amp; # and | # or ^ # xor, 前缀表示取反或按位取补(逐位取反) \u0026lt;\u0026lt; \u0026gt;\u0026gt; # 注意，有符号数右移按符号位填补空位 声明定义 不能有无用的声明变量 var s string # 未初始化值默认零值，类型和表达式可省一个 var s string = \u0026quot;\u0026quot; # 不推荐 var s = \u0026quot;\u0026quot; # 不推荐 s := \u0026quot;\u0026quot; # 短变量声明 var i,j int # 自动引申变量类型 i, j := 0, 1 i, j := true, \u0026quot;a\u0026quot; # 类型可不一致 i, err := 0, e # err声明过(只检测本词法块，外层不算)，声明i, 赋值err。:=要求至少一个声明 const # 编译时计算 枚举 type Weekday int const ( Sunday Weekday = iota # 值为0 Monday ... ) const ( i T1 = 1 \u0026lt;\u0026lt; iota # 值为1, 下值为 1\u0026lt;\u0026lt;1 ... ) 无类型常量 只有常量可以无类型 无类型常量存大数精度高于基本类型, 算术精度高于机器精度, 至少256位 可用于更多表达式，无需转换类型 分类 布尔: true 整数: 0 文字符号: '\\u0000' 浮点数: 0.0 复数: 0i 字符串: \u0026quot;\u0026quot; const ( _ = 1 \u0026lt;\u0026lt; (10 * iota) # 下值为 1\u0026lt;\u0026lt;(10*1) ... ) type # 类型声明 type A int # 底层共类型, 可赋值性，可比较性。可重写String方法让fmt打印时个性化 a = A(i) # 可赋值就可类型转换 func 变量生命周期 包级别是整个程序执行时间 局部变量声明时创建，直到不可访问 堆栈 逃逸变量(函数外保存地址)在堆，局部变量在栈 # 与变量创建方式无关(new与否), 逃逸需要一次额外内存分配。 赋值 x = 1 *p = 1 p.name = \u0026quot;\u0026quot; m[key] = 1 += i++和i-- # 只能自成一行, 且不能++i, --i _ # 忽略变量 a, b = b, a # 多重赋值 v, err = f() v, ok = m[key] # map查询 v, ok = x.(T) # 类型断言 v, ok = \u0026lt;-ch # 通道接收 可赋值性：类型精准匹配，nil赋值任何接口变量或引用变量, 常量更易隐式转换赋值 ==和!= 比较，两边要求是可赋值的 指针 # 不能运算 \u0026amp;获取地址 *获取指针 语句 变长参数 f(s...) for for i, j := 0, 1; i \u0026lt; n; i++ {} for i \u0026lt; n {} for {} for index, value := range slice1{} for key, value := range map1 {} for range s{} if if i \u0026lt; n {} else if i \u0026lt; m {} else {} if err := f(); err != nil {} switch switch { # 无标签(tagless), 相当于switch true, case x \u0026gt; 0: # fallthrough可贯穿, 可用控制流标签 } switch i := 0 {} # switch true switch i++ { } # switch true switch f() {} # switch true switch i { case 0: case 1: default: # default可在任何地方 } switch t.(type) { # 类型匹配, 无匹配类型会panic, 不能用fallthrough case nil: case int, uint; case bool: case string: default: } switch x := x.(type) {} select # channel用select, 值用switch。一直等待直到匹配(default会直接匹配)。多情况匹配随机选择。不能用fallthrough select { case \u0026lt;-ch1: case x := \u0026lt;-ch2: case ch3 \u0026lt;- y: default: } o-\u0026gt; 超时 select { case \u0026lt;-time.After(10*time.Second): case \u0026lt;-ch: } o-\u0026gt; 自发自接 for i := 0; i \u0026lt; 10; i++{ select { case x := \u0026lt;-ch: case ch \u0026lt;- i: } } o-\u0026gt; 标签 c := make(chan struct{},2) label1: for { select { case c\u0026lt;- struct{}{}: fmt.Println(1) case \u0026lt;-c: fmt.Println(2) break # 无标签break跳出当前select块 # break label # goto label2 # return default: fmt.Println(3) } } label2: ... 控制流标签 break, continue, goto # 可标签化, 如break Label1 作用域 词法块：语法块(block)(大括号), 隐式块(未在大括号中的声明, 如if中) 全局块 # 内置 包级别 # 函数外的声明 文件级别 # 导入的包 局部 控制流标签作用域是外层函数 覆盖 x := 1 for { x := x+1 if .. { x := x+1 # 这里值的x是最外层x } } if声明的变量(隐式词法块)，else中可见 if v, err := f(); err != nil { # else中处理非err逻辑 return err } else { v.close() } 包中声明作用域无顺序，可递归 # 常量、变量不可以引用自己 函数 字面量 var func() # 声明 func f(i int) int {} func f(i, j int) (int, error){} func f() (r int){} func f(vals ...int) {} # 变长函数, 只放最后, vals是slice f(vals...) 一等公民 函数签名，即函数类型，包括形参列表和返回列表, 命名不影响 未定义时为nil, 不可比较 值传递, 不能指定默认值 函数返回多值, 可return, 可做传入参数 返回值有命名，可祼返回(不在return后写参数) 错误 v, ok := f() # 错误只一种情况 v, err := f() # 错误信息会串联，避免首字母大写和换行 if err != nil { return nil, err } 匿名函数用字面量定义，包含外层词法环境(闭包) 递归要先声明，再赋值定义 重定义变量 for _, dir := range dirs() { dir := dir # for块作用域变量共享位置，重定义dir每次一个位置 dirs = append(dirs, func(){ # 匿名函数引用外层变量，却不一定同步执行 os.RemoveAll(dir) }) } 方法 字面量 func (t T) f(){} # t值传递, 方法名唯一, 方法名不能用字段名 func (t *T) f(){} # t引用传递 type Path []Point # 别名赋方法(不能是指针和接口), 可覆盖原类型方法 func (p *Path)f(){} 方法可在任何类型(除指针和接口), 如函数 变量与变量指针都可直接调方法，编译器隐式取地址或取指针 P{1}.f() # 编译器不报错但运行出错, f()声明成引用传递, 但P{1}.时, 内存地址还未分配, 即还没有*P, 就无法调f() 有引用传递方法时，避免值传递方法，会产生多例 值为nil时可调方法 方法可赋值 f := t.f f(t.f) 组合 结构体匿名成员方法可如属性般直接调用 匿名成员是引用时，多结构体可组合同一成员对象 多匿名成员方法冲突时，调用时编译报错 可给未命名结构体加方法 t = struct{ sync.Mutex v int } t.Lock(); t.v++; t.Unlock() 接口 字面量 type I interface { f() } type I2 interface { # 接口组合 I } v := t.(T) # 断言，失败panic v, ok := t.(T) # 失败不panic, ok=false 隐式实现，方法匹配即可(接口即约定) # 鸭子 指针方法匹配接口，对接口赋值时要传指针 interface{}为空接口类型，可赋值任何类型 实现 除了接口的定义类型，还包含动态类型(Type) + 动态值(Value) # 编译时不知道，生成代码在运行时动态分发 零值，是动态类型和动态值都是nil 动态类型是nil, 指的是它为接口本身类型 i = nil会设置接口为零值 ==和!=比较 动态值都为nil相等 动态类型和动态值都相等，才相等 i = new(T); i != nil 动态类型一致，动态值不可比较(如slice), 则panic # 非平凡 格式化输出%T拿到动态类型 断言 变定义类型, 动态类型和动态值不变 空接口断言总失败 断言成接口，使用公共功能 v := t.(I) v.Common() 风格 强调功能相似性 # 子类型多态(subtype polymorphism) 联合再断言区分 # 可识别联合(discriminated union), 特设多态(ad hoc polymorhpism) switch t.(type) {} 关键字 defer fn # 后进先出, return或panic后调用 defer func(i){...}(1) return、出参赋值、defer顺序 # 先赋值，再defer，再return func f() (i int) { defer func(){ i++ } return 0 # 相当于 i=0; i++; return } go fn 异常 panic() 日志包括值(interface{}), 调用栈 用interface{}自定义异常类型 runtime.Stack()查看栈，利用defer函数在栈清理前调用, 所以栈存在 终止当前goroutine, 外层goroutine不捕获 按函数调用栈依次中止函数并调defer, 最上层后程序异常退出 panic之后定义的defer不执行(声明不提前) recover() 中止panic 在defer中(panic时只调defer)捕获panic对象，没有时为nil 捕获panic对象后, 捕获函数正常返回。要上抛就再手动panic() o-\u0026gt; func Try(fn func(), handler func(interface{})) { defer func() { if err := recover(); err != nil { handler(err) } }() fn() } func main() {／ Try(func() { panic(\u0026quot;a\u0026quot;) }, func(e interface{}) { print(e) }) } 内置 # 零值 # 保障变量良好定义，没有未初始化变量 数字0, 布尔false, 字符串\u0026quot;\u0026quot; 接口和引用类型(slice, 指针, map, channel, 函数)nil 复合类型其所有元素或成员零值 常量 true false iota nil 比较 var s []int # 未初始化比较, ==nil s = []int(nil) # 强转, ==nil s = []int{} # 初始化比较, !=nil 基本类型 字面量 06 # 8进制 0x0a # 16进制 .1或1. # 小数点前后可省略 2.2e10 # 科学计数法 1 + 2i # 复数 字符串 \u0026quot;\\\\\u0026quot; # 转义 \u0026quot;\\r\u0026quot; # 光标退到行首 \u0026quot;\\b\u0026quot; # 光标退一字符 \u0026quot;\\x1a\u0026quot; # 16进制表示位数据, 必2位，无法识别成unicode \u0026quot;\\212\u0026quot; # 8进制表示位数据, 必3位, 无法识别成unicode \u0026quot;\\u1234\u0026quot; # unicode, 16进制数字, 共4x4=16位 \u0026quot;\\u12345678\u0026quot; # unicode, 16进制数字, 共4x8=32位 `` # 原生字符串, 回车被删除(换行符保留) 注意 会自动截断，如int i=127; i+1=-128; i*i=1 int # 平台原生整数大小，或该平台运算效率最高值, 多是int32 int8 # -128-127 int16 int32 int64 uint # 平台决定大小。无符号极少用于表示非负值，往往用于位运算或特定算术运算符，如位集，解析二进制，散列，加密 uint8 # 0-255 uint16 uint32 uint64 uintptr # 存放指针，大小不明确，底层编程 float32 # 运算会迅速累积误差, 正整数范围有限 float64 complex64 # float32构成 complex128 # float64构成 var x complex128 = complex(1,2) x := 1 + 2i bool byte # uint8别名, 强调是原始数据 rune # int32别名, unicode码点(UTF-8), 下标取字符(非字节) string # 认为是UTF-8编码的unicode, 不合理字节替换成方块(\\uFFFD)。不可变(安全截取、共用), 下标取字节，越界宕机异常 和数组和slice一样操作 []byte和string元素操作一致，只类型不同 互换 []byte, []rune, string # 转换产生副本 error 聚合类型 数组 字面量 var q [3]int q := [3]int{1,2,3} q := [...]int{1,2,3} # 长度由元素个数决定 q := [...]int{0: 1, 3:2} # 指定索引元素值 数组是值传递 数组元素不可包含自己 默认元素为零值 不同长度不同类型，不能赋值 如果元素可比较，数组就可比较 # 深度比较 q1 \u0026lt; q2 # 字符串比较按字节字典排序 slice 字面量 q := []int{1,2,3} # 这里创建了slice, 指向了隐式创建的数组 q[0:1] # 左闭右开 q[:1]; q[1:]; q[:] 轻量级数据结构，用来访问数组的部分 零值是nil, 行为和slice一样，不用特殊判断 slice后标访问越界时，会自动扩展，越界超过数组长度+1时，会panic append(arr[:i], arr[i+1:]...)删除元素, i为最后元素时, i+1不越界 不可比较, 只有写函数实现。只能和nil比较 因为slice的元素不是直接的 有可能包含它自身 同slice不同时间会拥有不同元素 如果slice可比较来做map键, map只对key做浅拷贝, slice需要深度比较, 所以要求slice元素不变 三元素 # 有自己的属性，不是纯引用类型，是聚合类型 指针: 指向slice在数组上起始位置 长度: slice长度 容量: 指针到数组结尾元素个数 map # key可nil, 取不存在key时, 得到value类型的零值。随机无序遍历 字面量 m := map[string]int{ \u0026quot;a\u0026quot;:1, } a[\u0026quot;b\u0026quot;]=2 不能获得地址，如\u0026amp;m[\u0026quot;a\u0026quot;] # 因为map增长时，已有元素可能重新散列 迭代顺序随机 # key用维护排序, 散列算法健壮 零值是nil, 向nil map设置元素会panic map[key1]没有时，获得零值 v, ok := m[\u0026quot;a\u0026quot;] # 判断有无key 不可比较，只能和nil比较 key要求可比较，可以数组,不可以slice,可以自己映射成可比较类型 q := [2]int{} m := map[[2]int]int{} m[q] = 1 结构体 字面量 type T struct { # 结构体, Name string `json:\u0026quot;name0,omitempty\u0026quot;` # 成员标签定义, opmitempty在零值时忽略 I1, I2 int } t := \u0026amp;T{\u0026quot;a\u0026quot;} # 顺序易出错, 用于明显的小结构。未指定成员为零值 t := \u0026amp;T{ Name: \u0026quot;a\u0026quot;, } (*t).Name = \u0026quot;a\u0026quot; t.Name = \u0026quot;a\u0026quot; # .可以用于指针 struct{} # 空结构体，没有长度，无信息。 type T1 struct{ # 匿名成员 T T2 *T3 Name1 string } t1 := T1{ T: { Name: \u0026quot;a\u0026quot; } } 首字母大写可导出 属性类型不可自己，但可自己指针 结构体零值由成员零值组成 # 希望结构体方法中处理零值成一个自然的值，如sync.Mutex 成员可比较，结构体实例可比较, 可作map key 匿名成员(组合) 点号访问可跨入(语法糖)，访问匿名成员属性和方法 t1.Name; t1.T.Name 不能有相同类型的匿名成员 不可导出类型的匿名成员，内部成员不影响，但匿名成员本身不可见 引用类型 Type IntegerType FloatType ComplexType chan ch := make(chan string) var cin chan\u0026lt;- string var cout \u0026lt;-chan string ch \u0026lt;- \u0026quot;\u0026quot; \u0026lt;-ch 接口类型 error Error() 命名类型 type 结构体 type Point struct { X, Y int } 函数 make() make([]int) make(map[string]int) make(chan int) delete() delete(m, \u0026quot;a\u0026quot;) # 删除map元素, 没key不报错返回零值 len() len(ch) # 当前缓冲个数 cap() cap(ch) # 缓冲区容量 new() # 创建指定类型变量，初始化为零值，返回地址。不带任何信息且是零值(struct{}和[0]int)的类型, new出的地址不同(从前相同) t := new(T) append() # 操作slice 先检查原容量，容量够修改原数组元素，不够创建新数组(容量扩一倍)复制元素, 返回新slice 所以append()最好赋值给原slice s1 := append(s1, s2...) copy() # slice或string元素复制 close() # channel中用 complex() # 创建复数对象 real() # 获取复数的实部 imag() # 获取复数的虚部 panic() recover() 反射 谨慎使用 脆弱，能导致编译报错的写法，反射中都对应panic，执行时才知道 降低自动重构和分析工具的安全性与准确度，反射对类型操作无法静态检查 反射慢1-2个数量级(实测20位左右), 适合测试用，不适合关键路径上用 unsafe 值在内存中对齐，计算更高效。结构体用内存间隙来对齐，占空间比元素之和更大 结构体成员内存中重新排列可省内存，但目前不是 cgo o-\u0026gt; c文件 #include \u0026lt;bzlib.h\u0026gt; int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen) {...} o-\u0026gt; go文件 /* #cgo CFLAGS: -I/usr/include #cgo LDFLAGS: -L/usr/lib -lbz2 #include \u0026lt;bzlib.h\u0026gt; int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen); */ import \u0026quot;C\u0026quot; import ( \u0026quot;io\u0026quot; \u0026quot;unsafe\u0026quot; ) type writer struct { w io.Writer stream *C.bz_stream outbuf [64*1024]byte } func NewWriter(out io.Writer) io.WriteCloser{ const ( blockSize = 9 verbosity = 0 workFactor = 30 ) w := \u0026amp;writer{w: out, stream: C.bz2alloc()} C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor) return w } func (w *writer) Write(data []byte) (int, erro) { if w.stream == nil { panic(\u0026quot;closed\u0026quot;) } var total int for len(data) \u0026gt; 0 { inlen, outlen := C.uint(len(data)), C.uint(cap(w.outbuf)) C.bz2compress(w.stream, C.BZ_RUN, (*C.char)(unsafe.Pointer(\u0026amp;data[0])), \u0026amp;inlen, (*C.char)(unsafe.Pointer(\u0026amp;w.outbuf)), \u0026amp;outlen) total += int(inlen) data = data[inlen:] if _, err := w.w.Write(w.outbuf[:outlen]); err != nil { return total, err } } return total, nil } 注释 #cgo 指令指定C工具链选项 import \u0026quot;c\u0026quot; 编译时促使go build用cgo预处理其上注释 产生临时包包含c函数对应声明 包含类型，函数，预处理宏对象 这里用了C.bz_stream和C.BZ2_bzCompressInit go也可编译成静态库链接进C, 或编译成动态库通过C加载和共享 内部包 # # golang.org/pkg 找到索引 errors New() testing T Error() Errorf() Fatal() Fatalf() B syscall # 执行其它语言 syscall/js js/wasm # 1.11, webAssembly go/doc go/token runtime Stack() # 调用栈 Gosched() # 让出执行权 Goexit() # 终止当前goroutine, 会执行defer LockOSThread() # 绑定协程到当前线程 UnlockOSThread() GOMAXPROCS() # 并发线程数 NumGoroutine() # 限制goroutine数 runtime/debug os Stdin # 输入流 Args # 运行参数 FileInfo Open() # 打开文件 File Read() Write() Close() Exit(1) # 1异常退出 RemoveAll() Stat() # 文件信息 os/exec # 子进程 io EOF # 文件结束标志, 是一个error Copy() WriteString() io/ioutil Discard # 丢弃 ReadFile() # 读整个文件到内存 ReadAll() WriteFile() ReadDir() bufio # 带缓冲io NewScanner() Scanner # 以行或单词断开 Scan() # 有内容返回true Text() NewReader() ReadRune() path # 文件路径 Base() # 获得最后文件名 path/filepath # 根据平台处理文件路径 net Conn net/http poolServer(epoll/kqueue/iocp) # 支持多核大量并发连接fd Get() Header Get() Body Close() HandleFunc() ResponseWriter Request RemoteAddr # 客户ip:端口 Host Method Proto # 网络协议 Header Form # 先ParseForm() URL Path ParseForm() ListenAndServe() net/http/httputil net/url QueryEscape() # url转义 context # 线程安全, 树形结构 Cancel() Deadline(Timeout) Value() TODO() o-\u0026gt; ctx.Done() func f(ctx context.Context) (error) { errc := make(chan error, 1) go func() { defer close(errc) time.Sleep(2 * time.Second) errc \u0026lt;- nil }() select { case \u0026lt;-ctx.Done(): \u0026lt;-errc return ctx.Err() case err := \u0026lt;-errc: return err } } o-\u0026gt; WithTimeout ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second) # 调cancel提前结束 defer cancel() return f(ctx) flag Args # 非标识参数 Parse() # 出错调os.Exit(2) o-\u0026gt; 输入'-s / a bc', 输出'a/bc' sep := flag.Strings(\u0026quot;s\u0026quot;, \u0026quot; \u0026quot;, \u0026quot;desc s\u0026quot;) flag.Parse() println(strings.Join(flag.Args(), *sep)) log SetPrefix() SetFlags() # 格式标记 Fatal() # 加日期时间前缀 Fatalf() time Time Format() Now() Since() Seconds() After() AfterFunc() NewTicker() ticker := time.NewTicker(1 * time.Second) \u0026lt;- ticker.C ticker.Stop() Tick() tick := time.Tick(1 * time.Second) # 无法中止, 用于全局，否则内部goroutine泄漏 for { \u0026lt;-tick } fmt # string类型会调对象的String()方法 Stringer # 接口，有String()方法可匹配 Printf() # 可以用转义序列(\\t等)表示不可见字符 %d # 十进制整数 %x, %o, %b # 十六进制、八进制、二进制整数 %X % x # 十六进制输出，两数一空格 %f, %g, %e # 浮点数6位小数、15位小数并自动精度与表示方式、6位小数e表示 \u0026quot;%8.3f\u0026quot; # 输出8字符宽度，保留3位小数 %t # 布尔 %c # unicode字符 %s # 字符串 %*s # 缩进后面指定数字个空格 %q # 带引号字符串(\u0026quot;abc\u0026quot;)，或字符('c') %v # 内置格式的任何值 %#v # 包含结构体成员名字 %T # 类型 %[1]c # 重复利用第一个参数 Printf(\u0026quot;%d %[1]c %[1]q\u0026quot;, 'a') %% # %本身 特殊数字 var z float64 fmt.Println(z,-z,1/z,-1/z,z/z) # \u0026quot;0 -0 +Inf -Inf NaN\u0026quot; Fprintf() Scanf() # 格式化输入 Errorf() # 产生一个error strconv # 类型转换 ParseFloat() ParseInt() ParseUint() Itoa() # 整数转字符串 FormatInt(int64(1a), 2) FormatUint() unicode # 单符号 ToUpper() ToLower() IsDigit() IsLetter() unicode/utf8 # 逐个处理 RuneCountInString() # 字符数 DecodeRuneInString() # 解码, string类型默认调用 bytes # 操作byte数组 Buffer WriteByte() WriteRune() WriteString() String() Index() Contains() Count() Fields() HasPrefix() Join() Equal() strings # 处理UTF-8或位序列 Index() Split() HasPrefix() HasSuffix() Contains() Count() Fields() Join() regexp MustCompile() # 检查 Compile() # 编译表达式 text/template Must() # 检查，有错panic o-\u0026gt; {{.Name}} # .代表当前值 {{range .Items}} {{.Title | printf \u0026quot;%.64s\u0026quot;}} {{.CreateAt | daysAgo}} {{end}} template.New(\u0026quot;report\u0026quot;). Funcs(template.FuncMap{\u0026quot;daysAgo\u0026quot;: daysAgo}). Parse(templ) text/tabwriter # 生成表格 Flush() html/template # 对html, js, css, url中原字符转义, 避免对输出页面注入控制 Html # 字符串转成该类型，受信任，不用转义 Parse() # 解析html encoding/json # unicode Marshal() # 转成json, 不可导出不可见 MarshalIndent() # 格式化转成json Unmarshal() NewDecoder() # 流式解码 Decode() encoding/xml encoding/gob encoding/asn1 compress/gzip # DEFLATE算法 NewWriter() NewReader() compress/bzip2 # Burrows-Wheeler变换, 压缩高，慢 sort IntSlice sort.Sort(sort.IntSlice(ints)) Sort() Reverse() sort.Sort(sort.Reverse(values)) IsSorted() Strings() Ints() IntsAreSorted() o-\u0026gt; type StringSlice []string func (p StringSlice) Len()int {return len(p)} func (p StringSlice) Less(i, j int)bool {return p[i] \u0026lt; p[j]} func (p StringSlice) Swap(i, j int) {p[i], p[j] = p[j], p[i]} sort.Sort(StringSlice(names)) math Sin() NaN() # 返回NaN, NaN值比较总false(除!=), NaN用作信号量 math/rand Seed(time.Now().UTC().UnixNano()) Float64() math/cmplx # 复数运算 Sqrt(-1) # 0 + 1i math/bits image Rect() NewPaletted() SetColorIndex() Decode() Encode() image/color Color White Black image/gif GIF image/jpeg # 空导入注册解码器 image/png # 空导入注册解码器 sync Mutex Lock() Unlock() RWMutex Lock() Unlock() RLock() RUnlock() Once # 单例资源初始化，解决了多线程下读检查，防重写的问题 Do() WaitGroup Cond Wait() # 计数加1, 进入阻塞 Signal() # 解除一个阻塞，计数减1 Broadcast() # 解除所有阻塞 Map Pool reflect # 非导出字段反射可见, 不可更新 Type # 类型 String() # 类型描述, fmt.Printf()中的\u0026quot;%T\u0026quot; 内部调用 Field() # 结构体成员, 返回StructField Name Method() Value # 值 String() # 值描述，如\u0026quot;\u0026lt;int Value\u0026gt;\u0026quot; Type() Interface() # 返回接口具体值 x := v.Interface() i := x.(int) Kind() # 得到类型，Bool, String, 各种数字, Array, Struct, Chan, Func, Ptr, Slice, Map, Interface, Invalid(零值), Func Index() # 数组 NumField() # 结构体成员数 FieldByName() MapKeys() # map MapIndex() # map IsValid() IsNil() # 指针 Elem() # 指针指向元素 CanAddr() # 是否可寻址，如指针元素取Elem()的值，数组元素 Addr() # 取地址 v.Addr().Interface().(*int) CanSet() # 检查CanAddr()和是否非导出字段 Set() # 要求可寻址, 类型一致。可Set()interface{}类型 SetInt(), SetUint(), SetString(), SetFloat() # 相对Set()有容错性,不可SetXx()interface{}类型 SetMapIndex() NumMethod() # 方法数 Method() # 取方法 Name Call() # 执行Func类型Value StructField Tag StructTag Get() # 字段标签中key的值 Method TypeOf() ValueOf() Zero() # 零值 Append() MakeMap() New() # 类型新对象地址 DeepEqual() # 深度比较，基本类型用==, 组合类型逐层比较。 判断武断，不认为值为nil的map和值不为nil的空map相等。slice同理 var c, d map[string]int = nil, make(map[string]int) var a, b []string = nil, []string{} unsafe # 由编译器实现，暴露了内存布局。 Pointer # 任何地址，可比较，可比较nil。无类型向内存写任意值。 可转成uintptr对地址计算 问题 移动垃圾回收器(目前未用)在移变量时地址改变使地址出错。 goroutine增长栈时旧栈地址重新分配 解决 Pointer转uintptr再转回来在一条语句中实现 应用 深度比较时，防止循环引用，每次比较存两个抽象的指针(即Pointer)和类型(y和y[0]地址一样) var f float64 i := *(*uint64)unsafe.Pointer(\u0026amp;f) Sizeof() # 表达式占字节长度, 不计算表达式，由编译器推断 Alignof # 报告类型对齐方式 Offsetof() # 成员相对起始偏移量, 计算空位 外部包 # # godoc.org 搜索 goimports # 格式化imports顺序 测试 # 规则 文件名以_test.go结尾 汇报PASS或FAIL, 平均执行时间 忽略main函数, 当作库测试 main特权函数 log.Fatal()和os.Exit()会阻止跟踪过程 包测试循环依赖时，建立外部测试包 导出内部成员用于测试的后门成员声明，放在export_test.go内 机制 扫描*_test.go 生成临时main包来调用，再编译、运行、汇报, 最后清空临时文件 Test函数 # t用于汇报结果和日志 func TestF(t *testing.T) {} benchmark函数 # 基准测试，性能 b增加了成员N指定执行次数, 增加了性能检测方法 开始指定小N, 再推断足够大的N检测稳定运行时间 基准测试时初始化代码放循环外面，它的执行时间不加到每次迭代时间中。普通Test做不到 用go test -bench=.运行 报告中 f-8 1000000 1035 ns/op 分别代表GOMAXPROCS=8, 执行100000次，平均每次1035ns o-\u0026gt; 基本使用 func BenchmarkF(b *testing.B) { for i := 0; i \u0026lt; b.N; i++{ f() } } o-\u0026gt; 相对比较, 如数量级、找最佳缓冲区大小、选算法策略 func benchmark(b *testing.B, size int){} func Benchmark10(b *testing.B) {benchmark(b, 10)} func Benchmark100(b *testing.B) {benchmark(b, 100)} Example函数 # 示例，无参无结果。 用处 可举例子作为文档 结尾注释 // output: 验证终端输出 实验代码 func ExampleF() { fmt.Print(\u0026quot;a\u0026quot;) // output: aa } 并发编程 # 同步 func channel # 和调度器深度关联，控制goroutine的阻塞和唤醒 缓冲区 作用 异步 发送接收解耦 让数据可并行处理(计数信号量) 消除goroutine间速率差异(速率大致相同, 某刻休息) 上下游速率差异大时无作用 阻塞时同步 c := make(chan struct{}) c1 := make(chan struct{}, 1) c ← struct{}{} # 阻塞 ← c # 阻塞 c1 ← struct{}{} # 不阻塞 c1 ← struct{}{} # 阻塞 ← c1 # 不阻塞 ← c1 # 阻塞 方向 var c chan struct{} # in和out var cin \u0026lt;-chan struct{} # in, 关闭时panic v := \u0026lt;-cin var cout chan\u0026lt;- struct{} # out cout \u0026lt;- v cin = c cout = c c = cin # 编译错误 c = cout # 编译错误 nil # 永远阻塞, 用于开启禁用情况 var c chan struct{} c \u0026lt;- struct{}{} # 阻塞 关闭 # 关闭不是必须的，不影响回收。只是用来通知和广播 c := make(chan struct{}) close(c) # 再关闭panic c ← struct{}{} # panic o, ok := ← c # o得到零值, ok是false for range c := make(chan struct{}) ... for x := range c {} # close(c)时break select sync包 sync/atomic包 o-\u0026gt; 并发三个业务, 一起结束 cond := sync.NewCond(new(sync.Mutex)) wg := sync.WaitGroup{} wg.Add(3) wg1 := sync.WaitGroup{} wg1.Add(3) for i := 0; i \u0026lt; 3; i++ { go func(i int) { defer wg1.Done() cond.L.Lock() fmt.Println(\u0026quot;wait\u0026quot;, i) # 业务预处理 wg.Done() cond.Wait() # 阻塞 fmt.Println(\u0026quot;done\u0026quot;, i) # 业务后续处理(要求所有业务预处理过) cond.L.Unlock() }(i) } wg.Wait() # 业务预处理完成 cond.L.Lock() cond.Broadcast() # 处理业务后续 cond.L.Unlock() wg1.Wait() # goroutine完成 异步 语句 语句是串行一致的(sequentially consistent) 串行一致基础上，语句会重排, 重排中可能穿插执行其它goroutine语句 t := map[string]int{ \u0026quot;a\u0026quot;: 1 \u0026quot;b\u0026quot;: 2 } 重排为 t := make(map[string]int) t[\u0026quot;a\u0026quot;]=1 t[\u0026quot;b\u0026quot;]=2 goroutine 语句 go f() 泄漏 阻塞不能自动结束 # 如操作channel时 main中最后调panic(), 从崩溃转储信息判断资源释放情况 死锁(deadlock) # 指没有可调度的goroutine 所有goroutine阻塞或没有goroutine 运行main的是主goroutine, main返回所有goroutine暴力终结 无id(标识) 不能中断 无返回值 runtime context time 并发模式 # 避免goroutine泄漏，保证通信顺序 done/quit o-\u0026gt; done控制goroutine退出。 # 更快的响应要写更多的逻辑入侵，找到响应慢点写done逻辑 func f(done \u0026lt;-chan struct{}) { select { case \u0026lt;-done: for range ch{ # 耗尽通道, 其它goroutine不会卡在ch\u0026lt;-上而退出 } return } } func cancelled()bool{ select { case \u0026lt;-done: return true default: return false } } func f2(){ # 轮循函数中入口检查, 避免创建新goroutine if cancelled() { return } } done := make(chan struct{}) defer close(done) f(done) channels of channels o-\u0026gt; 循环处理请求 func handle(reqs chan chan interface{}) { for req := range reqs { req \u0026lt;- 0 } } func server(req chan interface{}) { reqs := make(chan chan interface{}) defer close(reqs) go handle(reqs) reqs \u0026lt;- req } func client() interface{} { req := make(chan interface{}) defer close(req) go server(req) return \u0026lt;-req } fmt.Println(client()) o-\u0026gt; 循环异常退出 type S struct { closing chan chan error } func (s *S) close() error { errc := make(chan error) s.closing \u0026lt;- errc return \u0026lt;-errc } func (s *S) loop() { for { select { case errc := \u0026lt;-s.closing: errc \u0026lt;- nil return } } } pipeline(fan-in, fan-out) # 传入传出channel来处理 o-\u0026gt; func gen(done \u0026lt;-chan struct{}, nums ...int) \u0026lt;-chan int { out := make(chan int) go func() { defer close(out) for _, n := range nums { select { case out \u0026lt;- n: case \u0026lt;-done: return } } }() return out } func sq(done \u0026lt;-chan struct{}, in \u0026lt;-chan int) \u0026lt;-chan int { out := make(chan int) go func() { defer close(out) for n := range in { select { case out \u0026lt;- n * n: case \u0026lt;-done: return } } }() return out } func merge(done \u0026lt;-chan struct{}, cs ...\u0026lt;-chan int) \u0026lt;-chan int { # wg等cs数目个协程合并数据到out后，关闭out var wg sync.WaitGroup out := make(chan int) output := func(c \u0026lt;-chan int) { for n := range c { select { case out \u0026lt;- n: case \u0026lt;-done: } } wg.Done() } wg.Add(len(cs)) for _, c := range cs { go output(c) } go func() { wg.Wait() close(out) }() return out } func main() { done := make(chan struct{}) defer close(done) for n := range sq(done, sq(done, gen(done, 2, 3))) { # gen产生维护数字chan, sq产生维护平方chan。三个chan # 三个goroutine done()时return, chan return时close() fmt.Println(n) } // 扇出 in := gen(done, 2, 3) c1 := sq(done, in) c2 := sq(done, in) // 扇进 for n := range merge(done, c1, c2) { fmt.Println(n) } } timeout select { case \u0026lt;-ch: ... case \u0026lt;-time.After(time.Second) return } 控制并发数 并发写缓冲区channel for循环产生并发数goroutine 常用 中断 # os.Exit()程序返回错误码 done := make(chan struct{}) go func() { defer close(done) c := make(chan os.Signal, 1) defer close(c) signal.Notify(c, os.Interrupt, os.Kill) defer signal.Stop(c) \u0026lt;-c }() 并发压测 func concurrent(done chan struct{}, fn func(), num int, ccu int, qps int) { # num总数，ccu并行数，qps并发数 interval := time.Duration(1e9/qps) * time.Nanosecond don := make(chan struct{}, 2) go func() { \u0026lt;-done for i := 0; i \u0026lt; ccu; i++ { don \u0026lt;- struct{}{} } }() // tasks := make(chan struct{}) go func() { var wg sync.WaitGroup wg.Add(num) for i := 0; i \u0026lt; num; i++ { tasks \u0026lt;- struct{}{} wg.Done() time.Sleep(interval) } wg.Wait() close(tasks) }() // var wg sync.WaitGroup wg.Add(ccu) for i := 0; i \u0026lt; ccu; i++ { go func() { defer wg.Done() for range tasks { select { case \u0026lt;-don: return default: fn() } } }() } wg.Wait() } m := sync.Mutex{} count := 0 do := func(){ m.Lock() count++ m.Unlock() } concurrent(done, do, 999, 100, 1e3) "},{"id":60,"href":"/docs/pl/python/","title":"Python","section":"程序语言","content":" 介绍 # 虚拟机语言 虽然是脚本语言，可以预编译成pyc文件来执行 shell # #! /usr/bin/python # -*- coding: utf8 -*- 语法 # 规范 pep8 内置函数 # o-\u0026gt; input(\u0026quot;\u0026quot;) # x = int(input(\u0026quot;Please enter an integer:\u0026quot;)) print(\u0026quot;%s\u0026quot;, % s1) ## %.3s % (\u0026quot;abcdef\u0026quot;)取3字符 ## %.* s % (2, \u0026quot;abcd\u0026quot;)取2字符) # %r repr()显示字符串 # %c 单个字符 # %b 二进制整数 # %x 十六进制整数 # %d 十进制整数 # %i 十进制整数 # %o 八进制整数 # %e %E 指数(基底分别为e E) # %-10.3f %-10.3F 浮点数 ## 10位宽, 小数精确3位, 右对齐 # %g %G 指数(e E)或浮点数(根据显示长度决定) # %% 字符% print(\u0026quot;c is %s, e is %i\u0026quot; % (c, e) str(1) int(\u0026quot;1\u0026quot;) range(1, 10) # range(-2, -11, -3) exec('') # 执行字符串中的代码 execfile(r'a.py') eval('2 * 3', globals, locals) # 执行字符串中的表达式 # ast.literal_eval compile(str, filename, kind) # 编译字符串为模块 # kind取值: single单语句, exec多语句, eval一个表达式 assert 1 != 1 repr(list) # 对象转换成代码字符串　map(str, range(100)) filter() reduce() locals() # 当前作用域的变量字典 isinstance(value, list) hasattr(obj, '__call__') # 判断是否函数 type(l) # 返回对象类型，或创建metaclass chr(48) # 返回字符 unichr ord('0') # 返回ascii码 bool() iter() next() zip('abc', '123') list(zip()) o-\u0026gt; 文件 spath = \u0026quot;D:/a.txt\u0026quot; f = open(spath, \u0026quot;w\u0026quot;) # 没有时创建 f.write(\u0026quot;a\\n\u0026quot;) f.writelines(\u0026quot;b\u0026quot;) f.close() f = open(spath, \u0026quot;r\u0026quot;) for line in f: print(\u0026quot;%s\u0026quot; % line) f.readline() f.close() o-\u0026gt; 文档 dir(list) help(s.replace) 类型 # o-\u0026gt; 基本类型 数字 1.2, 3+4j, Decimal, Fraction 字符串 列表 [1, 2] 字典 {'a':1} 元组 (1) 文件 open('eggs', 'r') 集合 {'a'} 其他类型 类型, None, False, True 编程单元 函数, 模块, 类 实现相关类型 编译代码堆栈跟踪 o-\u0026gt; 扩展属性 dict = type('dict', (dict,), {}) d = dict() d.a = 1 o-\u0026gt; 序列 [1, 2] [1, [2]] len(l) l[0] l[-1] l[1:3] l[1:] l[:3] l[:-1] l[:] l + l l * 2 del l[1:3] o-\u0026gt; 字符串 # 不可变 r'a' R'a' u'a' U'a' b'a' B'a' 'abc\\ def' 'a' 'b' 'a' \u0026quot;a\u0026quot; '''a''' \u0026quot;\u0026quot;\u0026quot;a\u0026quot;\u0026quot;\u0026quot; s.startswith('a') s.find('a') s.replace('a', 'A') s.split(',') s.join(list) s.upper() s.isalpha() s.isdigit() s.rstrip() # 去右侧空白 '%s, %s' % ('a', 'b') '{0},{1}'.format('a', 'b') if 'a' in name: o-\u0026gt; 列表 l.append('h') l.pop(2) # 弹出特定位置 l.sort() l.reverse() print(l) for x in word: [2 * i for i in [2,3,4] if i \u0026gt; 2] # 列表解析 [row[1] + 1 for row in M] [M[i][i] for i in [0, 1, 2]] {ord(x) for x in 'spaam'} # 创建集合 {x: ord(x) for x in 'spaam'} # 创建字典 o-\u0026gt; 元组 # 不可变 ('a', 'b') (1,) + (2,) # (1, 2) t.index('c') t.count('c') o-\u0026gt; set s = set('a') set([1]) s.add(2) s1, s2 s1 \u0026amp; s2 s1 | s2 s1 - s2 {x ** 2 for x in [1,2,3,4]} # 返回set o-\u0026gt; 字典 d = {'a': 'aaa', 'b': 'bbb', 'c': 12} d['d'] = 3 d.items() # key value d.keys() list(d.keys()) len(d) del d['a'] d.get('a', 0) d['a'] for key in d: if 'a' in d: d['a'] if 'a' in d else 0 o-\u0026gt; 文件 f = open('data.txt', 'w') f.write('a') f.close() text = f.read() text.split() 语句 # o-\u0026gt; 语句 在物理行中用分号划分逻辑行 pass o-\u0026gt; 运算符 + - * / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= == != \u0026amp; | ^ ~ # 按位与 或 异或 翻转(x 变为 -(x + 1)) not and or ** # 幂 // # 取整除 code if None else 0 True and 1 or 0 o-\u0026gt; 条件 if x \u0026lt; 0: x = 0 elif x == 0: else: o-\u0026gt; 循环 for x in a: else: while running: else: 函数 # 函数 def sum(a, b=2, *args, **kwargs): # *args得到元组, kwargs得到字典 ''' doc string''' global x nonlocal y return a + b sum(a=1) sum.__doc__ def make_repeater(n): return lambda s: s * n # lambda只能跟表达式，返回一个函数 生成器 def gn2(): yield def gn(N): for i in range(N): yield i ** 2 yield from gn2() # 相当于静态引入gn2 g = gn() next(g) g.send(1) asyncio模块 @asyncio.coroutine def f(): yield from asyncio.sleep(1) loop = asyncio.get_event_loop() tasks = [asyncio.async(f())] loop.run_until_complete(asyncio.wait(tasks)) loop.close() 协程 @types.coroutine def f2(): yield async def f(): print(1) await f2() # 协程显式交替，线程不用写，会隐式交替 try: f().send(None) except StopIteration: pass 协程asyncio async f(): await asyncio.sleep(1) loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(f())] loop.run_until_complete(asyncio.wait(tasks)) loop.close() 协程属性 gi_frame f_code co_filename f_lineno 属性 __name__ __code__ __annotations__ oop # class Base: __metaclass__ = models.SubfieldBase # __metaclass__实例化结果是类，用于继承 description = '' def __init__(self, name): # self就是this # __del__(self) # __str__(self) # __lt__(self) # __getitem__(self, key) ## x[key]索引时调用 # __len__(self) super(Base, self).__init__(*args, **kwargs) self.data = [] def add(self, x) self.data.append(x) @classmethod def t1(cls): @staticmethod def t2(): class Child(Base): # 继承 def plus(self, a, b): return a + b oChild = Child() oChild.add(\u0026quot;str1\u0026quot;) oChild.data oChild.plus(2, 3) 模块 # # .pyc是字节编译文件 # __name__ 等于'__main__'时程序本身使用运行, 否则是引用 # a.py def add_func(a, b): return a + b # b.py from a import add_func # import add_func as f # from a import * # __init__.py # 表示文件夹为包, 可空 包路径 # 环境变量PYTHONPATH中的值 import sys import os sys.path sys.path.append(os.getcwd() + \u0026quot;\\\\parent\\\\child\u0026quot;) 异常 # if s == \u0026quot;\u0026quot;: raise Exception(\u0026quot;must not be empty.\u0026quot;) try: i = int(s) except Exception as err: # except Exception, err print('Error %d: %s' % (e.args[0], e.args[1])) except: finally: print(\u0026quot;Goodbye.\u0026quot;) else: 模块 # os sys argv # 参数列表, 多维列表 exit() # 退出线程 imp reload # 重载模块 time timeit profile decimal fractions urllib http http.server # python3中的SimpleHTTPServer re functools itertools SimpleHTTPServer # python2自带ftp服务器。 pythom -m SimpleHTTPServer 8080 PyQt # gui PyGTK # gui wxPython # gui TkInter # gui matplotlib # 图形 pillow # ocr, 文字识别 pytesseract # ocr, 精确 numpy math random scipy # 科学计算 beautifulsoup # 网页结构化 scrapy # 网页结构化 requests phantomJS # 运行网页js selenium # 运行网页js pandas # 数据分析，产生数据结构、操作、统计、绘图 seaborn # 数据可视化 scikit-learn # 机器学习 nltk # 自然语言分析 mysql-connector mysqlclient PyMySQL MySQLdb redis.py south # 表结构迁移, django自带 pickle # 持久化 qrcode # 二维码 ast # 运算前检查的eval() datetime shutil # shell fabric # 运程自动部署 celery # 定时调度 工具 # ipython notebook # 在线运行python bpython # 更好的repl pdb # 调试 cprofile # 性能测试 steuptools # easy_install pip # pip install -i http://pypi.douban.com/simple/ torndb # 用豆辨的pypi索引 pip install ipython==4.2.0 # 安装指定版本 pyenv # pyenv versions pyenv install 3.7.6 --list pyenv virtualenv 3.7.6 37 eval \u0026quot;$(pyenv init -)\u0026quot; eval \u0026quot;$(pyenv virtualenv-init -)\u0026quot; pyenv activate 37 pyenv deactivate conda # 环境相关 conda env create -f e.yml # 创建环境 -n name1 list # 列出所有环境 remove -n name1 # 删除环境 conda activate e1 conda init bash 包相关 conda list # 当前环境所有软件包 conda search pillow # 列出包所有版本 conda install pillow=7.0.0 -c # 指定channel，相当于命名空间 conda uninstall pillow conda upgrade numpy 容器 # gunicorn # python实现 sudo pip install gunicorn gunicorn -w4 -b0.0.0.0:8001 app.wsgi uwsgi # c语言实现 sudo pip install uwsgi uwsgi --http :8001 --chdir /path/to/project --home=/path/to/env --module project.wsgi # --home指定virtualenv的路径 nginx shell "},{"id":61,"href":"/docs/pl/clojure/","title":"Clojure","section":"程序语言","content":" 介绍 # 是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程 操作符知道自己的特征值(identity value), 如+是0, *是1 数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃 集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能 # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的 没有尾递归优化，不常用递归，要用loop.recur 语法 # s-expressions (max 3 5) (+ 1 (* 2 3)) (def meaning-of-life 42) (if (\u0026lt; meaning-of-life 0) \u0026quot;negative\u0026quot; \u0026quot;non-negative\u0026quot;) (def droids [\u0026quot;Huey\u0026quot; \u0026quot;Dewey\u0026quot; \u0026quot;Louie\u0026quot;]) (count droids) (droids 0) (def me {:name \u0026quot;Paul\u0026quot; :age 45 :sex :male}) (:age me) (defn percentage [x p] (* x (/ p 100.0))) (percentage 200 10) 并发 # o-\u0026gt; 原子变量 # 对一个值进行同步更新 (def my-atom (atom 42)) (deref my-atom) @my-atom (swap! my-atom inc) (swap! my-atom + 2) (reset! my-atom 0) (def session (atom {})) (swap! session assoc :username \u0026quot;paul\u0026quot;) (if (compare-and-set! a old new) # 判断原子变量a的值是否是old, 是时赋成new并返回true new (recur)) o-\u0026gt; conj 添加新成员 (def players (atom ())) (defn list-players [] (response (json/encode @players))) (defn create-player [player-name] (swap! players conj player-name) (status (response \u0026quot;\u0026quot;) 201)) (defroutes app-routes (GET \u0026quot;/players\u0026quot; [] (list-players)) (PUT \u0026quot;/players/:player-name\u0026quot; [player-name] (create-player player-name))) (defn -main [\u0026amp; args] (run-jetty (site app-routes) {:port 3000})) o-\u0026gt; cons列表首添加元素 (def listv2 (cons 4 listv1)) o-\u0026gt; validator # 值改变之前调用 (def non-negative (atom 0 :validator #(\u0026gt;= % 0))) (reset! non-negative -1) o-\u0026gt; 监视器 # 值改变之后调用　(def a (atom 0)) (add-watch a :print #(println \u0026quot;Changed from \u0026quot; %3 \u0026quot; to \u0026quot; %4)) (swap! a + 2) # !的命名表示函数是事务不安全的 o-\u0026gt; 代理 # 对一个值进行异步更新。 # 代理维护的数据与事务数据相同。代理具有事务性，send会在事务成功后生效 # 方便做内存并发日志系统 (def my-agent (agent 0)) @my-agent (send my-agent inc) # send在值更新之前立即返回，不进行重试。多线程同时调用send, 调用被串行。具有副作用 # send使用公用线程池，send-off使用一个新线程，send-via使用由参数指定的executor (send my-agent #((Thread/sleep 2000) (inc %))) # 设置延迟时间 (await my-agent) # 等待代理执行完成后再继续。await-for函数可以设置超时时间 (def non-negative (agent 1 :validator (fn [new-val] (\u0026gt;= new-val 0)))) # 代理可以使用校验器和监视器 # 校验器失败时抛出异常，代理进入失效状态 # 错误处理模式默认为 :fail, 可以置为:continue # 可以设置错误处理函数 (agent-error non-negative) # 查看代理是否在失效状态 (restart-agent non-negative 0) # 重置失效状态 o-\u0026gt; 引用 # 只有在事务中才能修改引用的值，对多个值进行同步更新 (def my-ref (ref 0)) @my-ref (dosync (ref-set my-ref 42)) # dosync创建一个事务，事务同swap!一样，用重试机制实现 # clojure的事务有原子性，一致性，隔离性，没有持久性 (dosync (alter my-ref inc)) # commute替换alter，可以得到不很强的隔离性，用于做优化 (defn transfer [from to amount] (dosync (alter from - amount) (alter to + amount))) o-\u0026gt; threed (defn stress-thread [from to iterations amount] (Thread. #(dotimes [_ iterations] (transfer from to amount)))) (let [t1 (stress-thread checking savings 100 100) t2 (stress-thread savings checking 200 100)] (.start t1) (.start t2) (.join t1) (.join t2)) o-\u0026gt; ensure确保当前返回的值不被其它事务修改 (when (and (= (ensure left) :thinking) (= (ensure right) :thinking)) (ref-set philosopher :eating)) csp # 介绍 core.async提供了channel和go块 引入的core.async中部分函数名与clojure核心库函数名冲突 o-\u0026gt; channel (def c (chan)) (thread (println \u0026quot;Read:\u0026quot; (\u0026lt;!! c) \u0026quot;from c\u0026quot;)) # thread是core.async提供的辅助宏，将其中代码运行在一个单独的线程上 (\u0026gt;!! c \u0026quot;Hello thread\u0026quot;) 用例 # o-\u0026gt;求和 (defn recursive-sum \u0026quot;\u0026quot; # 文档字符串 ## (require '[philosophers.util :refer :all]) ## (clojure.repl/doc swap-when!) 来查看文档字符串 [numbers \u0026amp; args]) # \u0026amp;表示可变参数 ## (apply f old args) 将args展开，作为附加参数传递给f (if (empty? numbers) 0 (+ (first numbers) (recursive-sum (rest numbers)))) (defn reduce-sum [numbers] (reduce (fn [acc x] (+ acc x)) 0 numbers)) (defn sum [numbers] (reduce + numbers)) o-\u0026gt;并行 (ns sum.core (:require [clojure.core.reducers :as r])) (defn parallel-sum [numbers] (r/fold + numbers)) (def numbers (into [] (range 0 10000))) (time (sum numbers)) (time (sum numbers)) # 预热jim编译器 (time (parallel-sum numbers)) o-\u0026gt; map (def counts {\u0026quot;apple\u0026quot; 2 \u0026quot;orange\u0026quot; 1}) (get counts \u0026quot;apple\u0026quot; 0) (get counts \u0026quot;banana\u0026quot; 0) # 没有时返回设定的默认值0 (assoc counts \u0026quot;banana\u0026quot; 1) (assoc counts \u0026quot;apple\u0026quot; 3) o-\u0026gt; frequencies (defn word-frequencies [words] (reduce (fn [counts word] (assoc counts word (inc (get counts word 0)))) {} words)) (frequencies [\u0026quot;one\u0026quot; \u0026quot;potato\u0026quot;]) # 标准库中已提供 o-\u0026gt; partial函数 # 返回一个被局部代入的函数 (def multiply-by-2 (partial * 2)) (multiply-by-2 3) o-\u0026gt; 序列 (defn get-words [text] (re-seq #\u0026quot;\\w+\u0026quot; text)) (get-words \u0026quot;one tow three four\u0026quot;) (map get-words [\u0026quot;one two three\u0026quot; \u0026quot;four five six\u0026quot;]) (mapcat get-words [\u0026quot;one two three\u0026quot; \u0026quot;four five six\u0026quot;]) # 平辅数组 o-\u0026gt; iterate # 不断将函数应用到初始值，第一次返回值，第二次返回值 (take 10 (iterate inc 0)) (take 10 (iterate (partial + 2) 0)) (take-last 5 (range 0 10000)) # 头元素使用后舍弃，耗相同的内存 o-\u0026gt; pmap (pmap #(frequencies (get-words %)) pages) # pmap在需要结果时并行计算，仅生成需要的结果，称为半懒惰(semi-lazy) # #(...)是读取器宏，来快速创建匿名函数，参数通过%1, %2标识, 只有一个参数时可以是% ## (fn [page] (frequencies (get-words page)))与其等价 o-\u0026gt; merge-with # 标准库函数 (merge-with f \u0026amp; maps) # 将maps中其余map合并到第一个map中，返回合并后的map ## 同键名时，多个值从左向右地合并，调用传递的f(val-in-result val-in-latter) (def merge-counts (partial merge-with +)) (merge-counts {:x 1 :y 2} {:y 1 :z 1}) o-\u0026gt; partition-all # 序列分批 (partition-all 4 [1 2 3 4 5 6 7 8 9 10]) # ((1 2 3 4) (5 6 7 8) (9 10)) o-\u0026gt; reducers包 # 化简器，不代表函数的结果，代表如何产生结果的描述 ## 嵌套的函数返回化简器，比返回懒惰序列效率更高 ## 可以对整个嵌套链的集合操作，可以用fold进行并行化 # clojure.core中大部分函数都有其对应的化简器版本 (require '[clojure.core.reducers :as r]') (r/map (partial * 2) [1 2 3 4]) # 返回一个化简器(reducible) (reduce conj [] reducible) # conj函数第一个参数为一个集合(初始值为[]), 将第二个参数合并到第一个参数中 (into [] reducible) # into函数为内置函数，同上 o-\u0026gt;协议(类似java中的接口)来定义 (defprotocol CollReduce # 化简 (coll-reduce [coll f] [coll f init])) # coll相当于this, 支持多态性分派(polymorphic dispatch) (coll-reduce coll f) (defn my-reduce ([f coll] (coll-reduce coll f)) ([f init coll] (coll-reduce coll f init))) (my-reduce + [1 2 3 4]) (my-reduce + 10 [1 2 3 4]) (defn make-reducer [reducible transforms] (reify CollReduce (coll-reduce [_ f1] (coll-reduce reducible (transformf f1) (f1))) (coll-reduce [_ f1 init] (coll-reduce reducible (transformf f1) init)))) # 用reify实现一个协议 # 调用reducible的coll-reduce方法。用transformf对f1进行转换，转换出的函数作为传给coll-reduce方法的一个参数 # _表示未被使用的函数参数名，可以写成(coll-reduce [this f1]) (defn my-map [mapf reducible] (make-reducer reducible (fn [reducef] (fn [acc v] (reducef acc (mapf v)))))) # acc是之前化简结果, v是集合元素。mapf对v进行转换 o-\u0026gt; fold折叠 # 不能适用于懒惰序列 (defprotocol CollFold (coll-fold [coll n combinef reducef])) (defn my-fold ([reducef coll] (my-fold reducef reducef coll)) ([combinef reducef coll] (my-fold 512 combinef reducef coll)) ([n combinef reducef coll] (coll-fold coll n combinef reducef))) (defn make-reducer [reducible transformf] (reify CollFold (coll-fold [_ n combinef reducef] (coll-fold reducible n combinef (transformf reducef))) (CollReduce (coll-reduce [_ f1] (coll-reduce reducible (transformf f1) (f1))) (coll-reduce [_ f1 init] (coll-reduce reducible (transformf f1) init)))) (def numbers (into [] (take 10000000 (repeatedly #(rand-int 10))))) (require ['reducers.parallel-frequencies :refer :all']) (time (frequencies numbers)) (time (parallel-frequencies numbers)) o-\u0026gt; doall强迫懒惰序列对全部元素求值 (reduce + (doall (map (partial * 2) (range 10000)))) o-\u0026gt; future # 单独线程中执行一段代码 # 典型场景是异步通信 (def sum (future (+ 1 2 3 4 5))) sum # 返回一个future对象 (deref sum) @sum # 运行 (let [a (future (+ 1 2)) b (future (+ 3 4))] (+ @a @b)) # let给a赋值，阻塞当前线程直到被求值 # 外层加法将一直阻塞，直到所有代表的值被求值 o-\u0026gt; promise # 创建promise对象后，代码并不会像future一样立即执行，等待deliver赋值后执行 (def meaning-of-life (promise)) (future (println \u0026quot;The meaning of life is:\u0026quot; @meaning-of-life)) (deliver meaning-of-life 42) o-\u0026gt; Compojure库的服务器 (def snippets (repeatedly promise)) (defn accept-snippet [n test] (deliver (nth snippets n) test)) (future (doseq [snippet (map deref snippets)] (println snippet))) (defroutes app-routes (PUT \u0026quot;/snippet/:n\u0026quot; [n :as {:keys [body]}] (accept-snippet (edn/read-string n) (slurp body)) (response \u0026quot;OK\u0026quot;))) (defn -main [\u0026amp; args] (run-jetty (site app-routes) {:port 3000})) o-\u0026gt; re-seq正则 (defn sentence-split [text] (map trim (re-seq #\u0026quot;[^\\.!\\?:;]+[\\.!\\?:;]*\u0026quot; text))) # trim是内置函数 (defn is-sentence? [text] (re-matches #\u0026quot;^.*[\\.!\\?:;]$\u0026quot; text)) o-\u0026gt; reductions # 同reduce, 返回中间值构成的序列 (reductions + [1 2 3 4]) # (1 3 6 10) o-\u0026gt; clj-http库 (def translator \u0026quot;http://localhost:3001/translate\u0026quot;) (defn translate [text] (future (:body (client/post translator {:body text})))) o-\u0026gt; delay在解引用前不求值 (def translations (delay (map translate (strings-\u0026gt;sentences (map deref snippets))))) o-\u0026gt; 系统时间 (defn now [] (System/currentTimeMillis)) o-\u0026gt; Schejulure库 (def session-sweeper (schedule {:min (range 0 60 5)} sweep-sessions)) # 定期调用 o-\u0026gt; Useful库 (defn expired? [session] (\u0026lt; @(:last-referenced session) (session-expiry-time))) (defn sweep-sessions [] (swap! sessions #(remove-vals % expired?))) # 删除元素 o-\u0026gt; Loop/Recur (defn swap-when! [a pred f \u0026amp; args] (loop [] (let [old @a] (if (pred old) (let [new (apply f old args)] (if (compare-and-set! a old new) new (recur))) nil)))) 工具 # clojureScript # 编译到js "},{"id":62,"href":"/docs/pl/js/","title":"JS","section":"程序语言","content":" 基础 # 特性 原型链, 面向对象, 动态语言(已超出脚本语言的范畴) 弱类型，变量都是var 解释器有自己的内存管理机制(garbage collection) 自由数据类型转换 # 产生了==, ===的判断相等的不同定义 v8引擎 直接生成机器码 分代式GC java jvm工程师参数了优化 历史 Netscape(现Mozilla)创建JavaScript, 但JavaScript是Sun(现Oracle)的注册商标 作为标准提交给ECMA(欧洲计算机制造协会), 改名为ECMAScript ECMAScript 3(ES3) 作为标准广泛使用 ECMAScript 5(ES5) 定义了新的语言标准 JavaScript1.5是Mozilla的版本号, 相当于ES3,包含一些非标准语言扩展 JavaScript1.8 在实现es7 JavaScript解释器或引擎(engine)也有版本号 Google的叫做V8(现在是4.0) 微软改动并取名Jscript 标准 # ECMAScript 6 # 介绍 目标是js可写 复杂的应用程序 函数库 代码自动自成器(code generator) mozilla基于ECMAScript6 发布 JavaScript2.0 V8, node.js使用 let # 块级作用域中声明变量 const # 声明常量 Set对象 # 同java Set, 是一个数组 属性 size 方法 add(value) delete(value) has(value) clear() Map对象 # 键值对，键可以是对象 使用 var m = new Map(); o = {p: \u0026quot;Helllo\u0026quot;}; m.set(o, \u0026quot;content\u0026quot;); m.get(o); 属性 size 方法 set(key, value) get(key) has(key) delete(key) clear() ... (rest运算符) yield关键字 class关键字 commonJS # 介绍 模块化标准 require同步加载, 再执行代码，会阻塞。对服务器不是问题，对浏览器是大问题 输出的是值的拷贝 require后的模块运行后缓存, 可手动清除缓存 commonJs规范下的javascript node.js mongoDB ringojs 使用 var math = require('math'); math.add(2, 3); let {stat, exists, readFile} = require('fs') # 加载fs所有方法生成_fs, 再取其中3个方法。没法做静态优化 AMD # 介绍 模块化标准 异步加载, 预执行 使用 require(['math'], functioni (math){ math.add(2, 3); }); # 加载成功后进行回调 CMD # 介绍 sea.js提出 懒执行 使用 define(function(require, exports, module){ ... }) 词法 # unicode编写的 转义 'café'表示为'caf\\u00e9' 'é' 也可以表示为'e\\u0301', e后面跟一个语调符 区分大小写 # html中不区分大小写 注释 //, /**/ 标识符和保留字 要求 开头以字母、下划线、dollar符。 后续可以加数字 可以出现unicode字符集中的Mn类、Mc类、Pc类，如 # Mn表示非间距字符，Mc表示影响基字符标志位的间距字符, Pc是连接两个字符的连接符或标点符号。 é, π, 保留字 break, delete, function, return, typeof, case, do, if, switch, var, catch, else, in, this, void, continue, false, instanceof, throw, while, debugger, finally, new, true, with, default, for, null, try 未被使用的名保留字 class, const, enum, export, extends, import, super 严格模式下的保留字 implements, let, private, public, yield, interface, package, protected, static 严格模式下不能用做变量名 arguments, eval es6新增保留字 await ECMAScript3将所有java关键字列为保留字 全局属性和对象和函数 直接量 # 直接量(numeric literal) 1 1.2 \u0026quot;hi\u0026quot; 'hi' true false /javascript/gi # 用于模式匹配 ## 实际是一个RegExp对象 ## gi是用来修饰匹配模式的含义 null {x:1, y:2} {foo} # 等同 {foo: foo}, 简化写法常用于函数返回值 {method () {}} # 等同 {method: function () {}} {*m () {}} # generator {['a' + 'b']: 1} # object {['hello'](){reutrn 0;}} # 对象属性是Symbol值时, name属性返回这个Symbol值的描述 {get a () {}, set a (val) {}} # 属性getter, setter。get, set函数的函数名name是 'get xxx', 'set xxx' [1,2,3,4] 整型直接量 0 10 0xff/0Xff # 16进制 0o377 # 8进制 0377 # ECMAScript标准不支持八进制直接量，某些实现可以采用八进制表示 # ECMAScript6严格模式下, 八进制直接量是明令禁止的 0b11/0B11 # 2进制 浮点型直接量 3.14 .333 6.02e23 # 6.02 x 10^23 1.4E-32 字符串直接量 ECMAScript5可多行 # ECMAScript3规定必须一行 \u0026quot;one\\ long line\u0026quot; 模板字符串 # 保留换行，空格，缩进 var name = 'Bob'; `hello ${name} # ${}中可用任意表达式，包括函数 how are you` 语法 # 可省略的分号 通用规则: 独占一行，并与下一行不能整体解析时 var a = f 反例 # 以 (, [, /, +, - 开始的语句极可能和前一条语句一起解析，可写成 ;(a+b) (a+b).toString(); 就不可以 例外规则 return, break, continue占一行时，总加分号 ++, -- 永远解析为前缀, 所以作后缀时要加分号 # 如　x [换行] ++ [换行] y, 解析为 x; ++y '}'之前的分号 严格模式 # 区别 所有变量都要先声明 增加了保留字(如await, protected, static, interface) eval, arguments当作关键字 不允许八进制整数直接量(0前缀) 不能给只读属性赋值，不能给不可扩展对象创建新成员 arguments对象拥有参数的静态副本。 # 非严格模式中，都是引用，可以改变原值 限制调用栈检测能力 # 具有caller和arguments属性，但访问时会抛出异常 arguments.caller, arguments.callee都会抛出类型错误异常 fn.caller, fn.arguments禁止使用 对象定义同名属性产生语法错误, 函数声明同名参数产生语法错误 禁止使用with语句 this值在调用的函数中是undefined, # this禁止指向全局变量 指非属性调用，如eval()，非a.test() eval()代码不能创建局部变量或函数 而是定义在eval创建的新作用域(在eval返回时弃用)中 eval不包含外层作用域 delete后非法标识符抛出异常 如delete prop, 只能delete global[prop] delete不可配置属性抛出异常 es5, es6中尾调用优化只在严格模式下开启 # 因为arguments.caller会跟踪函数调用栈, 无法开启 模块化 # 介绍 es6中模块化思想是尽量静态化，编译时确定模块依赖关系与输入输出 CommonJS(CMD)与AMD都只能在运行时确定 UMD模式只是加了CMD和AMD的切换 es6 特点 import, export可以出现在顶层的任何位置 import 会变量提升, 会执行import的模块 引入的变量是只读的，修改会报错。但可以修改引入变量的内部属性 只加载3个方法，编译时加载，可能静态分析。但不能引用fs模块本身 使引入宏(macro)和类型检查(type system)成为可能 模块自动采用严格模式 输出/引入的是值的只读引用, 值在运行时计算 import import {stat, exists, readFile} from 'fs' # 多引用 import {a as b} from './profile' # b 作为 a 的别名 import 'lodash' # 只运行模块 import * as circle from './circle' # 引入模块到对象 circle.area import a from './export-default' # 引入模块中默认的导出, a可以起任意名，不用大括号 import {default as xxx} from './' # 本质是输出名字为default变量 import def, {a} from './module' # 同时引入default和其它变量 export export var a = 1; export function f () {} var b = 1, c = 1; export {b, c} # 用于统一输出 export {v1 as sv1} export {a as b} from './someModule' # 导入同时导出 export v from 'mod' # 导入同时导出, es7提案可省略大括号 export default function() {} # export default命令来配置默认导出, 本质是输出名字为default的变量，系统允许它取任意名 # export default foo 导出的foo名在模块外部是无效 继承 export * from 'circle' export var e = 2.7 export default function() {} # 输出了circle模块的所有方法(忽略default), 又输出了自定义属性 循环引用 CommonJS会输出已执行的部分 写法问题 var foo = require('a').foo a在别处循环引用时, 得到的foo可能是执行到一半的值 而var a = require('a'), a.foo就会得到执行完后的值 o-\u0026gt; 例子 a.js exports.done = false; var b = require('./b.js'); console.log('a.js =\u0026gt; b.done : ', b.done) exports.done = true; console.log('a.js done') b.js exports.doen = false; var a = require('./a.js') console.log('b.js =\u0026gt; a.done : ', a.done); exports.done = true; console.log('a.js done') main.js var a = require('./a.js'), b = require('./b.js') console.log('main.js =\u0026gt; a.done: ', a.done, ' b.done: ', b.done) 执行 b.js =\u0026gt; a.done: false b.js done a.js =\u0026gt; b.done: true a.js done main.js =\u0026gt; a.done: true b.done: true a.js中require('./b.js')阻塞, 执行b.js b.js中require('./a.js'), 加载已执行的a.js 执行完b.js回到a.js, 执行完a.js main.js加载已执行的a.js b.js es6 import时不执行代码，而是引用 o-\u0026gt; 例子 # CommonJS中不能执行, a加载b, b加载a, a没有输出, foo不存在, es6中可以执行 a.js import {bar} from './b.js'; export function foo() { bar(); console.log('a.js done') } b.js import {foo} from './a.js'; export function bar() { if(Math.random() \u0026gt; 0.5) {foo()} } babel-node a.js o-\u0026gt; 例子 even.js import {odd} from './odd' export var counter = 0; export function even(n) { counter++; return n == 0 || odd(n - 1); } odd.js import {even} from './even'; export function odd(n) { return n != 0 \u0026amp;\u0026amp; even(n - 1); } main.js import * as m from './even.js' m.even(10) // true m.counter // 6 # 10 变到 0 even执行了6次 m.even(20) // true # 20 变到 0 even执行了11次 m.counter // 17 ＃es6中引用加载机制保证even, odd函数能加载，所以可执行。而CommonJS中循环引用，even和odd函数都不会加载 类型与变量 # 声明 特点 存值之前是undefined 声明提前 非声明变量赋值创建全局变量 # ECMAScript 5 严格模式下未声明赋值会报错 非声明的全局变量与声明全局变量的区别: 非声明的全局变量是可配置的(可delete)，而var声明的全局变量不可配置 let 支持了直接用{}的块级作用域 只在块级作用域有效 for(let i = 0; ...; ...) 无变量提升 声明前存在暂时性死区 死区中使用该变量会直接报错 重复声明报错 声明的全局变量不再是全局对象的属性 同样机制的还有const, class const 只能在声明时赋值一次, 其他同let var x; x = 1; let a = 10 const PI = 3.1415 export const A = 1; import * as constants from './constants' constants.A 类型 特点 可以拥有方法的类型, 不能拥有方法的类型 可变(mutable)类型 # 值可以改变, 比较(==, ===)是地址的比较 对象 不可变(immutable)类型 # 比较(==, ===)是值的比较 数字、布尔值、null、undefined、字符串 # 字符串不像c语言可以看作字符数组，js的字符串不可变 原始值 # 不可以拥有自己的方法 null undefined 原始类型(primitive type) # 可以拥有自己的方法, 原始类型都包含内置构造函数 数字 字符串 布尔值 Symbol 对象类型(object type)或引用类型，如 对象(object)是属性(property)的集合 property由key/value组成 全局对象(global object) 数组类: Array 内存连续保住的带编号的值的有序集合 函数类: Function 具有相关联的可执行代码的特殊对象 类型转换 # Symbol不可转换 转换为数字 # 字符串允许在开始和结尾处带有空格 false为 0 true为 1 \u0026quot;\u0026quot;为 0 失败为 NaN 转换为字符串 -0 为\u0026quot;0\u0026quot; -Infinity 为\u0026quot;-Infinity\u0026quot; [9]为 \u0026quot;9\u0026quot; ['a']其他数组，调用join()方法 对象转换字符串 # 运算符+ == != 的处理运用这里的原理 # 日期对象有自己的重定义,valueOf与toString返回的原始值将直接使用 toString() valueOf() # 没有toString()方法时调用, 如果返回原始值，自动将它转换为字符串 数组、函数、正则表达式返回对象本身 日期类返回毫秒数 无法得到原始值则抛出异常 对象转换数字 # 运算符 - \u0026lt; 用了这里的原理 首先尝试valueOf() # 如果返回原始值，自动转换为数字 再尝试toString() # 自动转换为数字 无法得到原始值则抛出异常 例子 数字 []为0 # valueOf -\u0026gt; toString -\u0026gt; \u0026quot;\u0026quot; -\u0026gt; 0 [9]为9 # valueOf -\u0026gt; toString -\u0026gt; \u0026quot;9\u0026quot; -\u0026gt; 9 相等性 null == undefined \u0026quot;0\u0026quot; == 0 0 == false \u0026quot;0\u0026quot; == false 类型 # 数字 基础 所有数字用二进制浮点数表示(64位, 如java中的double) # IEEE-754标准 ## 整数范围 -2^53 ~ 2^53(大约900亿亿) 实际的操作(数组索引, 位操作符)基于32位整数 负号是一元运算符，并不是数字直接量语法的组成部分 0与-0唯一差别 1/zero !== 1/-0 # 正无穷大和负无穷大不等 实数近似表示(几乎所有现代编程语言都存在, 因为都是IEEE-754标准) 浮点数表示褛的个数为18 437 736 874 454 810 627个 IEEE-754标准精确表示1/2, 1/8, 1/1024，但不精确表示1/10, 1/00。 # 建议用大整数进行重要计算(如元, 角, 分各用整数表示) 所以js只能近似表示0.1 var x = .3 - .2 var y = .2 - .1 x == y // =\u0026gt; false x == .1 // =\u0026gt; false y == .1 // =\u0026gt; true 字符串 基础 从0开始 没有如c语言中的字符型 采用UTF-16编码的Unicode字符集。 是一组无符号16位值组成的序列。 # 用16位内码表示, 表示一个单个字符 ## 不能16位Unicode表示的遵循UTF-16编码规则，两个16位值来表示一个(代理项对) ### 长度为2的字符串可能表示一个Unicode字符,如var e =\u0026quot;\\ud835\\udc52\u0026quot;; e.length // =\u0026gt; 2 字符串的操作不对代理项对单独处理 不对字符串做标准代加工 所以不能保证字符串是剑的UTF-16格式 运算 + # 字符串连接 unicode 允许采用\\uxxxx表示\\u0000 到 \\uFFFF之间的字符 超出范围时用4字节表示, 如 \\uD842\\uDFB7 '\\u20BB7' 会被解释成 '\\u20BB' + '7' '\\u{20BB7}' 会正确解释 多种表示法 '\\z' '\\172' '\\x7A' '\\u007A' '\\u{7A}' 转义 十六进制数表示Latin-1或Unicode中的任意字码, 由两位十六进制数指定 '\\xA9' // =\u0026gt; © \\u表示4个十六进制数指定的Unicode字符 '\\u03c0' // =\u0026gt; \\n \\' \\0 # 同\\u0000, 表示空字符串 \\b # 同\\u0008, 表示退格符 \\t # 同\\u0009, 表示tab \\v # \\u000B, 垂直制表符 \\f # \\u000C, 换页符 \\r # \\u000D, 回车 布尔 转换 # 所有值都可以转换为布尔值 false undefined null 0 -0 NaN \u0026quot;\u0026quot; true 除以上，全部为true api toString() # 转换成\u0026quot;true\u0026quot;或\u0026quot;false\u0026quot; null undefined 类型 null为object # 但可以表示数字类型、字符串类型 undefined为\u0026quot;undefined\u0026quot;, 是一个单独类型 比较 null == undefined // =\u0026gt; true null === undefined // =\u0026gt; false 无api # .和[]取成员会产生类型错误 bug undefined在ECMAScript可读/写，可赋任意值 结论 undefined表示系统级类似错误的空缺 null表示程序级的，正常出现的空缺 Symbol 介绍 原始数据类型，因为不是对象，所以不能new, 不能添加属性 不参与类型转换, 但可以toString # 可以String(s)得到 'Symbol(a)', Boolean(s)得到true, !s 得到false。Number(s)会报错 可以做属性名a[sym1] = 1, 不能用点运算符赋值或取值 常用于设置常量结构体来switch，以消除魔术字符串 作用域 # 全局变量 就是定义顶级对象的属性 # 这点在ECMAScript规范中强制规定 在js代码任何地方都有定义 局部变量 在函数内有定义，优先于全局变量 与c语言区别(嵌套作用域) c中{}内产生块级作用域(block scope), 其中变量其外不可见 js中没有块级作用域，是函数作用域(function scope), 变量在内部嵌套函数中有定义。 声明提前 内部嵌套函数而言, 变量声明之前就可用, 称为声明提前(hoisting) # hoisting js函数里声明的所有变量(不赋值), 被\u0026quot;提前\u0026quot;到函数体顶部，在js引擎预编译时进行。 例子 var scope = \u0026quot;global\u0026quot; function f(){ console.log(scope) # undefined, 因为局部scope声明提前，覆盖了全局scope, 而声明提前不定义, 定义在执行代码时进行 var scope = \u0026quot;local\u0026quot; # 等价于开头var scope; console.log(scope) } 特点 js本身设计中没有构造函数，普通函数，对象方法，闭包。这些都是莫须有的叫法 内部函数可以访问外部函数上下文 非严格格式直接声明变量，挂到global上 作用域在函数中定义, 非块定义, 所以 for(var i = 0; i \u0026lt; 10; i++){ # 中定义的i与value，在for之外可以被访问, 且声明提前 var value = 'hello'; } this 有调用对象就指向调用对象 没调用对象指向全局对象 O.a = function(){ var b = function(){ # b中的this永远是全局对象 console.log(this); }; b(); }; O.a() new 构造时this指向新对象 var O = function(){this.val = 100;} var o = new O(); console.log(o.val); # 这里输出o.val而不是O.val 用apply或call或bind方法改变this指向 function tt(){ console.log(arguments.callee); # 永远是tt本身 console.log(this); # 都是下面定义的a } var a = '1'; tt.call(a, 1, 2); tt.apply(a, [1, 2]); var att = tt.bind(a); att(); 参数调用时，会扩展作用域，如 f(a.b)() # a挂到f的作用域 var f = function(c){} 作用域链(scope chain) 特点 每一段js代码有关联的作用域链 一个对象链表，定义这段代码的作用域 变量解析(variable resolution)时，从链第一个开始查找到最后一个 # 查找不存在时抛出引用错误(ReferenceError) 原理 定义一个函数时，实际上保存一个作用域链 调用该函数时，创建新对象放局部变量，添加到保存的作用域链 同时，创建一个新的、更长的\u0026quot;函数调用作用域链\u0026quot; 该函数每次调用外部函数时，嵌套函数重定义 代码作用域链分类 顶层代码 顶级对象属性 无嵌套函数体 var定义的局部变量 顶级对象属性 嵌套函数体 var定义的局部变量 顶级对象属性 函数调用作用域\u0026quot;链\u0026quot; 注意 函数创建时，它的作用域链中会填入全局对象 执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象 运行期上下文定义了函数执行时的环境 每个运行期上下文都有自己的作用域链 其作用域链初始化为当前运行函数的Scope所包含的对象。 函数中的值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中 它们共同组成了一个新的对象，叫“活动对象(activation object)” 该对象包含了函数的所有局部变量、命名参数、参数集合以及this 此对象会被推入作用域链的前端 运行期上下文被销毁，活动对象也随之销毁 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。 该过程从作用域链头部，也就是从活动对象开始搜索 如果没找到继续搜索作用域链中的下一个对象 如果搜索完所有对象都未找到，则认为该标识符未定义 作用域链只会被 with 语句和 catch 语句影响。 优化代码： 因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。 所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量 一个好的经验法则是, 如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用 优化with with(o){ } 使用with语句来避免多次书写document，看上去更高效，实际上产生了性能问题。 代码运行到with语句时，运行期上下文的作用域链临时被改变了 一个新的可变对象被创建，它包含了参数指定的对象的所有属性, 这个对象将被推入作用域链的头部 这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。 优化try-catch try{ doSomething(); }catch(ex){ alert(ex.message); # 作用域链在此处改变。同理，catch语句使效率下降 try{ doSomething(); }catch(ex){ handleError(ex); # 委托给处理器方法, 没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。 } # 优化后的代码，handleError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。 表达式 # 介绍 表达式(expression), 由解释器计算(evaluate) 原始表达式(primary expression) 常量 直接量 关键字 true, false, null, this 变量名 对象和数组初始化表达式 # 对象直接量、数组直接量 {} [] 函数定义表达式 # 函数直接量 var square = function(x){reutrn x*x} 属性访问表达式 # 其前面的表达式首先计算, null, undefined会抛出类型错误异常，因为它们不能包含属性 . [1] [\u0026quot;a\u0026quot;] 调用表达式(invocation expression) 顺序 首先计算函数表达式，再计算参数表达式 传入实参的值赋值给形参 执行函数体 return返回值给变量名，无return 函数名赋为undefined 左边是属性访问表达式时，称作方法调用(method invocation) 函数体的this是宿主对象(执行者) 非方法调用时，this是顶级对象 ECMAScript 5中非方法调用时, this是undefined f(0) # 非方法调用 Math.max(x, y, z) # 静态方法调用, this为Math类 a.sort() # 动态方法调用, this为a实例 对象创建表达式(object creation expression) 特点 创建一个对象并调用构造函数 与调用表达式相似 过程 创建空对象，该对象作为构造函数的this，可用来初始化动态属性 传入指定参数，执行构造函数。 返回值以构造函数返回值优先(本次对象废弃)，没有时则返回本次创建的对象 new Point(2, 3) new Object() new Object # 不传参时, ()可以省略 关系表达式 == \u0026lt; in instanceof 逻辑表达式 ! \u0026amp;\u0026amp; || 赋值表达式 (a=b) == 0 i = j = k = 0; 运算符 # 概念 可符号，可关键字 一元、二元、三元运算符 # - +(正负号)是一元，*是二元, ?!是三元 期望与转型 \u0026quot;3\u0026quot; * \u0026quot;5\u0026quot; # 期望数字, 自动转型 对类型依赖 + # 数字则运算，字符串则拼接 \u0026lt; # 数字则比较, 字符则比较字符表次序 左值(lvalue) 表达式只能出现在赋值运算(=)的左侧 \u0026amp;, ++等操作符的操作数 内存栈中的变量名 变量、对象属性、数组元素 内置函数可返回左值，自定义函数不可以 优先级 左右结合性 运算顺序 总是严格从左到右计算表达式 表达式会影响变量值(如++, --, delete)时，先执行 b = (a++)+a # 计算b, 计算a++(返回的结果是1), 计算右边的a(结果是2), 计算等号右边(1 + 2), 赋值 关键字运算符 delete, typeof, instanceof, in, void in运算符 # 判断是否存在属性, 左是字符串, 右是对象 'toString' in obj for( var i in ojb) instanceof运算符 # 判断是否实例, 会判断父类, (prototype chain) o instanceof f # 遍历原型链, 计算f.prototype, 然后在o原型链中查找f, 找到则返回true typeof 运算符 # 返回一个对象的类型描述字符串 typeof value == \u0026quot;string\u0026quot; ? \u0026quot;'\u0026quot; + value + \u0026quot;'\u0026quot; : value typeof(value) # 可以写作函数的形式 返回值 \u0026quot;undefined\u0026quot;, \u0026quot;object\u0026quot;, \u0026quot;boolean\u0026quot;, \u0026quot;number\u0026quot;, \u0026quot;string\u0026quot;, \u0026quot;function\u0026quot; null, 对象和数组 返回\u0026quot;object\u0026quot; # 函数是对象的一种，但typeof特殊对待。 # instanceof, class特性, constructor属性 delete运算符 # 严格模式下删除失败会报错 删除属性, 成功则返回true 内置核心客户端属性不能删除 var语句声明的变量不能删除 function定义的函数和其参数不能删除 void运算符 写在操作数前，操作数照常计算, 但返回undefined \u0026lt;a href=\u0026quot;javascript:void window.open();\u0026quot;\u0026gt; # 使浏览器不必显示计算结果 普通一元(目)运算符 + # 这里+, -表示正负号, +, -会把变量自动转型为数字 - ++ # ++, -- 作为前增量时, 返回计算后的值，后增量时，返回计算前的值。与c语言不一样，c语言的前后增量作用于整个表达式s -- 普通二元(目)运算符 特点 必要时转换数字 js中数字都是浮点数, 所以5/2 = 2.5 左结合 根据类型进行数字相加或字符串连接 对象先尝试转换数字(Date除外，先转换字符串) 如果存在字符串，则拼接(不论字符串值是否数字) 都为非字符串，则转换数字计算，失败返回NaN - * / % ** # **是指数运算符 + 三元(目)运算符 ?: # 条件运算符, 唯一三元运算符 位运算符(对操作数每位布尔运算) 特点 要求操作数是整数(32位整形而非64位浮点型) 会自动强制转换 NaN, Infinity, -Infinity转换为0 \u0026amp; # 按位与 0x1234 \u0026amp; 0x00FF = 0x0034 | # 按位或 0x1234 | 0x00FF = 0x12FF ^ # 按位异或 0xFF00 ^ oxF0F0 = 0x0FF0 ~ # 按位非 ~0x0f = 0xFFFFFFF0或 -16 \u0026lt;\u0026lt; # 左移 7\u0026lt;\u0026lt;2 = 28 # 移动倍数是0~31的整数，用0补 \u0026gt;\u0026gt; # 左边高位 正数填0, 负数填1 7\u0026gt;\u0026gt;1 = 3 -7\u0026gt;\u0026gt;1 = -4 \u0026gt;\u0026gt;\u0026gt; # 无符号右移，左边高位总填0 相等不等运算符 ==(equality operator), ===(严格相等(strict equality)或恒等(identity operator)) == # 数字和字符串原始类型也是地址的相等(恒等) null == undefined 数字==字符串, 字符串转换为数字比较, true转换成1比较 \u0026quot;1\u0026quot;==true # 同时转换为数字比较 对象根据另一个值的类型转换 === 与 == 不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等 !=, !==是==, ===的求反 比较运算符 \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= # 存在NaN则返回false, \u0026lt;=只是简单的不大于，\u0026gt;=相反。不进行==比较 0 == -0 Infinity最大(除了本身) -Infinity最小(除了本身) 转换 对象转换为数字 同为字符串，字母表顺序比较(16位unicode字符索引顺序) 存在不为字符串，转换数字 逻辑运算符 ! \u0026amp;\u0026amp; || # !会隐式转换为布尔类型, \u0026amp;\u0026amp;比||优先级要高, !优先级最高 隔断性 (a == b) \u0026amp;\u0026amp; stop() # 同if(a == b) stop(); var max = a || b || 0; # 常用。层层按优先级判断，给max赋值, 用来给可能未传入的参数赋默认值 赋值运算符 = 带操作的赋值运算符 +=, -=, *=, /=, %/, \u0026lt;\u0026lt;=, \u0026gt;\u0026gt;=, \u0026gt;\u0026gt;\u0026gt;=, \u0026amp;=, |=, ^=, **= 注意 data[i++] *=2 data[i++] = data[i++] * 2 # 以上不相同 逗号运算符 # 计算左边表达式并忽略结果, 连接多上表达式成为一个表达式 i=0, j=1, k=2 # 计算结果是2 for(var i=0, j=10; i \u0026lt; j;j--) 扩展(spread)运算符 # 展开具有[Symbol.iterator]接口的可遍历对象，所以可以展开字符串, Map, Set, Generator # 内部使用for of, 支持4字节字符 [1, 2, ...arguments] # 展开成新数组, 等于[1, 2].concat(arguments) [a, ...rest] = [1, 2, 3] # 模式匹配给rest赋值, 只能放在最后 array.push(1, ...items, 2) # 函数调用 函数绑定运算符 # 返回原对象, 可以链式调用a::b::c, 把b, c都绑定到a foo::bar # bar.bind(foo) ::obj.foo # obj.foo.bind(obj) 优先级 优先级(js权威指南六版66页) 算术运算 不报错 溢出(overflow), 下溢(underflow), 被零整除 overflow 超过表示的数字上限, 得到Infinity或-Infinity underflow 比最小值还小, 返回0或负0, 负0几乎和0一样, 很少用到 除零 返回无穷大或负无穷大 返回NaN 零除以零 无穷除以无穷 负数开方 无法转换为数字 eval # 介绍 计算由源代码组成的字符串, 用eval(\u0026quot;\u0026quot;)来运行 eval()是一个函数，但设计上更像运算符。 限制eval()函数使它更像运算符 eval() 一个参数，如果不传入字符串，则直接返回传入的参数。 传入字符串, 则编译该字符串 失败则抛出语法错误异常(SyntaxError)，成功则开始执行这段代码 执行成功，返回字符串中最后一个语句的值。最后语句没有值，返回undefined 执行中抛出异常, 该异常将调用传递给eval()[?] eval的作用域是当前作用域, 如eval(\u0026quot;var y = 3;\u0026quot;) 用eval向函数中粘贴代码片段是无意义的，如 var foo = function(a){eval(a)}; foo(\u0026quot;return;\u0026quot;); # 执行eval(a)的上下文是全局的, 会抛出return not in function错误 eval作为单独脚本，如eval(\u0026quot; y = 1;\u0026quot;)是有意义的 问题 eval()中的代码，解释器不能分析和优化 eval()可以改变局部变量，对优化是很大的问题 eval()的函数名可以被赋予其他名字(与运算符的区别) var f = eval; var g = f; 这样解释器无法优化任何调用g()的函数 所以ECMAScript规定不可以对eval()赋予别名，会抛出EvalError异常 实际上，大多数实现并不这么做。别名调用时, 会当作顶层全局代码来执行 这样不会修改局部变量的值，不影响优化 ECMAScript 5规定 直接eval(direct eval), 总是在调用它的上下文作用域执行 间接调用(指别名调用)则作为顶层代码执行，不能读、写、定义局部变量 # 间接eval是有用的特性，允许在局部作用域执行上下文无依赖的脚本 ie9之前的不同 别名调用eval()是局部调用 用execScript()来全局eval调用 # 与eval不同在于总是返回null ECMAScript 5 严格模式 eval作为保留字, 不能用别名覆盖(更像运算符) eval中的字符串以\u0026quot;use strict\u0026quot;指令开始 可以使用和更改局部变量，不可以定义新的变量 语句 # 介绍 语句以分号结束 表达式计算出值，语句来执行。 有副作用的表达式也会执行，叫作表达式语句(expression statement) 声明语句(declaration statement), 来声明新变量或定义新函数 js解释器依照语句编写顺序执行 控制结构(control structure)改变顺序 条件conditional switch 循环loop while, for 跳转jump break, return, throw 表达式语句 赋值语句，如 greeting = \u0026quot;Hello\u0026quot; + name; ++, -- delete 函数调用，如 alert(greeting); # Math.cos(x)不是表达式语句，它没有对浏览器造成影响 复合语句和空语句 {}括起来当作单独语句 内部语句必须分号 内部声明的变量作用域在外部(es6之前) 如 { x = Math.PI; cx = Math.cos(x); } 空语句 ; 如 if(){....} if(); 块作用域(es6之后) # 内部使用严格模式 { } 声明语句 特点 声明语句创建的变量无法删除，但不是只读的，可以重写 函数声明常出现在代码最顶层 函数声明并没有归类为真正的语句 函数声明不能出现在if, while等语句中 var, function 如 var f = function(){} # 变量名指向函数对象，声明提前。初始化要在执行到时进行, 不可以在代码之前调用 function f(){} # 函数声明和定义均提前，可以在代码之前调用 条件语句 if(expression1) statement1 else if(expression2) statement2 else statement3 switch(expression){ statements} 特点 不重复计算表达式 无break向下执行，如c语言 ECMAScript规定case可跟随任意表达式 case是恒等比较, 所以不会作类型转换 case是运行时(run-time)计算的, 灵活但效率低。 c, c++, java中case是编译时(compile-time)常量 编译时常量形成跳转表(jump table), 执行非常高效 避免使用函数表达式和赋值表达式，建议常量表达式 default标签可以在switch语句内的任何地方 switch(typeof x){ case 'number': break; default: break; } while(expression) statement do statement while(expression); # 代码至少执行一次 for(initialize; test; increment) statement # for(;;)比while(true)高效 for(variable in object) # 遍历对象属性成员, 遍历出的数组key(如0, 1, 2)是字符串 for(a[i++] in o) for(i in [1,2,3]) 原理 计算object表达式 为null或undefined 则跳过 # ECMAScript3的实现可能会抛出一个类型错误异常 为原始值, 则包装对象 否则就一定是对象，枚举对象属性(或数组索引) 只有可枚举(enumerable)属性才会遍历到 代码中所有属性和方法可枚举 ECMAScript 5可以特殊手段变为不可枚举 js语言核心定义的内置方法不可枚举(nonenumerable)，如toString() 很多内置属性不可枚举 继承的自定义属性也可以枚举出来 prototype上有多个原型(原型链上多个对象), 每个都遍历 for/in中提前删除的未枚举属性不会枚举到 定义的新属性不会枚举到(有些实现是可以枚举到的) 每次循环计算variable表达式的值，以它为左值赋值 顺序 通常实现按照定义先后顺序 原型链多继承对象有特定顺序 数组依照数字顺序 # 不是全部实现, 索引非数字或不连续时，按照特定顺序 for(let c of s) # 会正确识别4字节字符 跳转语句(jump statement) break, continue, return, throw # throw是复杂的跳转语句，跳转到最近闭合异常处理程序, 处理程序可以在同函数中或高层调用栈中 标签语句 identifier: statement identifier不能是保留字。与变量或函数命名空间不同，可以使用同一个标识符作标签和函数名 外层语句标签不能和它内部的重名。不嵌套下是可重名的 break, continue是唯一可以使用语句标签的语句 mainloop: while(token != null){ continue mainloop; // break mainloop; } break语句 特点 break后面无内容自动补分号 不可以跳出函数边界，只在一个函数中起作用 for中不会计算自增表达式, 直接退出 break; break labelname; continue语句 特点 continue后面无内容自动补分号 while中跳到开头检测expression, do/while跳到结尾 for中先计算自增表达式，再检测expression, for/in中遍历下一个属性名，赋给变量 continue; continue labelname; return语句 特点 return后面无内容自动补分号 函数调用是表达式，return返回函数表达式的值并跳过后续结果。无return时, 函数表达式结果为undefined 只在函数中出现 throw语句 特点 js解释器立即停止当前执行的逻辑，并跳转到就近异常处理程序 try/catch/finally语句的catch编写异常处理程序 没有异常处理程序, js把异常当作程序错误处理，报告给用户 throw expression; throw new Error('x不能是负数'); # Error对象, name属性表示错误类型, message属性存放传递给构造函数的错误信息 try/catch/finally语句 # catch可选, finally可选, try finally一起, finally用于清理代码 finally中常写的逻辑 # finally中return, continue, break, throw跳转，忽略已有返回值或异常，以finally中的为准 o-\u0026gt; 正常终止, 收尾语句 o-\u0026gt; break, continue或return终止 o-\u0026gt; 抛出异常，被catch捕获。抛出异常未被捕获, 继续向上传播 模拟for(initialize; test; increment)body; initialize; while(test){ try{body;} # body中有break时, 这里相比for循环有一次额外的自增运算, 所以while不能完全模拟for finally{increment;} } with语句 with(object) statement with语句用于临时扩展作用域链, 将对象添加到作用域链的头部 with下创建未声明变量不会添加到with对应对象作属性，而是和平时一样 with执行完后把作用域链恢复到原始状态 作用域链(scope chain) 按序检索的对象列表, 通过它进行变量名解析 严格模式下禁止使用with语句。非严格模式不擒获with, 因为运行慢且非常难于优化 对象嵌套层很深时使用with来简化代码编写 debugger语句 debugger; # 产生一个断点(breakpoint)，在解释器调试模式运行时使用 # ECMAScript 5中加入的debugger语句。但从前主流浏览器已经实现了 \u0026quot;use strict\u0026quot;指令 只出现在代码或函数体的开始或eval()中。其前可以有其字符串直接量表达式语句 解释器可能将\u0026quot;use strict\u0026quot;之前的字符串和它都解释成解释器自有的指令 直到第一条常规语句出现之后, 字符串直接量就只当作普通表达式语句对待 表示其后的代码将会解析为严格代码 函数和eval()只作用到自身 ECMAScript 5引入的指令。可以使用单引号。对于没有实现ECMAScript 5的解释器来说，它什么也不做(没有副作用) 将来ECMAScript希望用use做关键字 tag函数 # 用于过滤html字符串, 嵌入其他语言执行或filter出特定的值 tag`hello ${1} world ${2}` function tag(strArr, ...values){} # ['hello ', ' world ', ''] , 1, 2 数组推导 # 支持iterator接口, 即也支持字符串。惰性求值, 可以替代filter方法 var a1 = [1, 2, 3] var a2 = [for (i of a1) i * 2] var a3 = [for (i of a1) if(i \u0026lt; 3) i] var b1 = [1, 2] var b2 = ['a', 'b'] [for (s of b1) for (w of b2) s+w] // ['1a', '1b', '2a', '2b'] let c = (for (n of generator()) n * n) 模式匹配 # 特点 模式匹配只对自身属性起作用 数组 let [foo, [[bar], baz]] = [1, [[2], 3]] # var, const同样适用 let [,, third] = [1, 2, 3] let [head, ...tail] = [1, 2, 3] let [x, y, z] = new Set(['a', 'b', 'c']) # 只要有Iterator接口，都可以匹配 var [foo = true] = [] # 设置默认值，在值严格等于undefined时生效 var [x = 1] = [undefined] x = 1 var [x = 1] = [null] x = null let [x = f()] = [1] # 惰性求值 let [x = y, y = 1] # 报错, y 未声明 对象 var {bar, foo} = {foo: 'a', bar: 'b'}; var {foo: baz} = {foo: 'a'}; # baz = 'a' var {p: [x, {y}]} = {p: ['a', {'b'}]} # 这里p是模式，不是变量，所以不声明或赋值 let obj = {}, arr = []; ({foo: obj.prop, bar: arr[0]} = {foo: 1, bar: 0}); # 嵌套值, 不加()时{}会被解释成代码块 var {x = 3} = {}; let {log, sin, cos} = Math # 将对象的方法赋值到变量 let n = {...{a: 3, b: 4}} # {a: 3, b: 4}, 扩展null, undefined会被忽略, 被扩展对象中的getter会执行 let n = {x: 1, ...a} # a中的x属性会被覆盖掉, 原理同Object.assign let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4} # x // 1, y // 2, z // {a: 3, b: 4}, z 是引用 基本类型 const [a, b] = 'hello' let {toString: s} = 123 # 如果右边不是对象，先包装, null 和 undefined不能匹配 # let {toString: s} = true 函数 function add([x, y]){} add([1, 2]) function move({x = 0, y = 0} = {}) # function move({x, y} = {x: 0, y: 0}) 是错误的 圆括号 [(b)] = [3] ({p: (d)} = {}) [(parseInt.prop)] = [3] # 只有非声明语句的非模式部分可以用圆括号 用途 [x, y] = [y, x] # 交换值 function f(){return [1, 2]} var [a, b] = f(); function f(){return {foo: 1, bar: 2}} var {foo, bar} = f(); # 函数返回多个值 function f([x, y]){} f([1, 2]) function f({x, y, z = 3}){} f({y: 2, x: 1}) # 参数定义 let {id} = {id: 42, status: 'ok'} # json匹配 var map = new Map(); map.set('a', 1) for(let [, val] of map){} # 遍历map const {SourceMapConsumer, SourceNode} = require('source-map') # 输入模块方法 函数 # 特点 js的函数是参数化的 在js中，函数即对象，可以随意传递，可以设置属性和调用该函数的函数 在js中，函数可以嵌套定义, 嵌套的函数可以访问被定义所处作域中的变量，这个作用域就是闭包(closure) 函数是对象，但typeof经过处理，所以返回\u0026quot;function\u0026quot;, 可以拥有静态属性和方法，可以用内部构造函数Function()创建 形参 标识符列表(函数中定义的变量)，调用时为其提供实参值。 初始化对象的函数是构造函数 return停止函数执行并返回它的表达式。没有表达式时返回undefined。没有return语句时返回undefined this是关键字，不是变量或属性名，所以不允许赋值。 this没有作用域限制 将函数绑定到Function.prototype上，以便所有函数对象都继承它 关键字 this 除实参外，每次调用拥有一个调用上下文 this 对象调用函数时, 此次调用上下文是该对象。 super super()调用父类的构造方法, super相当与父类的实例，super同时部署了父类的静态属性 对象总是继承其他对象，所以在任意对象中，都可以使用super, 如 var obj = {toString() {return 'a ' + super.toString() }} new.target 构造函数中使用, 返回调用该构造函数时new 命令作用的对象 如果直接调用等, 则值为undefined function Person() {new.target === Person} class {constructor() {new.target}} # 子类继承父类调用super()时, 父类构造方法中new.target指向子类, 可以利用写出不能继承的类 定义 # 函数名通常是动词或以动词为前缀的词组，常用的写短 function a(){} 声明和定义均提前 ECMA只允许它作为顶级语句，不能出现在循环、条件判断或者try/cache/finally及with语句中 一些js实现并未严格遵守规则，比如firefox就可以在if中出现函数声明 var a = function(){} 只声明提前。可作匿名函数 此为函数定义表达式, 可以出现在js代码的任何地方 o.m = f 给已有对象的属性引用方法 创建函数 function fun(){} var fun = function {} var fun = new Function(\u0026quot;输入变量1\u0026quot;,\u0026quot;输入变量2\u0026quot;,\u0026quot;执行内容\u0026quot;); # 动态创建函数 var f = (a, b) =\u0026gt; a + b var f = n =\u0026gt; n var f = () =\u0026gt; {return 1} var f = () =\u0026gt; ({a: 1}) 箭头函数特性: 没有自己的this, this是外部的this, 所以不能用call, apply, bind改变this 不能当作构造函数, 没有super, new.target 没有arguments, arguments是外部的 不能成为Generator 大括号解释为代码块, 要返回对象时用圆括号括起来 const pipeline = (...funcs) =\u0026gt; val =\u0026gt; funcs.reduce((a, b) =\u0026gt; b(a), val) const plus1 = a =\u0026gt; a + 1, mult2 = a =\u0026gt; a * 2, addThenMult = pipeline(plus1, mult2); addThenMult(5) // 12 let insert = val =\u0026gt; ({into: (arr) =\u0026gt; ({after: (afterVal) =\u0026gt; { arr.splice(arr.indexOf(afterVal) + 1, 0, val); return arr; }})}) insert(2).into([1, 3]).after(1) // [1, 2, 3] 参数 function f(x, y = 5) f({x: 1, y: 2})可以模式匹配 默认值可以是变量，作用域是函数内作用域。函数a默认值是函数b时, 函数b的作用域链不包含函数a 默认值一般在最后, 可以一眼看出哪些参数可以省略，调用时也好看 function f(url, {method = 'GET'} = {}) function f({a, b}) {a, b} f({a: 1, b: 2}) 对象匹配 function f(a = throwErr()) 设置不可省略的参数, 默认值是延迟计算的 function f(...rest) 一定在末尾 嵌套函数 特性 内部嵌套函数可以读写外部参数 this不会在嵌套函数中继承，函数调用和方法调用中this的规则不变。 如果要在内部访问外部this, 需要将外部this保存到变量中(通常用self, [that 是传递this时使用的变量名]) 调用 方式 作为函数 作为方法 作为构造函数 通过它们的call()和apply()方法间接调用 原理 调用由函数对象，左圆括号，参数列表(逗号分隔)，右圆括号组成 每个参数表达式都会计算出一个值作为实参传递给声明时定义的形参 在函数体中存在一个形参的引用指向当前传入的实参列表 函数表达式的值成为调用表达式的值 ECMAScritp 3和非严格ECMAScript 5中，函数调用上下文(this)是全局对象。严格模式下是undefined 常用this判断是否严格模式 调用表达式 f() # 作为普通函数调用 o.m(x, y) # 函数表达式本身就是属性访问表达式, 此时函数作为一个方法调用, 方法调用的上下文是该调用对象o o[\u0026quot;m\u0026quot;](x, y) a[0](z) # 可以用方括号来方法调用 a.b.c() f().m() # 方法链, 链式调用, 返回this或构造对象 构造函数调用 方法名前带有new, 就是构造函数的调用 与普通的函数调用及方法调用在实参处理、调用上下文、返回值方面都不同 定义一类(class)对象，创建对象继承构造函数的prototype属性 class看作是对象类型的子类型 使用新对象作为调用上下文, 如new o.m()中，this不是o 如果return一个对象，则构造的就是这个对象，如果返回原始值或没有值，则忽略返回值 原理 计算实参表达式，传入函数内。没有形参，允许省略实参列表和圆括号，如 var o = new Object() # 无参时圆括号可以省略 创建空对象，继承构造函数的prototype, 试图初始化该对象，并将该对象作为调用上下文 尽管构造函数看起来像方法调用，但它用新对象作为调用上下文 所以 new o.m()看起来是方法调用，但它的调用上下文并不是o 通常不使用return关键字，显式返回构造的新对象 显式使用return时，如果没有值或是原始值，就忽略return。如果是对象，就返回return的对象 间接调用 call和apply 可以显式指定调用上下文，这样任何函数都可以作为任何对象的方法来调用 call使用自有的实参列表作为函数实参，apply以数组形式传入参数 实参和形参 不检查传入的参数类型和参数个数，所以要手动做参数检查 传入参数少时，剩下的形参都设置为undefined 所以在参数检查时，要给省略的参数赋默认值。如 a = a || [] a = a || [] 是习惯用法，用来代替if语句，前提是a必须预先声明 前面的参数可选且不传时，传入占位符null(也可以传undefined) 函数定义中使用/*optional*/来强调形参可选, 如 function f(o, /*optional*/ a) 可变长实参列表(实参对象) arguments 是类数组对象，可以通过数字下标访问传入的实参值 这种可以接收任意个数实参的函数 称为 不定实参函数(varargs function) 非严格模式下, 实参对象的数组元素是函数形参对应实参的别名，改变实参值时，实参对象中的值也改变 ECMAScript 5中移除了别名这个特性(实测没有移除) 非严格模式中, arguments是一个标识符，严格模式中，它是一个保留字 arguments的callee和caller属性 ECMAScript 5 严格模式中，对这两个属性的读写操作都会产生类型错误 非严格模式中, callee指代当前正在执行的函数，caller是非标准的，但大多数浏览器都实现了这个属性，指代调用callee的函数。 通过caller属性可以访问调用栈 可通过callee递归调用自身 var factorial = function(x){ if( x \u0026lt;= 1) return 1; return x * arguments.callee(x-1) } 对象属性作实参，如 easycopy({from: a, to: b, length: 4}) function easycopy(args){ args.from; args.from_start || 0; } 类型注释 function max(/*number*/a, /*optional*/b, /*array*/c, /*integer*/d, /*index*/e){ if(isArrayLike(c)){ if(isFinite(a)); } } 函数作为值 function a(){} # 定义创建函数对象，赋值给a。函数对象的名字是看不见 o.f = f # 将函数赋值给对象的属性，就称为方法 var a = [function() {}, 20] # 没有名字的函数，放在数组直接量中 函数的自定义属性 如当函数需要专属常量时，可在上面定义静态属性 如要求函数返回唯一整数，可以定义静态属性做个计数器， 如果要做缓存，也可以定义多个静态属性来缓存返回过的结果，属性名就是传入过的值 作命名空间 无法声明只在一个代码块中可见的变量。所以定义一个函数做临时命名空间 有些js扩展中(如mozilla的java script 1.7)可以使用let声明语句块内的变量, 如 let(x = 1){ print(x)} (function(){ }()); 匿名函数不会定义全局函数变量并运行, 定义了内部的局部变量 最外层圆括号是习惯写法，尽管有些时候没必要也不应当省略 闭包 js采用词法作用域(lexical scoping), 函数的执行依赖变量作用域。作用域在函数定义时决定，而非调用时 当前函数的变量保存在函数作用域内(闭包) 闭包指函数变量可以被隐藏于作用域链之内，象是函数将变量\u0026quot;包裹\u0026quot;了起来 每函数中引入当前作用域链 定义时与运行时 大多定义函数时的作用域链在调用函数时依然有效 调用函数时与定义函数时作用域链不是同一个时 如返回内部嵌套的函数a时，外部运行a，其作用域链仍然是a的作用域链而非外部作用域链 作用 捕捉局部变量并一直保存 原理 如果一个函数的局部变量定义在cpu栈中, 函数返回时它们的确不存在了 js中作用域链是一个对象列表，不是绑定的栈。 运行js函数a时, 都创建新的对象保存局部变量。该新对象添加到作用域链中 函数a返回时，从作用域链中删除该局部变量对象，等待垃圾回收 如果a有嵌套函数，每个嵌套函数各自对应一个作用域链 # 该嵌套函数的作用域链，保留a的局部变量对象 嵌套函数在a中局部变量对象中保存时，会随其一起从作用域链删除 嵌套函数被返回或被外部引用时, 该嵌套函数不被回收，且其自身作用域链中的自身局部变量对象、a的局部变量对象也不删除。 闭包的this值会随外部调用者而变动，所以要先将this转存。var self = this; 闭包中使用的arguments也会变动，也要转存。var outerArguments = arguments; 可调用对象 如\u0026quot;类数组对象\u0026quot;不是真正的数组，\u0026quot;可调用对象\u0026quot;不是函数，但所有函数都是可调用的 可调用对象使用越来越少 例如 ie8及之前的版本window.alert()和document.getElementById()使用了可调用的宿主对象 RegExp对象可以直接调用(如RegExp()), 是非标准特性, Netscape提出后被后续浏览器兼容 typeof RegExp可能是\u0026quot;function\u0026quot;也可以是\u0026quot;object\u0026quot; 最好不要对可调用RegExp对象有太多依赖，其可调用特性将来可能被删除 generator # 基本 generator生成的遍历器g, g[Symbol.iterator]()得到自己。继承它prototype上的方法 generator中this添加的属性, 生成的遍历器实例中没有, generator new相当于执行得到遍历器 g.bind(obj) 可以改变generator中的this 作为对象属性时写做 {* g() {}}, {g: function* () {}} 应用 状态机 协程(coroutine) generator是半协程(semi-coroutine), 只有generator函数的调用者，才能改变程序运行状态 将多个协作的任务写成generator, 用yield语句交换控制权 异步程序同步写法 部署iterator接口 可看作数组结构 yield 特点 惰性求值 在表达式中时加圆括号, 如'hello' + (yield 1)，字符串模板中`${yield}` var n = yield i; g.next(1) 来返回值给n, g.next()返回undefined 第一次调用g.next()不能传值，因为执行第一个yield之前的代码, 还没有yield来接收 var a = yield* g() 展开g()得到的generator(可展开所有iterator), 是for ... of的一种简写形式 g()中有return 时, a 得到return 的值 yield [a(), b()] 非展开，而是并列执行, 全部执行返回时返回 throw 特点 外部的throw语句只被外部捕获 generator中throw的错误先内部捕获，再抛出, g.throw(1)相当于从内部yield处抛出一个错误 generator抛出错误后不再能继续执行，再执行返回done=true var g = function* () {try {yield;} catch (e) {}} # 可以多个yield一个try catch , 而回调函数只能一个回调一个try catch var i = g(); i.next() try{i.throw('a'); i.throw('b') } catch(e){} # 内部捕获a, 外部捕获b return 特点 相当于强制内部return generator中有finally时, g.return()延迟到所有finally执行后执行，再结束 g.return(0) // {value: 0, done: true} 使用 function* f () { yield 1; yield 2; return 3; } var ff = f(), ff.next() # {value: 1, done: false}, {value: 2, done: false}, {value: 3, done: true}, {value: undefined, done: true} ## 没有return语句时, 去掉第三个结果，其它不变 自动执行 # 写执行器处理thunk和promise 非promise thunk函数, 把回调函数抽离出来 promise # 三种状态 进行中(pending) 完成(fulfilled) 失败(rejected) 状态转换 状态可以由pending转换成fulfilled，或pending转换成rejected promise的状态转换只发生一次，之后代码会执行，但抛出的错误不捕获 p2中return p1, 则p1的状态决定了p2的状态, 如果p1是resolved或reject, p2的回调立即执行 所以返回promise对象时, then的回调相当于返回promise的then的回调 新建即执行，不能取消。内部错误不抛出。无法得到具体pending状态 async # 特点 generator的语法糖, 自动执行generator, 处理promise 内置执行器，返回promise对象 使用 var asyncReadFile = async function () { try { var f1 = await readFile('/etc/fstab'); } catch (e) {} await p2.catch(function (e) {}) } class # 特点 所有方法在prototype上(constructor, static外)，不可枚举 无变量提升 类内部即严格模式 class A的A.name = 'A', 意义同函数名 语法 class Point { constructor(x, y) { # 不定义时，生成空constructor方法, this代表新生的实例 this.x = x, this.y = y; } toString() {return 'a'} [methodName]() {} get prop() {...} set prop(val) {} * [Symbol.iterator]() {} static sMethod() {} # 相当于直接在Point上定义, es6 内只有方法，没有属性 prop: 1 # es6中忽略, es7提案 static prop2: 2 # es6中忽略 es7提案 } Point.a = 1; # es6 静态属性只能在class外部定义 var point = new Point(2, 3); o-\u0026gt; var A = class B{}; # 这时类的名字是A, 而B只能在类内中指代自己 var A = class {}; var a = new class {}(); 继承 两条原型链 Object.setPrototypeOf(B.prototype, A.prototype) B.prototype.__proto__ = A.prototype # 作为构造函数, 子类B的prototype是A的实例 Object.setPrototypeOf(B, A) B.__proto__ = A # 作为一个对象, 子类B的原型是A(强行成为继承关系来得到A的静态属性) B.__proto__.__proto__ = A.__proto__, # 子类原型的原型是父类的原型 继承的特殊种类 class A {}, A.__proto__ = Function.prototype, A.prototype.__proto__ = Object.prototype class A extends null {}, A.__proto__ = Function.prototype, A.prototype.__proto__ = undefined o-\u0026gt; class A extends B { constructor(x, y, color) { # 默认construcotr为constructor(...args) {super(...args)}; super(x, y); # 调用B的constructor, 必须调用super来创建父类对象作用自己的prototype, 否则整个继承失败，报错 this.color = color # this必须在super调用之后才能使用, 否则没有prototype生成this, 报错 } } let cp = new A(1, 2, 'a') cp instanceof A // true cp instanceof B // true o-\u0026gt; 继承原生构造函数(es5不可以) es5机制决定先新建子类实例this, 再将父类属性添加到子类上。父类的内部属性无法获取(如Array的[[DefineOwnProperty]])。 es6允许继承原生父类构造函数定义子类, 即先新建父类this, 再用子类修饰, 父类的所有行为都可继承 function MyArray() {Array.apply(this, arguments)} MyArray.prototype = Object.create(Array.prototype, {constructor: { value: MyArray, writable: true, configurable: true, enumerable: true, }}) class MyArray extends Array { constructor(... args) { super(... args); } } o-\u0026gt; 用mixin来混合继承 class A extends mix(B, C) decorator # 介绍 编译时执行 相当于 class A {}, A = decorator(A) || A; 不能用于函数，因为函数提升? o-\u0026gt; 修饰类 function testable(target) { # target是被修饰的类, 参数2为属性名, 参数3为属性描述对象 target.isTestable = true; } function testable(val) { return function(target) { target.isTestable = val; } } @testable class A {} A.isTestable // true o-\u0026gt; 修饰类属性 function readonly(target, name, descriptor) { descriptor.writable = false; return descriptor; } class Person { @readonly name() {return 0} } 对象 # 基础 一种复合值。属性的无序集合，属性由名/值对组成，看作字符串到值的映射。 这种数据结构叫做散列(hash), 散列表(hashtable), 字典(dictionary), 关联数组(associative array) 常用来模拟静态对象或静态语言的结构体。也可以模拟json字符串 可以基于原型(prototype)继承属性，称作原型式继承(prototypal inheritance) 除了字符串、数字、true、false、null、undefined外，js中的值都是对象 字符串、数字、布尔值可以自动包装为对象(构造函数的实例) 对象操作通过引用(而非值)。 常见属性操作 创建(create) 设置(set) 查找(query) 删除(delete) 检测(test) 枚举(enumerate) 组成 属性的名/值对 + 属性特性(property attribute) + 对象特性(object attribute) 属性名可以是空字符串，不能重名 属性特性包括: 可写(writable attribute), 可枚举(enumerable attribute), 可配置(configurable attribute) 可配置表明是否可以删除或修改该属性 通过代码给对象创建的所有属性都是可写、可枚举、可配置的, ECMAScript 5 中可以改变 对象特性包括 对象原型(prototype) # 指向另外一个对象, 本对象继承它的原型 对象的类(class) # 一个标识对象类型的字符串 对象的扩展标记(extensible flag) # ECMAScript 5中指明是否可以向该对象添加新属性 分类 内置对象(native object) # 由ECMAScript定义的对象或类。如数组、函数、日期、正则表达式 宿主对象(host object) # js解释器( 如web浏览器)嵌入的宿主环境,如 HTMLElement对象 # 宿主环境定义的方法可当作普通js函数对象, 宿主对象可当作内置对象 自定义对象(user-defined object) # 运行中的js代码创建的对象 自有属性(own property) # 直接在对象中定义的属性 继承属性(inherited property) # 对象的原型对象中定义的属性 原型 每一个js对象(null除外)都与另一个对象(原型)关联，从原型继承属性。 内容 对象直接量创建的对象有同一个原型对象Object.prototype new的对象原型是构造函数prototype的属性的值 # 于是new Object()创建的对象继承自Object.prototype Object.prototype这个对象没有原型 具体 除Object.prototype的对象是普通对象，都有原型。 所有内置构造函数都继承Object.prototype 如, new Date()创建的对象同时继承Date.prototype和Object.prototype 这一系列的链接的原型对象就是\u0026quot;原型链\u0026quot;(prototype chain) 创建对象 {} ECMAScript 5中(ECMAScript3的部分实现), 保留字用作属性名可以不带引号 ECMAScript 3中保留字作属性名必须用引号 ECMAScript 3的IE中, 最后一个逗号不可以忽略 每次计算对象直接量，都会计算它的每个属性的值 new # 关键字创建 new后的函数是构造函数(constructor)。 Object.create() ECMAScript 5中出现的静态函数 参数1是原型对象, 参数2可选，对对象属性进一步描述 Object.create({x:2}) Object.create(null) 传入参数null来创建没有原型的新对象。 没有原型的对象没有toString等方法, 所有不能+运算 Object.create(Object.prototype) 创建普通对象 对象序列化(serialization) # json(JavaScript Object Notation) ECMAScript 5 api # stringify, parse的第二个参数可选，传入属性列表来定制序列化或还原操作 JSON.stringify() 支持对象, 数组, 字符串, 无穷大数字, true, false, null。NaN, Infinity, -Infinity序列化结果是null 日期stringify为日期字符串，parse不能还原成对象 只序列化对象的可枚举自有属性。不能序列化的属性自动省略掉 函数, RegExp, Error对象和undefined不能序列化和还原 JSON.parse() 创建对象 # 函数即对象，本身为构造方法 var obj = {}; # var obj = []是数组, 数组中Obj['aa']添加的是属性而非成员, 静态对象 function Obj(a, b){}; new Obj(a, b); function Obj(a, b){ thisf = new Array(); return new Object(a, b) }; Obj(a, b); 只能返回Obj里定义的新对象的实例(不能返回本身的实例) 内的变量函数静态。指向外部函数可动态 内对象为动态 new Obj(a, b); # 内变量函数动态(内存浪费) Obj.prototype.c = 'c' Obj.prototype.d = function(){}; Obj.prototype.e = new Array(); # prototype函数为静态函数, prototype对象为静态 function Obj(a, b){ } # 内部prototype, 与外部完全相同 if(typeof Obj._initialized == 'undefined'){ Obj.prototype.c = function(){}; Obj._initialized = true; } 最好方式: 内部定义变量和对象, prototype定义函数(防止new对象的函数动态)。 prototype定义函数可以在内部，也可以在外部。 扩展对象 Obj.prototype.extend # 添加或重写当前对象的属性 Object.prototype.extend # 所有对象上添加属性 属性 # 查询和设置 . [] ECMAScript 3中, 点运算符后的标识符不能是保留字。ECMAScript5(包括ECMAScript3的某些实现)中可以 []中必须返回可以转换为字符串的值 []的写法用了字符串索引，叫做关系数组(associative array), 散列或字典 属性不存在时自动创建 描述对象 value writable # 可修改 enumerable # 可枚举性 for...in, Object.keys(), JSON.stringify(), Object.assign(), Reflect.enumerate()会忽略不可枚举属性 for...in等价Reflect.enumerate(), 会返回继承的属性 configurable # 可配置 遍历属性 # 先遍历属性名是数值的属性，再遍历字符串，再遍历Symbol for ... in # 自身和继承的可枚举属性 Object.keys # 自身的可枚举属性(不含Symbol) Object.getOwnPropertyNames # 自身所有属性(不含Symbol) Object.getOwnPropertySymbols # 自身所有Symbol属性 Reflect.ownKeys # 自身所有属性 Reflect.enumerate # 同for ... in 访问错误 查询不存在的属性不报错, 返回undefined 对象不存在，会查询null和undefined的属性，会报错 建议写法: var len = book \u0026amp;\u0026amp; book.subtitle \u0026amp;\u0026amp; book.subtitle.length 只读的设置不报错，如 # ECMAScript 5的严格模式中会报错 Object.prototype = 0; 设置属性失败的情况 o中属性p是只读的 # defineProperty()可以 o中属性p是继承属性，且它是只读的 o没有属性p, o没有使用p的setter方法, o可扩展性为false 删除属性 delete 删除成功，属性不存在，不是属性访问表达式时，返回true 属性可配置性为false，非严格模式下返回false, 严格模式下抛出异常 全局对象可以不用属性访问表达式, 如 delete x; 严格模式下, delete x; 会报语法错误, 必须delete this.x 只是断开联系 只删除自有属性，不能删除继承属性 继承属性可以从原型对象上删除它 a = {p:{x:1}}; b= a.p; delete a.p; 执行后p.x还是1。因为属性的引用依然存在 会内存泄漏，所以在销毁对象时，要遍历属性中的属性，依次删除 检测属性 in # 检测自有属性和继承属性 \u0026quot;x\u0026quot; in o; o.x !== undefined # 同in，但没法区分属性的值为undefined时的属性，in可以 # !==可以区分null和undefined, 所以用!== hasOwnProperty() # 只检测自有属性 o.hasOwnProperty(\u0026quot;x\u0026quot;); propertyIsEnumerable() # 自有属性且可枚举 o.propertyIsEnumerable(\u0026quot;x\u0026quot;) 枚举属性 # ECMAScript 3 的不可枚举属性不能得到 for/in ECMAScript 5之前, 工具库给Object.prototype添加的属性必须可枚举 所以for/in会枚举出来，要用hasOwnProperty(p)来过滤 Object.keys() # ECMAScript 5中定义，返回可枚举的自有属性名数组 Object.getOwnPropertyNames() # ECMAScript 5中定义，返回自有属性名数组 getter和setter 通常用来表示同一组数据的两种方法(如笛卡尔坐标系表示法和极坐标系表示法) 也用于检测属性的写入和读取值 ECMAScript 5中属性值可以用方法替代，就是getter和setter, 叫做存取器属性(accessor property) 是访问描述符，相对数据描述符(如writable) 普通的属性叫做数据属性(data property), 只有一个简单的值 存取器属性不具有可写性(writable attribute) 作为替代, 只有getter, 则只读。只有setter, 则只写。同时拥有, 则可读写 读取只写属性总是返回undefined 存取器属性是可以继承的 定义 var o = { data_prop: 1, get accessor_prop(){}, # 函数中的this表示当前对象o set accessor_prop(value){} }; var descriptor = Object.getOwnPropertyDescriptor(o, 'accessor_prop'); 'get' in descriptor // true 'set' in descriptor // true 例子 var p = { $x: 1.0, $y: 1.0, get r () {return Math.sqrt(this.x * this.x + this.y * this.y);}, set r (newvalue) { var oldvalue = Math.sqrt(this.x * this.x + this.y * this.y); var ratio = newvalue/oldvalue; this.x *= ratio; this.y *= ratio; }, get theta () {return Math.atan2(this.y, this.x); } } 例子 var serialnum = { # 序列 $n: 0, # $暗示私有属性 get next(){return this.$n++;}, set next(n){ if(n \u0026gt;= this.$n) this.$n = n; else throw \u0026quot;序列号的值不能比当前值小\u0026quot;; } } 例子2 var random = { # 返回不同数量范围的随机数 get octet(){ return Math.floor(Math.random() * 256)}, get uint16(){ return Math.floor(Math.random() * 65536)}, get int16(){ return Math.floor(Math.random() * 65536) - 32768} }; 属性的特性 # ECMAScrit 3这些特性不可以配置, ECMAScript 5中提供查询和设置的api 作用 给原型对象添加方法，设置该方法为不可枚举，看起来像内置方法 给普通对象定义不能修改或删除的属性，实现\u0026quot;锁定\u0026quot; 组成 值(value), 可写性(writable)、可枚举性(enumerable)、可配置性(configurable) 存取器特性是读取(get)、写入(set)、可枚举性、可配置性 原理 ECMAScript 5定义了 属性描述符(property descriptor)对象, 代表4个特性 该对象的属性有value, writable, enumerable, configurable, 代表4个特性 存取器属性描述符用get和set代替value和writable writable, enumerable, configurable是布尔值 get和set是函数值, value什么都可以 调用 # 新建属性的默认特性对象为false或undefined Object.getOwnPropertyDescriptor(o, p) 获得对象o的p自有属性的 属性描述符对象 要得到继承属性的特性, 要遍历原型链 Object.defineProperty(o, \u0026quot;x\u0026quot;, { # 新建或修改自有属性的特性, 传入对象和属性名与属性描述符对象 value: 1, writable: true, enumerable: false, configurable: true }); Object.defineProperty(o, \u0026quot;x\u0026quot;, {get: function(){ return 0; }}); 修改x为存取器属性 返回修改后的对象 不允许创建或修改的属性，抛出类型错误异常 规则(违反则抛异常) 对象不可扩展，可以编辑已有属性, 不能添加 属性不可配置, 不能修改可配置性和可枚举性 存取器属性不可配置, 不能修改getter, setter方法, 不能转换为数据属性 数据属性不可配置，不能转换在存取器属性 数据属性不可配置，不能可写性从false修改为true 数据属性不可配置且不可写, 不能修改值。可配置但不可写时可以修改值 实际上自动标记为可写，再改值，再转换为可写 Object.defineProperties({}, { x: {value: 1, writable: true, enumerable: true, configurable: true}, y: {value: 1, writable: true, enumerable:true, configurable:true}, r: { get: function(){return Math.sqrt(this.x * this.x + this.y * this.y)}, enumerable: true, configurable: true } }) 新建或修改多个属性及特性。第一个参数是修改对象，第二个参数是映射表 返回修改后的对象 不允许创建或修改的属性，抛出类型错误异常 老式api(ECMAScript 5之前，非IE浏览器) __lookupGetter__() __lookupSetter__() # 返回一个属性的getter和setter __defineGetter__() __defineSetter__() # 定义getter和setter, 第一个参数是属性名, 第二个参数是getter或setter方法 对象三个属性 包括 原型(prototype) 类(class) 可扩展性(extensible attribute) 原型 api Object.getPrototypeOf() # ECMAScript 5出现, 传入对象返回原型 o.constructor.prototype # 得到对的原型，对于Object.create()创建的对象常不是这样 p.isPrototypeof(o) # 检测p是否是o的原型(或牌原型链中)，与instanceof运算符类似 __proto__ # Mozilla实现的js有的属性, safari和chrome也支持 类属性 表示对象类型信息的字符串, 用toString()方法可以得到 ECMAScript 3和5 都不能设置这个属性，只能间接查询 js内置构造函数创建的对象类属性与函数名称相匹配 对象直接量、Object.create、自定义构造函数 创建的对象类属性是\u0026quot;Object\u0026quot; 对于自定义类来说，没办法通过类属性来区分对象的类 api toString() # 返回如 [object class], 提取class, 很多对象的toString方法重写了, 要间接调用Function.call()方法 function classof(o){ if(o === null) return \u0026quot;Null\u0026quot;; if(o === undefined) return \u0026quot;Undefined\u0026quot;; # ECMAScript 5中不需要对null和undefined作处理 return Object.prototype.toString.call(o).slice(8, -1); } 可扩展性 表示是否可以给对象添加新属性。ECMAScript 5中 内置对象和自定义对象都显式可扩展 宿主对象可扩展性由js引擎定义 api # preventExtensions, seal, freeze 都返回传入的对象 Object.esExtensible() # 判断对象是否可扩展 Object.preventExtensions() # 转换对象为不可扩展, 参数为待转换对象, 对象转换不可扩展后，无法再转换回来, 给不可扩展对象原型添加属性, 对象同样会继承新属性 Object.seal() # 对象设置不可扩展, 同时对象自有属性不可配置, 已有属性标记为可写的依然可配置, seal后的对象不能解封 Object.isSealed() # 检测对象是否封闭 Object.freeze() # 除了seal外，将自有数据属性设置为只读, setter方法不受影响 Object.isFrozen() # 检测是否冻结 继承 介绍 js对象有自有属性(own property)，有从原型继承来的属性 原型链(prototype chain) # 原型，原型的原型 ... 属性的查询先找自有属性，再找原型链 属性修改时, 先检查属性是否允许赋值。 总在自有属性修改或创建，不修改原型链上的对象。这就是属性的覆盖(override) 继承的对象有setter方法且是accessor属性时，修改属性时会由当前对象(非原型对象)调用setter方法。 由当前对象调用，所以还是不会修改原型链 setter方法如setTitle() inherit(p)函数 function inherit(p){ if(p == null) throw TypeError(); if(Object.create) return Object.create(p); var t = typeof p; if(t !== \u0026quot;object\u0026quot; \u0026amp;\u0026amp; t !== \u0026quot;function\u0026quot;) throw TypeError(); function f(){}; f.prototype = p; return new f(); } var o = {x: \u0026quot;don't change this value\u0026quot;}; library_function(inherit(o)); # 可以防止对o的意外修改 数组 # 介绍 数字索引 # 最大索引 2^32 - 2, 实现经过优化, 数字索引访问比访问常规属性快很多 元素无类型 数组是动态, 根据需要它们会增长或缩减 数组可能是稀疏的, 索引不一定连续, length对于稀疏数组取最大索引+1 原理 数组对象使用小于0 ~ 2^32 - 2 非负整数属性名时, 自动维护其length属性值 [] 索引内的数字作为索引创建和访问, 其它作为属性 a['1'] 同 a[1] 同 a[1.000] 数组可以原型继承, 可以定义getter, setter方法 数组元素可以delete, in, for/in # delete a[0], 0 in a 稀疏数组 稀疏数组比稠密数组更慢, 内存利用率更高, 查找元素与常规对象属性查找时间一样长 for/in时会跳过未有元素 a = new Array(5) a = [, , ,] a = [1, , 3] # 旧版本实现中, [1,,3]与[1,undefined, 3]是一样的，不是稀疏数组 a[1000] = 0 创建与调用 var misc = [1.1, , true] # 第二个是undefined new Array() new Array(10) # 预分配数组空间 new Array(5, 4, \u0026quot;testing\u0026quot;) a[0] a.length length大于每一个索引 对lenght赋值, 小于length索引的元素将删除, 如length=0清空数组 Object.defineProperty()让数组的length变成只读 Object.defineProperty(a, \u0026quot;length\u0026quot;, {writable: false})来避免删除元素 让数组无线不能配置也可以，如Object.seal, Object.freeze方法 添加删除 a[1] = \u0026quot;a\u0026quot;; a.push(\u0026quot;zero\u0026quot;, \u0026quot;one\u0026quot;) delete a[1] a.pop() # 反push a.shift() # 头部删除, 重改所有元素索引 a.unshift() # 反shift, 头部插入元素 splice() # 通用方法插入, 删除, 替换数组元素, 根据需要修改length属性 遍历 for(var i = 0; i \u0026lt; a.length; i++) # 判断undefined for(var index in a){ # 会遍历出Array.prototype中的方法, 要进行过滤, ECMAScript 允许for/in遍历顺序不同, 一般是升序的, 如果同时有属性和元素，很可能是创建顺序 if(!a.hasOwnProperty(i)) continue; // if(String(Math.floor(Math.abs(Nuber(i)))) !== i) continue; # 跳过不是正整数的i } a.forEach(function(x){}) # ECMAScript 5定义的新方法 多维数组 # js不支持真正的多维数组，可以用数组模拟 var a = new Array(10) a[0] = new Array(10) a[0][0] 空位问题 Array(3) // [, , , ] # 没有0位置, 但length = 3, 不同于有0位置但值为undefined, es5中对空位处理很不一致, 一般是跳过, es6会将空位值转为undefined 类数组对象 # 与数组相似的对象, 字符串虽然与数组类似，但length没有限制, 最好不看作类数组对象 特性 自动更新length属性, length设置后自动截断数组 从Array.prototype中继承了一些有用的方法 类属性(class)为\u0026quot;Array\u0026quot;(Date等类也是\u0026quot;Date\u0026quot;) 创建 # 数组的方法对于自定义的类数组对象是通用的, 虽然不能继承Array.prototype, 但可以间接调用Function.call 要求 自动维护length属性 下标是数字字符串并在数组下标范围内 var a = {\u0026quot;0\u0026quot;: \u0026quot;a\u0026quot;, \u0026quot;1\u0026quot;: \u0026quot;b\u0026quot;} 作为数组的字符串 介绍 ECMAScript 5中，字符串类似只读数组。访问如下 s.charAt(0) s[0] Array.isArray(s)是false 通用字符串方法可以乃至字符串中，如 # 但字符串是不可变值的，所以中push, sort, reverse, splice在字符串上是无效的, 出错时没有提示 Array.prototype.join.call('abc', \u0026quot; \u0026quot;) # \u0026quot;a b c\u0026quot; 二进制数组 介绍 ArrayBuffer, TypedArray, DataView TypedArray按小端字节序来处理ArrayBuffer, 大端字节序可以自定义DataView TypedArray 溢出 正向溢出(overflow) uint8[0] = 256 // 0 # 值为 数据类型最小值 + 余值 - 1, 这里为 0 + 1 - 1 int8[0] = 128 // -128 # -128 + 1 - 1 负向溢出(underflow) uint8[0] = -1 // 255 # 值为 数据类型最大值 - 余值 + 1, 这里为 255 - 1 + 1 int8[0] = -129 // 127 # 127 - 1 + 1 Uint8ClampedArray负向溢出都为0, 正向溢出都为255 场景 o-\u0026gt;ajax中 xhr.responseType设置为 'arraybuffer'来接收二进制数据(也可以设blob) o-\u0026gt; canvas中 ctx.getImageData(0, 0, canvas.width, canvas.height) uint8ClampedArray = imageData.data; o-\u0026gt;　websocket中 socket.binaryType = 'arraybuffer' var arrayBuffer = event.data; socket.send(new Uint8Array(4).buffer); o-\u0026gt; fetch api中 返回request.arrayBuffer()得到arrayBuffer数据 o-\u0026gt; file api中 reader.readAsArrayBuffer(file); reader.onload = function() { var arrayBuffer = reader.result; } 集合 # Set 数据唯一 Nan等于自身 WeakSet 成员只能是对象 成员弱引用，垃圾回收不考虑其引用，所以不能引用其成员，所以WeakSet不可遍历，因为刚遍历出的成员可能已删除 可用于储存dom节点，实时判断是否存在，且防止内存泄漏 Map 各种类型都可作为键, 键唯一覆盖, NaN等于自身, +0 等于 -0 WeakMap 只接受对象作key 元素被回收后, 自动移除对应的键值对 适用于dom节点作键名，部署关联外部的私有属性(外部对象删除后，私有属性同步删除)，不会内存泄漏 遍历器 介绍 默认三种结构支持, Array, Set, Map。Object不支持，因为不确定遍历顺序 字符串是类数组，有原生的iterator接口 内部调用方式 解构 let [x, y] = new Set().add(1).add(2); 扩展运算符 [...iterable] yield* iterable 参数 for ... of Array.from() Map(), Set(), WeakMap(), WeakSet() Promise.all() Promise.race() 实现 iterable[Symbol.iterator] = function* () { yield 1; yield 2; } iterable[Symbol.iterator] = function () { return { next(){}, return () { return {done: true}} # return 在for ... of 提前退出(出错, break, continue), 可以用于释放资源, return 方法必须返回一个对象，这是Generator规格规定的 throw() {} # 配合Generator使用 }; } 使用 var result = iterator.next() while(!result.done) { var x = result.value; result = iterator.next(); } proxy # 介绍 元编程(meta programming), 在对象外层进行代理 在obj.proxy上设置Proxy对象，该对象的操作会变成对Proxy对象的操作 var obj = new Proxy({}, { get: function (target, key, receiver) { return Reflect.get(target, key, receiver); }, set: function (target, key, value, receiver) { return Reflect.set(target, key, value, receiver); } }); reflect # 介绍 将Object上一些明显属于语言内部的方法(如Object.defineProperty)放到Reflect上 修改Object上原有方法，变得更合理, 如Object.defineProperty在无法定义属性时抛出异常, 而Reflect.definePropert则返回false 让Object操作变成函数作为, 如name in obj, delete obj[name]变成Reflect.has, Reflect.deleteProperty 让Proxy上方法与Reflect方法对应，让Proxy的对象操作默认行为在Reflect上执行 正则 # 基本字符 会精确匹配一段字符，如hi。这段字符可以出现多次 字面量 /^[a-z]+$/.text(str); # ^代表开头, $是结尾 转义 \\ 元字符 # metacharacter . # 匹配除换行符以外任意字符 \\b # 表示单词的开头或结尾，也就是单词的分界。只匹配一个位置\\s\\S \\bhi\\b # hi单词 \\d # 表示数字 \\s # 匹配任意空白符，包括空格、tab、换行、中文全角空格等 \\s\\S # 匹配包括\\n在内的所有字符 \\w # 匹配非特殊字符，包括字母、数字、下划线或汉字 ^ # 匹配开头 $ # 匹配结尾 反义 \\W # 非字符 \\S # 非空白 \\D # 非数字c \\B # 非单词位置 非 [^x] # 非x, [^aeiou] 除了aeiou以外的任意字符 限定字符 {2} # 表示前面的内容出现2次, {5, 12}内容出现5到12次, {5, }内容出现5或更多次 ? # 零次或一次 * # 零个或多个 + # 表示一个或多个 字符类 [aeiou] # 匹配其中的一个, [.?!] 匹配.或?或! [0-9] # 同\\d, [a-z0-9A-Z] 同\\w 分枝条件 | # jpg|png, 每个分支都从第一个分支开始匹配, 如\\d{5}|\\d{5}-d{4}只能匹配11111或11111-2222中的11111 分组 # 零宽断言只占用不消费 () 语法 (exp) (?\u0026lt;name1\u0026gt;exp) # 组命名 (?:exp) # 消费exp, 不捕获匹配的文本，也不分配组号 (?=exp) # 零宽断言，正向前瞻，后面能匹配表达式exp \\b\\w+(?=ing\\b) # 匹配以ing结尾单词的前面部分，如dancing中的danc /(\\w)\\1{2}(?=(\\w)\\2{2})/g # 匹配所有在3个连续相同字符前的相邻3个连续相同字符, aaalllsss0tAAAnnn999结果是aaa, lll, AAA, nnn (?\u0026lt;=exp) # 零宽断言，正向后瞻，前面能匹配表达式exp (?\u0026lt;=\\bre)\\w+\\b # 匹配以re开头单词的后半部分，如reading中的ading (?!exp) # 零宽断言，负向前瞻，后面不匹配exp的位置, js不支持 \\b\\w*q(?!u)\\w*\\b # 匹配一个单词，该单词包含后面不是字母u的字母q \\d{3}(?!\\d) # 匹配三位数字，且它们后面不能有数字 \\b((?!abc)\\w)+\\b # 匹配不包含连续字符串abc的单词 (?\u0026lt;!exp) # 零宽断言，负向后瞻，前面不匹配exp的位置, js不支持 (?\u0026lt;![a-z])\\d{7} # 匹配前面不是小写字母的七位数字 (?#comment) # 注释 后向引用 # 分组捕获后会自动编号，从左到右，1234。后向引用用于引用前面匹配到的文本，如 \\1 代表分组1匹配的文本 \\b(\\w+)\\b\\s+\\1\\b # 匹配重复的单词, 如go go (?\u0026lt;Word\u0026gt;\\w+) 或 (?'Word'\\w+) # 把\\w+的组名指定为Word, 用\\k\u0026lt;Word\u0026gt;引用 贪婪与懒惰 o-\u0026gt; 包含能接受重复限定符时，会匹配尽可能多的字符。如a.*b o-\u0026gt; a.*?b会懒惰匹配 懒惰限定符 *? 重复懒惰匹配任意次 +? 重复懒惰匹配1次或多次 ?? 重复懒惰匹配0次或1次 {n, m}? 重复懒惰匹配n到m次 {n,}? 重复懒惰匹配n次以上 平衡组/递归匹配 (?'group') 把捕获的内容命名为group，并压入栈(Stack) (?'-group') 从栈中弹出最后压入的名为group的捕获内容。如果栈为空，则匹配失效 (?(group)yes|no) 如果栈中存在名为group的捕获内容，继续匹配yes部分的表达式，否则则继续匹配no部分的表达式 示例 # 平衡组最常见的应用是匹配HTML 匹配xx\u0026lt;aa\u0026lt;bbb\u0026gt;\u0026lt;bbb\u0026gt;aa\u0026gt;yy 思路 每碰到左括号，就压入一个Open, 每碰到右括号，弹出一个 最后看栈是否空，如果否则表示不配对，应该失败 正则表达式引擎会进行回溯(放弃最前面或最后面一些字符), 尽量使整个表达式得到匹配 \u0026lt; # 最外层的左括号 [^\u0026lt;\u0026gt;]* # 后面非括号的内容 ( ( (?'Open'\u0026lt;) # 又碰到了左括号, 压入一个Open [^\u0026lt;\u0026gt;]* # 后面非括号内容 )+ ( (?'-Open'\u0026gt;) # 碰到了右括号, 擦掉一个Open [^\u0026lt;\u0026gt;]* # 后面非括号内容 )+ )* (?(Open)(?!)) # 负向前瞻，判断栈中还有没有Open, 有则匹配失败 \u0026gt; # 最外层右括号 ) 特点 # o-\u0026gt; js中不支持 回顾后发断言 o-\u0026gt; 可以跟三个flag，比如/something/igm i表示不区分大小写 g表示匹配多个 g会影响String.prototype.match()和RegExp.prototype.exec()的行为 match中加g会返回数组，不加g返回比较详细的信息 exec中加g，且正则存在变量中时,该正则变量执行exec后会存储信息, 如 var re = /h(.*?)\\b/g; re.exec('hello helloo') 执行三次，匹配内容有变化 m表示，^$可以匹配每一个的开头和结尾 o-\u0026gt; api RegExp exec # 执行第一个, exp本身保留执行状态 exp = /#/ exp.exec('##') test String replace # 替换第一个, 'abc - 123 - #$*' 'John Smith'.replace(/(\\w+)\\s(\\w+)/, '$2, $1') 'abc123#$*'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, function replacer(match, p1, p2, p3, offset, string) { return [p1, p2, p3].join(' - '); }); replaceAll match # 不能有g选项，只得到第一个匹配 .net中处理选项 IgnoreCase # 忽略大小写 Multiline # 多行模式, 更改^$的含义为一行首和行尾, $表示\\n之前的位置以及字符串结束前的位置 Singleline # 单行模式(可以与Multiline通用)，更改.的含义，便它与每一个字符匹配(包括\\n) IgnorePatternWhitespace # 忽略空白，会忽略表达式中非转义空白并启用#作为标记注释 ExplicitCapture # 显式捕获，仅捕获已被显式命名的组 常用 # \u0026lt;a[^\u0026gt;]+\u0026gt; # 用尖括号括起来的以a开头的字符串 ^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ # 密码的强度必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间 ^[\\\\u4e00-\\\\u9fa5]{0,}$ # 字符串只能是中文 ^\\\\w+$ # 由数字，26个英文字母或下划线组成的字符串 [\\\\w!#$%\u0026amp;'*+/=?^_`{|}~-]+(?:\\\\.[\\\\w!#$%\u0026amp;'*+/=?^_`{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[\\\\w](?:[\\\\w-]*[\\\\w])? # 校验E-Mail 地址 ^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$ # 校验身份证号码 15位 ^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$ # 校验身份证号码 18位 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ # “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年 ^[0-9]+(.[0-9]{2})?$ # 金额校验，精确到2位小数 ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$ # 国内 13、15、18开头的手机号正则表达式 ^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ # 判断IE的版本 \\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b # 校验IP-v4地址 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) # 校验IP-v6地址 /^[a-zA-Z]+:\\\\/\\\\// # 检查URL的前缀 ^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%\u0026amp;=]*)? # 提取URL链接 ^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?\u0026quot;\u0026lt;\u0026gt;|]+\\\\.txt(l)?$ # 文件路径及扩展名校验 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ # 提取Color Hex Codes \\\\\u0026lt; *[img][^\\\\\\\\\u0026gt;]*[src] *= *[\\\\\u0026quot;\\\\']{0,1}([^\\\\\u0026quot;\\\\'\\\\ \u0026gt;]*) # 提取网页图片 (\u0026lt;a\\\\s*(?!.*\\\\brel=)[^\u0026gt;]*)(href=\u0026quot;https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?'.implode('|(?:www\\\\.)?', $follow_list).'))[^\u0026quot;]+)\u0026quot;((?!.*\\\\brel=)[^\u0026gt;]*)(?:[^\u0026gt;]*)\u0026gt; # 提取页面超链接 ^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} # 查找CSS属性 \u0026lt;!--(.*?)--\u0026gt; # 抽取注释 \u0026lt;\\\\/?\\\\w+((\\\\s+\\\\w+(\\\\s*=\\\\s*(?:\u0026quot;.*?\u0026quot;|'.*?'|[\\\\^'\u0026quot;\u0026gt;\\\\s]+))?)+\\\\s*|\\\\s*)\\\\/?\u0026gt; # 匹配HTML标签 '12345678901'.replace(/(\\d{3})\\d{4}(\\d{4})/, '$1****$2') # 替换中四位到* '1111111'.replace(/([\\d]{3})(?=[\\d]+)/g, '$1-') # 替换为 '111-111-1' 元字符扩展 # \\a # 报警字符 \\t # 制表符 \\v # 竖向制表符 \\r # 回车 \\f # 换页符 \\n # 换行符 \\e # Escape \\0nn # ASCII码中八进制代码为nn的字符 \\xnn # ASCII码中十六进制代码为nn的字符 \\unnnn # Unicode码中十六进制代码为nnnn的字符 \\cN # ASCII控制字符，如\\cC 代表ctrl + c \\A # 字符串开头，同^但不受多行选项影响 \\Z # 字符串结尾或行尾，不受多行选项影响 \\z # 字符串结尾，同$但不受多行选项影响 \\G # 当前搜索的开头 \\p{name} # Unicode中命名为name的字符类，如\\p{IsGreek} (?\u0026gt;exp) # 贪婪子表达式 (?\u0026lt;x\u0026gt;-\u0026lt;y\u0026gt;exp) # 平衡组 (?im-nsx:exp) # 在子表达式exp中改变处理选项 (?im-nsx) # 为表达式后面的部分改变处理选项 (?(exp)yes|no) # 把exp当作零宽正向先行断言，如果能匹配，使用yes作为此组表达式，否则使用no (?(exp)yes) 只使用空表达式为no (?(name)yes|no) 命名为name的组捕获到内容，使用yes 风格 # o-\u0026gt; 最好js和html用独立的引号风格，如 html双引号, js单引号 o-\u0026gt; 始终用var之类来声明变量，不用未声明变量 o-\u0026gt; let和const取代var, 全局常量使用const o-\u0026gt; 特意将变量声明放在函数体顶部, 而不是使用变量之外, 来反映真实的作用域声明提前 o-\u0026gt; 多用解构 const [first, second] = arr # 数组取元素 function f({a, b}) {} # 对象解构给函数赋值 function f() {return {a, b}}, const {a, b} = f() # 函数返回值解构 var arr2 = [...arr] # 扩展运算符拷贝数组 o-\u0026gt; 单行定义对象不逗号结尾(以后不扩展), 多行时逗号结尾(以后可能会扩展), 尽量用简洁的写法 {a: 1, b} { [getKey('a')], } o-\u0026gt; Array.from转换类数组到数组 o-\u0026gt; 匿名函数 (() =\u0026gt; {})(), 同时绑定了this为当前作用域 o-\u0026gt; 不使用arguments, 使用rest运算符 o-\u0026gt; 函数使用默认值 function f (opts = {}) {} o-\u0026gt; 用Map取代Object, 因为Map内建遍历机制, key可为对象。只能要数据转换时用Object o-\u0026gt; 总是用class取代需要的prototype操作, 因为class写法更简洁。extends也更简单, 不会有破坏instanceof运算的危险 o-\u0026gt; 模块使用es6的机制, 模块只能一个输出时用export default, 多输出时用export, 不要export 和export default混合使用 o-\u0026gt; 运算符 var t = o \u0026amp;\u0026amp; o.a || '' # 有o时取o.a, 无o时取'', 因为\u0026amp;\u0026amp;的优先级比||高 var ifExist = !!o.a # 转换成布尔类型, 当然o.a = 0 什么的值时， 会判断失误，所以用来判断对象 o-\u0026gt; 判断类型 typeof a === \u0026quot;string\u0026quot; # 数组等其他Object类型通通是Object a instanceof Array # 判断Object类型的具体类型 a.constructor == Array # 判断构造函数 Object.prototype.toString.call(o) === '[object Array]' # 用toString判断 o-\u0026gt; 柯里化 function currying (fn, n) { return function (m) { return fn.call(this, m, n); } } function tailFactorial(n, total) { # 尾递归调用优化 if(n === 1) return total; return tailFactorial (n - 1, n * total); } const factorial = currying(tailFactorial, 1); factorial(5) o-\u0026gt; 尾递归 function factorial (n, total = 1) { if(n === 1) return total; return factorial(n - 1, n * total); } 浏览器 # js执行顺序 当页面载入时，会执行位于 body 部分的 JavaScript。 当被调用时，位于 head 部分的 JavaScript 才会被执行。 常用函数 # 基础扩展 # 循环变量作用域 function constfunc(v){ return function(){return v} } var funcs = [] for(var i = 0; i \u0026lt; 10; i++){ funcs[i] = constfunc(i) } 闭包序列 var uniqueInteger = (function(){ var counter = 0; return function(){return counter++;} }()); seq = uniqueInteger() id = seq() 闭包计数器 function counter(){ var n = 0; return { count: function(){return n++;}, reset: function(){n = 0;} }; } 属性存取器 function counter(n){ return{ get count() {return n++}, set count(m){ if(m \u0026gt;= n) {n = m } else {throw Error(\u0026quot;count can only be et to a larger value\u0026quot;)} } } } var c = counter(1000); c.count; 属性define Object.defineProperty(Object.prototype, \u0026quot;extend\u0026quot;, { writable: true, enumerable: false, configurable: true, value: function(o){ var names = Object.getOwnPropertyNames(o); for(var i = 0; i \u0026lt; names.length; i++){ if(names[i] in this) continue; var desc = Object.getOwnPropertyDescriptor(o, names[i]); Object.defineProperty(this, names[i], desc); } } }); 私有属性 function addPrivateProperty(o, name, predicate){ var value; o[\u0026quot;get\u0026quot; + name] = function(){return value;} o[\u0026quot;set\u0026quot; + name] = function(v){ if(predicate \u0026amp;\u0026amp; ! predicate(v)) {throw Error(\u0026quot;set\u0026quot; + name + \u0026quot;: invalid value \u0026quot; + v)} else {value = v} }; } var o = {} addPrivateProperty(o, \u0026quot;Name\u0026quot;, function(x){ return typeof x == \u0026quot;string\u0026quot;;}); o.setName(\u0026quot;A\u0026quot;); o.setName(o); 嵌套属性名 function getAllPropertyNames = function(obj){ var props = []; do { props = props.concat(Object.getOwnPropertyNames(obj)); } while (obj = Object.getPrototypeOf(obj)); return props; } 嵌套属性名2 function keys(o){ if(typeof o !== \u0026quot;object\u0026quot;) throw TypeError(); var result = []; for(var prop in o){ if(o.hasOwnProperty(prop)) result.push(prop); } return result; } 嵌套累加 function flexisum(a){ var total = 0; for(var i = 0; i \u0026lt; arguments.length; i++) { var element = arguments[i], n; if(element == null){ continue; } else if(isArray(element)){ n = flexisum.apply(this, element); } else if(typeof element === \u0026quot;function\u0026quot;){ n = Number(element()); } else{ n = Number(element); } if(isNaN(n)){ throw Error(\u0026quot;flexisum(): can't convert \u0026quot; + element + \u0026quot; to number\u0026quot;); } total +=n; } return total; } 泛函代理, monkey-patching 'this' function trace(o, m){ var original = o[m]; o[m] = function(){ return original.apply(this, arguments); } } 兼容ECMAScript 3实现bind function bind(f, o){ if(f.bind) {return f.bind(o)} else { return function(){ return f.apply(o, arguments); } } } 函数式 # thunk function thunk (fileName) { return function (callback) { return fs.readFile(fileName, callback) } } extend, 同名覆盖 function extend(o, p){ for(prop in p){ o[prop] = p[prop]; } return o } merge, 同名不覆盖 function merge(o, p){ for(prop in p){ if(o.hasOwnProperty[prop]) {continue} o[prop] = p[prop];s } return o; } restrict, 删除非公共属性 function restrict(o, p){ for(prop in o){ if(!(prop in p)) delete o[prop]; } return o; } substract, 删除公共属性 function subtract(o, p){ for(prop in p){ delete o[prop]; } return o; } union, extend产生新对象 function union(o, p) { return extend(extend({}, o), p);} intersection, restrict产生新对象 function intersection(o, p){ return restrict(extend({}, o), p);} mixin function mix (...mixins) { class Mix {} for (let mixin of mixins) { copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); } return Mix; } function copyProperties(target, source) { for(let key of Reflect.ownKeys(source)) { if(key !== 'constructor' \u0026amp;\u0026amp; key !== 'prototype' \u0026amp;\u0026amp; key !== 'name') { let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); } } } 混合继承 class A extends mix(B, C) {} mixins方法不被覆盖 let Mixin1 = (superclass) =\u0026gt; class extends superclass { foo () {if(super.foo) super.foo()} } let Mixin2 = (superclass) =\u0026gt; class extends superclass { foo () {if(super.foo) super.foo()} } class S { foo() {} } class C extends Mixin1(Mixin2(s)) { foo() {super.foo()} } new c().foo() // C, Mixin1, Mixin2, S trait # 同mixins 额外功能: 防止同名方法冲突, 排除混入某些方法，为混入方法起别名等 @traits(A, B) class C() generator # 状态机 generator clock var clock = function* (_) { while(true) { yield _; console.log('Tick'); yield _; console.log('Tock'); } } 非generator实现 var ticking = true; var clock = function() { if (ticking) {console.log('Tick');} else {console.log('Tock');} ticking = !ticking } 递归next function run(fn) { var gen = fn(); function next (err, data) { var result = gen.next(data); if (result.done) {return result.value;} result.value(next); } next(); } run(gen); generator, promise, 递归next2 var readFile = function(fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(err, data) { if(err) {reject(err);} resolve(data); }) }) } var gen = function* () { var f1 = yield readFile('/etc/fstab'); } function run(gen) { var g = gen(); function next(data) { var result = g.next(data); if (result.done) {return result.value;} result.value.then(function(data) { next(data); }) } next() } run(gen); co, thunkify var readFile = thunkify(fs.readFile); var gen = function* () { var r1 = yield readFile('/etc/fstab'); var r2 = yiled readFile('/etc/shells') } co(gen) mixins注解 function mixins (...list) { return function (target) { Object.assign(target.prototype, ...list) } } const Foo = { foo() {} } @mixins(Foo) class MyClass() api # 全局 # 属性 Infinity # 表示正无穷大 NaN # 指示是不是数字, Infinity与NaNECMAScript中可读写， ECMAScript修正为只读, Infinity与NaN与任何值不相等(包括自身), 建议用非来判断 undefined console log('abc %s', 'd') # 'abc d', 格式化输出 方法 parseFloat # 可以解析整数和浮点数, 跳过前导空格, 忽略后面非数字内容。第一个非空格字符是非法数字直接量时，返回NaN parseInt # 只解析整数, 可接收第二个可选参数，指定数字转换基数 \u0026quot;0x\u0026quot;, \u0026quot;0X\u0026quot;前缀, 解析为16进制数 isNaN isFinite # NaN, Infinity 不通过, 非数字报错 escape # deprecated since ECMAScript v3 decodeURI # 不处理 =, \u0026amp; 等 decodeURIComponent # 会处理 =, \u0026amp; 等 encodeURI encodeURIComponent eval # 可以访问调用时的整个作用域，所以编译器不能裁剪作用域, 要间接调用, 如 (0, eval)(src) requestAnimationFrame fetch fetch(url).then(function (request) { return request.arrayBuffer }) 构造函数 # 包装对象函数 # 介绍 基本类型(数字，布尔，字符串)在构建时，会通过new String(s)的方式转换成对象，有了对象的方法，这个过程就是包装对象 undefined没有包装对象，所以访问属性会造成类型错误。 String # 介绍 是Object类型, 是基本类型string的包装类型 引用字符串类型的属性时,js会调用new String(s)来转换成对象 属性引用结束, 该新对象销毁 实际上有优化 包装测试 自动包装测试 1.toString # 异常 (1).toString # =\u0026gt; \u0026quot;1\u0026quot; 原始类型属性只读 var s = \u0026quot;test\u0026quot;; s.len = 4; # 相当于new String(\u0026quot;test\u0026quot;).len = 4 s.len // undefined # 相当于new String(\u0026quot;test\u0026quot;).len 运算 == # 原始类型与包装类型相等 === # 原始类型与包装类型不相等 语法 ECMAScript 5中，可以用数组方式访问16位值, 如 s[0] 属性 length # 4字节的字符会误判为2 静态方法 localCompare() # 参照本地语言字母表字符次序 fromCodePoint() # 支持4字节字符值转换, 多参数时合并成字符串 raw # 一个tag函数, 转义模板字符串到字符串 String.raw`\\n${2 + 3}` # '\\\\n5' String.raw({raw: 'test'}, 0, 1, 2) # 正常调用时, 第一个参数对象中必要有raw属性，其值为tag函数的第一个字符串数组的参数。其余参数与tag函数其余参数对应 方法 substring(1, 4) // =\u0026gt; 返回第2~4个字符 # 与java不同，java是第1~3个 slice(1, 4) indexOf(\u0026quot;\u0026quot;) lastIndexOf(\u0026quot;\u0026quot;) toUpperCase() charAt(0) # 取2个字节的字符 charCodeAt() # 取2个字节字符的十进制值 codePointAt() # index位的4字节字符当作一个字符，正确处理，得到十进制值, index+1位会取该4字节字符的后2字节, 为了匹配length属性 at() # 支持4字节字符, 匹配正确长度的方法 fromCharCode() # 2字节字符值转换到字符 normalize() '\\u01D1'.normalize() === '\\u004F\\u030C'.normalize() 原重音符号与 (字符 + 重音)合成符等价 不支持3个及以上字符合成 includes # s.includes('o', 6) 从6位置开始搜索o是否出现 startsWith endsWith # s.endsWith('o', 6) 前6个字符是否以o结尾 repeat(3) # 字符串重复3次返回 padStart # 'x'.padStart(5, 'ab') 返回 'ababx', padStart(5)会填充空格 padEnd 正则 # es6中内部调用RegExp.prototype[Symbol.match]等方法 search(pattern) # 返回首次匹配成功的位置 match(pattern) # 所有匹配位置的数组 replace(pattern, \u0026quot;\u0026quot;) # 所有匹配替换 split(pattern) # 匹配分割 Number # 属性 NaN POSITIVE_INFINITY NEGATIVE_INFINITY MAX_VALUE MIN_VALUE EPSILON # 极小的常量 2.22....e-16, 用来设置浮点计算的一个合理误差范围 MAX_SAFE_INTEGER # 越界最大值 MIN_SAFE_INTEGER # 越界最小值 静态方法 isFinite isNaN isInteger isSafeInteger # 判断是否越界 parseInt parseFloat 方法 字符串解析 构造方法 # 只基于十进制转换 调用全局函数parseInt(), parseFloat() 转换为字符串 toString() # Number类的toString()可接收转换基数, 来转换进制 如 n.toString(2); n.toStrng(8); n.toString(16) toFixed(0) # 保留几位小数, 从不使用指数计数法 toExponential(1) # 转换为指数, 参数为指数前保留几位小数 toPrecision(4) # 保留有效数字，多出位数转换成指数, 以上三个方法自动补0 Boolean # Object # 属性 __proto__ 用来读取或设置当前对象的prototype对象，只有浏览器必须部署这个属性 语义上是内部属性，被支持仅因为被广泛使用 动态方法 hasOwnProperty 是否有某属性，可判断属性值为undefined的情况 没prototype的对象, 该方法直接调用失败，需要Object.prototype.hasOwnProperty.call来调用 propertyIsEnumerable isPrototypeOf b.isPrototypeOf(c) # b是否出现在c的prototype链中 toString toLocaleString 返回对象的本地化字符，默认时仅调用toString方法 Date和Number对toLocaleString做了定制 Array的toLocalString对每个数组元素调用toLocaleString方法 toString会对每个数组元素调用toString方法 *toJSON Object.prototype没有定义这个方法, JSON.stringigy会调用要序列化对象的toJSON方法,如Date.toJSON() valueOf 要将对象转换为原始值时调用 如果需要使用原始值的上下文中使用了对象，会自动调用这个方法 静态方法 create # new会执行构造方法，有副作用 Object.create(null) # 创建的对象没有prototype，不同于{} getPrototypeOf # 用于判断继承 Object.getPrototypeOf(B) === A getOwnPropertyNames # 所有自身属性 getOwnPropertyDescriptor(obj, 'foo') # 获得属性的描述对象 getEnumPropertyNames # 可枚举自身属性和继承属性 setPrototypeOf # 标准可靠的方法修改对象prototype的关联 Object.setPrototypeOf(Bar.prototype, Foo.prototype) # 同Bar.prototype = Object.create(Foo.prototype) keys # 可枚举自身属性 defineProperty # 数据描述符，getter、setter是访问描述符 # 修改属性，在原型链上层属性为writable: false或有对应属性的setter时，不会发生屏蔽。使用defineProperty可发生屏蔽 Object.defineProperty(Object, 'is', { value: function (x, y) {...}, configurable: true, # false时，delete该属性会静默失败 enumerable: false, writable: true, get: function(){return 1} }) toLocaleString toString # toString(16) 转换为16进制 is('foo', 'foo') # 比较两个值是否相等, 基本是===，不同在于, +0 等于 -0, NaN 等于 NaN assign(target, source1, source2) 复制源对象自身可枚举属性到目标对象, source2覆盖source2覆盖target Symbol值的属性也会被拷贝 _.defaultsDeep方法可以深拷贝 常用于给对象添加静态方法或方法，合并对象，为属性指定默认值 Object.assign({}, DEFAULTS, options); preventExtensions # 使对象不可设置属性 isExtensible seal # 创建“密封”对象, 在现有对象上调用preventExtensions并把现在属性标记为configurable: false freeze # 调用seal并标记现有属性为writable: false Array # 静态方法 isArray(a) # ECMAScript 5 判断是否数组 [] instanceof Array的问题 多frame中有多个js环境, 都有自己的全局对象与构造函数。一个窗体中的对象是当前窗体构造函数创建，而另外窗体构造函数判断该对象则不成立。 # 但窗体间的混淆不常发生 ECMAScript 3 可以检查对象类属性来判断。 # 实际上就是ECMAScript 5中Array.isArray的代码 var isArray = Array.isArray || function(o){ return typeof o === \u0026quot;ojbect\u0026quot; \u0026amp;\u0026amp; Object.prototype.toString.call(o) == \u0026quot;[object Array]\u0026quot; }; from # 类数组对象或可遍历对象(如Set, Map)转为数组，转换后的数组具有了iterator接口 # 类数组对象同[].slice.call(arraylike), 可遍历对象同[...traversable] Array.from(arraylike) Array.from([1, , 2, , 3], (n) =\u0026gt; n || 0) Array.from('abc') # 字符串转数组 Array.from(new Set(array)) # 去除重复元素 of # 一组值转换为数组, 用于替代Array(), new Array() # 弥补Array()的返回不一致问题, 如Array(3) // [, , ,] Array.of(1, 2, 3) // [1, 2, 3] 动态方法 join, ... # firefox1.5 后 动态方法也写入到了静态方法中。但不是标准, 是String.split()的逆向操作 a.join() // =\u0026gt; \u0026quot;1,2,3\u0026quot; a.join(\u0026quot;\u0026quot;) // =\u0026gt; \u0026quot;123\u0026quot; new Array(2).join('-') // =\u0026gt; \u0026quot;--\u0026quot; reverse # 倒序 a.reverse() sort # 排序 a.sort() # 默认以字母表排序, 自动转字符串 undefined排到最后 a.sort(function(a, b){ return a-b; # a在前, 返回负数。b在前返回正数。0表示相等，顺序无关紧要, 此处是升序排列 }) concat # 连接数组, 创建返回一个新数组, 传入数组, 连接数组元素而非本身, 但不扁平化数组的数组 a.concat(4, [5, [6, 7]]) slice # 截取新数组 var a = [1,2,3,4,5] a.slice(0,3) // 返回 [1,2,3] a.slice(3) // 返回 [4,5] a.slice(1, -1) // 返回 [2,3,4] a.slice(-3, -2) // 返回 [3] splice # 修改数组 第一个参数起始位置(包含), 第二个参数删除个数(省略则从起始到结束都删除) 后面任意个参数指定插入到数组中的元素 返回由删除元素组成的数组 push 和 pop # 数组作为栈(先进后出)来用, push在结尾添加, pop在结尾删除, 插入元素时不解封数组 unshift 和 shift # unshift在头部添加元素, shift在头部删除。都改变索引, 插入元素时不解封数组 toString # 调用每个元素的toString()方法, 输出有逗号分隔的字符串列表(没有方括号), 与不使用任何参数的join()是一样的 toLocaleString # 调用元素的toLocaleString copyWithin # 当前数组中复制一段到另一位置 [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] # 第三个参数是结束位置(不包含), 默认是结尾。把4, 5 复制替换到1, 2 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5] # 4到5(不包含)复制到1 find # 返回第一个符合条件的元素, 没有时返回undefined, 可处理NaN, 第二个参数绑定回调函数的this对象 [1, 4, -5, 10].find((n) =\u0026gt; n \u0026lt; 0) findIndex # 返回第一个符合条件的index, 没有时返回-1 fill # 用某元素填充数组, 可标识起始位置 [1, 2, 3].fill(0) // [0, 0, 0] [1, 2, 3].fill(0, 1, 2) // [1, 0, 3] includes # 是否包含元素，可识别NaN, 返回布尔值, 第二个参数表示起始位置, indexOf 使用===判断, 会对NaN误判 [1, 2, 3].includes(2, 0) 遍历类方法 对稀疏数组，不存在的元素不调用传递的回调函数 方法第一个参数是回调函数, 第二个参数是回调函数的this 多数情况下, 传入的回调函数传递三个参数: 数组元素, 元素的索引, 数组本身 forEach # 没有break语句，用抛出异常替代 a.forEach(function(value){}) function foreach(a, f, t){ try{a.forEach(f, t);} catch(e){ if(e === foreach.break) return; else throw e; } } foreach.break = new Error(\u0026quot;StopIteration\u0026quot;); map # 映射数组元素, 稀疏数组也返回相同的缺失元素 [1,2,3].map(function(x){return x * x}) // 返回 [1, 4, 9] filter # 回调返回true的元素保留，返回新数组, 返回的数组总是稠密的，可用于压缩空缺并删除undefined 和 null元素 [5, 4, 3, 2, 1].filter(function(x){ return x \u0026lt; 3}) // 返回 [2, 1] every和some every表示所有, 在都返回true时返回true some表示存在, 都返回false时返回false 在确定返回值时停止遍历 a.some(func) reduce和reduceRight # 使用指定函数将数组元素进行组合，称为\u0026quot;注入\u0026quot;和\u0026quot;折叠\u0026quot; a.reduce(function(x, y){ return x + y}, 0) 第一个是回调函数。第二个可选，是初始值，无初始值时一开始直接传入第一第二个元素 回调函数中第一个是累积的结果, 第二个是当前元素 空数组无初始值调用会导致类型错误异常。 只有一个值并没有初始值时, reduce只简单抬这个值 reduceRight同reduce，但索引从高到低处理数组 indexOf和lastIndexOf 搜索数组元素, 返回第一个匹配元素的索引, 失败则返回 -1 indexOf从前往后, lastIndexOf从后往前 第二个参数可选，指定起始索引。负索引代表相对末尾的偏移量 字符串也有indexOf和lastIndexOf, 针对每个字符 返回遍历器 entries for(let [ind, ele] of ['a', 'b'].entries()) {} # 得到 0 'a', 1 'b' # 不用for of , entriesIterator.next().value // [0, 'a'] keys values Function # 使用 var f = new Function(\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;return x*y;\u0026quot;); # 任意数量实参。最后一个实参是函数体，语句间用分号隔开 # 创建一个匿名函数 特点 允许js在运行时动态创建并编译函数 每次调用，都解析函数体并创建新函数对象，效率低 # 循环中嵌套函数和函数定义表达式不会每次都重新编译 总在全局作用域创建，可以认为其构造函数是全局作用域中执行eval() 函数体代码内 arguments callee caller # 调用栈的上层函数, 出于安全考虑，大部分编译器已不支持caller, 用非标准的 fn.caller来取代, fn为当前函数名 属性 length 只读属性，代表函数形参数量。不包含设置了默认值的形参，也不包含...rest参数 arguments.length是实际实参个数, arguments.callee.length是期望实参个数, 同本length name 函数名, es5中只支持具名函数如function a(){}, es6支持var a = function(){} (new Function).name // 'anonymous' foo.bind({}).name // 'bound foo' prototype # 指向原型对象(prototype object)，从该函数创建对象时，从原型对象上继承属性 方法 call(o, 1, 2) # 传入可变调用时参数 apply(o, [1, 2]) # 传入调用时参数数组或类数组对象, 这样可以将arguments数组直接传入另一个函数来调用 ECMAScript 严格模式中，o传入什么,this就是什么。其它情况下，o为null或undefined时替换为顶级对象，原始值会被包装。 bind(o, ...) ECMAScript 5新增方法。在函数a上调用bind, 传入对象o，反回以o调用a的新函数b bind返回的是一个闭包, 返回的函数不包含prototype属性 普通函数固有的prototype属性是不能删除的 除第一个实参外，其它实参按顺序绑定到调用bind函数f的实参上，称为柯里化(currying), 如 f = function(x, y); ff = f.bind(o, 1); ff(2); // 此时x绑定为1, y传入为2 ECMAScript 5中的bind, 返回的函数对象的length属性，值是返回函数的形参个数减其实参个数 返回的函数可以用作构造函数，此时以原始函数的形式调用作为构造函数(实参也会原封不动地传入) 用作构造函数时, 使用原始函数的prototype toString() ECMAScript规定返回和函数声明语法相关的字符串 大多数toString()方法返回函数的完整源码，内置函数往往返回类似\u0026quot;[native code]\u0026quot;的字符串作函数体 Date # var now = new Date() var then = new Date(2011, 0, 1) var later = new Date(2011, 0, 1, 17, 10, 30) var elapsed = now - then; now.setMonth(now.getMonth - 1); 方法 getFullYear() getMonth() getDate() getDay() getHours() getUTCHours() Error # RegExp # 构造 new RegExp('xyz', 'i'); // /xyz/i new RegExp(/abc/ig, 'i') // /abc/i 修饰符 i g # 全局多次匹配, 下次匹配从剩余中重新开始 u # 正确处理4字节字符, 存在u修饰符时, /\\u{61}/可以表示unicode字符, 否则会匹配61个连续的u y # 粘连，基本同g，不同在于剩余第一个字符开始必须匹配上, 确保匹配之间不会有漏掉的字符 var s = 'aaa_aa_a', r1 = /a+/g, r2 = /a+/y; r1.exec(s), r2.exec(s) # ['aaa'] ['aaa'] r1.exec(s), r2.exec(s) # ['aa'] null 属性 flags # 修饰符 lastIndex # 从这个index开始匹配 sticky # 是否设置了y字符 静态方法 方法 test /\\d+/g.test(\u0026quot;testing: 1, 2, 3\u0026quot;) exec # 返回带有特殊属性的Array match match 属性 index # 在index上匹配成功 Set # 构造 new Set() new Set([1, 2, 3]) 属性 size # Set实例成员数 方法 add(x) delete(x) has(x) # 是否有x clear() # 清除所有成员 keys() values() # values同keys完全一致, 返回遍历器 entries() # 返回[key, key]的遍历器 forEach(function (value, key, obj) {}, boundThis) WeakSet # 构造 new WeakSet() new WeakSet([1, 2, 3]) # 任何可遍历对象 属性 # 没有size 方法 add(x) delete(x) has(x) Map # 构造 new Map() new Map([['a', 1], ['b', 2]]) 属性 size 方法 set(key, value) get(key) delete(key) has(key) clear() keys() values() entries() # map[Symbol.iterator] === map.entries forEach(function(value, key, map) {}, boundThis) WeakMap # 方法 get set delete has Proxy # new Proxy(target, handlers) # target表示要拦截的对象, handler是回调方法 拦截器 get(target, propKey, receiver) # 属性读取。propKey是属性名, receiver是继承该proxy的对象 set(target, propKey, value, receiver) # 属性设置 has(target, propKey) # in操作，返回布尔值 deleteProperty(target, propKey) # delete操作，返回布尔值 enumerate(target) # for in , 返回遍历器 ownKeys(target) # Object.getOwnPropertyNames, Object.getOwnPropertySymbols, Object.keys, 返回数组 getOwnPropertyDescriptor(target, propKey) # Object.getOwnPropertyDescriptor, 返回描述对象 defineProperty(target, propKey, propDesc) # Object.defineProperty, Object.defineProperties, 返回布尔值 preventExtensions(target) # Object.preventExtensions, 返回布尔值 getPrototypeOf(target) # Object.getPrototypeOf, 返回对象 isExtensible(target) # Object.isExtensible, 返回布尔值 setPrototypeOf(target, proto) # Object.setPrototypeOf, 返回布尔值 apply(target, object, args) # 拦截proxy作为函数调用的操作, 如proxy(), proxy.call, proxy.apply construct(target, args, proxy) # 拦截proxy作用构造函数的操作, 如new proxy 静态方法 revocable(target, handler) # 返回有proxy, revoke属性的对象实例, proxy是Proxy实例, 调用revoke()函数可以取消Proxy et {proxy, revoke} = Proxy.revocable({}, {}) ArrayBuffer # 构造 var buf = new ArrayBuffer(32) # 生成32字节的内存区域，每个字节默认值为0 if(buf.byteLength === 32) # 由于内存可能不够大，要检查是否分配成功 属性 byteLength # 内存区字节长度 方法 slice(0, 3) # 拷贝前3个字节，生成新的ArrayBuffer isView(v) # 检查某视图是否为该buf的视图 (TypedArray) # 9种类型数组 Int8Array Uint8Array Uint8ClampedArray # 自动过滤溢出。用于处理图像颜色, 只取值0 - 255, 过滤掉高位, ie10不支持该类型 Int16Array Uint16Array int32Array Uint32Array Float32Array Float64Array 构造 var x1 = new Int32Array(buf) 带符号整形方式读buf new Int32Array(buf, 2, 2) 开始于字节2, 长度为2(2 * 32bit)。第3个参数不填则到末尾 开始字节数要符合视图类型, 如16位类型视图单位是2个字节, 不能从1字节开始, 否则将报错 用于构建复合视图 x1[0] = 1; # 第0位4个字节赋值 var x2 = new Uint8Array([0, 1, 2]) # 数组会直接分配内存生成ArrayBuffer new Float64Array(8) # 直接分配8字节生成ArrayBuffer来创建视图 new Int8Array(new Uint8Array(4)) # 会开辟新的ArrayBuffer，复制原有数据来建立视图 new Int8Array(new Uint8Array(4).buffer)可以用同一个buffer 属性 length BYTES_PRE_ELEMENT # 表示当前数据类型占用的字节数 buffer # 该视图的ArrayBuffer对象 byteLength # 该视图中buffer占内存的长度，是只读属性 byteOffset # 该视图从哪个字节开始, 只读属性 静态方法 of # 将参数转为TypedArray实例 from # 可遍历数据转TypedArray, 可将TypedArray转为另一种TypedArray。可以接map函数 Int16Array.from(Int8Array.of(1, 2, 3), x =\u0026gt; 2 * x) 方法 # 没有concat方法 set # 复制数组，整段内存覆盖 b.set(a, 2) # 从b的index2开始复制a subarray # 建立新视图 a.subarray(2, 3) # 从index2复制到index3(不包含), 参数2不填默认复制到结尾 slice DataView # 构造 new DataView(buf) # DataView(ArrayBuffer buffer [, startIndex [, length]]) 属性 buffer byteLength byteOffset 方法 getInt8(0, true) # 以带符号整形格式读第0个字节, 第二个参数默认false, 使用大端字节序解读(两个或以上字节的数据需要), 设置true则为小端字节序 getUint8 getInt16 getUint16 getInt32 getUint32 getFloat32 getFloat64 setUint8(0, 1, true) # 开始序号, 数据, 小端字节序 setInt16 setUint16 setInt32 setUint32 setFloat32 setFloat64 WebSocket # 构造 new WebSocket('ws://127.0.0.1:8081') 属性 binaryType # 设置成'arraybuffer'来接收和发送arraybuffer FileReader # 构造 var fileInput = document.getElementById('fileInput'); var file = fileInput.files[0]; var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.onload = function () { var arrayBuffer = reader.result; } 或 reader.addEventListener('load', processimage, false); function processimage(e) { var buffer = e.target.result; } Promise # 构造 var promise = new Promise(function (resolve, reject) {resolve(0); /* reject(err)*/}) 方法 then(func1, func2, func3) # func1对就fulfilled回调, func2对应rejected回调, func3用于处理进度信息 catch # 是then(null, rejection)的别名，尽量使用catch而非then(null, rejection), 这样看起来更接近同步写法 静态方法 all([p1, p2, p3]) # 成员不是promise对象时，先promise.resolve(data), 全部完成, fullfilled。一个rejected, rejected, 返回第一个reject的错误 race([p1, p2, p3]) # 一个完成, fullfiled, 返回该promise Promise.race([p1, new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; reject(new Error('time out.')), 5000) })]) resolve reject done # 不在规范内, 总是在回调链尾端, 保证抛出任何可能出现的错误 finally # 不在规范内, 接受一个回调函数，永远执行 全局对象 # 顶级全局对象 # 介绍 js代码最外层的this 初始化时, 定义所有预定义全局值 代码中定义的全局变量，实际是该对象的属性 Global Window 介绍 初始化时定义了一部分其他全局属性 Math # 属性 PI E # 自然对数底数 LN10 # 同Math.log(10), 表示以e为低10的对数, Math.log(100)/Math.LN10 消底后表示以10为底100的对数 LN2 静态方法 trunc # 去除小数部分 sign # 判断正负或零 exp # e的x次方 log # x的自然对数 cbrt # 立方根, 同Math.pow(Math.abs(x), 1/3) clz32 二进制下32位无符号整数有多少个前导0。小数会取floor count leading zero bits in 32-bit binary representations of a number Math.clz32(1000) // 22 Math.clz32(1000 \u0026lt;\u0026lt; 1) // 21 imul # 32位带符号整数的乘积, 在乘积越界时会返回正确的低位数值 fround # 返回一个数的单精度浮点数表示, 4位无法精确表示的小数，会返回最接近的数, 同new Float32Array([x])[0] Math.fround(1.337); // 1.337000012... hypot # 所有参数平方和的平方根 expm1 # 返回Math.exp(x) - 1 log1p # 返回Math.log(1 + x) log10 # 返回以10为低x的对数, 同 Math.log(x) / Math.LN10 log2 sinh # 双曲正弦 hyperbolic sine cosh # 双曲余弦 hyperbolic cosine tanh # 双曲正切 hyperbolic tangent asinh # inverse hyperbolic sine acosh atanh 方法 pow(x, y) # x的y次方, pow(x, 1/3) 表示立方根 round(.6) # 四舍五入 ceil(.6) # 向上求整 floor(.6) # 向下求整 abs(-5) # 绝对值 max(x, y) # 最大值 min(x, y) # 最小值 random() # \u0026gt;=0, \u0026lt; 1.0的伪随机数 sqrt(3) # 平方根 sin(0) log(10) # 自然对数 exp(3) # e的3次幂 JSON # 方法 parse(str) stringify(obj) Reflect # 静态方法 ownKeys(target) # 返回对象自身所有属性 enumerate(target) # 返回Iterator，遍历对象自身和继承的所有可枚举属性, 同for ... in apply(target, thisArg, args) construct(target, args) get(target, name, receiver) set(target, name, value, receiver) defineProperty(target, name, desc) deleteProperty(target, name) has(target, name) isExtensible(target) preventExtensions(target) getOwnPropertyDescriptor(target, name) getPrototypeOf(target) setPrototypeOf(target, prototype) Symbol # 属性 hasInstance # Obj[Symbol.hasInstance]方法在instanceof运算时调用，如Foo[Symbol.hasInstance](foo) isConcatSpreadable # arr.concat时是否要展开 let arr = [1, 2], arr[Symbol.isConcatSpreadable] = false, ['a', 'b'].concat(arr, 'c') // ['a', 'b', [1, 2], 'c'] species # 如果this.constructor[Symbol.species]存在, 用它来做构造函数 match # str.match(obj)时, 调用obj[Symbol.match](str) replace # str.replace(s, r)时, 调用s[Symbol.replace](s, r) search # str.search(obj)时，调用obj[Symbol.search](str) split # str.split(separator, limit)时, 调用separator[Symbol.split](str, limit) iterator for ... of指向调用的默认遍历器 function A {*[Symbol.iterator] () { let i = 0; while(this[i] != undefined) {yield this[i]; i++;} }} toPrimitive # 对象转原始类型值时调用 {[Symbol.toPrimitive] (hint) {}} // hint值有 'number', 'string', 'default' toStringTag toString时拼在后面, 如 '[object xxx]' unscopables 排除with时的属性, Array.prototype[Symbol.unscopables] // {copyWithin: true, ...} 方法 s.toString() // 'Symbol(foo)' # 可以String(s) 得到字符串'Symbol(foo)' 静态方法 for('foo') # 搜索以'foo'作参数登记的Symbol值, 没有时会新建、登记并返回, 这种登记是全局的 keyFor(s) # 返回s登录的字符串，没有时返回undefined dom # window对象 # document # 属性 id innerHTML # 非标准但通用 body 方法 appendChild(domElement) 方法 getElementById(\u0026quot;\u0026quot;) element # 属性 innerHTML style display = \u0026quot;none\u0026quot; visibility = \u0026quot;hidden\u0026quot; className 方法 createElement(\u0026quot;div\u0026quot;) createTextNode(msg) appendChild(ele) XMLHttpRequest # var req = new XMLHttpRequest() 方法 open(\u0026quot;GET\u0026quot;, url) send(null) # null表示不带正文地发送这个请求 onreadystatechange = function(){ # 重写回调函数 if(req.readyState == 4 \u0026amp;\u0026amp; req.status == 200){ var text = req.responseText; # 响应的字符串 } } localStorage # Worker # 介绍 it is a javascript running in the background, without affecting the performance of the page. dom中的js线程在执行时会阻塞 使用 var w; // start worker function startWorker(){ if(typeof(Worker) !== 'undefined'){ if(typeof(w) == 'undefined'){ w = new Worker('demo_workers.js'); } w.onmessage = function(event){ ＃ worker 's api, will call postMessage() document.getElementById('result').innerHTML = event.data; }; }else { document.getElementById('result').innerHTML = 'sorry, your browser does not support Web Workers...'; } } // stop worker w.terminate(); ＃ worker 's api, will trigger w.onmessage(); w = undefined; /* demo_workers.js */ # 外部的js文件不能访问window, document, parent对象 var i = 0; function timeCount(){ i = i + 1; postMessage(i); # worker 's api, when onmessage() was triggered. setTimeout('timeCount()', 500); } timedCount(); EventSource # 介绍 浏览器推送 事件 onopen onmessage onerror 使用 var source = new EventSource(\u0026quot;demo_sse.php\u0026quot;); source.onmessage = function(event){ document.getElementById('result').innerHTML += event.data + '\u0026lt;br/\u0026gt;'; }; // demo_sse.php \u0026lt;?php header('Content-Type: text/event-stream'); header('Cache-Control: no-cache'); $time = date('r'); echo \u0026quot;data: The server time is: {$time}\\n\\n\u0026quot;; # data在上面event.data中引用 flush(); ?\u0026gt; 控件 # ActiveXObject # new ActiveXObject(\u0026quot;Excel.Application\u0026quot;); # Microsoft.XMLHTTP, ie中适用 Server.CreateObject(\u0026quot;Microsoft.XMLHTTP\u0026quot;) # 在chrome中不起作用, 可以用 new XMLHttpRequest()创建 canvas # 概念 原点: canvas左上角 默认Style为black 颜色设定 \u0026quot;red\u0026quot; \u0026quot;blue\u0026quot; \u0026quot;#EEEEFF\u0026quot; \u0026quot;rgb(1-255, 1-255, 1-255)\u0026quot; \u0026quot;rgba(1-255, 1-255, 1-255, 0-1)\u0026quot; 路径 可以被填充多个轮廓或图形的操作。 基本使用 var context =canvas.getContext(\u0026quot;2d\u0026quot;); context.fill()//填充 context.stroke()//绘制边框 context.lineWidth//图形边框宽度 context.fillStyle//填充的样式 context.strokeStyle//边框样式 绘制 矩形 content.fillRect(x, y, width, height) strokeRect(x, y, width, height) # x, y是起点坐标, width, height为宽和高 清除矩形区域 context.clearRect(x,y,width,height) 圆弧 context.arc(x, y, radius, startAngle,endAngle, anticlockwise) x, y是圆心坐标, radius是半径, startAngle, endAngle是开始、结束弧度, anticlockwise=false时顺时针画圆 一刻钟是零度, 弧度可以用Math.PI来表示 例子 矩形 context.fillRect(0, 120, 100, 100); context.strokeRect(120, 120, 100, 100); context.clearRect(50, 50, 240, 120); 圆弧 context.beginPath(); ctx.arc(100,75,50,0,1.3 * Math.PI, false); context.closePath(); context.fill(); # 或ctx.stroke()画线, fill()填充开始点与结束点的连线 image var image = ctx.getImageData(0, 0, 256, 256); # 取画布矩形区域的图像 ctx.putImageData(image, 10, 70) # 把图像复制到画布的一个起点 例子 var c=document.getElementById(\u0026quot;myCanvas\u0026quot;); var ctx=c.getContext(\u0026quot;2d\u0026quot;); var imgData=ctx.createImageData(100,100); for (var i=0;i\u0026lt;imgData.data.length;i+=4) # 一个像素有4个值RGB + alpha, alpha=255表示不透明 { imgData.data[i+0]=255; imgData.data[i+1]=0; imgData.data[i+2]=0; imgData.data[i+3]=255; } ctx.putImageData(imgData,10,10); 优化 # canvas.width = canvas.width # 一种巧妙的方法清除并重置画布 webgl # 介绍 由Khronos Group维护 # 还维护了OpenGL和COLLADA 使用OpenGL渲染语言GLSL ES WebGL是在浏览器中实现三维效果的一套规范 webgl通过增加openGL es 2.0的一个js绑定, 把它们结合在一起 webgl可以为html5 canvas提供硬件3d加速渲染 更流畅地展示3d场景和模型 创建复杂的导航和数据视觉化 名词 科纳斯组织 Khronos Group GLSL ES OpenGL Shading Language Embedded System 网格 Mesh 模型 model 纹理映射 texture map 材质 material 光源 light 变换 transform 相机 camera 视口 viewport 投影矩阵 projection matrix 视锥体 view volume 视平截头体 view frustum 着色器 shader 图元 primitive 三角形带 triangle strip 类型化数组 typed array 模型视图矩阵 modelview matrix 投影矩阵 projection matrix 顶点着色器 vertex shader 片元着色器 fragment shader 像素着色器 pixel shader, 同fragment shader 自发光 unlit 预置光照 prelit 镜面高光 specular highlights 镜面反射 specular reflection alpha混合 alpha blending 变换层级 transform hierarchy 帧动画 frame-based animation 补间动画 tweening 关键帧 keyframe 关键帧动画 keyframe animation 插值 interpolation 线性插值 linear interpolation 关节动画 articulated animation 蒙皮动画 skinned animation 骨骼 skeleton 目标变形动画 morph target animation 程序贴图 procedural texture 纹理变换 texture transform 拾取 picking 面法线 face normal 程序贴图 procedural texture 多级渐进纹理过滤 mipmapping / mipmapping filtering 数码内容创作软件 DCC digital content creation 包围盒 bounding box 框架 three.js physi.js glMatrix GLGE philoGL sceneJS spiderGL 着色器 工具 webgl inspector # chrome的扩展, webgl调试 网站 www.khronos.org/webgl/ # Khronos提供的主页 learningwebgl.com/blog blog.tojicode.com https://developer.mozilla.org/en/WebGL # mozilla的webgl教程 www.chromeexperiments.com # chrome体验 www.html5rocks.com # 提供html5资源 www.lao3d.com # 国内首个webgl网站 "},{"id":63,"href":"/docs/basic/computer/","title":"Computer","section":"基本功","content":" 操作系统 # linux windows chrome os mac os fushsia # goolge os "},{"id":64,"href":"/docs/pl/java/","title":"Java","section":"程序语言","content":" 基础 # 历史 1991.4 Oak 1995.5 Java1.0 \u0026quot;Write Once, Run Anywhere\u0026quot; 1996.1 JDK1.0, 纯解释型JVM(Sun Classic VM), Applet, AWT 1996.5 JavaOne大会 1997.2 JDK1.1, JDBC, JAR文件格式, JavaBeans, RMI, 内部类(Inner Class), 反射(Reflection) 1998.12 JDK1.2, 分出J2SE、J2EE、J2ME。JVM内置JIT, EJB, Java Plug-in, Java IDL, Swing, Collections, strictfp关键字 1999.4 JVM HotSpot 2000.5 JDK1.3, 数学运算, Timer, JNDI成为平台服务, CORBA IIOP实现RMI, 2D API, JavaSound 2002.2 JDK1.4, 成熟版本，多公司参与。正则, 异常链, NIO, 日志类, XML, XSLT # .NET发布 2004.9 JDK1.5, 自动装箱, 泛型, 动态注解, 枚举, 变长参数, foreach, 改进内存模型JMM(Java Memory Model), concurrent包 2006.12 JDK1.6, 改名为Java SE 6, Java EE 6, Java ME 6。动态语言支持(内置Mozilla JavaScript Rhino), 编译API, HTTP服务器API。JVM改进(锁、gc、类加载) 2006.11 JavaOne Java开源。建立OpenJDK 2009.2 JDK1.7, OpenJDK1.7和Sun JDK1.7几乎一样。Lambda项目, Jigswa项目(虚拟机模块化), 动态语言支持, GarbageFirst收集器, Coin项目(语言细节进化)。Oracle收购Sun后延迟部分项目。支持Mac OS X和ARM 2009.4 Oracle收购Sun o-\u0026gt; JVM历史 Sun Classic # 1.0到1.3 解释器 sunwjit # 外挂编译器, 还有SymantecJITt shuJIT等 编译器和解释器不能同时工作，编译器接管后，要对所有代码编译，不能用耗时稍高的优化，效率低 Exact VM # 1.2到1.3 使用准确内存管理EMM(Exact Memory Management)而得名 虚拟机知道内存数据类型, gc时好判断数据是否被使用 抛弃Classic VM基于handler(句柄关联对象移动地址)的对象查找方式, 每次定位对象少一次间接查找 两级即时编译器 与解释器混合工作 Sun HotSpot VM # 1.2, Sun JDK和OpenJDK, 来源Strongtalk VM EMM 热点代码探测 # 与解释器协同，平衡最优响应时间和最佳执行性能 执行计数器找出最有编译价值的代码，通知JIT以方法为单位编译 方法频繁调用或有效循环多，触发标准编译和OSR(栈上替换) 不用等待本地代码输出就执行，编译时间压力小，可引入更多优化技术，输出更高效本地代码 KVM # 强调简单、轻量、可移植，但运行慢。Android, iOS前手机平台广泛使用 CDC-HI VM/CLDC-HI VM # CDC/CLDC(Connected Limited Device Configuration)希望在移动端建立统一java编译接口, 这是它们的参考实现， Java ME的支柱 Squawk VM # 运行于Sun SPOT(small programmable object technology, 一种手持wifi设备)。java本身实现大部分 JavaInJava # 实验，java实现自身元循环(meta-circular), 需要运行在宿主虚拟机上，没有JIT, 解释运行 Maxine VM # 几乎java实现, 有JIT和gc, 没有解释器，宿主或独立运行，效率接近HotSpot Client VM BEA JRockit # 专注服务器端，不太关心响应时间，没有解释器 gc和MissionControl领先 IBM J9 VM # IT4J(IBM Technology for Java Virtual Machine), SmallTalk虚拟机扩展而来, 面向各平台，主要应用于IBM产品 Azul VM # HotSpot改进，Azul Systems公司运行于专有硬件Vega 每个实例管理数十cpu, 数百GB内存，可控gc时间，对硬件优化线程调度 Zing JVM # Azul VM运行于x86平台 BEA Liquid VM # 现在的JRockit VE(virtual edition), BEA运行在自己Hypervisor系统上 实现专用操作系统的必要功能，如文件系统、网络支持 虚拟机直接控制硬件, 好处如 线程调度不用切换内核态、用户态等 Apache Harmony # 虚拟机，兼容Java1.5、1.6, 没得到TCK认证(Technology Compatibility Kit)兼容性测试的授权 许多代码吸纳进IBM的JDK1.7和Google Android SDK Google Android Dalvik VM # Android平台核心组成部分之一 不能直接执行class, 执行dex文件可由class文件转化, 可直接使用大部分Java API 寄存器架构，非栈架构 Android2.2提供JIT Microsoft JVM # 微软想垄断Java，Sun打官司令开发停止 其它 JamVM, cacaovm, SableVM, Kaffe, Jelatine JVM, NanoVM, MRP, Moxie JVM, Jikes RVM o-\u0026gt;JDK发行版 Open JDK Oracle JDK IBM JDK 概念 JDK(java development kit) # java开发的最小环境 Java语言 JVM Java API类库 JRE(java runtime environment) JVM Java SE API 平台 Java Card # Applets, 运行在小内存设备 Java ME(Micro Edition) # 以前叫J2ME。手机, PDA, 精简API Java SE(Standard Edition) # 以前叫J2SE, 桌面应用, 完整API Java EE(Enterprise Edition) # 企业应用(ERP, CRM), 扩充API(javax包, 有些合入了JavaSE), 部署支持 JDK # 5 自动装箱拆箱 枚举类型 import static 可变参数 内省 泛型 for增强 注解 6 AWT新类Desktop、SystemTray JAXB2，把Bean变为XML StAX XML处理 Compiler API动态生成class Http Server API, 轻量http容器 Common Annotations补充, Annotations API Console类 脚本语言引擎: js, groovy, ruby 7 switch支持String 泛型推断 new ArrayList\u0026lt;\u0026gt;() AutoCloseable interface，对象销毁时自动调用close() FileSystem新方法, 取环境变量 getJavaIoTempDir() # IO临时文件夹 getJavaHomeDir() # JRE目录 getUserHomeDir() # 用户目录 getUserDir() # 运行目录 Boolean加方法 negate() and() or() xor() Character加方法 equalsIgnoreCase() Math加方法，安全计算 safeToInt() safeNegate() safeSubtract() safeMultiply() safeAdd() switch case可以匹配String 数值可下划线, 二进制 int i = 1_000_000 int i = 0b1001_1001 多异常类型 catch(A|B e){} try with resource自动关闭资源 try (FileInputStream s1 = new FileInputStream(\u0026quot;\u0026quot;); FileOutputStream o1 = new FileOutputStream(\u0026quot;\u0026quot;)) {} 8 interface default方法 lambda表达式 lambda作用域可访问实际final变量, 可访问对象字段和静态变量 函数式接口 @FunctionalInterface 函数引用 Converter\u0026lt;String, Integer\u0026gt; f = Integer::valueOf User::new Predicate类, Function接口, Supplier接口, Consumer接口, Comparator接口, Optional接口 Stream接口 filter()... Collection stream() parallelStream() Date API Clock static systemDefaultZone() millis() instant() Date.from(instant) ZoneId static getAvailableZoneIds() static of() getRules() LocalTime static now() static of() static parse plust()... LocalDate static parse() LocalDateTime static of() toInstant()... ChronoUnit.HOURS.between() DateTimeFormatter static ofLocalizedTime(FormatStyle.SHORT) static ofPattern() withLocale(Locale.GERMAN) 多重注解, 同一注解使用多次 @Repeatable 9 JDK模块化加载，瘦身 AOT(Ahead of Time Compilation) 接口私有方法 jshell try with resource改进 FileInputStream s1 = new FileInputStream(\u0026quot;\u0026quot;); FileOutputStream o1 = new FileOutputStream(\u0026quot;\u0026quot;); try (s1;o1){} 下划线不能单独成为变量名，后续会成为关键字 String从char[]改为byte[] stream加强，集合加强 list.of() map.of() copyof() 10 引入var, 只能声明局部变量 var a = \u0026quot;a\u0026quot;; 11 直接运行源码 java a.java String strip() # 可去除unicode空白字符 isBlank() # 长度为0或空格 repeat(4) # 重复4次生成新串 lambda var类型推断 (var a) -\u0026gt; a Optional加强 InputStream transferTo() HTTP Client API 12 switch多值（preview） switch(a) { case 1,2,3 -\u0026gt; a; } 13 switch返回值(preview) String s = switch(a) { case 1 -\u0026gt; \u0026quot;a\u0026quot;; } 文本块(preview) String s = \u0026quot;\u0026quot;\u0026quot; abc \u0026quot;\u0026quot;\u0026quot;; 14 instanceof模式匹配(preview) if (o instanceof Integer i){ i++; } 空指针定位到对象 # a().b().c的情况 -XX:+ShowCodeDetailsInExceptionMessages record类型(preview) public record User(String name, Integer age){} jpackage 15 sealed类(preview), 限制子类继承 public sealed class Animal permits Cat, Dog {} public final class Cat extends Animal {} public sealed class Dog extends Animal permits Husky {} public final class Husky extends Dog {} CharSequence interface添加default isEmpty() TreeMap添加方法 putIfAbsent() computeIfAbsent() computeIfPresent() compute() merge() 正式版: 文本块 16 包装类编译时警告 Integer i = new Integer(1) synchronized(i){} 获取AM或PM DateTimeFormatter.ofPattern(\u0026quot;B\u0026quot;).format(LocalDateTime.now()) InvocationHandler添加方法 invokeDefault() # 调interface default方法 JVM优化: ZGC并发栈处理，弹性metaspace Stream toList() 正式版: record类型、instanceof模式匹配、jpackage 17, LTS版 去掉AOT、GraalVM的JIT switch模式匹配(preview) switch(a) { case B b -\u0026gt; b.b(); case null -\u0026gt; ; } 伪随机数增加interface, 用于使用stream RandomGeneratorFactory RandomGenerator, 由Random和ThreadLocalRandom继承 正式版: sealed类 21, LTS版 命令与工具 # bin javac # 编译器 java # 解释器 -jar a.jar --spring.config.location=/application.yml --spring.profiles.active=prod # 指定spring config -Xmx2g -Dserver.port # 覆盖properties javadoc # 生成HTML格式的帮助文档 javadoc -d docs -sourcepath src/ -subpackages com.ryx -author jdb # java调试器 javah # 反编译成c头文件 javap # 反编译成java文件 jar # 打包工具 打包标签 把包目录和class类放到jnb目录 jnb/META-INF/tld文件添加\u0026lt;uri\u0026gt;http:# www.xxx.com\u0026lt;/uri\u0026gt; jar cvf jnb.jar * jar cvfm ul.jar manifest.mf com native2ascii # 转换为unicode编码 serialver # 返回指定类的序列化号serialverUID appletviewer # 小程序浏览器，执行HTML文件上java小程序类 htmlconverter # 转换applet tags成java plug-in javap # 反编译 jad # 反编译 jad -o -a d.java Xxx.class jps # 查java进程 jinfo # 输出、修改opts jstat # 性能分析 -option # 查看分析项 -class # 加载class的数量 -compiler # 实时编译数量 -gc # gc次数，时间 -gccapacity # gc占量: young、old、perm -gcnew # new对象数量 -gcnewcapacity # new对象占量 -gcutil # gc统计 jmap # 内存分配 jconsole # 图形统计：heap, threads, classes, cpu, VM summary jstack # 查看线程(如死锁),得到java stack和native stack 工具 MAT (Memory Analyzer) # eclipse MAT插件分析dump文件 JProfiler # 图形化全面性能分析 常见场景 分析GC效果，内存泄漏 jstat -gcutil -t -h8 [pid] 1000 dump内存 jmap -dump:live,format=b,file=heap.bin [pid] 查死锁 jstack |grep deadlock # deadlock会列在最后 CPU占用 top top -Hp [pid] printf '%x' [tid] jstack [pid] | grep [16进制tid] -A 10 语法 # 基础 # 类型 基本类型 # 作为面向对象语言，为了方便引入了基本类型 boolean 1或4字节 # 没有定义类型的字节码，跟据jvm实现有时用int代替 # 据说[]boolean是1个，boolean直接用int类型是4个 byte 1个字节 short 2个字节 char 2个字节 # gbk, gb2312这种2字节编码，一个汉字存一个char。utf-8一个字用3字节 int 4个字节 long 8个字节 float 4个字节 double 8个字节 包装类型 # 不可变(immutable)类 Boolean, Byte, Short, Character, Integer, Long, Float, Double 享元 Integer i1 = 120, i2 = 120, i3 = 130, i4 = 130; i1 == i2; i3 != i4 # 数字小于1字节(-128 -- 127)后 , 内部存在IntegerCache中,这是一种享元模式 自动折装箱(java5) Integer iObj = 3; # 装箱 iObj + 12; # 折箱 字符串 # 不可变(immutable)类, 用cahr数组实现 字面量处理 String str = \u0026quot;abc\u0026quot; # String s = new String(\u0026quot;abc\u0026quot;) 放堆里 定义引用变量str 栈中查找\u0026quot;abc\u0026quot;, 有则返回地址，没有则开辟地址，再创建String对象，对象指向该地址, 该地址标记对象引用 # 放在栈的静态区(static segement)里 str指向地址, 所以str保存了一个指向栈中数据的引用 \u0026quot;a\u0026quot;+\u0026quot;b\u0026quot; 会编译成使用StringBuilder # 循环中会重复创建 泛型 字面量 Map\u0026lt;String, Integer\u0026gt; a = new HashMap\u0026lt;\u0026gt;(); # 后面的菱形操作符做了类型推断 f(new HashMap\u0026lt;\u0026gt;) # 传值使用菱形操作符 引用 强引用(strong reference) String s = new String(\u0026quot;\u0026quot;) 软引用(soft reference) # 内存不足时回收 # 用来实现内存敏感的高速缓存, 如object-cache，为了能cache又不会内存不足 SoftReference\u0026lt;String\u0026gt; softRef = new SoftReference\u0026lt;String\u0026gt;(s) 回收 将softRef引用referent(s)设为null，不再引用new String(\u0026quot;\u0026quot;) new String(\u0026quot;\u0026quot;)设置为可结束(finalizable) new String(\u0026quot;\u0026quot;)运行finalize(),空间释放。softRef添加到它的ReferenceQueue(如果有) 弱引用(weak reference) # 表示可有可无, gc扫描到随时回收 WeakReference\u0026lt;String\u0026gt; weakRef = new WeakReference\u0026lt;String\u0026gt;(s) 虚引用(PhantomReference) # 形同虚设，像没引用，用来跟踪垃圾回收活动 ReferenceQueue\u0026lt;String\u0026gt; queue = new ReferenceQueue\u0026lt;\u0026gt;() PhantomReference\u0026lt;String\u0026gt; phantomRef = new PhantomReference\u0026lt;String\u0026gt;(s, queue) # 必须和ReferenceQueue联合使用 # 可以通过判断ReferenceQueue是否有虚引用，来了解被引用对象是否将要被回收 修饰 volatile # 类型修饰符，告诉jvm该变量在寄存器/工作内存中值是不确定的 # 没有原子性 # 不会造成线程阻塞 # 读性能几乎不变，写稍慢，因为插入内存屏障来保证不乱序执行 对所有线程可见(可见性，线程的修改对其它线程可见) # 跳过cpu cache，新值立即同步到内存, 使用前从内存刷新 禁止编译器指令重排序优化 synchronized # 锁当前变量、方法、类，只有当前线程可用 # 保证可见性和原子性 语句 == # 基础类型比较数值，引用类型比较地址 +1 与 += 1 short s1 = 1; s1 = s1 + 1 # 出错，类型变为int s1 += 1 # 相当于 s1 = (short)(s1 + 1) + \u0026quot;\u0026quot; # 编译成StringBuilder实现 goto和const是保留字但没有使用 标签 label1: for(; true; ) { break lable1; // continue lable1; } 增强for循环(1.5) for(int i : args){ sum += i; } 同步 public synchronized void synMethod(){} synchronized(a1){} switch expr类型 1.5前只能byte, short, char, int 1.5可以枚举 1.7可以String long目前不可以 表达式 java赋值语句返回被赋值的对象 \u0026amp; 与 \u0026amp;\u0026amp; \u0026amp;是 按位与，逻辑与(后面会计算) \u0026amp;\u0026amp;是 短路与 | 与 || # 同上 lambda表达式 # 为了便于并行编程, 提高语法的抽象级别 字面量 () -\u0026gt; o.f() () -\u0026gt; { o.f() } event -\u0026gt; o.f() (x, y) -\u0026gt; x + y (Long x, Long y) -\u0026gt; x + y f(O::f1) # 简化 f((o) -\u0026gt; o.f1()) 类型 Predicate\u0026lt;T\u0026gt; Predicate\u0026lt;String\u0026gt; condition = (s) -\u0026gt; s.length() \u0026gt; 4); if (condition.test(s)) {} Predicate\u0026lt;String\u0026gt; a = (s) -\u0026gt; s.length() \u0026gt; 1; b = (s) -\u0026gt; s.length() \u0026gt; 2; Predicate\u0026lt;String\u0026gt; c = a.and(b) Consumer\u0026lt;T\u0026gt; Function\u0026lt;T, R\u0026gt; Supplier\u0026lt;T\u0026gt; UnaryOperator\u0026lt;T\u0026gt; BinaryOperator\u0026lt;T\u0026gt; 特点 参数类型推断 作为匿名内部类 button.addListener(event -\u0026gt; o.f()) 引用外部变量时，不一定声明final, 但要是即成事实(effectively)的final变量(不能重复赋值) 重载解析参数类型时，找最具体类型。 无法推断时报错, 如 # 重定义方法名或传入时做强转 f(Predicate\u0026lt;Integer\u0026gt; p) f(IntPredicate p) 声明 静态导入(1.5) import static java.lang.Math.max import static java.lang.Math.* # 导入的是方法，该方法就可以直接使用 方法 修饰 开放性 修饰符 当前类 同包 子类 其他包 public √ √ √ √ protected √ √ √ 无 √ √ private √ default修饰接口默认方法(虚方法) 方法参数都是值传递，无法改变外部的参数本身 可变参数(1.5) public void sum(int x, int... args) static方法初始化先于构造方法 overload与override 重载 父类、同类、子类中比较 方法名一致，入参有变化 返回值不影响 # 为副作用调用时(忽略返回值)考虑 修饰符、异常声明不影响 重写 入参，出参一致 构造方法、final方法不能被重写 static方法不能被重写，可再次声明 访问权限不能缩小 异常声明不扩大，可加非强制异常 finally # return前走finally, catch块中也一样 类 字面量 public class A {{ ... }} 这是匿名构造函数，相当于: public class A { public A() { ... } } 接口 不能定义构造函数 只定义抽象方法 类成员全部public 定义的实际上都是常量 不能定义静态方法 类可实现多接口 函数接口，接口声明默认方法 default方法 Collection中添加stream()会打破前版本二进制兼容性(原版本找不到stream而报错)，默认方法指定找不到时使用的方法, 维护兼容性 可被其它接口继承重写 多重继承 继承代码块，不继承类状态(属性) # 有些人认为多重继承的问题在于状态的继承 冲突报错, 可子类重写解决 优先级: 子类 \u0026gt; 类 \u0026gt; 接口 抽象类 # 有抽象方法的类 可定义构造函数 可定义抽象方法和具体方法 成员可以是private, default, protected, public 可定义成员变量 可定义静态方法 类只继承一个抽象类 接口与抽象类 不能实例化 可作为引用类型 继承的类要实现所有抽象方法，否则还是抽象类 抽象方法 不能static，static方法不能被重写 不能native，native需要实现 不能synchronized，synchronized表示一种实现方式 静态变量 # 实例变量属于对象实例，有多个 属于类，只有一个，实现共享内存 内部类 静态嵌套类(static nested class), 可不依赖外部类实例被实例化 内部类，外部类实例化后才能实例化 new Outer().new Inner() # 在Outer类中也不能new Innter() 注解 @FunctionalInterface # 检查是否符合函数接口标准 安全性 安全沙箱机制 类加载体系 .class文件检验器 JVM及语言的安全特性 安全管理器与java api 异常 # 异常机制 运行时出现错误，控制权交给异常处理器 方法立即结束，抛出一个异常对象。调用该方法的程序停止，搜索处理代码 Throwable Error # JVM相关问题，如系统崩溃、虚拟机错误、内存不足、方法调用栈溢出 Exception # 指可处理的异常 RuntimeException # 非强制(unchecked)。除RuntimeException都是强制异常(checked) Error java.lang.OutOfMemoryError # 内存溢出 java.lang.StackOverflowError # 堆溢出 运行时异常 ArithmeticExecption # 算术异常类 IllegalArgumentException # 方法传递参数错误 NullPointerException # 空指针异常类 ClassNotFoundException # 类找不到，加载路径错误 ClassCastException # 类型强制转换异常 NoClassDefFoundException # 未找到类定义 ArrayIndexOutOfBoundsException # 数组越界异常 ArrayStoreException # 数组存储异常，操作数组时类型不一致 BufferOverflowException # 缓冲溢出异常 NegativeArrayException # 数组负下标异常 NoSuchMethodException # 方法未找到异常 IllegalStateException # servlet过滤器中 chain.doFilter中request,response类型为ServletRequest，ServletResponse时出错 NumberFormatException # 字符串转换为数字异常 SQLException # sql语句出错 InstantiationException # 实例化异常 DateTimeException # 无效时间 强制异常 FileNotFoundException # 文件未找到异常 ParseException # 解析时间字符串到时间类型出错 ServletException # servlet转发时出现过该异常 IOException # io异常 java.sql.BatchUpdateException # sql批处理 com.mysql.jdbc.MysqlDataTruncation # mysql 插入数据被截断,插入数据过长时遇到 注解 # # annotation (1.5特性) jdk的注解 @SuppressWarnings(\u0026quot;deprecation\u0026quot;) # 压制警告 # SuppressWarning不是一个标记注解。它有一个类型为String[]的成员， # 参数如下 all to suppress all warnings boxing to suppress warnings relative to boxing/unboxing operations cast to suppress warnings relative to cast operations dep-ann to suppress warnings relative to deprecated annotation deprecation to suppress warnings relative to deprecation fallthrough to suppress warnings relative to missing breaks in switch statements finally to suppress warnings relative to finally block that don’t return hiding to suppress warnings relative to locals that hide variable incomplete-switch to suppress warnings relative to missing entries in a switch statement (enum case) nls to suppress warnings relative to non-nls string literals null to suppress warnings relative to null analysis rawtypes to suppress warnings relative to un-specific types when using generics on class params restriction to suppress warnings relative to usage of discouraged or forbidden references serial to suppress warnings relative to missing serialVersionUID field for a serializable class static-access to suppress warnings relative to incorrect static access synthetic-access to suppress warnings relative to unoptimized access from inner classes unchecked to suppress warnings relative to unchecked operations unqualified-field-access to suppress warnings relative to field access unqualified unused to suppress warnings relative to unused code @Deprecated # 标记过时 @Override 元注解(metadata) @Retention(RetentionPolicy.RUNTIME) # 保留策略 CLASS、RUNTIME和SOURCE这三种，分别表示注解保存在类文件、JVM运行时刻和源代码阶段 # 只有当声明为RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息。 @Target用来声明注解作用目标，如类型、方法和域等。如 @Target(ElementType.TYPE) //接口、类、枚举、注解 @Target(ElementType.FIELD) //字段、枚举的常量 @Target(ElementType.METHOD) //方法 @Target(ElementType.PARAMETER) //方法参数 @Target(ElementType.CONSTRUCTOR) //构造函数 @Target(ElementType.LOCAL_VARIABLE)//局部变量 @Target(ElementType.ANNOTATION_TYPE)//注解 @Target(ElementType.PACKAGE) ///包 @Document：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 自定义注解 # @interface用来声明一个注解 ## 其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型。可以通过default来声明参数的默认值。 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface Assignment { String assignee(); int effort(); double finished() default 0; } 版本特性 # java8 接口中可以定义静态方法与默认方法 不能重写equals，hashCode或toString的默认实现。 Lambdas # Lambda更好地利用多核处理器 与匿名内部类 匿名内部类编译成.class文件，lambda表达式编译成私有方法, 使用invokedynamic(java7)字节码指令动态绑定 private static java.lang.Object lambda$0(java.lang.String) 匿名内部类this指向该匿名内部类, lambda的this总指向所有的外部类 内部变量 可以使用静态、非静态局部变量 只能引用final和局部变量，不能修改外部变量 # 不可变闭包 注解 @Functionalnterface # 函数式接口 有且公有一个抽象方法 # SAM(single abstract method) 允许定义静态方法、默认方法、Object中的public方法 不是必须的，接口符合以上定义就算函数式接口 函数 (int x, int y) -\u0026gt; { return x + y; } Runnable r = () -\u0026gt; { System.out.println(\u0026quot;Running!\u0026quot;); } SAM new Thread(() -\u0026gt; System.out.println(\u0026quot;\u0026quot;)) # Thread有单个抽象方法run() 列表 list1.forEach(System::out::println) java.util.function包 # 声明于function包内的接口可接收lambda表达式 Predicate Stream Optional Jigsaw # jdk上的模块系统，使大块的代码更易于管理 java7 switch中可以使用字符串了 运用List\u0026lt;String\u0026gt; tempList = new ArrayList\u0026lt;\u0026gt;(); 即泛型实例化类型自动推断 语法上支持集合，而不一定是数组 final List\u0026lt;Integer\u0026gt; piDigits = [ 1,2,3,4,5,8 ]; map集合支持并发请求，且可以写成 Map map = {name:\u0026quot;xxx\u0026quot;,age:18}; java6 ui增强 Java应用程序可以和本地平台更好的集成 web service支持增强：jax-ws2.0与jaxb2.0 优先支持编写 XML web service 客户端程序。 用过简单的annotaion将你的API发布成.NET交互的web services. jdbc4.0 Scripting可以在Java源代码中混入JavaScript java5 泛型，允许指定集合里元素的类型 枚举类型 自动类型包装和拆包 可变参数 注解 增强for循环 静态引入 新的线程模型与并发库 HashMap的替代者ConcurrentHashMap ArrayList的替代者CopyOnWriteArrayList api # Object # clone() # 开始与new相同分配内存, 然后填充对象的域。是浅拷贝 深拷贝 class Body implements Cloneable { @Override protected Object clone() throws CloneNotSupportedException { body = (Body) super.clone() body.head = (Head)head.clone() return body } } equals() # 具有自反性、对称性、传递性、一致性 # 先确定hashCode一致，equals相等的对象hashCode一定相等 # 没重写时比较地址 重写equals 1 == 检查是否引用 2 instanceof 检查类型 3 属性是否匹配 4 是否满足对称性、传递性、一致性 5 总要重写hashCode finalize() # 垃圾收集时调用 valueOf() # 转换成自己类型 wait() notify() notifyAll() 系统 # System currentTimeMillis(); # Clock.systemDefaultZone().millis() # java8 arraycopy() File String[] list() # 列出目录下的所有文件名 String[] list(FilenameFilter filter) # 列出目录下符合filter规范的文件名（filter用匿名内部类定义） Scanner next() 例如： Scanner input = new Scanner(System.in); int data = input.nextInt(); System.out.println(data); 得到继承结构 StackTraceElement [] stackTraces = new Throwable().getStackTrace(); for(StackTraceElement temp : stackTraces){ temp.getClassName() temp.getFieldName(); temp.getMethodName(); } Cloneable接口 clone() 包装类型 # parseXxx(String) # 从字符串转换 valueOf(String) # 从字符串转换 String # # final类，不可继承 length() # String length是方法, 数组length是属性 isEmpty() indexOf() lastIndexOf() chatAt() substring() trim() toLowerCase() toUpperCase() split() getBytes() replaceAll() String p = \u0026quot;A0A1A2\u0026quot;.replaceAll(\u0026quot;([A-Z]{1,1})([A-Z0-9]{1,1})?\u0026quot;, \u0026quot;$1=$2 \u0026quot;); # A=0 A=1 A=2 ## $符是组的概念，与\u0026quot;([A-Z]{1,1})([A-Z0-9]{1,1})?\u0026quot;中的两对括号代表两组 ## {1,1}代表匹配1次, (从1次到1次) replaceAll(\u0026quot;[A_Z]\u0026quot;, \u0026quot;_$0\u0026quot;) # 分组匹配被替换的值到替换字符串中 类 StringBuffer # 线程安全 append() insert() StringBuilder # 1.5引入 intern() # 返回常量池中的引用(String对象equals池中某对象为true)，没有时添加 正则 # Pattern [abc] [^abc] [a-zA-Z] [a-z\u0026amp;\u0026amp;[def]] [a-z\u0026amp;\u0026amp;[^bc]] = [ad-z] [a-z\u0026amp;\u0026amp;[^m-p]] = [a-lq-z] .除了换行符之外的任意字符 \\d [0-9] \\D [^0-9] \\s [ \\t\\n\\x0B\\f\\r] \\S [^\\s] \\w [a-zA-Z_0-9] \\W [^\\w] posix的字符 \\p{Lower} [a-z] \\p{Upper} [A-Z] \\p{ASCII} [\\x00-\\x7F] \\p{Alpha} [\\p{Lower}\\p{Upper}] \\p{Digit} [0-9] \\p{Alnum} [\\p{Alpha}\\p{Digit}] \\p{Punct} !\u0026quot;#$%\u0026amp;'()*+,-./:;\u0026lt;=\u0026gt;?@[\\]^_`{|}~ 之一 \\p{Graph} [\\p{Alnum}\\p{Punct}]所有可见字符 \\p{Print} [\\p{Graph}\\x20] \\x20为空格 \\p{Blank} [ \\t] 一个空格或tab \\p{Cntrl} [\\x00-\\x1f\\x7f] 控制字符 \\p{XDigit} [0-9a-fA-F] 十六进制符号 \\p{Space} [ \\t\\n\\x0B\\f\\r] 代表边界的字符 ^ 行首 $ 行尾 \\b A word boundary \\B A non-word boundary \\A input的开始 \\G The end of the previous match \\Z The end of the input but for the final terminator,if any \\z The end of the input Greedy 定量 X? 0或1个 X* 0或多个 X+ 1或多个 X{n} n个 X{n,} 最少n个 X{n,m} n到m，包含n,m Logical operators XY XY X|Y X或Y (X) 捕获的匹配 \\n 得到第n个捕获 Quotation \\ Nothing, but quotes the following character \\Q Nothing, but quotes all characters until \\E \\E Nothing, but ends quoting started by \\Q Special constructs (non-capturing) (?某某) * 方案 * 任意字符 [\\S\\s] # 匹配空格或非空格，就是任意一个字符 ## [\\W\\w] 相同 * 匹配多个 Pattern p1 = Pattern.compile(\u0026quot;\\\\(.*?\\\\)\u0026quot;); Matcher m1 = p1.matcher(\u0026quot;kjdjdjj(738383)ddk(9999)ppp\u0026quot;); while (m1.find()) { System.out.println(m1.group().replaceAll(\u0026quot;[()]\u0026quot;, \u0026quot;\u0026quot;)); } Math # round # 四舍五入, -11.5得到11 时间 # java8的新时间类实现JSR-310 特点 不变性, 内部状态不变、线程安全 关注点分离，定义了不同的类：Date, Time, DateTime, timestamp, 时区 策略模式，所有类定义format()和parse()方法 实用方法，所有类定义了方便操作的方法 扩展性，使用ISO-8601日历系统，也可扩展在其它系统 包 java.time # 基础包 java.time.chrono # 非ISO日历系统的泛化api java.time.format # 格式化和解析，基本不用(基础包有封装) java.time.temporal # 时态对象，用来改变时间 java.time.zone # 时区相关类 JSR-310 精确到纳秒 对应人类观念，也不是像Date一样用零点时间表示日期 大部分基于Joda-Time，区别： 包名从org.joda.time到java.time 不接受null值，Joda-Time视null为0 机器用Instant和人用DateIme接口差别更明显 所有异常继承DateTimeException 方法 Of # 静态工厂 parse # 静态解析 get is with # 设置时间，不可变 plus minus to # 转换类型 at # 组合对象 Calendar getInstance() get(Calendar.YEAR) # YEAR, MONTH, DATE, HOUR_OF_DAY, MINUTE, SECOND getTimeInMillis() # 时间戳，毫秒 getTime() set() # 设置到时间 使用 Calendar c = Calendar.getInstance() c.set(Calendar.DAY_OF_MONTH, 1) // 月第一天 c.set(Calendar.DAY_OF_MONTH, c.getActualMaximum(Calendar.DAY_OF_MONTH)) // 月最后一天 System.out.println(format.format(c.getTime(0)) c.add(Calendar.DATE, -1) // 昨天 SimpleDateFormat format(Date) 使用 SimpleDateFormat formatter = new SimpleDateFormat(\u0026quot;yyyy/MM/dd\u0026quot;) System.out.println(formatter.format(new Date())) LocalDate # java8, 默认格式(yyyy-MM-dd) now() LocalDate.now() LocalDate.now(ZoneId.of(\u0026quot;Asia/Kolkata\u0026quot;)) // 时区时间 of() # 指定时间 ofEpochDay() # 纪元日(1970.1.1)后多少天 ofYearDay() # 年后多少天 minusDays() today.minusDays(1) # 昨天 isLeapYear() # 闰年 isBefore() # 比较大小 atTime() # 返回LocalDateTime plusDays() plusWeeks() plusMonths() minusDays() minusWeeks() minusMonths() with() # 定位时间 today.with(TemporalAdjusters.irstDayOfMonth()) today.with(TemporalAdujsters.lastDayOfYear()) until() # 返回Period 使用 LocalDate today = LocalDate.now() LocalDate firstday = LocalDate.of(today.getYear(), today.getMonth(), 1) // 月第一天 LocalDate lastDay = today.with(TemporaAdjusters.lastDayOfMonth()) // 月最后一天 System.out.println(lastDay) LocalTime # java8, 默认格式(hh:mm:ss.zzz) now() of() ofSecondOfDay() # 从0开始多少秒后 LocalDateTime # java8，默认格式(yyyy-MM-dd-HH-mm-ss.zzz) now() of() LocalDaeTime.of(LocalDate.now(), LocalTime.now()) LocalDateTime.of(2014, Month.JANUARY, 1, 10, 10, 30) ofEpochSecond() ofInstant() parse() # 按格式parse字符串 LocalDateTime.parse(\u0026quot;27::Apr::2014 21::39::48\u0026quot;, DateTimeFormatter.ofPattern(\u0026quot;d::MMM::uuuu HH::mm::ss\u0026quot;)) getYear() getMonthValue() getDayOfMonth() getHour() getMinute() getSecond() minusDays() plush() ZonedDateTime now() parse() ZonedDateTime.parse(\u0026quot;2013-12-31T23:59:59Z[Europe/Paris]\u0026quot;) Clock # java8 systemDefaultZone() systemUTC() system(ZoneId.of(\u0026quot;Europe/Paris\u0026quot;)) fixed(Instant.now(), ZoneId.of(\u0026quot;Asia/Shanghai\u0026quot;)) # 固定时区 offset(c1, Duration.ofSeconds(2)) # 偏移 millis() # 时间戳 Instant # java8, 机器可读格式，精确到纳秒 now() now(clock1) # 得到瞬间时间 ofEpochMilli toEpochMilli() getEpochSecond() Duration # java8, 时间段 between() ofDays() toDays() toHourse() Period # java8 getMonths() # 算成月数 DateTimeFormatter # java8 BASIC_ISO_DATE ofPatter() 使用 DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026quot;yyyy/MM/dd\u0026quot;) System.out.println(LocalDate.now().format(formatter)) Chronology # java8 年表 localDateTime(LocalDateTime.now()) 类 HijrahChronology INSTANCE 新旧转换 // Date, Instant, LocalDateTime Instant timestamp = new Date().toInstant() LocalDateTime date = LocalDateTime.ofInstant(timestamp, ZoneId.of(ZoneId.SHORT_IDS.get(\u0026quot;PST\u0026quot;))) Date date = Date.from(Instant.now()) // Calendar, Instant Instant time = Calendar.getInstance().toInstant() // TimeZone, ZoneId ZoneId defaultZone = TimeZone.getDefault().toZoneId() TimeZone timeZone = TimeZone.getTimeZone(defaultZone) // GregorianCalendar, ZonedDateTime ZonedDateTime gCalendarDateTime = new GregorianCalendar().toZonedDateTime() GregorianCalendar gCalendar = GregorianCalendar.from(gCalendarDateTime) 数组 # length 属性 newInstance() 泛型数组实例化 T[] = (T[]) new Object[0]; (T[]) Array.newInstance(type, size); 枚举 # # 枚举类型的比较取决于声明顺序 举类的实现类 java.lang.Enum\u0026lt;E\u0026gt; extends Object static \u0026lt;T extends Enum\u0026lt;T\u0026gt;\u0026gt; T valueOf(Class\u0026lt;T\u0026gt; enumType, String name) javax.lang.model.element.ElementKind extends java.lang.Enum\u0026lt;ElementKind\u0026gt; # 实际创建枚举类型时继承的类 # 此类的静态方法不是Enum本身的方法，所以它们在java.lang.Enum的javadoc中没有出现。 static ElementKind valueOf(String name) # 为提供的字符串返回一个枚举类型，该枚举类型必须精确地匹配源代码声明。 static ElementKind[] values() # 返回一个枚举类型所有可能值的数组。 定义1 public enum Color { RED, GREEN, BLANK, YELLOW # 元素列表必须在最前, 如果元素列表后面没有东西的话，可以省略分号 // 枚举的构造方法必须是私有的 // private WeekDay() { //} } 定义2 enum Signal { GREEN, YELLOW, RED } 定义3 自定义构造（要注意必须在enum的实例序列最后添加一个分号） public enum Color { RED(\u0026quot;红色\u0026quot;, 1), GREEN(\u0026quot;绿色\u0026quot;, 2), BLANK(\u0026quot;白色\u0026quot;, 3), YELLO(\u0026quot;黄色\u0026quot;, 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) { this.name = name; this.index = index; } // 普通方法 public static String getName(int index) { for (Color c : Color.values()) { if (c.getIndex() == index) { return c.name; } } return null; } // get set 方法 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getIndex() { return index; } public void setIndex(int index) { this.index = index; } } 使用 public enum TrafficLamp { RED(30) { @Override public TrafficLamp nextLamp() { return GREEN; } }, GREEN(45) { @Override public TrafficLamp nextLamp() { return YELLOW; } }, YELLOW(5) { @Override public TrafficLamp nextLamp() { return RED; } }; public abstract TrafficLamp nextLamp(); private int time; private TrafficLamp(int time) { this.time = time; } } @Test public void testHere() { WeekDay weekDay = WeekDay.MON; weekDay.toString(); weekDay.name(); // 排行 weekDay.ordinal(); WeekDay.valueOf(\u0026quot;SUN\u0026quot;); WeekDay.values(); } 自己实现 public abstract class WeekDay { private WeekDay() { }; /* * public WeekDay nextDay(){ if(this == SUN){ return MON; }else { return * SUN; } } */ public abstract WeekDay nextDay(); public final static WeekDay SUN = new WeekDay() { @Override public WeekDay nextDay() { return MON; } }; public final static WeekDay MON = new WeekDay() { @Override public WeekDay nextDay() { return SUN; } }; @Override public String toString() { return this == SUN ? \u0026quot;SUN\u0026quot; : \u0026quot;MON\u0026quot;; } } 使用接口组织枚举 public interface Food { enum Coffee implements Food{ BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO } enum Dessert implements Food{ FRUIT, CAKE, GELATO } } 用switch判断 # JDK1.6之前的switch语句只支持int,char,enum类型 enum Signal { GREEN, YELLOW, RED } public class TrafficLight { Signal color = Signal.RED; public void change() { switch (color) { case RED: color = Signal.GREEN; break; case YELLOW: color = Signal.RED; break; case GREEN: color = Signal.YELLOW; break; } } } 枚举的集合 java.util.EnumSet # 集合中的元素不重复 java.util.EnumMap # key是enum类型，而value则可以是任意类型。 Collection # 继承结构 \u0026lt;\u0026lt;Collection\u0026gt;\u0026gt; \u0026lt;\u0026lt;Queue\u0026gt;\u0026gt; PriorityQueue \u0026lt;\u0026lt;Deque\u0026gt;\u0026gt; ArrayDeque \u0026lt;\u0026lt;List\u0026gt;\u0026gt; ArrayList LinkedList # 实现\u0026lt;\u0026lt;Deque\u0026gt;\u0026gt; Vector Stack Set HashSet EnumSet \u0026lt;\u0026lt;SortedSet\u0026gt;\u0026gt; TreeSet \u0026lt;\u0026lt;Map\u0026gt;\u0026gt; HashMap LinkedHashMap \u0026lt;\u0026lt;SortedMap\u0026gt;\u0026gt; TreeMap Arrays fill() # 赋初值 asList() # 数组转List sort() binarySearch() equals() # 数组比较 parallelPrefix() # 前值和，如0, 1, 2, 3 处理后为 0, 1, 3, 6。 parallelSetAll() # 修改值 parallelSort() ArrayList # 用数组实现，查询快，增删慢 toArray() # 返回list中的所有元素作为一个Object [] toArray(T[] a) # 返回泛型类型的list中的所有元素 trimToSize() # 优化掉删除出现的空位 stream() parallelStream() # 并行流 实现 public ArrayList() { array = EmptyArray.OBJECT; } public ArrayList(int capacity) { if (capacity \u0026lt; 0) { throw new IllegalArgumentException(\u0026quot;capacity \u0026lt; 0:\u0026quot; + capacity); } array = (capacity == 0 ? EmptyArray.OBJECT : new Object[capacity]); } public ArrayList(Collection\u0026lt;? extends E\u0026gt; collection) { if (collection == null) { throw new NullPointerException(\u0026quot;collection == null\u0026quot;); } Object[] a = collection.toArray(); if (a.getClass() != Object[].class) { Object[] newArray = new Object[a.length]; System.arraycopy(a, 0, newArray, 0, a.length); a = newArray; } array = a; size = a.length; } @Override public boolean add(E object) { Object[] a = array; int s = size; if (s == a.length) { Object[] newArray = new Object[s + (s \u0026lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s \u0026gt;\u0026gt; 1)]; System.arraycopy(a, 0, newArray, 0, s) array = a = newArray; } a[s] = object; size = s + 1; modCount++; // 修改次数 return true; } @Override public E remove(int index){ Object[] a = array; int s = size; if (index \u0026gt;= s) { throwIndexOutOfBoundsException(index, s); } @SuppressWarnings(\u0026quot;unchecked\u0026quot;) E result = (E) a[index]; System.arraycopy(a, index + 1, a, index, --s - index); a[s] = null; size = s; modCount++; return result; } @Override public void clear() { if (size != 0) { Arrays.fill(array, 0, size, null); size = 0; modCount++; } } LinkedList # 循环双向链表实现，增删快，查询慢 类 Entry Vector # 数组实现，线程安全，增删慢，查询慢 HashMap # hash表实现，支持null的键和值 实现 数组存Entry, 位置称为bucket Entry为元素，单链表拉链解决碰撞 hashcode(key)得到bucket索引 扩容要rehash 类 Entry computeIfAbsent() # 无值时用计算新值 forEach() LinkedHashMap # 继承HashMap，hash表和链表实现，保存了插入顺序 HashTable # 线程安全，不支持null的键和值 TreeMap # 红黑树实现，有序，实现SortedMap接口 HashSet # HashMap实现，有时需要重写equals()和hashCode() # HashSet先按hashCode分区, 后比较equals的值再存放。修改参与hashCode值运算的属性后, 该元素删除会因无法定位,导致内存泄漏 LinkedHashSet # 继承HashSet。LinkedHashMap实现 List、Map、Set区别 List、Set单列，Map双列 List有序可重复, 可索引, Map无序，键不重复，值可重复，Set无序，不重复 Queue Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;String\u0026gt;(); queue.offer(\u0026quot;a\u0026quot;); # 添加 queue.poll(); # 返回第一个元素并删除 queue.element(); # 返回第一个元素, empty时抛异常 queue.peek(); # 同element(), 但empty时返回null Collections sort(List, Comparator) synchronizedCollection() # 线程不安全集合方法调用前加锁 synchronizedList() synchronizedMap() synchronizedSet() 流 # 函数流特点 Iterator是外部迭代，串行化操作。Stream是内部迭代, 自动并行处理 方法分惰性和及早执行 有序集合有序处理，无序集合无序处理 Stream of() # 静态方法，产生流 forEach() collect() # 用收集器, 转出结构化数据 collect(Collectors.toList()) # 转出List map() map(s -\u0026gt; s.toUpperCase()) reduce() reduce(0, (acc, element) -\u0026gt; acc + element) # acc是累加器 filter() filter(s -\u0026gt; isDigit(s.charAt(0))) flatMap() # 平铺多stream flatMap(numbers -\u0026gt; numbers.stream()) min() min(Comparator.comparing(track -\u0026gt; track.getLength())) max() peek() get() # 执行得到结果 count() mapToInt() # IntStream, LongStream, DoubleStream, 对基本类型做特殊优化(如不装箱占内存) IntStream range(0, N) sequential() # 串行 parallel() # 并行, fork-join结构。注意数据结构(arrayList快于linkedList)。有状态操作会线程通信, 如sorted, distinct, limit mapToObj() summaryStatistics() IntSummaryStatistics getAverage() Optional of(\u0026quot;a\u0026quot;) ofNullable(null) empty() get() # 空时抛异常 isPresent() ifPresent((s) -\u0026gt; {}) orElse(\u0026quot;b\u0026quot;) # 空返回b orElseGet(() -\u0026gt; \u0026quot;b\u0026quot;) orElseThrow(ValuesAsentException::new) map((s) -\u0026gt; s + \u0026quot;b\u0026quot;) # map非空值，返回Optional flatMap((s) -\u0026gt; Optinal.of(s + \u0026quot;b\u0026quot;)) filter((s) -\u0026gt; s.length() \u0026gt; 6) Collectors toList() toSet() toCollection(TreeSet::new) minBy() maxBy() averagingInt() summingInt() partitioningBy() # 按true, false分两组 groupingBy() # 分多组 joining(\u0026quot;,\u0026quot;, \u0026quot;[\u0026quot;, \u0026quot;]\u0026quot;) # 拼字符串, 传参是分隔符、前缀、后缀 o-\u0026gt; 自定义收集器 public class StringCombiner { public StringCombiner add(String element) { if (atStart()) { builder.append(prefix); } else { builder.append(delim); } builder.append(element); return this; } public StringCombiner merge(StringCombiner other) { builder.append(other.builder); return this; } } public class StringCollector implements Collector\u0026lt;String, StringCombiner, String\u0026gt; { public Supplier\u0026lt;StringCombiner\u0026gt; supplier(){ return () -\u0026gt; new StringCombiner(delim, prefix, suffix); } public BiConsumer\u0026lt;StringCombiner, String\u0026gt; accumulator(){ return StringCombiner::add; } public BinaryOperator\u0026lt;StringCombiner\u0026gt; combiner(){ return StringCombiner::merge; } public Function\u0026lt;StringCombiner, String\u0026gt; finisher(){ return StringCombiner::toString; } characteristics() # 描述特征 } o-\u0026gt; predicate void filter(list list, Predicate condition) list1.stream().filter((s) -\u0026gt; (condition.test(s))).forEach((s) -\u0026gt; { System.out.println(s)}) io流分类 输入、输出 节点流(如FileReader)、处理流(抽象处理方法) 字节流(InputStream)、字符流(InputStreamReader) 字节流处理一个字节，字符流包装字节流，设置编码类型映射成字符，处理字符 InputStream BufferedInputStream FileInputStream OutputStream BufferedOutputStream FileOutputStream Reader InputStreamReader FilerReader BufferedReader readLine() Writer OutputStreamWriter FileWriter BufferedWriter newLine() write(String) Serializable接口 # 对象流化 需求例如 spring中配置的bean session中用到的类 为什么实现序列化接口 为了注册序列化序号（不显式注册会自动注册）来标识java类，区分相同类名不同包名的类 实现深拷贝 public static \u0026lt;T extends Serializable\u0026gt; T clone(T obj) throws Exception { // 不必调close(), 因为gc时流对象释放 ByteArrayOutputStream bout = new ByteArrayOutputStream() ObjectOutputStream oos = new ObjectOutputStream(bout) oos.writeObject(obj) ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()) ObjectInputStream ois = new ObjectInputStream(bin) return (T)ois.readObject() } 并行 # 线程通信 共享变量 wait(), notify()实现生产和消费通知 同步线程 wait(), sleep(), notify(), notifyAll() ThreadLocal # 线程内数据共享，线程隔离 withInitial(() -\u0026gt; new SimpleDateFormat()) # 直接get()时返回调用结果 set(T t) # 向当前线程对象放入泛型对象 get() # 得到当前线程已放入的对象 InheritableThreadLocal\u0026lt;T\u0026gt; # 继承ThreadLocal, 子线程可使用父线程变量 Timer o-\u0026gt; class MyTask extends java.util.TimerTask{ @Override public void run() { // TODO Auto-generated method stub System.out.println(\u0026quot;________\u0026quot;); } } Timer timer = new Timer() timer.schedule(new MyTask(), 1000, 2000) // 1秒后执行，每两秒执行一次 timer.cancel(); // 停止任务 Thread currentThread().getContextClassLoader().getResource(\u0026quot;/\u0026quot;).getPath() # 静态路径 run() start() sleep() # 占有锁 o-\u0026gt; # 异常抛出不到父线程 new Thread(){ @Override public void run(){ while(count \u0026gt; 0){ synchronized(AboutThread.class){ count--; } } } }.start(); o-\u0026gt; # 异常抛出不到父线程 new Thread(new Runnable() { @Override public void run() { while(count \u0026gt; 0){ synchronized(AboutThread.class){ count--; } } } }).start(); FutureTask # java5 o-\u0026gt; # 有结果和异常 FutureTask\u0026lt;String\u0026gt; future = new FutureTask(new Callable\u0026lt;String\u0026gt;(){ @Override public String call() { return \u0026quot;\u0026quot; } }) new Thread(future).start() future.get() java.util.concurrent Executors # 线程池工厂 策略 1 创建并设置 2 execute()时 1 线程数小于corePoolSize, 创建线程并执行 2 线程数大于或等于corePoolSize, 任务入队列 3 队列满，线程数小于maximumPoolSize, 创建线程并执行 4 队列满，线程数大于maximumPoolSize, 抛出异常 3 线程完成任务，从队列取任务执行 4 线程空闲，超过keepAliveTime, 运行线程大于corePoolSize, 线程停掉 newFixedThreadPool(3) # 固定数量 ExecutorService Pool = Executors.newFixedThreadPool(2); pool.execute(new MyRunnable()) pool.shutdown() newCachedThreadPool() # 根据情况创建数量 newSingleThreadExecutor() # 数量为1 newScheduledThreadPool(2) # 延时 ScheduledExecutorService pool = Executors.newScheduledThreadPool(2); Thread r1 = new MyRunnable(); pool.execute(); pool.schedule(r1, 10, TimeUnit.MILLISECONDS); # t1在10秒后执行 pool.shutdown(); \u0026lt;\u0026lt;ExecutorService\u0026gt;\u0026gt; execute(Runnable) submit(Runnable) # 返回Future # submit(Callable) invokeAny() # 返回执行最快的一个结果 invokeAll() # 所有执行结束后返回 shutdown() # 只interrupt()空闲线程 shutdownNow() # interrupt()所有线程 ThreadPoolExecutor corePoolSize # 最小数量 maximumPoolSize # 最大数量 keepAliveTime # 线程空闲等待时间 \u0026lt;\u0026lt;ScheduledExecutorService\u0026gt;\u0026gt; schedule(r1, 10, TimeUnit.MILLISECONDS) # 10秒后执行 scheduleAtFixedRate(r1, 1, 2, TimeUnit.MILLISECONDS) # 1秒后执行，2秒一次，间隔计算开始时间。异常直接关闭 scheduleWithFixedDelay(r1, 1, 2, TimeUnit.MILLISECONDS) # 同上，间隔计算结束时间 ScheduledExecutorPoolService ForkJoinPool # java7 ForJoinPool(4) # 并行级别 invoke() RecursiveAction # 没返回值 MyRecursiveAction extends RecursiveAction { @Override protected void compute() { new MyRecursiveAction().fork() } } RecursiveTask # 有返回值 MyRecursiveTask extends RecursiveTask\u0026lt;Long\u0026gt; { @Override protected Long Compute() { MyRecursiveTask t1 = new MyRecursiveTask() t1.fork() retrun t1.join() } } CopyOnWriteArrayList # 列表被修改时，使用旧副本(保护性复制) \u0026lt;\u0026lt;BlockingQueue\u0026gt;\u0026gt; # 锁实现，插入和取值阻塞, 不能插入null add() # 抛异常 offer() # 超时退出，返回特殊值 put() # 阻塞 remove() # 抛异常 poll() # 超时退出，返回特殊值 take() # 阻塞 element() # 检查，抛异常 peek() # 返回特殊值 ArrayBlockingQueue # 固定大小 size() o-\u0026gt; queue.put(new PoisonPill()) # 毒丸, 标志数据取完 obj.isPoisonPill() LinkedBlockingQueue # 链式 # 两个ReentrantLock(可重入锁)分别控制元素入队和出队 # tomcat用TaskQueue的父类，它重写offer方法减少创建多余线程 PriorityBkockingQueue # 无界，排序 # 一个独占锁控制入队和出队, 通过cas(无锁算法)保证同时只有一个线程扩容成功 DelayQueue # 无界, 延迟期满才能提取。内部用PriorityQueue实现 SynchronousQueue # 单元素, cas实现 ConcurrentQueue add() offer() poll() peek() ConcurrentLinkedQueue # 无界队列, 使用cas isEmpty() size() remove() contains() ConcurrentHashMap # 并发集合通过复杂的策略提高效率, 用ReentrantLock # 加了concurrencyLevel属性，决定锁分段个数，取2的次幂。内部用分段锁技术，每段Segment中再存放Entity[]数组 ConcurrentSkipListMap # 非阻塞Hash跳表, 功能同TreeMap，线程安全，用跳表实现 java.util.concurrent.atomic # 基本数据 AtomicBoolean get() set() getAndSet() compareAndSet() AtomicInteger get() set() getAndSet() compareAndSet() getAndIncrement() getAndDecrement() getAndAdd() AtomicIntegerArray # 对int[]类型封装，使用Unsafe类通过cas方式实现线程安全 get() length() getAndSet() compareAndSet() getAndIncrement() getAndDecrement() addAndGet() AtomicLong AtomicLongArray Semaphore # 信号量控制并发 semaphore(5, true) # 5个信号量，公平(先启动线程大概率先获得锁) o-\u0026gt; Semaphore semaphore = new Semaphore(5, true) semaphore.acquire() semaphore.release() java.util.concurrent.locks # 锁 \u0026lt;\u0026lt;Lock\u0026gt;\u0026gt; # 主要是可重入锁，非阻塞结构上下文使用 ReentrantLock # 多线程不可同时访问一个类中2个加Lock的方法, 因为是2个锁。 lock() unlock # 用lock, unlock可设置交替锁(hand-over-hand locking), 轮流锁、解锁一部分 tryLcok() # 可设置超时 # 同时超时，再尝试失败再尝试而进入活锁。设置不同超时时间减少活锁机率 lockInterruptibly() # 突破死锁 newCondition() # 条件变量, 原子地阻塞并解锁，直到条件满足(如有容量，队列非空) condition.await() condition.signal() condition.signalAll() \u0026lt;\u0026lt;ReadWriteLock\u0026gt;\u0026gt; # 读写锁，写独占 \u0026lt;\u0026lt;Condition\u0026gt;\u0026gt; # 替代wait(), notify() await() signal() 内省 # # IntroSpector，操作javabean 例子 Point p = new Point(); PropertyDescriptor pd = new PropertyDescriptor(\u0026quot;x\u0026quot;, p.getClass()); Method methodGetX = pd.getReadMethod(); Method methodSetX = pd.getWriteMethod(); methodSetX.invoke(p, 7); System.out.println(methodGetX.invoke(p)); BeanInfo beanInfo = Introspector.getBeanInfo(p.getClass()); PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors(); for(PropertyDescriptor pd2 : pds){ if(pd.getName().equals(\u0026quot;x\u0026quot;)){ System.out.println(pd.getReadMethod().invoke(p)); break; } } 反射 # # 类中成分映射为类 字节码 Class类型对象指向类加载器中加载的字节码 Class对象不可以new, 因为字节码是类加载器中加载的, 不可能new出来 虚拟机中同一个类的字节码只有一份 预定义的class实例对象9个 # 包装类型中Type就是class，如int.class == Integer.Type # void的包装类型为Void void byte short int long float double boolean char 获得字节码三种方法 Class.forName(类名) 类名.class this.getClass() 内部类 内部类不为public时，会在前面加上public 的类的类名和$，所以不能用其类名.class来得到它的字节码 泛型 父类可以通过反射泛型类得到泛型的class, 通过该class创建泛型实例 方法中泛型类实例通过传入class创建(如dbutils) 用途 1. 根据配置文件实例化并注入对象(如spring) 2. 实现框架 # 运行时调用自定义类的指定方法(如struts的Action) 代理 动态代理机制 # 运行时确定, 用来AOP编程 没有接口的类：CGlib通过派生子类实现。运行时动态修改字节码 有接口的类:Proxy生成代理，但是生成的类是接口类型 静态代理 # 代理指定类，编译时确定 Class Type # 该类对应的字节码对象 isPrimitive() # 是否是基本类型 isArray() # 是否是数组 getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes) newInstance() # 用不带参数的构造方法创建对象 getField(\u0026quot;y\u0026quot;) : Field # 得到属性 field.get(该class的对象); # 得到属性的值 getDeclaredField(\u0026quot;x\u0026quot;) : Field field.setAccessible(true); field.get(该class的对象); # 暴力反射 getFields() : Field[] field.set(该class的对象, 新的值); getMethod(方法名, 方法参数类型的字节码对象) : Method method.invoke(该class的对象, 该方法的参数); # invoke中调用对象为null表是调用静态方法 # 注意，jdk1.5中为了兼容jdk1.4(jdk1.4中如果用到可变参数传递的是一个参数的数组), ## 在invoke中第二个参数为数组时，会把数组拆开成可变参数传递。但是这样的话，当我们传递的参数本身就是数组时， ## 如main(String[] args)中的参数, 就会变成多个参数。解决办法是：对要传递的数组参数进行打包， ## 如new Object[]{new String[]{\u0026quot;aa\u0026quot;, \u0026quot;bb\u0026quot;, \u0026quot;cc\u0026quot;}}, # 注：基本类型的数组是Object对象，String[]不是Object对象，而是Object[]对象 ## 参数也可以写成(Object)new String[]{\u0026quot;aa\u0026quot;, \u0026quot;bb\u0026quot;, \u0026quot;cc\u0026quot;}; # 这里把Object[]强转为是个Object对象, 这样jdk就不会对数组对象Object[]进行拆分了 getClassLoader() getResourceAsStream(\u0026quot;\u0026quot;) # 相对路径从class根目录开始。没有绝对路径，\u0026quot;/\u0026quot;会报错 getResourceAsStream(\u0026quot;\u0026quot;) # 相对路径从当前包目录开始。\u0026quot;/\u0026quot;绝对路径从class根目录开始 使用class Class cls1 = Data.class; # 虚拟机中已经加载过该类的字节码时 Class cls2 = p1.getClass(); Class cls3 = Class.forName(\u0026quot;java.lang.String\u0026quot;); # 在虚拟机中没有加载过该类的字节码时 使用constructor新建实例 Constructor constructor1 = String.class.getConstructor(StringBuffer.class); String str1 = (String)constructor1.newInstance(new StringBuffer(\u0026quot;abc\u0026quot;)); 数组 class上的isArray()判断是否数组 # 不同维度(一维、二维等), 不同类型的数组，不是同一份字节码。只有同维度同类型的数组是相同的字节码 ## 基本类型的数组是Object对象，如int[]。String[]是一个Object[]对象，不是Object对象 Arrays.asList() # 打印Object[], 不能打印基本类型数组的Object Array.getLength(obj) # 得到长度 Array.get(obj, i) # 得到数组中的元素 # 没有办法得到int[] 对象的元素类型(即int), 只能取得其元素之后得到其类型 泛型 public class BaseDao\u0026lt;T\u0026gt; 中 // 得到的是继承类的字节码 // hibernate.basedao2.HeroDao Class subClass = this.getClass(); // 直接超类 // hibernate.basedao2.BaseDao\u0026lt;hibernate.domain.Hero\u0026gt; Type type = subClass.getGenericSuperclass(); // 得到参数 ParameterizedType pt = (ParameterizedType) type; // 参数数组 Type[] types = pt.getActualTypeArguments(); // hibernate.domain.Hero type = types[0]; //User this.clazz= (Class) type; Proxy # 只代理有接口的类 o-\u0026gt; final List\u0026lt;String\u0026gt; list = newArrayList\u0026lt;String\u0026gt;() List\u0026lt;String\u0026gt; proxyInstance = (List\u0026lt;String\u0026gt;) Proxy.newProxyInstance(list.getClass().getClassLoader(), list.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{ return method.invoke(list, args) } }) proxyInstance.add(1) web service # 常识 基于socket # socket可以跨语言访问 # 单用socket提供网络服务出现的问题： 1.不能处理不同协议的请求，如http协议发送的是请求头信息 #　http调用socket:127.0.0.1:8888/或action=\u0026quot;127.0.0.1:8888\u0026quot; 2.添加新参数，客户端也要修改 版本 jdk6之后的版本开始支持web service jdk6不支持soap1.2 传输标准：xml或json # 普遍使用xml,RestFul使用json 优点 易推广、协议匹配、便于升级（加参数） 服务方式 # 返回的结果均为xml http get http post # get与post方式直接传递参数，参数易混淆，所以有soap发送xml的方式 soap1.1 soap1.2 soap 常识： soap:simple object access protocol soap是以post方式传输的 内容 请求soap \u0026lt;soapenv:Envelope xmlns:soapenv=\u0026quot;http://schemas.xmlsoap.org/soap/envelope/\u0026quot; xmlns:q0=\u0026quot;http://my.test/\u0026quot; xmlns:xsd=\u0026quot;http://www.w3.org/2001/XMLSchema\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\u0026gt; \u0026lt;soapenv:Body\u0026gt; \u0026lt;q0:sayHello\u0026gt; \u0026lt;arg0\u0026gt;小明\u0026lt;/arg0\u0026gt; \u0026lt;/q0:sayHello\u0026gt; \u0026lt;/soapenv:Body\u0026gt; \u0026lt;/soapenv:Envelope\u0026gt; 响应soap \u0026lt;S:Envelope xmlns:S=\u0026quot;http://schemas.xmlsoap.org/soap/envelope/\u0026quot;\u0026gt; \u0026lt;S:Body\u0026gt; \u0026lt;ns2:sayHelloResponse xmlns:ns2=\u0026quot;http://my.test/\u0026quot;\u0026gt; \u0026lt;return\u0026gt;hello,小明\u0026lt;/return\u0026gt; \u0026lt;/ns2:sayHelloResponse\u0026gt; \u0026lt;/S:Body\u0026gt; \u0026lt;/S:Envelope\u0026gt; wsdl 获得 http://192.168.10.3:1234/hello?wsdl # 发布url后面加?wsdl 内容 # 查看时从后向前看 \u0026lt;service\u0026gt;标签 name属性：默认 发布类名 + Service \u0026lt;port\u0026gt;标签 name属性：默认有soap1.1 soap1.2 get post(jdk1.6只有soap1.1)，默认 类名 + port binding属性:真正的实现者 # 指向\u0026lt;binding\u0026gt;标签 \u0026lt;soap:address\u0026gt;标签 location属性:访问的地址 \u0026lt;binding\u0026gt;标签：是真正的实现类,soap协议，是文本，方法名 \u0026lt;portType\u0026gt;标签： input output \u0026lt;message\u0026gt;标签 用schema格式来描述参数类型 xsd:schema关联的schema文件中 \u0026lt;element\u0026gt;标签 ，约定了参数类型 创建与发布 发布到eclipse的jetty容器 @WebService MyWebService public String showName(Strng name) System.out.println(\u0026quot;name=\u0026quot; + name); return name + \u0026quot;你好!\u0026quot;; main Endpoint.publish(\u0026quot;http://localhost:8888/hello\u0026quot;,new MyWebService()); # 发布webService ## 1.6.0_13及之前的版本不支持,1.6.0_14之后的版本支持 ## 发布之后http://localhost:8888/hello?wsdl中有wsdl文件 可以发布成服务的方法 1.非final、static修饰的public方法 2.@WebMethod(exclude=true)方法前加该注解时不发布该方法 调用 HttpClient get post soap wsdl.xml #　web service提供给不同平台生成解决方案的配置文件 ## HttpClient发送soap时充当了:wsdl.xml解决方案调用的过程 o-\u0026gt; wsimport.exe(jdk1.6) 解析wsdl.xml文件 命令：wsimport -s . -p cn.itcast # -s 保存源码（默认不保存）,-p指定包名 生成类： # jdk1.6中解析时忽略生成soap12服务类文件（jdk1.6不支持）与get post服务类文件(默认忽略) XxxService XxxServicePort Xxx .. 调用： MyWSService mywsService = new MyWSService(); String retVal = mywsService.getMyWSPort().sayHello(); o-\u0026gt; myeclipse的web service soap浏览器 # 可以从soap浏览器中查看请求和返回的soap.xml文件的源码 |-\u0026gt; 右上角wsdl page |-\u0026gt; 左边栏 uddi main |-\u0026gt; 右边栏按提示输入即可 o-\u0026gt; ajax 方式一：直接调用 缺点 新版浏览器（ie10等）不支持跨域请求(为了安全)，所以只能请求localhost 会把数据暴露在客户端 注解 @WebMethod(exclude=true) # 对此方法不进行发布 @WebService # 声明为web service服务类 ## 可选属性 name=\u0026quot;服务名\u0026quot;, portName=\u0026quot;端口名\u0026quot;, serviceName=\u0026quot;真正服务类的名字\u0026quot;, targetNamespace=\u0026quot;包名a.b.c\u0026quot; @WebResult(name=\u0026quot;\u0026quot;) # 方法返回值类型前，指定返回值名（如果返回的是集合，则指定的是集合内元素的名） @WebParam(name=\u0026quot;\u0026quot;) # 方法参数值类型前，指定参数名 框架 # cglib # 构造接口 dbutils fastjson # 淘宝json beanUtils ioUtils jvm # 基础 # 继承 被继承的对象是会单例，不会新创建。如果被继承的对象没有，则创建一个 多态 父类(接口)中定义的引用变量，在运行时动态绑定到具体实例的方法执行 内部unicode编码 类 初始化时机 new 访问静态变量，或对静态变量赋值 调用静态方法 反射 Class.forName(\u0026quot;\u0026quot;) 初始化子类，会先初始化父类 jvm启动时标明的类 (java com.a.A中的A类) 步骤 类加载 链接 验证 准备 # 静态变量分配内存，设置默认初始值 解析 # 符号引用替换直接引用 初始化父类(非接口) 初始化 父类 初始化语句 # 如static块和static变量 线程 运行时都有线程栈，保存变量值信息。访问对象值时，建立变量副本。修改后(线程退出前)副本值写到对象 JIT(just in time) # 热点代码检测, 运行时编译和优化 内存 # # java自动管理堆栈, c++手动分配 组成 方法区(method area) 组成 类信息 class 数据区(data segment) 运行时常量池(constant pool) # 编译期确定，保存在.class中的数据 字面量 文本形式的符号引用 字段名称和描述符 方法名称和描述符 类和接口的全限定名 静态区(static segment) 静态变量 代码区(code segement) JIT编译后的代码 特点 线程共享 静态分配, 位置不改变 栈(stack) 分类 虚拟机栈(vm stack) 本地方法栈(native method stack) 保存 基础数据类型 引用类型在栈分配地址, 局部变量生命周期结束后，栈空间立即回收 方法调用 # 一次调用一个帧(frame) 方法的形参, 调用完回收 方法引用参数, 在栈上分配地址, 调用完回收 方法实参，栈空间分配，调用完释放 特点 线程隔离 逻辑概念，可连续可不连续, 系统自动分配。栈中的字面值可共享,如int i = 3 StackOverflowError 实现 java的stack存放的是frames, frames由heap分配，所以stack内存不连续 只存在本地变量、返回值、调用方法，不能直接push和pop frams 堆(heap) 保存 引用类型在堆分配类变量, 局部变量生命周期结束后，堆空间等待gc回收 this 特点 线程共享 以随意顺序，运行时分配和回收空间, 代码申请 大小、数量、生命期常常在编译时不确定 细分为新生代和老年代, 再具体为 eden survivor(from survivor、to survivor), tenured OutOfMemoryError 实现 存放所有runtime data heap是jvm启动时创建 程序计数器(program counter register) 特点 线程隔离 机制 程序计数器、虚拟机栈、本地方法栈 是线程私有空间 随线程产生和销毁，每个栈帧分配多少内存在随类结构确定。内存分配回收都是确定的 方法区和堆 一个接口的各实现类需要内存可能不一样, 所以运行时才知道创建哪些对象，内存分配和回收是动态的，gc主要关注 内存溢出 原因 加载数据过大 # 大约10万条以上, 应分页查询 集合中对象引用未清除 代码循环产生对象 第三方软件bug 启动参数内存设置过小 方案 jvm启动参数 -Xms, -Xmx jvm错误日志, OutOfMemory前信息 内存查看工具动态查看 类加载器 # 父亲委派机制(java2) # 常用类不被替代 先试上层类加载器 4种类加载器(加载类文件位置不同) 层级关系 # 父级类加载器向下加载子加载 BootStrap ExtClassLoader AppClassLoader 自己的类加载器 优先级 只加载层级关系靠前面的同名类 BootStrap # c++写的二进制代码，jvm中启动时创建,无法获得引用对象 位置 JRE/lib/rt.jar # java9后为jrt-fs.jar 参数-Xbootclasspath指定 代码 System.class.getClassLoader() # null ## 说明是BootStrap类加载器加载的，不能得到该类加载器 ExtClassLoader(sun.misc.Launcher$ExtClassLoader) 位置 JRE/lib/ext/*.jar 参数-Djava.ext.dirs指定 AppClassLoader(sun.misc.Launcher$AppClassLoader) 位置 环境变量CLASSPATH 或 系统属性java.class.path 参数-cp覆盖 代码 ClassLoaderText.class.getClassLoader().getClass().getName() # AppClassLoader 自定义 # 如tomcat的StandardClassLoader # 继承ClassLoader api TestClass.class.getClassLoader() getParent() # 得到加载该类加载器的类加载器 loadClass(String name) # 找parent委托，没有加载时执行findClass(String name) ## 模板方法的设计模式，见 note-\u0026gt; 设计模式 findClass(String name) # 自己加载 defineClass(..) # 将二进制数据转换为class 线程 # 该线程类加载器加载线程中的第一个类 线程.setContextClassLoader(ClassLoader cl) # 指定一个线程的类加载器 自己的类加载器 挂在AppClassLoader下面 加载指定的目录 该目录下的class加密后，自己的类加载器解密 写法 覆盖findClass(String name) 例子 public class MyClassLoader extends ClassLoader{ private String classDir; @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException{ // 传入的name是全限定名 String classFileName = classDir + \u0026quot;\\\\\u0026quot; + name.substring(name.lastIndexOf('.') + 1) + \u0026quot;.class\u0026quot;; // 处理异常 FileInputStream fis = new FileInputStream(classFileName); ByteArayOutputStream bos = new ByteArraOutputStream(); cypher(fis, bos); fis.close(); byte[] bytes = bos.toByteArray(); return defineClass(bytes, 0, bytes.length); // 抛出异常时 return super.findClass(name); } public MyClassLoader(){} public MyClassLoader(String classDir){this.classDir = classDir;} private static void cypher(InputStream ips, OutputStream ops){...} } // 删掉父类的ClassLoaderAttachment.class // new 的MyClassLoader挂在了AppClassLoader这个类加载器上 Class clazz = new MyClassLoader(\u0026quot;itcastLib\u0026quot;).loadClass(\u0026quot;cn.itcast.day2.ClassLoaderAttachment\u0026quot;); // 错误写法。因为这样写 jvm编译器要加载ClassLoaderAttachment类，但是该类已经加密 ClassLoaderAttachment d1 = (ClassLoaderAttachment)clazz.newInstance(); // 正确写法。用该加密类继承的父类来引用它的实例 Date d1 = (Date)clazz.newInstance(); servlet部署 tomcat类加载器 AppClassLoader StandardClassLoader WebappClassLoader 输出Servlet.class的jar与servlet-api.jar到jdk/lib/ext # 因为servlet.class加载的时候需要HttpServlet类，该类在tomcat提供的servlet-api.jar 规范 # 命名与写法 包名 小写、只用一个单词、只用单数 类名 UpperCamelCase 类名可以使用复数 抽象类开头 Abstract或Base 异常类结尾 Exception 测试类以要测试类名开始，以Test结尾 使用的设计模式，可以写在类名上 接口类形容能力时，用形容词做名字(一般是-able, 如Translatable) 实现类1: 结尾加Impl 实现类2: Translatable的实现类名Translator 枚举类结尾加Enum 成员全大写,下划线隔开 方法名、参数名、成员变量、局部变量 lowerCamelCase 获得单个对象前缀get 获得多个对象前缀list 获得统计值前缀count 插入前缀save或insert 删除前缀remove或delete 修改前缀update 方法按顺序排列 # 公有或保护 -\u0026gt; 私有 -\u0026gt; getter/setter 常量 MAX_COUNT 布尔类型变量不以is开头 保留字和运算符左右加空格, 参数逗号后加空格 缩进用4空格 杜绝不规范的缩写 如 AbstractClass写成AbsClass、condition写成condi 换行 # 单行120要换行 运算符、点号在下一行 参数中的逗号在上一行 括号前不换行，如append(\u0026quot;a\u0026quot;)的括号前 空行 执行语句组、变量定义语句组、业务逻辑或不同语义之间插入空行 # 相同业务逻辑和语义间不要空行 领域模型 # POJO是 DO/DTO/BO/VO 的统称，禁止命名xxxPOJO 数据对象 xxxDO 数据传输对象 xxxDTO 展示对象 xxxVO ide的text file encoding设置为utf-8, 文件换行用unix格式 类 类成员和方法，访问控制从严 构造方法不加业务逻辑 POJO类要实现toString (避免继承) 接口类 接口类中方法和属性，不要加修饰(如public)， 尽量不定义变量和default实现 枚举类 变量值在一范围内变化的，用Enum类，有延伸属性的(如MONDAY(1))，用Enum类 方法 覆写方法一定加@Override，可判断是否覆盖成功 过时方法要加@Deprecated，并写明新接口是什么 可变参数只用在ids之类的地方 不使用过时方法 变量 常量 不要定义一个总常量类，应分类定义单独的类 共享常量 跨应用，放在二方库，如client.jar中的constant目录 应用内，放在一方库modules中的constant目录 子工程内部，放在子工程的constant目录 包内，放在包的constant目录 类内，在类中定义private static final 不写魔法值，如key=\u0026quot;Id#toabao\u0026quot; long型赋值用大写L, 如Long a = 2L 数组 String[] args,而不是String args[] 编程 方法可以反回null, 但要注释充分 POJO类属性和RPC方法参数返回值使用包装类型，局部变量使用基本类型 避免所有NPE(空指针)问题(赋初值或非空检查) 用\u0026quot;a\u0026quot;.equals(object)而不是object.equals(\u0026quot;a\u0026quot;),否则容易抛空指针 # 也可以用java.util.Objects#equals String.split时，要检查最后分隔符后有无内容 (如 \u0026quot;a,b,,\u0026quot;, 使用arr[3]时异常) 包装类比较，用equals # 只有Integer -128到127在IntegerCache中运用享元，才== 用StringBuilder扩展字符串 慎用Object.clone，是浅拷贝，要重写 final 不需要重新赋值的变量 对象参数加final，表示不修改引用 类方法不重写 正则要预编译 # Patern.compile()在外 Math.random()可以取到0，取整数时用nextInt或nextLong方法 用System.currentTimeMillis()而不是new Date().getTime() 任何数据结构的构造或初始化，都要指定大小，避免OOM NPE(空指针异常)场景 返回包装类型为null时，解包NPE 数据库查询结果 集合里元素即使isNotEmpty，也可取出null 远程调用结果要判null Session中数据判null 级联调用 a.b().c() 集合 初始化时，尽量指定大小 hashCode与equals # 同时重写 Set存的对象与Map的键，要重写hashCode与equals sublist只是个视图，不能转ArrayList sublist修改原集合个数，会引起之后使用的CuncurrentModificationException异常 集合转数组要用toArray(T[]) Arrays.asList返回的集合不要add/remove/clear # 只是适配器，内部还是数组 \u0026lt;? extends T\u0026gt;接收的对象，不能用add方法 remove/add用Iterator，并发要加锁，不能foreach JDK7以上版本，Comparator要满足3个条件，不然Arrays.sort和Collections.sort会报异常 x,y比较结果和y,x相反 x\u0026gt;y, y\u0026gt;z, 则x\u0026gt;z x=y则x, z比较结果与y, z比较结果相同 使用entrySet遍历Map, 而不是KeySet, JDK8使用Map.foreach # KeySet遍历了2次，一次转为Iterator对象，一次从hashMap取key的value null情况 集合类 Key Value Super 说明 Hashtable 非null 非null Dictionary 线程安全 ConcurrentHashMap 非null 非null AbstractMap 分段锁技术 TreeMap 非null 可null AbstractMap 线程不安全 HashMap 可null 可null AbstractMap 线程不安全 稳定性和有序性 ArrayList order/unsort HashMap unorder/unsort TreeSet order/sort 并发 单例方法要线程安全, 获取单例要注意线程安全 线程或线程池指定有意义的名称 public class TimerTaskThread extends Thread { public TimerTaskThread() { super.setName(\u0026quot;TimerTaskThread\u0026quot;) 线程资源只从线程池取，不要自行创建 不用Executors而用ThreadPoolExecutor创建 FixedThreadPool和SingleThreadPool允许请求队列长度为Integer.MAX_VALUE, 可能堆积大量请求OOM(out of memory) CachedThreadPool和ScheduledThreadPool允许创建线程数量为Integer.MAX_VALUE，可能创建大量线程，导致OOM SimpleDateFormat线程不安全，不要static。应使用DateUtils JDK8用Instant代替Date, LOcalDateTime代替Calendar, DateTimeFormatter代替Simpledateformatter 尽量锁小范围 多线程中，都对多对象加锁，加锁顺序要一致，否则会死锁 并发修改时，在应用层加锁或在缓存加锁或在数据库层加乐观锁并使用version作更新依据 每次访问冲突率小于20%, 使用乐观锁，否则用悲观锁。 乐观锁重试次数不得小于3 Timer的多个TimeTask，一个没有捕获异常会同时终止。应使用ScheduledExecutorServcie CountDownLatch进行异步转同步时，线程代码注意catch异常，确保countDown执行 # 子线程异常，主线程catch不到 Random多线程下，会因竞争同一seed导致性能下降。JDK7后用ThreadLocalRandom 延迟初始化的双重检查锁隐患。将目标属性声明为volatile volatile不能解决多写问题, 使用AtomicInteger或JDK8的LongAdder，它减少了乐观锁的重试次数 HashMap在容量不够进行resize时，高并发可能会出现死链，导致cpu飙升 ThreadLocal使用static修饰 控制语句 switch中，case要么有break/return，要么注释执行到哪个case。switch都要有default 不要省略大括号 尽量少用else，用卫语句（只有一个if）或状态模式 条件判断只调用getXxx/isXxx，运算赋值给布尔变量判断，提高可读性 循环体中语句考量性能 参数校验场景 调用频次低的方法 执行时间大的方法 需要极高稳定性和可用性 对外开放接口 敏感权限入口 不需参数校验场景 可能被循环调用 # 要注明外部参数检查 底层方法，如DAO private方法明确入参已校验 注释 # 自解释代码少注释，注释要反应设计思想与代码逻辑，描述业务含义 类、类属性、类方法使用/**内容*/ # Javadoc规范 抽象方法要Javadoc注释，除返回值、参数、异常说明外，还要指出做什么事，实现什么功能 类要添加创建者 枚举类型都要注释 用中文说清楚 注释要跟进修改 注释掉的代码要有说明 特殊注释，要注明标记人和标记时间 TODO: (标记人，标记时间，[预计处理时间]) 异常 事先检查值，而不是调用后处理异常 异常不要用来做流程控制，效率低 异常要对小段代码, 要细分 异常要处理或上抛，最外层一定要处理 注意事务回滚 finally资源要关闭，异常要处理，JDK7用 try-with-resources finally中不要return，否则不执行try中return 不要捕获异常的父类 rpc异常定义自己的result，好处一是调用方不会漏查，二是可以加异常栈 不抛RuntimeException，Exception和Throwable。抛确定异常 日志 不直接用日志系统，用门面模式的日志框架 日志保存15天，因为有“周”频次发生的异常 利用日志文件名和目录 stats/desc/monitor/visit/appName_logType_logName.log 直接logger.debug(a + b)，级别为warn是表达式还会执行。用2种方式避免 if logger.isDebugEnabled() {...} logger.debug(\u0026quot;{} {}\u0026quot;, id, symbol) 设置log4j.xml的additivity=false，防止重复打印 要记录异常堆栈。logger.error(参数或对象toString + \u0026quot;_\u0026quot; + e.getMessage(), e) 可以用warn记录用户输入参数错误的情况，避免用户投诉时无所适从 生产环境禁止输出debug日志，有选择地输出info。如果用warn来记录刚上线业务，要注意量的问题 mysql 类型 is_xxx unsigned tinyint # 1是0否 唯一索引名 uk_字段名，普通索引idx_字段名 # unique key, index 表名、字段名 库名与应用名尽量一致 小写与数字 不数字开头 不能下划线间仅有数字 不使用复数 不用保留字 desc、range、match、delayed等 必有三字段 id unsigned bigint，单表时自增，步长为1 gmt_create date_time gmt_modified date_time 表名 业务名称_表的作用，如tiger_task, mpp_config 字段含义修改或追加状态时，及时更新注释 orm boolean属性POJO不加is, 数据库前缀is_ # mybatis generator生成的代码中需要修改 不能返回resultClass, HashMap, Hashtable xml配置用 #{}, #param#, 不要${}，容易sql注入 尽量不用ibatis的queryForList(String statementName, int start, int size) # 会查整表 应在sqlmap.xml中引入#start# #size# 更新时要同时更新gmt_modified 不要大而全的更新接口，传入POJO类。会更新无改动字段，易出错，效率低，增加binlog存储 @Transactional事务不要滥用，影响qps 事务回滚方案包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等 分层 开放接口层 终端显示层 web层 对访问控制进行转发，参数校验，不复用业务简单处理 service层 manager层 对第三方封装 service通用能力下沉，如缓存方案、中间件通用处理 与dao层交互，对dao业务通用能力封装 dao层 直接抛DAOException，由service层处理 外部接口或第三方平台 分层领域模型 DO (Data Object) DTO (Data Transfer Object) BO (Business Object) QUERY VO (View Object) 服务器 JVM设置- XX :+ HeapDumpOnOutOfMemoryError, OOM时输出dump信息 "},{"id":65,"href":"/docs/pl/java/javaweb/","title":"JavaWeb","section":"Java","content":" 基础 # 分层 视图层 jsp 控制层 servlet 业务层 过滤数据 manager层 封装第三方，service能力下沉，dao中间件 数据访问层对象 封装对象 数据库 java web 13种技术 JDBC Java Database Connectivty JNDI Java Name and Directory Interface EJB Enterprise JavaBean RMI Remote Method Invoke Java IDL/CORBA JSP Java Server Pages Java Servlet XML Extensible Markup Language JMS Java Message Service JTS Java Transaction Service JTA Java Transaction Architecture JavaMail JAF JavaBeans Activation Framework jsp # 基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层 域对象 pageContext # 当前页面有效 request # 一次请求范围 session # 会话 application context # 同一服务器 内置对象 Request Response Session Out # 输出流 PageContext # context Page # jsp的this Exception # \u0026lt;%@ page isErrorPage=\u0026quot;true\u0026quot;%\u0026gt; 时使用，显示异常信息 Application # 服务器 Config # 服务器配置 jsp-el表达式 # ${ } 11个内置对象 pageContext // pageContext page // map （相当于pageScope，不过写法上省略了Scope） requestScope // map sessionScope // map applicationScope // map param // map ,用${param.name}的形式得到传递的参数 paramValues // map\u0026lt;String,String []\u0026gt; header // map hearderValues // map\u0026lt;String, String []\u0026gt; cookie // map initParam // map 语法 ${list[0]}\u0026lt;br\u0026gt; ${map.mapteststring}\u0026lt;br\u0026gt; ${map[mapkey]}\u0026lt;br\u0026gt; ${map['mapteststring']}\u0026lt;br\u0026gt; ${request } ${pageContext.request.contextPath }\u0026lt;br\u0026gt; # el表达式中访问内置对象 ${requestScope.aaa } # 访问内置对象requestScope，得到request作用域中的aaa元素 ${pageContext.servletContext.contextPath }\u0026lt;br\u0026gt; ${param}\u0026lt;br\u0026gt; ${paramValues['a'] }\u0026lt;br\u0026gt; ${paramValues['a'][0] } ${paramValues['a'][1] } ${paramValues['a'][2] }\u0026lt;br\u0026gt; ${empty novalue}\u0026lt;br\u0026gt; ${1\u0026gt;2?\u0026quot;yes\u0026quot; : \u0026quot;no\u0026quot;}\u0026lt;br\u0026gt; # . 与 [] 可以替换使用，但有两点需要注意 1 .1不行，但是[1]可以 2 1\u0026gt; map[\u0026quot;key\u0026quot;] 是取map中\u0026quot;key\u0026quot;对应的值 2\u0026gt; map[key]是先从作用域中取得key的字符串如\u0026quot;aaa\u0026quot;,再取map中\u0026quot;aaa\u0026quot;对应的值 3\u0026gt; .key 相当于1\u0026gt;中的介绍，是取map中\u0026quot;key\u0026quot;对应的值 4\u0026gt; .是不能相当于2\u0026gt;中的介绍那样使用的 比较符${ }中使用 empty not empty 三元式（?:） 简单的算术运算 jsp-taglib标签库 # jstl标签库1.1 或1.2 标签库1.1中需要 jstl.jar 与 standard.jar 库 可放入域scope的类型 page request session application functions el表达式级使用，其它都标签级使用 functions \u0026lt;%@ taglib prefix=\u0026quot;fn\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/functions\u0026quot;%\u0026gt; ${fn:contains(\u0026quot;gzitcast\u0026quot;, \u0026quot;itcast\u0026quot;) } \u0026lt;br\u0026gt; ${fn:containsIgnoreCase(\u0026quot;gzitcast\u0026quot;, \u0026quot;ITCAST\u0026quot;) } \u0026lt;br\u0026gt; ${fn:endsWith(\u0026quot;gzitcast\u0026quot;, \u0026quot;st\u0026quot;) } \u0026lt;br\u0026gt; ${fn:indexOf(\u0026quot;gzitcsat\u0026quot;, \u0026quot;cs\u0026quot;) } \u0026lt;br\u0026gt; ${fn:join(arr, \u0026quot;-\u0026quot;) } \u0026lt;br\u0026gt; ${fn:length(\u0026quot;gzitcast\u0026quot;) } \u0026lt;br\u0026gt; ${fn:replace(\u0026quot;gzitcast\u0026quot;, \u0026quot;gz\u0026quot;, \u0026quot;广州\u0026quot;) } \u0026lt;br\u0026gt; ${fn:split(\u0026quot;gz,it,cast\u0026quot;, \u0026quot;,\u0026quot;) } \u0026lt;br\u0026gt; ${fn:startsWith(\u0026quot;gzitcsat\u0026quot;, \u0026quot;gz\u0026quot;) } \u0026lt;br\u0026gt; ${fn:substring(\u0026quot;gzitcsat\u0026quot;, 3, 8) } \u0026lt;br\u0026gt; ${fn:substringAfter(\u0026quot;gzitcsat\u0026quot;, \u0026quot;cs\u0026quot;) } \u0026lt;br\u0026gt; ${fn:substringBefore(\u0026quot;gzitcsat\u0026quot;, \u0026quot;cs\u0026quot;) } \u0026lt;br\u0026gt; ${fn:toLowerCase(\u0026quot;gziTCsat\u0026quot;) } \u0026lt;br\u0026gt; ${fn:toUpperCase(\u0026quot;gziTCsat\u0026quot;) } \u0026lt;br\u0026gt; ${fn:trim(\u0026quot; gzitcsat \u0026quot;) } \u0026lt;br\u0026gt; \u0026lt;%-- 对字符串中进行转义处理，如：会把\u0026quot;\u0026lt;\u0026quot;替换为\u0026quot;\u0026amp;lt;\u0026quot;，把\u0026quot;\u0026gt;\u0026quot;替换为\u0026quot;\u0026amp;gt;\u0026quot; --%\u0026gt; ${fn:escapeXml(\u0026quot;\u0026lt;h3\u0026gt;gzitcsat\u0026lt;/h3\u0026gt;\u0026quot;) } \u0026lt;br\u0026gt; core 所有标签： out set remove catch if choose when otherwise forEach url param redirect forTokens import \u0026lt;%@ taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/cores\u0026quot;%\u0026gt; \u0026lt;c:out var=\u0026quot;\u0026quot; default=\u0026quot;\u0026quot; escapeXml=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;%-- 放过xml过滤，让它显示，默认不显示 --%\u0026gt; ------------------------------------- scope方式 \u0026lt;c:set var=\u0026quot;\u0026quot; value=\u0026quot;\u0026quot; scope=\u0026quot;\u0026quot;\u0026gt; target方式 \u0026lt;%-- 这个放入page作用域中的map值 --%\u0026gt; \u0026lt;% Map map = new HashMap(); %\u0026gt; \u0026lt;c:set property=\u0026quot;key1\u0026quot; value=\u0026quot;key1value\u0026quot; target=\u0026quot;\u0026lt;%=map%\u0026gt;\u0026quot; \u0026lt;% pageContext.setAttribute(\u0026quot;map\u0026quot;, map); %\u0026gt; \u0026lt;c:out value=\u0026quot;${map[key2]}\u0026quot; ------------------------------------- \u0026lt;c:catch var=\u0026quot;e\u0026quot;\u0026gt;\u0026lt;/c:catch\u0026gt; \u0026lt;c:out value='\u0026lt;%= ((Exception)pageContext.getAttribute(\u0026quot;e\u0026quot;,PageContext.PAGE_SCOPE)).getMessage() %\u0026gt;'\u0026gt;\u0026lt;/c:out\u0026gt; ------------------------------------- \u0026lt;c:remove var=\u0026quot;\u0026quot; scope=\u0026quot;\u0026quot;\u0026gt; ------------------------------------- \u0026lt;c:if test=\u0026quot;${not empty }\u0026quot; scope=\u0026quot;\u0026quot; var=\u0026quot;\u0026quot;\u0026gt; ------------------------------------- \u0026lt;%-- if...else标签 --%\u0026gt; \u0026lt;c:choose\u0026gt; \u0026lt;c:when test=\u0026quot;\u0026quot;\u0026gt; \u0026lt;c:otherwise\u0026gt; ------------------------------------- \u0026lt;c:forEach begin=\u0026quot;\u0026quot; end=\u0026quot;\u0026quot; step=\u0026quot;\u0026quot; items=\u0026quot;\u0026quot; var=\u0026quot;\u0026quot; varStatus=\u0026quot;state\u0026quot;\u0026gt; \u0026lt;%-- varStatus中的函数有first last count begin end --%\u0026gt; \u0026lt;tr bgcolor='${state.count%2 == 0? \u0026quot;red\u0026quot; : \u0026quot;pink\u0026quot;}' \u0026gt; \u0026lt;/c:forEach\u0026gt; varStatus可用的函数 current // 当前这次迭代的项 index // 索引 count // 计数 first // 第一个 last // 最后一个 begin // begin属性值 end // end 属性值 step // step属性值 ------------------------------------- uri 代表所有协议路径 \u0026lt;c:url var=\u0026quot;itcast\u0026quot; value=\u0026quot;http://www.itcast.cn\u0026quot; scope=\u0026quot;page\u0026quot; context=\u0026quot;\u0026quot; \u0026gt; \u0026lt;%-- context 是整个网站 --%\u0026gt; \u0026lt;c:param name=\u0026quot;name\u0026quot; value=\u0026quot;中文\u0026quot;\u0026gt; \u0026lt;%-- 这样传参数有编码 --%\u0026gt; 如果value值为\u0026quot;/\u0026quot; 则加入context属性提供上下文名称，如果context也被省略，就使用当前servlet的上下文名称 ------------------------------------- \u0026lt;c:redirect url=\u0026quot;${itcast}\u0026quot; context=\u0026quot;\u0026quot; \u0026gt; ------------------------------------- \u0026lt;c:set var=\u0026quot;name\u0026quot; value=\u0026quot;xx,xxx,xxx,xx\u0026quot; scope=\u0026quot;request\u0026quot; \u0026gt; \u0026lt;c:forTokens items=\u0026quot;${name}\u0026quot; delims=\u0026quot;,\u0026quot; begin=\u0026quot;\u0026quot; end=\u0026quot;\u0026quot; step=\u0026quot;1\u0026quot; var=\u0026quot;name\u0026quot; varStatus=\u0026quot;\u0026quot; \u0026gt; \u0026lt;%--切割字符串--%\u0026gt; ------------------------------------- \u0026lt;c:import url=\u0026quot;/publics/head.jsp\u0026quot; \u0026gt; \u0026lt;%--动态包含，引入公共文件--%\u0026gt;\u0026lt;%--网站publics文件夹--%\u0026gt; sql标签库 # 以前没有mvc模式的时候，通过页面访问数据库时用的，现在不用 引入 \u0026lt;%@ taglib prefix=\u0026quot;sql\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/sql\u0026quot; %\u0026gt; 设置数据源 \u0026lt;sql:setDataSource dataSource=”dataSource”[var=”name”] [scope=”page|request|session|application”]/\u0026gt; jdbc连接 \u0026lt;sql:setDataSource driver=”driverClass” url=”jdbcURL” user=”username” password=”pwd” [var=”name”] [scope=”page|request|session|application”]/\u0026gt; JSTL提供了\u0026lt;sql:query\u0026gt;、\u0026lt;sql:update\u0026gt;、\u0026lt;sql:param\u0026gt;、\u0026lt;sql:dateParam\u0026gt;和\u0026lt;sql:transaction\u0026gt;这5个标签 1.query: query必需指定数据源 \u0026lt;sql:query sql=”sqlQuery” var=”name” [scope=”page|request|session|application”] [dataSource=”dateSource”] [maxRow=”maxRow”] [startRow=”starRow”]/\u0026gt; 或 \u0026lt;sql:query var=”name” [scope=”page|request|session|application”] [dataSource=”dateSource”] [maxRow=”maxRow”] # 设定最多可以暂存数据的长度 [startRow=”starRow”] # 设定从哪一行开始 \u0026gt; sqlQuery \u0026lt;/sql:query\u0026gt; 结果集的参数 rowCount # 结果集中的记录总数 rowsByIndex # 以数字为作索引的查询结果 columnNames # 字段名称数组 Rows # 以字段为索引查询的结果 limitedByMaxRows # 是否设置了maxRows属性来限制查询记录的数量 limitedByMaxRows用来判断程序是否收到maxRows属性的限制。 并不是说设定了maxRows属性，得到结果集的limitedByMaxRows的属性都为true， 当取出的结果集小于maxRows时，则maxRows没有对结果集起到作用此时也为false。 例如可以使用startRow属性限制结果集的数据量。 2.update: \u0026lt;/sql:update\u0026gt; \u0026lt;sql:update sql=”SQL语句” [var=”name”] [scope=”page|request|session|application”] [dateSource=”dateSource”]/\u0026gt; 或 \u0026lt;sql:update [var=”name”] [scope=”page|request|session|application”] [dateSource=”dateSource”] \u0026gt; SQL语句 参数说明 dataSource # 数据源对象 其它与query一样 3.param 参数设置 \u0026lt;sql:param value=”value”/\u0026gt; 或 \u0026lt;sql:param\u0026gt; Value \u0026lt;/sql:param\u0026gt; 4.dataParam 标签 # 用于为SQL标签填充日期类型的参数值 参数说明 value：java.util.Date类型的参数。 type属性：指定填充日期的类型timestamp（全部日期和时间）、time（填充的参数为时间）、date（填充的参数为日期）。 5.transaction 标签 \u0026lt;sql:transaction [dataSource=”dataSource”] [isolation=”read_committed|read_uncommitted|repeatable|serializable”] \u0026gt; \u0026lt;sql:query\u0026gt; \u0026lt;sql:uptade\u0026gt; \u0026lt;/sql:transation\u0026gt; xml标签库 核心操作 out # 主要用来取出XML中的字符串。 属性 select # XPath语句 escapeXml # 是否转换特殊字符 parse # 用来解析xml文件 属性 doc # XML文件 systemId # XML文件的URL filter # XMLFilter过滤器 varDom # 储存解析后的XML文件 scopeDom # varDom的范围 set # 将从XML文件取得的内容储存至属性范围中 属性 select # XPath语句 流程控制 if choose when otherwise 属性 select # XPath语句 文件转换 \u0026lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”] [result=”result”] [var=”name”] [scope=”scopeName”] [xsltSystemId=”xsltsystemid”]/\u0026gt; 或 \u0026lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”] [result=”result”] [var=”name”] [scope=”scopeName”] [xsltSystemId=”xsltsystemid”] \u0026gt; \u0026lt;x:param/\u0026gt; \u0026lt;/x:transform\u0026gt; 或 \u0026lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”] [result=”result”] [var=”name”] [scope=”scopeName”] [xsltSystemId=”xsltsystemid”] \u0026gt; 属性 doc # 指定xml文件来源 xslt # 转化xml的样式模板 docSystemId # xml文件的URI xsltSystemId # xslt文件的URI result # 用来存储转换后的结果对象 国际化 \u0026lt;%@ taglib prefix=\u0026quot;fmt\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/fmt\u0026quot; %\u0026gt; 国际化标签 1.setLocale # 设置一个全局的地区代码,设定的是本地的环境 中文－大陆:\u0026lt;fmt:setLocale value=\u0026quot;zh_CN\u0026quot;/\u0026gt; \u0026lt;fmt:formatDate value=\u0026quot;${todayValue}\u0026quot;/\u0026gt;\u0026lt;br\u0026gt; 2.requestEncoding # 设置统一的请求编码 \u0026lt;fmt:requestEncoding value=\u0026quot;GB2312\u0026quot;/\u0026gt; 信息显示标签 1.\u0026lt;fmt:bundle\u0026gt; 设置临时要读取的资源文件 2.\u0026lt;fmt:message\u0026gt; 通过key取得value 3.\u0026lt;fmt:setBundle\u0026gt; 设置一个要读取的全局的资源文件 如 \u0026lt;fmt:setBundle basename=\u0026quot;applicationMessage\u0026quot; var=\u0026quot;MyResourse\u0026quot;/\u0026gt; # 绑定了名为applicationMessage_zh_CN.properties一类 的文件 \u0026lt;fmt:bundle basename=\u0026quot;MyResourse\u0026quot; prefix=\u0026quot;label.\u0026quot;\u0026gt; \u0026lt;fmt:message key=\u0026quot;backcolor\u0026quot; bundle=\u0026quot;${applicationBundle}\u0026quot;/\u0026gt; \u0026lt;fmt:message key=\u0026quot;fontcolor\u0026quot; /\u0026gt; \u0026lt;/fmt:bundle\u0026gt; 数字及日期格式化标签 1.\u0026lt;fmt:formatDate\u0026gt; 日期的格式化 属性 value:格式化的日期，该属性的内容应该是 java.util.Date 类型的实例 type:格式化的类型 pattern:格式化模式 timeZone:指定格式化日期的时区 2.\u0026lt;fmt:parseDate\u0026gt; 解析日期 属性 value:将被解析的字符串 type:解析格式化的类型 pattern:解析格式化模式 parseLocale:以本地化的形式来解析字符串，该属性的内容为 String 或 java.util.Locale 类型的实例 timeZone:指定解析格式化日期的时区 3.\u0026lt;fmt:formatNumber\u0026gt; 数字格式化 属性 value:格式化的数字,该数值可以是 String 类型或 java.lang.Number 类型的实例 type:格式化的类型,可能值包括:currency（货币）、number（数字）和percent（百分比） pattern:格式化模式 maxIntegerDigits:指定格式化结果的最大值 minIntegerDigits:指定格式化结果的最小值 maxFractionDigits:指定格式化结果的最大值，带小数 minFractionDigits:指定格式化结果的最小值，带小数 如 \u0026lt;fmt:formatNumber value=\u0026quot;1000.888\u0026quot; type=\u0026quot;currency\u0026quot; var=\u0026quot;money\u0026quot;/\u0026gt; 4.\u0026lt;fmt:parseNumber\u0026gt; 解析数字 属性 value:将被解析的字符串 type:解析格式化的类型 pattern:解析格式化模式 如 \u0026lt;fmt:parseNumber value=\u0026quot;15%\u0026quot; type=\u0026quot;percent\u0026quot; var=\u0026quot;num\u0026quot;/\u0026gt; 5.\u0026lt;fmt:setTimeZone\u0026gt; 标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行属性描述 属性 value # 时区的设置 var # 用于保存时区为一个变量 6.\u0026lt;fmt:timeZone\u0026gt; 标签将使得在其标签体内的工作可以使用该时区设置 属性 value # 时区的设置 7.\u0026lt;fmt:param\u0026gt; 标签:用于参数传递 如：在MyResourse.properties文件中,有一个索引值如下(其中,{0}代表占位符): Str2=Hi,{0} 则,使用\u0026lt;fmt:param\u0026gt;标签传入值如下: \u0026lt;fmt:bundle basename=\u0026quot;MyResourse\u0026quot;\u0026gt; \u0026lt;fmt:message key=\u0026quot;Str2\u0026quot;\u0026gt; \u0026lt;fmt:param value=\u0026quot;张三\u0026quot; /\u0026gt; \u0026lt;/fmt:message\u0026gt; \u0026lt;/fmt:bundle\u0026gt; 也可以在资源文件中指定参数的类型: 如:在MyResourse.properties文件中,有一个索引值如下: Str3={0,date} 则,使用\u0026lt;fmt:param\u0026gt;标签传入值如下: \u0026lt;% request.setAttribute(\u0026quot;now\u0026quot;,new Date()); %\u0026gt; \u0026lt;fmt:bundle basename=\u0026quot;MyResourse\u0026quot;\u0026gt; \u0026lt;fmt:message key=\u0026quot;Str3\u0026quot;\u0026gt; \u0026lt;fmt:param value=\u0026quot;${now}\u0026quot; /\u0026gt; \u0026lt;/fmt:message\u0026gt; \u0026lt;/fmt:bundle\u0026gt; jsp动作标签 # 在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。 一、Include行为 \u0026lt;jsp:include\u0026gt;标签表示动态包含一个静态的或者动态的文件。 语法： \u0026lt;jsp:include page=\u0026quot;path\u0026quot; flush=\u0026quot;true\u0026quot; /\u0026gt; or \u0026lt;jsp:include page=\u0026quot;path\u0026quot; flush=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;jsp:param name=\u0026quot;paramName\u0026quot; value=\u0026quot;paramValue\u0026quot; /\u0026gt; \u0026lt;/jsp:include\u0026gt; 注： 1、page=\u0026quot;path\u0026quot; 为相对路径，或者代表相对路径的表达式。 2、flush=\u0026quot;true\u0026quot; 必须使用flush为true，它默认值是false。 3、\u0026lt;jsp:param\u0026gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个\u0026lt;jsp:param\u0026gt;来传递多个参数给动态文件。 4、\u0026lt;jsp:include page=\u0026quot;\u0026quot; flush=\u0026quot;\u0026quot;\u0026gt; 与\u0026lt;%@ include file=\u0026quot;\u0026quot;%\u0026gt;的区别： \u0026lt;jsp:include \u0026gt;是动态包含\u0026lt;%@include%\u0026gt;是静态包含。 # jsp页面是把include指令元素（\u0026lt;%@ include file=\u0026quot;\u0026quot;%\u0026gt;）所指定的页面的实际内容（也就是代码段）加入到引入它的jsp页面中,合成一个文件后被jsp容器将它转化成servlet。 ## 可以看到这时会产生一个临时class文件和一个servlet源文件。 ## 而动作元素（\u0026lt;jsp:include page=\u0026quot;\u0026quot;/\u0026gt;）是在请求处理阶段引入的，会被JSP容器生成两个临时class文件和两个servlet原文件。 ## 而引入的只是servlet的输出结果，即JspWriter对象的输出结果，而不是jsp的源代码。 二、Forward行为 \u0026lt;jsp:forward\u0026gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。 语法： \u0026lt;jsp:forward page=\u0026quot;path\u0026quot;} /\u0026gt; or \u0026lt;jsp:forward page=\u0026quot;path\u0026quot;} \u0026gt; \u0026lt;jsp:param name=\u0026quot;paramName\u0026quot; value=\u0026quot;paramValue\u0026quot; /\u0026gt;…… \u0026lt;/jsp:forward\u0026gt; 注： 1、page=\u0026quot;path\u0026quot; 为一个表达式，或者一个字符串。 2、\u0026lt;jsp:param\u0026gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个\u0026lt;jsp:param\u0026gt;将多个参数发送到一个动态文件中。 三、UseBean行为 \u0026lt;jsp:useBean\u0026gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。 语法： \u0026lt;jsp:useBean id=\u0026quot;name\u0026quot; scope=\u0026quot;page | request | session | application\u0026quot; typeSpec /\u0026gt; 其中typeSpec有以下几种可能的情况： class=\u0026quot;className\u0026quot; | class=\u0026quot;className\u0026quot; type=\u0026quot;typeName\u0026quot; | beanName=\u0026quot;beanName\u0026quot; type=\u0026quot;typeName\u0026quot; | type=\u0026quot;typeName\u0026quot; | 注： 你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。 四、GetProperty行为 \u0026lt;jsp:getProperty\u0026gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。 语法： \u0026lt;jsp:getProperty name=\u0026quot;name\u0026quot; property=\u0026quot;propertyName\u0026quot; /\u0026gt; 注： 1、在使用\u0026lt;jsp:getProperty\u0026gt;之前，必须用\u0026lt;jsp:useBean\u0026gt;来创建它。 2、不能使用\u0026lt;jsp:getProperty\u0026gt;来检索一个已经被索引了的属性。 3、能够和JavaBeans组件一起使用\u0026lt;jsp:getProperty\u0026gt;，但是不能与Enterprise Java Bean一起使用。 JavaScript通用库 Jsp语法 JSP的动作标签 2008-04-01 11:47:49| 分类： JSP学习 | 标签： |字号大 中 小 订阅 在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。 一、Include行为 \u0026lt;jsp:include\u0026gt;标签表示包含一个静态的或者动态的文件。 语法： \u0026lt;jsp:include page=\u0026quot;path\u0026quot; flush=\u0026quot;true\u0026quot; /\u0026gt; or \u0026lt;jsp:include page=\u0026quot;path\u0026quot; flush=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;jsp:param name=\u0026quot;paramName\u0026quot; value=\u0026quot;paramValue\u0026quot; /\u0026gt; \u0026lt;/jsp:include\u0026gt; 注： 1、page=\u0026quot;path\u0026quot; 为相对路径，或者代表相对路径的表达式。 2、flush=\u0026quot;true\u0026quot; 必须使用flush为true，它默认值是false。 3、\u0026lt;jsp:param\u0026gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个\u0026lt;jsp:param\u0026gt;来传递多个参数给动态文件。 二、Forward行为 \u0026lt;jsp:forward\u0026gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。 语法： \u0026lt;jsp:forward page=\u0026quot;path\u0026quot;} /\u0026gt; or \u0026lt;jsp:forward page=\u0026quot;path\u0026quot;} \u0026gt; \u0026lt;jsp:param name=\u0026quot;paramName\u0026quot; value=\u0026quot;paramValue\u0026quot; /\u0026gt;…… \u0026lt;/jsp:forward\u0026gt; 注： 1、page=\u0026quot;path\u0026quot; 为一个表达式，或者一个字符串。 2、\u0026lt;jsp:param\u0026gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个\u0026lt;jsp:param\u0026gt;将多个参数发送到一个动态文件中。 三、UseBean行为 \u0026lt;jsp:useBean\u0026gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。 语法： \u0026lt;jsp:useBean id=\u0026quot;name\u0026quot; scope=\u0026quot;page | request | session | application\u0026quot; typeSpec /\u0026gt; 其中typeSpec有以下几种可能的情况： class=\u0026quot;className\u0026quot; | class=\u0026quot;className\u0026quot; type=\u0026quot;typeName\u0026quot; | beanName=\u0026quot;beanName\u0026quot; type=\u0026quot;typeName\u0026quot; | type=\u0026quot;typeName\u0026quot; | 注： 你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。 四、GetProperty行为 \u0026lt;jsp:getProperty\u0026gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。 语法： \u0026lt;jsp:getProperty name=\u0026quot;name\u0026quot; property=\u0026quot;propertyName\u0026quot; /\u0026gt; 注： 1、在使用\u0026lt;jsp:getProperty\u0026gt;之前，必须用\u0026lt;jsp:useBean\u0026gt;来创建它。 2、不能使用\u0026lt;jsp:getProperty\u0026gt;来检索一个已经被索引了的属性。 3、能够和JavaBeans组件一起使用\u0026lt;jsp:getProperty\u0026gt;，但是不能与Enterprise Java Bean一起使用。 五、SetProperty行为 \u0026lt;jsp:setProperty\u0026gt;标签表示用来设置Bean中的属性值。 语法： \u0026lt;jsp:setProperty name=\u0026quot;beanName\u0026quot; prop_expr /\u0026gt; 其中prop_expr有以下几种可能的情形： property=\u0026quot;*\u0026quot; | property=\u0026quot;propertyName\u0026quot; | property=\u0026quot;propertyName\u0026quot; param=\u0026quot;parameterName\u0026quot; | property=\u0026quot;propertyName\u0026quot; value=\u0026quot;propertyValue\u0026quot; 注： 使用 jsp:setProperty 来为一个Bean的属性赋值；可以使用两种方式来实现。 1、在jsp:useBean后使用jsp:setProperty： \u0026lt;jsp:useBean id=\u0026quot;myUser\u0026quot; … /\u0026gt; … \u0026lt;jsp:setProperty name=\u0026quot;user\u0026quot; property=\u0026quot;user\u0026quot; … /\u0026gt; 在这种方式中，jsp:setProperty将被执行。 2、jsp:setProperty出现在jsp:useBean标签内： \u0026lt;jsp:useBean id=\u0026quot;myUser\u0026quot; … \u0026gt; … \u0026lt;jsp:setProperty name=\u0026quot;user\u0026quot; property=\u0026quot;user\u0026quot; … /\u0026gt; \u0026lt;/jsp:useBean\u0026gt; 在这种方式中，jsp:setProperty只会在新的对象被实例化时才将被执行。 * 在\u0026lt;jsp:setProperty\u0026gt;中的name值应当和\u0026lt;jsp:useBean\u0026gt;中的id值相同。 六、Plugin行为 \u0026lt;jsp:plugin\u0026gt;标签表示执行一个applet或Bean，有可能的话还要下载一个Java插件用于执行它。 语法： \u0026lt;jsp:plugin type=\u0026quot;bean | applet\u0026quot; code=\u0026quot;classFileName\u0026quot; codebase=\u0026quot;classFileDirectoryName\u0026quot; [ name=\u0026quot;instanceName\u0026quot; ] [ archive=\u0026quot;URIToArchive, ...\u0026quot; ] [ align=\u0026quot;bottom | top | middle | left | right\u0026quot; ] [ height=\u0026quot;displayPixels\u0026quot; ] [ width=\u0026quot;displayPixels\u0026quot; ] [ hspace=\u0026quot;leftRightPixels\u0026quot; ] [ vspace=\u0026quot;topBottomPixels\u0026quot; ] [ jreversion=\u0026quot;JREVersionNumber | 1.1\u0026quot; ] [ nspluginurl=\u0026quot;URLToPlugin\u0026quot; ] [ iepluginurl=\u0026quot;URLToPlugin\u0026quot; ] \u0026gt; [ \u0026lt;jsp:params\u0026gt; [ \u0026lt;jsp:param name=\u0026quot;parameterName\u0026quot; value=\u0026quot;{parameterValue | \u0026lt;％= expression ％\u0026gt;}\u0026quot; /\u0026gt; ]+ \u0026lt;/jsp:params\u0026gt; ] [ \u0026lt;jsp:fallback\u0026gt; text message for user \u0026lt;/jsp:fallback\u0026gt; ] \u0026lt;/jsp:plugin\u0026gt; 注： \u0026lt;jsp:plugin\u0026gt;元素用于在浏览器中播放或显示一个对象（典型的就是applet和Bean),而这种显示需要在浏览器的java插件。 当Jsp文件被编译，送往浏览器时，\u0026lt;jsp:plugin\u0026gt;元素将会根据浏览器的版本替换成\u0026lt;object\u0026gt;或者\u0026lt;embed\u0026gt;元素。注意，\u0026lt;object\u0026gt;用于HTML 4.0 ，\u0026lt;embed\u0026gt;用于HTML 3.2。 一般来说，\u0026lt;jsp:plugin\u0026gt;元素会指定对象是Applet还是Bean,同样也会指定class的名字，还有位置，另外还会指定将从哪里下载这个Java插件。 jsp函数 # 用response.getOutputStream返回数据（而非JspWriter）时，调用： # 如输出图片对象：ImageIO.write(image, \u0026quot;jpeg\u0026quot;, response.getOutputStream()); out.clear(); # 清空 out out = pageContext.pushBody() # 将图片对象的流从out输出，直到整个输出结束（接收方网页加载全部完成时）后才断开 jsp基本 # 模板元素 脚本 \u0026lt;% %\u0026gt; 脚本表达式 \u0026lt;%= %\u0026gt; 注释 \u0026lt;%-- --%\u0026gt; 指令 \u0026lt;%@ page%\u0026gt; language=\u0026quot;java\u0026quot; import=\u0026quot;java.util.*,java.io.*\u0026quot; contentType=\u0026quot;mineType [; charset=characterSet]\u0026quot; pageEncoding=\u0026quot;characterSet\u0026quot; session=\u0026quot;true\u0026quot; buffer=\u0026quot;none | 8kb | sizekb\u0026quot; autoFlush=\u0026quot;true\u0026quot; isThreadSafe=\u0026quot;true\u0026quot; info=\u0026quot;text\u0026quot; errorPage=\u0026quot;relative_url\u0026quot; isErrorPage=\u0026quot;true\u0026quot; isELIgnored=\u0026quot;true\u0026quot; \u0026lt;%@ include%\u0026gt; # \u0026lt;%@ include file=\u0026quot;in.jspf\u0026quot; %\u0026gt; 是静态包含（原代码中包含），一般包含名字为*.jspf的jsp文件 \u0026lt;%@ taglib%\u0026gt; # 标签库 声明 \u0026lt;%! %\u0026gt; # 全局声明（刷新页面仍然保存数据） \u0026lt;% %\u0026gt; # 局部的声明（刷新页面不保存数据） 标签 \u0026lt;jsp:forward page=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/jsp:forward\u0026gt; \u0026lt;jsp:include page=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/jsp:include\u0026gt; 内置对象 9个 pageContext request response config session application page out exception 全局变量 static final JspFactory _jspxFactory static java.util.List _jspx_dependants javax.el.ExpressionFactory _el_expressionfactory org.apache.AnnotationProcessor _jsp_annotationprocessor 在_jspService中的变量 HttpServletRequest request HttpServletResponse response PageContext pageContext = null; pageContext = _jspxFactory.getPageContext(this,request,response,null,true,8192,ture); HttpSession session = null; session = pageContext.getSession(); ServletContext application = null; application = pageContext.getServletContext(); ServletConfig config = null; config = pageContext.getServletConfig(); JspWriter out = null; out = pageContext.getOut(); Object page = this; JspWriter _jspx_out = null; _jspx_out = out; PageContext _jspx_page_context = null; _jspx_page_context = pageContext; jsp验证码 # 实例 # 在\u0026lt;img\u0026gt;标签的src属性中指定该jsp文件即可 ## out.clear();out = pageContext.pushBody();两条语句的作用是 ## 使该验证码jsp文件的传输不会默认地在返回数据后中断，而是在\u0026lt;img\u0026gt;标签调用该jsp的页面加载结束之后再中断数据的传输 \u0026lt;%@ page language=\u0026quot;java\u0026quot; pageEncoding=\u0026quot;UTF-8\u0026quot;%\u0026gt; \u0026lt;%@ page contentType=\u0026quot;image/jpeg\u0026quot; import=\u0026quot;java.util.*,java.awt.*,java.awt.image.*,javax.imageio.*\u0026quot;%\u0026gt; \u0026lt;%! // 声明区，定义产生颜色和验证内容的全局方法 public Color getColor(){ Random random = new Random(); int r = random.nextInt(256); int g = random.nextInt(256); int b = random.nextInt(256); return new Color(r,g,b); } public String getNum(){ String str = \u0026quot;\u0026quot;; Random random = new Random(); for(int i = 0; i \u0026lt; 4; i++){ str += random.nextInt(10) + \u0026quot; \u0026quot;; } return str; } %\u0026gt; \u0026lt;% // 设置响应无缓存 response.setHeader(\u0026quot;pragma\u0026quot;, \u0026quot;mo-cache\u0026quot;); response.setHeader(\u0026quot;cache-control\u0026quot;, \u0026quot;no-cache\u0026quot;); response.setDateHeader(\u0026quot;expires\u0026quot;, 0); // 图片对象,画笔对象 BufferedImage image = new BufferedImage(80,30,BufferedImage.TYPE_INT_RGB); Graphics g = image.getGraphics(); // 画背景 g.setColor(new Color(200,200,200)); g.fillRect(0, 0, 80, 30); // 画干扰线 for(int i = 0; i \u0026lt; 30; i++){ Random random = new Random(); int x = random.nextInt(80); int y = random.nextInt(30); int xl = random.nextInt(x+10); int yl = random.nextInt(y+10); g.setColor(getColor()); g.drawLine(x, y, x + xl, y + yl); } // 画内容 g.setFont(new Font(\u0026quot;serif\u0026quot;, Font.BOLD,16)); g.setColor(Color.BLACK); String checkNum = getNum(); g.drawString(checkNum,15,20); // 放内容到session中，返回图片流 session.setAttribute(\u0026quot;validateCode\u0026quot;, checkNum.replaceAll(\u0026quot; \u0026quot;, \u0026quot;\u0026quot;)); ImageIO.write(image, \u0026quot;jpeg\u0026quot;, response.getOutputStream()); out.clear(); out = pageContext.pushBody(); // 不按照jsp默认的getWriter()方法输出，用我们定义的流的方法进行输出 %\u0026gt; 自定义标签 # 1、JspTag 接口（标记接口，类以Serializable） 2、Tag 接口（空标签，如\u0026lt;img/\u0026gt;） 属性： static int EVAL_BODY_INCLUDE 通过流执行标签体 static int EVAL_PAGE 继续执行页面 static int SKIP_BODY 忽略执行标签体 static int SKIP_PAGE 忽略后面的JSP页面 方法： // 生命周期方法 int doEndTag() 当遇到标签结束的时候自动执行 int doStartTag() 当遇到标签开始的时候自动执行 // 实现方法 Tag getParent() 获取当前标签的父标签处理类对象 void release() 当事件改变的时候自动执行 void setPageContext(PageContext pc) 设置当前的JSP上下文环境 void setParent(Tag t) 设置当前标签的父标签对象 3、TagSupport 类（有属性的标签，如\u0026lt;img src=\u0026quot;\u0026quot;/\u0026gt;） 实现了Tag接口并且提供处理标签属性的方法(set和get)。而且内部定义了一个PageContext变量并且已经初始化开发者可以直接使用this或者super直接方法该属性。 4、BodyTagSupport类（有属性有文本内容和标签，如\u0026lt;img src=\u0026quot;\u0026quot;\u0026gt;aaa\u0026lt;/img\u0026gt;） 新属性 protected BodyContent bodyContent 新方法 void setBodyContent(BodyContent b) BodyContent getBodyContent() BodyContent类 abstract String getString() //获取标签体 写Tag接口的标签库 1、写Tag接口实现类 写属性pageContext（getter 和setter），从setPageContext(PageContext pc)方法中获得该属性 复写方法 2、写tld文件，放到/META-INF文件夹中 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;taglib xmlns=\u0026quot;http://java.sun.com/xml/ns/javaee\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd\u0026quot; version=\u0026quot;2.1\u0026quot;\u0026gt; \u0026lt;tlib-version\u0026gt;1.0\u0026lt;/tlib-version\u0026gt; \u0026lt;short-name\u0026gt;ouru\u0026lt;/short-name\u0026gt; # 简称 \u0026lt;uri\u0026gt;/outrun-tags\u0026lt;/uri\u0026gt; # 自定义引入标签时写的路径 \u0026lt;tag\u0026gt; \u0026lt;name\u0026gt;testDate\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;outrun.util.jsp.taglib.test.DataImplTag\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;empty\u0026lt;/body-content\u0026gt; \u0026lt;/tag\u0026gt; \u0026lt;/taglib\u0026gt; 3、jsp 中引用它 \u0026lt;%@ taglib prefix=\u0026quot;ouru\u0026quot; uri=\u0026quot;/META-INF/myUtil.tld\u0026quot; %\u0026gt; 写TagSupport接口的实现类 pageContext已内置 定义接收属性 tld文件中加入attribute属性 \u0026lt;attribute\u0026gt; 属性描述的开始 \u0026lt;name\u0026gt;pattern\u0026lt;/name\u0026gt; 描述属性名 \u0026lt;required\u0026gt;true\u0026lt;/required\u0026gt; 描述属性是否是必须的 \u0026lt;rtexprvalue\u0026gt;true\u0026lt;/rtexprvalue\u0026gt; 描述属性值是否可以是输出表达式 \u0026lt;/attribute\u0026gt; 写BodyTagSupport接口的实现类 BodyContent body = this.getBodyContent(); String desc = body.getString(); tld 文件中 \u0026lt;body-content\u0026gt;JSP\u0026lt;/body-content\u0026gt; # 有标签体，可执行脚本表达式 ## scriptless，有标签体，不执委脚本表达式 ## empty,没有标签体 Jsp2.0 JspTag — SimpleTag — SimpleTagSupport SimpleTagSupport类 该类可以直接进行操作标签的属性和标签体。 void doTag() 遇到标签的时候自动指定 protected JspFragment getJspBody() 获取标签体对象 protected JspContext getJspContext() 获取JSP上下文环境对象 JspTag getParent() 获取该标签的父标签处理类对象 JspFragment类 该类代表的标签的标签体。 abstract void invoke(Writer out) 输出数据到指定的流，null输出到JSP页面 获得标签体的方法： Writer writer = new StringWriter(); JspFragment jspFragment = getJspBody(); jspFragment.invoke(writer); String text = writer.toString(); 项目：实现 if else 判断 Choose.java private boolean tag = true; public boolean isTag() { return tag; } public void setTag(boolean tag) { this.tag = tag; } @Override public void doTag() throws JspException, IOException { getJspBody().invoke(null); super.doTag(); } when.java 文件 private boolean test = false; public boolean isTest() { return test; } public void setTest(boolean test) { this.test = test; } @Override public void doTag() throws JspException, IOException { Choose parent = (Choose) getParent(); if(isTest() \u0026amp;\u0026amp; parent.isTag()){ // 条件成立 getJspBody().invoke(null); // 设置父的tag为false parent.setTag(false); } super.doTag(); } Otherwise.java 文件 @Override public void doTag() throws JspException, IOException { Choose parent = (Choose) getParent(); if(parent.isTag()){ // 条件成立 getJspBody().invoke(null); parent.setTag(false); } super.doTag(); } tld文件 \u0026lt;tag\u0026gt; \u0026lt;name\u0026gt;choose\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;outrun.util.jsp.taglib.ifelse.Choose\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;scriptless\u0026lt;/body-content\u0026gt; # 有标签体，可执行脚本表达式 ## scriptless，有标签体，不执委脚本表达式 ## empty,没有标签体 \u0026lt;/tag\u0026gt; \u0026lt;tag\u0026gt; \u0026lt;name\u0026gt;when\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;outrun.util.jsp.taglib.ifelse.When\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;scriptless\u0026lt;/body-content\u0026gt; \u0026lt;attribute\u0026gt; \u0026lt;name\u0026gt;test\u0026lt;/name\u0026gt; \u0026lt;required\u0026gt;true\u0026lt;/required\u0026gt; \u0026lt;rtexprvalue\u0026gt;true\u0026lt;/rtexprvalue\u0026gt; \u0026lt;/attribute\u0026gt; \u0026lt;/tag\u0026gt; \u0026lt;tag\u0026gt; \u0026lt;name\u0026gt;otherwise\u0026lt;/name\u0026gt; \u0026lt;tag-class\u0026gt;outrun.util.jsp.taglib.ifelse.Otherwise\u0026lt;/tag-class\u0026gt; \u0026lt;body-content\u0026gt;scriptless\u0026lt;/body-content\u0026gt; \u0026lt;/tag\u0026gt; 控件标签： 自定义函数库 1 创建函数库类 public class MyFunctions { public static String formatMyName(String name) { return \u0026quot;your name is \u0026quot; + name; } public static int add(int a, int b) { return a+b; } } 2 在TLD文件中配置 (引用于目标1中的tld文件) \u0026lt;function\u0026gt; \u0026lt;name\u0026gt;formatMyName\u0026lt;/name\u0026gt; \u0026lt;function-class\u0026gt;com.taglib.MyFunctions\u0026lt;/function-class\u0026gt; \u0026lt;function-signature\u0026gt;java.lang.String formatMyName(java.lang.String)\u0026lt;/function-signature\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;function\u0026gt; \u0026lt;name\u0026gt;add\u0026lt;/name\u0026gt; \u0026lt;function-class\u0026gt;com.taglib.MyFunctions\u0026lt;/function-class\u0026gt; \u0026lt;function-signature\u0026gt;java.lang.String add(int, int)\u0026lt;/function-signature\u0026gt; \u0026lt;/function\u0026gt; 3 JSP中调用 ${cc:formatMyName(\u0026quot;wangfei\u0026quot;) } ${cc:add(12, 34) } jdbc # 流程 Class.forName() # 加载驱动 DriverManager.getConnection() 获得sql会话对象 Statement或PreparedStatement 设置参数setXxx(), 执行sql，处理结果集 关闭结果集、关闭会话、关闭连接 Statement execute executeQuery executeUpdate 不要使用Statement 容易sql注入 代码可读性可维护性差 PreparedStatement性能高，db缓存机制，相同预编译语句调用不再编译 PreparedStatement # 继承Statement, 预编译sql 事务怎么写 编程式 声明式: 用aop注入 三种连接 Connection 默认自动提交 禁止自动提交开启事务, 后调commit Pooled Connection 使用完后不用关闭 XA Connection 分布式事务 XAResource获得 i18n # 页面需要获取用户信息，从数据库中取数据显示 java类中试用： cn.itcast.resource包中 hello_en_US.properties hello=hello hello_zh_CN.properties hello=编码后的“你好” Test.java # 获取信息 Locale locale = locale.CHINA; # 加载资源 ResourceBundle bundler = ResourceBundle.getBundle(\u0026quot;cn.itcast.resource.hello\u0026quot;,locale); # 取出数据 String str = bundler.getString(\u0026quot;hello\u0026quot;); jsp中 \u0026lt;% ResourceBundle bundler = ResourceBundle.getBundle(\u0026quot;lang.properties.hello\u0026quot;, request.getLocale()); out.write(bundler.getString(\u0026quot;title\u0026quot;)); %\u0026gt; \u0026lt;fmt\u0026gt;标签 \u0026lt;fmt:setLocale value=\u0026quot;${pageContext.request.locale }\u0026quot; scope=\u0026quot;page\u0026quot;/\u0026gt; \u0026lt;fmt:setBundle basename=\u0026quot;lang.properties.hello\u0026quot; var=\u0026quot;bundler\u0026quot; scope=\u0026quot;page\u0026quot;/\u0026gt; \u0026lt;fmt:message bundle=\u0026quot;${bundler }\u0026quot; key=\u0026quot;title\u0026quot;\u0026gt;\u0026lt;/fmt:message\u0026gt; 资源转码 native2ascii.exe myeclipse properties文件编辑器 ie 中得到en_US Locale locale getLanguage(); getCountry(); getDefault(); ResourceBundle 读取文件cn.itcast.resource.hello省略_en_US.properties getString(String key) 实例1： 创建页面 创建资源文件 编辑页面 request.getLocale(); ResourceBundle.getBundle(\u0026quot;\u0026quot;,locale); getString(\u0026quot;\u0026quot;) 实例2： 编辑页面 \u0026lt;%@ taglib%\u0026gt; \u0026lt;f:setLocale scope=\u0026quot;\u0026quot; value=\u0026quot;\u0026quot;\u0026gt; \u0026lt;f:setBundle basename=\u0026quot;\u0026quot; var=\u0026quot;\u0026quot; scope=\u0026quot;\u0026quot;\u0026gt; \u0026lt;f:message bundle=\u0026quot;\u0026quot; key=\u0026quot;\u0026quot; \u0026gt; 动态数据国际化 日期国际化 SimpleDateFormat # 继承DateFormat getDateTimeInstance getDateInstance getTimeInstance static int FULL static int LONG static int MEDIUM static int SHORT 实例3： cn.itcast.i18n.MyDateI18n DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA); String str = format.format(new Date()); 解析页面中的字符串 FULL 和 LONG 和 MEDIUM 和 SHORT 的 区别 DataFomat String format(Date date) Date parse(String source) 创建static string2Date(String str) # 分析区域 Locale locale = Locale.CHINA; # 分析日期的风格 int dateType = DateFormat.SHORT; int timeType = DateFormat.FULL; # 获取对象 DateFormat format = DateFormat.getDateTimeInstance(dateType,timeType,locale); # 解析 format.parse(str); 动态数字国际化 java.text.*; Number类 NumberFormat(普通数字，货币，百分比) getIntegetInstance getCurrencyInstance getPercentInstance(Locale inLocale) format parse 创建cn.itcast.i18n.MyNumberI18n # 获取对象 # getPercentInstance # getCurrencyInstance NumberFormat format = NumberFormat.getIntegerInstance(Locale.CHINA); # 格式化 或解析 long num = 10000000000L; # Number num = format.parse(str); # double price = num.doubleValue(); format.format(num); 动态文本国际化 At 12:30 pm on jul 3,1998, a hurricance destroyed 99 houses and caused $1000000 of damage. MessageFormat MessageFormat(String pattern,Locale locale) format(String pattern,Object...arguments) format(Object) parse() 占位 At{0} on {0}, a hurricance destroyed{1} houses and caused {2} of damage. 实例1： MyMessageI18n.java # 定义模式字符串 String pattern # 定义locale对象 MessageFormat format = new MessageFormat(pattern,Locale.CHINA); # 定义参数数组 DateFormat datef = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.SHORT,Locale.US); Date date = datef.parse(\u0026quot;Jul 3,1998 12:30 PM\u0026quot;); Integer num = new Integer(99); long currency = NumberFormat.getCurrencyInstance(Locale.US).parse(\u0026quot;$1000000\u0026quot;); String damage = NumberFormat.getCurrencyInstance(locale).format(currency); Object [] values = {date,num,damage}; # 格式化 String str = format.format(values); 分析：{索引，对象，类型} MessageFormat messf = new MessageFormat(\u0026quot;{0,time,short} on {0,date}, a hurricance destroyed {1} houses and caused {2,number,currency} of damage.\u0026quot;,Locale.CHINA); Object [] values = {new Date(),new Integer(100),1000}; String str = messf.format(values); 中间件 # 顺序 监听器 -\u0026gt; 过滤器 监听器 # 分类 ServletContextListener ServletContextAttributeListener HttpSessionListener HttpSessionAttributeListener HttpSessionActivationListener web.xml 注册在过滤器后面，servlet前面 \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;cn.listen.MyListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; 自定义 public class MyListener implements ServletContextListener { public void contextDestroyed(ServletContextEvent sce) { System.out.println(\u0026quot;die\u0026quot;); } public void contextInitialized(ServletContextEvent sce) { System.out.println(\u0026quot;init\u0026quot;); } // 当过滤器被销毁时自动执行 public void destroy(){ System.out.println(\u0026quot;Filterdestroyed\u0026quot;); } // 当拦截的时候 public void doFilter(request,response,chain){ System.out.println(\u0026quot;doFilter\u0026quot;); System.out.println(\u0026quot;放行目标资源\u0026quot;); chain.doFilter(request,response); System.out.println(\u0026quot;目标已经放行\u0026quot;); } // 初始化的时候 public void init(FilterConfig config){ System.out.println(\u0026quot;FilterInited\u0026quot;); } } 过滤器 # web.xml \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;testFilter \u0026lt;filter-class\u0026gt;cn.itcast.filter.text.TestFilter \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;GB2312\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;testFilter \u0026lt;url-pattern\u0026gt;/* \u0026lt;/filter-mapping\u0026gt; api Filter接口 ## 多个过滤器, 按web.xml中注册的顺序映射调用。servlet执行完后, 从后向前返回执行chain.doFilter之后的方法 init destroy doFilter(ServletRequest request, ServletResponse response, FilterChain chain) FilterChain接口 doFilter(ServletRequest request, ServletResponse response) FilterConfig接口 private FilterConfig config = null; init() this.config = config; doFilter() String ip = this.config.getInitParameter(\u0026quot;ip\u0026quot;); 映射 1.映射的url 2.servlet的名字 # 通配servlet \u0026lt;url-pattern\u0026gt;/servlet/*\u0026lt;/url-pattern\u0026gt; 3.为了映射servlet中的转发, 映射一个过滤器到某种传递方式 \u0026lt;filter-mapping\u0026gt; \u0026lt;dispatcher\u0026gt;FORWARD # FORWARD 转发方式 # REQUEST 请求方式 # INCLUDE 包含方式 # ERROR 错误页面 \u0026lt;/dispatcher\u0026gt; \u0026lt;/filter-mapping\u0026gt; 设置编码 doFilter() HttpServletRequest httpRequest = (HttpServletRequest) request; HttpServletResponse httpResponse = (HttpServletResponse) response; httpRequest.setCharacterEncoding(\u0026quot;utf-8\u0026quot;) String method = httpRequest.getMethod(); if(\u0026quot;get\u0026quot;.equalsIgnoreCase(method)){ chain.doFilter(new MyWapperRequest(httpRequest),response); }else{ request.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); } class MyWapperRequest extends HttpServletRequestWrapper{ private HttpServletRequest request = null; public MyWapperRequest (HttpServletRequest request){ super(request); this.request = request; } @Override public String getParameter(String name){ String value = request.getParameter(name); String method = request.getMethod(); if(value != null \u0026amp;\u0026amp;\u0026quot;get\u0026quot;.equalsIgnoreCase(method)){ value = new String(value.getBytes(\u0026quot;iso8859-1\u0026quot;),request.getCharacterEncoding()) } return value; } } 设置缓存 # Expires:-1 # Cache-Control:no-cache # Pragma:no-cache NoCacheFilter implements Filter # 设置不缓存 doFilter() HttpServletResponse httpResponse = response; httpResponse.setHeader(\u0026quot;Expires\u0026quot;,-1 + \u0026quot;\u0026quot;); // setDataHeader(\u0026quot;expires\u0026quot;,-1); httpResponse.setHeader(\u0026quot;cache-control\u0026quot;,\u0026quot;no-cache\u0026quot;); httpResponse.setHeader(\u0026quot;pragma\u0026quot;,\u0026quot;no-cache\u0026quot;); chain.doFilter(request,httpResponse); CacheFilter # 缓存静态资源 # web.xml中url-pattern 可以映射多个 param-name=jpg param-value=2 private FilterConfig config = null; doFilter() HttpServletResponse httpResponse = (HttpServletResponse) response; HttpServletResponse httpRequest = (HttpServletRequest) request; String resource = request.getRequestURI(); String date = null; if(resource.endsWith(\u0026quot;jpg\u0026quot;)){ date = config.getInitParameter(\u0026quot;jpg\u0026quot;); httpResponse.setDateHeader(\u0026quot;expires\u0026quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000); // 换算成秒 } else if(resource.endsWith(\u0026quot;js\u0026quot;)){ String date = config.getInitParameter(\u0026quot;js\u0026quot;); config.getInitParameter(\u0026quot;js\u0026quot;); httpResponse.setDateHeader(\u0026quot;expires\u0026quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000); } chain.doFilter(httpRequest,httpResponse); 修改编码 EncodingFilter implements Filter{ doFilter(request,response){ HttpServletResponse httpResponse = (HttpServletResponse) response; HttpServletResponse httpRequest = (HttpServletRequest) request; httpRequest.setCharacterEncoding(\u0026quot;utf-8\u0026quot;); chain.doFilter(httpRequest,httpResponse); } } class EncodingRequest extends HttpServletRequestWrapper{ private HttpServletRequest request; public EncodingRequest (HttpServletRequest request){ super(request); this.request = request; } @Override public String getParameter(String name){ String value = request.getParameter(name) if(value != null \u0026amp;\u0026amp; \u0026quot;get\u0026quot;.equalsIgnoreCase(request.getMethod)){ value = new String(value.getBytes(\u0026quot;iso8859\u0026quot;),\u0026quot;utf-8\u0026quot;); } return value; } } 登录 LoginFilter init(){ this.config = config; } private FilterConfig config = null; doFilter(){ String path = this.config.getInitParameter(\u0026quot;loginPage\u0026quot;); HttpSession session = httpRequest.getSession(false); // 判断用户请求的是否是UserServlet String servletName = httpRequest.getServletPath(); servletName = substring(servletName.lastIndexOf(\u0026quot;/\u0026quot;)+1); if(\u0026quot;UsersServlet\u0026quot;.equals(servletName)){ }else{ // 一般的servlet if(session != null){ // 获取登录标记 User user = null; user = (User)session.getAttribute(\u0026quot;user\u0026quot;); // 判断 if(user != null){ // 放行资源 chain.doFilter(httpRequest,httpResponse); }else{ // 页面重定向到登录页面 httpResponse.sendRedirect(httpRequest.getContextPath() + \u0026quot;/\u0026quot; + path); } } } } web.xml \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;loginFilter \u0026lt;filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;loginPage \u0026lt;param-value\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/jsps/* \u0026lt;url-pattern\u0026gt;/servlet/* \u0026lt;url-pattern\u0026gt;/publics/* \u0026lt;filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/publics/head.jsp \u0026lt;dispatcher\u0026gt;INCLUDE \u0026lt;dispatcher\u0026gt;FORWARD \u0026lt;dispatcher\u0026gt;ERROR \u0026lt;dispatcher\u0026gt;REQUEST # 默认是request，当加上其它参数时（如include），request会没有，所以要加两个forward,request ## 是指向里面以该方法请求的时候进行过滤 struts2 # "},{"id":66,"href":"/docs/pl/java/juc/","title":"Java并发","section":"Java","content":" 基础 # 并发编程三大特性 可见性(visibility) synchronized会刷新线程栈 有序性(ordering) 原子性(atomicity) CPU # PC寄存器(Program Counter Register, 存下一指令) 优化 乱序读 合并写 乱序执行(流水线) ALU 访问速度 Registers: \u0026lt; 1ns L1 cache(核内): 1ns WC(Writer Comblining) Buffer # 合并写, 一般4个字节 L2 cache(核内): 3ns L3 cache(CPU内): 15ns memory: 80ns 局部性原理 空间 按块读取(cache line) 一次读64Bytes # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知 Java1.8注解@Contended # 保证不在同一行，需要JVM参数-XX:-RestrictContended 时间 批量读指令 内存屏障 # 不同CPU不一样 Intel sfence # save, 之前写操作必须完成 lfence # load, 之前读操作必须完成 mfence # mix(save + load) lock指令 # 指令执行完之前，锁内存 lock_add CPU缓存一致性协议 # # 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁 状态 MESI Cache一致性协议 # Intel CPU，实现方式为主动监听 Modified # 一行数据在CPU Modified, 其它CPU为Invalid Exclusive # 独享，其它CPU没有 Shared # 别人也在读 Invalid # 别人改过了 MSI MOSI 缓存行 # 多数64字节 伪共享 # 缓存行内无关数据也要同步 OS # 进程 # 资源分配 线程 # 调度执行 切换(Context Switch) CPU导出原线程指令和data到cache, 再导入新线程数据 线程数 N(threads) = N(CPU) * U(CPU) * (1 + W/C) # N(CPU): CPU数 # U(CPU): 期望CPU利用率, 0到1 # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析 压测决定 CPU性能压榨 单进程 批处理 多进程切换 多线程进程内切换 I/O复用 协程(纤程、绿色线程)用户空间切换 JVM # 内存屏障 # LoadLoad StoreStore LoadStore StoreLoad 乱序执行(指令重排序) # 为什么 CPU快, 指令1阻塞时，指令2先执行 判断 代码不影响单线程最终一致性 例子，多线程 static int x = 0, y = 0; static int a = 0, b = 0; void main(){ for (long i = 0; i \u0026lt; Long.MAX_VALUE; i++\u0026gt;) { x=0; y=0; a=0; b=0; CountDownLatch latch = new CountDownLatch(2); Thread one = new Thread(() -\u0026gt; { public void run() { a = 1; x = b; latch.countDown(); } }); Thread other = new Thread(() -\u0026gt; { public void run() { b = 1; y = a; latch.countDown(); } }); one.start(); other.start(); latch.await(); if (x == 0 \u0026amp;\u0026amp; y == 0) { break; } } } 例子，类初始化指令换顺序 class T { int m = 8; } T t = new T(); 汇编码 0 new #2 \u0026lt;T\u0026gt; # 变量半初始化状态为0 3 dup 4 invokespecial #3 \u0026lt;T.\u0026lt;init\u0026gt;\u0026gt; 7 astore_1 # 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0。线程访问时中间状态逸出 8 return class C { private int num = 0; public C() { new Thread(() -\u0026gt; System.out.println(this.num)).start(); } void main() { new C(); System.in.read(); } } Unsafe类 # # 相当于指针。1.8只能根部类用, 11可以直接用 操作内存 allocateMemory putXX freeMemory pageSize 生成类实例 allocateInstance 操作类或实例 objectFieldOffset getInt getObject CAS compareAndSwapObject() # JDK1.8 compareAndSetObject() weakCompareAndSetObject() # JDK11 修饰符与锁 # 概念 # 锁细化 # 少代码加轻量锁 锁粗化 # 锁太多时，如行锁变表锁 synchronized # 实现方式 JVM没要求实现方式 早期都是OS调度 HotSpot 在对象头(64位)上用2位实现，组合成锁的类型 锁升级 # 不比原子类慢，升完不降 偏向锁, 第一个线程第一次访问只记线程id 自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平 重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景 原子性、可见性 可重入 # 同一个对象同线程可重入 加锁对象 方法锁和对象锁锁this static方法锁和类锁锁class类 继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象 使用注意 抛异常立即释放锁，但被锁数据已更新 不能用的对象 String常量，可能未知地方锁同一个 Integer、Long等基本类型, 值变化会生成新对象 synchronized的属性加final防止赋值 volatile # # 用synchronized性能差不多，volatile一般不用 作用 # 没有原子性，可能写同一值 变量在线程见可见性 依靠CPU缓存一致性协议 禁止指令重排序 # 用JVM的读写屏障 修饰引用类型，内部属性不监控 DCL(Double Check Lock)单例volatile问题 private static volatile C c; // 禁止了创建c指令重排序 private C(){} public static C getInstance() { if (c == null) { synchronized (C.class) { if (c == null) { // 申请内存(半初始化状态默认0)，成员变量初始化，赋值 // 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象 c = new C(); } } } return c; } CAS # # Compare And Set/Swap, 无锁优化, 乐观锁, 自旋 # Unsafe类支持 CPU原语 cas(V, Expected, NewValue) if V == E # 无并发值判断问题，原语上加了屏障 V = New else try again or fail Java AtomicInteger incrementAndGet() ABA问题 # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据 版本号 # Java版本号类AtomicStampedReference LongAdder LongAdder每次加数字, LongAccumulator用lambda 分段锁(CAS)。值分开放数组里, 多线程对应一个item 性能测试 LongAdder(713) \u0026gt; Atomic(2166) \u0026gt; Synchronized(3129) 锁 # AQS # # AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种 # 实现方式: CAS，volatile, 模板方法 类图 AbstractQueueSynchronizer Sync NonfairSync 方法 AbstractQueueSynchronizer # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待) Node volatile Node prev volatile Node next volatile Thread thread VarHandle # JDK1.9，保存引用，普通属性原子操作。 # 相比反射，直接操作二进制码 get() set() compareAndSet() # 原子性 getAndAdd() # 原子性 class C { int x = 0; private static VarHandle handle; static { handle = MethodHandles.lookup().findVarHandle(C.class, \u0026quot;x\u0026quot;, int.class) handle.compareAndSet(c, 0, 1); } } volatile state # 多态实现 acquire() tryAcquire() # 模板方法 acquireQueued() # 获得 addWaiter(Node.EXCLUSIVE) # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表) cancelAcquire() # status CANCELLED, tail时设置null, 非tail时unpark下一节点 NonfairSync nonfairTryAcquire() ReentrantLock # # 可重入锁，CAS实现, state记重入多少次 new ReentrantLock(true) # 公平锁 tryLock(long, TimeUnit) lockInterruptibly() # 响应interrupt()标记 newCondition() # 多一个等待队列 源码 调NonfairSync CountDownLatch # # 比join()灵活 new CountDownLatch(4) countDown() await() CyclicBarrier # # 满了一起放行, 场景如I/O批量消费 new CyclicBarrier(4, ()-\u0026gt;{}) await() Phaser # # 阶段批量执行过滤 class MyPhaser extends Phaser { @Override protected boolean onAdvance(int phase, int registeredParties) { switch(phase) { case 0: print(\u0026quot;arrived\u0026quot; + registeredParties); return false; case 1: print(\u0026quot;eated\u0026quot; + registeredParties); return false; case 2: print(\u0026quot;hugged\u0026quot; + registeredParties); return true; default: return true; } } } Person implements Runnable { private int i; public Person(int i) { this.i = i; } public void arrive() { phaser.arriveAndAwaitAdvance(); } public void eat() { phaser.arriveAndAwaitAdvance(); } public void hug() { if (i == 0 || i == 1) { phaser.arriveAndAwaitAdvance(); } else { phaser.arriveAndDeregister(); } } @Override public void run() { arrive(); eat(); hug(); } } phaser = new MyPhaser(); phaser.bulkRegister(5); for (int i = 0; i \u0026lt; 5; i++) { new Thread(new Person(i)).start() } ReadWriteLock # # 读锁是共享锁，不能写，悲观锁 # 写锁是排他锁，不能读写 ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); Lock readLock = readWriteLock.readLock(); Lock writeLock = readWriteLock.writeLock(); void read(Lock lock) { lock.lock() lock.unlock() } void write(Lock lock) { lock.lock() lock.unlock() } for (int i =0; i\u0026lt;10;i++) { new Thread(()-\u0026gt;read(readLock)).start(); } for (int i =0; i\u0026lt;2; i++) { new Thread(()-\u0026gt;write(writeLock)).start(); } StampedLock # # 读时允许写，读完判断不一致再读一遍，乐观锁 Semaphore # # 信号量, 限流同时运行, 用于线程间同步。可设置公平 Semaphore s = new Semaphore(1, true) new Thread(() -\u0026gt; { s.acquire(); s.release() }) Exchanger # # 线程间通信, 阻塞交换 exchange() LockSupport # # 线程间通信，非锁阻塞，指定线程唤醒 # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1) Thread t = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10; i++) { if (i == 5) { LockSupport.park(); } } }) t.start(); TimeUnit.SECONDS.sleep(1); LockSupport.unpark(t); 线程及线程池 # 使用注意 # 为什么不用Executors线程池 用LinkedBlockingQueue超数量OOM 拒绝策略 线程命名 类 # Object wait() # 释放synchronized锁并加入等待队列，唤醒后执行需要得到synchronized锁 notify() # 只唤醒，不释放当前synchronized锁 Thread static currentThread() static sleep() static yield() # 让出CPU, 进Ready队列 start() getState() join() # 等待结束 setDaemon() # 是否后台 setPriority(Thread.NORM_PRIORITY) # 优先级，没有用 interface Runnable void run() interface Callable V call() throws Exception interface Future get() get(long, TimeUnit) cancel(boolean) isCanceled() isDone() interface RunnableFuture class FutureTask interface CompletableFuture # parallel static CompletableFuture\u0026lt;U\u0026gt; supplyAsync() static CompletableFuture\u0026lt;Void\u0026gt; allOf(CompletableFuture\u0026lt;U\u0026gt;...) static CompletableFuture\u0026lt;Void\u0026gt; anyOf(CompletableFuture\u0026lt;U\u0026gt;...) T join() CompletableFuture\u0026lt;U\u0026gt; thenApply() CompletableFuture\u0026lt;Void\u0026gt; thenAccept(Consumer\u0026lt;T\u0026gt;) interface ThreadFactory Thread newThread(Runnable) class DefaultThreadFactory interface Executor void execute() interface ExecutorService shutdown() shutdownNow() isShutdown() isTerminated() awaitTermination(long, TimeUnit) Future submit(Callable\u0026lt;T\u0026gt;) Future submit(Runnable, T) # 手动设个result submit(Runnable) invokeAll(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;) invokeAll(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;, long, TimeUnit) invokeAny(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;) invokeAny(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;, long, TimeUnit) abstract AbstractExecutorService RunnableFuture\u0026lt;T\u0026gt; newTaskFor(Runnable, T) RunnableFuture\u0026lt;T\u0026gt; newTaskFor(Callable\u0026lt;T\u0026gt;) T doInvokeAny(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;, boolean timed, long) submit() invokeAll(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;) # 忽略CancellationException, ExecutionException，其它异常抛出并取消未完成任务 invokeAll(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;, long, TimeUnit) # 忽略CancellationException, ExecutionException, TimeoutException，其它异常抛出并取消未完成任务 invokeAny(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;) invokeAny(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt;, long, TimeUnit) class ThreadPoolExecutor # 线程池+任务队列 # 任务顺序: 核心线程, 任务队列，起新线程，拒绝策略 class ScheduledThreadPoolExecutor # 用DelayedWorkQueue scheduleAtFixedRate(()-\u0026gt;{}, int initial, int period, TimeUnit) class ForkJoinPool execute(ForkJoinTask) interface ScheduledExecutorService [class ScheduledThreadPoolExecutor] interface CompletionService # 不阻塞全部任务，已有结果入队列 poll() class ExecutorCompletionService static class Executors newSingleThreadExecutor() # 为了用任务队列和生命周期管理 newCachedThreadPool() # 超时60s, max为MAX_VALUE, 任务不堆积场景 newFixedThreadPool() newScheduledThreadPool() # AbstractQueuedSynchronizer newWorkStealingPool() # ForkJoinPool, go的M,G,P # 每个线程单独队列, 尾部偷加尾部 创建线程 # # 继承 class MyThread extendws Thread { @Override public void run(){} } new MyThread().start(); # 组合 class MyRun implements Runnable { @Override public void run(){} } new Thread(new MyRun()).start(); # 返回值 class myCall implements Callable\u0026lt;String\u0026gt; { @Override public String call(){} } FutureTask = ft = new FutureTask\u0026lt;String\u0026gt;(new MyCall()) new Thread(ft).start(); ft.get(); # 线程池 // execute无返回值 ExecutorService service = Executors.newCachedThreadPool() service.execute(()-\u0026gt;{}); // submit有返回值 Future\u0026lt;String\u0026gt; f = service.submit(new MyCall()); service.shutdown(); 线程状态 # NEW RUNNABLE # 可调度 READY RUNNING WAITING # 等待唤醒，忙等待(一直占CPU) o.wait() t.join() LockSupport.park() Lock.lock() o.notify() o.notifyAll() LockSupport.unpark() Lock.unlock() TIMED WAITING Thread.sleep(time) o.wait(time) t.join(time) LockSupport.parkNanos() LockSupport.parkUntil() BLOCKING # 阻塞等待（不占CPU但经过OS调度) synchronized TERMINATED 线程打断 # 方法 interrupt() # 设置打断标记位 isInterrupted() # 检查标记位 static interrupted() # 检查当前线程标记位，并重置 检测当前线程打断标记的方法 # 抛异常并重置 Thread.sleep() o.wait(); o.join(); ReentrantLock lockInterruptibly() 不检测当前线程打断标记的方法 synchronized # 不是代码实现检测不了 ReentrantLock lock() 强制打断 Thread stop() # 已废弃, 立即释放所有锁 suspend() # 已废弃，强制暂停，所有锁不释放容易死锁 resume() # 已废弃，强制恢复 volatile 判断数字不准，有同步的时间延迟, interrupt()也有延迟 也需要代码中判断, 但interrupt()有wait()等系统方法支持 线程间通信 # 通知 # # synchronized wait() notify(), CountDownLatch, LockSupport volatile List c = new ArrayList(); final Object lock = new Object(); new Thread(() -\u0026gt; { synchronized(lock) { if (c.size() != 5) { lock.wait(); } lock.notify(); // 唤醒t1 } }, \u0026quot;t2\u0026quot;).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -\u0026gt; { synchronized(lock) { for (int i = 0; i \u0026lt; 10; i++) { c.add(new Object()); if (c.size() == 5) { lock.notify(); lock.wait(); // 让出sychronized锁 } } } }, \u0026quot;t1\u0026quot;).start(); 生产消费 # # 优化count可以用CAS加(有ABA问题) class MyContainer\u0026lt;T\u0026gt; { final private List\u0026lt;T\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); final private int MAX = 10; private int count = 0; public synchronized void put(T t) { while(list.size() == MAX) { this.wait(); // 期间可能有add() } list.add(t); count++; this.notifyAll(); // 应该只唤醒消费者 } public synchronized T get() { T t = null; while(list.size() == 0) { this.wait(); } t = list.removeFirst(); count--; this.notifyAll(); // 应该只唤醒生产者 return t; } } # 同步容器, ReentrantLock Condition private Lock lock = new ReentrantLock(); private Condition producer = lock.newCondition(); private Condition consumer = lock.newCondition(); public void put(T t) { try { lock.lock(); while(list.size() == MAX) { producer.await(); } list.add(t); count++; consumer.signalAll(); } finally { lock.unlock(); } } public T get() { T t = null; try { lock.lock(); while(list.size() == 0) { consumer.await(); } t = list.removeFirst(); count--; producer.signalAll(); } finally { lock.unlock(); } return t; } 协程 # quasar库 # 需要设javaagent, 每个fiber生成栈 fiber = new Fiber\u0026lt;Void\u0026gt;() fiber.start() 并发API # Stream # parallelStream() # ForkJoinPool ThreadLocal # 内部类 ThreadLocalMap\u0026lt;ThreadLocal, Object\u0026gt; # 存在每个线程里。场景如声明式事务拿conn # key是弱引用指向ThreadLocal, value是强引用。 Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } 方法 set(T) 内存泄露问题 ThreadLocal\u0026lt;M\u0026gt; tl = new ThreadLocal(); tl.set(new M()); tl = null; # threadLocalMap中key弱引用回收, value不回收 tl.remove(); # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在 PipedStream # # 效率不高 PipedInputStream connect(PipedOutputStream) read(byte[]) PipedOutputStream write(byte[]) JMH # # Java Microbenchmark Harness 概念 Warmup # 预热 Mesurement # 总执行次数 Timeout # 每次执行超时时间 Threads # fork线程数 Benchmark mode # 模式 Benchmark # 方法名 环境变量 TEMP或TMP # JHM临时文件存放 使用 @Benchmark @Warmup(iterations = 2, time = 3) # 执行2次, 每次隔3秒 @Fork(5) # 多少线程 @BenchmarkMode(Mode.Throughput) # 显示每秒多少次 @Measurement(iterations = 10, time = 3) # 共测10次, 每次隔3秒 public void testA() { } Disruptor # 介绍 CAS, 环形数组Buffer 数组用sequence定位修改快,也避免了头尾加锁 直接覆盖降低GC 覆盖前有等待策略 单机MQ 发布订阅模式 观察者模式 EventFactory 会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC 使用 class MyEvent {} class MyEventFactory implements EventFactory\u0026lt;MyEvent\u0026gt; { @Override public MyEvent newInstance() {} } class MyEventHandler implements EventHandler\u0026lt;MyEvent\u0026gt; { @Override void onEvent(MyEvent, long sequence, boolean endOfBatch) {} } class MyExceptionHandler implements ExceptionHandler\u0026lt;MyEvent\u0026gt; { @Override void handleEventException() @Override void handleOnStartException() @Override void handleOnShutdownException() } disruptor = new Disruptor\u0026lt;\u0026gt;(factory, 1024, Executors,defaultThreadFactory()) disruptor = new Disruptor\u0026lt;\u0026gt;(MyEvent::new, 1024, Executors,defaultThreadFactory()) disruptor = new Disruptor\u0026lt;\u0026gt;(factory, 1024, Executors,defaultThreadFactory(), ProducerType.SINGLE, new BlockingWaitStrategy()) # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁 // 消费 disruptor.handleEventsWith(handler1, handler2) disruptor.handleEventsWith((event,seq,end)-\u0026gt;{}) disruptor.handleExceptionsFor(handler1).with(excptionHandler1) disruptor.start() // 生产 ringBuffer = disruptor.getRingBuffer() sequence = ringBuffer.next() event = ringBuffer.get(sequence) event.set(\u0026quot;\u0026quot;) ringBuffer.publish(sequence) translator = new EventTranslator\u0026lt;\u0026gt;() { @Override void translateTo(event, sequence) { event.set(\u0026quot;\u0026quot;) } } ringBuffer.publishEvent(translator) ringBuffer.publishEvent((event,seq, \u0026quot;\u0026quot;) -\u0026gt; event.set(l), \u0026quot;\u0026quot;) 等待策略 BlockingWaitStrategy # 阻塞直到再次唤醒 BusySpinWaitStrategy # 自旋等待 SleepingWaitStrategy # sleep等待 LiteBlockingWaitStrategy # 同BlockingWaitStrategy减少加锁次数 LiteTimeoutBlockingWaitStrategy # 同LiteBlockingWaitStrategy加超时 PhasedBackoffWaitStrategy TimeoutBlockingWaitStrategy # 同BlockingWaitStrategy加超时 YieldingWaitStrategy # 尝试100然后Thread.yield() 源码分析 # ThreadPoolExecutor # new ThreadPoolExecutor() int corePoolSize # 核心线程数, 永远存活。可设置参与回收 int maximumPoolSize # 最大线程数 long keepAliveTime # 生存时间 TimeUnit BlockingQueue\u0026lt;Runnable\u0026gt; # 任务队列 ThreadFactory # 线程工厂, 设线程名 RejectedExecutionHandler # 拒绝策略 Abort # 抛异常 Discard # 忽略掉 DiscardOldest # 忽略掉排除最久的 CallerRuns # 调用者线程执行, 再多就阻塞 AtomicInteger ctl # 高3位线程池状态，低29位线程数量 void execute() 判断添加核心线程 放入队列成功 拒绝或添加非核心线程 添加非核心线程失败 拒绝 boolean addWorker(Runable, boolean) 线程数量加1 添加Worker 加锁 加线程 启动 class Worker extends AbstractQueuedSynchronizer implements Runnable # 本身是AQS锁, 被多任务(线程)访问 Tread thread ForkJoinPool # abstract class ForkJoinTask ForkJoinTask\u0026lt;V\u0026gt; fork() V join() abstract class RecursiveAction # 无返回值 void compute() abstract class RecursiveTask # 有返回值 例子 class MyTask extends RecursiveTask\u0026lt;Long\u0026gt; { int start; int end; @Override Long compute() { if (end - start \u0026lt;= MAX_NUM) { return sum } subTask1 = new MyTask(start, mid) subTask2 = new MyTask(mid, end) subTask1.fork() subTask2.fork() return subTask1.join() + subTask2.join(); } } fjp = new ForkJoinPool() task = new MyTask(0, nums.length) fjp .execute(task) result = task.join() "},{"id":67,"href":"/docs/architect/code/design_mode/","title":"Java设计模式","section":"代码","content":" 六个原则 # 单一职责原则(SRP, Single Responsibility Principle) 一个类只做一件事，应该只有一个引起它修改的原因 开闭原则(OCP, Open-Close Principle) 对修改封闭，对扩展开放 里氏替换原则(LSP, the Liskov Substitution Principle) 子类可以完全替换父类。也就是继承只扩展新功能 依赖倒置原则(DIP, the Dependency Inversion Principle) 细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定 接口隔离原则(ISP, the Interface Segregation Principle) 客户端不依赖它不需要的接口。冗余依赖应该将接口拆分 迪米特法则（最少知道原则）(LoD, Law of Demeter) 一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话 构建型 # 工厂方法(Factory Method) # # 简单工厂, 根据参数创建不同的类 # 静态工厂，单例工厂 public interface Sender{ public void Send(); } public class MySender implements Sender{ @Override public void Send(){} } public SenderFactory { public static Sender produceStatic() { return new MySender(); } public Sender produce(){ return new MySender(); } public Sender produce(int i){ return new MySender(); } } # 工厂子类继承工厂接口, 不同产品对应不同工厂 public interface AbstractFactory { public MySender produce(); } public class MyFactory implements AbstractFactory { @Override public MySender produce(){ return new MySender(); } } 抽象工厂(Abstract Factory) # # 生产抽象产品 public interface AbstractFactory { public Sender produce(); } public class MyFactory implements AbstractFactory { @Override public Sender produce(){ return new MySender(); } } 单例(Singleton) # 确保只有一个实例 # 大多有资源管理器的功能 # 反射机制会使所有单例失效：私有构造方法可以被访问 应用 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 o-\u0026gt; 饿汉 public class Singleton { public static Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } o-\u0026gt; 懒汉式 public class Singleton { private static Singleton single=null; private Singleton() {} public synchronized static Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; } } o-\u0026gt; 懒汉，双重检测(DCL) # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。 # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized public class Singleton { private static volatile Singleton singleton = null; # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。 private Singleton(){} public static Singleton getInstance(){ if (singleton == null) { // t1,t2并发进入 synchronized (Singleton.class) { // t1释放后，t2进入 if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } o-\u0026gt; map注册 # 学Spring，将类名注册 public class Singleton { private static Map\u0026lt;String,Singleton\u0026gt; map = new HashMap\u0026lt;String,Singleton\u0026gt;(); static{ Singleton single = new Singleton(); map.put(single.getClass().getName(), single); } protected Singleton(){} public static Singleton getInstance(String name) { if(name == null) { name = Singleton.class.getName(); } if(map.get(name) == null) { map.put(name, (Singleton) Class.forName(name).newInstance()); } return map.get(name); } } 建造者(Builder) # # 提供工厂方法，建造内部复合对象 o-\u0026gt; public class Builder { private List\u0026lt;Sender\u0026gt; list = new ArrayList\u0026lt;Sender\u0026gt;(); public void produceMailSender() { list.add(new MailSender()) } } 原型(Prototype) # # 复制原型来创建新对象 结构型 # 适配器(Adapter) # # 用来匹配接口 o-\u0026gt; 类 public class Source(){ public void method1(){} } public interface Targetable { public void method1() public void method2() } public class Adapter extends Source implements Targetable { @Override public void method2(){} } o-\u0026gt; 对象 public class Wrapper implements Targetable { private Source source; public Wrapper(Source source){ super(); this.source = source; } @Override public void method1(){ source.method1() } @Override public void method2(){} } o-\u0026gt; 接口 public abstract class AbstractTarget implements Targetable { @Override public void method1(){} } public class Adapter extends AbstractTarget { @Override public method2(){} } 桥接(Bridge) # # 分离抽象和具体(两个维度发展)分别继承，抽象聚合(桥接)具体 public abstract class Gift { GiftImpl impl; } public class Flower extends GiftImpl {} public class WarmGift extends Gift { public WarmGift(GiftImpl impl) { this.impl = impl; } } 组合(Composite) # # 树状结构 abstract class Node{} class LeafNode extends Node{} class BranchNode extends Node{ List\u0026lt;Node\u0026gt; nodes = new ArrayList\u0026lt;\u0026gt;(); } tree(Node b, int depth) { b.print(); if (b instanceof BranchNode) { for (Node n : ((BranchNode)b).nodes){ tree(n, depth+1) } } } 装饰(Decorator) # # 持有被装饰实例，实现同一接口 public interface Sourceable { public void method(); } public class Source implements Sourceable { @Override public void method(){} } public class Decorator implements Sourceable { private Sourceable source; public Decorator(Sourceable source) { super(); this.source = source; } @Override public void method() { source.method(); } } 门面(Facade) # # 对外接待 中介者(Mediator) # # 内部都只关联它，如mq 享元(Flyweight) # # 共享元数据 代理 # # 静态代理，实现同装饰 class TankTimeProxy implements Movable { Movable m; @Override public void move(){ m.move(); } } # 动态代理，Proxy调asm生成代理类 Tank tank = new Tank(); Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader()), new Class[]{Movable.class}, new Hander(tank) ); class Handler implements InvocationHandler { Tank tank; @Override public Object invoke(Object proxy, Method method, Object[] args) { return method.invoke(tank, args); } } // 动态代理, CGLIB调asm，由于是继承，所以final类不能代理 Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Tank.class); enhancer.setCallback(new TimeMethodInterceptor()); Tank tank = (Tank)enhancer.create(); tank.move(); class TimeMethodInterceptor implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) { return methodProxy.invokeSuper(o, objects); } } // Spring AOP: aspect指定代理类, pointcut指定被代理方法 行为型 # 观察者 # # Observer, 对象变化，对观察者广播 public interface Observer { public void update(); } public class Observer1 implements Observer { @Override public void update(){} } public interface Subject{ public void add(Observer observer); public void del(Observer observer); public void notifyObservers(); public void operate() } public abstract class AbstractSubject implements Subject { private Vector\u0026lt;Observer\u0026gt; vector = new Vector\u0026lt;Observer\u0026gt;(); @Override public void add(Observer observer) { vector.add(observer); } @Override public void del(Observer observer) { vector.remove(observer); } @Override public void notifyObservers(){ Enumeration\u0026lt;Observer\u0026gt; enumo = vector.elements(); while (enumo.hasMoreElements()) { enumo.nextElement().update(); } } } public class MySubject extends AbstractSubject { @Override public void operate() { notifyObservers(); } } 模板方法(TemplateMethod) # # 钩子函数 abstract class F { public void m() { op1(); } abstract void op1(); } class C1 extends F { @Override void op1(){} } 状态(State) # # 状态便于扩展, 方法不便扩展。如果相反用switch public class MM { MMState state; public void smile(){ state.smile(); } } public abstract class MMState { abstract void smile(); } public class MMHappyState extends MMState { @Override void smile(){} } # FSM例子，线程状态 public class Thread_ { ThreadState_ state; void move(Action a) { state.move(a);} } abstract class ThreadState_ { abstract void move(Action a); } public class NewState extends ThreadState_ { private Thread_ t; @Override void move(Action a) { if (\u0026quot;start\u0026quot;.equals(a.msg)) { t.state = new RunningState(t); } } } public class Action { String msg; } 迭代器(Iterator) # public interface Iterator\u0026lt;E\u0026gt; { boolean hasNext(); E next(); } public interface Collection\u0026lt;E\u0026gt; { Iterator\u0026lt;E\u0026gt; iterator(); } class List\u0026lt;E\u0026gt; implements Collection\u0026lt;E\u0026gt; { private class Itr\u0026lt;E\u0026gt; implements Iterator\u0026lt;E\u0026gt; { @Override public boolean hasNext(){} @Override public E next(){} } @Override public Iterator iterator(){ return new Itr(); } } 策略 # # strategy, 封装多个算法类, 更换策略，调用方式一致 o-\u0026gt; public interface ICalculator { public int calculate(String exp); } public class Minus extends AbstractCaculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp, \u0026quot;-\u0026quot;); return arrayInt[0] - arrayInt[1]; } } public class AbstractCalculator { public int[] split(String exp, String opt) { String[] array = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; } } Icalculator cal = new Minus(); cal.calculate(exp); 备忘录(Memento) # # 快照 # Java序列化, ProtoBuf库 class C implements Serializable { private transient List\u0026lt;Object\u0026gt; list; } ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\u0026quot;\u0026quot;))); oos.writeObject(o1) oos.writeObject(o2) ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\u0026quot;\u0026quot;))); o1 = ois.readObject(); o2 = ois.readObject(); 命令(Command) # # 别名Action或Transaction # 配合组合实现宏命令, 配合责任链实现undo，配合备忘录实现事务回滚 abstract class Command { abstract void do(); abstract void undo(); } class InsertCommand extends Command {} 责任链(Chain of Responsibility) # interface Filter { boolean doFilter(Msg m); } class HTMLFilter implements Filter {} class FilterChain implements Filter{ List\u0026lt;Filter\u0026gt; filters = new ArrayList\u0026lt;\u0026gt;(); public boolean doFilter(Msg msg){ for (Filter f : filters) { if (!f.doFilter(msg)) { return false; } } return true; } public FilterChain add(Filter f) { filters.add(f); return this; } } FilterChain fc = new FilterChain(); FilterChain fc2 = new FilterChain(); Filter f = new Filter(); fc.add(f).add(fc2); # ServletFilter Filter1 implements Filter { void doFilter(req, resp, chain) { chain.doFilter(req, resp); } } FilterChain implements Filter { List\u0026lt;Filter\u0026gt; filters; int curIndex = 0; void doFilter(req, resp){ curIndex++; if (curIndex \u0026lt; filters.size()) { filters[curIndex].doFilter(req, resp, this); } } } 访问者(Visitor) # # 内部结构不变，访问方式扩展 interface Visitor { void visitCpu(CPU cpu); } class Visitor1 implements Visitor { double price = 0.0; @Override void visitCpu(CPU cpu) { price += cpu.getPrice() * 0.9; } } class Computer { Part cpu; void accept(Visitor v) { this.cpu.accept(v); } } abstract class Part { abstract void accept(Visitor v); abstract double getPrice(); } class CPU extends Part { @Override void accept(Visitor v){ v.visitCpu(this); } } Visitor p = new Visitor1(); new Computer().accept(p); p.price; # Java类AST编译器Visitor, ASM // 打印 class ClassPrinter extends ClassVisitor { @Override MethodVisitor visitMethod(){ print(name + \u0026quot;()\u0026quot;); retrun null; } } ClassPrinter cp = new ClassPrinter(); ClassReader cr = new ClassReader(\u0026quot;java.lang.Runnable\u0026quot;); cr.accept(cp, 0); // 生成类 ClassWriter cw = new ClassWriter(0); cw.visitMethod(ACC_PULIC + ACC_ABSTRACT, \u0026quot;compareTo\u0026quot;, \u0026quot;(Ljava/lang/Object;)I\u0026quot;, null, null).visitEnd(); cw.visitEnd(); MyClassLoader cl = new MyClassLoader(); byte[] b = cw.toByteArray(); Class c = cl.defineClass(\u0026quot;pkg.Comparable\u0026quot;, b, 0, b.length); // 代理类 ClassReader cr = new ClassReader(); ClassWriter cw = new ClassWriter(0); ClassVisitor cv = new ClassVisitor(ASM4, cw) { @Override public MethodVisitor visitMethod() { MethodVisitor mv = super.visitMethod(); return new MethodVisitor(ASM4, mv) { @Override public void visitCode(){ visitMethodInsn(INVOKESTATIC, \u0026quot;TimeProxy\u0026quot;, \u0026quot;before\u0026quot;, \u0026quot;()v\u0026quot;, false); super.visitCode(); } } } }; cr.accept(cv, 0); cw.toByteArray(); 解释器(Intepreter) # # 解释出AST 其它补充 # 元素模式 # 抽象各模式成元素，简化表示 actor # 消息通信 reactor # 事件轮循，注册回调，如libevent proactor # 注册事件回调，os通知触发回调 惰性求值 链式定义(配方)，后自动触发(js tick调度)终止操作 dsl测试(如jasmine.js) "},{"id":68,"href":"/docs/pl/java/jvm/","title":"JVM","section":"Java","content":" 基础 # 定义 JVM规范说明书, JVMS(Java Virtual Machine Specifications) Java语言规范, JLS(Java Language Specification) 虚拟机 指令集 内存管理 过程 x.java -\u0026gt; javac -\u0026gt; x.class -\u0026gt; ClassLoader -\u0026gt; (字节码解释器、JIT) -\u0026gt; 执行引擎 JVM语言 Scala, Kotlin, Groovy, Clojure, jython, jruby等100多个 JVM实现 HotSpot # Oracle官方, 8之后收费, OpenJDK为开源版本 Jrockit # Oracle收购, 合并入HotSpot J9 # IBM Microsoft VM TaobaoVM # HotSpot深度定制 LiquidVM # 直接匹配专门硬件 azul zing # 收费，快, GC1mm, HotSpot参考写的G1 JRE, JDK JRE = jvm + core lib JDK = JRE + development kit JVM构造 # 指标 # 吞吐量: 代码时间 / (代码时间 + GC时间) 响应时间: STW越短, 响应时间越好 指令(Instructions) # 分类 基于栈的指令类 # 简单, HotSpot 基于寄存器的指令集 # 复杂但快, HotSpot局部变量表 8大原子操作(JSR-133已放弃这个描述，但指令没变化) lock # 主内存，标识变量线程独占 unlock # 主内存，解锁独占 read # 主内存，读到工作内存 load # 工作内存，read后的值放入线程本地变量副本 use # 工作内存，传值给执行引擎 assign # 工作内存，执行引擎结果赋值给线程本地变量 store # 工作内存，存值到主内存给write备用 write # 主内存，写变量值 方法指令 # 在methods的Code中罗列 aload_0 # 变量表第0项入栈 invokespecial #1 # 调private(无多态)的方法 invokevirtual # 调有多态可能性的方法 invokestatic # 调静态方法 invokeinterface # 调interface方法 invokedynamic # 1.7加入，定义类似函数指针时生成(但每个函数都创建了类) 调用动态产生的类 lambda 反射 scala等JVM语言 CGLib ASM 组成 bootstrapMethod 方法签名 \u0026lt;1.8的bug # 类产生于Perm Space，内存不回收 for(;;) {I j = C::n;} return # 方法返回 bipush 8 # byte扩展成int类型，放到方法栈中 sipush 200 # short istore_1 # 出栈，放到下标为1的局部变量表 iload_1 # 局部变量表下标1位置值压栈 iinc 1 by 1 # 局部变量表1位置值+1 iadd # 出栈两个，相加压栈 new # new对象, 地址压栈 dup # 复制栈顶并压栈 pop # 弹出栈顶 if_icmpne 7 # int值比较，不等时跳到第7条指令 mul # 乘法 sub # 减法 class结构 # 工具 # javap -v a.class jetbrain jclasslib jetbrain BinEd JBE # 可编辑 二进制 # Magic Number(4字节) cafe babe Minor Version(2字节) # 小版本 Major Version(2字节) # 大版本 JDK1.7是51.0 JDK1.8是52.0 constant_pool_count(2字节) # 长度constant_pool_count-1的表 constant_pool # 索引、tag、类型 1 CONSTANT_Utf8_info # 存一些描述字符串 2 标记 3 CONSTANT_Integer_info 4 CONSTANT_Float_info 5 CONSTANT_Long_info 6 CONSTANT_Double_info 7 CONSTANT_Class_info 8 CONSTANT_String_info 9 CONSTANT_Fieldref_info 10 CONSTANT_Methodref_info # 方法引用 指向CONSTANT_Class_info 指向CONSTANT_NameAndType_info 11 CONSTANT_InterfaceMethodref_info 12 CONSTANT_NameAndType_info # 方法名与类型 15 CONSTANT_MethodHandle_info 16 CONSTANT_MethodType_info 18 CONSTANT_InvokeDynamic_info access_flags(2字节) # bitmap按位与组合 # class的修饰符 ACC_PUBLIC 0x0001 public ACC_FINAL 0x0010 final ACC_SUPER 0x0020 JDK1.0.2之后必须为真, 表示invokespectial用新语义 ACC_INTERFACE 0x0200 是否接口 ACC_ABSTRACT 0x0400 抽象类 ACC_SYNTHETIC 0x1000 编译器自动生成 ACC_ANNOTATION 0x2000 ACC_ENUM 0x2000 this_class(2字节) 存名字对应指向常量池序号 super_class(2字节) 存名字对应指向常量池序号 interfaces_count(2字节) interfaces fields_count(2字节) fields access_flags(2字节) name_index # 存常量池索引 descriptor_index byte B char C double D float F int I long L short S boolean Z void V Object Ljava/lang/Object 数组 一维数组 [B 多维数组 [[C attributes_count # 赋加属性 attributes methods_count(2字节) methods access_flags(2字节) name_index descriptor_index # 先参数列表，后返回值 void m() -\u0026gt; ()V String toString() -\u0026gt; Ljava/lang/String; attributes_count attributes # 赋加属性 Code # 指令列表, 一般先压栈this(aload_0) LineNumberTable LocalVariableTable attributes_count(2字节) attributes Agent # 例子 打包 a.jar MANIFEST.MF Premain_Class: MyAgent public class MyAgent { public static Instrumentation inst; public static void premain(String agentArgs, Instrumentation _inst) { inst = _inst; } } JVM参数 -javaagent: a.jar 使用 MyAgent.inst JMM(Java Memory Model) # 内存 # 运行时区域 # # Runtime data areas 分类 Program Counter # 程序计数器，下一条指令位置 Method Area # 方法区,线程间共享 存储 Class元信息 代码编译信息, JIT编译信息 常量池(Runtime Constant Pool) # 常量池在运行时存放区 版本区别 Perm Space(\u0026lt;1.8) # 要设定大小, 会溢出报错 存字符串常量 lambda生成临时类永远存在 Full GC不清理 Meta Space(\u0026gt;=1.8) # 自动大小无上限 字符串常量位于堆 会触发Full GC JVM stacks # 线程栈 Frame(栈帧) # 一个方法一个栈帧 Local Variable Table # 局部变量表, 方法内的局部变量，值在常量池 默认第0个为this Operand Stack # 操作数栈 Dynamic Linking # 指向调用方法的 运行时常量池的符号连接 return address # 当前方法执行完的返回地址 Native Method Stacks # C/C++方法栈 Direct Memory # 直接内存 Heap # 堆, 线程间共享 屏障 # CPU屏障 JVM规范 LoadLoad # 上load和下load不能重排 StoreStore LoadStore StoreLoad # 最强 对象 # 对象内存存储 # 普通对象 对象头: markword 8字节 ClassPointer # 指向Class对象, 启用压缩4字节，不启用8字节 实例数据 引用类型 # 启用压缩4字节，不启用8字节 Padding: 对齐8的倍数 数组对象 对象头 ClassPointer 数组长度4字节 数组数据 Padding 对象头 # 32位64位(25位没用到)，内容不同 锁标志位2位 # 根据锁标志位判断存储内容 01 无锁/偏向锁 00 轻量级锁 10 重量级锁 11 GC标记 是否偏向锁1位 剩余位 无锁状态 对象hashCode(25位或31位) 没重写过时默认计算(System.identityHashCode()) 重写过的hashCode()结果不存在这里 分代年龄 轻量级锁 指向栈中锁记录的指针 重量级锁 指向互斥量（重量级锁）的指针 偏向锁 线程ID 23位 Epoch 2位 分代年龄4位(所以分代年龄只有15) 其它问题 对象计算过hashCode，对象不能进入偏向锁状态(位已经被占了) 实验工具 javaagent 对象定位 # 句柄池 # 指向句柄，句柄有对象指针和class指针, 三色标记GC提高效率 直接指针 # 指向对象，对象指class, HotSpot使用 并发 # 硬件层数据一致性 # 硬件结构 L0寄存器 # 1 cycles L1高速缓存 # 3-4 cycles, 1ns L2高速缓存 # 10 cycles, 3ns L3高速缓存 # 40-45 cycles, 15ns, 在主板 (QPI总线传输) # 20ns L4主存 # 60-80ns L5磁盘 L6远程文件存储 数据不一致 # 从L2多CPU开始 锁总线(bus lock) CPU缓存一致性协议(如intel MESI) volatile # 工具 hsdis # HotSpot Dis Assembler, 虚拟机字节码对应汇编 bytecode ACC_VOLATILE JVM StoreStoreBarrier volatile写操作 # 上边写完再写，写完下边再读，写一致 StoreLoadBarrier LoadLoadBarrier volatile读操作 # 上边读完再读，读完下边再写，读一致 LoadStoreBarrier OS windows lock linux 上下屏障，最后lock synchronized # bytecode 方法修饰 synchronized 代码 monitorenter monitorexit JVM C/C++实现，会调用OS的同步机制 OS lock happens-before原则 # # Java要求指令不能重排的几种情况 as if serial # # 不管如何重排序，单线程执行结果不变 过程 # 编译 # 过程 代码 -\u0026gt; bytecode -\u0026gt; JVM指令 -\u0026gt; OS指令 解释器(bytecode intepreter) JIT(Just In-Time compiler) 混合模式 解释器 + 热点代码编译 热点代码检测 方法计数器 循环计数器 加载 # HotSpot C++代码加载 class对象加载到MethodArea metaspace(JDK1.8) permGeneration(JDK1.8之前) class加载过程 loading # 读到内存 linking verification # 校验 preparation # 静态变量赋默认值 resolution # 解析, loadClass()可指定是否解析。常量池的符号引用转换成内存地址引用 initializing # 静态变量赋初始值，执行静态代码 对象加载 new过程 class加载 申请对象内存 成员变量赋默认值 调用构造方法\u0026lt;init\u0026gt; 成员变量顺序赋初始值 执行构造方法语句(先super) 双亲委派 过程 类名一层层向上找 找不到时，一层层找再向下委派找 都不能加载时, 抛ClassNotFound 为什么 安全, 自定义类不能覆盖 已加载不用重复加载 父加载器 不是类加载器的加载器 不是父类 是组合的parent对象 打破 为什么 JDK1.2之前都重写loadClass() thread.setContextClassLoader()指定线程上下文classLoader 热启动/热部署(OSGi tomcat)加载同一类不同版本 做法 重写loadClass(), new多个ClassLoader 类加载器 Bootstrap # 加载核心类 lib/rt.jar charset.jar等, C++实现所以get时为null 如加载String Extension # 加载扩展jar jre/lib/ext/*.jar, 由-Djava.ext.dirs指定 App # 加载classpatch指定内容 Custom ClassLoader # 自定义ClassLoader 加载路径环境变量 # 来自Launcher源码 Bootstrap.ClassLoader sun.boot.class.path ExtensionClassLoader java.ext.dirs AppClassLoader java.class.path API Class getClassLoader() ClassLoader # findInCache() -\u0026gt; parent.loadClass() -\u0026gt; findClass() private final ClassLoader parent loadClass # 热加载 Launcher $AppClassLoader $ExtClassLoader 自定义类加载器 class MyClassLoader extends ClassLoader { @Override Class findClass(String) { return defineClass() } } 懒加载 # JVM未规定什么时候加载,但规定了什么时候初始化 初始化 new getstatic putstatic invokestatic指令，访问final变量除外 java.lang.reflect对类进行反射调用 初始化子类时，父类首先初始化 虚拟机启动时，被执行的主类 动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic, REF_putstatic, REF_invokestatic的方法句柄时, 该类初始化 GC # 引用方式(强软弱虚) # 软引用 # 内存不够用时回收，用做缓存 # -Xms20M -Xmx20M SoftReference\u0026lt;byte[]\u0026gt; m = new SoftReference\u0026lt;\u0026gt;(new byte[1024*1024*10]); System.gc(); m.get(); new byte[1024*1024*15] m.get(); 弱引用 # 只要gc就回收，用做容器如WeakHashMap(key是弱引用), ThreadLocalMap的key WeakReference\u0026lt;M\u0026gt; m = new WeakReference\u0026lt;\u0026gt;(new M()); System.gc(); m.get(); 虚引用 # 值被回收时放入队列来通知, 用来触发回收堆外内存(用Unsafe的freeMemory()) # 如NIO的直接内存DirectByteBuffer PhantomReference\u0026lt;M\u0026gt; r = new PhantomReference\u0026lt;\u0026gt;(new M(), QUEUE); r.get() // 自己写永远返回null 对象分配过程 # 向栈分配 # 不要调参数 好处 不必GC 条件 线程私有小对象 无逃逸 可标量替换(基本类型替换整个对象) 过大，分配到老年代 线程本地分配 # TLAB(Thread Local Allocation Buffer), 不要调参数 好处 为了减少线程争用 条件 小对象 占用eden, 默认每个线程占1% 伊甸区 s1,s2 次数 # 最大15(对象头上空间决定) Parallel Scavenge 15 CMS 6 G1 15 动态年龄 eden + s1 复制到s2, 超过s2总内存一半时，年龄最大的对象进入老年代 分配担保 YGC时survivor区空间不够, 直接进入老年代 GC清除或到老年代 GC分代过程 # YGC -\u0026gt; s0 YGC, eden + s0 -\u0026gt; s1 年龄足够 -\u0026gt; old s区装不下 -\u0026gt; old YGC, eden + s1 -\u0026gt; s0 old满了 -\u0026gt; FGC 常见的回收器 # 概念 Safe Point # STW时机 没有无STW的回收器 分代 Young Serial # 第一个GC STW, 单线程串行回收 Parallel Scavenge STW, 并行回收 ParNew # Parallel New 增强PS, 以配合CMS并行回收, CMS到某阶段时PN运行 Old Serial Old 特点 适用几十M mark-sweep-compact，单线程 Parallel Old 特点 适用几个G mark-sweep-compact，多线程 CMS # concurrent mark sweep, 1.4后期引入, JDK11取消 特点 适用20G 多线程并行回收, 并发回收(GC与程序同时运行)，降低STW时间(200ms) 不足 # 问题多，没有版本默认CMS 浮动垃圾 碎片多，新对象分配不下时，使用SerialOld 设低GC阈值回收浮动垃圾 清理过程 初始标记(initial mark) STW, 单线程, 标记根对象 [预标记] # Card Marking, 把Card标为Dirty 并发标记(concurrent mark) 不STW, 多线程, 执行多次 重新标记(remark) # 处理并发标记过程中的变化 STW, 多线程, 并发清理(concurrent sweep) # 过程中产生的浮动垃圾, 下次回收 不STW, 多线程, [整理阶段] 日志 [GC(Allocation Failure)[ParNew:6144K-\u0026gt;640K(6144K)], 0.02 secs] 6585K-\u0026gt;2770K(19840K),0.02 secs][Times:user=0.02 sys=0.00, real=0.02 secs] 6144K-\u0026gt;640K(6144K): 回收前 回收后 总容量 6585K-\u0026gt;2770K(19840K): 堆回收前 回收后 总大小 [GC (CMS Initial Mark)] [1 CMS-initail-mark] [CMS-concurrent-mark-start] [CMS-concurrent-preclean-start] [GC (CMS Final Remark)] [YG occupancy] # 清理后年轻代占用及容量 [Rescan(parallel)] # STW下标记存活对象 [weak refs processing] # 弱引用处理 [class unloading] # 卸载用不到的class [scrub symbol table] # 清理常量池 [scrub string table] # 清理常量池 [1 CMS-remark] # 清理后老年代占用及容量 [CMS-concurrent-sweep-start] [CMS-concurrent-reset-start] 不分代 G1 # Garbage First, 1.7引入, 1.8完善, 1.9默认 特点 适用上百G STW 10ms回收 容易预测STW时间 低latency, 但throughput也低 并发回收, 三色标记 只逻辑分代, 不物理分代 内存分Region, Region组成不同大小块，块在逻辑分代中 Eden和Old区的内存映射会变化 动态新老代空间 # 如果YGC频繁，就Young调大 不要手工指定, 是G1预测YGC停顿时间的基准, 停顿时间通过参数设置 概念 CSet # Collection Set 可回收Region集合, 回收时存活的对象被移动 占堆空间不到1% RSet # Remembered Set 用于找到谁引用当前对象(对象级别), 记录其他Region的引用 赋值时有GC写屏障 # 非内存屏障 CardTable # YGC定位垃圾，要从Root查所有Old区对象，效率低 Old区对象引用Young区时, bitmap标DirtyCard。YGC时只扫描DirtyCard MixedGC # 默认45%, 同CMS 初始标记 重新标记 筛选回收 # 筛选Region回收，有用对象复制到其它Region 日志 [GC pause (G1 Evacuation Pause) (young) (initial-mark)] # 复制存活对象, initial-mark在MixedGC时有 [GC concurrent-root-region-scan-start] # 混合回收 [GC concurrent-mark-start] # 混合回收 [Full GC (Allocation Failure)] # 无法evacuation时, G1中很严重 ZGC # JDK11, 不分代(SingleGeneration) 特点 STW设计10ms, 实际1ms 适用4T（JDK13 16T） 内存分块（有大有小） 概念 没有RSet, 改进了SATB指针 Shenandoah # JDK11 Epsilon # JDK11, debug用 Zulu 组合 S + SO PS + PO # 1.8默认, 10G内存10+秒 PN + CMS 算法 # 定位 引用计数(ReferenceCount) 循环引用问题 # 内部互相引用，没有外部引用 根可达算法(RootSearching) 线程栈变量 静态变量 常量池 JNI指针 # 本地方法用到的对象 并发标记 三色标记 白 # 未被标记 灰 # 自身被遍历到，成员变量未被遍历到 黑 # 自身、成员变量都被遍历到 漏标问题 两个必要条件 黑引用白后，灰对白的引用断开 算法 incremental update # 增量更新，关注引用的增加, CMS用的 增加引用后，标记为灰, 重新标记阶段再扫描 缺点是灰色还要重新扫描 SATB snapshot at the beginning # 关注引用的删除, G1用的 开始时快照, 引用消失时，引用推到堆栈, 下次扫描还扫白色对象 优点是只扫描修改过的对象, 看RSet中有没有引用 颜色指针 # 信息记在指针里 租户隔离, Session Base GC # Web专用, 基于session, session断开后删除 各GC应用 CMS 三色标记 + Incremental Update G1 三色标记 + SATB ZGC 颜色指针 + 写屏障 Shenandoah 颜色指针 + 读屏障 清除 标记清除(Mark-Sweep) # 一遍标记，一遍清理, 适合老年代 算法简单，戚对象多时效率高 两遍扫描效率低，容易产生碎片 拷贝(Copying) # 存活对象copy到新内存, 旧内存直接清理，适合伊甸区(新生代) 适用存活对象少的情况 内存减半 标记压缩(Mark-Compact) # 有用的填到前边去空隙去, 适合老年代 不会碎片，不会内存减半 扫描两次，还要移动 分代模型 分代模型 # -Xms -Xmx设置大小 new/young(新生代) # MinorGC/YGC, -Xmn设置大小, 默认占比1 eden(伊甸) # 默认占比8 survivor x 2 # 默认每个占比1 old(老年代) # MajorGC/FullGC, 1.8默认占比2, 之前是3 tenured(终身) methodArea # 1.7永久代, 1.8元数据区 各JVM的分代模型 Epsilon ZGC Shenandoah不是分代模型 G1是逻辑分代，物理不分代 其他都是逻辑分代 + 物理分代 调优(Tuning) # 前提 从业务场景开始 无监控(能压测), 不调优 目标 减少FGC 确定倾向 # 吞吐量, 或响应时间 吞吐量好: PS + PO 响应时间好: G1 或 PN + CMS # G1吞吐量少10% 组成部分 JVM预规划 优化JVM运行环境(慢、卡顿) 解决JVM运行时出现的问题(OOM) 步骤 熟悉业务场景 响应时间 吞吐量 选择回收器组合 计算内存需求(小的快，大的少gc) 选CPU 设定年代大小、升级年龄 设定日志参数 观察日志情况 问题分析 # 工具 # CPU经常100% top查进程CPU(top) 进程中线程CPU(top -Hp) 导出该线程堆栈(jstack) 查哪个方法(栈帧)消耗时间(jstack) 内存高 导出堆内存(jmap) 分析(jhat jvisualvm mat jprofiler ...) 监控JVM jstat jvisualvm jprofiler arthas top ... 网管: Ansible 流程 网管报警 top -Hp 进程号 jstack 进程号 # 列出所有线程号, 线程状态 WAITING, 一直等不到, BLOCKED, 拿不到锁 waiting on \u0026lt;0x0000\u0026gt; (a java.lang.Object) # 找到目标等待的线程 jstack -l 16进制线程号 jps jinfo 进程号 # 列JVM信息 jstat -gc 进程号 500 # 每500ms打印一次gc信息 jmap -histo 进程号 | head -20 # 列所有对象 有性能消耗，但不很高，可以在线执行 jmap -dump:format=b, file=x pid # 导出转储文件 内存特别大时，jmap会卡顿 多个服务器可用，停一个不影响 设定HeapDumpOnOutOfMemoryError产生堆转储文件 在线定位(中小型公司用不到) jhat -J-mx512M x.hprof # 分析堆dump文件, 有OQL arthas # 在线定位 启动 java -jar arthas-boot.jar 常用命令 # 没有集成jmap功能 jvm # jinfo thread # jstack thread 1 dashboard # top heapdump # jmap -dump dump redefine # 热替换 目前只能改method实现，不能改方法名与属性 jad # 反编译类 看动态代理生成的类 看第三方类 看版本 sc # search class, 显示class信息 watch # watch method MAT # 分析dump文件 jprofiler jconsole # 需要JMX JMX会消耗性能生产服务器不开 JMX图形界面只用于压测 jvisualVM # 需要JMX, 可分析dump文件 内存 # 现象 OOM崩溃 CPU飙高, 不断FGC 线程池不当运用 加内存反而卡顿 GC, 应该用CMS或G1替换 PS+PO JIRA不停FGC, 没定位出来 扩内存到50G, GC换G1, 重启 tomcat server.max-http-header-size过大 默认4096, 每个请求都分配 lambda表达式导致方法区溢出 java.lang.OutofMemoryError: Compressed class space disruptor不释放缓存 使用Unsafe分配内存, 直接内存溢出 -Xss设定小, 栈溢出 重写finalize()引发GC finalize()耗时长, GC时回收不过来，不停GC 内存不到10%，频繁FGC 有人显式调用System.gc() # 不定时调，但会频繁调 大量线程, native thread OOM 减少堆空间，留更多系统内存产生native thread G1产生FGC 降低MixedGC触发的阈值 # 默认45% 扩内存 提高CPU # 回收快 HotSpot参数 # 辅助 -XX:+PrintCommandLineFlags -version # 打印启动参数, -version是随便一个命令 -XX:+PrintFlagsFinal -version # 打印所有XX参数 -XX:+PrintFlagsInitial # 打印默认参数 -XX:+PrintVMOptions # 显示VM启动参数 - # 标准参数 -X # 显示非标参数 -XX # 显示不稳定参数 内存 -XX:+HeapDumpOnOutOfMemoryError # OOM时产生堆转储文件 -Xms40M # 堆起始大小 -Xmx60M # 堆最大大小, 最好和Xms一样以免堆弹大弹小 -Xmn # 年经代 -Xss # 栈空间 -XX:InitialHeapSize # 起始堆大小，自动算 -XX:MaxHeapSize # 堆最大大小，自动算 内存模型 -XX:-DoEscapeAnalysis # 去逃逸分析 -XX:-EliminateAllocations # 去标量替换 -XX:-UseTLAB # 去tlab -XX:TLABSize # 设置TLAB大小 -XX:+PrintTLAB -XX:MaxTenuringThreshold # 进老年代（升代）回收次数, 最大值15， CMS默认6，其它默认15 对象和类 -XX:+UseCompressedClassPointers # class指针压缩 开启时4字节，不开启时8字节 -XX:+UseCompressedOops # 引用类型指针压缩, Ordinary Object Pointers 开启为4字节，不开启时8字节 -verbose:class # 类加载详细过程 -XX:PreBlockSpin # 锁自旋次数 编译 -Xmixed # 混合模式 -Xint # 解释模式 -Xcomp # 编译模式 -XX:CompileThreshold = 10000 # 检测热点代码次数 GC -XX:+PrintGC # 打印GC信息 PrintGCDetails # 打印GC更详细 PrintGCTimeStamps # 打印GC时间 PrintGCCauses # GC原因 PrintHeapAtGC PrintGCApplicationConcurrentTime # GC应用程序时间 PrintCApplicationStoppedTime # 打印STW时长 -XX:+PrintReferenceGC # 打印回收多少种引用类型 -XX:+UseConcMarkSweepGC # 用CMS -XX:+DisableExplictGC # System.gc()不管用 Parallel常用 -XX:SurvivorRatio # 新生代Eden区和Surivor区的比例 -XX:PreTenureSizeThreshold # 大对象到底多大 -XX:+ParallelGCThreads # 并发线程数, 默认是CPU数 -XX:+UseAdaptiveSizePolicy # 自动调所有区比例 CMS常用 -XX:ParallelCMSThreads # 并发线程数，默认是CPU数一半 -XX:CMSInitiatingOccupancyFraction 92% # 老年代占多少时触发GC, 1.8 92%, 之前68% 设小一点，清除浮动垃圾 过大时，栈分配不下，Promotion Failure，触发FGC -XX:+UseCMSCompactAtFullCollection # GC时压缩，避免碎片片 -XX:CMSFullGCsBeforeCompaction # 多少次GC后压缩 -XX:+CMSClassUnloadingEnabled # 回收方法区 -XX:CMSInitiatingPermOccupancyFraction # 到什么比例时进行Perm回收, 1.8之前 GCTimeRatio # GC占程序运行时间的百分比 -XX:MaxGCPauseMillis # GC停顿时间, CMS会减少年轻代大小 G1 -XX:MaxGCPauseMillis # STW时间, 区别CMS, G1会调整Young区的块数 GCTimeRatio -XX:GCPauseIntervalMillis # STW之间间隔时间 -XX:+G1HeapRegionSize # Region大小, 1 2 4 8 16 32, 逐渐增大, GC间隔更长, 每次GC时间更长 ZGC是动态调整的 G1NewSizePercent # 新生代最小比例, 默认5% G1MaxNewSizePercent # 新生代最大比例，默认60% ConcGCThreads # GC线程数 InitiatingHeapOccupancyPercent # 启动GC的堆空间占用比例 JMX监控 -Djava.rmi.server.hostname=192.168.1.1 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false 调优 # 参数越来越少 JVM参数800个 CMS参数300个 G1参数100个 ZGC更少 Zing1个 GC组合参数 -XX:+UseSerialGC S + SO -XX:+UseParNewGC # 已废弃 PN + SO -XX:+UseConc(urrent)MarkSweepGC PN + CMS + SO -XX:+UseParallelGC # 1.8默认 PS + PO -XX:+UseParallelOldGC PS + PO -XX:+UseG1GC G1 日志参数 -Xloggc:/logs/xx-xx-%t.log -XX:+UseGCLogFileRotation # 5个满了，覆盖第一个 -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=1024M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause HotSpot日志 # GC # PrintGCDetails [GC GC表示YGC, Full GC是FGC (Allocation Failure) 原因 [DefNew:4544k-\u0026gt;259k(6144k), 0.0873 secs] DefNew表示年轻代, 回收前后的大小, 6144是年轻代总大小，回收时间 4544k-\u0026gt;4356k(19840k), 0.0812 secs] 堆的前后大小, 19840是堆总空间, 回收时间 [Times: user=0.01 sys=0.00, real=0.01 secs] linux time命令，用户态时间，内核态时间，总时间 异常退出dump堆 def new generation total 6144k, used 5504k [0x00, 0x00, 0x00] 新生代总共多少，用了多少。内存起始地址，使用空间结束地址，整体空间结束地址 total = eden + 1个survivor eden space 5504k, 100% used [] eden from space 640k, 0% used [] s0 to space 640, 0% used [] s1 tenured generation total 13696k, used 13312k [] old the space 13696k, 97% used [] old Metaspace used 2538k, capacity 4486k, committed 4864k, reserved 1056768k used真正使用的大小 capacity目前指定的容量 committed 表示预先占用的大小 reserved表示共保留的大小 class space used 275k, capacity 386k, committed 512k, reserved 1048576k metaspace中存class的部分 "},{"id":69,"href":"/docs/basic/algorithm/thought/","title":"算法思想","section":"算法","content":" 口诀 # 难题首选动归 受阻贪心暴力 考虑分治思想 配合排序哈希 递归(recursion) # 介绍 利用递归，把状态的管理责任推给运行时 递归转迭代 可加上memory做优化 分治(divide and conquer) # 介绍 广义分治法 例子 二分检索 找最大/最小元素 归并分类 快速分类 选择问题 斯特拉森矩阵乘法 贪心(greedy) # 案例 Dijkstra最短路径 最小生成树Prim, Kruskal 背包问题 作业排序 最优归并模式 动态规划(dynamic planning) # 方法 常用滚动数组降低空间复杂度 案例 多段图 结点间最短路径 最优二叉检索树 0/1背包问题 可靠性设计 货郎担问题(旅行商问题) 流水线调度问题 检索与周游(retrieval/travel) # 案例 深度优先检索 广度优先检索 与/或图 对策树 回溯(backtracking) # 案例 8皇后问题 图的着色 哈密顿环 背包问题 暴力(brute force) # 介绍 分支限界条件加快效率 例子 DFS, BFS 分支-限界(branch and bound) 案例 LC检索 0/1背包问题 货郎担问题 并行(parallel) # 时间复杂度(time complexity) # O()表示上界(\u0026lt;=), Ω() [omega]表示下界(\u0026gt;=), Θ() [Theta] 表示上下界相同, o()表示非Θ()的O() N \u0026gt;= n0时, T(N) \u0026lt;= cf(N), 记为T(N) = O(f(N)) N \u0026gt;= n0时, T(N) \u0026gt;= cg(N), 记为T(N) = Ω(g(N)) T(N) = Θ(h(N)) 当且仅当T(N) = O(h(N)) 和 T(N) = Ω(h(N)) 上界(upper bound) 下界(lower bound) 法则 # 约定, 不存在特定的时间单位 # 约定, 机器模型中, 1. 所有指令顺序执行。2. 任一简单的工作都恰好花费一个时间单位 ## 假设不存在如矩阵求逆或排序这样的单位操作 1. 如果T1(N) = O(f(N)), T2(N) = O(g(N)), 那么 T1(N) + T2(N) = O(f(N) + g(N)), 或写成 max(O(f(N)), O(g(N))) T1(N) * T2(N) = O(f(N) * g(N)) 2. 如果T(N)是一个k次多项式, 则T(N) = Θ(N^k) 3. 对任意常数k, (logk) * N = O(N) # 对数增长得非常缓慢 一般法则 1. for 循环时间, 为内部语句的运行时间 * 迭代次数 2. 嵌套for 循环, 内部语句时间 * 迭代次数n次方 3. 顺序语句, 各语句时间求和 4. if(S1)/else(S2), 判断的运行时间加 S1和S2中时间长者 相对增长率(relative rate of growth) lim(N-\u0026gt;∞)f(N)/g(N)来确定两个函数的相对增长率 1. 极限是0, 则f(N) = o(g(N)) 2. 极限是c\u0026lt;\u0026gt;0, 则f(N) = Θ(g(N)) 3. 极限是∞, 则g(N) = o(f(N)) 4. 极限摆动，则f(N)与g(N)无关 洛必达法则 lim(N-\u0026gt;∞)f(N) = ∞, 且lim(N-\u0026gt;∞)g(N) = ∞ 时, lim(N-\u0026gt;∞)f(N)/g(N) = lim(N-\u0026gt;∞)f'(N)/g'(N) 多项式时间算法 O(1) \u0026lt; O(logn) \u0026lt; O(n) \u0026lt; O(nlogn) \u0026lt; O(n^2) \u0026lt; O(n^3) 指数时间算法 O(2^n) \u0026lt; O(n!) \u0026lt; O(n^n) 递归分析 1. 如求factorial(阶乘)的简单for循环, 则为O(N) 2. 求解一个递推关系, 如fabonacii, return fib(n - 1) + fib(n - 2) T(N) = T(N - 1) + T(N - 2) + 2, 又fib(N) = fib(N - 1) + fib(N - 2), 由归纳法得T(N) \u0026gt;= fib(N) 又fib(N) \u0026lt; (5/3)^N, 可知时间指数增长 # 该算法大量重复计算, 违反递归的合成效益法则 3. 对于T(N) = aT(N / b) + Θ(N^k), 解为 O(N^(log(b)(a))), 若 a \u0026gt; b^k O(N^k * logN), 若 a = b^k O(N^k), 若 a \u0026lt; b^k 影响性能的其它因素 程序实现方法和语言 数据读入 空间复杂度(space complexity) # Space(N) = Heap(N) + Stack(N), 忽略低次项、系数 # Heap表示额外申请堆内存空间大小, Stack表示函数栈的最大深度 "},{"id":70,"href":"/docs/basic/algorithm/data_structure/","title":"数据结构","section":"算法","content":" 线性 # 列表(list) 数组(array) # 相同数据类型元素的序列，下标(index)访问 low high 字符串 二进制串(binary string) # 位串(bit string) 链表(linked list) 节点(node) 指针(pointer) 表头(header) 单链表(singly linked list) 双链表(doubly linked list) 栈(stack) # 插入和删除只能在端部进行的列表，应用于递归 栈顶(top) LIFO last-in-first-out 队列(queue) 队头(front) 队尾(rear) 入队(enqueue) FIFO first-in-first-out 优先队列(priority queue) # 数据项多来自于全序域(常整数或实数) 查找最大元素，删除最大元素，插入新元素 堆(heap)实现 散列表 # 介绍 有序输入时，树效率低，如果不要求查找有序结果，可以用散列 概念 hash table hashing(散列) item(项) key(关键字) # 项中某部分 hash function(散列函数) # 映射函数 collsion(冲突) # 多个关键字散列到同项的状况 load factor(装填因子) # λ 元素个数对表长度的比， # 如果散列是均匀的，表示了一个项中关键字的平均长度 # 一次成功查找要遍历约1 + (λ / 2)个链，1表示被匹配的项 rehashing(再散列) 一半时进行 直到插入失败再进行 middle-of-the-road # 到达某load factor时进行 caching the hash code(闪存散列代码) 算法 separate chaining(分离链接法) # 解决冲突 probing hash table(探测散列表) 线性探测法 primary clustering(聚集) # 线性探测法中形成数据区块 平方探测法 secondary clustering(二次聚集) # 模拟结果指出，对每次查找，会引起另外的少于一半的探测 double hashing(双散列) # 模拟表明, 两个散列都mod质数时，探测次数几乎和随机冲突解决方法相同 extendible hashing(可扩散列) D directory(目录) # 一个分区中bit的个数，所以M最多2^D 性质 # 基于位模式(bit patterm)是均匀分布的事实, 是\u0026quot;分支系数(branch factor)\u0026quot;, N 是记录总数(随时间变化) 树叶期望个数为(N/M)log(2)(e) 所以平均树叶满的程度为ln2 = 0.69, 同B树 目录期望大小为O(N^(1 + 1 / M) / M) 叶子可以指向实际记录的链表(内存装不下太大目录时)，这样得到实际数据就需要第二次磁盘访问 队列 # 介绍 queue 先进先出 概念 enqueue(入队) dequeue(出队) priority queue(优先队列) insert deleteMin binomial queue(二项队列) merge, insert, deleteMin 最坏时间为O(logN), 插入花费常数时间 堆序树(二项树)的森林实现 B0 = 2^0, B1 = 2^1, B2 = 2^2 ... Bn = B0 + B1 + ... B(n-1) 集合 # 概念 set(集合)，互不相同项的无序组合(可空) element(元素) dictionary(字典)，能够查找，增加，删除元素的集合 # 实现时要达到效率的平衡 set union problem(集合合并问题) # 动态地把n个元素集合划分为一系列不相交的子集 ADT abstract data type(抽象数据类型) # 由表示数据项的抽象对象集合和一系列对它的操作构成 实现 universal set(通用集合) 通用集合的子集，用长度为n(通用集合的长度)的位向量(bit vector)表示 # 占用大量存储空间 线性列表 # 去除包含的重复元素 # 列表是有序的，但这差别并不重要 多重集(multiset)、包(bag) # 可重复项的无序组合 表示 S = {2, 3, 5, 7} S = {n: n 为小于0的质数} 树 # 概念 tree free tree(自由树)，连通无回路的图 full tree(满树)，所有节点要么是树叶，要么是两个儿子 forest(森林)，无回路但不一定连通的图 root rooted tree(有根树)，确定根的树，常简称为树 node ancestor(祖先)，顶点本身也作为自己的祖先 proper ancestor(真祖先)，除了自己的祖先 parent(父母) child(子女) sibling(兄弟) leaf(叶节点), 没有子女的顶点 parental(父节点)，至少有一个子女的顶点 descendant(子孙)，以v为祖先的所有节点，包含v proper descendant(真子孙)，不包含本身 subtree(子树) depth(深度)，从根到v简单路径的长度 height depth 树中结点的最大级数 rank(秩) # 子女数 height(高度)，从根到叶节点最长简单路径的长度 # 按树的层的数量定义时，高度增加1 degree(度，一个节点子树的数目) level(root为1级, 结点为p级时，儿子在p+1级) state-space tree(状态空间树)，可用于分析回溯和分支界限 ordered tree(有序树)，有根树的每个顶点，所有子女有序 first child-next sibling representation(先子女后兄弟表示法) # 子女数不定，父节点只存第一个子女，该子女存兄弟链表 ## 以一种高效方式将有序树改造成关联二叉树 ## 关联二叉树中，左指针表示下层，右指针表示兄弟节点 binary tree(二叉树)，属于有序树 left child(左子女) right child(右子女) 左(右)子树 # 二叉树可以递归定义，所有可以用递归算法 binary search tree(二叉查找树)，父母顶点比左子树中所有数字大，右子树中小 效率，多取决于高度 logn \u0026lt;= h \u0026lt;= n - 1 # h 为高度, n为顶点数 multiway search tree(多路查找树) B树, B+树, B-树 边 树向边 回边 前向边 # 顶点到非子孙 交叉边 # 非前三都是交叉边 性质 |E| = |V| - 1 # 树的边数总比顶点数小1 # 图变树的必要不充分条件，连通图变树的必要充分条件 任意两个顶点间总存在简单路径，任选顶点可作根 二叉树 # 介绍 binary tree 常用顺序表或链表存储 概念 full binary tree(满二叉树) # 满子节点，且子节点在同一层上 heap(堆) # 根向下从大到小排序 binary search tree(二分检索树) # 左子节点小于父节点小于右子节点 left child(左子女) right child(右子女) 左(右)子树 # 二叉树可以递归定义，所有可以用递归算法 complete binary tree(完全二叉树) # 只有最大层节点不满且连续集中在左边 高是logN 可以用数组实现(从index = 1开始存储) 左儿子在2i, 右儿子在2i + 1, 父亲在i / 2 perfect binary tree(理想二叉树) # 满节点二叉树 full binary tree(满二叉树) # 同理想二叉树 skewed tree(斜树) # 一个节点不断左斜是左斜树，相反为右斜树 binary search tree(二叉查找树) # 父母顶点比左子树中所有数字大，右子树中小 AVL tree(Adelson-Velskii-Landis tree) # 带有平衡条件(balance condition)的二叉查找树 平衡条件: 左右子树最多差1 # 节点中存储高度信息 splay tree(伸展树) # 分析树的一种 效率，多取决于高度 logn \u0026lt;= h \u0026lt;= n - 1 # h 为高度, n为顶点数 树转换二叉树 堆 # 概念 binary heap(二叉堆、堆) # 一棵完全二叉树 结构性 heap-order property(堆序性) heap-order tree(堆序树) 已证明，平均一次插入需要2.607次比较，所以上移1.607层 d-堆 # 二叉堆是2-堆 deleteMin为时间为O(dlog(d)(N)) 实践中 插入次数比deleteMin次数多(可加速) 主存不够时如B树使用 4-堆胜过二叉堆 leftist heap(左式堆) 不是理想平衡(perfectly balanced)的，实际趋向于不平衡 具有堆序性 npl(X) null path length 零路径长 # X到一个不具有两个儿子节点的最短路径。到本身npl(X) = 0。npl(null) = -1 o(N)时间处理一个merge 定义 堆中每个节点，左儿子的npl \u0026gt;= 右儿子的npl 操作 merge insert deleteMin 性质 左儿子npl \u0026gt;= 右儿子npl skew heap(斜堆) 有堆序性 定义 不维护npl 每次合并都交换左右(只有左儿子的除外) 其它同左式堆 性质 任意M次连续操作, 总的最坏情况运行时间为O(MlogN), 每次摊开销为O(logN) 操作 merge insert deleteMin binomial queue(二项树) B(k) 由B(0), B(1), ... B(k - 1)连接根组成 有2^k个节点, k为高度 pairing heap(配对堆) fibonacci heap(斐波那契堆) 算法 heapsort(堆排序) merge(合并) 图 # 概念 graph vertices(结点) edge(边) # 是结点对偶的集合 endpoint(端点) # 边(u, v)的端点u, v incident(关联) # u, v和边(u, v)关联 尾(tail)头(head) # 边(u, v)离开u进入v, u是尾, v是头 loop(环) # 连接顶点自身的边，只考虑不含圈的图 cycle(圈) # 长至少1的路径 acycle(无圈的) DAG(无圈图) adjacent(邻接) # (i, j)则i, j邻接 directed(图是有向的) # 对偶\u0026lt;i, j\u0026gt;与对偶\u0026lt;j, i\u0026gt;不同 digraph(有向图) undirected(无向的) # 边表示为(i, j) network(网络) # 边上有成本的图 weighted graph(加权图) # weighted digraph(加权有向图)相同 weight(权重) cost(成本) 度 # 点的邻接点的数目 出度 # 有向图中，用该点作为第一个成分的边数目 path(路) # 结点序列 cycle(环、回路) # 首尾相同的简单路 acyclicity(无环性) connected(连通的) # 每一对结点间存在一条路 connectivity(连通性) connected component(连通分量) # 非连通图中包含的连通部分 underlying graph(基础图) # 有向图去掉方向 strongly connected(强连通的) # 有向图中, 一对结点都存在互相连通的路，则两点强连能 weakly connected(弱连通的) # 有向图的基础图是连通的 strongly connected graph(强连通图) # 所有结点对强连通 strongly connected components(强连通分量) # 极大强连通子图 length(路的长度) # 路的边数 simple path(简单路) # 除首尾结点外，所有结点不同的路 directed path(有向路经) complete(完全的) # 任意两个顶点之间都有边相连，表示为K|V| dense(稠密) # 缺少边较少 connected(连通的) biconnected(双连通的) # 不存在割点(articulation point) 表示 V = {a, b, c, d, e, f}, E = {(a, c), (a, d), (b, c), (b, f), (c, e), (d, e), (e, f)} |E| # 边的数量 |V| # 顶点的数量 adjacency matrix(邻接矩阵) # 图的顺序表示法 无向图的邻接矩阵总是对称的 稠密图，邻接矩阵占空间小 weight matrix(权重矩阵)、cost matrix(成本矩阵) adjacency list(邻接表) # 图的链接表示法 稀疏图，邻接表占空间小 公式 0 \u0026lt;= |E| \u0026lt;= |V|(|V| - 1) / 2 # 无圈无向图，可能包含边的数量 算法 critical path analysis(关键路径分析法) 应用 activity-node graph(动作节点图) event-node graph(事件节点图) slack time(松弛时间) critical path(关键路径) "},{"id":71,"href":"/docs/basic/algorithm/math/","title":"数学","section":"算法","content":" 指数 # X^A * X^B = X^(A + B) X^A / X^B = X^(A - B) (X^A)^B = X^(A * B) X^N + X^N = 2X^N \u0026lt;\u0026gt; X^(2N) 2^N + 2^N = 2^(N + 1) 对数 # 约定 计算机科学中, log默认为log(2) X^A = B, log(X)(B) = A log(A)(B) = log(C)(B)/log(C)(A) logAB = logA + logB 级数 # ∑(i=0)(N)2^i = 2^(N + 1) - 1 ∑(i=0)(N)A^i = (A^(N + 1) - 1) / (A - 1) 如果0 \u0026lt; A \u0026lt; 1, 则 \u0026lt;= 1 / (1 - A) ∑(i=1)(∞)i/2^i = 2 ∑(i=1)(N)i = N(N + 1) / 2 ≈ N^2 / 2 ∑(i=1)(N)i^2 = N(N + 1)(2N + 1) / 6 ≈ N^3 / 3 ∑(i=1)(N)i^k ≈ N^(k + 1) / |k + 1| k \u0026lt;\u0026gt; -1 k = -1时, Hn = ∑(i=1)(N)1 / i ≈ log(e)(N), Hn是调和级数 该近似式误差趋向于 λ ≈ 0.57721566, 称为欧拉常数(Euler's constant) 模 # 如果N整除A - B, 则称A与B模N同余, 记为A≡B(mod N) 81≡61≡1(mod 10) 如果A≡B(mod N), 则A + C ≡ B + C(mod N)，则AD≡BD(mod N) 证明方法 # 归纳法 基准情形(base case) 归纳假设(inductive hypothesis), k成立 证明k + 1成立 反证法 无理数 # 圆周率π，黄金分割比ψ，重力加速度g，和自然对数的底e # e约等于2.718281828 # e表示基础增长率为1时连续增长的实际增长率 ## 连续增长是自然界最广泛、增长最快的一种 ## ，所以e也表示自然增长速度, 也是增长的极限速度 e=lim(x→∞)(1+1/x)^x 例子 单细胞24小时分裂一次，x天产生2^x个细胞 加条件, 一天中新生细胞产生到一半(12小时)的时候自身可以分裂 一天产生2.25个细胞, 1个原有，1个新生, 0.25个是新生细胞分裂的 改条件，每8小时细胞具有分裂能力 一天可得到2.37个细胞 改条件，新生细胞每个细微时间都有分裂能力，一天最多可以产生的细胞 一天可得到e个细胞 例子2 e或e经过一定变换得到\u0026quot;自然律\u0026quot; 例子3 螺线φkρ=αe。其中，α和k为常数，φ是极角，ρ是极径，e是自然对数的底 pi = 3. 14159 26535 89793 23846 26433 83279 50288 41971 69399 37510 58209 74944 59230 78164 06286 20899 86280 34825 34211 70679 82148 08651 32823 06647 09384 46095 50582 23172 53594 08128 48111 74502 84102 70193 85211 05559 64462 29489 54930 38196 44288 10975 66593 34461 28475 64823 37867 83165 27120 19091 45648 56692 34603 48610 45432 66482 13393 60726 02491 41273 72458 70066 06315 58817 48815 20920 96282 92540 91715 36436 78925 90360 01133 05305 48820 46652 13841 46951 94151 16094 33057 27036 57595 91953 09218 61173 81932 61179 31051 18548 07446 23799 62749 56735 18857 52724 89122 79381 83011 94912 98336 73362 44065 66430 86021 39494 63952 24737 19070 21798 60943 70277 05392 17176 29317 67523 组合数学 # 原理 鸽巢原理、ramsey定理 概率 加法原理、乘法原理 排列组合、多重集排列组合 组合恒等式 容斥原理 多重集r-组合数 mobius反演 集合 集合分划 stirling数 生成函数 组合数 指数型 catalan数列与stirling数列 分拆数 递推关系 群 置换群 burnside引理 共轭类 不动置换类 等价类 polya定理 问题 幻方 拉丁方 涂色 非降路径 正整数分拆 无序分拆 ferrers图 分配 错位排列 棋盘多项式与有禁区的排列 离散数学 # 集合 c(0)(n) + c(1)(n) + ... + c(n)(n) = 2^n # 幂集 关系r 子关系 逆 自反 对称、反对称 传递 乘积(合成) 自反闭包 等价 部分序 映射 原像、映像 满射、单射 基数(浓度) 逻辑 联结词 ∨, ∧, ￢, ←, →, ↔ =, =\u0026gt; # 等价，蕴涵 原子、公式、解释 范式 析取范式 合取范式 前束范式、skolem范式 谓词 ∀, ∃ 谓词演算 图 权图 dijkstra算法 树 最优树 kruskal、t* 有向图 euler路、euler图 无向图 hamilton路 平面图 kuratowski判定 同胚 平面图的euler公式 plato体 着色 匹配 二部图 增广路 最大匹配 konig无限性引理 王浩定理 计算机表示 邻接矩阵 关联矩阵 弧表表示 邻接表表示 星形表示 单源最短路径 dijkstra bellman - ford 最大流问题 增广路定理 ford - fulkerson 最大容量增广路算法 dinic、dinic改进 最短增广路算法 一般的预流推进算法 最高标号预流推进算法 数论 辗转相除 质数 合同 剩余类 一次同余式 秦九韶定理 euler函数 一元高次同余式 二次剩余 legendre符号 euler判别法 二次剩余互反律 应用 加密 群 性质 封闭性 # 运算结果还在群中 结合律 # (a·b)·c = a·(b·c) 单位元(幺元) # e·a = a·e = a 逆元 # a·b = b·a = e 代数系统 半群 封闭性 结合律 幺半群 封闭性 结合律 幺元 置换群 轮换表 奇偶性 子群 循环群 右陪集 正规子群 lagrange定理 同态映射 同构映射 核 环 整数环、矩阵环、多项式环 消去环、交换环 整区 域 子环 理想 平凡理想 单纯环 极大理想 合同关系 环同态、同构 应用 计数问题 轨道 代表元素 burnside引理 纠错码 域 素域 多项式 根 有理域多项式 eisenstein定则 分圆多项式 有限域 格 x, ⊕ 对偶原理 对偶表达式 同态、同构 几个分类 有界格 有余格 分配格 模格 布尔代数 有余分配格 stone定理 化简 quine karnaugh图 语言 语法 # 任何3型语法都是2型语法...都是1型语法...都是0型语法 g = (v, t, s, p) # v 字母表, t是v的一个终止符子集, s是v的一个元素初始符，p是产生式集合 0型语法 # 没有任何限制 1型语法 # 产生式如 w1 -\u0026gt; w2, w2长度大于等于w1, 或者 w1 -\u0026gt; λ # 可以写 lw1r -\u0026gt; lw2r , 所以上下文有关 2型语法 # w1 -\u0026gt; w2, w1是单个非终止符 3型语法 # w1 -\u0026gt; w2, w1 = a 并且w2 = ab 或者w2 = a, 其中a, b为非终止符, a是终止符，也可以是λ # 正则语法 演绎树 有输出的fsm mealy机 moore 没有输出的fsm kleeme闭包 终止状态 非确定fsm 转换确定fsm 语言识别 可识别集合(stephen kleene) 正则表达式 kleene定理 其它fsm pushdown自动机 识别到上下文无关语法 线性有界自动机 识别到上下文有关语法 turing机 识别所有语法结构产生的语言，可实现任何算法 随机数学 # 概率 古典概型 几何概型 条件概率 全概率公式 bayes公式 bernoulli概型 随机变量 离散 连续 分布函数 概率密度 分布 (0 - 1)分布 二项分布 poisson分布 几何分布 均匀分布 指数分布 正态分布 二维 联合概率密度 边缘概率分布 边缘概率密度 二维正态分布 条件分布 卷积公式 n维 数字特征 期望、方差 cauchy - schwarz不等式 标准化随机变量 协方差 矩 k阶原点矩 k阶中心矩 k + l 阶混合原点矩 k + l 阶混合中心矩 协方差矩阵 n维正态分布　大数 chebyshev不等式 chebyshev定理 bernoulli定理 中心极限定理(levy - lindberg定理) de moivre - laplace 极限定理 liapunov 定理 样本 样本分布函数 伽玛函数 χ2分布 t 分布 f 分布 参数估计 矩估计 最大似然估计 评选标准 无偏性 有效性 一致性 区间估计 置信下限、置信上限 正态总体参数的区间估计 两个正态区间估计 u估计 t估计 f估计 假设检验 显性检验 参数检验 正态总体参数 u检验 t检验 χ2检验 f检验 ... 分布拟合检验 回归分析 一元线性回归 最小二乘 可线性化的回归方程 双曲线 幂函数 指数函数 倒指数 对数 s型曲线 1 / (a + b * e ^ -x) 多元线性回归模型 方差分析 单因素 双因素 交互作用双因素 正交试验 "},{"id":72,"href":"/docs/architect/manage/","title":"Manage","section":"架构","content":" 合作办法 # 苏格拉底法 不推动不会发生 执行力差的5大原因 # 不知道干什么？-\u0026gt; 目标明确 不知道怎么干？ -\u0026gt; 培训到位 干起来不顺畅 -\u0026gt; 流程合理 干好了怎么样？ -\u0026gt; 激励公平 干不好又如何？ -\u0026gt; 考核有效 性格测试 # MBTI 九型人格 "},{"id":73,"href":"/docs/architect/method/","title":"Method","section":"架构","content":" TOGAF # 介绍 The Open Group Architecture Framework 属于EAF(企业架构框架)的一种 目标 统一语言 免费，避免被绑架到各个专有解决方案 全局思考，更有效利用资源 提高ROI 架构域 业务架构 战略、组织 关键流程 治理和标准 应用程序体系结构 部署蓝图: 系统间交互、基本业务流程关系 数据架构 数据资产结构 相关管理资源 技术架构 硬件、软件、网络架构 架构开发模型(ADM) 定制开发实际企业架构，可反复重用 企业连续 对架构跟踪 约定 # 巴科斯范式 # \u0026quot;word\u0026quot; 表示字符本身 double_quote 表示\u0026quot;本身 \u0026quot;\u0026quot; 外表示语法字符 \u0026lt;\u0026gt; 表示必选项 [] 表示可选项 {} 表示可重复0到多次 | 表示or ::= 表示“被定义为” "},{"id":74,"href":"/docs/architect/strategy/block_chain/","title":"Block Chain","section":"战略性技术","content":" 历史 # 1.0: 2008年中本聪 组成: 数字货币、分布式账本、块链式数据、梅克尔树、工作量证明 产业: 挖矿、交易所、钱包 2.0: 2015年“世界计算机”Etereum上线 组成: 智能合约(图灵完备)、虚拟机、去中心化、分布式应用 3.0: 大规模商业应用，区块链+ 4.0: 行业基础设施，生态体系 组成 # 区块链: 分布式基础架构、计算方式 按照时间顺序,数据区块顺序相连链式存储 存储、验证 时间戳 密码学方式保证 不可篡改不可伪造 数据传输和访问安全 分布式节点(分布式账本) 共识算法：生成、更新数据 分布式存储 自动化脚本组成智能合约 编程、操作数据 链类型 # 类型 联盟链: 数个机构有写权限 私有链: 写权限在中心化组织内部 公有链: 无需验证身份 发行方 # 比特币 以太坊 EOS Hyper Ledger 技术 # 核心 分布式计算 加密 环签名 服务层 共识 PoW(工作量证明) PoS(权益证明) DPoS(股份授权证明) PAXOS(分布式事务一致性协议)、PBFT(拜占庭容错算法) 智能合约: 基于预定义事件触发、不可篡改、自动执行 高效引擎 合约算法库 预言机 协议层 SHA256哈希算法 ECDSA签名算法 交易不匿名 数据结构 链式DAG P2P网络层 跨链技术 分片技术 应用特点 # 技术业务特点 链 哈希加密、非对称加密 时间戳 P2P网络传输 共识算法、拜占庭容错 分布式存储 去中心化: 无中心化硬件、管理机构、节点权利和义务均等 加密交易 交易隐私保护 开放性: 除交易和私有信息被加密，数据对所有人公开 Token通证 自治性: 基于协商一致规范和协议，对人的信任改成对机器的信任 去除信任 信息不可篡改: 除非控制51%的节点 可溯源 匿名性: 节点之交换遵循固定算法，数据交换无需信任，所以无须公开身份 隐私性 安全性 应用业务特点 数据共享 补充了互联网不安全的短板 公平 透明化 唯一性 确权性 应用 # 互联网基础数据 多标识网络体系 掌控域名生成/管理 多模态标识解析体系，去IP 网络安全 工业物联网设备安全 身份认证与信任基础设施 数据完整性保护 多信任源安全基础设施 跨域协同信任服务 分布式PKI 可信DNS等网络基础设施 网络安全数据可信 数据安全共享 网络安全威胁情报共享 网络行为追踪溯源 网络防御协同激励 DDoS协同防御 众包漏洞挖掘 网络安全态势感知 网络安全态势可信感知 态势数据融合与统一呈现 隐藏通信 特点 交易量大、隐蔽性好 非定向发送、不经意接收 数据多副本、可溯源 金融：省去第三方中介, 可编程金融 支付、数字货币 股权、私募、信贷、风险 钢材贸易担保、生物资产监管、农业联盟链 供应链金融 融资、监管、信息共享 资方与平台直连 财务结算 金融大数据: 企业征信、智能风控引擎、知识产权评估、实控人征信、生产经营数据、履约表现 银行链 融资：云链云信平台，资方平台直连 共享经济 租车、租房、知识技能 量化交易 商品溯源 供应链 物流 数据市场融通 分布式云存储UGC 供应商画像，应收款凭证，合同履约，预测分析 处方流转 电子印章 IP授权 跨境贸易直通车、国际快件 零售批发小店 算力供应 隐私保护 账本隔离: 分片、多通道 私有数据: 同一通道隐私数据在小部分组织间共享 数据加密授权访问：加密给指定人，同一通道内其他成员不能访问 监管科技，以链治链 建设工程项目管理: 进度，质量，安监，申报，数据，信用 场景式存证，资金透明 资金监管 安全生产 保险结算、审核支撑 广告监播 公共服务领域：去中心化改造 认证、公证：不可篡改 数字版权 专利、著作权、商标保护、软件、游戏、音频、视频、书籍许可证、艺术品证明 保险：去人力运营批准，自动触发理赔 公益慈善 疫情：结果证明材料上链存证 数字医疗链 电子病历、健康管理 隐私保护 教育链 数据确权、安全存证、溯源审计 档案管理、学生征信、学历证明、成就证明、产学合作 电子商务 电子签约 司法 电子证据溯源 电力链 供应链、产业链上下游打通 产融协同 资源共享 营销 积分卡券 农业 农业产权交易 房地产 上市、交易、产权登记 通信 消息系统 社会管理 代理投票、身份认证、档案管理、公证、遗产继承、个人社会信用、工商管理 文化娱乐 视频版权、音乐版权、软件防伪、数字内容确权、软件传播溯源 物联网 物品溯源、物品防伪、物品认证、网络安全、网络效率、网络可靠性 趋势 # 链融合 隐私保护计算 # Privacy-Preserving Computing 目标 数据聚合时，增强对数据的保护，降低数据泄露风险 数据最小化，可用不可见 方法 多方安全计算 联邦学习 "},{"id":75,"href":"/docs/architect/strategy/datalake/","title":"Datalake","section":"战略性技术","content":" 愿景 # 统一 批流一体 数据难点 # SQL脚本拼凑，没有可视化工具 技术要求高，大量重复开发工作 数据稽核难: 勾稽关系不可见，数据校核不可见 数据运维困难：可读性差，难以调整，扩展困难 湖仓一体计划 # 思路 分治 计算向数据移动 本地取数据\t数据仓库计划 # 采集 -\u0026gt; kafka -\u0026gt; ETL -\u0026gt; kafka -\u0026gt; 存储 -\u0026gt; OLAP 采集工具 # 业务数据 ODS原始数据快照 日志 动态数据：用户推荐数据，用户行为 第三方数据：用户征信、广告投放数据、企业信息 技术 RPC同步 ETL拉取 日志采集 爬虫 实时 trigger、日志 canel 准实时 日志 非实时 任务调度 quartz, xxl-job, 大数据 技术 Flume 日志采集 Sqoop 数据库ETL etl, sql-to-Hadoop, MapReduce程序, 支持Hive, HDFS OoZie 任务调度 Azkaban 任务调度 存储工具 # HDFS HBase Hive 数据仓库 封装的HDFS和MapReduce ClickHouse 运维工具 # Ambari 安装、部署、配置和管理 Flume cloudera开源, 日志收集 Ganglia 分布式监控系统，php页面 HUE web管理Hadoop 处理工具 # 离线计算(批处理) # MapReduce 每个task启动一个jvm Pig 数据流处理语言，类SQL, 脚本转换为MapReduce任务 Mahout 数据挖掘, 机器学 Tez 用DAG(有向无环图)组织多个MR任务 流式计算 # Impala # cloudrea开源,实时视图计算框架, 分布式查询引擎。直接从HDFS或Hbase中用select, join, 支持事务, 需要kafka S4 # 分布式流计算，允许请求丢失 Storm 只能流式计算 Spark Flink Kafka Stream 数据管理工具 # 分类 资产大屏 元数据管理 任务管理：管理、编排、调度、监测 数据质量、数据治理 Yarn 介绍 Yet Another Resource Negotiator, 任务管理, 调度算力资源, 在HDFS上运行计算框架(如MapReduce, Storm, Spark) 组成 ResourceManager(RM) 处理请求 监控NodeManager 启动、监控ApplicationMaster 资源分配调度 常驻 NodeManager(NM) 常驻 ApplicationMaster(AM) 数据切分 为应用程序申请资源再分配给内部任务 任务监控、容错 非常驻，job拉起 Container 运行APP 某节点上多维度的资源 由NodeManager调度 非常驻 Mesos Tachyon 分布式缓存 分析展示工具 # Mllib machine learning library, Spark机器学习库 Giraph 大规模图分布式计算 GraphX Spark分布式图处理框架 Superset Metabase Redash BIRT Kylin Davinci DBus-allinone HAWQ # Hadoop原生sql查询引擎 phoenix # OLTP, 支持Hbase和HDFS, jdbc, 更快sql查询 Shark # sql on Spark, 并行job处理比MapReduce快100倍 Presto # 分布式sql查询, facebook开源, 称比Hive快10倍 Drill # Apache, Dremel的开源版本, 对多数据库生成query plan Dremel 介绍 google的交互式数据分析系统，构建于gfs上 特点 嵌套型数据的列存储, 多层查询 减少查询的处理数据量 Kylin # OLAP, Apache, 支持Cube类查询 Doris GridGain 网格计算框架，提供平行计算能力 数仓建模 # 分层 ODS层(数据源): 多源接入 业务库，集团数据，流量日志，三方数据 IDL层(数据集成): 屏蔽底层影响，还原业务，统一标准 CDL层(数据组件): 指标口径统一，重复计算 MDL层(数据集市): 数据分析查询，数据应用支持 ADL层(数据应用): 多维数据分析 工具 基础层工具: 元数据中心维护业务过程，表关联关系、实体对象、识别分析对象、数据组件 自助查询工具: 逻辑宽表、生成查询语句、查询情况反馈建模 应用层工具: 拼接小模型 "},{"id":76,"href":"/docs/architect/strategy/datalake/ecology/","title":"Ecology","section":"Datalake","content":" Hadoop体系 # 发行版 Apache Hadoop CDH(Cloudera's Distribution Including Apache Hadoop) HDP(Hortonworks Data Platform) 宜信 D.Bus # 数据收集与计算 UAVStack # AIOps, 智能运维 UAV.Monitor # 监控 UAV.APM # 性能管理 UAV.ServiceGovern # 服务治理 UAV.MSCP # 微服务计算 Wormhole # SPaaS(Stream Processing as a Service) Gartner # ITOA，算法即运维 大数据 PB级数据 4V volume(大量) velocity(高速) variety(多样) value(低价值密度) 场景 物流仓储: 精细化运营，命中率 推荐 保险: 风险预测 金融: 用户特征 房产: 精准投策、营销 AI 组织部门 平台: 集群 Hadoop、Flume、Kafka、HBase、Spark等搭建 性能监控、调优 数据仓库: 写SQL ETL, 数据清洗 Hive, 数据分析、建模 数据挖掘 数据支持 算法、推荐、用户画像 报表 JavaEE hadoop Apache开源, 分布式系统基础架构 面临问题 硬盘 1块: 10TB-14TB 1PB: 102块硬盘 算 MySQL5.5: 300w-500w MySQL8: 1亿、1GB Doug Cutting GFS -\u0026gt; HDFS 存储 Map-Reduce -\u0026gt; MapReduce 计算 BigTable -\u0026gt; HBase 表式存储 发展 2003-2004: Google公开部分GFS和MapReduce 2005: Hadoop成为Apache Lucene子项目Nutch了一部分 2006.3: MapReduce和NDFS(Nutch Distributed File System)纳入Hadoop 发行版本 Apache: 开源 Cloudera: Doug Cutting, 一键部署, 资源占用大 Hortonworks: 雅虎工程师，贡献Hadoop 80%代码, 一键部署 阿里云 特点 高可靠性：多副本 高扩展性 高效性: 并行运行 高容错性 组成 Hadoop1.x HDFS(存), MapReduce(算、资源调度), Common Hadoop2.x HDFS(存), MapReduce(算), Yarn(资源调度), Common Hadoop3.x HDFS # # Hadoop Distributed File System, 一开始为Nutch搜索引擎开发 存储模型 按字节切割,block存储,block多副本 不支持修改(因为修改文件而非block, 且会引发规模修改)，可以追加 主从架构 NameNode 树形目录 内存存储元数据，可持久化(EditLog事务日志, FsImage) NameNode启动时安全模式 SecondaryNameNode合并EditLog到新FsImage DataNode上报block列表 存副本策略 DataNode 本地文件形式存block, 存校验 与NameNode心跳，汇报block列表 Client 交互元数据和block API结构 推荐节点数不过5000 角色：一个进程 Block副本放置策略 Pipeline HA JournalNode NameNode同步EditLog FailoverController 利用ZooKeeper 同主机下监控NameNode 验证对方主机主NN是否真的挂掉，调用对方降级为Standby 问题及方案 单点故障 多NameNode，主备(2.x只能1主1备, 3.x可以1主5备) 压力大，内存受限 联帮: Federation(元数据分片) 配置网络 /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network NETWORKING=YES HOSTNAME=node01 /etc/hosts /etc/selinux/config SELINUX=disabled /etc/ntp.conf server htp1.aliyun.com /etc/profile export JAVA_HOME=/usr/java/default export PATH=$PATH:$JAVA_HOME/bin service iptables stop \u0026amp; chkconfig iptables off service ntp start \u0026amp; chkconfig ntp on 配ssh免密登录 部署配置 mkdir /opt/bigdata /etc/profile export HADOOP_HOME=/opt/bigdata/hadoop-2.6.5 export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin /etc/hadoop hadoop-env.sh export JAVA_HOME=/usr/java/default core-site.xml \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://node01:9000\u0026lt;/value\u0026gt; hdfs-site.xml \u0026lt;name\u0026gt;fs.replication\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.name.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/var/bigdata/hadoop/local/dfs/name\u0026lt;/value\u0026gt; # namenode元数据 \u0026lt;name\u0026gt;dfs.datanode.data.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/var/bigdata/hadoop/local/dfs/data\u0026lt;/value\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.secondary.http-address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;node01:50090\u0026lt;/value\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.checkpoint.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/var/bigdata/hadoop/local/dfs/secondary\u0026lt;/value\u0026gt; slaves node1 命令 hdfs namenode -format start-dfs.sh 访问页面 node01:50070 node01:50090 hdfs dfs -mkdir -p /user/root hdfs dfs -D dfs.blocksize=1048576 -put a.txt /user/root 使用 # 软件结构 0 jdk, Hadoop NameNode, DFSZKFailoverController 1 jdk, Hadoop NameNode, DFSZKFailoverController 2 jdk, Hadoop ResourceManager 3 jdk, Hadoop, Zookeeper DataNode, NodeManager, JournalNode, QuorumPeerMain 4 jdk, Hadoop, Zookeeper DataNode, NodeManager, JournalNode, QuorumPeerMain 5 jdk, Hadoop, Zookeeper DataNode, NodeManager, JournalNode, QuorumPeerMain Zookeeper 配置conf/zoo.cfg tickTime=2000 # 心跳间隔(ms) initLimit=10 # 初始化时最多容忍心跳次数 syncLimit=5 # 同步失败最多容忍心跳次数 dataDir=/usr/local/Zookeeper/data # 运行时文件目录 clientPort=2181 # 运行端口号 server.1=主机名或ip:2888:3888 # 服务运行端口与选举端口 server.2=主机名或ip:2888:3888 server.3=主机名或ip:2888:3888 命令 ./bin/zkServer.sh start ./bin/zkServer.sh status jps # 显示名为QuorumPeerMain Hadoop Hadoop-env.sh export JAVA_HOME= core-site.xml \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HDFS://ns1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;Hadoop.tmp.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/usr/local/Hadoop-2.2.0/tmp\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;ha.Zookeeper.quorum\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;192.168.56.13:2181, 192.168.56.14:2181, 192.168.56.15:2181\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; HDFS-site.xml \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.nameservices\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;ns1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.namenodes.ns1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;nn1,nn2\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.rpc-address.ns1.nn1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;192.168.56.10:9000\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.http-address.ns1.nn1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;192.168.56.10:50070\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.rpc-address.ns1.nn2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;192.168.56.11:9000\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.http-address.ns1.nn2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;192.168.56.11:50070\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.shared.edits.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;qjournal://192.168.56.13:8485;192.168.56.14:8485;192.168.56.15:8485\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.journalnode.edits.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/usr/local/Hadoop-2.2.0/journal\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.automatic-failover.enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.client.failover.proxy.provider.ns1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.Apache.Hadoop.HDFS.server.namenode.ha.ConfiguredFailoverProxyProvider\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.fencing.methods\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;sshfence\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.fencing.ssh.private-key-files\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/root/.ssh/id_rsa\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; mapred-site.xml \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;Yarn\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; Yarn-site.xml \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;Yarn.resourcemanager.hostname\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;192.168.56.12\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;Yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; etc/Hadoop/slaves 192.168.56.13 192.168.56.14 192.168.56.15 收尾 ssh免登录(0到1,2,3,4,5) ssh-keygen -t rsa ssh-copy-id -i 192.168.56.11 # 这样就可以免登录访问192.168.56.11了 ## ssh-copy-id -i localhost 免登录自己 复制Hadoop2.2.0(从0到1,2,3,4,5) 添加Hadoop_home到环境变量 etc/profile export HADOOP_HOME=/usr/local/Hadoop-2.2.0 export PATH=$PATH:$HADOOP_HOME/bin 启动 0 上启动 ./sbin/Hadoop-daemons.sh start journalnode 0 上格式化namenode Hadoop namenode -format HBase # 介绍 Hadoop Database, 实时分布式, bigtable列簇数据库, 非结构化，自动切分, 并发读写 只能row key查询, master有单点问题 版本 0.98 1.x 2.x 原理 修改只追加记录，合并时删除 架构 Client 提供接口，维护客户端缓存 Zookeeper 只有一个活跃master 存Region寻址入口 实时监控region server在线信息，通知master 存schema、table元数据 Master 为region server分配region\tregion server负载均衡 失效region server重新分配region 管理table CRUD RegionServer 维护region 切分大region Region 表水平分region分配在多个region server, region增大时裂变 HLog 写Store之前先写HLog, flush到HDFS, store写完后HDFS存储移到old，2天后删除\tStore region由多个store组成, 一个store对应一个CF store先写入memstore, 到阈值后启动flashcache写入storefile storefile增长到阈值，进行合并 minor compaction major compaction，默认最多256M region所有storefile达到阈值，region分割 Spark # 介绍 in memory, 准实时的批处理，生态好于Storm 无事务 集群 Master Worker Driver Executor\t组件 Spark RDD(Resiliennt Distributed Datasets) Spark Core 批计算，取代MR 粗粒度资源申请，task自行分配启动快，executor不kill 内存计算 chain Spark Streamming 流计算，取代Storm 批计算无限缩小，实时性差 默认无状态 用updateStateByKey保存上次计算结果，变成有状态 借助Redis或ES存 Spark SQL 数据处理 Spark MlLib 机器学习 Spark R 数据分析 使用 val session = SparkSessionBase.createSparkSession() var sc = session.sparkContext var rdd = sc.makeRDD(List(1,2,3,4,5,6)) val mapRDD = rdd.map(x -\u0026gt; { x }) val filterRDD = mapRDD.filter(x =\u0026gt; { true }) filterRDD.count 独立体系 # Flink # 特点 高吞吐、低延迟、高性能 支持事件时间(Event Time) 擅长有状态的计算\t内存 磁盘 RocksDB 灵活的窗口（Window）操作： time, count, session 基于轻量级分布式快照（CheckPoint）实现容错，保证exactly-once 基于JVM实现独立内存管理 Save Points方便代码升级 批计算是流计算的特例 unbound streams\t# 定义开始不定义结束，流计算 bounded streams\t# 定义开始也定义结束，批计算 迟到数据问题 温度窗口 水位线(Watermark) 集群 JobManager(JVM进程) TaskManager(JVM进程) Task Slot\t一组固定的资源，隔离内存，不隔离核 一般与核数对应，核支持超线程时一个算两个 配置 /etc /flink-conf.yaml /slaves /masters 组件 部署 Single JVM\t# 多线程模拟 Standalone YARN\t库 CEP\t# 复杂事件库 Table FlinkML Gelly 使用 import org.apache.flink.streaming.api.scala._ val env = StreamExecutionEnvironment.getExecutionEnvironment val initStream:DataStream[String] = env.socketTextStream(\u0026quot;node01\u0026quot;, 8888) val wordStream = initStream.flatMap(_.split(\u0026quot; \u0026quot;)) val pairStream = wordStream.map((_, 1)) val keyByStream = pairStream.keyBy(0) val restStream = keyByStream.sum(1) restStream.print() env.execute(\u0026quot;job1\u0026quot;) "},{"id":77,"href":"/docs/architect/strategy/edge/","title":"Edge","section":"战略性技术","content":" 应用 # 监控行为计算 "},{"id":78,"href":"/docs/architect/strategy/iot/framework/","title":"Framework","section":"IoT","content":" ThingsBoard # # java, 社区版、企业版 文档 github.com/thingsboard/thingsboard thingsboard.io/docs localhost:8080/swagger-ui.html # 本地swagger 安装 docker docker run -it -p 9090:9090 -p 1883:1883 -p 5683:5683/udp -v ~/.mytb-data:/data -v ~/.mytb-logs:/var/log/thingsboard --name mytb thingsboard/tb-postgres maven 确定ui/pom.xml中\u0026lt;nodeVersion\u0026gt; mvn install -DskipTests 配置 application zk ZOOKEEPER_ENABLED ZOOKEEPER_URL cassandra CASSANDRA_URL CASSANDRA_USERNAME CASSANDRA_PASSWORD redis REDIS_HOST REDIS_PORT REDIS_DB REDIS_PASSWORD postgresql SPRING_DATASOURCE_URL SPRING_DATASOURCE_USERNAME SPRING_DATASOURCE_PASSWORD kafka TB_KAFKA_SERVERS 运行 application server transport http demo数据 admin sysadmin@thingsboard.org sysadmin tenant tenant@thingsboard.org tenant customer customer@thingsboard.org或customerA@thingsboard.org customer customerB@thingsboard.org customer customerC@thingsboard.org customer device A1, A2, A3 A1_TEST_TOKEN,... customerA B1 B1_TEST_TOKEN customerB C1 C1_TEST_TOKEN customerC 'DHT11 Demo Device' DHT11_DEMO_TOKEN 'Raspberry Pi Demo Device' RASPBERRY_PI_DEMO_TOKEN 包结构 application # 可改, 网关 server install config # 同源策略、swagger、websocket、消息、安全 exception controller # 页面调用 service actors service DefaultActorService actorContext actorService(this) actorSystem appActor statsActor rpcManagerActor common # 不可改, 功能代理 data # 数据结构 message # 消息类型 transport # 客户端调用 dao # 可改, 业务, 适配db model # 数据库对象 resources sql # 表结构 netty-mqtt # 不可改, 数据通信协议 rule-engine # 不可改, 规则引擎 transport # 不可改, 设备端运行 http # 启动http传输协议 coap mqtt tools # 可改, 工具 ui # 可改, 页面, angular, react, webpack docker # 不可改, 打包 msa # 不可改，分布式 black-box-tests # 黑盒测试 js-executor # 执行js log img 模块 application common data # 数据结构 message # 消息结构 transport # 接口结构，适配客户端 dao # 交互data, 兼容不同db tools extensions kafka mqtt rabbitmq rest-api-call extensions-api action filter plugin processor extensions-core # 实现公用extensions-api transport http # rest coap # californium mqtt # netty 规则引擎 # 基于actors执行 filters processors action ui # node.js + yarn 表结构 tenant customer # 关联tenant tb_user # user信息、角色 user_credentials # user密码 admin_settings # admin信息, key value形式 audit_log # 登录日志 asset entity_view attribute_kv # entity attribute component_descriptor # node类 device # 设备, label device_credentials # 设备ACCESS_TOKEN ts_kv # 设备事件 ts_kv_latest # 设备当前状态 rule_chain # rule root chain rule_node # rule节点 relation # rule关系 event # rule事件 alarm # alarm事件 dashboard # dashboard设置 widget_type # widget, 别名 widgets_bundle api host:port/api/v1/$ACCESS_TOKEN/ telementry # 上传遥测数据 post {\u0026quot;key1\u0026quot;:\u0026quot;value1\u0026quot;} post [{\u0026quot;key1\u0026quot;:\u0026quot;value1\u0026quot;}] post {\u0026quot;ts\u0026quot;:1451649600512, \u0026quot;values\u0026quot;:{\u0026quot;key1\u0026quot;:\u0026quot;value1\u0026quot;}} attributes post {\u0026quot;attribute1\u0026quot;:\u0026quot;value1\u0026quot;} # 更新属性 get # 请求属性 attributes/updates get ?timeout=20000 # 订阅属性 rpc get ?timeout=20000 # 要求订阅，返回id, method, params post {\u0026quot;method\u0026quot;: \u0026quot;getTime\u0026quot;, \u0026quot;params\u0026quot;:{}} # 执行method rpc/{$id} post claim # 用户认领设备 post 服务架构 产品架构 设备接入: MQTT、CoAP、HTTP 规则引擎 # 处理设备消息 消息(message) 设备传入数据 设备生命周期事件 rest api事件 rpc请求 规则节点(node) # 过滤消息 filter enrichment transformation action external rule chain 规则链 # 连接节点 核心服务 设备认证: token、X.509 规则和插件 多租户(tenant) 客户 资产 设备 部件(widget)仪表盘(dashboard) alarm 实体视图 设备即服务(DaaS) 共享资产、设备 传感器等权限 告警和事件 网关: rest api, websocket actor模型: 用于并发 集群: zookeeper服务发现, 一致性哈希 安全: SSL 第三方 akka zookeeper grpc cassandra system general mail security 功能模块 admin tenant rule chain filter enrichment transformation action *analytics external rule chain *data converters *integrations *roles *customers hierarchy *user groups customers *customer groups assets *asset groups devices *device groups entity views *entity view groups widgets library dashboards *dashboard groups *scheduler report send rpc update attributes *white labeling main server mail templates custom translation custom menu white labeling login white labeling self registration audit logs entities 包含 tenants customers users devices assets alarms dashboards rule node rule chain 操作 detail assigned to customer attributes client server shared telemetry alarms events relations audit logs "},{"id":79,"href":"/docs/basic/computer/performance/","title":"Performance","section":"Computer","content":" 基础 # 性能指标 latency throughput qps = throughput / latency 性能分析 bottle-nect(first-principle) 资源 CPU和GPU 内存 磁盘 网络 能源 逻辑资源 fds(文件描述符) sockets 内核对象: locks inodes(磁盘索引节点) transactions ip addresses ports random numbers(分布式随机数) 容量 2000前 尽量少 200~ 不到机型限制 2017 尽量把机器用满 以后 metrics分离, 单独规划 计算 # cpu gpu 存储 # 类型 时间 描述 L1 cache 0.5ns branch mispredict(分支、转移) 5ns L2 cache 7ns 14x L1 cache Mutex lock/unlock 25ns Main memory 100ns 20x L2 cache, 200x L1 cache 1k字节压缩Zippy 3,000ns = 3us 在1Gbps网络上发送1k字节 10,000ns = 10us SSD随机读4k 150,000ns = 150us 1GB/秒 内存顺序读1MB 250,000ns = 250us 同一数据中心往返 500,000ns = 500us SSD顺序读1MB 1,000,000ns = 1000us = 1ms 1GB/秒, 4x 内存 磁盘搜索 10,000,000ns = 10,000us = 10ms 20x 数据中心往返 磁盘顺序读1MB 20,000,000ns = 20,000us = 20ms 80x 内存, 20x SSD 发包: 美国 -\u0026gt; 荷兰 -\u0026gt; 加拿大 150,000,000ns = 150,000us = 150ms 传输 # 带宽 热门并发1.5倍到2倍购买 方式 HDD SSD ethernet 南桥、北桥芯片 并发 # 并发 jetty 2k-3k nginx 1w lvs 100w f5 + lvs 400w-800w mysql 1k oracle 1.5k-2k tomcat 1k 1并发/10在线用户/100注册用户 1用户/20pv 访问时段 8点 - 23点 最大访问量为平均值1.7倍 每个html页面20k, 40k/css, 50k/js. css与js会缓存 数据库 mongodb 查询 4w++/5s # aurora测 一个进程13M左右 10g内存787多并发(最早的apache) 一个线程2M内存 10g内存5120并发 cpu一级缓存取数据: 3个时钟周期(tick) cpu二级缓存取数据: 14 tick 内存取数据: 250 tick 磁盘取数据: 4100w tick 网络取数据: 24000w tick 负载均衡器 # 并发在100w - 800w 深信服 F5 性能调优 # 影响因素 内因 项目设计、实现 资源加载 配置 外因 网络 流量 架构 服务器配置 步骤 分析用户习性 # 功能路径，热点 内存瓶颈 内部 托管资源 对象分配回收 # session、缓存、对象池等 非托管资源 数据库、文件、线程 外部 进程竞争 cpu瓶颈 cpu密集业务 加密、解密，垃圾回收，解压缩，算术运算，过度编译 缓存分析 浏览器缓存 # 资源文件，过期 代理缓存 # 地域、安全、更新 内核缓存、IIS缓存 数据缓存 资源等待分析 数据库等待 线程锁定 磁盘读写 数据库瓶颈(找数据库笔记) http优化 减小页面 只传必要数据 资源加载 架构 去单点 服务化 优质业务专门机器 广播改订阅 换语言/框架重构 案例 # o-\u0026gt; 小米论坛 pv 2000w 热门并发300 20k/页面 300k/图片(未压缩) 70k/无图帖子 500k-3M/有图帖子 动态服务器最小带宽: 48Mbps 静态服务器最小带宽: 1440Mbps 实际购买带宽: 800M 带宽费用: 8.7w/month o-\u0026gt; 糗事百科 pv 1000w 热门并发150 10k/页面 70k/图 4图/页 90k-400k/综合页 动态服务器带宽: 12Mbps 静态服务器带宽: 336Mbps 工具数据 # nodejs 虚拟机数据 mem: 512m mem: 66.7% cpu: 1% 执行 5秒循环mongo数据: 17w条 状况 程序完全阻塞 并发: 300 qps: 140 8核全满 2-4G 内存 3000万并发 5w socket # 系统最高65535个端口，支持这么多连接 已实现成就 ruby迁移到node.js有10倍的性能提升，特定情况下20倍性能提升 5w并发/min redis 200并发, 每次3ms, 37000次/s mysql 最多3.5w写入/s "},{"id":80,"href":"/docs/cache/ops/","title":"Ops","section":"Cache","content":" java # -Dserver.port=18001 -Deureka.client.serviceUrl.defaultZone=http://localhost:19090/eureka -javaagent:/opt/svc/apache-skywalking-apm-bin/agent/skywalking-agent.jar -Dspring.profiles.active=prod -Dlogging.config=classpath:logback-spring-prod.xml mac os 改mac # sudo /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -z sudo ifconfig \u0026lt;intf\u0026gt; lladdr 00:bb:cc:dd:ee:ff "},{"id":81,"href":"/docs/cache/work_code/","title":"Work Code","section":"Cache","content":" 框架编写 # 命令 # git update-index \u0026ndash;assume-unchanged a mvn clean deploy -P keruyun -pl alsc-item-solution-kryun-dish-client -DskipTests\n阿里云搜索词 # 大屏 # and tag:path: \u0026ldquo;/data/app/jncloud/screen/log/info.log\u0026rdquo; and resourceMap and {7435ca87-1c8c-4c76-bcfd-6f45b9c8b167} 时长请求 # tag:path:/var/log/nginx/access.log and upstream_response_time \u0026gt; 1 | select distinct request_uri , count(request_uri) as \u0026ldquo;count\u0026rdquo;, max(upstream_response_time) as max_time, min(upstream_response_time) as min_time, avg(upstream_response_time) as avg_time from log group by request_uri order by count desc\nIP分布 # tag:path:/var/log/nginx/access.log | select count(1) as c, ip_to_province(remote_addr) as address group by address order by c desc limit 100 tag:path:/var/log/nginx/access.log | select count(1) as c, remote_addr, ip_to_province(remote_addr) as address group by remote_addr order by c desc limit 100\nPV、UV # tag:path:/var/log/nginx/access.log not request_uri: \u0026ldquo;/stub_status\u0026rdquo; | select time_series(time, \u0026lsquo;2m\u0026rsquo;, \u0026lsquo;%H:%i\u0026rsquo;, \u0026lsquo;0\u0026rsquo;) as time, COUNT(1) as pv, approx_distinct(remote_addr) as uv GROUP by time ORDER by time LIMIT 1000\n流量 # tag:path:/var/log/nginx/access.log not request_uri: \u0026ldquo;/stub_status\u0026rdquo; | select sum(body_bytes_sent) / 1024 as net_out, sum(request_length) / 1024 as net_in, date_format(date_trunc(\u0026lsquo;hour\u0026rsquo;, time), \u0026lsquo;%m-%d %H:%i\u0026rsquo;) as time group by date_format(date_trunc(\u0026lsquo;hour\u0026rsquo;, time), \u0026lsquo;%m-%d %H:%i\u0026rsquo;) order by time limit 10000\n地址排名 # tag:path:/var/log/nginx/access.log not request_uri: \u0026ldquo;/stub_status\u0026rdquo; | select split_part(request_uri, \u0026lsquo;?\u0026rsquo;, 1) as path, count(1) as pv group by path order by pv desc limit 10\ntomcat状态 # tag:path:/var/log/nginx/access.log not request_uri: \u0026ldquo;/stub_status\u0026rdquo; | select date_format(date_trunc(\u0026lsquo;minute\u0026rsquo;, time), \u0026lsquo;%H:%i\u0026rsquo;) as time, COUNT(1) as count, status GROUP by time, status ORDER by time LIMIT 1000\nsnip # sql # 海享汇 # 工作量风险点 数据库迁移 融合项目表 系统间调用 IoT通过HTTP注册接口实时调用 服务拆分: 拆分不合理但可用 系统, 公用，空调，多品类 代码 service层业务未分层, 但不复杂 中间件 无跨服务中间件\n"},{"id":82,"href":"/docs/db/elasticsearch/","title":"Elasticsearch","section":"数据库","content":" 介绍 # 分布式实时lucene 使用 # ./bin/elasticsearch curl http://localhost:9200 命令 # elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name 概念存储 # index type # document中加_type field实现 # 所以不同type中的field在index要唯一，否则冲突 # 对field排序会载入所有type的document document # 对应lucene中的key value倒排文档 # 对就一个请求的json对象 field mapping # 定义type的field，映射json到document field 设置 # config/elasticsearch.yml action.auto_create_index: -l*, +z* # 自动创建，以z开头和非l开头的索引 action.destructive_requires_name: true # 允许通配删index http.cors.enables: true http.cors.allow-origin: \u0026quot;*\u0026quot; cluster.name: c1 node.name: n1 node.master: true node.data: true transport.host: localhost transport.tcp.port: 9300 network.host: 0.0.0.0 # 修改es监听地址，别的机器也可以访问。同时设置bind_host和publish_host # 需要设置transport.host:localhost network.bind_host # 节点绑定ip network.publish_host # 发布地址，其它节点通过这个地址通信 http.port: 9200 transport.tcp.port # 通信端口，默认9300 discovery.zen.minimum_master_nodes: 2 o-\u0026gt; 可用配置 cluster.name: myES_Cluster node.name: ESNODE_CYR node.master: true node.data: true transport.host: localhost transport.tcp.port: 9300 http.port: 9200 network.host: 0.0.0.0 discovery.zen.minimum_master_nodes: 2 接口 # index # get/put/delete /index1 # 创建index, get查询，delete删除 settings mappings aliases: put /index1/_mapping/type2 get/put /index1/type2/_mapping # 创建type或给已有type加mappings properties put /index1/_settings get/put /index1/type1/1 # 插入doc name: \u0026quot;name1\u0026quot; _cat # get /_cat/health?v # 集群健康 get /_cat/nodes?v # 集群节点 get /_cat/indices?v # 所有索引 _cluster # get /_cluster/state?pretty # 集群状态 _aliases # post /_aliases # 索引别名 actions: add: alias: \u0026quot;my_index\u0026quot; index: \u0026quot;my_index_v1\u0026quot; remove _template # put /_template/tpl1 template: \u0026quot;te*\u0026quot; # 匹配所有re开头的index settings: mappings: _search # post /index1/type1/_search # from size实时分页 # scroll快照分页 ?from=0\u0026amp;size=50 ?scroll=1m\u0026amp;size=50 # 过期时间1分钟，每次返回50条 ?search_type=scan\u0026amp;scroll=1m # scroll-scan分页不排序，更快, _analyze # post /index1/_analyze text: \u0026quot;刘德华\u0026quot; analyzer: \u0026quot;analyzer1\u0026quot; _close # post /index1/_close # 关闭索引，此后可以改settings _open # post /index1/_open _cache # post /index1/type1/_cache/clear?filter_keys=k1 # 清空query filter的缓存 数据对象 # _search # query match # 理解如何分词的, 会对field分词再查询 field1: query: \u0026quot;a b\u0026quot; operator: \u0026quot;and\u0026quot; minimum_should_match: \u0026quot;75%\u0026quot; # 匹配的query分词的最低占比 match_all # 默认，会查出所有文档 multi_match query: \u0026quot;a b\u0026quot; fields: [\u0026quot;field1\u0026quot;, \u0026quot;field2\u0026quot;] match_phrase # 所有term命中，并且位置邻接 field1: \u0026quot;a b\u0026quot; term # 确切查询 field1: \u0026quot;value1\u0026quot; terms # 多条件and field1: [1,2,3] range field1: gt: 20 gte: lt: lte: exists: field: \u0026quot;field1\u0026quot; missing: field: \u0026quot;field1\u0026quot; regexp postcode: \u0026quot;W[0-9].+\u0026quot; wildcard postcode: \u0026quot;W?F*HW\u0026quot; prefix # 以某些字符开头 field1: \u0026quot;a\u0026quot; bool # 分值计算来自must和should语句, must_not不影响 must match must_not should: [] minimum_should_match: 2 filtered query filter: # filter的field会缓存起来 ## geo, and, or, not, script, numeric_range的默认不缓存 term: field1: \u0026quot;a\u0026quot; _cache_key: \u0026quot;k1\u0026quot; _cache: false range: field1: gte: 0 aggs diy1: avg: field: \u0026quot;field1\u0026quot; diy2: terms: # 聚合查询中的所有term field: \u0026quot;field1\u0026quot; post_filter: # 对搜索结果进行过滤 term: field1: \u0026quot;a\u0026quot; sort: [] # 默认升序，_score默认降序 field1 order: \u0026quot;desc\u0026quot; # asc mode: \u0026quot;min\u0026quot; # 对数组元素排序时的取值, 还有max, sum, avg, median missing: \u0026quot;field1\u0026quot; \u0026quot;_score\u0026quot;, highlight pre_tags: [\u0026quot;\u0026lt;tag1\u0026gt;\u0026quot;] post_tags: [\u0026quot;\u0026lt;/tag1\u0026gt;\u0026quot;] fields: content: {} simple_query_string: query: \u0026quot;\u0026quot; analyzer: fields: [\u0026quot;body^5\u0026quot;, \u0026quot;_all\u0026quot;] default_operator: \u0026quot;and\u0026quot; mappings # type1: dynamic: true # 默认true,自动给未知field建索引 # false: 忽略未知field， strict: 未知field报错 include_in_all: false # 默认不include _all: # meta field enabled: false # 关闭all作用域 analyzer: # 其实是search_analyzer term_vector: no # 对field建立词频向量空间 store: \u0026quot;false\u0026quot; _source: # 是否保存内容 enabled: true properties: field1: type: “text” # text分词，keyword不分词，numeric, date, string # multi_field可定义多个field fields:[] field1: type store: \u0026quot;yes\u0026quot; index: \u0026quot;not_analyzed\u0026quot; # analyzed analyzer: \u0026quot;ik_max_word\u0026quot; search_analyzer: \u0026quot;ik_max_word\u0026quot; # 默认为analyzer include_in_all: \u0026quot;true\u0026quot; # 是否加入_all作用域 boost: 8 aliases # alias1: filter: term: user: \u0026quot;kimchy\u0026quot; routing: \u0026quot;kimchy\u0026quot; settings # # 有些设置不能动态修改 index: number_of_shards: 3 number_of_replicas: 2 max_result_window: 10000 # from + size的上限，默认10000 analysis: tokenizer: # 处理原始输入 tokenizer1 type: \u0026quot;pinyin\u0026quot; pinyin_field1: filter: # tokenizer作为输入 filter1: type: \u0026quot;pinyin\u0026quot; pinyin_field1: analyzer: # 组合tokenizer和filter analyzer1: type: \u0026quot;custom\u0026quot; tokenizer: \u0026quot;ik_smart\u0026quot; filter: [\u0026quot;filter1\u0026quot;, \u0026quot;word_delimiter\u0026quot;] 插件 # 使用 复制到/plugins 场景中，指定type:\u0026quot;xx\u0026quot;使用 ## ik 介绍 elasticsearch-analysis-ik 安装 mvn package unzip -d /elasticsearch/plugins/ik ./target/releases/elasticsearch-analysis-ik-1.8.0.zip 重启elasticsearch 分词器 ik_max_word curl -XGET 'http://localhost:9200/_analyze?pretty\u0026amp;analyzer=ik_max_word' -d '联想是全球最大的笔记本厂商' ik_smart curl -XGET 'http://localhost:9200/_analyze?pretty\u0026amp;analyzer=ik_smart' -d '联想是全球最大的笔记本厂商' mapping type { \u0026quot;properties\u0026quot;: { \u0026quot;content\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;text\u0026quot;, \u0026quot;store\u0026quot;: \u0026quot;no\u0026quot;, \u0026quot;term_vector\u0026quot;: \u0026quot;with_positions_offsets\u0026quot;, \u0026quot;analyzer\u0026quot;: \u0026quot;ik_smart\u0026quot;, \u0026quot;search_analyzer\u0026quot;: \u0026quot;ik_smart\u0026quot;, \u0026quot;include_in_all\u0026quot;: \u0026quot;true\u0026quot;, \u0026quot;boost\u0026quot;: 8 } } } ## pinyin 介绍 elasticsearch-analysis-pinyin o-\u0026gt; \u0026quot;analysis\u0026quot; : { \u0026quot;analyzer\u0026quot; : { \u0026quot;pinyin_analyzer\u0026quot; : { \u0026quot;tokenizer\u0026quot; : \u0026quot;my_pinyin\u0026quot;, \u0026quot;filter\u0026quot; : \u0026quot;word_delimiter\u0026quot; } }, \u0026quot;tokenizer\u0026quot; : { \u0026quot;my_pinyin\u0026quot; : { # 单字 \u0026quot;type\u0026quot; : \u0026quot;pinyin\u0026quot;, \u0026quot;first_letter\u0026quot; : \u0026quot;none\u0026quot;, \u0026quot;padding_char\u0026quot; : \u0026quot; \u0026quot; }, \u0026quot;my_pinyin_fisrt_letter\u0026quot; : { # 首字母, 如北京为bj \u0026quot;type\u0026quot; : \u0026quot;pinyin\u0026quot;, \u0026quot;first_letter\u0026quot; : true, \u0026quot;padding_char\u0026quot; : \u0026quot; \u0026quot; }, } } o-\u0026gt; pinyin \u0026quot;analysis\u0026quot; : { \u0026quot;tokenizer\u0026quot; : { \u0026quot;my_pinyin\u0026quot; : { \u0026quot;type\u0026quot; : \u0026quot;pinyin\u0026quot;, \u0026quot;keep_separate_first_letter\u0026quot; : false, \u0026quot;keep_full_pinyin\u0026quot; : true, \u0026quot;keep_original\u0026quot; : true, \u0026quot;limit_first_letter_length\u0026quot; : 16, \u0026quot;lowercase\u0026quot; : true, \u0026quot;remove_duplicated_term\u0026quot; : true } }, \u0026quot;analyzer\u0026quot; : { \u0026quot;pinyin_analyzer\u0026quot; : { \u0026quot;tokenizer\u0026quot; : \u0026quot;my_pinyin\u0026quot; } } } \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;keyword\u0026quot;, \u0026quot;fields\u0026quot;: { \u0026quot;pinyin\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;text\u0026quot;, \u0026quot;store\u0026quot;: \u0026quot;no\u0026quot;, \u0026quot;term_vector\u0026quot;: \u0026quot;with_offsets\u0026quot;, \u0026quot;analyzer\u0026quot;: \u0026quot;pinyin_analyzer\u0026quot;, \u0026quot;boost\u0026quot;: 10 } } } } o-\u0026gt; ik-pinyin \u0026quot;analysis\u0026quot;: { \u0026quot;filter\u0026quot;: { \u0026quot;pinyin1\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;pinyin\u0026quot; } }, \u0026quot;analyzer\u0026quot;: { \u0026quot;ik_pinyin_analyzer\u0026quot;: { \u0026quot;filter\u0026quot;: [\u0026quot;pinyin1\u0026quot;,\u0026quot;word_delimiter\u0026quot;], \u0026quot;type\u0026quot;: \u0026quot;custom\u0026quot;, \u0026quot;tokenizer\u0026quot;: \u0026quot;ik_smart\u0026quot; } } }, 工具 kopf bigdesk head 使用 https://github.com/mobz/elasticsearch-head cnpm i npm i -g grunt-cli grunt server curl localhost:9100 配置 Gruntfile.js port:9100 client olivere/elastic Search # SearchService Do Index Query Sort From Pretty Index # IndexService Do Index Type Id BodyJson Refresh Suggest # SuggestService query SimpleQueryString\n"},{"id":83,"href":"/docs/db/mysql/","title":"Mysql","section":"数据库","content":" 基础 # 介绍 c++编写 端口 3306 命令 mysql --max-relay-logs-size=300 # 中继日志大小(sql语句数) --relay-log-purge={0|1} # 中继日志自动清空 --relay-log-space-limit=0 # 限制中继日志大小,0表示无限制 o-\u0026gt; mysql -h 127.0.0.1 -u root -p mysqldump -uroot -p -h127.0.0.1 -P3306 --force --all-databases # 所有库 --databases db1 db2 # 多库 o-\u0026gt; mysqldump -uroot -p db1 tb1\u0026gt; tb1.sql mysqladmin -uroot -p status # 查看当前连接数 组件 mysql enterprise monitor documentation mysql enterprise monitor connector mysql enterprise monitor service manager mysql enterprise monitor agent mysql enterprise backup mysql connector 工具 mysql database mysql cluster # 创建集群，配置复杂 mysql cluster manager # cluster帮助软件，配置简单 mysql workbench # 据库建模工具 mysql utilities # 提供一组命令行工具用于维护和管理 MySQL 服务器 连接参数 root:123456@tcp(abcdefg:3306)/meiqia? charset=utf8mb4,utf8\u0026amp; characterEncoding=UTF-8\u0026amp; loc=UTC\u0026amp; interpolateParams=true\u0026amp; time_zone=%27%2B00%3A00%27\u0026amp; sql_mode=%27NO_ENGINE_SUBSTITUTION%2CSTRICT_TRANS_TABLES%27 数据类型 int # int(5) zerofill varchar(20) # null不占空间 decimal(10,2) # 小数 char(10) # 空间已固定, 不论null与否 date bool或boolean double float longtext longblob timestamp # 自动在插入、修改记录时添加，用于记录更新 enum('male','female') default male # 枚举，只有一个 set(('football','sleep','film') # 集合，可以多个 架构 服务器 连接管理与安全验证 解析器 # 解析到缓存 查询缓存(修改时清出缓存)，分析查询语句，生成解析树 优化器 查询语句优化 选索引 读取方式 获取查询开销信息 统计信息 执行器 执行查询语句，返回结果 生成执行计划 缓存 执行计划缓存 数据缓存 存储引擎 缓存管理 # 管理缓存 锁管理 # 管理执行器 事务管理 文件管理 innodb 事务 由存储引擎决定 # 与其它数据库产品不同 默认自动提交 # variables autocommit, 0 off 1 on 一些命令强制自动提交 DLL命令 lock tables 目录 /var/lib/mysql # 默认数据库 /var/log/mariadb # 默认日志 引擎 # XtraDB Memory(Heap) # 之前叫Heap, 存到内存 NDB 特点 集群设计 share nothing, 高可用，可扩展 存到内存, 主键查找快 join操作在数据库层完成，不是引擎完成。需要网络开销大，查询慢 Archive # 适合归档数据，只支持insert和select,提供高速插入和压缩功能 Federated # 不存数据, 指向远程表，类似oracle的透明网关 Maria # 开源，用于取代M主ISAM MyISAM 特点 不支持事务 表锁 适用联机分析(OLAP) 不缓存数据文件，只缓存索引文件 占较少空间保存数据与索引 表文件 .frm # 存储定义 .MYD # MYData 存储数据 .MYI # MYIndex 存储索引 InnoDB 特点 支持事务 行锁 支持外键 支持非锁定读 # 类似oracle, 默认读不产生锁 面向联机事务(OLTP) 数据放在一个逻辑表空间中 # 类oracle 实现4种隔离级别 默认可重复读repeatable, 使用next-key locking的策略避免幻读 索引组织表(Clustered)的方式进行存储 # 类oracle 内存池维护并发线程 注意 自增id最大值放在内存中，重启后会再查找。MyISAM的自增id最大值在文件中，重启不丢失。 函数 # count(*) count(name) # 不统计null，所以不推荐，会漏数据 sum(english)/count(*) as 英语平均分 avg(chinese) max(english) min(english) password('jiaoningbo') concat('jiao','ning','bo') concat(38.8) # 连接 转换数字到字符串 cast(38.8 as char) # 转换数字到字符串 同 concat(38.8) 但这个更正式 strcmp('text','text2') # 比较字符串，相同则返回0，不同则返回-1 abs('-1') # 绝对值 crc32('mysql') # 计算循环冗余码校验值并返回一个 32比特无符号值 pi() # pi floor(1.2) # 取整 返回一个bigint mod(29,9) # 取摩 is # select 1 is true,0 is false,null is unknown,null is not unknown 结果 ：1,1,1,0 coalesce(null,1) # 返回第一个非空值，全空则返回null greatest(0,2,66,34) # 返回不定参数个数的 参数的最大值，个数为0时返回null least(2,0) # 返回不定参数个数的 参数的最小值，个数为0时返回null 1 xor 0 xor 1 # 异或，两个1消为0 ascii('ab') # 返回最左字符的ascii码 bin(13) # 返二进制 bit_length('text') # 返回二进制长度 char_length('str') # 返回字符长度 left('foobar',5) # 截取左数前5个 right('foobar',4) # 截取右数前4个 locate('bar','foobar') # 返回位置4 locate('bar','foobarbar',5) # 返回从5开始数的子串的位置，这里是7 ltrim(str) # 去左空格 rtrim(str) # 去右空格 trim(str) # 去空格 make_set(1|4,'hello','nice','world') # 第一位是bit,1|4 表示1+4=5 即二进制101，所以显示结果为\u0026quot;hello,world\u0026quot;, 0 输出空字符串 repeat('m',3) # 重复 replace('wb','w') # replaceAll reverse(str) # 倒序 space(6) # 输出6个空格 adddate('1998-01-02',31) # 加日期 同 adddate('1998-01-02',interval 31 day)同 date_add('1998-01-02',interval 31 day) addtime('1997-12-31 23:59:59.999999','1 1:1:1.000002') #加时间 同 '1997-12-31 23:59:59.999999','1 1:1:1.000002'); curdate()+ 3 # 当前日期 + 3 天 date(str) # 提取日期时间表达字符串中的日期部分 date('1997-11-12','1997-11-11') # 前面减后面 得到天数 系统库/数据字典 # 系统库 information_schema # 默认内置元信息数据库 INNODE_TRX # 当前开启的事务 mysql # 内置安全设置数据库 performance_schema # 资源消耗，资源等待等情况 sys # 5.7后，数据来源performance_schema, 降低复杂度 test # 5.7移除，内置测试数据库 触发器(trigger) # new与old # 指代新数据 insert只有new是合法的； delete只有old才合法； update可同时使用。 语句 show triggers [from schema_name]; drop trigger [if exists] [schema_name.]trigger_name 例1 create trigger tr1 after # before, after insert on tb1 # insert, update, delete for each row update tb2 set field1 = field1+char_length(new.name); # 当更新表tb1的name字段时，更新表tb2 field1加上name的长度 例2 # UPDATE同时使用NEW和OLD create trigger tr1 before update on t22 for each row begin set @old = old.s1; set @new = new.s1; end; 存储过程(stored procedure) # # 5.0加入 结束符号(delimiter) // 语法 create procedure 存储过程名(参数类型 参数名 参数数据类型) begin 业务逻辑 end// call pro1()// # 执行 drop function pro1; 语句 # 所有sql语句都是合法的 declare a int default 2; set @name = 'admin'; # @name 为局部变量 @@name 为全局变量 if then else end if; case variable1 when 0 then when 1 then else end case while true do end while loop_label:LOOP LEAVE[ITERATE] loop_label; end loop [end loop_label] # iterate是迭代 LABEL label_name GOTO label_name repeat until end repeat # 执行后检查结果 存储过程名 大小写不敏感 可以包含空格，最长为64位 最好数据库名.过程名 不要使用内建函数名 参数类型 IN参数 # 不修改传递进来的参数 OUT参数 # 参数无法传进来，只修改参数 INOUT参数 # 可读可写 特征子句(characteristics clauses) 查看 show procedure status; show create procedure proc_name; show create function func_name; 异常 DECLARE { EXIT | CONTINUE } HANDLER FOR { error-number | { SQLSTATE error-string } | condition } SQL statement DECLARE EXIT HANDLER FOR 1216 DECLARE CONTINUE HANDLER FOR not found # 写在存储过程的begin后，当前程序出错后会自动触发代码 MySQL允许两种处理器， ## 一种是EXIT处理，上面所用的就是这种。另一种就是我们将要演示的，CONTINUE处理， ## 它跟EXIT处理类似，不同在于它执行后，原主程序仍然继续运行 DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1; # 如果下面将@x2的值赋为1就会出错 DECLARE EXIT HANDLER FOR `Constraint Violation` ROLLBACK; # 回滚 DECLARE `Constraint Violation` CONDITION FOR SQLSTATE '23000'; DECLARE EXIT HANDLER FOR `Constraint Violation` ROLLBACK; # 先声明条件 游标 declare cur_1 cursor for select s1 from t; open cur_1 fetch cur_1 into a close cur_1 函数 # 与存储过程唯一不同必须有RETURN语句 # 不能在函数中访问表 function example1: create function myadd(num1 int, num2 int) returns int begin return num1 + num2; end// 例1 create procedure pro(in name varchar(20)) begin select name; set name='hello world'; select name; end// set @name='jnb'// call pro(@name)// 例2 # if语句，根据输入0/1 判断 男/女 create procedure findGender(in op int) begin declare gendar varchar(20); # 在函数中定义变量gendar和其类型 if op=0 then # =表示判断 set gendar='male'; else set gendar='female'; end if; select gendar; end// 例3 # switch语句，判断星期 create procedure findday(in day int) begin declare findday varchar(20); case day when 1 then set findday='星期一'; when 2 then set findday='星期二'; when 3 then set findday='星期三'; when 4 then set findday='星期四'; when 5 then set findday='星期五'; when 6 then set findday='星期六'; when 7 then set findday='星期七'; else set findday='无效'; end case; select findday; end// 例4 # while循环 create procedure findsum(in n int) begin declare sum int default 0; declare i int default 0; while i\u0026lt;=n do set sum=sum+i; set i=i+1; end while; select sum; end// 例5 # 验证登录 create procedure prologin(in user_name varchar(20), in user_psw varchar(100), out flag int) begin if exists(select name from users where name=user_name and psw=password(user_psw)) then set flag = 1; else set flag = 0; end if; end// 配置 # o-\u0026gt; my.cnf文件 [client] port=3306 socket=/tmp/mysql.sock [mysql] default-character-set=gbk [mysqld] character-set-server=utf8 port=3306 socket=/tmp/mysql.sock log-bin=mysql-bin server-id=1 skip-name-resolve # 远程访问时非常慢解决 innodb-flush-log-at-trx-commit=2 innodb_log_file_size=268435456 sync-binlog=1 # 这两个配置为了使用事务的InnoDB在复制中最大的持久性和一致性 master-connect-retry=60 # 从服务器断开重连时间 binlog-do-db=test # 主从都可以设置，复制的数据库 binlog-ignore-db=mysql # 主从都可以设置，不复制的数据库 lower_case_table_names=1 # 设置大少写不敏感 interactive_timeout=3600 sql_mode=IGNORE_SPACE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 安全性 # 跨域访问，使用ssh隧道加密通信 set password设置密码 用grant和revoke对用户授权 少开权限 只有启动mysql的用户有写权限 只授权process和super权限给管理用户 mysqladmin processlist 可列举当前执行的查询 super 可切断连接，改变服务器运行参数，控制从库 不信任dns时，权限表只设置ip 常见攻击 防偷听 篡改 回放 拒绝服务 acl控制接口权限 设置只有root可访问mysql数据库和user表 不用明文密码，密码强度高 数据库放在防火墙后，或在DMZ(demilitarized zone, 隔离区) 防火墙设置3306端口不可访问 sql预编译，避免sql注入 存数据时检查大小 以普通用户启动mysql tcpdump检查传输数据的安全性 tcpdump -l -i eth0 -w -src or dst port 3306 strings max_user_connections变量限制指定帐户连接数 打开mysqld安全开关 --local-infile=0 # 0时客户端无法使用local load data --skip-grant-tables # 对用户不做访问控制 mysqladmin flush-privileges # 运行中开启访问控制 mysqladmin reload # 运行中开启访问控制 --skip-show-databases # 禁止show databases 方案 # 初始化 systemctl start mariadb mysql_secure_installation etc/my.cnf文件 [mysqld] default-storage-engine = innodb innodb_file_per_table max_connections = 4096 collation-server = utf8_general_ci character-set-server = utf8 [mysql] default-character-set=utf8 systemctl restart mariadb 移数据库 同mysql版本, 新目录下替换(/var/lib/mysql/)ibdata1、数据库名目录 error: mysqld does not have the access rights to the directory. File name ./ibdata1 chcon -R --reference=/var/lib/mysql 新目录 或 chcon -R -t mysqld_db_t -u system_u -r object_r 新目录 重初始化数据库 rm -r /var/lib/mysql/* mysql_install_db chown mysql:mysql -R /var/lib/mysql systemctl restart mariadb mysql -uroot mysql update user set password=password('asdf') where user='root'; flush privileges; 授权远程登录 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'asdf' WITH GRANT OPTION; 创建用户 CREATE USER 'username'@'host' IDENTIFIED BY 'password'; 删除用户 DROP USER 'username'@'host'; 免密登录 mysql_safe --user=mysql --skip-grant-tables --skip-networking 修改密码 问题 error 1045(28000) access denied for user 'root'@'localhost' (using password:no) 不能登录时 mysqld_safe方式 mysqld_safe --user=mysql --skip-grant-tables --skip-networking \u0026amp; mysql -u root mysql update user set password=password('newpassword') where user='root'; # 新版中password改为authentication_string flush privileges; mysqld_safe方式2 创建a.sql update mysql.user set password=password('mysql') where user='修改用户'; flush privileges mysqld_safe --defaults-file=\u0026quot;a.sql\u0026quot; 文件方式 使用/etc/mysql/my.cnf中[client]下的user与password 能登录时 mysqladmin方式 mysqladmin -uroot -p password 新密码 update方式 update mysql.user set password=password('root') where user='root'; flush privileges; set方式 SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword'); flush privileges; 编码问题 查询 show variables like \u0026quot;%colla%\u0026quot; # 字符串排序规则 show variables like \u0026quot;%char%\u0026quot; 修改 set character_set_client='utf8' 创建db时指定 create database `db1` character set 'utf8' collate 'utf8_general_ci' 创建表时指定 create table (...) engine=innodb default charset=utf8 查看db和表编码 show database `db1` show create table `tb1` 修改db和表编码 alter database `db1` default character set utf8 collate utf8_general_ci alter table `tb1` default character set utf8 collate utf8_general_ci 导库 导出 o-\u0026gt; mysqldump -uroot -p db1 \u0026gt; db1.sql o-\u0026gt; mysqldump -uroot -p db1 tb1 \u0026gt; db1_tb1.sql 导入 o-\u0026gt; mysql -uroot -p db1 \u0026lt; db1.sql o-\u0026gt; 数据库中 source db1.sql 主从复制 mysql配置文件my.cnf [mysqld] log-bin=mysql-bin server-id=222 log-slave-updates =1 # m-m-s结构中第二个m配置 主服务器授权从服务器 GRANT REPLICATION SLAVE ON *.* to 'slave'@'%' identified by 'asdf'; 从服务器设置主服务器 change master to master_host='192.168.56.14', master_user='slave', master_password='asdf', master_log_file='mysql-bin.000001', master_log_pos=319; 命令 主服务器 flush tables with read lock; grant replication slave on *.* to 'slave'@'%' identified by 'asdf' show master status\\G unlock tables; 从服务器 stop slave change master to master_host='192.168.0.42', master_user='slave', master_passowrd='asdf', master_log_file='mysql-bin.000001', master_log_pos=120; start slave show slave status\\G 问题 The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work. # 随意修改data/auto.cnf中的uuid的值 主A复制到主B后，主B不会把数据复制到主B的从 "},{"id":84,"href":"/docs/db/oracle/","title":"Oracle","section":"数据库","content":" 基础 # 安装 运行services.msc 找到OracleServiceORCL 服务 （最后是数据库名）改为手动 sqlplus / as sysdba 运行oracle测试是否安装成功 解锁scott用户 sqlplus / as sysdba alter user scott account unlock; alter user scott identified by tiger; 启动 OracleServiceORCL OracleOraDb11g_home1TNSListener 端口 1521 # 停了以后再开会变 权限 系统权限：创建数据库，创建用户 对象权限：表操作 sys create database权限 system 没有create database权限 scott hr 角色 # 超管以角色进入，普通用户输入用户名密码 dba dbaoperator 服务器的组成 oracle数据库 存储位置 oracle安装位置/oradata/ 每个数据库文件夹中有多个二进制文件（*.dbf） oracle实例(内存概念) 一个数据库进程可以有多个实例 一个实例可以有多个数据库进程和一个内存池(缓存) # 不同于windows进程，每个进程对应一个用户访问 服务名为OracleService数据库名 集群(多实例) 连接失败转移 负载均衡 连接类型 normal sysdba sysoper 分布式 认证 开发技术认证 Java认证 数据库开发语言SQL和PL/SQL认证 数据库技术认证 OCM【大师】 OCP【专家】 OCA【初级】 中间件技术认证 OracleServer认证，WEB服务器认证 专业领域技术认证 ERP CRM HR OA 支持的事务隔离 只支持读提交与序列化两种 版本 8i 9i 10i # i是internet 11g # 基于jdk6, g是grid网格(一个请求多个服务器运行) 12c # c是cloud SQL99标准 # 不区分大小写 PLSQL是Oracle对SQl99标准的扩展 结构代查询语言 DML select,insert,update,delete DDL create table,alter table, drop table DCL grant, revoke TCL(杜撰) commit, rollback,rollback to savepoint 加载过程 启动oracle服务 oradim -startup -sid 数据库名 # 相当于windows服务中启动该服务，会从windows注册表中加载配置 oradim -shutdown -sid orcl -shuttype srvc # 停止oracle 服务 普通登录 sqlplus system/asdf # 从注册表中查找默认的数据库名称进行登录 sqlplus system/asdf@orcl # 指定数据库名登录，必须有监听的时候该命令可以执行，监听的进程是独立于oracle之外的进程 管理员登录 sqlplus / as sysdba # windows管理员的身份进行登录，不需要用户名密码，可以在配置文件中禁用它 无连接登录 sqlplus /nolog #用来设置sql/plus 启动实例 cmd\u0026gt; sqlplus / as sysdba # 连接到数据库的空闲实例 sql\u0026gt; select status from v$instance # 查看实例状态 sql\u0026gt; shutdown abort # 立即终止当前的实例,实例结束后用户仍然登录状态，但没有连接实例 sql\u0026gt; startup nomount # 启动默认实例（不加载数据库） sql\u0026gt; startup open # 启动、装载、打开默认的数据库 cmd\u0026gt; set oracle_sid=orcl # 在windows下设置oracle的默认登录数据库 启动过程 加载参数文件database/init数据库名 分配sga (system global area)到内存空间，用于缓存数据库信息 创建后台进程 挂载数据库 sql\u0026gt; startup mount 挂载过程 装载数据库文件夹中的文件 # sga中有已经初始化了ctl文件的路径，通过ctl文件装载数据库 ctl(从中得到数据库文件名) -\u0026gt; dbf # 3种数据库文件: .ctl(控制文件) .dbf(数据库文件) .log(日志文件) 这时，数据库还是不能访问,但是管理员可以访问（debug数据库） 打开数据库 # 使外界可以访问 sql\u0026gt; alter database 数据库名 open # 数据库文件夹中记录日志 类型 # varchar2(7) # 可变字符串 char # 字符 number(precision [, scale]) # presision是有效位（从左边第一个不为0的数算起，小数点和负号不计入有效位数），scale是精确位（正数为小数的精确位，负数为整数的精确位） constant number # 常量 数据字典 # dual # dual表只有一行，用于执行一些特殊操作 dba_sequences select SEQUENCE_OWNER,SEQUENCE_NAME from dba_sequences # 查询序列 dba_users select username,password from dba_users; # 查询用户和密码 tab select * from tab # 查看自己的可用表，视图，等 v$session select count(*) from v$session # 查看当前数据库的连接 存储过程 # 过程与函数 返回值 函数有且只一个返回值 过程没有或多个返回值用(out参数) 过程可返回函数,函数只能返回值或表对象 过程和函数不能重名 函数可嵌入sql执行，过程不行 语法 IF .. THEN null; ELSIF .. THEN null; ELSE null; END IF; select into给变量赋值 raise 异常名 # 抛异常 函数 create or replace function calculate_score ( cat in varchar2 , score in number , weight in number ) return number as begin return null; end calculate_score; 例子1 # in参数 和返回值的函数 create or replace function findEmpIncome(pempno in number) return number as income number(10); begin select sal*12+NVL(comm,0) into income from emp where empno = pempno; return income; end; / 例子2 # in、out 参数和返回值的函数 create or replace function findEmpNameAndSal (pempno in number, psal out number)return varchar2 as pename emp.ename%type; begin select ename , sal into pename,psal from emp where empno = pempno; return pename; end; / 执行 declare psal emp.sal%type; pename emp.ename%type; begin pename := findEmpNameAndSal(7788,psal); dbms_output.put_line(pename||'的工资是'||psal); end; / 过程 # 参数默认in create or replace procedure add_evaluation ( evaluation_id in number , employee_id in number , evaluation_date in date , job_id in varchar2 , manager_id in number , department_id in number ) as # as 变量 类型 (值范围); begin null; exception when others then rollback; end add_evaluation; exec add_evaluation drop procedure add_evaluation; 例子1 # in 参数的使用 create or replace procedure raiseSalary(pempno in emp.empno%type) as begin update emp set sal = sal * 1.1 where empno = pempno; end; / exec raiseSalary(7369); 例子2 # out参数的使用 select into create or replace procedure findEmpNameAndSalAndJob (pempno in emp.empno%type, pename out emp.ename%type, pjob out emp.job%type, psal out emp.sal%type) as begin select ename,job,sal into pename,pjob,psal from emp where empno = pempno; end; / declare pename emp.ename%type; pjob emp.job%type; psal emp.sal%type; begin findEmpNameAndSalAndJob(7788,pename,pjob,psal); dbms_output.put_line('7788号员工的姓名是'||pename||',职位是'||pjob||',薪水是'||psal); end; / 包 声明 create or replace PACKAGE emp_eval AS PROCEDURE eval_department(department_id IN NUMBER); FUNCTION calculate_score(evaluation_id IN NUMBER , performance_id IN NUMBER) RETURN NUMBER; END emp_eval; 定义 CREATE OR REPLACE PACKAGE BODY emp_eval AS PROCEDURE eval_department(department_id IN NUMBER) AS BEGIN /* TODO implementation required */ NULL; END eval_department; FUNCTION calculate_score(evaluation_id IN NUMBER , performance_id IN NUMBER) RETURN NUMBER AS BEGIN /* TODO implementation required */ RETURN NULL; END calculate_score; END emp_eval; 触发器 # 分类 # select 没有触发器 语句级insert / delete # 只在语句执行时触发 行级(for each row)update # 每一行都执行，出错后不会继续执行并且回滚 语法 create [or replace] trigger 触发器名 {before|after} {insert|delete|update of 列名} on 表名 for each row plsql块 行级触发器中 :new 代表更新后那一行整行的值 :old 则是旧的整行的值 update of 列名 for each row是连起来用的。语句级触发器没有for each row drop trigger 触发器名 例子(语句级) # 当在休息日与非9点到17点之间的时候，禁止对emp表进行插入操作 create or replace trigger securityTrigger before insert on emp declare pday varchar2(10); phour number(20); begin select to_char(sysdate,'day') into pday from dual; select to_char(sysdate,'hh24') into phour from dual; if(pday in ('星期六','星期日') or (phour not between 9 and 17)) then raise_application_error('-20666','禁止操作'); end if; end; / 例子(行级)：当对每一行的工资进行修改的时候，新的工资不能小于原来的工资 create or replace trigger checkSalayTrigger before update of sal on emp for each row begin if :new.sal \u0026lt; :old.sal then raise_application_error('-20555','工资不能减少'); end if; end; / 函数及常量 # 常量 sysdate 当前日期 单行函数 nvl(comm,0) # 替换comm列中的空值为0 nvl2(comm,comm,0) # 替换comm列中的空值为0，非空时为comm select lower('AAA') from dual; # 取小写 upper('') # 取大写 initcap('www.itcast.cn') # 每一段字符串的首字符大写 concat('','') # 拼接字符串 substr('itcast',1,3) # 取第一个和第三个字符，脚标从1开始 length('') # 字符的长度 lengthb('') # 字节的长度 instr('itcast','t') # 查找第一个匹配字符串的位置,区分大小写 lpad('a',10,'*') # 左填充，一直到10位,也可以截取左边的10位字节（并非字符） rpad('a',10,'*') # 右填充，一直到10位,也可以截取右边的10位字节（并非字符） trim('x' from 'xxhelloxsx') # 增强版trim(),去掉字符串中的所有'x' replace('hello','l','o') # 替换字符串中的'l' 为 'o' round(3.45,2) # 四舍五入，2代表小数点后的位数 -1代表个位，-2代表十位 round(sysdate,'month') # 四舍五入到月(15号前后判断) round(sysdate,'year') # 四舍五入到年(6月30号前后判断) trunc(3.142,1) # 截取小数点后1位 mod(10,3) # 10mod3取余 nullif(10,20) # 比较两个数值，相同时返回空，不同时返回第一个数值 (job,'analyst',sal + 1000,\u0026quot;manager\u0026quot;,sal + 800, sal + 400) \u0026quot;新工资\u0026quot; from emp; decode(...)函数：例子 select ename \u0026quot;姓名\u0026quot; , sal \u0026quot;原工资\u0026quot; , decode(job, 'analyst',sal + 1000, 'manager',sal + 800, sal + 400) \u0026quot;新工资\u0026quot; from emp; select ename \u0026quot;姓名\u0026quot; , sal \u0026quot;原工资\u0026quot; , case job when 'analyst' then sal + 1000 when 'manager' then sal + 800 else sal + 400 end \u0026quot;新工资\u0026quot; from emp #sql99语法 日期函数 sysdate +/- 1 # 增加或减少1天 sysdate - hiredate # 日期减日期，得到天数 to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') # 格式化显示时间 months_between('12-2月-13',sysdate) # 日期之间的月数 add_months(sysdate,1) # 给当前日期增加1个月 next_day(sysdate,'星期一') # 下一个星期一的日期 last_day(sysdate) # 反回这个月的最后一天 类型转换： 隐式转换 # 要求 1，格式正确。2，内容合理 字符串与Date,number相互转换 显式转换 到字符串： 日期到字符串：to_char(sysdate,'yyyy \u0026quot;年\u0026quot; mm \u0026quot;月\u0026quot; dd \u0026quot;日\u0026quot; day hh12:mi:ss:am') # day是星期、hh12是12进制计时(hh24代表24进制计时)、am是个变量,上午时是am，下午是pm ##　双引号中的内容直接显示 货币值到字符串：to_char(1234,'L9,999') # L可以小写，代表当地货币，','可以省略 字符串到Date： to_date('1980-12-17','yyyy-mm-dd') 字符串转换到数字： to_number('123') 多行函数 # 多行函数分为接收多个输入，返回一个输出。 ##　多行函数本身不会统计值为null的记录 ## 多表的多行函数的统计多会用到group by ，因为where 只是筛选出了不符合条件的部分 ## ,剩下的部分分列在不同的表中，只有按照列名分组以后才能按列名执行多行函数 having count([distinct] deptno) # 统计deptno【不重复的】记录数 sum(sal) # 统计数值的和 avg(sal) # 统计平均值 max(sal) # 统计最大值，可以用在日期上 min(sal) # 统计最小值 ，可以用在日期上 游标 # 分类 显示 cursor is 隐式 执行insert, delete, update，返回单条记录的select时，pl/sql自动定义 闪回技术 # 可以闪回的操作 dml ddl操作（回收站中存在） 闪回记录 1.获取当前时间与改变号 select to_char(sysdate,'yyyy-mm-dd:mi:ss') \u0026quot;系统时间\u0026quot;, timestamp_to_scn(sysdate) \u0026quot;系统改变号\u0026quot; from dual; # scn 是 系统改变号，每秒钟都会变，oracle根据它来进行闪回,如1216687 2.给普通用户授于闪回的权限 grant flashback any table to scott; 3.alter table emp enable row movement; # 更改rowid号可以更改 4.flashback table emp to SCN 1216687; # 闪回表到时间改变号 # 如果没有做第三步，这里会出错 ，原因是 还原表记录时，递增的rowid后面不能插入数据。在rowid之间插入数据必须改变rowid的状态为可以'移动'，即还原记录后面的表记录可以'移动'。 闪回表（回收站中才可以） 1.确定回收站中有该表，可以用show recyclebin命令查看 2.flashback table emp to before drop; # flachback table \u0026quot;BIN$Pu9C2euHQ96xySmn08e5aQ==$0\u0026quot; to before drop; 也是可以的 3.如果回收站中有两个相同的表需要闪回时，设置一个表名 flashback table emp to before drop rename to newemp; # 两张同名的表首先恢复最近删除的表 审计 # 审计（Audit) 用于监视用户所执行的数据库操作，并且Oracle会将审计跟踪结果存放到OS文件（默认位置为$ORACLE_BASE/admin/$ORACLE_SID/adump/） 或数据库（存储在system表空间中的SYS.AUD$表中，可通过视图dba_audit_trail查看）中。 默认情况下审计是没有开启的。 不管你是否打开数据库的审计功能，以下这些操作系统会强制记录：用管理员权限连接Instance；启动数据库；关闭数据库。 两个参数 # cmd\u0026gt; set xxx=xx ## 这两个参数是static参数，需要重新启动数据库才能生效。 Audit_sys_operations 默认为false，当设置为true时，所有sys用户（包括以sysdba,sysoper身份登录的用户）的操作都会被记录， audit trail不会写在aud$表中，因为数据库还没有启动，conn / as sysdba 这样的命令是没法记录的 windows平台记录在windows的事件管理中,unix平台记录在audit_file_dest参数指定的文件中 Audit_trail None：是默认值，不做审计； DB：将audit trail 记录在数据库的审计相关表中，如aud$，审计的结果只有连接信息； DB,Extended：这样审计结果里面除了连接信息还包含了当时执行的具体语句； OS：将audit trail 记录在操作系统文件中，文件名由audit_file_dest参数指定； XML：10g里新增的。 审计级别 Statement(语句)、Privilege（权限）、object（对象）。 Statement 按语句来审计，比如audit table 会审计数据库中所有的create table,drop table,truncate table语句。 Privilege 按权限来审计，当用户使用了该权限则被审计，如执行grant select any table to a， object 按对象审计，只审计on关键字指定对象的相关操作，如aduit alter,delete,drop,insert on cmy.t by scott; 工具 # sqldeveloper isqlplus dbconsole toad sqlplus # 命令 # ;或/结束 / # 执行最近一次的sql命令（不执行工具命令） host cls # 清屏 edit # 用本地编辑器编辑 设置显示 column deptno format 9999 # deptno是列名,9999 代表4个数字宽度 column ename format a8 # a8代表8个字符宽度(date也用a) col ename for a8 # 简写 set pagesize 40 # 设置一页显示40条记录 spool d:/a.sql # 假脱机,开始记录控制台信息 spool off # 正式保存记录信息到文件 @ d:/a.sql # 从脱机文件中导入命令并执行 监查时间 set timing on / set timing off # 每执行一段语句显示语句的执行时间 set time on / set time off # 在输入标记前面显示当前时间 pl/sql # procedure language oracle对sql99的扩展 增加了类型定义 判断 循环 指针/游标/光标 输出语句 异常 语法 符号 / # 结束标记 := # 赋值号 \u0026amp; # 进行定义运行时赋值 语句 declare 分号结束 ; begin dml语句/tcl语句,以分号结束 # 必写 ; [exception] ; end; # 必写 / set serveroutput on; # 设置plsql的输出打开，默认是off 的 dbms_output.put_line(''); # 只能在 plsql 的执行语句中使用，dbms_output的输出方法,会自动换行 emp.ename%type; # 同emp表中的ename的类型一样的类型 emp_record emp%rowtype # 匹配一行类型 emp_record.ename输出一个字段的数据 if 条件1.1 and 条件1.2 then 语句1; elsif 条件2 then 语句2; else 语句3; end if; loop exit [when]; end loop; while 条件 loop ; end loop; for i in 1..3 # 不可以在循环中更改i的值 loop ; end loop; cursor # 多行数据 ，相当于resultset cursor c1 查询语句 open c1; loop fetch # 先判断再下移，最后一条记录打印两次 ## 先下移再判断 ，正常显示 exit when 条件; end loop; close c1; 异常 内置异常 no_data_found # 没有查到数据,游标中使用的时候异常不抛出 select ename into pename from emp where deptno = 100; # select into 插入的数据找不到的时候 too_many_rows # zero_divide # 除零异常 value_error timeout_on_resource 例子 declare i number(2) := 10; s number(2); begin s:= i/0; exception when zero_divide then dbms_output.put_line('除0异常'); end; / 自定义异常 declare no_emp_found exception; begin if()then raise no_emp_found; end if; exception when no_emp_found then dbms_output.put_line('查无数据'); end; / 抛出异常的函数 raise_application_error('-20666','禁止操作'); # begin语句中的相关地方调用此函数即可 # 20000-20999错误编号范围，是负数 例1 # dbms_output.put_line(''); declare mysum number(3); begin mysum := 10 + 100; # :=就是赋值 dbms_output.put_line('结果为' || mysum); end; / 例2 # emp.ename%type ## select .. into .. declare x emp.ename%type; y emp.sal%type; begin --select ename,sal from emp where empno = 7369 # sql语句可以单独执行 select ename,sal into x,y from emp where empno = 7369 # plsql语句只能整体执行 dbms_output.put_line(x || '是' || y); end; / 例3 # emp%rowtype declare emp_record emp%rowtype; begin select * into emp_record from emp where empno = 7788; dbms_output.put_line(emp_record.ename || emp_record.sal); end; / 例4 # 运行时赋值符号与if判断语句 declare num number(2); begin num := \u0026amp;num; if num\u0026lt;5 then dbms_output.put_line(num || '\u0026lt;5'); elsif num=5 then .. else .. end if; end; / 例5 # loop 循环 declare i number(2) := 1; # 声明的时候可以赋值 begin loop exit when i \u0026gt; 10; dbms_output.put_line(i); i := i + 1; end loop; end; / 例6 # while循环 declare i number(2) := 10; begin while i \u0026lt;= 20 loop dbms_output.put_line(i); i := i + 1; end loop; end; / 例7 # for循环 declare i number(2) begin loop for i in 20..30 # 一个一个增加,循环中不能再对i进行操作 dbms_output.put_line(i); end loop; end; / 例8 # cursor declare cursor cemp is select ename,sal from emp; pename emp.ename%type; psal emp.sal%type; begin open cemp; loop exit when cemp%notfound; fetch cemp into pename,psal; dbms_output.put_line(pename || '的薪水是' || psal); end loop; close cemp; end; / 例9 # 有参游标 declare cursor cemp(pdeptno emp.deptno%type) is select ename,sal from emp where deptno=pdeptno; pename emp.ename%type; psal emp.sal%type; begin open cemp(\u0026amp;deptno); loop fetch cemp into pename,psal; exit when cemp%notfound; dbms_output.put_line(pename ||'的薪水是' || psal); end loop; close cemp; end; / 例10 # 输入\u0026amp;emptno没有的时候，输出\u0026quot;查无员工\u0026quot; # 综合if loop 与cursor declare cursor cemp(pdeptno emp.deptno%type) is select ename,sal from emp where deptno=pdeptno; pename emp.ename%type; psal emp.sal%type; pdeptno emp.deptno%type := \u0026amp;deptno; begin if pdeptno in (10,20,30) then dbms_output.put_line('输入的值正确'); open cemp(pdeptno); loop fetch cemp into pename,psal; exit when cemp%notfound; dbms_output.put_line(pename ||'的薪水是' || psal); end loop; close cemp; else dbms_output.put_line('输入的值不正确'); end if; end; / 例11 # 给所有ANALYST加工资 # 综合cursor if loop ,循环之后执行了tcl 事务控制语言 declare cursor cemp is select empno,ename,job,sal from emp; pempno emp.empno%type; pename emp.ename%type; pjob emp.job%type; psal emp.sal%type; begin open cemp; loop fetch cemp into pempno,pename,pjob,psal; exit when cemp%notfound; if pjob='ANALYST' then update emp set sal = sal+1000 where empno = pempno; end if; end loop; commit; close cemp; end; / "},{"id":85,"href":"/docs/db/redis/","title":"Redis","section":"数据库","content":" 基础 # remote dictionary server 特点 no-sql, c编写 内存数据库 # 请求不经过parser和optimizer key-value 单线程 可持久化 与memcache区别 memcache全在内存，不能持久化，redis部分硬盘 memcache类型支持简单 # memcache类型只有字符串，append字符串, blacklist删除麻烦 emecache多线程, redis单线程 底层模型，与客户端通信协议不同，redis自己实现vm机制(冷热数据分离) value, memcache只能存1MB, redis可存1GB redis可设置expire, 支持排行榜, 浮点数 类型 string 整个或一部分操作 整数、浮点数自增自减 list 两边推入或弹出 偏移量trim 读单个多个元素 值查找移除元素 set 增删查单个元素 单个元素是否存在 交集、并集、差集 随机取元素 hash 增删查单个键值对 获取所有键值对 zset # 有序集合, 排序根据score, score为双精度浮点数 增删查单个元素 根据range或成员获取元素 应用 会话缓存(session cache) 全面缓存(FPC) 队列 排行榜/计数器 发布/订阅 命令 文件命令 redis-server # 端口为6379 redis-server /etc/redis.conf 来加载配置文件 redis-cli redis-benchmark # 性能测试工具 redis-cli命令 ping # 成功时返回 PONG shutdown # 关闭redis-server服务 -p 端口号 quit 功能 # 性能高 # 100k次读写/s 数据类型丰富 所有操作有原子性 支持发布/订阅，通知，key过期 发布订阅 subscribe psubscribe # 订阅给定模式匹配的所有频道 unsubscribe punsubscribe publish sort # 列表、集合、有序集合排序，返回结果或生成存储 过期 persist # 移除键过期时间 ttl # 键距离过期时间还有多少秒 pttl # 多少毫秒 expire # 给定键指定数秒后过期 pexpire # 指定的毫秒后过期 expireat # unix时间戳过期 pexpireat # 毫秒unix时间戳 事务 # 事务期其他客户端命令阻塞 multi # 创建事务队列，开始记录命令 exec # 提交事务队列 watch # 对键加锁 unwatch discard # 取消事务 持久化 bgsave # fork线程创建快照, windows不支持 save # 停止响应创建快照 sync # 向主服务器要求复制时，主服务器bgsave，非刚bgsave过 bgrewriteaof # 重写aof文件使它缩小 复制 slaveof 客户端分片 不完全事务 性能 # 内存数据库，需要预估内存，使用key过期节约 完整重同步占资源，可以部分重同步 重启数据加载慢 master内存快照时，save命令调rdbSave阻塞主线程 master AOF持久化，追加文件大时影响master重启恢复速度 用slave AOF master调用BGREWRITEAOF重写AOF文件时，cpu和内存负载高 主从复制最好同局域网 数据 # set mykey somvalue get mykey del mykey incr decr incrby decrby incrbyfloat append getrange setrange getbit setbit bitcount # 二进制位串位为1的数量 bitop # 二进制位串执行and, or, xor, not rpush list-key item lpush lrange list-key 0 -1 # -1为结束索引 lindex list-key 1 rpop lpop list-key lrange ltrim # 修剪 blpop # timeout秒内阻塞并等待弹出元素 brpop rpoplpush # 一个列表中右弹元素推入另一个列表左端，最后返回这个元素 brpoplpush sadd set-key item smembers set-key sismember set-key item srem set-key item # 删除，返回删除的数量 scard # 元素数 srandmember # 随机返回一个或多个元素。count正数时，返回的元素不重复, 负数时可重复 spop # 随机移除一个元素 smove # 一个集合中移除，并在一个集合中添加。返回移除的数量 sdiff # 差集 sdiffstore # 差集生成集合 sinter # 交集 sinterstore sunion # 并集 sunionstore hset hash-key sub-key value hget hash-key sub-key hdel hash-key sub-key hlen hexists hash-key sub-key hkeys hash-key hvals hgetall hash-key hincrbyfloat hincrby hash-key field -1 hmget hmset hash-key field1 \u0026quot;foo\u0026quot; field2 \u0026quot;bar\u0026quot; zadd zset-key 728 member zrange zset-key 0 -1 withscores zrevrange zset-key 0 -1 withscores zrangebyscore zset-key 0 800 withscores # 根据score范围查找 zrevrangebyscore zrem zset-key member zremrangebyrank zremrangebyscore zincrby zinterstore sum 3 sub1 sub2 sub3 # 生成交集, 重复值score相加, 3 指定可变参数的数量 zunionstore # 并集 zcard # 成员数量 zcount # 分值之间的成员数量 zrank # 返回排名 zrevrank zscore # 返回分值 client # jedis # java, 支持redis sharding, 即ShardedJedis结合ShardedJedisPool Jedis jedis = new Jedis(\u0026quot;localhost\u0026quot;); # 连接redis数据库 jedis.set(\u0026quot;name\u0026quot;, \u0026quot;aa\u0026quot;); # 添加、覆盖 jedis.append(\u0026quot;name\u0026quot;, \u0026quot;bb\u0026quot;); # 追加，结果为 name=aabb jedis.get(\u0026quot;name\u0026quot;); # 取值 jedis.del(\u0026quot;name\u0026quot;); # 删除 jedis.mset(\u0026quot;name1\u0026quot;, \u0026quot;aa\u0026quot;, \u0026quot;name2\u0026quot;, \u0026quot;bb\u0026quot;); # 批量添加、覆盖 jedis.mget(\u0026quot;name1\u0026quot;, \u0026quot;name2\u0026quot;) # 批量取值 分布式 # redisCluster twemProxy # twitter开发的redis集群代理 redisMonitor redisSentinel # 主从复制，高可用 codis # 豌豆荚开发的redis集群代理 持久化 # 方式 无持久化 RDB # 一段时间备份一个RDB文件，RDB文件很紧凑。用fork子进程的方式备份，恢复速度快 # 服务器故障时，会丢当前时段数据。数据集大时，fork耗时出现停止服务(毫秒至1秒) point-in-time dump dump-to-disk二条命令 AOF # 记录写操作, AOF先于RDB # fsync不fork在后台执行, 追加写文件，文件大时自动重写 # AOF文件结构不紧凑，AOF速度慢于RDB(关闭fsync一样快) append-only文件 fsync策略 从不同步 每秒同步一次 # 只丢一秒数据 一命令同步一次 策略 配置 save 60 1000 # 60秒内有1000次写入时，自动save stop-writes-on-bgsave-error no rdbcompression yes dbfilename dump.rdb appendonly no # 打开AOF appendfsync everysec always # 每个写命令都马上同步 everysec # 每秒 no # 操作系统决定 no-appendfsync-on-rewrite no auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb dir ./ "},{"id":86,"href":"/docs/middleware/library/hibernate/","title":"Hibernate","section":"小功能","content":" 基础 # 优点 完全面向对象编程思想，无sql 减少代码 控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率 hibernate具有独立性（访问层随时可以更换） 特性 不写hbm.xml映射文件，而是基于注解的验证 对象、集合、属性的延迟加载 dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常 目录 . # hibernate程序包 documentation # 文档 lib # 所有依赖包 project # 源码文件 加载顺序 后面的覆盖前面的 hibernate.properties中的配置被覆盖 # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置 hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准） 开发流程 加载配置: jdbc参数，数据库方言，hbm映射 创建SessionFactory # 内有连接池 创建session 事务处理 关闭session 关闭连接池 对象状态 𣊬时态 # 没有OID(持久化标识), 没有关联session 持久态 # 有OID, 与session关联, 事务未提交 脱管态 # 有OID, 没有关联session 缓存机制 一级缓存(session) 事务级，事务结束缓存失效 # 请求同一对象，取得同一实例 总是打开 二级缓存 SessionFactory级别，session共享 缓存散装持久化实例, 有不同缓存策略 先设置策略，再设置过期时间与cache提供器 优点 提高速度、减小压力 缓存失效时，不立即查找，而是合并sql查找 查询方式 HQL QBC(命名查询) SQL get与load get立即加载，load延时加载 get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库 # 代理对象只存id get没有时返回null, load抛异常 检索策略 # 取关联对象 立即检索 # 一次全加载, select多 延迟检索 # 访问游离状态代理类，需要在持久化状态时已被初始化 迫切左外连接检索 # 用外连接取代select，全加载 优化 # 数据库设计调整 HQL优化 api正确使用 配置参数 # 日志、查询缓存，fetch_size, batch_size等 映射文件优化 # id生成策略，二级缓存，延迟加载，关联优化 一级缓存管理, 二级缓存策略 事务控制策略 基本概念 # o-\u0026gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题 o-\u0026gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想) DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准 它们的区别在于 hibernate中不写sql语句 ibatis中写少量sql语句 DBUtils中写sql语句 它们的另一个相同点是 底层全都是jdbc o-\u0026gt; 结构对应 javabean中的 类，对象，属性 数据库中的 表，记录，字段 o-\u0026gt; hql hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用 o-\u0026gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean 使用 # 1.导入核心包(10 + 1个) hibernate3.jar # 核心包 c3p0-0.9.1.jar antlr-2.7.6.jar # 转换hql到sql commons-collections-3.1.jar # apache的集合增强包 dom4j-1.6.1.jar javassist-3.9.0.GA.jar # 动态代理 jta-1.1.jar # java transaction api 处理事务用 slf4j-api-1.5.8.jar log4j.jar slf4j-log4j12.jar # 三个日志 + mysql-connector-java-5.1.7.bin.jar 2.建立目录 hibernate.dao demo.java hibernate.db xx.sql hibernate.domain xx.java hibernate.util HibernateUtil.java 3.创建映射文件 xx.java文件的同目录下，创建 xx.hbm.xml 4.创建配置文件 src/hibernate.cfg.xml (可变) src/hibernate.properties 5.写提供hibernate session的工具类 HibernateUtil 6.demo中用hibernate session创建事务进行数据库操作 demo.java session # 查询不需要事务，其它都需要事务 流程 Session session = HibernateUtil.getSession(); Transaction t = session.getTransaction(); t.begin(); session.update(hero); session.delete(hero); t.comment(); 批量 t.begin(); session.save(hero); t.commit(); session.clear(); 查询 Query query = session.createQuery(hql); List\u0026lt;Hero\u0026gt; heroList = query.list(); 查询2 Query query = session.createQuery(hql); query.setString(0,name); // hql中参数从0开始 query.setString(1,des); Hero hero = (Hero) query.uniqueResult(); // 只有一个结果时使用 修改 Query query = session.createQuery(hql); int i = query.executeUpdate(); 结尾 }catch(Exception e){ e.printStackTrace(); t.rollback(); }finally{ HibernateUtil.closeSession(); // session.close(); } session 元素的状态 # oid: object id,hibernate 的id值唯一并且与表中的数据一一对应 ## hibernate中分辨数据只看oid 临时（new），无oid,不在session中.生成sql语句 持久化（persistence object）：session.save(hero),有oid,在session中;(saveOrUpdate(hero)) 游离：session.evict(hero),有oid,不在session中,session.update(hero)重新持久化 删除：sesssion.delete(hero),有oid,不在session中,不可恢复,提交后可修改数据库 # 隐含将po对象转成持久化状态，并生成delete语句。提交后成delete状态，执行语句 ## 临时、持久、游离都可以调用 ## 临时调用delete时会删除数据库中相应id的值 ，危险 函数 get 与 load session.get(hero.class,1),从数据库得到持久状态对象 与数据库交互 查到时返回po 查不到时返回null session.load(hero.class,1) 不与数据库交互,返回自己创建的po(只有id) 访问非id值的时候，与数据库交互 session.clear() # session中的引用变量清空 session.close() # clear() + 关闭session对象，回收资源，但session非空 session.isOpen() session.flush() # 对session中的更改部分生成相应的sql语句,只在session中，不访问数据库 session.update() # 只是将游离重新持久化,不产生sql语句。（执行更新语句时加上它增加可读性） ## update()方法执行时会检验一级缓存（session）中是否有 oid相同的po ## ,同时会连接数据库，查询一级缓存中po与数据库中记录的一一对应关系 session.commit() # flush() + 提交事务 hibernate.cfg.xml # 必要性 必须配置 目录与文件名 任意，建议 src/hibernate.cfg.xml 源码中的案例文件： \\project\\tutorials\\web\\src\\main\\resources\\hibernate.cfg.xml \\project\\etc\\hibernate.cfg.xml 约束文件位置 hibernate3.jar/org/hibernate/hibernate-configuration-3.0.dtd 数据库连接属性与方言属性的属性名和值可以查找 \\project\\etc\\hibernate.properties # 由于xml文件中配置要覆盖的是hibernate.properties文件中的属性 ## 所以属性内容从hibernate.properties文件的属性中查找 方言类的位置是：hibernate3.jar/org.hibernate/dialect/中查找到相应的类， 这是最终的路径，（oracle的通用方言类的类路径 可以用这种方法找到，hibernate.properties配置文件中没有写） 加载 该配置文件属于纯人为配置，需要在Configuration类的实例中调用addResource(\u0026quot;\u0026quot;)方法加载 addResource()方法中的参数是本配置文件相对于src/目录的全限定名 作用 1.映射数据库 2.配置 类-表映射 资源xml文件的路径 内容 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE hibernate-configuration PUBLIC \u0026quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN\u0026quot; \u0026quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\u0026quot;\u0026gt; \u0026lt;hibernate-configuration\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;!-- 配置访问数据库需要的属性 --\u0026gt; \u0026lt;property name=\u0026quot;connection.driver_class\u0026quot;\u0026gt;oracle.jdbc.driver.OracleDriver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.url\u0026quot;\u0026gt;jdbc:oracle:thin:@localhost:1521:orcl\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.username\u0026quot;\u0026gt;scott\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;connection.password\u0026quot;\u0026gt;tiger\u0026lt;/property\u0026gt; \u0026lt;!-- 配置方言 通知hibernate访问哪种数据库的语法结构--\u0026gt; \u0026lt;property name=\u0026quot;dialect\u0026quot;\u0026gt;org.hibernate.dialect.OracleDialect\u0026lt;/property\u0026gt; \u0026lt;!-- 类表映射文件 --\u0026gt; \u0026lt;mapping resource=\u0026quot;hibernate/domain/Hero.hbm.xml\u0026quot;/\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt; hibernate.properties # 必要性 不必须配置 位置： 该文件的位置在src/目录下是不可以改变的，是hibernate加载配置的入口 源码中的参考文件： /project/etc/hibernate.properties # oracle的通用驱动可以从hibernate3.jar/org.hibernate/dialect包中查找 作用 1.配置连接的数据库，更换数据库只需要更改配置文件即可 2.配置数据库方言 3.其它控制开关 方言的作用 更换数据库访问形式，实现通用性 内容 hibernate.dialect org.hibernate.dialect.MySQLDialect hibernate.connection.driver_class com.mysql.jdbc.Driver hibernate.connection.url jdbc:mysql:///outrun hibernate.connection.username outrun hibernate.connection.password asdf hibernate.show_sql true # 开关：显示实际操作数据库的sql语句 自动创建表 hibernate.hbm2ddl.auto=create # 每次都创建 hibernate.hbm2ddl.auto=update # 没有时再创建(有但是结构不同时会按照酌情增加列字段) ## 当更新或插入记录不满足条件时会出错 缓存 hibernate.cache.provider_class # 开启二级缓存中的普通区 hibernate.cache.use_query_cache # 开启二级缓存中的查询区 HibernateUtil # 目的 对SessionFactory返回Session的方式进行了重构，通过调用该静态工具方法 实现只有一个SessionFactory实例，由它产生和销毁很多Session的工厂机制。 缓存 SessionFactory 是二级缓存 Session 是一级缓存 # 查询时，先在二级缓存中查找，没有数据时查找一级缓存，最后查询数据库 # 缓存中的数据会用镜像联系着数据库，如果数据库有更新，缓存中的数据会自动更新 SessionFactory对象与Session对象 SessionFactory:只创建一次，重量级对象，线程安全，可以共享，实例变量，开始时创建 Session:创建多次，轻量级对象，线程不安全，不可以共享，局部变量，临时创建 实现代码 /** * 提供hibernate session * 并且用threadLocal跟踪实现无参删除 * * @author Administrator * */ public final class HibernateUtil { // 单例的SessionFactory工厂 private static SessionFactory sessionFactory; // 单例的ThreadLocal\u0026lt;Session\u0026gt;实例，但是每个调用者都有自己独有的方法？ private static ThreadLocal\u0026lt;Session\u0026gt; threadLocal; /** * 解析配置文件（properties,xml）到hibernate 的配置JavaBean,常驻内存 * */ static{ // 在这里加载了hibernate.properties配置文件（这里可以配置数据库），执行其它配置 // 相当于jdbc中的DriverManager类（如果配置了数据库，相当于也注册了连接数据库的类文件 【Class.forName(\u0026quot;..Driver\u0026quot;)语句 ..Driver 新建实例的时候自动向DriverManager注册自己】） Configuration config = new Configuration(); // 这里写xml配置文件对于src/目录的相对路径,加载映射用xml文件 config.addResource(\u0026quot;hibernate.hbm.xml\u0026quot;); // 加载src/目录下的hibernate.cfg.xml配置文件 config.configure(); # configure(\u0026quot;classpath:hibernate.cfg.xml\u0026quot;); 1.configure方法中可以加路径 2.classpath:代表src/目录 // 导入org.hibernate.SessionFactory类而非org.hibernate.classic.SessionFactory类 sessionFactory = config.buildSessionFactory(); } /** * 从单例工厂中得到被跟踪定位(每个调用者)的Session对象,没有就创建 * * @return */ public static Session getSession(){ /* 根据不同的调用者返回跟踪的不同的Session对象,如果是第一次调用，就创建新的session，绑定到单例的ThreadLocal对象中记录，返回给调用者 * 如果不是第一次调用 ，也能返回让其得到原来为它创建的Session对象 */ Session session = threadLocal.get(); if(session == null){ session = sessionFactory.openSession(); threadLocal.set(session); } return session; } /** * 删除调用者在ThreadLocal实例中的跟踪记录，并且关闭该Session实例 * */ public static void closeSession(){ Session session = threadLocal.get(); if(session != null){ session.close(); threadLocal.remove(); } } } hql # hql特性 1.hql是hibernate专用，有专用的技术转换hql到sql,但降低效率 2.hql完全面向对象,只出现类，属性，操作符和关键字,例如sum(),order by 而sql是面向关系的语言 使用语句 Query query = session.createQuery(hql); Customer c = (Customer)query.uniqueResult(); # 只返回一条结果 List\u0026lt;Customer\u0026gt; list = query.list(); # 返回多条结果 常用 api session.createQuery() session.getNamedQuery() # 从映射文件中加载\u0026lt;query\u0026gt;标签配置的与\u0026lt;class\u0026gt;标签同级的hql语句 query.setString(\u0026quot;\u0026quot;,\u0026quot;\u0026quot;) Object o = query.uniqueResult(); List list = query.list(); 分页 query.setFirstResult(0); # 开始标号 setMaxResults(3); # 最多显示的条数 query语句 习惯用别名替代类名 # from后面出现的是类名，where中比较的是对象属性（已经在映射文件中映射到了表名与字段名） 占位符 冒号占位符 \u0026quot;from Customer c where c.name = :cname\u0026quot; query.setString(\u0026quot;cname\u0026quot;,\u0026quot;司马懿\u0026quot;); 问号占位符 \u0026quot;from Customer c where c.name = ?\u0026quot; query.setString(0,\u0026quot;司马懿\u0026quot;); 映射文件中分离hql语句 # \u0026lt;query\u0026gt;标签与\u0026lt;class\u0026gt;标签同级 \u0026lt;Query name=\u0026quot;findCustomerByAge\u0026quot;\u0026gt; \u0026lt;![CDATA[ from Customer c where c.age \u0026lt; ? ]]\u0026gt; Query query = session.getNamedQuery(\u0026quot;findCustomerByAge\u0026quot;); query.setInteger(0,60); 查询 \u0026quot;from Customer where id = 1\u0026quot; \u0026quot;from Customer as c where c.name = '司马懿' \u0026quot; \u0026quot;from java.lang.Object\u0026quot; # 映射中没有，写类的全称。查找 src/hibernate.cfg.xml中加载到内存中的映射的类对应的表中的所有记录 \u0026quot;from Order o order by o.price desc\u0026quot; 投影查询 1.\u0026quot;select c.name,c.age from Customer c \u0026quot; List\u0026lt;Object[]\u0026gt; list = query.list(); # Object[]中存储的是查询的select 语句中的数值 for(Object [] o : list){ System.out.println(o[0]); System.out.println(o[1]); } 2.\u0026quot;select count(o), sum(o.price),min(o.price) from Order o\u0026quot; # count()中的是表类名，统计实例数，查询Order表记录对象的个数 3.\u0026quot;select o.customer.id from Order o\u0026quot; 用到过的hql 级联抓取 FROM Role r LEFT JOIN FETCH r.privilegeSet WHERE r.id = :id 级联抓取顶级权限表（去重复） SELECT DISTINCT p FROM Privilege p LEFT JOIN FETCH p.childrenSet WHERE p.parent IS NULL 级联抓取角色 FROM Account a LEFT JOIN FETCH a.roleSet WHERE a.id = :id 三级级联抓取 # 对抓取的集合也可以直接抓取下一层 FROM Account a LEFT JOIN FETCH a.roleSet r LEFT JOIN FETCH r.privilegeSet WHERE a.login = :login AND a.pass = :pass 案例 # 编码 hibernate用用户操作系统的编码作为自己的编码 mysql5.5中设置编码：根目录下my文件 default-character-set=gbk 查询 # hibernate的查询方式 1.session.get(字节码,1) 2.session.load(字节码,1) 3.HQL查询session.createQuery() session.getNamedQuery() # 后面是从配置文件中载入hql语句 4.对象导航，如多表映射中 # 以对象的形式操作数据库中的表，如 ## p是person表的一个对象，c是card（身份证表）表的一个对象，p通过配置外键时定义的属性card得到自己的身份证表对象 ## 1.从表对象中：Card c = p.getCard(); ## 2.从hql语句中：select o.customer.id,o.customer.name,sum(o.price) from Order o group by o.customer.id 5.createSQLQuery原生sql语句查询： # 不要用，用了以后 hibernate跨平台的特性就没有了 String sql = \u0026quot;select {a.*} from sysgroup {a} where department regexp ?\u0026quot;; Query query = session.createSQLQuery(sql).addEntity(\u0026quot;a\u0026quot;,SysGroup.class); # addEntity将表的别名与类字节码关联起来（否则返回的表字段数据是Object类型,jsp页面读取时会出错） 连接查询的hql语法 # 只能连接有外键关系的表类，用表类中的关系类来表示第二张表，不能用笛卡尔积查询 ## 也就是说只能查一个表类 注意 hql连接查询的语法中用where替代了sql语法中的on 外连接与 sql不同，只能查询与一个表类有关系的外连接表（from语句后面不能写两个表类） 内连接 from Customer c join c.orderSet o where c.id = o.customer.id 外连接 # 这里与 sql不同，只能查询与一个表类有关系的外连接表 select c.name,count(o.orderno) from Customer c left join c.orderSet o group by c.name; 自连接 select a.name, b.name from emp a, emp b where a.mgr=b.id; 多表映射 # 主控方 # 就是只有主控方的操作成立，非主控方的改变忽略 inverse=\u0026quot;true\u0026quot; # false:主表管理，主表插入成功后，再发送n条更新语句来更新外键 ## true:从表管理，自己插入时加上：自己javabean中存放的外键关联 # 所以购物项中要关联购物车，由于购物车中已经一对多购物项，所以形成了双向关联 有该属性的标签 \u0026lt;set\u0026gt; 缺少主控方出现的问题 双向一对多中 1.hibernate生成的sql语句产生重复 2.主键冲突 # 插入操作时，由于“一”表级联插入“多”表，“多”表也要插入自己，它们的主键是相同的，会引起主键冲突 级联 # 数据库只有级联删除 cascade=\u0026quot;save-update\u0026quot; # 插入和更新 # 一般使用save-update，因为表一般软删除，（更新也没有，因为主键不更新，但是hibernate没有单save） cascade=\u0026quot;delete\u0026quot;; # 删除订单，级联删上层客户 cascade=\u0026quot;none\u0026quot; # 什么都不做（默认） cascade=\u0026quot;all\u0026quot; # save-update + delete 有级联属性的标签 class标签下的 \u0026lt;set\u0026gt; \u0026lt;one-to-one\u0026gt; \u0026lt;many-to-one\u0026gt; 注意 级联插入的子表的id内容要为空，否则会变成级联更新 # 这里和单个数据插入时设置对象的id属性不起作用【只有hibernate的主键增长策略起作用】是不同的 单向一对多 # 集合映射的一种 “一”的类中 private Set\u0026lt;Order\u0026gt; orderSet = new LinkedHashSet\u0026lt;Order\u0026gt;(); 映射xml文件中 \u0026lt;!-- set标签用于映射单向一对多 name表示单方的关联属性 table表示多方对应表的名字 key-column表示多方对应表的外健 one-to-many-class表示单方关联属性中的每个元素的类型 --\u0026gt; \u0026lt;set name=\u0026quot;orderSet\u0026quot; table=\u0026quot;ORDERS\u0026quot; cascade=\u0026quot;all\u0026quot;\u0026gt; \u0026lt;key column=\u0026quot;CUSTOMERS_ID\u0026quot;/\u0026gt; \u0026lt;one-to-many class=\u0026quot;Order\u0026quot;/\u0026gt; \u0026lt;/set\u0026gt; 单向多对一 # 常用 映射xml文件中 \u0026lt;!-- many-to-one映射多方的关联属性 name表示多方的关联属性名 column表示多方对应表的外健(存储关联类对应表的主键) cascade 级联 lazy表示“一”的类数据是否在一开始的时候就查询 # 如果lazy=\u0026quot;proxy\u0026quot;【相当于懒加载】，action类中加载“一”方数据时会出错，因为调用service类结束后线程中的session销毁,延迟加载找不到session会失败 fetch表示抓取策略 # 这里产生了hibernate的n+1问题：一条查询语句查出\u0026quot;一\u0026quot;的集合，n条查询语句查出集合中每个元素的一 join代表用join语句查询(一条语句),但是hibernate在多对一的时候不支持fetch=\u0026quot;join\u0026quot; 默认是select，每次查询用一条select语句（多条语句） 解决：自己写新的查询方法查询,执行hql如：FROM Category c LEFT JOIN FETCH c.account --\u0026gt; \u0026lt;many-to-one name=\u0026quot;customer\u0026quot; column=\u0026quot;CUSTOMERS_ID\u0026quot; cascade=\u0026quot;all\u0026quot; /\u0026gt; 双向一对多 # 双向映射就存在主控方的问题 ##　主表从表（外键【可以为空】） ## 集合映射的应用 1.同时配置单向一对多与单向多对一 2.在\u0026quot;一\u0026quot;表中配置inverse=\u0026quot;true\u0026quot;,反转权力，“多”表为主控方 双向一对一 # 主表从表（从表id既是主键又是外键） ## 双方都是主控方 1.两表都配置\u0026lt;one-to-one/\u0026gt; 2.主表配置cascade 3.从表中constrained=true属性（主键是否同时为外键约束） 多对多（单向左到右，单向右到左，双向） # 集合映射的应用 ## 多对多关系中一定要有主控方，否则主键冲突问题 1.创建中间表 # 中间表可以没有自己的JavaBean类文件对应，这时默认有联合主键（联合主键分别是保存的两个外键） students_id teachers_id # student_id 与 teachers_id为联合主键 ## sql语句是primary key(student_id,teacher_id); 创建中间表原因： 之所以中间表是因为两边的表中主键唯一，所以不能在一个记录中对对应另一个表的多个记录 中间表相当于把多对多分成两个一对多。 2.表对象类中都有对方表的set集合 3.映射xml中 # 可以用inverse,cascade ## cascade=\u0026quot;none\u0026quot;时,middle表中的记录也会被删除 ## 不配置主控方的话一边更新另一边，另一边也更新自己，会出错 \u0026lt;set table=\u0026quot;MIDDLES\u0026quot; name=\u0026quot;teacherSet\u0026quot;\u0026gt; \u0026lt;key columnet=\u0026quot;STUDENTS_ID\u0026quot;/\u0026gt; \u0026lt;many-to-many class=\u0026quot;Teacher\u0026quot; column=\u0026quot;TEACHERS_ID\u0026quot;/\u0026gt; 4.dao中 在cascade=\u0026quot;all\u0026quot;的配置下实现只删除老师与middle表中的教学关系 # 手工解除关系 # 不手工解除关系的话， 表记录对象：Teacher t1 ，t1删除时,级联删除middle表中数据，middle表中对应了学生的外键 ，由于多对一级联，会删除学生，由于该学生的主键可能会被middle表中的其它记录作为外键引用，所以不能删除，删除时会出错。 查询1号老师对应的学生,并解除关系 Teacher t1 for(Student s: t1.getStudentSet()){ s.getTeacherSet().remove(t1); } 1号老师解除关系 t1.setStudentSet(null); session.delete(t1); 缓存 # 缓存 1.一级缓存(session)中的数据是独享的，二级缓存(sessionFactory)中的数据是共享的 2.一级缓存中的数据改变时会更新二级缓存(如果二级缓存设置为read-only时，会更新出错) 3.二级缓存默认不能存po(持久化对象) ，只存放连接数据库的信息和映射文件 # 这时查询数据时的顺序是 一级缓存 -\u0026gt; 数据库 启用二级缓存 # 开启的二级缓存中可以保存po ## 二级缓存的两个空间：普通缓存区(get、load)、查询缓存区(query对象查询) 普通缓存区 hibernate.properties文件中配置 hibernate.cache.provider_class org.hibernate.cache.HashtableCacheProvider # 只能内存缓存 org.hibernate.cache.EhCacheProvider # 也能磁盘缓存ehcache的jar包中ehcache-failsafe.xml配置文件中可以查到默认缓存配置 # 可以在hibernate的中文官方教程中查到缓存策略提供商的类 ## hibernate3.2之前缓存类jar包是集成的，默认是EhCache ## hibernate3.2之后缓存类jar包要自己导入 ## ...Provider类并不是实现类，而是桥接类 cache.use_second_level_cache true # 开启二级缓存（默认是true,但是没有配置缓存提供商之前不开启） hibernate.cfg.xml文件中配置使用二级缓存的类 # 可以设置\u0026lt;cache\u0026gt;的标签\u0026lt;class\u0026gt;\u0026lt;set\u0026gt; ## 设置\u0026lt;set\u0026gt;时，set对应表类的也要设置\u0026lt;cache\u0026gt;标签 \u0026lt;class-cache usage=\u0026quot;read-write\u0026quot; class=\u0026quot;pojo.Goods\u0026quot; /\u0026gt; usage属性 read-only：二级缓存只读(只是不能进行修改，但是从表中读取数据时一级缓存可以向二级缓存中放入数据) read-write:可读写 查询缓存区（hql语句）：默认不开启 # 因为hql命中率低(要求hql语句相同才行，模糊查询每次基本不同),每次查找会到缓存，找不到再到数据库，查询完数据再存入缓存，效率低 ## 不配置的话查询还会存到缓存，但只提供get使用，hql自己不用 1.首先开启普通缓存区（设置了表类可以缓存） 2.在query对象中开启查询缓存区 query.setCacheable(true); 查询顺序：一级缓存 -\u0026gt; 二级缓存 -\u0026gt; 数据库 缓存提供商配置 ehcache缓存提供商 创建src/ehcache.xml配置文件，使用ehcache缓存时会自动加载其中的配置 \u0026lt;diskStore path=\u0026quot;java.io.tmpdir\u0026quot;/\u0026gt; # 设置缓存目录，java.io.tmpdir指操作系统的临时目录 diskPersistent diskExpiryThreadIntervalSeconds # 这两个集群中使用，上面是是否集群持久化，下面是设置持久化时间 maxElementsInMemory # 内存支持最大对象数目(溢出的对象会存到硬盘中) overflowToDisk # 内在到最大数目时是否缓存到硬盘 eternal # 缓存是否永久有效，如果为true，则timeToIdleSeconds与timeToLiveSeconds不起作用 timeToLiveSeconds # 内存中缓存最大存活时间，服务器启动的时间加入其中 timeToIdleSeconds # 缓存不被访问时最大存活时间 memoryStoreEvictionPolicy # 内存中对象的替换算法FIFO(先进先出first in first out) ## LRU(最近最未使用算法,最久没有被访问的对象踢出) ## LFU(最少未被使用算法,考虑了对象的访问频率,踢出最近最少被访问的对象) ## 是windows自己的替换算法 清空缓存 一级缓存：session.clear(); 二级缓存：sessionFactory.close(); 集合映射 # 作用 集合包含于表类中，对应其一个属性，相当于该类对应表的一个子表 每种集合对应一张表，内容对应记录。 把java类中经常使用的数据结构对应到表中 使用 javaBean（User）中 private Set\u0026lt;String\u0026gt; telSet = new LinkedHashSet\u0026lt;String\u0026gt;(); private List\u0026lt;String\u0026gt; cityList = new ArrayList\u0026lt;String\u0026gt;(); private Map\u0026lt;String,String\u0026gt; telCityMap = new LinkedHashMap\u0026lt;String,String\u0026gt;(); xml文件中 \u0026lt;set name=\u0026quot;telSet\u0026quot; table=\u0026quot;TELS\u0026quot;\u0026gt; \u0026lt;key column=\u0026quot;USERS_ID\u0026quot;/\u0026gt; # 外键列：集合所创建的表的外键列名 \u0026lt;element column=\u0026quot;TEL\u0026quot; type=\u0026quot;string\u0026quot;/\u0026gt; # 内容列：这里必需要有type # set中也可以把\u0026lt;element\u0026gt;标签换成\u0026lt;one-to-many class=\u0026quot;Order\u0026quot;/\u0026gt;标签来对应JaveBean作为值，这就是一对多的映射 \u0026lt;list name table\u0026gt; \u0026lt;key column/\u0026gt; \u0026lt;list-index column=\u0026quot;IDX\u0026quot;/\u0026gt; # 索引列：表中的索引号列(对应在list中的索引) \u0026lt;element column type/\u0026gt; \u0026lt;map name table\u0026gt; \u0026lt;key\u0026gt; \u0026lt;map-key type column\u0026gt; # map对应key的列 \u0026lt;element column type\u0026gt; dao中使用 user.getTelSet().add(\u0026quot;131\u0026quot;); 检索策略 # hibernate检索的两种类型 立刻检索:session.get,query.list \u0026lt;class lazy=\u0026quot;true\u0026quot;\u0026gt;标签中类的检索策略，get方法与list都不遵循 延迟检索:session.load # 初始时是代理对象,使用时查询 只有load方法遵循\u0026lt;class lazy=\u0026quot;true\u0026quot;\u0026gt;标签中类的检索策略 检索方法是load时 lazy属性出现在\u0026lt;class\u0026gt;与\u0026lt;set\u0026gt;标签中,两个标签中lazy属性的含义是不同的，两个lazy属性都是对load方法执行时是否查询数据库进行设置。 # \u0026lt;class\u0026gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中除了set集合之外的所有属性 ## \u0026lt;set\u0026gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中set集合的数据 ## \u0026lt;class\u0026gt;中默认lazy属性的值为true ## \u0026lt;set\u0026gt;中默认lazy属性的值为true true true 时 查类时没有查集合 false true 时 查类时没有查集合 false false 时 查类时查集合 true false 时 查类时没有查集合 经验 # 删除的两种方法 session.delete(session.get(Category.class,id)); # 先查询再删除，效率低 session.createQuery(\u0026quot;delete Categroy c where c.id=:id\u0026quot;).setInteger(\u0026quot;id\u0026quot;,id).executeUpdate(); # 执行hql语句，效率高 hibernate注解 hibernate3.6支持注解 javaee5不支持，默认关闭 javaee6支持，默认开启，此时不加载注解配置文件会报错，所以要关掉 hibernate.cfg.xml中 \u0026lt;property name=\u0026quot;javax.persistence.validation.mode\u0026quot;\u0026gt;none\u0026lt;/property\u0026gt; DB Browser反射编译表的生成映射文件和类的时候，会生成项目目录下hibernate.reveng.xml的临时配置文件，可以删掉 映射文件class属性 dynamic-update=\u0026quot;true\u0026quot; # 动态更新，只有对相同的session有效，而且性能不好 ## 用字段设置中的update=\u0026quot;false\u0026quot;（对象中有字段值时更新，没有时不更新）属性来设置动态更新 映射文件set标签属性 Order-by=\u0026quot;id\u0026quot; # set中级联对象按照\u0026quot;id\u0026quot;属性进行排序 c3p0 # c3p0并不是hibernate默认的连接池（默认的是hibernate自带的连接池算法） 配置c3p0以后自动关闭Hibernate自带的连接池，而使用c3p0连接池 hibernate.cfg.xml文件中 \u0026lt;!-- 最大连接数 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.c3p0.max_size\u0026quot;\u0026gt;20\u0026lt;/property\u0026gt; \u0026lt;!-- 最小连接数 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.c3p0.min_size\u0026quot;\u0026gt;5\u0026lt;/property\u0026gt; \u0026lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.c3p0.timeout\u0026quot;\u0026gt;120\u0026lt;/property\u0026gt; \u0026lt;!-- 最大的PreparedStatement的数量 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.c3p0.max_statements\u0026quot;\u0026gt;100\u0026lt;/property\u0026gt; \u0026lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--\u0026gt; \u0026lt;property name=\u0026quot;hibernate.c3p0.idle_test_period\u0026quot;\u0026gt;120\u0026lt;/property\u0026gt; \u0026lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.c3p0.acquire_increment\u0026quot;\u0026gt;2\u0026lt;/property\u0026gt; \u0026lt;!-- 每次都验证连接是否可用 --\u0026gt; \u0026lt;property name=\u0026quot;hibernate.c3p0.validate\u0026quot;\u0026gt;true\u0026lt;/property\u0026gt; hibernate.properties文件中 hibernate.c3p0.min_size=5 hibernate.c3p0.max_size=20 hibernate.c3p0.timeout=1800 hibernate.c3p0.max_statements=50 映射 # hbm.xml 位置与名称： domain.xx.java 文件同级目录 xx.hbm.xml 约束文件位置 hibernate3.jar/org/hibernate/hibernate-mapping-3.0.dtd 从其中复制约束头 源码中的案例文件 \\project\\tutorials\\中搜索 hbm.xml 类-表映射的特点 1.映射JavaBean到表字段（动态占位符），可以使用面向对象的hql语名生成sql语句 2.session中保存类对象，缓存查询过的表的内容 3.在映射关系的xml文件中可以设置主键的改变方式（这样以后dao类中设置的主键内容被配置文件中的设置覆盖） 主键 表中的主键 自然主键：有业务逻辑含义的字段（如name）（多个自然主键：联合主键） 代理主键 hibernate中id的增加类型 increment 整型,不依赖数据库自增,多线程不安全 uuid 缺点：占空间 identity 整型，依赖数据库自增,线程安全 sequence 专用于oracle数据库,要用特定名字的序列，create sequence hibernate_sequence;线程安全 native(重点) 根据情况判断是identity或sequence assigned 自然主键：\u0026lt;id name=\u0026quot;name\u0026quot; column=\u0026quot;name\u0026quot;\u0026gt;,线程不安全 composite-id 多个自然主键,表的javaBean必须实现序列化(1.对象序列化到硬盘、数据库【其它JavaBean有id属性，hibernate自动实现序列化】2.线程间传递数据) \u0026lt;composite-id\u0026gt;\u0026lt;key-property name=\u0026quot;firstname\u0026quot; column=\u0026quot;firstname\u0026quot;/\u0026gt;\u0026lt;key-property name=\u0026quot;firstname\u0026quot; column=\u0026quot;lastname\u0026quot;/\u0026gt; 持久化对象的两种类型 实体型：具有id属性的类，映射成一条含有id主键的完整记录 值类型或组件：与上面相反(被实体型包含)，如 # 包含以后会把组件的属性添加到实体类属性的后面，一起当作一张表，仅此而已 # Address province city area 映射组件型属性 1.类中引用组件：private Address address 2.映射 \u0026lt;component name=\u0026quot;address\u0026quot; class=\u0026quot;Address\u0026quot;\u0026gt;\u0026lt;property name column/\u0026gt; 3.dao中 star.setAdrress(address); 内容 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE hibernate-mapping PUBLIC \u0026quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN\u0026quot; \u0026quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\u0026quot;\u0026gt; \u0026lt;hibernate-mapping package=\u0026quot;hibernate.domain\u0026quot;\u0026gt; \u0026lt;class name=\u0026quot;Hero\u0026quot; table=\u0026quot;heros\u0026quot; dynamic-insert=\u0026quot;true\u0026quot;\u0026gt; # 设置动态插入为true:如果是null的值，不再插入 ## 如果不设定动态插入，会插入数据库null值，数据库中设定的默认值不会起作用 \u0026lt;!-- hibernate通过自己内部的类型type=\u0026quot;\u0026quot;,来转换java类型与sql类型之间的转换，一般不必写，自动反射 --\u0026gt; \u0026lt;!-- id 是指主键，property是属性 --\u0026gt; \u0026lt;id name=\u0026quot;id\u0026quot; column=\u0026quot;id\u0026quot;\u0026gt; \u0026lt;!-- hibernate内部的主键生成器 --\u0026gt; \u0026lt;generator class=\u0026quot;increment\u0026quot;/\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; column=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;gender\u0026quot; column=\u0026quot;gender\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;age\u0026quot; column=\u0026quot;age\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;birthday\u0026quot; column=\u0026quot;birthday\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;des\u0026quot; column=\u0026quot;des\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/class\u0026gt; \u0026lt;/hibernate-mapping\u0026gt; javaBean 实现序列化接口 在有名为id属性的JavaBean中，hibernate会自动实现序列化接口 没有名为id属性的JavaBean中，需要我们自己实现序列化接口 public class Hero implements java.io.Serializable{ private Integer id; private String name; private String gender; private Integer age; private Date birthday; private String des; } "},{"id":87,"href":"/docs/pl/java/collection/","title":"Collection","section":"Java","content":" 基础 # 物理容器 数组 链表 Java容器 Collection List ArrayList Vector # JDK1.0，所有方法加synchronized Stack LinkedList CopyOnWriteList # 写时复制整个list, 写加锁读无锁, 无fail-fast Set HashSet LinkedHashSet SortedSet TreeSet EnumSet CopyOnWriteArraySet ConcurrentSkipListSet Queue # 相比List添加线程友好API Deque # 双端队列 ArrayDeque BlockingDeque LinkedBlockingDeque BlockingQueue # LockSupport实现, channel, 生产者消费者 SynchronousQueue # 锁实现, 无缓冲区channel TransferQueue # CAS, 生产者带队列阻塞 LinkedTransferQueue ArrayBlockingQueue # 有缓冲区channel DelayQueue # 内部维护按时间排序队列 PriorityBlockingQueue LinkedBlockingQueue # 最大数量Integer.MAX_VALUE PriorityQueue # 堆排序实现 ConcurrentLinkedQueue # CAS Map HashMap LinkedHashMap # 双向链表，按插入或访问顺序遍历 Hashtable # JDK1.0，所有方法加synchronized ConcurrentHashMap # CAS, 写慢、读快 ConcurrentSkipListMap # 有序, 没有concurrentTreeMap因为CAS红黑树难实现 TreeMap # 有序，红黑树, 查找效率高。 WeakHashMap IdentityHashMap 工具类 Collections synchronizedMap(Map) # 内部mutex加synchronized Queue # 方法 add() # 满了报异常 boolean offer() # 返回是否成功 boolean offer(long, TimeUnit) # 返回是否成功 poll() peek() element() # 同peek(), 但空时报错 remove() BlockingQueue # 方法 put() # 阻塞 take() # 阻塞 TransferQueue transfer() take() getWaitingConsumerCount() # 阻塞的消费者长度 "},{"id":88,"href":"/docs/pl/java/spring/","title":"Spring","section":"Java","content":" 基础 # 特点 容器, 也容纳管理了第三方框架 # 目的是解耦框架api 轻量级，模块化，无(少)侵入 IOC(inversion of control) 容器用工厂装配对象并管理, 面向接口编程 优点 降低代码量 容易测试 最小侵入性松耦合 方式 Setter 构造器 静态工厂、实例工厂 DI(dependency injection) 容器向类添加属性 # 反射，用带参构造或set方法 AOP(aspect oriented programming) # 继承是纵向组织，AOP横切入业务 # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用） 动态代理实现切入代码 权限控制 事务管理 记录日志 概念 连接点:普通方法 切入点:名称满足条件的连接点 增强（通知）类:服务对象 # 切入点与增强是多对多的 切面:切入点 + 增强类 # 我们切入的是横切面 目标对象（服务对象）：要注入的对象 通知 before # 执行前 after # 执行后 after-returning # 正常退出 after-throwing # 异常退出 around # 执行前后 代理对象(业务对象)：被注入的对象 模块 dao, orm, aop, jee, web, core 结构 核心容器(core container) Core # 最底层，资源访问，类型转换 Beans # IOC, DI, BeanFactory Context # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播 EL # 表达式语言 AOP, Aspects # Aspects对AspectsJ集成, 功能多于spring asp 数据访问/集成 JDBC ORM OXM # object xml 映射 JMS # 消息与异步通信 事务 Web/Remoting Web # ioc窗口，rmi, hessian,burlap, web service Web-Servlet Web-Struts Web-Porlet # portal认证 Test 设计模式 代理 目标对象实现接口，使用Proxy 未实现接口，使用CGLIB 单例 bean默认单例 模板, 解决代码重复问题 RestTemplate, JmsTemplate, JpaTemplate 控制器 DispatherServlet对请求分发 视图帮助(view helper) 提供jsp标签、高效宏 帮助在视图中写代码 依赖注入 BeanFactory, ApplicationContext核心理念 工厂 BeanFactory 循环依赖问题 构造器, 正在创建在Bean池标记，创建完删除标记，标记冲突报错 # 所以用@Autowired决定注入时机，不写在构造方法里 单例， 三级缓存, 提前暴露使双方都可初始化 setter, 提前暴露bean 版本 2.5 注解 3.2 基于注解的注入测试类@RunW.. 使用 # jar包 ： 核心包：/dist/modules # 或是/dist中的spring.jar包 core模块 beans context context-support core 日志包：/lib/jakata-commons/commons-logging.jar 创建xml文件(最好在JavaBean的旁边) 绑定约束文件 /dist/resources/spring-beans-2.5.xsd copy xml文件的头：/sample/petclinic/war/web-inf/app...xml 创建JavaBean.java xml文件中配置bean # src下 \u0026lt;bean id=\u0026quot;\u0026quot; class=\u0026quot;\u0026quot;\u0026gt; # id值唯一,class指定 javaBean的类目录 \u0026lt;property name=\u0026quot;\u0026quot; value=\u0026quot;\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;\u0026quot; ref=\u0026quot;girlID\u0026quot;\u0026gt; # 引用类型，其中girlID为spring配置的bean Id 业务类中 ApplicationContext ac = new ClassPathXmlApplicationContext(new String [] {\u0026quot;配置xml文件路径\u0026quot;}) # 注意：ac创建时，其内部的JavaBean默认全部实例化一遍，并且全部注入了属性 ## 该容器不用关闭 if(ac.containsBean(\u0026quot;boyID\u0026quot;)){ Boy boy = (Boy)ac.getBean(\u0026quot;boyID\u0026quot;); } api # ApplicationContext是一个接口，表示spring容器/ioc容器 ClassPathXmlApplicationContext # 只从类路径中读取xml配置文件（src/目录下能访问的路径）省略src/目录 FileSystemXmlApplicationContext # 文件路径 ,从src/开始 ac.getBean(\u0026quot;boyID\u0026quot;) ac.containsBean(\u0026quot;boyID\u0026quot;) # 通过此方法去判断是否存在 ，而不是得到的是否为null ac.destroy() # ac中的bean实例全部销毁 BeanFactory # 基础IOC容器, 默认延迟初始化 DefaultListableBeanFactory ApplicationContext XmlBeanFactory # 根据xml中的定义加载bean Spring-DAO # 提供规范, 翻译框架(JDBC\u0026lt;Hibernate,JPA等)异常为DataAccessException @Repository 注解DAO类 Spring-JDBC # 模板类 DataSource JdbcTemplate JdbcDaoSupport # 对dao扩展, DataAccessExceptions异常翻译器 Spring-ORM # 统称，对各模块(JPA,JDO,Hibernate,iBatis,TopLink,OJB)实现了spring的集成类 把DataSource注入到SessionFactory或EntityManagerFactory等bean中 # jdbc不需要，因为jdbc直接使用DataSource HibernateTemplate HibernateDAOSupport # 继承它提供aop拦截器 Web # 在ApplicationContext基础上, 提供web上下文和面向web的服务 ApplicationContext # 以BeanFactory为基础,容器启动后默认全部初始化绑定 FileSystemXmlApplicationContext # 指定文件 ClassPathXmlApplicationContext # 从classpath找设置 WebXmlApplicationContext 注解 # applicationContext.xml \u0026lt;context:annotation-config/\u0026gt; \u0026lt;!-- 添加注解扫描功能,启动的时候哪些包要检查是否有注解 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;xxx\u0026quot; /\u0026gt; @Required # setter @Autowired # setter、构造方法、变量 @Qualifier(\u0026quot;dataSource) # 多类配置时，指定使用类 @Bean # 返回对象注册为bean @Configuration # bean定义 @Service # 添加类名小写的spring bean id 也可以@Service(value=\u0026quot;xx\u0026quot;)自定义id ## action类前换成@Controller @Service也是可以的 @Scope(value=\u0026quot;prototype\u0026quot;) # 工具类或其它组件类换成@Component 也可以@Service,如定时器TimerTask就是组件 @Resource # 按属性名注入资源 测试类 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = \u0026quot;classpath:applicationContext*.xml\u0026quot;) @PostConstruct # 类加载时运行的方法，相当于xml中配置的init-method @PreDestroy # 类销毁前运行的方法 aop applicationContext.xml \u0026lt;aop:aspectj-autoproxy/\u0026gt; @Aspect # 注册一个类为切面 @Pointcut(value=\u0026quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))\u0026quot;) # 配置切点表达式 private void testAop(){} @AfterReturning(pointcut=\u0026quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))\u0026quot;) # 配置通知，在通知中配置切点 @AfterReturning(value=\u0026quot;testAop()\u0026quot;) # 配置通知，使用已经配置的切点 @Around(value=\u0026quot;testAop()\u0026quot;) # 配置通知，使用已经配置的切点 @Around(value=\u0026quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.queryByWord(..))\u0026quot;) # 配置通知，在通知中配置切点,注意这里没有pointcut,只有value 模块 # 监听器 # 原理 org.springframework.web.context.ContextLoaderListener中 this.contextLoader.initWebApplicationContext(event.getServletContext()); # 加载Spring 的配置文件 ，加载Application内置对象中 initWebApplicationContext方法中 this.context = createWebApplicationContext(servletContext, parent); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); # 创建并存储spring的application内置对象到ServletContext中，属性名称是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE createWebApplicationContext方法中 wac.setConfigLocation(sc.getInitParameter(CONFIG_LOCATION_PARAM)); # 该类文件中有：public static final String CONFIG_LOCATION_PARAM = \u0026quot;contextConfigLocation\u0026quot;; # 获得web.xml中配置的context-param初始化参数：contextConfigLocation的内容，并加载spring配置文件 使用 servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext) properties # spring xml配置文件中使用properties配置的属性 配置一个bean的class类是org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer的单例bean \u0026lt;property name=\u0026quot;locations\u0026quot; value=\u0026quot;classpath:public.properties\u0026quot; \u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;classpath:conn.properties\u0026lt;/value\u0026gt; 或 \u0026lt;property name=\u0026quot;location\u0026quot; value=\u0026quot;classpath:conn.properties\u0026quot; /\u0026gt; xml文件中用\u0026quot;${driver}\u0026quot;的方式引用properties中配置的属性 java类中用spring的注解注入properties配置的属性 # 要求必须是spring管理的类 bean中的class类换成org.springframework.beans.factory.config.PropertiesFactoryBean id=\u0026quot;Xxx\u0026quot;其它相同 java类的属性或set方法上添加注解： @Value(\u0026quot;#{public.basePath}#{public.filePath}\u0026quot;) # 其中public 是上面配置的bean的id(xml文件中注入属性的话用不到id,所以没有配置) ## '#{}'代表引用属性 ## '.'可以用'[]'代替，如public[basePath] ## 字符串的拼接可以用+连接 # 第一次配置@Value的时候不会成功，改一次值再试就可以了 bean # 创建bean的顺序 xml中按配置顺序的先后 注解中按照字母的顺序 生命周期 配置中定义\u0026lt;bean\u0026gt;\u0026lt;/bean\u0026gt; 初始化 配置文件中init-method 实现org.springframework.beans.factory.InitializingBean接口 调用 销毁 配置文件中destroy-method 实现org.springframework.bean.factory.DisposeableBean scope # 默认singleton prototype # 每次产生新对象 singleton # 单例 request # 一个请求一个对象，只在ApplicationContext下有效 session # 一个session一个对象，只在ApplicationContext下有效 global-session # 一个全局session一个对象, 只在ApplicationContext下有效 内部bean \u0026lt;property\u0026gt;或\u0026lt;constructor-arg\u0026gt;中定义的\u0026lt;bean\u0026gt;,通常匿名 注入对象 \u0026lt;list\u0026gt; \u0026lt;set\u0026gt; \u0026lt;map\u0026gt; \u0026lt;props\u0026gt; # 键值都只能是string类型 自动装配 方式 no # 不自动装配，通过ref属性指定 byName 查找类中setter 容器中找id 报空指针 byType 容器中找类型 # 找到多个时抛异常 constructor byType带构造函数参数 autodetect 先试constructor, 再试byType 写法 \u0026lt;bean\u0026gt;属性autowire=\u0026quot;byName\u0026quot; @Autowired 类型自动装配 加上@Qualifier(value=\u0026quot;a\u0026quot;) @Resource(name=\u0026quot;a\u0026quot;)注解的name装配 byName装配 byType装配 配置 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xsi:schemaLocation=\u0026quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\u0026quot;\u0026gt; \u0026lt;bean id=\u0026quot;userDaoID\u0026quot; name=\u0026quot;\u0026quot; class=\u0026quot;cn.itcast.javaee.spring.bean.life.UserDao\u0026quot; init-method=\u0026quot;getSession\u0026quot; destroy-method=\u0026quot;closeSession\u0026quot; factory-method=\u0026quot;getUserDao\u0026quot; scope=\u0026quot;singleton\u0026quot; lazy-init=\u0026quot;false\u0026quot; parent=\u0026quot;userDaoID\u0026quot; abstract=\u0026quot;true\u0026quot; autowire=\u0026quot;no\u0026quot;\u0026gt; \u0026lt;constructor-arg type=\u0026quot;java.lang.Integer\u0026quot; index ref\u0026gt; \u0026lt;value\u0026gt;2013\u0026lt;/value\u0026gt; \u0026lt;constructor-arg type=\u0026quot;java.lang.Double\u0026quot;\u0026gt; \u0026lt;value\u0026gt;6000\u0026lt;/value\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;aa\u0026quot;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; ref=\u0026quot;dateID\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;telSet\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;11\u0026lt;/value\u0026gt; \u0026lt;property name=\u0026quot;cityList\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;property name=\u0026quot;telCityMap\u0026quot;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026quot;\u0026quot;\u0026gt; \u0026lt;value\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;property name=\u0026quot;\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/prop\u0026gt; 标签、属性分析 bean标签：代表一个JavaBean # 多个JavaBean配置时，先配置的先创建，先创建的后销毁 id：该JavaBean的唯一标识 name：可以和id一样用，但是name可以设置\u0026quot;/a\u0026quot;来绑定路径 class：该JavaBean的类路径 init-method：创建该JavaBean时运行的其中的方法 destroy-method：销毁该JavaBean时运行的其中的方法 # ClassPathXmlApplicationContext类的实例不监听销毁方法 ## 用AbstractApplicationContext中的close()与registerShutdownHook()方法 ## close()直接马上销毁，registerShutdownHook()方法会注册关闭钩子,监听容器的销毁 ## factory-method：创建该Bean的函数 得到接口实现类的方法 1.通过实现类的无参构造器 # 没有factory-method属性 2.没有无参构造器时，工厂静态方法创建实例 \u0026lt;bean id=\u0026quot;userDaoID\u0026quot; factory-bean=\u0026quot;daoFactoryID\u0026quot; factory-method=\u0026quot;getUserDao\u0026quot;\u0026gt; # class中的内容是工厂类，而非UserDao类，factory-method是工厂类中返回UserDao类的静态方法 3.没有无参构造器时，工厂非静态方法创建实例 \u0026lt;bean id=\u0026quot;daoFactoryID\u0026quot; class=\u0026quot;cn.itcast.javaee.spring.bean.create.type3.DaoFactory\u0026quot;\u0026gt; \u0026lt;bean id=\u0026quot;userDaoID\u0026quot; factory-bean=\u0026quot;daoFactoryID\u0026quot; factory-method=\u0026quot;getUserDao\u0026quot;\u0026gt; # 先实例化工厂（Spring 加载本xml文件默认实例化），然后静态方法的配置即可 scope：作用域 1.singleton（单例）是默认值，是单例的，会调用init destory方法 2.prototype（原型）每次创建一个实例， 调用init方法，但不调用destory方法（实例的维护 ：javase程序交给jvm,javaee程序交给服务器） lazy-init 1.false:为启动容器时立即创建一个实例 # singleton与prototype模式都会创建 2.true:启动时不加载,获取时创建 parent： 继承一个Spring bean(包含其中的所有属性) # javaBean类中不必有实际的继承关系（但是有继承关系则必要配置parent） abstract=\u0026quot;true\u0026quot; : 配置此Bean为抽象Bean autowire=\u0026quot;no\u0026quot;:自动装配，只能装配关联属性 # 还可以进行注解装配 byName 装配时根据bean中的每个属性名从spring中找id同名的bean,通过setter方法注入到该属性中 byType 根据bean中的每个属性的类型找到spring中映射该类型的bean进行装配,通过setter方法注入到该属性中 constructor 找满参构造器装载，构造器中的参数以byType方式注入 autodetect 先找构造器装载，再set方法注入。但实际使用中只能set方法注入 no 不注入 可以配置init-method与destroy-method属性来配置该bean创建和销毁时执行的方法 注入值 # 通过setter方法注入值 \u0026lt;constructor-arg type=\u0026quot;java.lang.Integer\u0026quot; index ref\u0026gt; \u0026lt;value\u0026gt;2013\u0026lt;/value\u0026gt; # 传入构造方法参数注入值，,位置不能颠倒，不调用setter方法 ## type是注入参数的类型，index是参数的标号，从0开始，ref是引用类型,有引用类型时不用\u0026lt;value\u0026gt;标签 \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;aa\u0026quot;/\u0026gt; # 基本类型直接赋值（包括包装类型与String） \u0026lt;property name=\u0026quot;name\u0026quot; ref=\u0026quot;dateID\u0026quot;/\u0026gt; # 引用类型,dateID是一个Spring Bean ## 可以直接引用Spring Bean 的id \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;\u0026lt;/value\u0026gt; # set集合 \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;\u0026lt;/value\u0026gt; # list集合 \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026quot;\u0026quot;\u0026gt; \u0026lt;value\u0026gt;\u0026lt;/value\u0026gt; # map集合 # 集合的值均可配置引用类型 \u0026lt;property name=\u0026quot;\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/prop\u0026gt; # 属性类型，只能配置基本类型 （包括包装类型与String） aop # 实现 # 基于Aspectj 原理 启动容器时，创建目标对象与代理对象 \u0026lt;aop:config/\u0026gt;加载完时,通过cglib创建目标对象的代理对象，运行时产生 程序员-代理对象-代理方法-目标对象-目标方法-代理对象 使用 写类文件 1.jar包 aspectjweaver.jar/aspectjrt.jar/cglib-nodep-2.1_3.jar(动态代理包) 2.配置xml文件头,保留aop \u0026lt;bean id class/\u0026gt; # 目标对象 \u0026lt;bean id=\u0026quot;serviceBeanID\u0026quot; class /\u0026gt; # 配置增强对象 \u0026lt;aop:config\u0026gt; # 相当于创建了代理对象 \u0026lt;aop:pointcut id=\u0026quot;xxxx\u0026quot; expression=\u0026quot;\u0026quot; /\u0026gt; # 切入点表达式：expression=\u0026quot;execution(public void addUser() throws java.lang.Exception)\u0026quot; ## 可以写成execution(public void 类名.*()),表示匹配所有方法 ## execution(* *(..)) 第一个*是返回值，第二个*是方法，..表示参数不限 ## 可以声明抛异常 ## 条件命名为xxxx,升级连接点到切入点 \u0026lt;aop:aspect ref=\u0026quot;serviceBeanID\u0026quot;\u0026gt; \u0026lt;aop:before method=\u0026quot;writeLog\u0026quot; pointcut-ref=\u0026quot;xxxx\u0026quot;/\u0026gt; # 前置增强，method是注入的方法，xxxx是增强的条件,只能写一个方法 \u0026lt;aop:after/\u0026gt; \u0026lt;aop:after-returning/\u0026gt; # 方法返回后执行 \u0026lt;aop:after-throwing/\u0026gt; # 抛出异常时执行 \u0026lt;aop:around/\u0026gt; # 环线，执行目标方法前、后都执行,出错则之后的函数不执行 public void both(ProceedingJoinPoint pjp){ # ProceedingJoinPoint是连接代理对象 与目标对象的桥梁 open(); pjp.proceed(); # 执行目标代码 close(); } # 目标方法出错，后置增强仍然执行,after-throwing执行，前置增强不执行,after-returning不执行 \u0026lt;aop:advisor advice-ref=\u0026quot;txAdvice\u0026quot; pointcut-ref=\u0026quot;xxxx\u0026quot;/\u0026gt; # 配置事务的切面 切入点表达式 execution(方法的修饰符 方法的返回值类型 方法所属的类 方法名 方法中参数列表 方法抛出的异常) 方法的修饰符： 支持通配符*，可省略 方法的返回值类型：支持通配符*，表示所有返回值，不可省 方法所属的类： 支持通配符*，可省略 方法名： 支持通配符*，表示所有方法，不可省 方法中参数列表： 支持通配符*，不可省 # *表示【一个】任意类型的参数 ## ..表示零个或一个或多个任何类型的参数【提倡】 execution(方法的返回值类型 方法名（方法中参数列表）） # 一般形式 例如: execution(public void add()throws Exception) execution(public void add(..)throws Exception) execution(public void add(*)throws Exception) execution(* cn.itcast.web.spring.aop.UserDao.add(..)) execution(* add()throws Exception) execution(public void *(..)throws Exception) execution(public void a*(..)throws Exception)：方法名以a字符开始 execution(public void *d(..)throws Exception)：方法名以d字符结束 execution(* add()) execution(* *(..)) 切点方法的编写 public void Xxx(JoinPoint joinPoint){ joinPoint.getTarget(); # 获取目标对象 joinPoint.getSignature(); # 获取当前连接点的方法信息 joinPoint.getArgs()[0]; # 获取当前连接点的第一个参数 .. } public Goods Yxx(ProceedingJoinPoint joinPoint){ Object object = joinPoint.proceed(); # 得到连接点的返回值 .. return goods; # 本切面返回的数据会作为切点返回的数据返回给调用它的函数 } dao # 使用 1.xml文件中 \u0026lt;!-- 配置C3P0连接池 --\u0026gt; \u0026lt;bean id=\u0026quot;comboPooledDataSourceID\u0026quot; class=\u0026quot;com.mchange.v2.c3p0.ComboPooledDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot; value=\u0026quot;com.mysql.jdbc.Driver\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot; value=\u0026quot;jdbc:mysql://127.0.0.1:3306/spring\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;initialPoolSize\u0026quot; value=\u0026quot;60\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;acquireIncrement\u0026quot; value=\u0026quot;5\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置JdbcTemplate --\u0026gt; \u0026lt;bean id=\u0026quot;jdbcTemplateID\u0026quot; class=\u0026quot;org.springframework.jdbc.core.JdbcTemplate\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;comboPooledDataSourceID\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置UserDao --\u0026gt; \u0026lt;bean id=\u0026quot;userDaoID\u0026quot; class=\u0026quot;dao.UserDao\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;jt\u0026quot; ref=\u0026quot;jdbcTemplateID\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; 2.Dao中 private JdbcTemplate jt; addUser() String sql = \u0026quot;\u0026quot;; Object [] params = {user.getUsername(),user.getPassword()} jt.update(sql,params); 批量： for(int i = 0; i \u0026lt; ids.length; i++){ sqls[i] = \u0026quot;\u0026quot;; } jt.batchUpdate(sqls); 查询一个 return (User)jt.queryForObject(sql,params,new RowMapper(){ public Object mapRow(ResultSet rs,int rowNum){ # rs是查询出来的结果集,rowNum是结果集的行号,从0开始 Integer id = rs.getInt(\u0026quot;id\u0026quot;); User user = new User(id); return user; } }); 查询多个 # query方法把RowMapper帮助类中返回的user分别加入到list中，返回一个list list = jt.query(sql,new RowMapper(){ public Object mapRow() .. return bean; }) 分页 String sql = \u0026quot;select * from users limit ?,?\u0026quot;; Object[] params = {0,3}; jt.query(sql,params,new RowMapper(){ 记录 jt.queryForInt(sql); 事务 # TransactionInterceptor transactionManager # 指定事务治理类 transactionAttributes # key方法名 value事务属性 注解 @Transactional(propagation = Propagation.REQUIRED) 手写 # TransactionDefinition Public class BankServiceImpl implements BancService{ Private BanckDao bankDao; private TransactionDefinition txDefinition; private PlatformTransactionManager txManager; public boolean transfer(Long fromId, Long toId, double amount) { TransactionStatus txStatus = txManager.getTransaction(txDefinition); boolean result = false; try { result = bankDao.transfer(fromId, toId, amount); txManager.commit(txStatus); } catch (Exception e) { result = false; txManager.rollback(txStatus); System.out.println(\u0026quot;Transfer Error!\u0026quot;); } return result; } } 手写 # TransactionTemplate public class BankServiceImpl implements BankService { private BankDao bankDao; private TransactionTemplate transactionTemplate; public boolean transfer(final Long fromId, final Long toId, final double amount) { return (Boolean) transactionTemplate.execute(new TransactionCallback(){ public Object doInTransaction(TransactionStatus status) { Object result; try { result = bankDao.transfer(fromId, toId, amount); } catch (Exception e) { status.setRollbackOnly(); result = false; System.out.println(\u0026quot;Transfer Error!\u0026quot;); } return result; } }); } } 配置 # TransactionInterceptor \u0026lt;bean id=\u0026quot;transactionInterceptor\u0026quot; class=\u0026quot;org.springframework.transaction.interceptor.TransactionInterceptor\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;transactionManager\u0026quot; ref=\u0026quot;transactionManager\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;transactionAttributes\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;transfer\u0026quot;\u0026gt;PROPAGATION_REQUIRED\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;bankServiceTarget\u0026quot; class=\u0026quot;footmark.spring.core.tx.declare.origin.BankServiceImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;bankDao\u0026quot; ref=\u0026quot;bankDao\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;bankService\u0026quot; class=\u0026quot;org.springframework.aop.framework.ProxyFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;target\u0026quot; ref=\u0026quot;bankServiceTarget\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;interceptorNames\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;idref bean=\u0026quot;transactionInterceptor\u0026quot;/\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 配置 # TransactionProxyFactoryBean \u0026lt;bean id=\u0026quot;bankServiceTarget\u0026quot; class=\u0026quot;footmark.spring.core.tx.declare.classic.BankServiceImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;bankDao\u0026quot; ref=\u0026quot;bankDao\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;bankService\u0026quot; class=\u0026quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;target\u0026quot; ref=\u0026quot;bankServiceTarget\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;transactionManager\u0026quot; ref=\u0026quot;transactionManager\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;transactionAttributes\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;transfer\u0026quot;\u0026gt;PROPAGATION_REQUIRED\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 配置 # tx空间 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:aop=\u0026quot;http://www.springframework.org/schema/aop\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xmlns:tx=\u0026quot;http://www.springframework.org/schema/tx\u0026quot; xsi:schemaLocation=\u0026quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\u0026quot;\u0026gt; \u0026lt;!--配置c3p0连接池--\u0026gt; \u0026lt;!-- 配置JdbcTemplate类 --\u0026gt; \u0026lt;!-- 配置Dao --\u0026gt; \u0026lt;!-- 配置jdbc事务管理器 --\u0026gt; \u0026lt;bean id=\u0026quot;dataSourceTransactionManagerID\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;comboPooledDataSourceID\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置事务增强(服务对象) --\u0026gt; \u0026lt;tx:advice id=\u0026quot;txAdvice\u0026quot; transaction-manager=\u0026quot;dataSourceTransactionManagerID\u0026quot;\u0026gt; \u0026lt;tx:attribute\u0026gt; \u0026lt;tx:method name=\u0026quot;addUsers\u0026quot; # 可以用通配符\u0026quot;*users\u0026quot; propagation=\u0026quot;required\u0026quot; # 传播行为：事务开始、结束的时间。required 保证方法执行时事务已开始，事务开始时不创建，没有开始时创建 isolation=\u0026quot;default\u0026quot; # 隔离级别 timeout=\u0026quot;-1\u0026quot; # 事务超时,-1代表不超时，用数据库底层的配置 rollback-for:\u0026quot;java.lang.Exception\u0026quot; # 何时回滚 read-only=\u0026quot;false\u0026quot; # 不只读 # name 方法名的匹配模式 # required : 外部存在事务，则加入外部事务，不存在则新建事务 # requires_new : 总是新建事务 # mandatory : 外部必须存在事务 # never : 外部不能存在事务 # supports : 外部存在则加入，不存在则不以事务方式运行 # not_supported : 总是非事务 # nested : 外部存在事务，嵌套执行，不存在则新建 # no-rollback-for 以逗号分隔异常，这些异常不会导致事务回滚 # rollback-for 导致事务回滚的异常 /\u0026gt; \u0026lt;tx:attribute\u0026gt; \u0026lt;!-- 配置AOP --\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026quot;xxxx\u0026quot; expression=\u0026quot;execution(public void *Users(..))\u0026quot;/\u0026gt; ## 任意公共方法的执行： execution(public * *(..)) 任何一个以“set”开始的方法的执行： execution(* set*(..)) AccountService 接口的任意方法的执行： execution(* com.xyz.service.AccountService.*(..)) 定义在service包里的任意方法的执行： execution(* com.xyz.service.*.*(..)) 定义在service包和所有子包里的任意类的任意方法的执行： execution(* com.xyz.service..*.*(..)) 定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行： execution(* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))\u0026quot;) \u0026lt;!-- 将事务代码切入点addUser()方法中，从而产生事务 --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;txAdvice\u0026quot; pointcut-ref=\u0026quot;xxxx\u0026quot;/\u0026gt; \u0026lt;/aop:config\u0026gt; spring mybatis # 基础 #与$ #相当于解析成引号, 防止sql注入 $变量引用, 不能防止sql注入，用于传入表名之类 特点 sql易维护，传参方便 orm Mapper接口 方法名与配置id相同 输入输出参数类型对应定义的parameterType类型和resultType类型 类路径是配置的namespace 缓存 # 基于PerpetualCache的HashMap 一级缓存 存在本地 作用域为session, session flush后清空 二级缓存 可定义存储服务 作用域为namespace 配置 \u0026lt;cache/\u0026gt; readOnly=\u0026quot;true\u0026quot; 时，缓存实例单例，false时返回缓存拷贝 更新 create, update, delete后，作用域下所有select缓存clear 与hibernate区别 都通过SessionFactoryBuilder从配置生成SessionFactory, 再生成Session 都支持jdbc和jta mybatis可细致优化sql, hibernate移植性好 mybatis学习成本低 mybatis本身缓存不好，hibernate对象维护和缓存好 hibernate dao层封开发简单(不用维护映射)，crud方便 使用 编程 创建SqlSessionFactory 创建SqlSession 执行数据库操作 session.commit() session.close() 导入ibatis jar包 配置文件 SqlMap.properties # 属性名可以修改 driver=oracle.jdbc.driver.OracleDriver url=jdbc:oracle:thin:@127.0.0.1:1521:orcl username=root password=root SqlMapConfig.xml # 总配置文件 \u0026lt;sqlMapConfig\u0026gt; \u0026lt;properties recource=\u0026quot;SqlMap.properties\u0026quot;/\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;\u0026gt; \u0026lt;dataSource type=\u0026quot;SIMPLE\u0026quot;\u0026gt; \u0026lt;property value=\u0026quot;${driver}\u0026quot; name=\u0026quot;JDBC.Driver\u0026quot;/\u0026gt; \u0026lt;property value=\u0026quot;${url}\u0026quot; name=\u0026quot;JDBC.ConnectionURL\u0026quot;/\u0026gt; \u0026lt;property value=\u0026quot;${username}\u0026quot; name=\u0026quot;JDBC.Username\u0026quot;/\u0026gt; \u0026lt;property value=\u0026quot;${password}\u0026quot; name=\u0026quot;JDBC.Password\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;sqlMap resource=\u0026quot;Student.xml\u0026quot;/\u0026gt; \u0026lt;/transactionManager\u0026gt; \u0026lt;/sqlMapConfig\u0026gt; Student.xml # 映射xml文件 \u0026lt;sqlMap\u0026gt; \u0026lt;typeAlias alias=\u0026quot;Student\u0026quot; type=\u0026quot;com.Student\u0026quot;/\u0026gt; \u0026lt;select id=\u0026quot;selectAllStudent\u0026quot; resultClass=\u0026quot;Student\u0026quot;\u0026gt; select * from Student \u0026lt;/select\u0026gt; \u0026lt;/typeAlias\u0026gt; \u0026lt;/sqlMap\u0026gt; 辅助类Student.java # 要求有无参构造方法 private sid = 0; private String name = null; private String major = null; private Date birth = null; private float score = 0; Xxx.java private static SqlMapClient sqlMapClient = null; static{ Reader reader = Resources.getResourceAsReader(总配置文件); sqlMapClient = SqlMapClientBuilder.buildSqlMapClient(reader); reader.close(); } public List\u0026lt;Student\u0026gt; queryAllStudent(){ List\u0026lt;Student\u0026gt; studentList = sqlMapClient.queryForList(\u0026quot;selectAllStudent\u0026quot;); return studentList; } @Test public void testHere(){ for(Student student: this.queryAllStudent()){ System.out.println(student.getName); } } 配置 sqlMapConfig.xml mybatis加载属性顺序 properties中property中的属性 properties中resource或url中的属性 parameterType中传递一属性 # properties中配的属性会影响到mapper.xml中${}的sql拼接，因为都是ognl 配置标签 properties settings # ibatis有性能优化的参数，mybatis会自动调优，不用设置了 typeAliases # 针对parameterType和resultType指定的类型定义别名 # java.lang.Integer在mybatis中默认别名为int typeHandlers # 类型处理器，jdbc类型和java类型的转换 ## 一般mybatis提供的类型处理器够用了 objectFactory plugins environments mappers mapper.xml 内容 #{}接收简单类型, pojo的ognl属性注入 ${}是字符串的拼接 SELECT * FROM USER WHERE id=#{id} SELECT * FROM USER WHERE username LIKE '%${value}%' # sql 注入 输入输出映射 parameterType java类型 hashmap # #{key}来取value pojo 包装类型 resultType # 指定一条数据的类型，在java方法的返回类型中list或pojo来体现数据条数 # mybatis判断mapper代理中使用selectOne或者selectType pojo # 返回字段可以是别名，但要与pojo中的属性名相同 ## 如果有记录返回但没有pojo中匹配的属性名对应，则直接不创建该对象 java类型 # 在返回结果只有一行一列时，可以是简单类型 hashmap # key是字段的字，value是字段的值 ## 多条数据时，list里面存hashmap resultMap # 查询出来的字段名与pojo属性名不一致 定义resultMap 使用resultMap 动态sql \u0026lt;where\u0026gt; \u0026lt;if\u0026gt; sql片段\u0026lt;sql\u0026gt; \u0026lt;foreach\u0026gt; 高级映射 缓存 逆向 要求 1. mapper.xml中namespace 写mapper接口 \u0026lt;mapper namespace=\u0026quot;com.otr.tea.mapper.UserMapper\u0026quot;\u0026gt; 2. mapper.java中方法名与mapper.xml的statementid一致 3. mapper.java中方法的输入类型与mapper.xml中的parameterType一致 # 由于传入的参数只有一个，所以用包装类型的pojo来传多个参数，不利于业务层的可扩展性 4. mapper.java中方法的返回类型与mapper.xml中的resultType一致 机制 如果Mapper中返回类型为pojo, 则调用selectOne, 如果是List, 则调用selectList api sqlSessionFactory sqlSession # 是线程不安全的，因为它的类中有数据和属性 ＃ 是多例的，在方法中局部变量使用 Executor # 执行器操作数据库（基本执行器，缓存执行器） mapped statement # 封装sql语句、输入参数、输出结果类型 例子 InputStream is = Resources.getResourceAsStream(\u0026quot;SqlMapConfig.xml\u0026quot;); # Resources是mybatis提供的资源加载类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = factory.openSession(); User user = sqlSession.selectOne(\u0026quot;test.findUserById\u0026quot;, 1); ＃ selectList() # insert(\u0026quot;test.insertUser\u0026quot;, user) ## sqlSession.commit(); ## user.getId() 会主键返回 ### mysql中LAST_INSERT_ID()在insert语句后接着执行可以得到刚刚自成的id sqlSession.close(); 案例 返回id mysql \u0026lt;insert id=\u0026quot;insert\u0026quot; parameterType=\u0026quot;com.test.User\u0026quot; keyProperty=\u0026quot;userId\u0026quot; useGeneratedKeys=\u0026quot;true\u0026quot; \u0026gt; oracle \u0026lt;insert id=\u0026quot;insert\u0026quot; parameterType=\u0026quot;com.test.User\u0026quot;\u0026gt; \u0026lt;selectKey resultType=\u0026quot;INTEGER\u0026quot; order=\u0026quot;BEFORE\u0026quot; keyProperty=\u0026quot;userId\u0026quot;\u0026gt; SELECT SEQ_USER.NEXTVAL as userId from DUAL \u0026lt;/selectKey\u0026gt; insert into user (user_id, user_name, modified, state) values (#{userId,jdbcType=INTEGER}, #{userName,jdbcType=VARCHAR}, #{modified,jdbcType=TIMESTAMP}, #{state,jdbcType=INTEGER}) \u0026lt;/insert\u0026gt; spring struts2 # 原理 tomcat启动日志：没有整合时不能加载struts-plugin.xml（spring-struts-plugin.jar包中的配置文件 ） struts中struts-default中常量配置加载com.opensymphony.xword2.ObjectFactory类作为默认struts创建action的类 加载后struts-plugin.xml 中 修改了常量为struts-spring-plugin中的类来创建struts的类，也就是整个struts2创建action类的类被更改了 整合 jar包 struts2/lib/struts2-spring-plugin-2.3.1.1.jar # 为了在struts的xml配置文件中的class找spring 的容器 配置web.xml # \\samples\\petclinic\\war\\WEB-INF\\web.xml目录下有示例 \u0026lt;listener\u0026gt; # 监听器，web程序启动时加载spring bean \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener \u0026lt;context-param\u0026gt; # （可选）配置spring 配置文件的路径， ## 从示例文件中查到，默认文件目录是/WEB-INF/applicationContext.xml(我们示例文件也是从源码/simple项目下的这个开头的文件中找的) \u0026lt;param-name\u0026gt;contextConfigLocation \u0026lt;param-value\u0026gt;/WEB-INF/classes/struts2/xxx.xml UserAction 中 # 不用值栈是因为通用性 spring.xml # action类由spring 产生 \u0026lt;bean id=\u0026quot;userActionID\u0026quot; class=\u0026quot;\u0026quot; scope=\u0026quot;prototype\u0026quot;/\u0026gt; struts2的配置文件中，替换class属性为spring beanid，其它一样 总结 spring的web配置是由下向上，一个个依赖注入的过程 comboPooledDataSourceID -\u0026gt; localSessionFactoryBeanID -\u0026gt; hibernateTemplateID -\u0026gt; SysStaffDaoID -\u0026gt; SysStaffServiceID -\u0026gt; SysStaffActionID -\u0026gt; struts.xml配置中的\u0026lt;action class=\u0026quot;SysStaffActionID\u0026quot;\u0026gt; 最后给Dao中的方法加入事务 spring mvc # 原理 DispatchServlet doService()捕获请求, doDispatch()用HandlerMapping映射url得到HandlerExcutionChain(执行链, 包括拦截器和handler) handler getHandlerAdapter得到适配器来处理handler, 返回ModelAndView # HandlerAdapter分三类: Servlet、Controller, HttpRequest DispatchServlet用ViewResolver(视图解析器)解析ModelAndView成View # ModelAndView是逻辑视图，DispatchServlet转化成视图View 返回View 与struts2区别 spring mvc方法对应请求, struts2是类 spring mvc请求是方法调用，struts2创建Action实例 spring mvc用aop处理请求，struts2用独有的拦截器(interceptor) spring mvc入口是servlet, struts2入口是filter spring mvc集成ajax(@ResponseBody), struts2需要插件 spring mvc验证支持JSR303, struts2不支持 spring mvc与spring无缝 spring mvc不需要配置 注解 @RequestMapping # url映射 @RequestBody # 转换参数到对象 @ResponseBody # 返回对象转json 开启注解处理器 springmvc.xml \u0026lt;mvc:annotation-driven\u0026gt; 乱码问题 post web.xml中配置CharacterEncodingFilter get tomcat配置文件修改项目编码 new String(Request.getParameter(\u0026quot;a\u0026quot;).getBytes(\u0026quot;ISO8859-1\u0026quot;), \u0026quot;utf-8\u0026quot;) quartz:定时器 # 执行：ApplicationContext类加载后自动执行 导包：quartz-all.jar包 与 commons-collections.jar包 与 commons-logging.jar xml配置： \u0026lt;!-- 任务类 ,其中有个叫execute的方法--\u0026gt; \u0026lt;bean id=\u0026quot;myTaskID\u0026quot; class=\u0026quot;jee.quartz.MyTask\u0026quot;/\u0026gt; \u0026lt;!-- spring提供专用于定时任务类 --\u0026gt; \u0026lt;bean id=\u0026quot;methodInvokingJobDetailFactoryBeanID\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\u0026quot;\u0026gt; \u0026lt;!-- 要定时执行的实例的spring bean id --\u0026gt; \u0026lt;property name=\u0026quot;targetObject\u0026quot;\u0026gt; \u0026lt;ref bean=\u0026quot;myTaskID\u0026quot;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- spring bean中定时执行的方法 --\u0026gt; \u0026lt;property name=\u0026quot;targetMethod\u0026quot;\u0026gt; \u0026lt;value\u0026gt;execute\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- spring提供专用于任务频率类，给上面的任务指定频率 --\u0026gt; \u0026lt;bean id=\u0026quot;cronTriggerBeanID\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.CronTriggerBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;jobDetail\u0026quot;\u0026gt; \u0026lt;ref bean=\u0026quot;methodInvokingJobDetailFactoryBeanID\u0026quot;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;cronExpression\u0026quot;\u0026gt; \u0026lt;value\u0026gt;0 0/1 * * * ?\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- spring提供的专用于任务频率工厂类 --\u0026gt; \u0026lt;bean id=\u0026quot;schedulerFactoryBeanID\u0026quot; class=\u0026quot;org.springframework.scheduling.quartz.SchedulerFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;triggers\u0026quot;\u0026gt; \u0026lt;ref bean=\u0026quot;cronTriggerBeanID\u0026quot;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 任务频率cronTriggerBean的配置： cron解析器: 反斜线（/）字符表示增量值。例如，在秒字段中“5/15”代表从第 5 秒开始，每 15 秒一次。 问号（?）字符和字母 L 字符只有在月内日期和周内日期字段中可用。问号表示这个字段不包含 具体值。 所以，如果指定月内日期，可以在周内日期字段中插入“?”，表示周内日期值无关紧要。字母 L 字符是 last 的缩写。放在月内日期字段中，表示安排在当月最后一天执行。在周内日期字 段中，如果“L”单独存在，就等于“7”，否则代表当月内周内日期的最后一个实例。所以“0L” 表示安排在当月的最后一个星期日执行。 在月内日期字段中的字母（W）字符把执行安排在最靠近指定值的工作日。把“1W”放在月内 日期字段中，表示把执行安排在当月的第一个工作日内。 井号（#）字符为给定月份指定具体的工作日实例。把“MON#2”放在周内日期字段中，表示把任 务安排在当月的第二个星期一。 星号（*）字符是通配字符，表示该字段可以接受任何可能的值。 顺序：秒 分 时 日 月 周 年（年可以忽略） 例子 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 12 ? * WED 表示每个星期三中午12点 0 0 12 * * ? 每天中午12点触发 0 15 10 ? * * 每天上午10:15触发 0 15 10 * * ? 每天上午10:15触发 0 15 10 * * ? * 每天上午10:15触发 0 15 10 * * ? 2013 2013年的每天上午10:15触发 0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 15 10 15 * ? 每月15日上午10:15触发 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 ? * 6L 2014-2018 2014年至2018年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 0/1 * * * * ? 每秒钟触发一次 0 0/1 * * * ? 每分钟解发一次 0 0 0/1 * * ? 每小时解发一次 远程调用 # # rmi:remote message invoke 服务端 1.自定义接口IServer,自定义抽象方法int rax(int) 2.写接口实现类ServerImpl 3.配置spring.xml 文件 \u0026lt;!-- 服务端实现类 --\u0026gt; \u0026lt;bean id=\u0026quot;serverImplID\u0026quot; class=\u0026quot;jee.server.ServerImpl\u0026quot;/\u0026gt; \u0026lt;!-- spring提供的专用于RMI服务端注册器 --\u0026gt; \u0026lt;bean id=\u0026quot;rmiServiceExporterID\u0026quot; class=\u0026quot;org.springframework.remoting.rmi.RmiServiceExporter\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;serviceInterface\u0026quot;\u0026gt; \u0026lt;value\u0026gt;jee.server.IServer\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;service\u0026quot;\u0026gt; \u0026lt;ref bean=\u0026quot;serverImplID\u0026quot;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;serviceName\u0026quot;\u0026gt; \u0026lt;value\u0026gt;XXXX\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 客户端 配置spring.xml 文件 \u0026lt;!-- spring提供专用于RMI远程服务代理工厂类 --\u0026gt; \u0026lt;bean id=\u0026quot;rmiProxyFactoryBeanID\u0026quot; class=\u0026quot;org.springframework.remoting.rmi.RmiProxyFactoryBean\u0026quot;\u0026gt; \u0026lt;!-- 协议名://远程提供服务的IP地址:提供服务的端口/提供服务的名称 --\u0026gt; \u0026lt;property name=\u0026quot;serviceUrl\u0026quot;\u0026gt; \u0026lt;value\u0026gt;rmi://127.0.0.1:1099/XXXX\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;serviceInterface\u0026quot;\u0026gt; \u0026lt;value\u0026gt;jee.client.IServer\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 执行： 服务端加载 ApplicationContext类 客户端 加载 ApplicationContext类 ac ac.getBean方法中得到RmiProxyFactoryBean实际类型（可变类型）的实例，强转成服务端自定义的接口IServer的实现类（实现类由服务器决定） 执行IServer实现类中的方法int rax(int)，实现了远程调用 websocket # handler extends TextWebSocketHandler @Override handleTextMessge() # 处理client.send()的数据 @Override afterConnectionEstablished(WebSocketSession) # 连接事件 @Override handleTransportError() # 出错事件 @Override afterConnectionClosed() # 断开事件 @Override supportsPartialMessages() # 并行处理 config @EnableWebSocket implements WebSocketConfigurer @Override registerWebSocketHandlers() registry.addHandler(handler, \u0026quot;/ws\u0026quot;) # 路由handler client extends WebSocketClient constructor(uri) super(new URI(uri)) @Override onOpen() @Override onClose() @Override onError() @Override onMessage() service init() client = new Client(\u0026quot;ws://127.0.0.1:8001/ws\u0026quot;) client.connectBlocking() send() while(!client.getReadyState().equals(ReadyState.OPEN)){ log(\u0026quot;connecting\u0026quot;) } client.send(\u0026quot;\u0026quot;) runner implements ApplicationRunner run() service.init() spring boot # 介绍 减少配置, 习惯大于配置 支持groovy, gradle 命令 java -jar xxx.jar --server.port=8080 # --后内容，相当于application.yml设置 --spring.profiles.active=two # 选择applicaton-two.yml配置 基础文件 # 目录 src main java com.outrun XxxApplication resources static/ templates/ application.properties application.yml webapp WEB-INF test java com.outrun XxxApplicationTests pom.xml XxxApplication.java # 程序入口 @SpringBootApplication # 类，组合@Configuration, @EnableAutoConfiguration, @ComponentScan @EnableAutoConfiguration根据jar包依赖自动配置 扫描该注解同级下级包的Bean application.yml # application.yml或application.properties, 放在src/main/resources或config目录下 pom.xml 配置 # 区分环境 application-{profile}.properties # profile比如是dev, test, prod 设置spring.profiles.active=dev来区分 加载顺序 # 为了外部人员维护，可覆盖定义 命令行 SPRING_APPLICATION_JSON环境变量, json格式 java:comp/env的JNDI属性 java系统属性 # System.getProperties()查看 系统环境变量 random.*配置的随机属性 jar包外文件名, 如application-{profile}.properties jar包内文件名 @Configuration注解类中，@PropertySource修改的属性 SpringApplication.setDefaultProperties定义的内容 application.yml --- # ---分隔多个配置，这里相当于建立了application-two.yml文件 spring: profiles: two --- spring: profiles active: dev # 配置环境, 加载applicaton-dev.yml application: name: app1 pom.xml \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; # 不用war包部署, 嵌入了tomcat, jar可服务 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; # 提供spring boot基础依赖和默认配置 \u0026lt;relativePath/\u0026gt; # 从仓库查找parent \u0026lt;/parent\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; # 方便启动停止应用, 如mvn spring-boot:run \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 注解 # @SpringBootApplication # spring boot 启动类 组合了@Configuration, @EnableAutoConfiguration, @ComponentScan 类 # ApplicationRunner # 继承该类，注解@Component, 随容器启动运行 run() 插件 # maven # 命令 mvn spring-boot:run pom.xml \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; # 方便启动停止应用, 如mvn spring-boot:run \u0026lt;/plugin\u0026gt; 组件 # starter POMs # spring-boot-starter开头的组件 子域 # NamedContextFactory # class Spec1 implements NamedContextFactory.Specification { @Override public String getName(){} @Override public Class\u0026lt;?\u0026gt;[] getConfiguration(){} } public class MyFactory extends NamedContextFactory\u0026lt;Specification1\u0026gt; { public MyFactory(Class\u0026lt;?\u0026gt; clazz) { super(clazz, \u0026quot;my\u0026quot;, \u0026quot;my.name\u0026quot;) } } @Configuration public class Config0 { @Bean Bean0 getBean(){ return new Bean0() } } parent = new AnnotationConfigApplicationContext() parent.register(Config0.class) parent.refresh() factory = new MyFactory(Config00.class) factory.setApplicationContext(parent) spec1 = new Spec1(\u0026quot;1\u0026quot;, new Class[]{Config1.class}) factory.setConfigurations(List.of(spec1)) factory.getInstance(\u0026quot;1\u0026quot;, Bean0.class) // 子域共享 factory.getInstance(\u0026quot;1\u0026quot;, Bean00.class) // 子域复制 factory.getInstance(\u0026quot;1\u0026quot;, Bean1.class) spring # 配置 随机数用${random} ${random.value} 字符串 ${random.int} int ${random.long} long ${random.int(10)} 10以内int ${random.int[10,20]} 10到20 int pom.xml \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; application.yml aa bb: 1 # 可用properties类管理属性 xxx: 1 # 自定义value 配置文件中用\u0026quot;${xxx}\u0026quot;引用 类中用@Value(\u0026quot;${xxx}\u0026quot;)注入到属性 SpEL中用\u0026quot;#{xxx}\u0026quot;引用 AaProperties.java @Component @ConfigurationProperties(prefix = \u0026quot;aa\u0026quot;) public class AaProperties { private String bb; ...getter和setter... } 注解 @Configuration @PropertySource(value = \u0026quot;classpath:test.properties\u0026quot;) # 加载文件, 配合@ConfigurationProperties注入属性 @EnableConfigurationProperties({ConfigBean.class, User.class}) # 加载bean, 配合@Autowired注入 基础 注解 @Value(\u0026quot;${xxx}\u0026quot;) @Autowired # 装载bean @Bean # 实例化Bean, 属性名为方法名 @Bean public RestTemplate restTemplate() { return new RestTemplate(); } 相当于 RestTemplate restTemplate = new RestTemplate(); @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) # 生命周期 singleton # 单例 prototype # 多例 request # web程序ContextApplication用, 随请求创建 session # web程序ContextApplication用, 随session创建 global session # porlet的global用, 其它用降级为session @EventListener(XxxEvent.class) # 修饰方法, 外部publishEvent()时触发 实体 注解 @Entity # 修饰bean类 @Id # id属性 @GeneratedValue(strategy=GenerationType.AUTO) # 自增属性 @Column(nullable = false, unique = true) 组件 注解 @Component @ConfigurationProperties(prefix = \u0026quot;my\u0026quot;) # 注入properties对应名称的属性 dao 注解 @Repository # 修饰类 service 注解 @Service # 修饰类 @PostConstruct # 修饰方法, 加载servlet时, init()前执行 @PreDestroy # 修饰方法, 销毁servlet时, destroy()后执行 controller 注解 @Controller # 修饰类 测试 # pom.xml \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 注解 @Before @Test @RunWith(SpringRunner.class) # 修饰类, 测试spring @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) # 修饰类, 测试spring boot @LocalServerPort # 注入端口号 @AutoConfigureMockMvc # 使用mockMvc, 用@Autowired注入MockMvc @WebAppConfiguration # 模拟ServletContext XxxApplicationTests.java # junit测试 @RunWith(SpringJUnit4ClassRunner.class) @SpringApplicationConfiguration(classes = XxxApplication.class) @WebAppConfiguration public class XxxApplicationTests { private MockMvc mvc; @Before public void setUp() throws Exception { mvc = MockMvcBuilders.standaloneSetup(new XxxController()).build(); } @Test public void hello() throws Exception { mvc.perform(MockMvcRequestBuilders.get(\u0026quot;/hello\u0026quot;).accept(MediaType.APPLICATION_JSON)) .addExpect(status().isOk()) .addExpect(content().string(equalTo(\u0026quot;hello\u0026quot;))); } } 数据库 # pom.xml spring-boot-starter-jdbc spring-boot-starter-data-jpa # spring data JPA application.yml jpa: generate-ddl: false show-sql: true hibernate: ddl-auto: none # create时, 第一次create之后update datasource: platform: h2 schema: classpath:schema.sql # 建表 data: classpath:data.sql # 数据 注解 @Transactional # 修饰方法，开启事务，或在事务中 mybatis # pom.xml \u0026lt;!-- mybatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mysql --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.21\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; application.yml spring: datasource: url: jdbc:mysql://127.0.0.1:3306/outrun?characterEncoding=UTF-8 username: root password: asdf driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update # 新建连接必要 mybatis: mapper-locations: classpath:mapper/*.xml # 指定mapper.xml位置 mapper.xml # 用mbg生成 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;mapper namespace=\u0026quot;com.outrun.erp.mapper.UserMapper\u0026quot;\u0026gt; \u0026lt;resultMap id=\u0026quot;BaseResultMap\u0026quot; type=\u0026quot;com.outrun.erp.entities.User\u0026quot;\u0026gt; \u0026lt;id column=\u0026quot;id\u0026quot; jdbcType=\u0026quot;BIGINT\u0026quot; property=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;result column=\u0026quot;name\u0026quot; jdbcType=\u0026quot;VARCHAR\u0026quot; property=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026quot;selectUserById\u0026quot; parameterType=\u0026quot;long\u0026quot; resultMap=\u0026quot;UserMap\u0026quot;\u0026gt; SELECT name FROM user WHERE id=#{userId} \u0026lt;/select\u0026gt; \u0026lt;insert id=\u0026quot;inserUser\u0026quot;\u0026gt; \u0026lt;selectKey keyProperty=\u0026quot;id\u0026quot; resultType=\u0026quot;int\u0026quot; order=\u0026quot;BEFORE\u0026quot;\u0026gt; select field1 from seq1 \u0026lt;/selectKey\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;sql id=\u0026quot;userColumns\u0026quot;\u0026gt; ${alias}.id, ${alias}.username \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026quot;selectColumns\u0026quot; resultType=\u0026quot;map\u0026quot;\u0026gt; select \u0026lt;include refid=\u0026quot;userColumns\u0026quot;\u0026gt;\u0026lt;property name=\u0026quot;alias\u0026quot; value=\u0026quot;tb1\u0026quot;/\u0026gt;\u0026lt;/include\u0026gt; from tb1 \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026quot;dynamicSql\u0026quot; resultType=\u0026quot;User\u0026quot;\u0026gt; select * from user where state = 0 \u0026lt;if test=\u0026quot;title != null\u0026quot;\u0026gt; and title like #{title} \u0026lt;/if\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026quot;title != null\u0026quot;\u0026gt; and title like #{title} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026quot;author != null and author.name != null\u0026quot;\u0026gt; and author_name like ${author.name} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; and featured = 1 \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;foreach item=\u0026quot;item\u0026quot; index=\u0026quot;index\u0026quot; collection=\u0026quot;list\u0026quot; open=\u0026quot;(\u0026quot; separator=\u0026quot;,\u0026quot; close=\u0026quot;)\u0026quot;\u0026gt; #{item} \u0026lt;/foreach\u0026gt; \u0026lt;trim prefix=\u0026quot;where\u0026quot; prefixOverrides=\u0026quot;and | or\u0026quot;\u0026gt; ... \u0026lt;/trim\u0026gt; \u0026lt;bind name=\u0026quot;a\u0026quot; value=\u0026quot;'%' + _data.getTitle() + '%'\u0026quot; /\u0026gt; select * from blog where title like #{a} \u0026lt;/select\u0026gt; \u0026lt;update\u0026gt; update User \u0026lt;set\u0026gt; \u0026lt;if test=\u0026quot;username != null\u0026quot;\u0026gt;username=#{username},\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/update\u0026gt; \u0026lt;cache\u0026gt; # 该命名空间缓存 \u0026lt;cache-ref\u0026gt; # 引用其它命名空间缓存 \u0026lt;delete\u0026gt; \u0026lt;resultMap\u0026gt; \u0026lt;constructor\u0026gt; # 构造方法 \u0026lt;idArg\u0026gt; # id参数, 标记id帮助提高性能 \u0026lt;arg\u0026gt; # 普通参数 \u0026lt;/constructor\u0026gt; \u0026lt;id\u0026gt; # 标记id帮助提高性能 \u0026lt;result\u0026gt; # 普通字段 \u0026lt;association\u0026gt; # 关联 \u0026lt;collection\u0026gt; # 结构体 \u0026lt;discriminator\u0026gt; # 自动映射 \u0026lt;/resultMap\u0026gt; \u0026lt;/mapper\u0026gt; mapper/UserMapper @Mapper # 如果扫描mapper.xml，不用加@Mapper public interface UserMapper { List\u0026lt;User\u0026gt; selectUserById(@Param(\u0026quot;userId\u0026quot;) long userId) @Select(\u0026quot;select * from user\u0026quot;) List\u0026lt;User\u0026gt; findAll(); } entities/User public class User { private Integer id; private String name; ...getter, setter... } 注解 @Table(name = \u0026quot;user\u0026quot;) # 修饰类，指定表 @Id # 修饰属性, 指定主键 @Column(name = \u0026quot;name\u0026quot;) # 修饰属性, 指定字段 @Mapper # 修饰类 @Select(\u0026quot;select * from user\u0026quot;) # 修饰方法 @Param(\u0026quot;userId\u0026quot;) # 修饰参数 api SqlSessionFactory build openSession # 重载事务方法 SqlSesion selectOne() selectList() selectMap() insert() update() delete() commit() rollback() clearCache() close() Mapper o-\u0026gt; @Insert(\u0026quot;insert into tb1(id, name) values(#{id}, #{name})\u0026quot;) @SelectKey(statement=\u0026quot;next value\u0026quot;, keyProperty=\u0026quot;id\u0026quot;, before=true, resultType=int.class) int insertTable1(String name) SQL INSERT_INTO() VALUES() o-\u0026gt; new SQL(){{ SELECT(\u0026quot;a.name\u0026quot;); SELECT(\u0026quot;a.age\u0026quot;); FROM(\u0026quot;tb1 a\u0026quot;); WHERE(\u0026quot;a.name like ?\u0026quot;); }}.toString() LogFactory useSlf4jLogging() useLog4jLogging() useStdOutLogging() web # # 用的spring mvc pom.xml \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; # web模块, 有tomcat, spring mvc \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; # 测试模块, 有JUnit, Hamcrest, Mockito \u0026lt;/dependency\u0026gt; application.yml server port: 8080 # 默认8080 servlet context-path: /hello # uri前缀 静态资源 默认映射public, resources, static到/ 注解 控制器 @RestController # 修饰类, 组合@Controller与@responseBody @RequestMapping(\u0026quot;/index\u0026quot;) # 修改类或方法, url @GetMapping(\u0026quot;/{id}\u0026quot;) # 相当于@RequestMapping(method=RequestMethod.GET) @PostMapping @PutMapping @DeleteMapping @PatchMapping @CrossOrigin # 修饰方法, 允许跨域 @RequestBody # 修饰方法, 解析body到参数 @PathVariable Long id # 修饰参数, 接收url参数 内置对象 ServerProperties # 单例可@Autowired, 存端口之类属性 自实现 XxxController.java @RestController public class HelloController { @RequestMapping(\u0026quot;/hello\u0026quot;) public String index() { return \u0026quot;hello\u0026quot;; } } 日志 # application.yml logging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE 注解 @Slf4j # 修饰类，其中可直接用log变量 @EnableSwagger2 # 修饰类 @Api(tags = \u0026quot;\u0026quot;) # 修饰类, 文档 @ApiModel(\u0026quot;\u0026quot;) # 修饰类 @ApiModelProperty(\u0026quot;) # 修饰属性 @ApiOperation(value=\u0026quot;\u0026quot;, notes=\u0026quot;\u0026quot;) # 修改方法, 文档 @ApiIgnore # 修饰方法, 文档忽略 jackson # 注解 @JsonInclude # 修饰类, 序列化时包含 @JsonInclude(JsonInclude.Include.NON_EMPTY) # null或\u0026quot;\u0026quot;时不序列化 @JsonIgnore # 修饰属性 Scheduled # scheduled 注解 @Scheduled # 修饰方法, 定时调度 @Scheduled(initialDelay = 1000, fixedRate = 1000) 类 @Configuration implements SchedulingConfigurer # 配置类 configureTasks(ScheduledTaskRegistrar) registrar.setScheduler(Executors.newScheduledThreadPool(2)); # worker池 async 注解 @Async # 修饰方法, 异步调用 类 implements AsyncUncaughtExceptionHandler # 处理@Async异常 @Override public void handleUncaughtException() @Configuration @EnableAsync implements AsyncConfigurer @Bean @Override public Executor getAsyncExecutor() @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() # 处理无返回值＠Async方法异常 return handler 使用 @Async Future\u0026lt;String\u0026gt; fetch(){ return new AsyncResult\u0026lt;String\u0026gt;(\u0026quot;\u0026quot;) } future = fetch() try{ future.get() } 热部署 # pom.xml \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; # 热部署 \u0026lt;/dependency\u0026gt; application.yml spring: devtools: restart: enabled: true additional-paths: src/main/java jsp # pom.xml \u0026lt;!-- servlet依赖. --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- tomcat的支持.--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.embed\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-embed-jasper\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; application.yml spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp controller类 @Controller public class XxxController { @RequestMapping(\u0026quot;/xxx\u0026quot;) public String xxx(Model m) { m.addAttribute(\u0026quot;a\u0026quot;, 1); return \u0026quot;view1\u0026quot;; } } src/main/webapp/WEB-INF/views/view1.jsp \u0026lt;%@ page language=\u0026quot;java\u0026quot; contentType=\u0026quot;text/html; charset=utf-8\u0026quot; pageEncoding=\u0026quot;utf-8\u0026quot;%\u0026gt; jsp ${a} lombok # 注解 @Builder # 修饰类, 可build方式设置属性 @Getter # 修饰类, 生成getter @Setter # 修饰类, 生成setter @ToString # 修饰类, 生成toString方法 @Data # 修饰类, 注入getter, setter, toString @NoArgsConstructor # 修饰类, 生成无参构造方法 @AllArgsContructor # 修饰类, 生成带所有参数的构造方法 @RequiredArgsConstructor # 修饰类, 生成带常量、@NotNull修饰变量参数的构造方法 @RequiredArgsConstructor(onConstructor_ = @Autowired) # 构造类时，自动对private final 属性@Autowire remote shell # pom.xml spring-boot-starter-remote-shell actuator # pom.xml \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 原生端点 应用配置类 /autoconfig # 自动化配置详情 positiveMatches\t# 成功 negativeMatches /beans # 所有bean /configprops # 属性 /env # 环境属性 /mappings # spring mvc映射关系 /info # 自定义信息，默认为空，用info前缀定义 度量指标 /metrics # 程序信息，内存、线程、gc等 nonheap.* # 非堆内存 gauge.* # http请求性能，如gauge.response表示上次延迟 counter.* # 记录累计，如counter.status.200表示返回200的次数 /metrics/{name} # 查看某项 /metrics/mem.free /health # 启动状态，磁盘空间 DiskSpaceHealthIndicator # 低磁盘空间 DataSourceHealthIndicator # DataSource连接是否可用 MongoHealthIndicator RabbitHealthIndicator RedisHealthIndicator SolrHealthIndicator /dump # 线程信息 /trace # 跟踪信息 操作控制 # 用属性配置开启 /shutdown # 关闭端点 通过endpoints.shutdown.enabled=true开启 自定义counter统计 @Autowired private CounterService counterService; counterService.increment(\u0026quot;didispace.hello.count\u0026quot;) 自定义health检测器 @Component public class RocketMQHealthIndicator implements HealthIndicator { private int check(){} @Override public Health health() { int errorCode = check(); if (errorCode !=0) { return Health.down().withDetail(\u0026quot;Error Code\u0026quot;, errorCode).build(); return Health.up().build(); } } } spring boot admin # application.yml spring: application: name: erp-admin-server boot: admin: routes: endpoints: env,metrics,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream endpoints: health: sensitive: false enabled: true actuator: enabled: true sensitive: false beans: sensitive: false enabled: true spring initializer # 介绍 生成spring基础项目 spring security # 配置 application.yml security: basic: enabled: false # 禁用security 注解 @EnableWebSecurity # 修饰WebSecurityConfigurerAdapter, 开启web验证 @EnableGlobalMethodSecurity(prePostEnabled = true) # 修饰WebSecurityConfigurerAdapter, 开启方法验证 @PreAuthorize # 修饰controller方法 api Subject # 主体数据结构, 如用户 SecurityManager # 安全管理器, 管理所有subject UserDetails getAuthorities() getUsername() getPassword() isAccountNonExpired() isAccountNonLocked() isCredentialsNonExpired() isEnabled() GrantedAuthority getAuthority() WebSecurityConfigurerAdapter configure(HttpSecurity) # 验证请求 configure(AuthenticationManagerBuilder) # 验证数据，需要授权服务配置AuthenticationManager userDetailService passwordEncoder authenticationManagerBean() # 指定管理bean spring security oauth2 # pom.xml spring-cloud-starter-oauth2 结构 OAuth2 Provider Authorization Service # 授权服务 Resource Service # 资源服务 Spring Security过滤器 /oauth/authorize # 授权 /oauth/token # 获取token 授权服务 applicatoin.yml # server security: oauth2: resource: filter-order: 3 注解 @EnableAuthorizationServer # 修饰AuthorizationServerConfigurerAdapter, 开启授权服务 api AuthorizationServerConfigurerAdapter # 授权服务配置 configure(ClientDetailsServiceConfigurer) # 客户端信息 clientId secret scope authorizedGrantTypes # password, refresh_token, client_credentials authorities # 具体权限 configure(AuthorizationServerEndpointsConfigurer) # 使用token的服务 authenticationManager # 密码认证 authenticate(Authentication) userDetailService # 获取用户数据 loadUserByUsername(String) authorizationCodeServices # 验证码 implicitGrantService tokenGranter tokenStore InMemoryTokenStore JdbcTokenStore JwtTokenStore configure(AuthorizationServerSecurityConfigurer) # 使用token服务的安全策略, 授权服务与资源服务分离时配置 接口 Principal /users/current 测试 insert into user(username, password) values('outrun', '$2a$10$l7.7AJEHtXukwUZiKAyVSO6lHJOyHhPxHvi7MHawe8SjlOKkCVbAe') curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf 浏览器 url: localhost:9016/uaa/oauth/token header 'Authorization': 'Basic ' + base64('erp-auth-resource:asdf') data username: 'outrun' password: '123456' grant_type: 'password' 资源服务 application.yml # client security: oauth2: resource: user-info-uri: http://localhost:9016/uaa/users/current client: clientId: erp-auth-resource clientSecret: asdf accessTokenUri: http://localhost:9016/uaa/oauth/token grant-type: client_credentials,password scope: server 注解 @EnableResourceServer # 修饰ResourceServerConfigurerAdapter, 开启资源服务 # 修饰AuthorizationServerConfigurerAdapter, 因为授权服务提供token获取和验证接口 @PreAuthorize(\u0026quot;hasAuthority('ROLE_ADMIN')) # 修饰controller方法，验证权限 api ResourceServerConfigurerAdapter # 资源服务配置 configure(HttpSecurity) authorizeRequests # 请求放行 测试 curl -d \u0026quot;username=outrun\u0026amp;password=asdf\u0026quot; \u0026quot;localhost:9017/user/registry\u0026quot; insert into role values(1, 'ROLE_USER'), (2, 'ROLE_ADMIN') insert into 'user_role' values(user_id, 2) curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf curl -l -H \u0026quot;Authorization:Bearer 7df6669c-0c86-417b-827f-9a58297f57e5\u0026quot; -X GET \u0026quot;localhost:9017/hello\u0026quot; 客户端 注解 @EnableOAuth2Client # 修饰[Oauth2ClientConfig], 客户端 api [Oauth2ClientConfig] # 客户端配置, 自定义类，名称任意 ClientCredentialsResourceDetails # bean, 资源信息 RequestInterceptor # bean, 保存请求上下文 OAuth2RestTemplate # bean, 用于向授权服务发送请求 表 clientdetails oauth_access_token oauth_approvals oauth_client_details oauth_client_token oauth_code oauth_refresh_token spring integration # # 服务编排 "},{"id":89,"href":"/docs/pl/markup_language/","title":"Markup Language","section":"程序语言","content":" xml # 介绍 可扩展性标记语言，使用DTD和XML Schema标准化XML结构 优点: 格式统一，符合标准，用于互不兼容系统 缺点: 格式复杂，占流量大，解析占资源 解析器 DOM # 树形结构 SAX # 事件模型 标签头 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; 命名空间 \u0026lt;xsl:stylesheet version=\u0026quot;1.0\u0026quot; xmlns:xsl=\u0026quot;http://www.w3.org/1999/XSL/Transform\u0026quot;\u0026gt; # xmlns:beans=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; # 引用其它uri空间 ## jar 包中的dtd/xsd文件直接用相对路径引用即可（相当于src/目录下的文件） \u0026lt;h:table xmlns:h=\u0026quot;http://www.w3.org/TR/html4/\u0026quot;\u0026gt; \u0026lt;h:tr\u0026gt; \u0026lt;h:td\u0026gt;Apples\u0026lt;/h:td\u0026gt; \u0026lt;h:td\u0026gt;Bananas\u0026lt;/h:td\u0026gt; \u0026lt;/h:tr\u0026gt; \u0026lt;/h:table\u0026gt; # 命名空间约束文件的查找 1.联网 2.myeclipse中的xml 3.同目录下 4.jar包中 # xmlns:只能有一个没有别名 注意 命名空间不可以分层使用，如 \u0026lt;r:g:element\u0026gt; 是不允许的 例子 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;GB2312\u0026quot; ?\u0026gt; \u0026lt;c:customer xmlns:c=\u0026quot;http://www.customer.com/\u0026quot;\u0026gt; \u0026lt;c:name\u0026gt;ZhangSan\u0026lt;/c:name\u0026gt; \u0026lt;c:phone\u0026gt;09098768\u0026lt;/c:phone\u0026gt; \u0026lt;c:host xmlns:e=\u0026quot;http://www.employee.com/\u0026quot;\u0026gt; \u0026lt;e:name\u0026gt;LiSi\u0026lt;/e:name\u0026gt; \u0026lt;e:phone\u0026gt;89675412\u0026lt;/e:phone\u0026gt; \u0026lt;/c:host\u0026gt; \u0026lt;/c:customer\u0026gt; \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;GB2312\u0026quot;?\u0026gt; \u0026lt;book xmlns=\u0026quot;http://www.library.com/\u0026quot;\u0026gt; \u0026lt;title\u0026gt;The C++ Standard Library\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;Nicolai M.Josutis\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;GB2312\u0026quot;?\u0026gt; \u0026lt;customer xmlns=\u0026quot;http://www.customer.com/\u0026quot; xmlns:e=\u0026quot;http://www.employee.com/\u0026quot;\u0026gt; \u0026lt;name\u0026gt;ZhangSan\u0026lt;/name\u0026gt; \u0026lt;phone\u0026gt;09098768\u0026lt;/phone\u0026gt; \u0026lt;host\u0026gt; \u0026lt;e:name\u0026gt;LiSi\u0026lt;/e:name\u0026gt; \u0026lt;e:phone\u0026gt;89675412\u0026lt;/e:phone\u0026gt; \u0026lt;/host\u0026gt; \u0026lt;/customer\u0026gt; 语法 xmlns:[prefix]=”[URI of namespace]” dtd文件路径解析 system声明方式：根据给出URL寻找DTD?DTD通过URL显式地直接定位。 public声明方式：查找众所周知词汇表，应用程序自行确定从数据库中定位dtd，或是从声明的网站中下载（存入数据库缓存中）。 # myeclipse中通过xml Catalog选项来定位dtd约束 schema文件路径解析 xsd文件中：targetNamespace=\u0026quot;http://www.w3school.com.cn\u0026quot; # 定义自己的uri标识空间名 xml文件中：xsi:schemaLocation=\u0026quot;http://www.w3school.com.cn note.xsd\u0026quot; # 指定约束文件的uri地址，一般是空间名加/文件名（目前只有cxf的jaxws约束文件例外【把路径换成了包名】） dtd # 注意 同名元素只能用命名空间来区分定义 例子 \u0026lt;?xml version='1.0' encoding='utf-8'?\u0026gt; \u0026lt;!DOCTYPE poem[ \u0026lt;!ELEMENT poem (author, title, content)\u0026gt; \u0026lt;!ELEMENT author (#PCDATA)\u0026gt; \u0026lt;!ELEMENT title (#PCDATA)\u0026gt; \u0026lt;!ELEMENT content (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;poem\u0026gt; \u0026lt;author\u0026gt;王维\u0026lt;/author\u0026gt; \u0026lt;title\u0026gt;鹿柴\u0026lt;/title\u0026gt; \u0026lt;content\u0026gt;空山不见人， 但闻人语声， 返景入深林，复照青苔上。\u0026lt;/content\u0026gt; \u0026lt;/poem\u0026gt; 外部引用 \u0026lt;?xml version='1.0' encoding='utf-8'?\u0026gt; \u0026lt;!DOCTYPE poem SYSTEM \u0026quot;outer.dtd\u0026quot;\u0026gt; // outer.dtd \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;!ELEMENT poem (author, title, content)\u0026gt; \u0026lt;!ELEMENT author (#PCDATA)\u0026gt; \u0026lt;!ELEMENT title (#PCDATA)\u0026gt; \u0026lt;!ELEMENT content (#PCDATA)\u0026gt; 语法 \u0026lt;!ELEMENT author (#PCDATA)\u0026gt; 之中的两个空格必须要有 元素类型 EMPTY # 可以有属性 ANY # 根元素设为ANY类型后，元素出现的次数和顺序不受限制 #PCDATA 纯元素类型 混合类型 # 可以是元素与内容的混合 例子 \u0026lt;!ELEMENT 家庭 (人+, 家电*)\u0026gt; 修饰符说明 () # 用来给元素分组 如 (古龙|金庸|梁羽生), (王朔|余杰), 毛毛 ｜ # 选择一个 如 (男人|女人) + # 出现一或多次 如 (成员+) * # 出现零或多次 ? # 出现零或一次 , # 对象必须按指定的顺序出现 如 (西瓜, 苹果, 香蕉) 属性类型 schema # Schema约束 tld文件是Schema约束的 引入 根元素添加 文件books.xsd \u0026lt;xs:schema xmlns:xs=\u0026quot;http://www.w3.org/2001/XMLSchema\u0026quot; // ns 是 namespace targetNamespace=\u0026quot;http://www.jnb.com\u0026quot; // 给当前约束文件起一个名字 elementFormDefault=\u0026quot;qualified\u0026quot;\u0026gt; // 添加属性，qualified指所有都来自xs空间 可选attributeFormDefault=\u0026quot;unqualified\u0026quot; // unqualified 默认来自的空间 文件books.xml 从根元素开始约束 \u0026lt;jnb:书架 xmlns:jnb=\u0026quot;http://www.jnb.com\u0026quot; // 在被约束文件根元素添加属性，约束命名空间 xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; // 找到xsi xsi:schemaLocation=\u0026quot;http://www.jnb.com books.xsd\u0026quot;\u0026gt; // 指定对应约束文件的物理地址 \u0026lt;jnb:书\u0026gt; \u0026lt;/jnb:书\u0026gt; \u0026lt;/jnb:书架\u0026gt; // 在被约束所有元素添加指定空间前缀 // 保存并检验 语法 元素约束 \u0026lt;xs:element name=\u0026quot;xxx\u0026quot; type=\u0026quot;yy\u0026quot; defaule=\u0026quot;\u0026quot; /\u0026gt; // name 元素名 type 类型 元素类型 xs:string // 字符串 xs:decimal // big decimal 数字类型 xs:integer // xs:boolean xs:date // 日期 xs:time // 时间 属性约束，在元素标签体里 \u0026lt;xs:attribute name=\u0026quot;\u0026quot; type=\u0026quot;\u0026quot; /\u0026gt; // name 属性名 type 类型 属性类型和元素类型一样 属性说明 \u0026lt;xs:attribute use=\u0026quot;required\u0026quot; /\u0026gt; 限定约束 对值的限定 枚举限定 正则限定 选择限定 长度限定 混合内容 \u0026lt;xs:complexType mixed=\u0026quot;true\u0026quot;\u0026gt; // 只有文本和子元素，mixed可以不使用 \u0026lt;/xs:complexType\u0026gt; 指示器 All Choice // 选择出现 Sequence // 按声明顺序出现 maxOccurs minOccurs Group name attributeGroup name \u0026lt;xs:all\u0026gt; // 指定以下元素随意出现 \u0026lt;/xs:all\u0026gt; uml # Unified Modeling Languag 静态模型 用例图(需求分析):客户看 # 项级图(突出重点)，一级图，二级图，三级图 参与者(泛化) (关联) 用例(包含，扩展【继承】) # 是动词，表示功能模块 注释 类图：类结构、类关系（可以自动生成java类） 继承 实现 关联（全局变量）【导航性：一对多关系等】【聚合(所有引用)，组合（生命周期相同，如int类型属性）】 # spring 中的依赖注入是关联 依赖（局部变量） 实体关系图ER 动态模型 时序图：可以根据时序图写代码 #　rose工具中时序图中加入参与者：用例图中创建参与者，拖入时序图中 plantUML # 分类 salt wireframe uml activity class component sequence state use case mermaid.js # 流程图(flowchart) graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; 时序图(sequence diagram) sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! 甘特图(gantt diagram) gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 类图(class diagram) classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label git graph gitGraph options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch markdown # 标题 # 到 ######开头 # 分别表示一号 到 六号 标题 字体 **a**或__a__ # 加粗 *a*或_a_ # 斜体 ***a***或___a___ # 加粗斜体 ~~a~~ # 删除线 格式 换行 结尾两空格 或 \u0026lt;br/\u0026gt; 引用 \u0026gt;a \u0026gt;\u0026gt;b # 不断增加\u0026gt;来多层引用 分割线 --- # 三个及以上 *** # 三个及以上，与---显示无分别 图片 ![alt内容](url \u0026quot;title内容\u0026quot;) # alt显示在图片下，title在鼠标悬停时显示 超链接 [文本](url) \u0026lt;a href=\u0026quot;url\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;文本\u0026lt;/a\u0026gt; # 可以用a标签指定target，在新页面显示 列表 -或+或*开头 # 无序列表- 数字加点开头 # 有序列表，行数自动 多空格（至少两个）加列表开头 # 嵌套列表 表格 标题1|标题2|标题3 # 默认居中对齐 -|-|- # -可以多个，:-控制标题和内容左对齐，:-:居中，-:右对齐 1|2|3 ＃ 默认左对齐 代码 `a + b;` # 单选代码 ``` function a(){ } ``` # 多行代码 # tab开头 流程图 略 org-mode # restructedText # LaTeX # KaTeX # "},{"id":90,"href":"/docs/tool/develop/","title":"Develop","section":"工具","content":" Chrome # chrome://net-internals/#dns "},{"id":91,"href":"/docs/tool/linux/","title":"Linux","section":"工具","content":" 基础 # 历史 40年代：汇编语言 60年代：汇编语言unux 70年代初：c语言、c语言unux、unux开源（美国反垄断法制裁AT\u0026amp;T） 70年代末：AT\u0026amp;T分裂，unix闭源 80年代：minix 90年代：linux # 80、90年代之间：gun计划 文件权限 drwxr-xr-x # d代表目录 lrwxrwxrwx # l代表软连接 drwxrwxrwt # 末尾的t代表粘滞位(sticky bit)，用户只能删除自己建东西 ## chmod 1777来设置 扩展名 .bin # 二进制可执行文件，加上执行权限./执行即可 .tar.gz # gzip压缩,tar打包的文件 .tar.tgz ＃ 同gzip .tar.bz2 .tar.xz 环境变量 http_proxy=http://1.1.1.1：8082 # http代理 https_proxy=http://1.1.1.1：8082 # https代理 no_proxy='m.test.com,127.0.0.1' # 代理白名单 PATH # 命名查找路径 SHELL # shell命令位置 PWD # 当前用户目录 HOME # 同上 LOGNAME # 用户名 USER # 同上 LANG # 语言环境 _ # 查看环境变量的命令 文件位置 # /var /log /boot.log # 启动日志 /proc /[pid] /status # 任务虚拟地址空间的大小 VmSize, 应用程序正在使用的物理内存的大小 VmRSS /loadavg # 1分钟、5分钟、15分钟平均负载。运行队列进程数/进程总数。最后一个进程id /etc /etc/fstab /dev/nvme0n1p5 /home ext4 defaults 0 2 /dev/nvme0n1p3 /home/outrun/nvme0n1p3 ntfs-3g defaults 0 0 # /dev/nvme0n1p6 UUID=b00fac49-46d7-43ef-aea7-256d82b862b2\t/ ext4 rw,relatime,data=ordered\t0 1 # /dev/nvme0n1p1 LABEL=ESP UUID=FE8F-730F /boot/EFI vfat rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro\t0 2 /sudoers outrun ALL=(ALL) NOPASSWD:ALL /passwd /group /resolv.conf # dns nameserver 223.5.5.5 nameserver 223.6.6.6 # alidns nameserver 114.114.114.114 /sysconfig /network-scripts/ifcfg-eth0 # 永久修改网卡 DEVICE=eth0 # 设备别名 BOOTPROTO=static # 网卡获得ip地址的方式，默认dhcp HWADDR=00:00:00:00:00:00 # mac IPADDR=192.168.0.100 # ip NETMASK=255.255.255.0 # netmask ONBOOT=yes # 系统启动时是否激活此设备 /network # 修改网关 NETWORKING=yes # 系统是否使用网络 HOSTNAME=abc # 设置本机主机名, 要与/etc/hosts中设置的主机名相同 GATEWAY=192.168.0.1 # 网关ip /selinux # 软连接到../selinux/config SELINUX=disabled # 关闭selinux /selinux/config # selinux SELINUX=enforcing # disabled 为关闭 /systemd /logind.conf # 电源管理配置 HandleLidSwitch=ignore # 关闭盖子不执行操 /system # units位置 /default.target # 启动级别 /docker.service.d/http-proxy.conf # docker代理 Environment=\u0026quot;HTTP_PROXY=http://127.0.0.1:8123\u0026quot; \u0026quot;HTTPS_PROXY=http://127.0.0.1:8123\u0026quot; \u0026quot;NO_PROXY=192.168.1.1,localhost\u0026quot; /security /limits.conf # 设置系统限制，如文件句柄数 /X11 /xorg.conf.d/70-synaptics.conf # 触摸板设置 Section \u0026quot;InputClass\u0026quot; Identifier \u0026quot;touchpad\u0026quot; Driver \u0026quot;synaptics\u0026quot; MatchIsTouchpad \u0026quot;on\u0026quot; Option \u0026quot;TapButton1\u0026quot; \u0026quot;1\u0026quot; Option \u0026quot;TapButton2\u0026quot; \u0026quot;3\u0026quot; Option \u0026quot;TapButton3\u0026quot; \u0026quot;2\u0026quot; Option \u0026quot;VertEdgeScroll\u0026quot; \u0026quot;on\u0026quot; Option \u0026quot;VertTwoFingerScroll\u0026quot; \u0026quot;on\u0026quot; Option \u0026quot;HorizEdgeScroll\u0026quot; \u0026quot;on\u0026quot; Option \u0026quot;HorizTwoFingerScroll\u0026quot; \u0026quot;on\u0026quot; Option \u0026quot;CircularScrolling\u0026quot; \u0026quot;on\u0026quot; Option \u0026quot;CircScrollTrigger\u0026quot; \u0026quot;2\u0026quot; Option \u0026quot;EmulateTwoFingerMinZ\u0026quot; \u0026quot;40\u0026quot; Option \u0026quot;EmulateTwoFingerMinW\u0026quot; \u0026quot;8\u0026quot; Option \u0026quot;FingerLow\u0026quot; \u0026quot;30\u0026quot; Option \u0026quot;FingerHigh\u0026quot; \u0026quot;50\u0026quot; Option \u0026quot;MaxTapTime\u0026quot; \u0026quot;125\u0026quot; Option \u0026quot;VertScrollDelta\u0026quot; \u0026quot;-50\u0026quot; Option \u0026quot;HorizScrollDelta\u0026quot; \u0026quot;-50\u0026quot; EndSection /issue # 发行版信息 /hosts # 修改localhost /ld.so.conf # lib设置,加入so文件的配置路径如:/usr/local/lib 执行/sbin/ldconfig -v 更新 /profile # 用户登录时加载的环境变量 /inittab # 设置启动级别 id:3:initdefault: /usr /lib /systemd /system # units位置 /share /applications # desktop文件 /run /systemd /system # units位置 /sys /class /backlight /acpi_video0 # ati显卡是acpi_video0, intel显卡是intel_backlight /brightness # 修改亮度 ~ /.bash_profile /.bash_login /.profile # 在登录时执行一次, 先.bash_profile, 再bash_login, 再.profile /.bashrc /.bash_logout /.local /share /applications # desktop文件 initd /etc/rc.d/init.d/rc.local chmod +x rc.local ln -sf ../init.d/rc.local rc0.d/S999rc.local ln -sf ../init.d/rc.local rc1.d/S999rc.local ln -sf ../init.d/rc.local rc2.d/S999rc.local ln -sf ../init.d/rc.local rc3.d/S999rc.local ln -sf ../init.d/rc.local rc4.d/S999rc.local ln -sf ../init.d/rc.local rc5.d/S999rc.local ln -sf ../init.d/rc.local rc6.d/S999rc.local # 文件名中S表示传递start参数(K表示stop), 999为启动级别 fstab /dev/sda1 /home/outrun/sda1 ntfs-3g defaults 0 0 日志 access-log # http传输 acct和pacct # 用户命令 aculog # modem活动 btmp # 失败记录 lastlog # 最近成功登录、最后一次不成功登录 syslog # 系统日志 messages # syslog sudolog # sudo记录 sulog # su记录 utmp # 当前登录用户 wtmp # 用户登录登出记录 xferlog # ftp会话 设置 # lib设置 /etc/ld.so.conf加入so文件的配置路径如:/usr/local/lib 执行/sbin/ldconfig -v 更新 发行版 # lfs coreos debian gentoo opensuse mint centos # 包 dnf install @development-tools yum install epel-release 安装VBoxAdditions yum update kernel yum install kernel-headers kernel-devel gcc # 可能要加软连接 /usr/src/kernels/ mount /dev/cdrom /mnt /mnt/VBoxLinuxAdditions.run gcc升级 yum -y install centos-release-scl yum -y install devtoolset-6-gcc devtoolset-6-gcc-c++ devtoolset-6-binutils scl enable devtoolset-6 bash echo \u0026quot;source /opt/rh/devtoolset-6/enable\u0026quot; \u0026gt;\u0026gt;/etc/profile ubuntu # 包 apt-cache madison xxx # 查看仓库中所有版本 apt-cache search xxx apt-get -f -y --assume-yes install aptitude search show install remove purge # 删除包及配置 clean # 删除下载的包文件 autoclean # 仅删除过期 fedora # 升级 fedup --network 21 或 fedora-upgrade 升级21 rpm --import https://fedoraproject.org/static/95A43F54.txt yum update yum yum clean all yum --releasever=21 distro-sync --nogpgcheck group yum grouplist yum groupinstall \u0026quot;X Window System\u0026quot; yum groupinstall \u0026quot;GNOME Desktop Environment\u0026quot; yum groupinstall \u0026quot;KDE\u0026quot; gnome的快捷方式存放地址 安装unity cd /etc/yum.repos.d/ wget http://download.opensuse.org/repositories/GNOME:/Ayatana/Fedora_17/GNOME:Ayatana.repo yum install unity arch # 设置 ahci, secure boot, post behavious thorough 源 vim /etc/pacman.d/mirrorlist pacman -Syy 依赖 base-devel 分区 # mount -t efivarfs efivarfs /sys/firmware/efi/efivars # 判断efi cfdisk mkfs.vfat -F32 /dev/nvme0n1p1 # 或直接使用windows的uefi分区 mkfs.ext4 /dev/nvme0n1p2 mkswap /dev/nvme0n1p3 swapon /dev/nvme0n1p3 mount /dev/nvme0n1p2 /mnt mkdir -p /mnt/boot/EFI mount /dev/nvme0n1p1 /mnt/boot/EFI 配置 pacstrap -i /mnt base genfstab -U -p /mnt \u0026gt;\u0026gt; /mnt/etc/fstab arch-chroot /mnt /bin/bash pacman -S dialog wpa_supplicant vim vim /etc/locale.gen locale-gen echo LANG=en_US.UTF-8 \u0026gt; /etc/locale.conf ls -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc --utc echo outrun \u0026gt; /etc/hostname grub pacman -S dosfstools grub os-prober efibootmgr # bios下 grub os-prober grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=grub grub-mkconfig -o /boot/grub/grub.cfg 用户 passwd groupadd outrun useradd -m -g users -G outrun -s /usr/bin/bash outrun passwd outrun vim /etc/sudoers 退出 exit umount -R /mnt reboot 桌面 pacman -S xorg-server xorg-apps xorg xorg-xinit pacman -S xf86-video-intel mesa xf86-input-synaptics pacman -S gnome echo exec gnome-session \u0026gt; .xinitrc # systemctl enable gdm /etc/modprobe.d/blacklist_nouveau.conf中写blacklist nouveau /etc/modprobe.d/modprobe.conf中写blacklist nouveau pacman -S ttf-dejavu wqy-microhei network pacman -S networkmanager-openvpn systemctl enable NetworkManager yaourt vim /etc/pacman.conf [archlinuxfr] SigLevel = Never Server = http://repo.archlinux.fr/$arch pacman -Sy base-devel yaourt 字体 wiki上找font configuration AUR git clone https://aur.archlinux.org/snapd.git cd snapd makepkg -si sudo systemctl enable --now snapd.socket "},{"id":92,"href":"/docs/tool/product/framework/","title":"Framework","section":"工具","content":" 博客框架 # cleaver # # 基于node幻灯片 hexo # 介绍 简单轻量，基于node的静态博客框架 可以部署在自己node服务器上，也可以部署在github上 目录结构 scaffolds # 脚手架 scripts # 写文件的js, 扩展hexo功能 source # 存放博客正文内容 _drafts # 草稿箱 _posts # 文件箱 themes # 皮肤 _config.yml # 全局配置文件 db.json # 静态常量 使用 npm install -g hexo hexo version hexo init nodejs-hexo cd nodejs-hexo \u0026amp;\u0026amp; hexo server hexo new 新博客 # 产生 source/_posts/新博客.md hexo server # 启动server hexo generate # 静态化处理 github中创建一个项目nodejs-hexo, 在_config.yml中找到deploy部分，设置github项目地址 hexo deploy # 部署以后，分支是gh-pages, 这是github为web项目特别设置的分支 上github，点settings找到github pages, 找到自己发布的站点 无法访问静态资源 设置域名 申请域名 dnspod 中 绑定ip hugo # 简介 hugo由go编写，开源，特点为编译快 本文基于hugo0.49 安装 go install --tags extended 命令 hugo help help server # server代表任何子命令 场景 发布 hugo --theme=hyde --baseUrl=\u0026quot;https://outrunJ.github.io\u0026quot; 生成站点 hugo new site blog1 # 站点命令在blog1中执行 生成文章 hugo new about.md hugo new post/first.md 本地服务器 hugo server # 自带watch -s /path/to/codes --theme=hyde --buildDrafts -p 1315 # 默认端口1313 主题 git clone https://github.com/spf13/hyde.git themes/hyde # 更多主题在https://themes.gohugo.io 文章 开头 --- 用YAML写内容 --- # +++标记可写TOML Description = \u0026quot;\u0026quot; Categories = [\u0026quot;a1\u0026quot;, \u0026quot;a2\u0026quot;] Tags = [\u0026quot;b1\u0026quot;,\u0026quot;b2\u0026quot;] draft = true # 文章隐藏 menu = \u0026quot;\u0026quot; title = \u0026quot;a\u0026quot; # 文章标题 配置 打开config.toml # 可以是config.yaml、config.json baseURL = \u0026quot;\u0026quot; title = \u0026quot;\u0026quot; theme = \u0026quot;\u0026quot; [permalinks] post = \u0026quot;/:year/:month/:title/\u0026quot; # 生成list页面 [taxonomies] category = \u0026quot;categories\u0026quot; tag = \u0026quot;tags\u0026quot; [params] description = \u0026quot;\u0026quot; author = \u0026quot;\u0026quot; ignoreFiles = [] [blackfriday] # 设置markdown库 jekyll # 介绍 ruby静态站点生成器，根据网页源码生成静态文档文件 提供模板、变量、插件等功能 生成的站点可以直接发布到github上 使用 curl http://curl.haxx.se/ca/cacert.pem -o cacert.pem # 移动到ruby安装目录 安装devkit gem install jekyll git clone https://github.com/plusjade/jekyll-bootstrap.git jekyll # 下载jekyll-bootstrap模版 cd jekyll \u0026amp;\u0026amp; jekyll serve rake post title = 'Hello' # 生成文章 ## 编辑_posts下面生成的文章 修改convertible.rb文件编码为utf-8 jekyll serve 发布到github github上创建新仓库 git remote set-url origin git@新仓库 git add . git commit -m 'new' git push origin master git branch gh-pages # 新建一个分支，用于发布项目 git checkout gh-pages 修改_config.yml production_url: http://outrun.github.io BASE_PATH: /jekyll-demo 在线服务 # webIDE # codebox 游戏 # 框架 pomelo # node.js上网易开源的实时性好的游戏类服务器 架构 MySQL user_id_list club_id_list Redis Netty ProxyServer # 交互客户端, 监听Redis Channel拿到BizServer列表， 代理请求到多个BizServer channelHandlerList Encoder Decoder 内容长度限制 WebSocket处理 msgHandler 客户端连接时动态添加handler msg带类型，区分handler, 据msg类型转发到bizServer 每个用户存routerTable BizServer Go + Protobuf + WebSocket Cocos Creator/白鹭/LayaBox Unity(C#) 三方服务 # web # aws 阿里云 青云 轻云 digital ocean vultr Linode azure # 微软开放平台 gce # google compute engine txCloud # 云柜，数据存储和计算 首都在线 paas # gae # google app engine sae # sina app engine heroku dns # godaddy 万网 dnspod cdn # 七牛 pay # 支付宝 易宝 财付通 idc # # infomation data corporation, 互联网数据中心 cti # 天润 云之讯 容联 报表/olap # palo im # 环信 云片 jpush im sms.webchinese.cn 个推 safe # 1password 设备 # 京东叮咚 # 智能音箱 萤石 # 视频设备 "},{"id":93,"href":"/docs/tool/develop/apple/","title":"Apple","section":"Develop","content":" ipad # 操作 下边向上(短)：桌面 下边向上(停): dock dock拖app: 小窗、分屏 小窗向边(短): 隐藏 小窗向边(停): 分屏 小窗向上：分离 下角向内(短): 切app 下角向内(停): app表 右上角向下: 控制中心 左上角向下：通知 桌面向下: 搜索 3指左右: app内切换 4指左右：切app 4指向内(短): 桌面 4指向内(停): app表 home一下：桌面 home两下：app表 截图、导出pdf: 主按键 + 电源键 键盘：两指缩小浮动 分屏: 一指拉出dock, 一指拖出程序 siri 问答: 笑话, 常识, 抛硬币 safari: 搜索 设置: 蓝牙,飞行模式 时钟 6点起床 德国时间 倒计时 日历: 9点开会 提醒：提醒和给妈妈打电话 备忘录：记下我花了10块钱 地图：回家路线 打车 打电话, 发信息 照片 体育：比赛消息 音乐 邮件 天气 计算器 股票: xx涨了吗 朋友：xx在哪里 发微博 指定xx: 打开trello发送a 附近店 相机：自拍模式 alfred # 搜索 指定网站搜索 文件 剪贴板 计算器 自定义脚本 打字 命令 工作流 fantastical # 个人总结 名字 date 9th from 9.30p to 10.32p alert 30min 对象 Account - Calendar Sets - Cals(Subscription+Interesting) + Item(Events + Tasks) nlp 语法 事件 [with 人物] [at 地点] [at 日期时间] [on 日期] [from 日期时间] [to 日期时间] [of every 日期时间] 提醒 URL 日历 日期 特定 日期 11月1日 11/1 11.1 星期 周一 mon/tue/wed/tur/fri/sat/sun 相对 日期 15天后 after 15 days 星期 下周一 next mon 重复 日期 每月2号 every 2 星期 每周二 every tue 每隔两周的周三 on wed every 2 weeks 复合 7月1日到8月1日之间的每个周一周二 on mons tues from 7/1 to 8/1 区间 12月17日到次年1月3日是寒假 寒假 12/17-1/3 12/17~1/3 时间 24小时制 13 12小时制 下午一点 1p 1pm 分钟 下午一点半 13:30 1.30p 默认 早上8点 morning 中午12点 noon 下午5点 evening 晚上8点 night 半夜12点 midnight 区间 下午1点32到晚上7点47 1.32-7.47 1.32~7.47 提醒 提前2小时提醒 alert 2 hours 提前5分钟提醒 alert 5 min URL 在合适位置的url 日历 /Work /w 四个空格 待办事项(reminder) 开启 todo、task、Remind、Remind me to开头 独有语义 11月27日晚上8点截止 due 11/27 8p until 11/27 8p by Thursday 低 中 高 ! !! !!! 快捷键 新建 command + n 切换日程/待办事项 command + k 保存 command + s 删除 command + d 搜索 command + f 详情 command + i 显示事项 command + r 定位到今天 command + t 设置 command + , 切换全屏视图 command + shift + f 操作 新建页面滑动隐藏 长按日期新建 长按Item 移动到Calendar 颜色 复制/重建/剪切/删除 建模板 隐藏 邮件触发事件 横划删除 mathStudio # Basic Expressions 1+2 4*5 6! Algebra a*a+b Expand((a+b)^10) Apart( (x^2) / ( x^2 + 1)^2) Factor( x^4 + 5x^2 - 6 ) Solving Quadratic Equations Solve( x^2 + 5x + 6 = 0 ) Solve(1,5,6) Limits Limit() Derivatives D(sin(x)) Integrals Integrate( x^2 + 3x - 6 ) Graphing Plot(sin(x)) Parametric Plots ParametricPlot(cos(u), sin(u)) Polar Plots PolarPlot(sin(2@theta)) Time Graphing Plot(sin(x + T)) Vector Fields VectorPlot(-y, x) Multiple Plots Minimum, Maximum and Zero Values Plot(sin(x), min=1) List Plots ListPlot([1,2,3,4,5,4,3,8,6,8]) Regression Analysis LinearFit([1,4,9,5,7,5,4,2,9], [3,4,5,7,8,10,4,7,6]) LinearFitModel() LinearFitPlot() QuadraticFitPlot() SinFitPlot() 3D Graphing Plot3D(2cos(x) * sin(y)) 3D Parametric Plots Sliders Slider(n, 1..50) Slider(a, 2, 10, 0.1) Scripting one = 1 two = 2 one + two cube(x) = x^3 cube(5) for [row, column] in data end Lists 1:100 [1,2,3] * [4,5,6] Matrices [[1,2], [3,4]] * [[5,6], [7,8]] Inverse([a,b], [c,d]) Identity(5) Units 2@feet + 24@inches Working Copy # mac # 操作 四指 向内：启动台 向外：桌面 三指 左右：切桌面 向上：app列表 向下：expose(单程序多窗口) 二指 上下：滚动 左右：前进后退 右边：通知中心 缩放,旋转 点一下：菜单 点二下：小缩放 一指 点一下：选中 点二下：打开 点一段：拖 点二段：查询 快捷键 系统： 锁屏：control + command + q 关屏：shift + control + 关机 注销：shift + command + q 睡眠：option + command + 关机 强退：control + command + 关机 程序坞： option + command + d 调度中心： app列表: control + 上 expose: control + 下 左右桌面：control + 左右 桌面：f11 窗口： 切换：command + tab 程序内切换：command + ` 关闭：command + w 退出：command + q 强制退出：option + command + esc 隐藏：command + h 最大化: control + command + f 最小化：command + m 放大、缩小：command + +和- 新标签：command + t 新建: command + n 打开：command + o 保存：command + s 另存为：shift + command + s 刷新：command + r 打印：command + p 搜索：command + f 文件： 全选、复制、剪切、粘贴、撤销: command + a c x v z 粘贴移到: option + command + v 删除: command + return 访达： 预览：空格 简介：command + i 回收站： 清空：shift + command + return 截屏： 整屏存文件：shift + command + 3 区域存文件：shift + command + 4 窗口区域：shift + command + 4 + 空格 录屏：shift + command + 5 输入法：control + 空格 命令 # brew update # 更新brew search install remove upgrade tap # 安装扩展 options # 查看安装选项 info home # 访问包官网 services list # 查看已安装 cleanup # 清除无用配置 restart # 重启 "},{"id":94,"href":"/docs/cache/","title":"Cache","section":"Docs","content":" 主机 # 备份目录 # ~ /etc /opt awesome常用键 # 独立 \u0026lt;M - s\u0026gt; # 帮助 \u0026lt;M - w\u0026gt; # 菜单 client \u0026lt;M - 回车\u0026gt; # 终端 \u0026lt;M - ctrl - r\u0026gt; # reload \u0026lt;M - c\u0026gt; # 自定义chromium \u0026lt;M - f\u0026gt; # 全屏 \u0026lt;M - shift - c\u0026gt; # 关闭 \u0026lt;M - 数字\u0026gt; # 切换到tag \u0026lt;M - j\u0026gt; \u0026lt;M - k\u0026gt; # 本tag切换client \u0026lt;M - 空格\u0026gt; # 变布局 "},{"id":95,"href":"/docs/tool/develop/jetbrains/","title":"Jetbrains","section":"Develop","content":" Intellij Idea # 注意 Project 相当于workspace, module 相当于工程 注册 服务器 # 发布网站 http://idea.lanyus.com http://idea.qinxi1992.cn http://idea.lianghongbo.com/licens http://im.js.cn:8888 javaagent https://zhile.io/ 快捷键 settings -\u0026gt; Keymap 设置eclipse alt + enter # 改错 shift shift # 搜索跳转 shift + f4 # 新窗口打开文件 类注释 settings -\u0026gt; Editor -\u0026gt; File and Code Templates -\u0026gt; Includes -\u0026gt; File Header /** * * @Description: ${Description} * @author: ShenWenqing * @date: Created on ${DATE} ${TIME} * */ alt + enter 可生成 serialVersionUID settings -\u0026gt; Inspections 勾选 Serializable class without 'serialVersionUID' JDK Project Settings -\u0026gt; Project settings -\u0026gt; Build Tools settings -\u0026gt; Compilers 编码 file -\u0026gt; settings -\u0026gt; appearence里use custom font设置中文字体 file -\u0026gt; settings -\u0026gt; editor -\u0026gt; file encodings 三处utf-8 idea安装目录/bin/idea.vmoptions和idea64.vmoptions,最后添加 -Dfile.encoding=UTF-8 .idea/encodings.xml里删除除了UTF-8的项 插件 # .env files supoort .ignore BinEd EasyYapi EnvFile Extra Icons File Expander Free MyBatis plugin GitToolBox IdeaVim jclasslib Bytecode Viewer JMH Java Microbenchmark Harness LeetCode Editor Lua MapStruct Support Maven Helper Presentation Assistant Rainbow Brackets Save Actions Solarized Theme Solarized Themes SonarLint Statistic Tabnine AI Code Completion EmmyLua webstorm # pycharm # goland # clion # phpCharm # "},{"id":96,"href":"/docs/basic/","title":"基本功","section":"Docs","content":" 思维 # 第一性原理 # 特点 来源于物理学思维, 是演绎法 唯一、穷尽 佐证: 分形 思维转变 改变归纳法（工程学），人们认识事物的习惯 改变类比思考，它偏离了根源 改变从问题出发不断归因的思考，它只能改进 用演绎法（物理学），更不偏离真相，但需要思考成本 用第一性原理思考：用物理学的角度看待世界，利用基本原则，进行物理推理，再一层层往上走 物理学角度，最不偏离事实 从问题出发找到方案再找到方案的原理，推出其它方案 实施方法 归零: 不断问为什么(奥卡姆剃刀) 解构 重构 限制 归纳法只能证伪、演绎法只能证明 演绎的逻辑来自归纳法，所以才有奇怪的不证自明的公理 逻辑思维 # 同一律、矛盾律、排中律、充足理由律 推理 归纳: 完全归纳、简单枚举归纳、因果分析 演绎 三段论 经典式：大前提、小前提、结论 问题式：what、why、how 类比: 容易外表性偏差 论证论题 论点 论据: 支持度(必然性、或然性)，要比论题可信 论证方式 分清事实或观点(态度、判断) 识别推理的好坏 金字塔原理 纵向 表达自上而下 分解：疑问回答式 思考自下而上 罗列、归类、搭建结构、概括总结 横向 演绎、归纳 分类(MECE) 独立、穷尽 逻辑树: 还原论 议题树 假设树 是否树 排序 时间 空间 重点程度 序言(SCQA) 情景(Situation)、冲突(Conflict)、问题(Questiong)、答案(Answer) 使用场景 写作：序言、标题、构架、内容 解决问题 传统方式：提出问题、分析问题、解决问题 金字塔方式： 界定问题：在哪里 结构性分析: 为什么存在 实施方案: 能做什么，应该做什么 构筑金字塔 动力 # 计划 # 为什么 重要性 时间是最重要的资源 做事目的性 有全局性: 有方向, 轻重有序，平时活动与目标联系起来 怎么坚持 实行的决心 养成习惯(抗干扰不费意志) 28定律筛选，降低预期，细想出实施过程 怎么样 聚焦（殚精竭虑，第一） 目标列项: 时间（黄金时间、常规时间、碎片时间）分配 精力管理 # 精力产生 好情绪 针对各焦虑的方案: 进度、身体、家庭、工作 左手温暖右手 好体力 作息：6-10 饮食: 体形 牛逼在于后天努力(关注过程) 付出代价(痛苦)，努力获得正反馈 精力使用 简化: 放弃、性价比 锚点： 提示 能力: 控制阻力(直接启动，家无事务) 动机 做事 浪费时间在大局 3号人格: 必须完成, 不情绪内耗 deadline是第一生产力 动力闭环 先做完再说，1次1个，小成功庆祝 张驰有度 学习 # 预习 # 为什么 上课时：扫除知识障碍、针对性解决问题、笔记有针对性 提高自学能力 改变被动局面，成为良性循环 是什么 初步理解 关联旧知识 找不理解 做笔记和习题 怎么样 先粗读, 再反复细读 先读最困惑点 问为什么 请教别人 实践 笔记 重点、结构、摘要 分类 问题 查阅资料 理解思路 逐步提高 由点到面，由浅入深 学习 # 怎么样 集中注意 获取知识主动权 作者思路，比较思维方法 方法 分析综合法、归纳演绎法、比较分类法 规律 同一律、矛盾律、排中律 # 形式逻辑学 对立统一、量变到质变、否定之否定 # 辩证逻辑学 学科特点 理科: 逻辑性，抽象思维 文科: 知识有独立性，形象思维 教师特点 保持连续性，不中断钻牛角尖 笔记 思维方法、过程、结果 完整简洁 当堂掌握 领会、巩固、运用 重点是认知过程而非结论 复习 # 贵在及时 怎么样 尝试回忆 读原文 整理笔记 参考资料 系统复习 为什么 牢固、完整 系统、实用 怎么样 之前之后回忆 有重点阅读 熟记 整理笔记 练习 记忆能力 有记忆意识 理解后记忆 艾宾浩斯曲线 过度学习来记忆 分散记忆好于集中记忆 先整体理解, 后分段记忆, 最后综合复习 多感官 思维能力 积极思维状态 基本思维方法 分类、抽象概括 系统化, 使用时具体化 思维形式 整体思维 相似思维 逆向思维 创造思维 工作 # 人 # 组织 简单，分离 管理 无为 沟通 在线文档 \u0026gt; 邮件 \u0026gt; im \u0026gt; 口头/电话 多方口头时，要维护自有重点 谈判 抛回对方问题，使其思考，后做到已方稍强 事 # 计划 把握纲领，不能变 先核心再扩展 # 稳定隔离 第一性原理 做重要不紧急 边界分割 # 正交 拆分并只安排步骤 思考框架：现状、目标、实现路径 意义(目标导向)。通常是解决问题 拆分到最细节的方案, 分配到人、工作量、联调提测时间 迷雾即瓶颈 曼陀罗思考法 实行 原型 风险点 # 技术 只输出产品，电梯演讲(简单, 清晰, 轻松, 主线, 一套) 输入时保持输出 把控变化，提供适应方案 内部有 \u0026gt; 外部有 \u0026gt; 半成品 \u0026gt; 自实现 解耦低速设备 update全员参与, 或文档 灰度替换 总结 向流程和工具找问题 发现问题(创造新视角) # 分类 已知的已知, 已知的未知，未知的未知 知 事实，解释 方法 解决问题到发现问题 从知到无知的视角转换 存量到流量 封闭体系到开放体系 固定维度到可变维度 元级超越维度 抽象化、类推 轴 why型思维 解决问题 # 提问 提原始问题，因为相对自己的看法，可能有更优解 描述问题，尝试与尝试结果 描述环境 要结构化、解决导向的提问, 否则散乱无意义 定义 为什么，是什么，怎么样，展望 zoom in, zoom out 解决 定位、权衡、落地、风控 解决数量级问题 读源码 # 目标 了解思路 难点 理解非自己的思路 了解数据结构、设计模式 原则 跑不起来不读 带目的性读，解决问题就好 一条线索到底 无关细节略过 画类图、类调用泳道图 "},{"id":97,"href":"/docs/tool/physics/","title":"实物工具","section":"工具","content":" HHKB HyBrid # 生产日期 20210108 购买日期 202104 配对方式 # 1.按Fn + q键进入配对模式。 2.再按Fn + z + ~ 键清空键盘配对信息,键盘自动关闭。 3.长按开关键重新打开键盘后按Fn + q键进入配对模式,再按Fn + Ctrl + 1/2/3/4指定一个序号。 4.然后关闭电脑蓝牙功能再打开进行搜索。 切换 # Fn + Ctrl + 1/2/3/4 Fn + Ctrl + 0 Swiftpoint ProPoint # Blix Komfort Prima # "},{"id":98,"href":"/docs/tool/","title":"工具","section":"Docs","content":" 采用 # 趋向 # 本地(app) -\u0026gt; 线上(browser) 工具 # 资讯 课：腾讯视频 搜索: DEVONagent, WolframAlpha 渠道: pages, 知网, 博客, 知乎, 慕课, 网易公开课, 微信/qq, outlook 发散查找: 百度指数, DEVONSphere 存储 文件管理: DEVONthink, SiteSucker, FEFileExplorer, Documents 网盘: icloud, oneDrive x 2, 坚果云, 百度网盘, 阿里网盘 效率 浏览器: SwitchyOmega, tampermonkey, downthemall, fireshot, pushBullet, firefoxFocus, Alook 设备同步: synergy, pushbullet, sharemouse 人机: alfred, divvy, unclutter, workspaces, yoink, xscope, hazeOver, microSnitch 监视: istatistica, wifiExplorer 图: Flameshot 短链: shortMenu 远程：OpenVPN, Shadowrocket, TeamViewer, 向日葵, ToDesk, AnyDesk, Google远程桌面, Termius, 腾讯会议，钉钉 语言：欧路词典 制品 架构图: Visio, WPS, Office, OmniGraffle, PlantUML, Graphviz, VisualParadigm 甘特图: OmniPlan, GanttProject, MicrosoftProject 表: Excel, Xmind, MindNode, Ithoughts, Scapple 大纲: Drafts, Workflowy, 幕布 字: LaTeX, iAWriter 数学: MathStudio, PocketCAS, 画: Procreator, Realistic, MentalCanvas, ExplainEverything 代码: Jetbrains, VIM, Spacemacs, VsCode, Code[iPad], WorkingCopy[iPad] 表达式: Expressions 图片: touchRetouch, auroraHDR, lensFlare, reflectStudio, superDenoising, Logoist, polarrPhoto, priimeStyles, tonality, QRFactory, Faceu, 美图秀秀 音频: permute3 视频: quickTime, gifox, gif brewery, gif maker, Hype3 3d: RealityComposer, Aurora3DMaker, 3dScanner, JigSpace, MagicPlan 笔记 信息: Notion, hugobook, Goodnotes, Notability, Prodrafts, OneNote[oneDrive] 双链: LogSeq, Obsidian, Roam 图: MarginNote, LiquidText, ThinkSpace GTD：Fantastical2, Trello, MicrosoftToDo, Things3 记账: DayOne, 支付宝, MoneyPro, FamilyTree 代码: Snipaste, Cacher[github], lepton[github], dash, snippetsLap, textastic 休闲: iPad: Chameleon, Frax, CoStudy Mac: noizio, relaxMelodiesSeasions, earth3D 政务财务 APP: 个人所得税, 微店, 贝壳, 住这儿, 热力集团, 网上国网 依赖 # 系统: 文件: tree, unrar, unzip, 7z, diff, du 系统: ntfs-3g, os-prober, network-manager, wireless-tools, systemctl, service 包: yaourt, yay, pkgfile, snap wps-office, ttf-wps-fonts 界面: awesome, i3-wm, arandr, xscreensaver, tmux, synergy, ibus, synaptics, pepper-flash, virtualbox 网络: chromium, firefox, thunderbird ops: shell: ^z, bg, fg, jobs, nohup, expect, 系统: sysdig, sysstat包(sar, sadf, mpstat, iostat, pidstat), ifconfig, top, htop, ps, df 网络: wireshark, netstat, ss, ping, telnet, iptables, wget, git, openssh, nc, nmap, nslookup vpn: openvpn, shadowsocks, polipo, v2ray vm: docker, docker-compose db: mysql, mariadb, postgresql, redis, mongodb, cassandra, neo4j elasticsearch, elasticsearch-head, elasticsearch-analysis-hanlp, elasticsearch-ik, elasticsearch-pinyin mq: nsq, rabbitmq, kafka, 容器: nginx, nginx-php 监控: zipkin, 应用: dokuwiki, tiddlywiki, wordpress, 服务: vsftpd, filezilla 分布式: ansible 程序: 基本: make, cmake, g++, gcc, lua, ruby, java: openjdk8, jdk8, jdk12, maven, tomcat go: go1.9.3, go1.12.6, go1.13.5, probobuf, protoc python: python2.7, python3.8, pip2, pip3 php: php-cgi, php-fpm js: node, mvn, babel-cli 分析: flame-graph 媒体: dia, convert, import, alsamixer, mplayer ide: vscode, sublime, emacs, vim jetbrains: webstorm, goland, intellijIdea, phpstorm, pycharm, mps, android studio eclipse: eclipse-inst, eclipse-birt, eclipse-jee-neon 数据库: datagrip, neoclipse, robo3t, studio-3t 测试: postman 工作: snapcast, mosquitto, sox, snapcastrd, websockify 系统 # windows # # 方案 附件 -\u0026gt; 系统工具 -\u0026gt; 字符映射表 -\u0026gt; 新宋体 中查看汉字的unicode编码 远程协助 端口：3389 1.系统属性 远程 2.附件：远程连接 # xp:单用户，远程操作时原用户无法操作 chm 不显示内容 右键 -\u0026gt; 常规 -\u0026gt; 解锁 # 命令 route print route delete route add 0.0.0.0 mask 0.0.0.0 10.0.2.2 nstsc # 运程桌面 # cmd CMD 属性 cmd /c dir 是执行完dir命令后关闭命令窗口。 cmd /k dir 是执行完dir命令后不关闭命令窗口。 cmd /c start dir 会打开一个新窗口后执行dir指令，原窗口会关闭。 cmd /k start dir 会打开一个新窗口后执行dir指令，原窗口不会关闭。 语法命令 | findstr asdf # 相当于grep CMD命令 1. gpedit.msc-----组策略 2. sndrec32-------录音机 3. Nslookup-------IP地址侦测器 4. explorer-------打开资源管理器 5. logoff---------注销命令 6. tsshutdn-------60秒倒计时关机命令 7. lusrmgr.msc----本机用户和组 8. services.msc---本地服务设置 9. oobe/msoobe /a----检查XP是否激活 10. notepad--------打开记事本 11. cleanmgr-------垃圾整理 12. net start messenger----开始信使服务(或其它服务) 13. compmgmt.msc---计算机管理 14. net stop messenger-----停止信使服务(或其它服务) 15. conf-----------启动netmeeting 16. dvdplay--------DVD播放器 17. charmap--------启动字符映射表 18. diskmgmt.msc---磁盘管理实用程序 19. calc-----------启动计算器 20. dfrg.msc-------磁盘碎片整理程序 21. chkdsk.exe-----Chkdsk磁盘检查 22. devmgmt.msc--- 设备管理器 23. regsvr32 /u *.dll----停止dll文件运行 24. drwtsn32------ 系统医生 25. rononce -p ----15秒关机 26. dxdiag---------检查DirectX信息 27. regedt32-------注册表编辑器 28. Msconfig.exe---系统配置实用程序 29. rsop.msc-------组策略结果集 30. mem.exe--------显示内存使用情况 31. regedit.exe----注册表 32. winchat--------XP自带局域网聊天 33. progman--------程序管理器 34. winmsd---------系统信息 35. perfmon.msc----计算机性能监测程序 36. winver---------检查Windows版本 37. sfc /scannow-----扫描错误并复原 38. taskmgr-----任务管理器（2000／xp／2003 39. winver---------检查Windows版本 40. wmimgmt.msc----打开windows管理体系结构(WMI) 41. wupdmgr--------windows更新程序 42. wscript--------windows脚本宿主设置 43. write----------写字板 44. winmsd---------系统信息 45. wiaacmgr-------扫描仪和照相机向导 46. winchat--------XP自带局域网聊天 47. mem.exe--------显示内存使用情况 48. Msconfig.exe---系统配置实用程序 49. mplayer2-------简易widnows media player 50. mspaint--------画图板 51. mstsc----------远程桌面连接 52. mplayer2-------媒体播放机 53. magnify--------放大镜实用程序 54. mmc------------打开控制台 55. mobsync--------同步命令 56. dxdiag---------检查DirectX信息 57. drwtsn32------ 系统医生 58. devmgmt.msc--- 设备管理器 59. dfrg.msc-------磁盘碎片整理程序 60. diskmgmt.msc---磁盘管理实用程序 61. dcomcnfg-------打开系统组件服务 62. ddeshare-------打开DDE共享设置 63. dvdplay--------DVD播放器 64. net stop messenger-----停止信使服务 65. net start messenger----开始信使服务 66. notepad--------打开记事本 67. nslookup-------网络管理的工具向导 68. ntbackup-------系统备份和还原 69. narrator-------屏幕“讲述人” 70. ntmsmgr.msc----移动存储管理器 71. ntmsoprq.msc---移动存储管理员操作请求 72. netstat -an----(TC)命令检查接口 73. syncapp--------创建一个公文包 74. sysedit--------系统配置编辑器 75. sigverif-------文件签名验证程序 76. sndrec32-------录音机 77. shrpubw--------创建共享文件夹 78. secpol.msc-----本地安全策略 79. syskey---------系统加密，一旦加密就不能解开，保护windows xp系统的双重密码 80. services.msc---本地服务设置 81. Sndvol32-------音量控制程序 82. sfc.exe--------系统文件检查器 83. sfc /scannow---windows文件保护 84. tsshutdn-------60秒倒计时关机命令 84. tsshutdn-------60秒倒计时关机命令 85. tourstart------xp简介（安装完成后出现的漫游xp程序） 86. taskmgr--------任务管理器 87. eventvwr-------事件查看器 88. eudcedit-------造字程序 89. explorer-------打开资源管理器 90. packager-------对象包装程序 91. perfmon.msc----计算机性能监测程序 92. progman--------程序管理器 93. regedit.exe----注册表 94. rsop.msc-------组策略结果集 95. regedt32-------注册表编辑器 96. rononce -p ----15秒关机 97. regsvr32 /u *.dll----停止dll文件运行 98. regsvr32 /u zipfldr.dll------取消ZIP支持 99. cmd.exe--------CMD命令提示符 100. chkdsk.exe-----Chkdsk磁盘检查 101. certmgr.msc----证书管理实用程序 102. calc-----------启动计算器 103. charmap--------启动字符映射表 104. cliconfg-------SQL SERVER 客户端网络实用程序 105. Clipbrd--------剪贴板查看器 106. conf-----------启动netmeeting 107. compmgmt.msc---计算机管理 108. cleanmgr-------垃圾整理 109. ciadv.msc------索引服务程序 110. osk------------打开屏幕键盘 111. odbcad32-------ODBC数据源管理器 112. oobe/msoobe /a----检查XP是否激活 113. lusrmgr.msc----本机用户和组 114. logoff---------注销命令 115. iexpress-------木马捆绑工具，系统自带 116. Nslookup-------IP地址侦测器 117. fsmgmt.msc-----共享文件夹管理器 118. utilman--------辅助工具管理器 119. gpedit.msc-----组策略 120. explorer-------打开资源管理器 其它 arp -a # 显示当前局域网ip与物理地址 net view # 显示局域网用户 nbtstat # 详细局域网用户 sfc /scannow # windows 文件检查器（修复系统） shutdonw # 关机等一系列指令 # 注册表 使用UTC时间(兼容linux) cmd\u0026gt; Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 # 工具 端口映射器 远程vpn代理到ssh everything 文件快速搜索工具 远程访问电脑文件的服务器 花生壳 动态域名软件，已申请域名，ip经常变换时使用 xmanager ssh工具 端口映射 portmap xshell secureCRT Xmanager # 可运行图形界面如vnc teamViewer # 可图形界面 cmder # windows命令行工具 网络 # teamviewer # # 远程桌面 wireshark # # 抓包 charlet # # 抓包 mitmproxy # # 抓包 命令 mitmdump mitmproxy mitmweb Burp Suite # # 抓包 fiddler # # 抓包 whistle # # 抓包 tcpdump # # 抓包 anyproxy # # 代理http/https proxychains # # 代理 chrome # 介绍 webkit: chrome firefox safari的内核，来源于kde的khtml与kjs 快捷键 ctrl + f5 无缓存刷新 f12 调试模式 调试模式 js调试 sources-\u0026gt; js文件打断点调试 # “{}”按钮是格式化代码，右边按钮单步调试，依次为执行， 跳过进入方法，进入方法，跳出方法，开启／停止调试，暂停 //# sourceURL=base.js console 可以查看js常量，如THREE.VERSION 设置页 about:about # 进入查看所有设置页 chrome:extensions chrome:flags # 可以开启硬件加速解码 集成抓包工具 chrome://net-internals/#events chrome://net-export 导出文件,netlog-viewer.appspot.com分析 插件 ARC Welder # android模拟器 firefox # 代理设置 “编辑”→“首选项”→“高级”→“网络”→“设置”→“手动配置代理” mozvr 介绍 mozilla vr 虚拟现实 购买Oculus Rift头盔来看它的网页 数据分析 # paraview # # 数据可视化 finreport # # 数据可视化 设计 # sketch # # mac下轻量ui设计工具 rose # # ibm uml工具 开发 # vim # sublime # 功能 显示风格好 缩略图 热加载(不改变原文件) 插件 多文件夹查找 多视窗 命令模糊搜索下拉菜单 柜形选择 V8插件，js运行控制台 js校验 vi 操作设置 修改配色方案 快捷键 批量修改 idle # # python tkinter开发的python ide lighttable # # clojure hbuilder # # h5 komodo edit # # 免费跨平台，多pl vscode # source insight # gerrit # # 查看代码 keil # # 嵌入式 客户端 # datastudio # # ibm数据库连接工具 plsql # oracle sql developer # navicat # # ios的数据库操作gui robo3t # # 原robomongo, 免费 studio3t # # mongodb, 收费 字体 # 中文等宽 Sarasa Mono SC https://github.com/be5invis/Sarasa-Gothic "},{"id":99,"href":"/docs/db/","title":"数据库","section":"Docs","content":" 基础 # 数据库类型 关系型数据库 模糊型数据库 # 存放模糊数据，提供函数 如模糊数，包括模糊区间数，模糊中心数，模糊集合数 隶属函数 统计数据库 # 管理统计数据 这类数据库包含有大量的数据记录，但其目的是向用户提供各种统计汇总信息，而不是提供单个记录的信息。 网状数据库(层次数据库) # 处理以记录类型为结点的网状数据模型 处理方法是将网状结构分解成若干棵二级树结构，称为系。 演绎数据库 # 指具有演绎推理能力 实现 数据库管理系统 规则管理系统 外延数据库 将推理用的事实数据存放在数据库中 内涵数据库 用逻辑规则定义要导出的事实 主要研究内容: 如何有效地计算逻辑规则推理。 递归查询的优化 规则的一致性维护 其它数据存储方式 文件系统 版本控制 保存持久状态 CQRS(command query responsibility segregation) 查询(query) 命令(command) 领域模型(domain model) 领域事件(domain event) 对象数据库 趋势 分布式new sql # tidb Polyglot persistence (混合持久化) # 将对不同数据库的操作封装成服务 事务隔离级别 读未提交（Read Uncommitted） # 读其它事务未提交的数据 现象 不允许更新丢失 允许脏读(dirty read) # 事务中读到不存在数据, 是其它事务修改中的数据 原理 可同时读 不同时写，多事务写 实现 排他写锁 读提交（Read Committed） # 读其它事务提交的数据 现象 不允许脏读 允许不可重复读(nonRepeatable read) # 事务中前后查询不一致 原理 可同时读 单事务写 实现 瞬间共享读锁 排他写锁 可重复读（Repeatable Read） # 读到的数据加锁，解决不可重复读问题 现象 不允许脏读 不允许不可重复读 允许幻读(phantom read) # 事务中存在未生效行，是其它事务的插入或删除 原理 读到的数据(加锁)不写 单事务写 实现 # 读涉及范围加锁 共享读锁 排他写锁 序列化（Serializable） # 或叫串行化 原理 事务序列化执行 实现 读锁写锁互斥 事务特点(ACID) 原子性(atomicity) # 什么都做或都不做 一致性(correspondence) # 事务前后数据库状态一致, 事务中断时也不会有暂时状态 隔离性(isolation) # 事务间不干扰 持久性(durability) # 提交结果是永久的 索引存储 B+ tree LSM(log-structured merge) tree fractal tree OLTP和OLAP CAP(一致性、可用性、分区容错性)中, OLTP要求ca或cp, OLAP要求ap OLTP要求写优化, OLAP要求查优化 OLTP要求优化latency, OLAP要求优化throughput OLTP基于row, OLAP基于column OLTP看中IOPS, OLAP看中data-size传输 分布式数据库 面临问题 ACID CAP scale out self-healing 运维友好 sql 事务 性能 api用明文或二进制 升级方案 硬件，网络，网络模型，存储模型，语言 分布式协议，压缩方案，ha，api，运维方案，存储计算分离，缓存方案 rds # # relational database service 缺点 阻抗失谐 # 和内存中的模型存在差异 安全 sql注入 # 应该写符号编译sql 范式 # Normal Form 用于避免冗余数据 第一范式(1NF) 列不可再细分列(原子性) 第二范式(2NF) 必须有主键，允许联合主键 其它列依赖完整主键(不能只依赖一部分) 第三范式(3NF) 其它列直接依赖主键(非传递依赖，如A依赖B, B依赖主键) 实例 postgres sqlserver mysql mariadb percona # mysql分支, Oracle发布的最接近官方mysql的发行版 drizzle # mysql分支 oracle db2 oceandb h2database # java编写，可嵌入java使用 tidb sqlite # 命令 sqlite3 数据库文件 语法 .table # 查看所有表 .schema # 查看建表语句 sql # 语法 注释 -- # 单行注释 /**/ # 多行注释 单引号 字符串大小写敏感 双引号 转日期时, 双引号直接显示。to_char(sysdate,'yyyy \u0026quot;年\u0026quot; mm \u0026quot;月\u0026quot; dd \u0026quot;日\u0026quot; day') 表别名不加as关键字, 有别名后原名无效 oracle || # 管道符号 select ename || '的薪水是' || sal from emp; 定义(DDL, data definition language) create database db1 # create or replace default character set utf8 # 默认编码 collate utf8_general_ci; # 校对规则(排序), ci(case insensitive)大小写不敏感, cs(case sensitive)大小写敏感 create table `tb1`( # create or replace `id` int unsigned unique not null auto_increment, # `id` int unsigned not null primary key, `id2` int unsigned, `name` varchar(20), `age` int unsigned, `birthday` date, primary key(`id`), # 主键 key idx_tb1_name (`name`), # 索引 foreign key(`id2`) references `tb2`(id) on delete cascade on update cascade # 外键、级联删除、级联更新, 不要用 )character set utf8 collate utf8_general_ci engine=innodb default charset=utf8; create table person like student; # 复制表结构 create table emp1 as select * from emp; # 复制内容 create view tb1_v (a,b) as select a, b from tb1 # create or replace create synonym tb2 for tb1; # 同义词 drop database db1; drop table tb1 purge; # 加purge不放入回收站 drop synonym tb1; truncate table tbq; alter database db1 character set gbk collate gbk_chinese_ci; # 更改数据库的编码 alter table tb1 add column sex char(1); alter table tb1 add constraint pr_id primary key (id); # 添加主键 alter table tb1 add constraint fk_id2 foreign key (st_id) references tb2(id); # 添加外键 alter table tb1 rename to tb2; alter table tb1 change sex gender char(1); # 只能改名，但类型必须写 alter table tb1 modify birthday varchar(20); # 只能改类型 alter table tb1 convert to character set utf8 collate utf8_general_ci; # 转换表编码 alter table tb1 drop column name; alter table field1 auto_increment = 5; # 更改自增长初始值 rename table tb1 to tb2; desc tb1; mysql use db1 source a.sql # 批执行 show status [from schema_name]; # 服务器状态 show databases; show create database db1; show tables; show create table tb1; show processlist # 查看当前连接 show VARIABLES LIKE \u0026quot;general_log%\u0026quot; # 查看变量　\u0026quot;version\u0026quot; # 显示版本 \u0026quot;autocommit\u0026quot; # 事务开启状态 0 off 1 on, set autocommit=off 或 0 show character set # 显示所有字符集 select @@sql_mode # 查看变量 select @@tx_isolation # 查看事务隔离级别 select select VERSION() # 显示版本 set sql_mode = '' # sql_mode定义支持的sql语法，数据校验。 set names 'gbk'; # 设置终端编码, 等价character_set_client=gbk 与 character_set_results=gbk set global general_log = 'ON' # 设置记录所有sql oracle create table tb1 ( sex char(1) check(sex in (0, 1)) # check约束 show user # 显示用户名 show recyclebin # 回收站 purge recyclebin # 闪回文件 oracle表创建时自动添加伪列 rowid # 唯一，指向当前记录 rownum # 唯一，字段列名, 从1开始，永远连续。 # 支持比较符号 \u0026lt;, \u0026lt;=(可以比较=1)。取别名后可以比较 \u0026gt;, = 操作(DML, data manipulation language) # 和DQL, data query language, select、from、where insert into tb1 values (3, 'a', null); insert into tb1 select * from tb2; insert into tb1(name) values ('a'),('b'); insert into tb1(a, b) select c, d from tb2 update tb1 set name='a' delete from tb1 select * from outrun.employee; # 限定数据库名 select field1 as f1 from tb1 as t1 select a, b into tb2 from tb1; select distinct (a+b) as c from tb1 # select distinct sum(price) as s 子查询 # 要求数量和类型匹配 # 不能利用索引(join可以), 不形成笛卡尔积 where a \u0026lt; (select max(a) from tb2) # 单行符号 =、\u0026lt;、\u0026gt; where a in () # 多行符号 in、any、all where a \u0026lt; any () # 小于一个就true where a \u0026lt; all () # 小于所有才true where a=1 and b=2 # where后不能出现列的别名，可以出现表的别名 a=1 or b=2 # \u0026lt;\u0026gt;表示!= # =可设置日期 a in (1,2) # a not in (1,2) a between 1 and 2 # a not between 1 and 2 a like 'a%' # 不能用* # % 匹配任意个字符 # _ 匹配一个字符 # \\ 转义 _ 或 % a regexp '^.*d.*$' # 匹配正则 a is null order by # null看作最大值 a asc # 升序 a desc # 降序 group by select a, count(b), avg(c) from tb1 # group by的select元素都是聚合函数 where b \u0026gt; 0 group by a having count(b) \u0026gt; 2 # having使用聚合函数条件 select a from tb1 # 子查询 where b in (select b from tb2 where c='c') group by a having count(distinct b) = (select count(*) from tb2 where c='c') select执行过程 # 每步都产生虚拟表 from 组装数据 join on where 筛选 group by 划分 # with, with是sql server的语法 计算聚合函数 having 筛选 计算表达式 select 字段 distinct order by 排序 top oracle insert into tb1 values(\u0026amp;id, '\u0026amp;s') # \u0026amp;是占位符，字符型数据加'' alter table tb1 rename column field1 to field2 常用 分页 select * from tb1 limit 0,1 # mysql, 从0开始，查找1条 select * from # oracle (select rownum r, a from tb1 where rownum\u0026lt;=20) where r \u0026gt; 10 select * from # oracle, 效率低 (select rownum rn, a from tb1) where rn between 21 and 40 select rownum,emp.* from emp # oracle, 效率低 where rownum \u0026lt;=4 minus select rownum,emp.* from emp where rownum \u0026lt;=2; 控制(DCL data control language) grant all privileges on db1.tb1 # 授权 # grant insert,delete,update,select,create on db1.tb1 to 'user1'@'host1' # localhost本地 , %代表远程 identified by 'pwd1' with grant option; # 有授权权限 grant select any table # oracle to user1 revoke select any table # oracle from user1 revoke privilege ON db1.tb1 from 'user1'@'host1'; # 撤销权限 flush privileges; # 提交授权修改, oracle不用flush直接生效 oracle alter user user1 account unlock # 解锁用户 alter user user1 identified by user1 # 改密码 conn / as sysdba # 换角色 事务 start transaction; savepoint a; rollback to [savepoint] a; rollback; commit; 聚合函数 avg() count() max() min() sum() 连接(join) 内连接(inner) # 带条件的交叉连接 # 只查出符合条件的记录 select * from tb1 a # 显示 inner join tb2 b on a.c_id=b.c_id select * from tb1 a, tb2 b # 隐示 where a.c_id=b.c_id 自连接 # 表中有层次关系。自连接无中间表, 效率快 select a.c, b.d from course as a, course as b where a.c=b.d 外连接(outer) # 以一表为基准，查另一表 # 可查出不符合条件的记录(另一表无对应值，标记成null) 左外连接 # 以左为基准 select * from tb1 as a left [outer] join tb2 as b on a.c_id=b.c_id select a.c_id # oracle from tb1 a, tb2 b where a.c_id = b.c_id(+) 右外连接 right [outer] join 全外连接 # full [outer] join, 只oracle支持 # 先左连接再右连接，取的是交集 select * from a full join b on a.c_id=b.c_id 交叉连接(cross) # 笛卡尔积 # 有where条件时，会先生成where查出的两个表 select * from tb1 a [cross] join tb2 b where a.c_id = b.c_id; 自然连接(natural) # 自动检查相同名称的列，类型会隐式转换，不能指定显示列(或用*)、不能用on语句 # 每种连接名称前加natural都是自然连接 select * from tb1 a natural innter join tb2 b 集合 # 数量,类型匹配 # 前语句别名可用,后语句别名不可用 select a, b from tb1 union [all] select a, b from tb2 # 并集, all 允许重复 # intersect 交集 # minus 差集 约束(constraint) not null unique primary key primary key unique, not null auto_increment primary key(col1, col2) # 联合主键 foreign key constraint fk_id2 foreign key(id2) references tb2(id) # 被引用的列要建索引 # 被引用的记录不可删除 # 被引用的值要级联修改 on update cascade on delete cascade # 级联约束 检查约束 # oracle支持 存储过程 # 优势 高效, 首次运行进行预编译 模块化 更快执行，大量sql时，比sql快 减少网络流量 安全机制 针对过程授权 调用时看不到语句信息和数据 避免sql注入 # 参数视为文字 可对过程加密 劣势 不可移植 需要专人维护 逻辑变更时修改不灵活 触发器 # 用途 表级联更改 实现比check约束复杂的逻辑 强制执行业务规则 评估修改后表状态，执行操作 基础 同一表不能建立2个相同类型触发器 视图 # 特点 优点 简化查询 提供独立访问 限制访问 查看时，生成sql查看, 有即时性 更新视图表级联 不能更新的视图包含元素 组函数 distinct group by rownum grant可授权 不能与表名重名 mysql保存在information_schema.views中 删除不放回收站 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] # TEMPTABLE是临时表，不能更新 VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] # 通过该视图更改的数据，可再通过该视图查看到(满足视图的限制) o-\u0026gt; CREATE VIEW test.v AS SELECT * FROM t; o-\u0026gt; CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t; # 可以计算 o-\u0026gt; CREATE VIEW v AS SELECT CHARSET(CHAR(65)), COLLATION(CHAR(65)); # 可以联合 o-\u0026gt; CREATE ALGORITHM = MERGE VIEW v_merge (vc1, vc2) AS SELECT c1, c2 FROM t1 WHERE c3 \u0026gt; 100 查询解释 SELECT * FROM v_merge WHERE vc1 \u0026lt; 100; 会执行 SELECT c1, c2 FROM t WHERE (c3 \u0026gt; 100) AND (c1 \u0026lt; 100); ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] # CASCADED 忽略主外键关系 DROP VIEW [IF EXISTS] view_name [, view_name] ... [RESTRICT | CASCADE] SHOW CREATE VIEW view_name 索引 # 特点 第一次查询时创建 加快查询的速度，表删除时索引自动删除 primary key 与 unique 自动建立 命中 where 中添加对应索引的条件， 只能从前向后命中 是否使用 使用 分布广 经常在where中出现 表经常访问 不使用 表小 不经常出现的列 经常更新的字段 类型 index unique primary key CREATE INDEX index_name ON table_name (column_list) # 创建索引，primary key已有索引 CREATE UNIQUE INDEX index_name ON table_name (column_list) ALTER TABLE table_name ADD INDEX index_name (column_list) # 创建索引，列名逗号分隔。index_name缺省时，根据第一个索引列取名 ALTER TABLE table_name ADD UNIQUE (column_list) ALTER TABLE table_name ADD PRIMARY KEY (column_list) DROP INDEX index_name ON talbe_name ALTER TABLE table_name DROP INDEX index_name # 等价于前一个 ALTER TABLE table_name DROP PRIMARY KEY show index from tb1; show keys from tb1; Table # 表的名称。 Non_unique # 如果索引不能包括重复词，则为0。如果可以，则为1。 Key_name # 索引的名称。 Seq_in_index # 索引中的列序列号，从1开始。 Column_name # 列名称。 Collation # 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。 Cardinality # 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。 Sub_part # 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。 Packed # 指示关键字如何被压缩。如果没有被压缩，则为NULL。 Null # 如果列含有NULL，则含有YES。如果没有，则该列含有NO。 Index_type # 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。 Comment # 更多评注。 序列 # # 共享对象唯一的数值，不一定连续 create sequence tb1_seq INCREMENT BY 10 # 步长是10 START WITH 120 # 从120开始 MAXVALUE 9999 # 最大到9999 NOCACHE # 不缓存序列的值（缓存是先创建很多再取出，不缓存则是什么时候取，什么时候创建） NOCYCLE; # 到最大值的时候是否循环 select seq.nextval from dual # nextval下一个序列 currval当前序列 第一次使用必须是nextval insert into emp(id) vallues(seq.nextval); # 使用 alter sequence tb1_seq increment by 10; start with 100; # 错误 ，不能变更启动序列，只能在创建序列时指定 drop sequence seq 性能优化 # 设计 库 分库 拆微服务 主从 # master不拆，slave树形 索引与数据分库 表 不要代价高的关系(外键、级联) 字段可冗余，为了提高性能，但要考虑同步。不能是频繁修改的字段，不是varchar和text 单表行数超过500万或意表容量超过2GB，才分库分表 分表 # 垂直分字段，水平分记录 表名加hash到多表 partitioning key字段分表 # proxy网关分流 时间 地点 建lookup table查找对应表 冷热分离 用表变量代替临时表 表变量数据大时，只有主键索引 大量重复引用大型表或常用表数据时，可创建临时表。一次性事件，最好导出表 临时表时数据大时, 用select into代替create table, 避免log过多 临时表最后要先truncate, 再drop, 避免表较长时间锁定 类型 尽量not null 数字类型尽量用 char存几乎定长字符串类型 varchar变长字符串，不预先分配空间，长度不要超过5000 text存大于5000,独立出表用主键对应，避免影响其它字段索引效率 bool用unsigned tinyint 小数类型用decimal，不用float double # float和double存储的时候，存在精度损失的问题 # 长度超过decimal范围，拆成整数和小数分开存 合适的字符长度，不但节约表空间，节约索引存储，更提升检索速度 unsigned tinyint 0到255 unsigned smallint 0到65535 unsigned int 0到42.9亿 unsigned bigint 0到10的19次方 索引 有唯一特性，都建唯一索引 # insert速度损耗可以忽略，但明显提高查找速度 # 不建唯一索引，总会有脏数据产生 where与order by涉及的列建索引 建组合索引时，区分度最高的在左边 where a=? and b=? ，a列几乎接近唯一值，只需要建idx_a索引 非等号和等号混合时，等号是最左边，如where a\u0026gt;? and b=?, 那么b在索引最前列 字段值大量重复时，索引作用不大 索引降低insert与update效率 索引数据列少更新 # 数据列为表存储方式，更新会调整整表存储 varchar建索引，要指定索引长度 一般字符串数据，长度为20的索引，区分度高达90%以上 count(distinct left(列名，索引长度)) / count(*)来计算 语句 where放弃索引，全盘扫描 比较符 in # in元素尽量控制在1000内 not in # exists代替in select num from a where num in(selct num from b) 改为 select num from a where exists(select 1 from b where num=a.num) is null is not null \u0026lt;\u0026gt; or like '%a'模糊开头 where对字段用表达式或运行函数 where num/2=100 改为 where num = 100*2 where year(admin_time)\u0026gt;2014 改为 where admin_time\u0026gt;'2014-01-01' where使用参数 # 因为运行时解析局部变量，访问计划在编译时进行 select id from t where num=@num 改为 select id from t with(index(索引名)) where num=@num # 强制使用索引 select 不要写无意义查询 select a into #t from t where 1=1 改为 create table #t 不要select * # 增加查询分析器解析成本，增减字段容易与resultMap不一致 不select for update # 长期锁定行(游标默认都用) 不要用游标 函数 使用count(*)统计行数 用count(distinct col1, col2)来计算不重复 sum(col)会返回null，如下解决 SELECT IF(ISNULL(SUM(g)), 0, SUM(g)) FROM table1 使用ISNULL()来判断NULL # NULL与任何值比较都为NULL 业务 sql优化至少到range级别 # explain结果type= # all 全表扫描 # index 扫描整个索引表，几乎相当于全表扫描 # range 用索引选择范围 # ref 非唯一索引扫描 # eq_ref 唯一索引扫描 # consts 索引一下就找到，单表中最多有一个匹配行(主键或唯一索引), 在优化阶段即可读取到数据 # system 表只有一行 库 不在数据库写逻辑 # 不使用存储过程, 难调试和扩展，没有移植性 正确锁类型 # 隐式锁、显式锁、行锁、页锁、范围锁、表锁、数据库锁 全球化用utf-8，要使用表情，用utfmb4 SELECT LENGTH(\u0026quot;轻松工作\u0026quot;) 返回 12 SELECT CHARACTER_LENGTH(\u0026quot;轻松工作\u0026quot;) 返回4 事务 不要多阶段提交 # 更好的拆分表，而不多阶段提交延长单一数据库生命 避免大事务 连接释放 crud TRUNCATE快，但无事务不触发trigger, 不要在开发代码中使用 修改数据时，先select，避免误删除和修改 分页时count为0直接返回 用覆盖索引来变相加快查询，如explain的结果，命中时出现using index 避免返回大量数据 order by注意利用索引的有序性，order by最后的字段是组合索引的最后，避免file_sort 如 where a=? and b=? order by c; 索引 a_b_c 有范围查找时，有序性无法利用，如 where a\u0026gt;10 order by b 联合 多表联合查询拆分多个query # 容易锁表和阻塞 禁止三表join join的字段类型要一致 被关联的字段需要有索引 注意sql性能 join时，小结果驱动大结果 # left join小表在左 优化前 select * from admin left join log on admin.admin_id = log.admin_id where log.admin_id\u0026gt;10 优化后 select * from (select * from admin where admin_id\u0026gt;10) T1 left join log on T1.admin_id = log.admin_id mysql 引擎选择 limit 1 只查一条时，加limit 1, 引擎会找到一条马上返回 limit基数大用between, 分页时要找到id, 避免offset之前全查的问题 优化前 select * from admin order by id limit 10000,10 优化后 select * from admin where id between 10000 and 10010 order by id 子查询id select a.* from 表1 a, (select id from 表1 where 条件 limit 100000,20) b where a.id=b.id nosql # 介绍 aggregate-oriented (面向聚合) 键值 文档 列族 relationship-oriented (面向关系) 图 特点 少约束(schemaless) 应用程序数据库（作为微服务的数据库来解耦） 聚合(aggregate) # 领域驱动设计中提出 # 图除外 图支持事务 牺牲一部分一致性和持久性 问题 存在不一致窗口 会话一致性问题 兼容 物化视图来处理更新 实时BI, 来更新中间关系聚合 一致性 锁 条件更新(更新前检查) 版本戳 # http 中的etag 写入仲裁与读取仲裁 复制因子大于某值时认为写入完成 读取多于某值个节点数据并相同时，认为读到最新数据 用zookeeper等外部“事务”程序库同步读写操作 图 # 介绍 领域 关系是一等公民 大部分不支持分布式 Gremlin，Cypher 查询语言 适用 互联数据 运输等基于位置的服务 推荐引擎 不适用 经常更新 工具 flockDB # 仅支持单深度关系及邻接表 hyperGraphDB infiniteGraph allegroGraph orientdb pregel # google图数据库 neo4j # 介绍 使用zookeeper 特点 完全兼容ACID 主从复制 副本从节点 从节点写数据，先同步到主节点, 再由主节点分发 配置 dbms.connector.bolt.enabled=true dbms.connector.bolt.listen_address=0.0.0.0:7687 dbms.connector.http.enabled=true dbms.connector.http.listen_address=0.0.0.0:7474 # 远程访问 cql 数据类型 boolean byte # 8位整数 short # 16位整数 int # 32位整数 long # 64位整数 float # 32位浮点数 double # 64位浮点数 char # 16位字符 string 命令 create # 创建, 自动生成属性, 最大约为35亿 CREATE (dept:Dept:Dept2 { deptno:1,name:\u0026ldquo;a\u0026rdquo;}) # 节点名:多标签 {属性} CREATE (p1:Profile1)-[r1:LIKES]-\u0026gt;(p2:Profile2) # 2节点,1关系\nMATCH (cust:Customer),(dept:Dept) WHERE cust.id = 1 AND dept.deptno= 1 CREATE (cust)-[r:Do{a:1}]-\u0026gt;(dept) RETURN cust,dept,r # match并创建关系 merge # 不存在时才创建 MERGE (gp2:GoogleProfile2{ Id: 201402,Name:\u0026quot;Nokia\u0026quot;}) set # 更新 MATCH (dc:DebitCard) SET dc.atm_pin = 3456 RETURN dc delete # 删除节点，关系 MATCH (cc: CreditCard)-[rel]-(c:Customer) DELETE cc,c,rel remove # 删除属性 MATCH (dept:Dept) REMOVE dept.dname RETURN dept match # 查询 MATCH (dept: Dept) RETURN dept # 节点名:标签名, return 节点名.属性名 MATCH (dept: Dept) RETURN dept.deptno,dept.dname # 只查属性,不形成图 MATCH ( cc: CreditCard)-[r]-() RETURN r # 全集 return RETURN dept # 节点名 RETURN dept.deptno,dept.dname as dname where WHERE emp.name = 'Abc' OR emp.name = 'Xyz' WHERE cust.id = \u0026quot;1001\u0026quot; AND cc.id= \u0026quot;5001\u0026quot; WHERE e.id is not null WHERE e.id in [1,2] MATCH (emp:Employee) WHERE emp.name = 'Abc' OR emp.name = 'Xyz' RETURN emp # 加where order by MATCH (emp:Employee) RETURN emp.empid,emp.name,emp.salary,emp.deptno ORDER BY emp.name DESC union MATCH (cc:CreditCard) RETURN cc.id,cc.number UNION MATCH (dc:DebitCard) RETURN dc.id,dc.number union all limit和skip MATCH (emp:Employee) RETURN emp LIMIT 2 SKIP 2 create index CREATE INDEX ON :Customer (name) # 建索引, 标签(属性) drop index DROP INDEX ON :Customer (name) # 删除索引 create constraint CREATE CONSTRAINT ON (cc:CreditCard) ASSERT cc.number IS UNIQUE # 约束 drop constraint DROP CONSTRAINT ON (cc:CreditCard) ASSERT cc.number IS UNIQUE 函数 信息 RETURN ID(movie),TYPE(movie) # 显示id, 标签 字符串 RETURN LOWER(e.name) RETURN SUBSTRING(e.name,0,2) 聚合 RETURN COUNT(*) RETURN MAX(e.sal),MIN(e.sal) RETURN SUM(e.sal),AVG(e.sal) 关系 RETURN STARTNODE(r) # 返回开始节点 RETURN ENDNODE(r) HugeGraph # 百度开源 NebulaGraph # 分布式图数据库 TigerGraph # 列族 # 特点 键空间 适用 事件记录 # 事件id为行 内容管理 计数器 带过期的列 不适用 ACID事务 多行数据聚合 工具 cassandra hbase amazon simpleDB hypertable bigtable clickhouse # 用于OLAP, 实时分析 cassandra # 特点 适用大规模数据 良好的分布式扩展性 功能比key-value丰富，不如mongo 写快于读 不稳定 没有主节点，所有节点平等 查询语言CQL 列TTL(秒) 命令 cqlsh localhost 9042 数据库命令 use aaa # 用aaa键空间 hbase # 特点 hdfs存储，分布式，面向列 可利用map reduce 特点 多版本 列权限控制 多个列划分为列族，可设置保留多少版本 多行划分为region 空列不占空间，可稀疏存储 无类型，所有类型都是字符串 行一致性，一行数据在一个server 查询方式有限：rowkey, rowkey的range, 全表扫描 协处理器coprocessors 观察者observer（监听器） 终端endpoint（rpc调用代码） 文档 # 适用 事件记录 内容管理 网站分析与实时分析数据 电子商务中产品或订单 不适用 事务 持续变化的数据 工具 couchDB orientDB ravenDB terrastore xml数据库 mongoDB memDB # 带事务的mongo tokumx couchDB # 特点 apache托管, alang语言开发的，面向文档的分布式数据库 json结构，易于存储cms, 电话本，地址本等半结构化数据。存储类似于lucene的index 易添加，不易修改 主主双向复制 键值 # 适用 session 用户配置信息 购物车 不适用 数据间关系 多项操作的事务 模糊键查询 对集合关键字操作 工具 redis riak # 类cassandra berkeleyDB levelDB # google memcached project voldemort tokyo cabinet rocksDB groupCache # go编写 时序 # influxDB # go编写 newsql # 工具 分布式 google spanner voltdb clustrix nuodb tidb # go编写 h-store foundationDB scalebase dbshards scalearc tokudb memsql tidb # 流式数据库 # piplelineDB # 依赖zeromq, 记录时间段内的事件 全文索引 # Lucene ElasticSearch Solr Sphinx proxy # mycat # # 目录结构 bin mycat # 服务器启动等 conf wrapper.conf # jvm配置参数(如分配系统资源) server.xml # 服务器参数，用户授权 schema.xml # 逻辑库，表，分片的定义．修改后要重启 log4j.xml # 配置输出到logs/mycat.log的日志 logs mycat.log # 日志（每天一个日志文件）， 可调整输出级别 # 默认值 默认数据端口: 8066 默认管理端口: 9066 # 配置 wrapper.conf # jvm配置参数(如分配系统资源) server.xml # 服务器参数，用户授权 schema.xml # 逻辑库，表，分片的定义．修改后要重启 log4j.xml # 配置输出到logs/mycat.log的日志 mysql linux版数据库设置大小写不敏感，否则会发生表找不到的问题 my.cnf [mysqld] lower_case_table_names = 1 # 例子 server.xml \u0026lt;mycat\u0026gt; \u0026lt;user name=\u0026quot;test\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot;\u0026gt;test\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026quot;schemas\u0026quot;\u0026gt;TESTDB\u0026lt;/property\u0026gt; \u0026lt;/user\u0026gt; \u0026lt;/mycat\u0026gt; schema.xml \u0026lt;mycat\u0026gt; \u0026lt;schema name=\u0026quot;TESTDB\u0026quot; checkSQLschema=\u0026quot;false\u0026quot; sqlMaxLimit=\u0026quot;100\u0026quot;\u0026gt; \u0026lt;table name=\u0026quot;travelrecord\u0026quot; dataNode=\u0026quot;dn1,dn2,dn3\u0026quot; rule=\u0026quot;auto-sharding-long\u0026quot; /\u0026gt; \u0026lt;table name=\u0026quot;employee\u0026quot; primaryKey=\u0026quot;ID\u0026quot; dataNode=\u0026quot;dn1,dn2\u0026quot; rule=\u0026quot;sharding-by-intfile\u0026quot; /\u0026gt; \u0026lt;table name=\u0026quot;company\u0026quot; primaryKey=\u0026quot;ID\u0026quot; type=\u0026quot;global\u0026quot; dataNode=\u0026quot;dn1,dn2,dn3\u0026quot; /\u0026gt; \u0026lt;table name=\u0026quot;goods\u0026quot; primaryKey=\u0026quot;ID\u0026quot; type=\u0026quot;global\u0026quot; dataNode=\u0026quot;dn1,dn2\u0026quot; /\u0026gt; \u0026lt;table name=\u0026quot;hotnews\u0026quot; primaryKey=\u0026quot;ID\u0026quot; dataNode=\u0026quot;dn1,dn2,dn3\u0026quot; rule=\u0026quot;mod-long\u0026quot; /\u0026gt; \u0026lt;table name=\u0026quot;customer\u0026quot; primaryKey=\u0026quot;ID\u0026quot; dataNode=\u0026quot;dn1,dn2\u0026quot; rule=\u0026quot;sharding-by-intfile\u0026quot;\u0026gt; \u0026lt;childTable name=\u0026quot;orders\u0026quot; primaryKey=\u0026quot;ID\u0026quot; joinKey=\u0026quot;customer_id\u0026quot; parentKey=\u0026quot;id\u0026quot;\u0026gt; \u0026lt;childTable name=\u0026quot;order_items\u0026quot; joinKey=\u0026quot;order_id\u0026quot; parentKey=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;/childTable\u0026gt; \u0026lt;childTable name=\u0026quot;customer_addr\u0026quot; primaryKey=\u0026quot;ID\u0026quot; joinKey=\u0026quot;customer_id\u0026quot; parentKey=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/schema\u0026gt; \u0026lt;dataNode name=\u0026quot;dn1\u0026quot; dataHost=\u0026quot;localhost1\u0026quot; database=\u0026quot;db1\u0026quot; /\u0026gt; \u0026lt;dataNode name=\u0026quot;dn2\u0026quot; dataHost=\u0026quot;localhost1\u0026quot; database=\u0026quot;db2\u0026quot; /\u0026gt; \u0026lt;dataNode name=\u0026quot;dn3\u0026quot; dataHost=\u0026quot;localhost1\u0026quot; database=\u0026quot;db3\u0026quot; /\u0026gt; \u0026lt;dataHost name=\u0026quot;localhost1\u0026quot; maxCon=\u0026quot;1000\u0026quot; minCon=\u0026quot;10\u0026quot; balance=\u0026quot;0\u0026quot; writeType=\u0026quot;0\u0026quot; dbType=\u0026quot;mysql\u0026quot; dbDriver=\u0026quot;native\u0026quot;\u0026gt; \u0026lt;heartbeat\u0026gt;select user()\u0026lt;/heartbeat\u0026gt; \u0026lt;writeHost host=\u0026quot;hostM1\u0026quot; url=\u0026quot;centos6.5_1:3306\u0026quot; user=\u0026quot;root\u0026quot; password=\u0026quot;asdf\u0026quot;\u0026gt; \u0026lt;/writeHost\u0026gt; \u0026lt;/dataHost\u0026gt; \u0026lt;/mycat\u0026gt; rules.xml \u0026lt;mycat\u0026gt; \u0026lt;tableRule name=\u0026quot;sharding-by-intfile\u0026quot;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;columns\u0026gt;sharding_id\u0026lt;/columns\u0026gt; \u0026lt;algorithm\u0026gt;hash-int\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;tableRule name=\u0026quot;mod-long\u0026quot;\u0026gt; \u0026lt;rule\u0026gt; \u0026lt;columns\u0026gt;id\u0026lt;/columns\u0026gt; \u0026lt;algorithm\u0026gt;mod-long\u0026lt;/algorithm\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/tableRule\u0026gt; \u0026lt;function name=\u0026quot;hash-int\u0026quot; class=\u0026quot;org.opencloudb.route.function.PartitionByFileMap\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;mapFile\u0026quot;\u0026gt;partition-hash-int.txt\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;function name=\u0026quot;mod-long\u0026quot; class=\u0026quot;org.opencloudb.route.function.PartionByMod\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;count\u0026quot;\u0026gt;3\u0026lt;/property\u0026gt; \u0026lt;/function\u0026gt; \u0026lt;/mycat\u0026gt; partition-hash-int.txt 10000=0 10010=1 sql create table employee (id int not null primary key,name varchar(100),sharding_id int not null); insert into employee(id,name,sharding_id) values(1,'leader us',10000); insert into employee(id,name,sharding_id) values(2,’me’,10010); insert into employee(id,name,sharding_id) values(3,’mycat’,10000); insert into employee(id,name,sharding_id) values(4,’mydog’,10010); create table company(id int not null primary key, name varchar(100)); insert into company(id,name) values(1,'hp'); insert into company(id,name) values(2,'ibm'); insert into company(id,name) values(3,'oracle'); create table customer(id int not null primary key, name varchar(100), company_id int not null, sharding_id int not null); insert into customer (id,name,company_id,sharding_id )values(1,'wang',1,10000); insert into customer (id,name,company_id,sharding_id )values(2,'xue',2,10010); insert into customer (id,name,company_id,sharding_id )values(3,'feng',3,10000); create table orders (id int not null primary key ,customer_id int not null,sataus int ,note varchar(100)); insert into orders(id,customer_id)values(1,1); insert into orders(id,customer_id)values(2,2); create table travelrecord( id bigint not null primary key,username varchar(100), traveldate DATE, fee decimal, days int); insert into travelrecord(id,username,traveldate,fee,days)values(1,'wang','2014-01-05',510.5,3); insert into travelrecord(id,username,traveldate,fee,days)values(5000001,'wang','2014-01-05',510.5,3); create table hotnews(id int not null primary key, title varchar(400), created_time datetime); insert into hotnews(id,title,created_time)values(1,'first',now()); insert into hotnews(id,title,created_time)values(5,'first',now()); create table goods(id int not null primary key,name varchar(200),good_type tinyint,good_img_url varchar(200), good_created date, good_desc varchar(500), price double); create table order_items(id int not null primary key, order_id int not null); insert into order_items(id, order_id) values(1,1); # 经验 o-\u0026gt; 数据库上的数据修改(权限修改)立即生效 o-\u0026gt; 支持跨库事务，且等待主从复制完成后完成事务(如全局表的复制) o-\u0026gt; virtualbox4.3下配置的mycat节点不能子表插入 o-\u0026gt; 可以配置jdbc数据库进行远程数据调用 o-\u0026gt; childTable中的joinKey与parentKey是必须字段, childTable不能配置dataNode o-\u0026gt; 同一个childTable出现在多个主表时(相当于mysql的多个外键)，会出错，提示该childTable重复创建 o-\u0026gt; childTable不能配置dataNode, 默认和主表存的dataNode相同 o-\u0026gt; 虽然childTable只能配一个，但mysql里可以配置多个外键，但要求外键关联的表配置\u0026gt;在相同的dataNode上 o-\u0026gt; 配置在两个dataHost中的表, show tables 时表名会显示两遍 o-\u0026gt; table不配置rule默认数据每个dataNode存一份，但是mycat查询时显示同id的两份数据，此方法不可用 o-\u0026gt; table不配置，不可以创建 o-\u0026gt; 全局序列号名称必需大写 o-\u0026gt; 不同dataNode中的普通表不可以关联查询 o-\u0026gt; 同样配置dn1, dn2 的两个普通外键关系表之间数据插入可能会出错(如: 表2数据在dn1中, 其外键关联表2在dn2中的数据时) "},{"id":100,"href":"/docs/cache/template/","title":"模板配置","section":"Cache","content":" 详见 # https://github.com/outrunJ/backup-script\n"},{"id":101,"href":"/docs/tool/test/","title":"测试","section":"工具","content":" 基础 # 方法 TDD # Test-Driven Development 阶段 单元测试阶段 单元测试 集成测试阶段 # 出厂测试 冒烟测试 # 测主流程 功能测试 黑盒 灰盒 # 集成测试阶段，黑盒但关注程序内部 白盒 回归测试 系统测试阶段 # 第三方测试 验收测试阶段 性能测试 # PTS(Performance Testing Service) 压力测试 # 系统失效的负载点 常规模式 # 稳定并发 梯度模式 # 并发梯度递增 目标模式 # 并发梯度递增，达到预设指标(CPU、用户数、TPS、RT等) 负载测试 # 满足性能指标情况下，最大负载 疲劳强度测试 # 长时间执行最大工作量，保证持续业务量指标 基准测试 # 统计多少时间内执行了多少次某个方法 大数据量测试 独立测试 # 针对存储、传输、统计、查询测试 综合测试 # 大数据量下压测，负载，疲劳结合 全链路压测 灰度发布 # 金丝雀发布 A/B测试 蓝绿测试 前端测试 structure/behavior(数据结构/行为)问题 # 判断是否有此耦合，用一个测试验证: 是否为应用逻辑编写一个单元测试而不需要dom结构存在 ## angular中没有这种问题，因为所有定位元素和处理事件的工作都是在angular内部完成的 ## 在测试时创建dom，就增加了测试的复杂性。而且页面变化时有更多维护要做。访问dom的操作很慢，测试反馈时间长 数据库 # sysbench # mysql 压测 --db-driver=mysql --mysql-host=visitor-bench.ctysoosgzk4k.rds.cn-north-1.amazonaws.com.cn --mysql-user=root --mysql-password=12345678 --threads=512 --events=1000000 --time=0 --report-interval=15 ./bench_visit_page_insert.lua run 接口 # jmeter # 压测场景 HEAP=\u0026quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m\u0026quot; jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder] loadrunner # 脚本参数 get web_url(\u0026quot;login\u0026quot;, \u0026quot;URL=http://192.168.0.14:9081/ryx-login/sso/login\u0026quot;, \u0026quot;Resource=0\u0026quot;, \u0026quot;RecContentType=text/html\u0026quot;, \u0026quot;Referer=\u0026quot;, \u0026quot;Snapshot=t1.inf\u0026quot;, \u0026quot;Mode=HTML\u0026quot;, EXTRARES, \u0026quot;Url=../ycls/img/banner1.jpg\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/banner2.jpg\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/banner3.jpg\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/userinput.png\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/sawtooth.png\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/tip2.png\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/pwdinput.png\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/login_back.png\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/tip1.png\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/codeinput.png\u0026quot;, ENDITEM, \u0026quot;Url=../ycls/img/loading-small2.gif\u0026quot;, ENDITEM, \u0026quot;Url=/favicon.ico\u0026quot;, \u0026quot;Referer=\u0026quot;, ENDITEM, LAST); post参数 web_submit_data(\u0026quot;getActivityParameter\u0026quot;, \u0026quot;Action=http://192.168.0.14:9081/tobacco/retail/lottery/getActivityParameter?jsonp=jQuery19109862107675272699_1401335732777\u0026quot;, \u0026quot;Method=POST\u0026quot;, \u0026quot;RecContentType=text/html\u0026quot;, \u0026quot;Referer=http://192.168.0.14:9081/tobacco/retail/index;jsessionid=7BBAFC6DE481FBCB1CB88D738BD7EE71\u0026quot;, \u0026quot;Snapshot=t6.inf\u0026quot;, \u0026quot;Mode=HTML\u0026quot;, ITEMDATA, \u0026quot;Name=requestType\u0026quot;, \u0026quot;Value=ajax\u0026quot;, ENDITEM, LAST); post直接传数据 web_custom_request(\u0026quot;dataservice\u0026quot;, \u0026quot;URL=http://202.110.222.207:7080/rtserver/rest/resource/tobacco/dataservice\u0026quot;, \u0026quot;Method=POST\u0026quot;, \u0026quot;Resource=0\u0026quot;, \u0026quot;RecContentType=text/plain\u0026quot;, \u0026quot;Referer=\u0026quot;, \u0026quot;Snapshot=t1.inf\u0026quot;, \u0026quot;Mode=HTML\u0026quot;, \u0026quot;Body= {\\\u0026quot;trans_code\\\u0026quot;:\\\u0026quot;1006\\\u0026quot;,\\\u0026quot;end_date\\\u0026quot;:\\\u0026quot;20140701\\\u0026quot;,\\\u0026quot;source\\\u0026quot;:\\\u0026quot;appkey\\\u0026quot;,\\\u0026quot;data\\\u0026quot;:\\\u0026quot;eyJiZWdpbl9kYXRlIjoiMjAxNDA2MDEiLCJlbmRfZGF0ZSI6IjIwMTQwNzAxIiwicG9zX2lkIjoiODg1MDAzMTAiLCJzb3VyY2UiOiJhcHBrZXkiLCJjdXN0b21lcl9pZCI6IjM3MDExMjEwNzQ2NyIsImFjY2Vzc190b2tlbiI6IiJ9\\\u0026quot;,\\\u0026quot;begin_date\\\u0026quot;:\\\u0026quot;20140601\\\u0026quot;,\\\u0026quot;mac\\\u0026quot;:\\\u0026quot;123\\\u0026quot;,\\\u0026quot;pos_id\\\u0026quot;:\\\u0026quot;88500310\\\u0026quot;,\\\u0026quot;customer_id\\\u0026quot;:\\\u0026quot;370112107467\\\u0026quot;,\\\u0026quot;access_token\\\u0026quot;:\\\u0026quot;\\\u0026quot;}\u0026quot;, LAST); phoenix # 介绍 web自动化测试工具 特点 分布式执行 无脚本模式执行 无人值守模式执行 自定模式执行 模块 数据维护模块 部署模式 server-client 仅windows下可用 socket通信 web部署 server与client放到tomcat或webLogic下部署 http通信 web页面控制与监控client端执行 wireshark siege siege -c 200 -r 100 http://www.google.com # 200并发，发送100次请求 tcpcopy # 基于tcp packets的请求复制工具, 在线流量导入到测试系统中 ab 内网测试, apache自带的压力测试工具, 安装apache后在bin目录中找到 ab -n1000 -c100 http://www.google.com/a.html # 100并发, 发送1000次请求 locust # 外网性能测试　http_load # 压测 http_load -rate 5 -seconds 10 http://www.baidu.com # -p 并发 # -f 总计访问数 # -r 每秒访问频率 # -s 总计访问时间 yslow # firefox插件，网页性能测试工具 gatling # dsl脚本, 生成报表 wrk # 压测 wrk -R5000 -d10s \u0026quot;http://internal-rope-api-1875734411.cn-north-1.elb.amazonaws.com.cn/online_agents/1\u0026quot; swagger # 文档与测试用例 fortio # istio压测工具 hey # http压测 js # heapdump # 堆内存快照 jslint supertest # 测http接口 sinon.js # 非运行测试，延时测试等 vows # asynchronous BDD(behaviour drven development) for Node chai # js断言 mock.js # 模拟生成接口假数据 benchmark # 介绍 测试代码执行性能 使用 var Benchmark = require('benchmark'); var suite = new Benchmark.Suite; var int1 = function(str){ return +str; }; var int2 = function(str){ return parseInt(str, 10); }; var int3 = function(str){ return Number(str); }; // 开始测试 var number = '100'; suite .add('+', function(){ int1(number); }); .add('parseInt', function(){ int2(number); }); .add('Number', function(){ int3(number); }); .on('cycle', function(event){ // 每个测试跑完后输出信息 console.log(String(event.target)); }) .on('complete', function(){ console.log('Fastest is' + this.filter('fastest').pluck('name')); }) .run({'async': true}); // 这里async与时间计算有关，默认为true travis # 介绍 项目node版本测试，在基本依赖下跑 使用 在travis上授权仓库，每当push代码到github, 会自动跑测试 配置根目录下的.travis.yml文件来配置测试内容，如 language: node_js node_js: -'0.8' -'0.10' -'0.11' script: make test services: mongodb # 一个使用了mongodb的nodejs应用，用0.8、0.10、0.11三个版本来跑，跑测试的命令是make test travis测试的项目，可以得到一个图片地址，显示项目当前的测试通过状态，把这个图片添加到项目的README中 jasmine # 介绍 编写单元测试 使用 describe(\u0026quot;A suite\u0026quot;, function(){ var foo; beforeEach(function(){ foo = 0; foo += 1; }); afterEach(function(){ foo = 0; }); it(\u0026quot;contains spec with an expectation\u0026quot;, function(){ expect(true).toBe(true); }); }); should # 介绍 兼容性测试 安装 npm install should --save-dev 使用 var should = require('should'); user.should.have.property('name', 'jack') # should(user).have.property('name','jack'); user.should.have.property('pets').with.lengthOf(4); # 判断数组 should.not.exist(err); should.exist(result); result.bar.should.equal(foo); (5).should.be.exactly(5).and.be.a.Number(); user.should.be.an.instanceOf(Object).and.have.property('name', 'jack'); this.obj.should.have.property('id').which.is.a.Number(); memwatch # 介绍 监控内存leak, stats,leak在连续5次垃圾回收后内存没释放时触发, stats事件在垃圾回收时触发 o-\u0026gt; 堆内存比较 var memwatch = require('memwatch') var leakArray = [] var leak = function () { leakArray.push('leak' + Math.random()) } var hd = new memwatch.HeapDiff() for (var i = 0; i \u0026lt; 10000; i++) { leak() } var diff = hd.end() console.log(JSON.stringify(diff, null, 2)) muk # var muk = require('muk') before(function () { muk(fs, 'readFileSync', function (path, encoding) { throw new Error('mock readFileSync error') }) muk(fs, 'readFile', function (path, encoding, callback) { process.nextTick(function () { # 模拟异步 callback(new Error('mock readFile error')) }) }) }) after(function () { muk.restore() }) rewire # 介绍 测试私有方法 o-\u0026gt; it('limit should return success', function () { var lib = rewire('../lib/index.js') var litmit = lib.__get__('limit') litmit(10).should.be.equal(10) }) mocha # 介绍 单元测试框架 命令 mocha # --reporters 查看所有报告样式, 默认dot, 常用spec, json, html-cov # -R \u0026lt;reporter\u0026gt;采用某报告样式 # -t \u0026lt;ms\u0026gt;设置超时时间 使用 npm install -g mocha // package.json { \u0026quot;scripts\u0026quot;: { \u0026quot;test\u0026quot;: \u0026quot;mocha test\u0026quot; \u0026quot;blanket\u0026quot;: { \u0026quot;pattern\u0026quot;: \u0026quot;//^((?!(node_modules|test)).)*$/\u0026quot;, \u0026quot;data-cover-flags\u0026quot;: { \u0026quot;debug\u0026quot;: false } } } } mocha test o-\u0026gt; bdd风格 describe('Array', function() { before(function() {}) # 钩子函数还有after, beforeEach, afterEach it('should return -1 when not present', function (done) { [1,2,3].indexOf(4).should.equal(-1) this.timeout(500) # 500ms后超时 done() # 用done来测试异步 }) }) o-\u0026gt; bdd风格 suite('Array', function() { setup(function () {}) # 钩子函数还有teardown suite('$indexOf()', function () { test('should return -1 when not present', function() { assert.equal(-1, [1,2,3].indexOf(4)) }) }) }) istanbul # 介绍 名字是依斯坦布尔，用来白盒覆盖用例测试 支持的use cases有unit tests, browser tests, server side code embedding 使用 instanbul cover test.js phantomjs # 介绍 前端测试工具 webkit js测试工具，支持多web标准, dom, css, json, canvas和svg o-\u0026gt; 使用1 npm install mocha-phantomjs mocha-phantomjs index.html o-\u0026gt; 使用2 phantomjs hello.js // hello.js console.log('Hello, world'); phantom.exit(); browserstack # 介绍 前端测试工具 内建webdriver的api 使用 npm install browserstack-runner --save-dev ./node_modules/.bin/browserstack-runner init // browserstack.json \u0026quot;test_framework\u0026quot;: \u0026quot;mocha\u0026quot;, \u0026quot;timeout\u0026quot;: 60, \u0026quot;test_path\u0026quot;: \u0026quot;public/index.html\u0026quot; https://www.browserstack.com/accounts/automate 得到username 和 access key 复制到browserstack.json中的username和key browserstack-runner https://www.browserstack.com/automate 查看结果 karma # 介绍 是google Testacular的新名字，自动化完成单元测试 使用 npm install -g karma karma start karma init # 初始化karma配置文件 npm install karma-jasmine jscover # 介绍 覆盖率测试 使用 npm install jscover -g jscover lib lib-cov # 把lib下的源码编译到lib-cov下，新代码在每一行加上了执行次数统计 index.js中 module.exports = process.env.LIB_COV ? require('./lib-cov/index') : require('./lib/index') export LIB_COV=1 mocha -R html-cov \u0026gt; coverage.html # 生成结果 blanket # 介绍 比jscover更好的测试工具 使用 package.json中 \u0026quot;scripts\u0026quot;: { \u0026quot;blanket\u0026quot;: { \u0026quot;pattern\u0026quot;: \u0026quot;eventproxy/lib\u0026quot; # 要测试的源码目录 } } mocha --require blanket -R html-cov \u0026gt; coverage.html python # nose # 注解测试 selenium # 自动化测试 go # gomock # 官方mock库, 对接口mock monkey # 介绍 对函数mock Patch() Unpatch() PatchInstanceMethod() UnpatchInstanceMethod() 问题 内联函数不能mock 测试时禁止内联, go test -gcflags=all=\u0026quot;-N -l\u0026quot; java # hamcrest # # 自然语法 mockito # 页面 # jsperf # js性能分析 jasmine # js单元测试 移动 # robotium # android自动化测试 "},{"id":102,"href":"/docs/architect/method/test_plan/","title":"测试规划","section":"Method","content":" 规划 # 蓝图 规范 \u0026amp; 稳定 用例规范，测试方案规范，自动化代码规范，工单处理标准，提测准人/出标准，Bug规范 线上异常监控，PPE环境监控，发布接管，线上问题对接，线上告警，自动巡检 内容 基础：功能测试，兼容性测试，性能测试，数据治理，安全测试，线上问题，环境治理，故障演练 提效：API自动化，框架\u0026amp;测试代码自动生成，自动部署\u0026amp;持续集成，数据工厂，UI自动化，Doom引流 赋能：测试用例开放，代码质量度量，story_QA，测试工具\u0026amp;平台开放，自由组装case场景，精准推荐 探索：探索性测试，契约测试，AI技术赋能测试 度量 线上：发布次数，紧急发布/回滚，工单预警数，生产冒烟数，线上工单数，复盘数 线下：代码质量数据，缺陷修复效率，Bug打回数据，自动化通过率，项目进度度量，Story owner度量 基础 # 功能测试 业务梳理：业务结构图，服务调用图，数据流，特殊逻辑时序图 用例设计：模板化，框架化 安全测试 清扫漏洞: 敏感信息，接口安全问题 工具：BurpSuite, 自研代码安全扫描工具 常态化: 下沉QA流程，研发流程加入 兼容性测试 包括：App，H5，操作系统，Web浏览器，API 线上问题治理 工具：工单系统 线上反馈线上化：钉钉机器人接入，Bug自动转移 数据沉淀及可视化 FAQ 运营自查：-\u0026gt;QA-\u0026gt;开发产品 问题解决 功能缺陷类: 开发解决-\u0026gt;QA-\u0026gt;运营 答疑问：加入自查文档 功能优化类：指派给产品 问题规约 宣导：线上群公告，线下组织文档操作和业务培训 问题分类和定级 1/5/30原则：1分钟感知，5分钟响应，30分钟解决 FAQ持续转化输出 提效 # API测试 工具: Jenkins+Newman, JMeter, 思想: 模块化，测试库，数据驱动，关键字驱动，BDD 框架 Jenkins+Python(UnitTest/Pytest, Requests, HTMLTestRunner/Allure) Jenkins+Java+Maven+JUnit/TestNG+HttpClient/RestAssured+ExtentReport/Allure 框架思想 框架分层解耦: 用例层，组件/业务层，API层，公共基础层 数据分类处理: 公共数据，隔离数据，运行时数据 多协议封装: 接口协议，接口定义及调用 多环境处理: 发布流，框架管理(切换、可维护性可扩展性) 结果自动验证 框架扩展: Pytest 对比策略 数据库设计: 自动化用例nodeid，请求URL，运行环境，用例路径，request_id，请求体，cURL，Response 对比引擎设计：JSONPath匹配对比策略 API覆盖率统计 分类 白盒覆盖率: 代码 灰盒覆盖率：接口 黑盒覆盖率：需求 实践 分子：结合日志，生成RequestID扩展py.test 分母：代码，文档系统 自动生成框架 底层代码生成 核心层 逻辑封装层: 自动获取接口信息，建立模板机制，数据解析器，建立自动触发机制 用例层: 用例自动转化代码(XMind SDK) 冒烟代码生成 步骤: 获取接口信息，拼装请求并验证 场景化改造 Journey模式：用户角色为中心 方案：梳理场景需求，实例化故事场景，转化为自动化验收代码 框架设计： Actor 复用基础层、API层: 公共基础层引入Actor为中心的设计模式 组件层对基础层Actor写业务测试逻辑代码: 主要调用API层 用例层不变 FSM场景化代码，动态组合 FSM生成自动化用例 步骤 业务建模 动态绘制流程图: Graphviz 构建FSM转化器 解析器: 节点函数，解析多叉树与节点内容 用例组合 赋能 # 数据工厂 手工化 脚本化: RESTful API转向SOA API 平台化 服务化 持续集成 代码零库存管理: 代码尽早提交，feature分支尽早集成，功能尽早测试，代码尽早得到反馈 工具：Doom, Sonar 节点 本地IDE: sonarLint, findbugs, P3C, checkstyle, unit test 提交: fundbugs, P3C,checkstyle,unit test, 集成测试，安全检查，集成测试覆盖率，代码构建 环境部署: 集成测试，全量代码质量检查 pull rquest: 新增代码质量预览，测试覆盖率 PRE: 验收测试 PROD: 冒烟检查 自动化 feature分支合入时：接口自动化用例，增量代码扫描用例，流量回放用例 环境部署：全量API自动化用例测试和流量引流测试 代码质量 属性：清晰度，可维护性，注释，重构，充分测试，可扩展，效率 内容：代码规范，持续集成，度量 建设步骤：标准化，数据化，流程化 Story QA 项目经理 作用：培养大家的全局视野，锻炼大家的软性能力 职责：记录技术方案，站会，汇报，验收，把控风险，协调，跟踪 度量体系: 各维度打分 工具化制度化 奖惩：级别，措施 探索 # 流量回放 工具：jvm-sandbox-repeater, RDebug, goreplay mock处理: DefaultMockStrategy, Parameter-MatchMockStrategy 契约测试 微服务测试模式: 单元测试，接口测试，契约测试，集成测试 特性：一致性，测试前移，覆盖API的各种调用场景 实施：服务消费者，服务提供者，契约文件，契约验证 相对mock有期望请求响应的契约内容 框架：Pack，Srping Cloud Contract 探索性测试 理念：边学习，边设计，边执行，持续优化 全局探索性测试 商业区: 核心特性 娱乐区: 辅助功能 旅馆区: 软件“休息”时要持续保持的功能 历史区: 历史遗留功能，曾经经常出现的问题 旅游区: 老用户不太使用，新用户着重使用 破旧区: 对软件破坏来测试稳定性 流程 反馈收集，持续监控和跟踪 客户/项目需求 技术/测试设计 技术/测试用例/代码评审 单元/集成/系统测试 上线 思维 策略模型: 质量标准、项目环境、产品元素 -\u0026gt; 测试技术 -\u0026gt; 观察到的产品质量 基于测程的测试管理 管理 # 团队管理 团队画像 定格局 团队文化：专业，高效，靠谱 认识自我 向心力 技术分享 方案 课题制度：每人一领域 学习形式：阶段性、周期性 学习周期：每周以小组形式，一小组2人 落地推行：有demo 个人发展 方向：抓住当下，关注自身本体，技术体系构建(横向、纵向) 工作习惯：内容合理分配，多关注业界的思路及方案，总结反思 项目管理 难点：掌控项目进度，合理协调资源，保证整体线上质量 三部曲 序幕 仪式感：同步背景，熟悉相关人员，明确关键时间节点，理清各自边界及上下游依赖 粮草：排期，数据准备及测试用例，环境资源 ，工具资源 高潮 把控进展：定期站会，同步进度风险预警，制定原则 集成测试：重点跟进核心链路，小黑屋即时响应，每天测试报告 线上质量：明确上线顺序、灰度、回滚策略，小规模集成测试，线上压测及演练 终章 线上灰度跟进 项目总结 文档沉淀 沟通一致 风险评估和预案 技术改动 工具化自动化 用人不疑疑人不用 纲领 # 代码门禁 公共分支只能pull request，执行检验 编译 单元测试 接口级别功能测试 静态代码扫描 人员检查 优化门禁工具 缩短时间 10分钟内 mariadb4j 精准测试 提高稳定性 90%成功率 更多用途 Bug Jail不允许开发名单 组件升级检查 测试的本质: 反馈 测试演进 平台建设 自动化回归、造数 质量监控 线上监控报警、资损演练、红蓝对抗、线上引流 基于风险的测试全方位深入 智能化提速: 判断测试范围、测试用例范围 API生成测试框架和代码 专项测试平台使测试结果 可持续沉淀 可视化质量看板 赋能 测试工具全员可运行 质量反馈 代码门禁的结果: 代码是否可接受 功能回归结果: 是否推进到预发布 预发布和灰度验证结果: 是否上线 反馈能力：缩短反馈时间，降低成本，提高可信度 缩短反馈弧 方面 反馈前置等待时间 反馈本身耗时 方法 持续集成 提升稳定性 高频：持续打包，发布，证书和密钥更新，容灾演练，缩短反馈弧，变主动验证为被动 隔离 TiP(Testing in Production) 用完即抛 不自动重跑 提升有效性 防止注水 测试测试代码 变异测试和Bug注入 提升充分性 用例自动生成 业务覆盖率 从测到不测 防错: Poka-yoke 第一时间校验输入值 线上线下权限隔离 视觉辨识度 代码写错：易混淆的类和方法 事情没按正确的方式做 静态代码分析和Bug自动识别 大促场景 # 全链路压测 全链路影子体系: 各中间件切流 压测模型与施压能力 常态化智能压测 全链路功能 统一环境隔离：流量隔离，时间控制，预案开关推送 全链路影子数据: 生成，使用 全民预演 预案开关：大促预案，日常预案 全链路预热: 系统预热，数据预热，预热场景编排 快速扩/缩容：水平，垂直 风险识别引擎压测 移动App场景 # 工具 自动化工具 云测平台 框架 用例生成 数据Mock 专项测试: 启动、崩溃、卡顿、发烫等 稳定性测试: 智能化Monkey方案 基于遗传算法 基于用户操作 兼容性测试 标准 线上保障 监控 监控方案：定义监控指标、监控方式、监控维度 监控度量：版本趋势，版本对比，年度趋势，业务趋势 告警分析 异常监控 性能分级与降级 大数据 # 测什么 功能性验证 数据更新的实时性 数据请求响应的及时性 算法的效果验证 AI算法系统的线上稳定性 工程效率方向 算法系统 工程系统 效果评估 AI系统 # 语音类 计算机视觉类 云计算 # 专有云质量定义 高可用 性能容量 热升级 用户场景测试 金融类 # 风险防控 资损风险防范 资损风险识别 资损风险应急 资损防控文化: 红蓝攻防，常态化演练 物流类 # 通用技术 仓储实操机器人 末端IoT设备 全球化物流骨干网 安全生产 # 资金安全 故障快恢 灰度发布 信息安全风险 突袭演练 "},{"id":103,"href":"/docs/pl/","title":"程序语言","section":"Docs","content":" c # 库 libvirt c++ # 问题 野指针、迷途指针 Double Free问题 智能指针 RAII资源获取就是初始化 二级指针 库 opencv iplimage # 图像处理 php # 安装 php, php-cgi, php-fpm 编译安装 yum install libxml2-devel openssl-devel bzip2-devel libmcrypt-devel -y ./configure --prefix=/opt/zly/php --with-mysql=mysqlnd --with-openssl --with-mysqli=mysqlnd --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --enable-sockets --enable-fpm --with-mcrypt --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --with-bz2 make make install cp php.ini-production /etc/php.ini cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm chmod +x /etc/rc.d/init.d/php-fpm cp /opt/zly/php/etc/php-fpm.conf.default /opt/zly/php/etc/php-fpm.conf chkconfig --add php-fpm chkconfig php-fpm on /etc/init.d/php-fpm start 命令 php -S localhost:8000 -t dir/ 配置 /etc/php/php.ini date.timezone = Europe/Berlin # 时区设置 display_errors = On 框架 zend opcache # php5.5集成，把php执行后的数据缓冲到内存中从而避免重复编译 工具 fpm # php fastCGI 进程管理器 scheme # # 特点 词法定界(Lexical Scoping) 动态类型(Dynamic Typing) 良好的可扩展性 尾递归(Tail Recursive) 函数作为值返回 计算连续 传值调用(passing-by-value) 算术运算相对独立 # 标准 R5RS (Revised5 Report on the Algorithmic Language Scheme) Guile (GNU's extension language) # guile脚本中(.scm) #! /usr/local/bin/guile -s !# # 语法 注释 ; # 注释到行尾 #! ... !# # 标准中没有，实现中有的多行注释 类型 1 'symbol \u0026quot;str\u0026quot; true, false struct empty # 表示一个空表 块(form) (define x 123) (set! x \u0026quot;abc\u0026quot;) (+ 1 2) (* (+ 2 (* 3 4)) (+ 5 6 7)) (display \u0026quot;hello world\u0026quot;) (not #f) # #t (not #t) # #f # not 后不是逻辑型，都返回#f 非精确数 (- #i1.0 #i0.9) 函数 or and not (sqrt A) (expt A B) # A^B (remainder A B) # A%B (log A) # A的自然对数 (sin A) (cond [(\u0026lt; n 10) 5.0] [else .06]) (if (\u0026lt; x 0) (- x) x) (symbol=? 'Hello x) # 符号，比较。符号还有字符串和图像 (string=? \u0026quot;the dog\u0026quot; x) # 字符串，系统看作符号 (make-posn 3 4) # 创建posn结构体 (poson-x (make-posn 7 0)) # 7 (define-struct posn (x y)) # 定义结构体 (number?) (boolean?) (struct?) (zero?) (posn?) # 可以是自定义结构体名 (null?) # 检查是否空list (eq? i list) # 元素i是否在list中， 否返回false, 是返回所在的子表 # 可以比较符号 (memq) # eq?的内部调用 (error ''checked-number \u0026quot;number expected\u0026quot;) # 马上出错 (cons 'Mercury empty) # push (cons? alon) # 是否有元素 (define x (cons 1 2)) # 序对, 可嵌套 (car x) # 1 (cdr x) # 2 (define (dispatch m) # 传0返回x, 传1返回y (cond ((= m 0) x) ((= m 1) y) (else (error \u0026quot;\u0026quot; m)))) (first) (rest) (list (list 'bob 0 'a) (list 'car1 1 'a)) (local) # 局部定义使用 (lambda) # 匿名函数 (append) (set! x 5) # 例子 复合数据 (define-struct student (last first teacher)) (define (subst-teacher a-student a-teacher) (cond [(symbol=? (student-teacher a-student) 'Fritz) # 如果教师的名字是'Fritz (make-student (student-last a-student) # 创建student结构体，设置新教师名 (student-first a-student) a-teacher)] [else a-student])) 递归列表 (define (contains-doll? a-list-of-symbols) (cond [(empty? a-list-of-symbols) false] [else (cond [(symbol=? (first a-list-of-symbols) 'doll) true] [else (contains-doll? (rest a-list-of-symbols))])])) 排序 (define (sort alon) (cond [(empty? alon) empty] [(cons? alon) (insert (first alon) (sort (rest alon)))])) (define (insert n alon) (cond [(empty? alon) (cons n empty)] [else (cond [(\u0026gt;= n (first alon)) (cons n alon)] [(\u0026lt; n (first alon)) (cons (first alon) (insert n (rest alon)))])])) or函数 (define (blue-eyed-ancestor? a-ftree) (cond [(empty? a-ftree) false] [else (or (symbol=? (child-eyes a-ftree) 'blue) (or (blue-eyed-ancestor? (child-father a-ftree)) (blue-eyed-ancestor? (child-mother a-ftree))))])) 列表替换 (define (replace-eol-with alon1 alon2) (cond ((empty? alon1) alon2) (else (cons (first alon1) (replace-eol-with (rest alon1) alon2))))) 列表相等 (define (list=? a-list another-list) (cond [(empty? a-list) (empty? another-list)] [(cons? a-list) (and (cons? another-list) (and (= (first a-list) (first another-list)) (list=? (rest a-list) (rest another-list))))])) 匿名函数 (define (find aloir t) (filter1 (local ((define (eq-ir? ir p) (symbol=? (ir-name ir) p))) eq-ir?) aloir t)) (lambda (ir p) (symbol=? (ir-name ir) p)) 快速排序 (define (quick-sort alon) (cond [(empty? alon) empty] [else (append (quick-sort (smaller-items alon (first alon))) (list (first alon)) (quick-sort (larger-items alon (first alon))))])) (define (larger-items alon threshold) (cond [(empty? alon) empty] [else (if (\u0026gt; (first alon) threshold) (cons (first alon) (larger-items (rest alon) threshold)) (larger-items (rest alon) threshold))])) (define (smaller-items alon threshold) (cond [(empty? alon) empty] [else (if (\u0026lt; (first alon) threshold) (cons (first alon) (smaller-items (rest alon) threshold)) (smaller-items (rest alon) threshold))])) erlang # 特点 由爱立信所辖CS-Lab开发，目的是创造一种可以应对大规模并发活动的编程语言。易于编写分布式应用。 面向并发(concurrent-oriented) 在语言中定义了erlang进程的概念和行为，使它特别经量级(309字节)，创建和结束一个进程时间为1-3ms 该进程(绿进程)在rlang虚拟机内管理和高度，是用户态进程 进程堆栈占用233字节 erlang虚拟机支持几十万甚至更多进程 结构化，动态，函数式 lisp # 介绍 为人工智能开发的函数语言 目前最主要两大方言为scheme和commonLisp。Emacs扩展语言为Lisp，有一种Emacs Lisp语言 拥有理论上最高的运算能力 编译器 sbcl # steel bank common lisp lua # 介绍 lua语言，来实现逻辑。 c/c++来实现功能 eclipse ldt 来开发（cdt 再安装 ldt 使用更方便） 使用 lua Hello.lua # 执行脚本 luac Hello.lua # 编译字节码 #-\u0026gt; lua luac.out 语法 -- # 注释 num = 10 # 定义 perl # 标准 pcre: Perl Compatible Regular Expressions prolog # 介绍 programming in logic缩写， 是一种逻辑编程语言。广泛应用于人工智能 不是真正意义上的程序，运行步骤由计算机决定。没有if, when, case, for这样的控制流程语句 很难分清哪些是程序，哪些是数据，程序就是数据，是一个智能数据库 有强大的递归功能。 R # 介绍 本身是GNU的一个开源软件 用于统计分析、绘图 是S语言的一个分支(实现) 特点 数据存储和处理 数组运算(向量、矩阵运算强大) D # # 并发 ruby # 工具 gems gem update --system rust # 介绍 mozilla开发的,注重安全, 性能, 并发的系统编程语言 js之父Brendan Eich设计 scala # 介绍 haskell衍生语言 集成了面向对象和函数语言的特性 可以很简单地与已有的java代码交互，只需要反java相关类导入就可以了 面向对象语言同时结合命令式和函数式编程风格 工具 sbt simple build tool 语法 表达式 actor1 ! case1 # 异步消息 actor1 !? case1 # 同步消息, 需要对方一定返回 actor1 !! case1 # 异步消息, 需要对方一定返回 Actor o-\u0026gt; import scala.actors.Actor class HelloActor extends Actor { def act() { while (true) { receive { case name: String =\u0026gt; println(\u0026quot;Hello, \u0026quot; + name) } } } } val helloActor = new HelloActor helloActor.start() helloActor ! \u0026quot;leo\u0026quot; case # 模式匹配 case class Login(username: String, password: String) class UserManageActor extends Actor { def act() { while (true) { receive { case Login(username, password) =\u0026gt; println(username + password) } } } } val userManageActor = new UserManageActor userManageActor.start() userManageActor ! Login(\u0026quot;leo\u0026quot;, \u0026quot;1234\u0026quot;) .net # objective-c # swift # groovy # # 基于jvm，结合python, ruby, smalltalk的特性 dart # # 谷歌发布的基于javascript的编程语言 hack # # facebook开发的基于HHVM，可与PHP无缝对接 特点 结合了PHP开发高效性同时，有了静态语言的报错特性 支持lambda表达式和强制返回等流行特性 roy # # 可编译到js elm # # 可编译到js jujia # # 动态语言，用于科学和数值计算 Fortran # # 最早出现的高级语言，用于工程计算领域 ML # # meta language, 非纯函数式编程,允许副作用和指令式编程 OCaml # # 在caml上加上oo, 源于ML simula # # 专注于仿真的语言，由类创建的对象会在协调的多线程模式下，像erlang的进程一样并行处理 "},{"id":104,"href":"/docs/tool/test/debug/","title":"程序调试","section":"测试","content":" 分析方向 # cpu # 方法调用 调用栈时长比例 录制时间内调用栈时长 火焰图(graph frames) 宽度: 方法耗时 高度: 调用栈深 排序是按字母的，颜色是随机的 subsecond offset heat map x轴: 秒 y轴: 一秒内各阶段 z轴: 颜色深度标记events采样数 内存 # 对象 对象个数、空间比例 调用栈分配比例 线程/协程 # 泄露 I/O阻塞 锁阻塞 channel阻塞 GC问题 # 少建对象 Linux # time ftrace perf_events eBPF SystemTap LTTng ktap dtrace4linux OEL DTrace sysdig Java # VisualVM # JProfiler # # 收费, java perfino # # 监测jvm YourKit # # 收费, java, 有调用链 Spring Insight # # java spring Golang # go命令 go tool pprof Xx.bin Xx.prof -inuse_space # -inuse_space显示真正使用的内存 -cpuprofile=cpu.prof -memprofile=mem.prof -blockprofile=block.prof -svg # 输出svg go build -toolexec=\u0026quot;/usr/bin/time\u0026quot; # -toolexec在每个命令加上前缀 -toolexec=\u0026quot;perf stat\u0026quot; -gcflags='-memprofile=m.p' -gcflags='-traceprofile=t.p' go test -blockprofile=b.p net/http -trace=t.p go tool trace Xx.bin t.p go-torch cpu.prof 环境变量 GODEBUG=gctrace=1 # 打印gc信息 http import _ \u0026ldquo;net/http/pprof\u0026rdquo; func main() { log.Println(http.ListenAndServe(\u0026ldquo;localhost:3999\u0026rdquo;, nil)) }\ngo tool pprof http://localhost:3999/debug/pprof/profile go tool pprof http://localhost:3999/debug/pprof/heap go tool pprof http://localhost:3999/debug/pprof/block pprof # "},{"id":105,"href":"/docs/basic/algorithm/","title":"算法","section":"基本功","content":" 名词 # graph 图 TSP traveling salesman problem 旅行商问题 graph-coloring-problem 图填色问题 combinatorial problems 组合问题 geometric algorithm 几何问题 closest-pair problem 最近对时间 convex-hull problem 凸包问题 numerical problem 数值问题 lexicographic order 字典序 on-line algorithm 联机算法 ADT abstract data type 抽象数据类型 activation record 活动记录, 递归栈所存的信息 stack frame 栈桢, 同 activation record circular array 循环数组 amoritzed 摊还 biased deletion 偏删除, 二叉树删除节点引起平衡不足问题的删除 symbol table 符号表, 编译器用 tranposition table 变换表, 游戏用 tick 滴答, 模拟的一份时间 external sorting 外部排序 comparison-based sorting 基于比较的排序 transposition table 置换表 排序 # 插入排序(insert sort) # /* 插入排序 时间 n^2, 稳定 向前插入，先找位置再移动 */ func InsertSort(arr []int) { length := len(arr) for i := 1; i \u0026lt; length; i++ { j := i - 1 for j \u0026gt;= 0 { if arr[j] \u0026lt; arr[i] { break } j-- } if j != i-1 { temp := arr[i] k := i - 1 for ; k \u0026gt; j; k-- { arr[k+1] = arr[k] } arr[k+1] = temp } } } // 向前插入，边移动边找位置 func InsertSort2(arr []int) { length := len(arr) for i := 1; i \u0026lt; length; i++ { if arr[i-1] \u0026gt; arr[i] { temp := arr[i] j := i - 1 for ; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; temp; j-- { arr[j+1] = arr[j] } arr[j+1] = temp } } } // 向前插入，值向前冒泡 func InsertSort3(arr []int) { length := len(arr) for i := 1; i \u0026lt; length; i++ { for j := i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; arr[j+1]; j-- { arr[j], arr[j+1] = arr[j+1], arr[j] } } } 冒泡排序(bubble sort) # /* 时间 n^2, 稳定 */ func BubbleSort(arr []int) { length := len(arr) for i := 0; i \u0026lt; length; i++ { for j := 1; j \u0026lt; length-i; j++ { if arr[j-1] \u0026gt; arr[j] { arr[j-1], arr[j] = arr[j], arr[j-1] } } } } func BubbleSortSwapFlag(arr []int) { flag := true for i := len(arr); flag == true; i-- { flag = false for j := 1; j \u0026lt; i; j++ { if arr[j-1] \u0026gt; arr[j] { arr[j-1], arr[j] = arr[j], arr[j-1] flag = true } } } } func BubbleSortTailFlag(arr []int) { flag := len(arr) for flag \u0026gt; 1 { i := flag flag = 0 for j := 1; j \u0026lt; i; j++ { if arr[j-1] \u0026gt; arr[j] { arr[j-1], arr[j] = arr[j], arr[j-1] flag = j } } } } 选择排序(select sort) # /* 时间 n^2, 不稳定 */ func SelectSort(arr []int) { length := len(arr) for i := 0; i \u0026lt; length; i++ { ind := i for j := i + 1; j \u0026lt; length; j++ { if arr[ind] \u0026gt; arr[j] { ind = j } } arr[i], arr[ind] = arr[ind], arr[i] } } 希尔排序(shell sort) # 概念 diminishing increment sort(缩减增量排序) increment sequence(增量序列) /* 1 循环：选gap为一半长度 2 循环：第一段gap 3 循环gap间隔序列 4 选择排序 时间 n^(1.3-2), 不稳定 */ func ShellSort(arr []int) { length := len(arr) for gap := length / 2; gap \u0026gt; 0; gap /= 2 { for i := 0; i \u0026lt; gap; i++ { for j := i + gap; j \u0026lt; length; j += gap { k := j - gap if arr[k] \u0026gt; arr[j] { temp := arr[j] for k \u0026gt;= 0 \u0026amp;\u0026amp; arr[k] \u0026gt; temp { arr[k+gap] = arr[k] k -= gap } arr[k+gap] = temp } } } } } /* 1 循环：选gap为一半长度 2 循环：第一个gap之后每个元素为j 3 j向前的gap间隔序列做选择排序 */ func ShellSort2(arr []int) { length := len(arr) for gap := length / 2; gap \u0026gt; 0; gap /= 2 { for j := gap; j \u0026lt; length; j++ { k := j - gap if arr[k] \u0026gt; arr[j] { temp := arr[j] for k \u0026gt;= 0 \u0026amp;\u0026amp; arr[k] \u0026gt; temp { arr[k+gap] = arr[k] k -= gap } arr[k+gap] = temp } } } } /* .. 最后用冒泡排序 */ func ShellSort3(arr []int) { length := len(arr) for gap := length / 2; gap \u0026gt; 0; gap /= 2 { for i := gap; i \u0026lt; length; i++ { for j := i - gap; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; arr[j+gap]; j -= gap { arr[j], arr[j+gap] = arr[j+gap], arr[j] } } } } 桶排序(bucket sort) # 介绍 将数据分到有限数量的桶子里，每个桶分别排序(可能再使用别的排序办法) 当数据均匀分配时，时间复杂度是O(n), 不受O(nlogn)下限的影响 适用于小范围、独立均匀分布的整数数据。可以计算数据量大，符合线性期望时间的排序 步骤 # 排序7, 36, 65, 56, 33, 60, 110, 42, 42, 94, 59, 22, 83, 84, 63, 77, 67, 101 设置5个桶, 找到最大值110, 最小值7, 每个桶范围是(110 - 7 + 1)/5 = 20.8 遍历原始数据，以链表结构分组放入桶中，公式为: 桶编号n = floor((a - 7) / 20.8) 桶第二次插入数据时，进行插入排序的一次插入 拼接5个桶 快速排序(quick sort) # /* 分割，快排左右 分割： 1 取轴 2 中位为start（轴本身占1位），循环除轴的节点 2.1 节点值小时，中位后移，交换节点和中位的值 3 交换轴与中位的值 时间 n^2, 平均时间 nlog(n), 不稳定 */ func QuickSort(arr []int, start int, end int) { swap := func(i int, j int) { arr[i], arr[j] = arr[j], arr[i] } partition := func(start int, end int) int { pivot := start val := arr[start] pos := start for i := start + 1; i \u0026lt;= end; i++ { if arr[i] \u0026lt; val { pos++ swap(pos, i) } } swap(pivot, pos) return pos } if start \u0026lt; end { pivot := partition(start, end) QuickSort(arr, start, pivot-1) QuickSort(arr, pivot+1, end) } } /* .. 双指针法分割 1 取轴为开头（或交换到开头），开头为左点，缓存值 2 向中循环 2.1 找到右点，向左点赋值 2.2 找到左点，向右点赋值 3. 找到中点，赋缓存值 */ func QuickSort2(arr []int, start int, end int) { partition := func(start int, end int) int { i := start j := end val := arr[start] for i \u0026lt; j { for i \u0026lt; j \u0026amp;\u0026amp; arr[j] \u0026gt;= val { j-- } if i \u0026lt; j { arr[i] = arr[j] i++ } for i \u0026lt; j \u0026amp;\u0026amp; arr[i] \u0026lt; val { i++ } if i \u0026lt; j { arr[j] = arr[i] j-- } } arr[i] = val return i } if start \u0026lt; end { pivot := partition(start, end) QuickSort2(arr, start, pivot-1) QuickSort2(arr, pivot+1, end) } } test func TestQuickSort(t *testing.T) { assert := assert.New(t) arr := []int{8, 2, 4, 65, 2, 4, 7, 1, 9, 0, 2, 34, 12} QuickSort(arr, 0, len(arr)-1) assert.Equal([]int{0, 1, 2, 2, 2, 4, 4, 7, 8, 9, 12, 34, 65}, arr) } 堆排序(heap sort) # /* 数组表示大顶堆，pos为父节点时, pos*2+1为第一个子节点 调整堆：父值非最大时下降 1 给出父节点pos,找到儿子child。 2 循环直到child越界 2.1 找大儿子下降，更新pos，计算child 构建堆: 默认给出数组为堆，从最后一个父节点pos=halfLen开始，向前一个个父节点调整堆 堆排序: 1 构建堆，重复2 2 循环堆节点 2.1 交换堆顶与末节点叶子, 下降堆顶 时间 nlog(n), 不稳定 */ func HeapSort(elements []int) { swap := func(i int, j int) { elements[i], elements[j] = elements[j], elements[i] } headAdjust := func(pos int, len int) { val := elements[pos] child := pos*2 + 1 for child \u0026lt; len { if child+1 \u0026lt; len \u0026amp;\u0026amp; elements[child] \u0026lt; elements[child+1] { child++ } if elements[pos] \u0026gt;= elements[child] { break } elements[pos] = elements[child] pos = child child = pos*2 + 1 elements[pos] = val } } buildHeap := func() { halfLen := len(elements) / 2 for i := halfLen; i \u0026gt;= 0; i-- { headAdjust(i, len(elements)) } } buildHeap() for i := len(elements) - 1; i \u0026gt; 0; i-- { swap(0, i) headAdjust(0, i) } } func HeapSort2(arr []int) { length := len(arr) swap := func(i int, j int) { arr[i], arr[j] = arr[j], arr[i] } parentPos := func(pos int) int { return (pos - 1) / 2 } child1Pos := func(pos int) int { return pos*2 + 1 } fixDown := func(pos int, l int) { val := arr[pos] child := child1Pos(pos) for child \u0026lt; l { if child+1 \u0026lt; l \u0026amp;\u0026amp; arr[child+1] \u0026gt; arr[child] { child++ } if arr[child] \u0026lt;= val { break } arr[pos] = arr[child] pos = child child = child1Pos(pos) } arr[pos] = val } buildHeap := func() { lastParentPos := parentPos(length - 1) for i := lastParentPos; i \u0026gt;= 0; i-- { fixDown(i, length) } } buildHeap() for i := length - 1; i \u0026gt; 0; i-- { swap(0, i) fixDown(0, i) } //fixUp := func(child int) { //\tval := arr[child] //\tpos := parentPos(child) //\tfor pos \u0026gt;= 0 \u0026amp;\u0026amp; child \u0026gt; 0 { //\tif arr[pos] \u0026gt;= val { //\tbreak //\t} //\tarr[child] = arr[pos] //\tchild = pos //\tpos = parentPos(child) //\t} //\tarr[child] = val //} } test func TestHeapsort(t *testing.T) { assert := assert.New(t) elements := []int{3, 1, 5, 7, 2, 4, 9, 6, 10, 8, 33, 2, 21, 2, 15, 22, 77, 11, 0, -1, 23345, 12} HeapSort(elements) assert.Equal( []int{-1, 0, 1, 2, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 21, 22, 33, 77, 23345}, elements, ) } 归并排序(merge sort) # /* 时间 nlog(n) */ func MergeSort(arr []int) { length := len(arr) temp := make([]int, length) merge := func(start int, mid int, end int) { i := start j := mid + 1 m := mid n := end k := 0 for i \u0026lt;= m \u0026amp;\u0026amp; j \u0026lt;= n { if arr[i] \u0026lt;= arr[j] { temp[k] = arr[i] k++ i++ } else { temp[k] = arr[j] k++ j++ } } for i \u0026lt;= m { temp[k] = arr[i] k++ i++ } for j \u0026lt;= n { temp[k] = arr[j] k++ j++ } for r := 0; r \u0026lt; k; r++ { arr[start+r] = temp[r] } } recurse := func(start int, end int) {} recurse = func(start int, end int) { if start \u0026lt; end { mid := (start + end) / 2 recurse(start, mid) recurse(mid+1, end) merge(start, mid, end) } } recurse(0, length-1) } 查找 # 二分查找(binary search) # /* 时间 log(n) */ func BinarySearch(nums []int, low int, high int, val int) int { for low \u0026lt;= high { mid := (low + high) / 2 if nums[mid] == val { return mid } else if nums[mid] \u0026gt; val { high = mid - 1 } else { low = mid + 1 } } return -1 } /* 递归 */ func BinarySearch2(nums []int, low int, high int, val int) int { if low \u0026gt; high { return -1 } mid := (low + high) / 2 if nums[mid] == val { return mid } else if nums[mid] \u0026gt; val { return BinarySearch2(nums, low, mid-1, val) } else { return BinarySearch2(nums, mid+1, high, val) } } topK # /* 第k大数 用快排划分 时间 n, 空间 n */ func topK(arr []int, low int, high int, k int) { start, end, mid := low, high, arr[low] for low \u0026lt; high { for low \u0026lt; high \u0026amp;\u0026amp; arr[high] \u0026lt;= mid { high-- } if low \u0026lt; high { arr[low] = arr[high] low++ } for low \u0026lt; high \u0026amp;\u0026amp; arr[low] \u0026gt;= mid { low++ } if low \u0026lt; high { arr[high] = arr[low] high-- } } arr[low] = mid if low \u0026gt; k { topK(arr, start, low-1, k) } else if low \u0026lt; k { topK(arr, low+1, end, k) } } /* 大顶堆 时间 nlog(k), 空间k */ func topK2(arr []int, k int) []int { heap := make([]int, k) for i := 0; i \u0026lt; k; i++ { heap[i] = arr[i] } adjust := func(start int, end int) { parent := start child := parent*2 + 1 for child \u0026lt;= end { if child+1 \u0026lt;= end \u0026amp;\u0026amp; heap[child+1] \u0026lt; heap[child] { child++ } if heap[parent] \u0026lt;= heap[child] { return } heap[parent], heap[child] = heap[child], heap[parent] parent = child child = parent*2 + 1 } } buildHeap := func() { for i := k / 2; i \u0026gt;= 0; i-- { adjust(i, k-1) } } buildHeap() for i := k; i \u0026lt; len(arr); i++ { if arr[i] \u0026gt; heap[0] { heap[0] = arr[i] adjust(0, k-1) } } return heap } test func main() { arr := []int{1, 10, 2, 20, 3, 30, 4, 40, 5, 50, 6, 60, 7, 70, 8, 80, 9, 90} topK(arr, 0, 17, 10) fmt.Print(arr) } 倒排索引 # 数字 # 斐波那契 # /* 返回第n个斐波那契数 时间 n */ func Fibonacci(n int) int { if n \u0026lt; 3 { return 1 } a, b := 1, 1 for i := 3; i \u0026lt;= n; i++ { r := a + b a, b = b, r } return b } /* 时间 n */ func Fibonacci2(n int) int { if n \u0026lt; 3 { return 1 } return Fibonacci2(n-2) + Fibonacci2(n-1) } 正整数和 # /* 正整数和 递归 */ func CommonSum(n int) int { if n == 1 { return 1 } return CommonSum(n-1) + n } 最大公约数/最小公倍数 # /* 最大公约数 每执行一次循环, m或n至少缩小了2倍，故时间复杂度上限为log(2)(M),M是循环次数 对于大量随机测试样例, 每次循环能便m与n值缩小一个10进位，所以平均复杂度为O(lgM) */ func GCD(m int, n int) int { var max, min int if m \u0026gt; n { max, min = m, n } else { max, min = n, m } for max%min != 0 { r := max % min max = min min = r } return min } /* .. 递归 时间 logM 空间 logM */ func GCD2(m int, n int) int { var max, min int if m \u0026gt; n { max, min = m, n } else { max, min = n, m } if max%min == 0 { return min } return GCD2(min, max%min) } /* 最小公倍数 */ func LCM(m int, n int) int { return m * n / GCD(m, n) } 最大子序列和 # /* 最大子序列和 时间 n */ func SumArr(arr []int) int { tmp := arr[0] max := tmp for i := 1; i \u0026lt; len(arr); i++ { if tmp \u0026gt;= 0 { tmp += arr[i] } else { tmp = arr[i] } if max \u0026lt; tmp { max = tmp } } return max } 判断素数 # /* 判断素数 合数一定有因子小于sqrt(n) 时间 n */ func isPrime(n int) bool { if n \u0026lt; 2 { return false } m := int(math.Sqrt(float64(n))) for i := 2; i \u0026lt;= m; i++ { if n%i == 0 { return false } } return true } /* arr中false的是素数 j从i开始, 因小于i的数已筛过 时间 n*loglog(n) n(1/2 + 1/3 + ... 1/n) */ func filterPrime(n int) { if n \u0026lt; 2 { return } arr := make([]bool, n+1) m := int(math.Sqrt(float64(n))) for i := 2; i \u0026lt;= m; i++ { for j := i; i*j \u0026lt;= n; j++ { arr[i*j] = true } } } 连续正整数和 # /* 描述：给正整数s, 写出连续正整数和为s的所有序列 双指针法 由等差数列求和公式知，数列最开始不能过一半 移end加sum, 移start减sum sum找到后，只能同时加减sum，即同时移start、end */ func SeriesSum(s int) { half := (s + 1) / 2 start := 1 end := 2 sum := 0 for start \u0026lt; half { sum = (start + end) * (end - start + 1) / 2 if sum == s { println(start, end) start++ end++ } else if sum \u0026lt; s { end++ } else { start ++ } } } 有序数组两元素和 # /* 升序不重复数组中，所有两个元素和为s的组合 时间 n^2 */ func TwoSum(arr []int, s int) { n := len(arr) for i := 0; i \u0026lt; n-1; i++ { for j := i + 1; j \u0026lt; n; j++ { if arr[i]+arr[j] == s { println(i, j) break } } } } /* 二分查找 时间 nlog(n) */ func TwoSum2(arr []int, s int) { n := len(arr) for i, j := 0, 0; i \u0026lt; n-1; i++ { another := s - arr[i] j = sort.SearchInts(arr, another) if j \u0026gt; i { println(i, j) } } } /* 双指针 移i加sum, 移j减sum sum找到后，只能同时加减sum，即同时移i,j 时间 n */ func TwoSum3(arr []int, s int) { i := 0 j := len(arr) - 1 for i \u0026lt; j { if arr[i]+arr[j] == s { println(i, j) i++ j-- } else if arr[i]+arr[j] \u0026lt; s { i++ } else { j-- } } } test func TestTwoSum(t *testing.T) { TwoSum([]int{ 1, 2, 3, 4, 5, 6, 7, 8, 9 },10) } 猴子吃桃 # /* 猴子吃桃：每天吃一半加1个，第n天剩1个，一共几个 */ func MonkeyEat(n int) int { if n == 1 { //指倒数第一天 return 1 } return MonkeyEat(n-1)*2 + 2 } 滑动平均数 # /* 滑动平均数 先算sum数组 隔n位的两sum之差即此n位的sum 除位数取均值 */ func movingAverage(arr []float64, n int) { sum := 0.0 for i, _ := range arr { arr[i] += sum sum = arr[i] } result := make([]float64, len(arr)) for i, v := range arr { start := i - n count := n if start \u0026lt; 0 { count += start + 1 start = 0 } result[i] = (v - arr[start]) / float64(count) } } 爬楼梯 # /* 爬楼梯问题：一次走1或2级，爬上n级有多少走法 要走到n+1层，只能从n层或n-1层走。n+1层方法数为n层与n-1层方法数的和。所以是个斐波那契数列问题 */ func ClimbStairs(n int) int { if n == 1 { return 1 } if n == 2 { return 2 } return ClimbStairs(n-1) + ClimbStairs(n-2) } 几瓶汽水 # /* 1元两瓶水, 两空瓶一瓶水, n元几瓶水 */ func sodaBottle(n int) int { if n == 0 { return 0 } bottle := 0 sum := 0 for i := 1; i \u0026lt;= n; i++ { sum++ bottle += 1 } return sodaBottle(bottle/2) + sum } 数组 # 翻转 # /* 翻转数组 双指针 时间 n，空间 1 */ func Inverse(arr []int) { for i, j := 0, len(arr)-1; i \u0026lt; j; i, j = i+1, j-1 { arr[i], arr[j] = arr[j], arr[i] } } /* 单指针 */ func Inverse2(arr []int) { length := len(arr) for i, half := 0, length/2; i \u0026lt; half; i++ { j := length - 1 - i arr[i], arr[j] = arr[j], arr[i] } } 轮换 # /* 轮换，如：[1,2,3,4,5],指定2时，结果[4,5,1,2,3] 翻转前段，翻转后段，再整体翻转 时间 n，空间 1 */ func Rotate(arr []int, k int) { if k == 0 { return } length := len(arr) if k \u0026gt;= length { k = k % length } inverse := func(start int, end int) { for i, j := start, end; i \u0026lt; j; i, j = i+1, j-1 { arr[i], arr[j] = arr[j], arr[i] } } inverse(0, length-1-k) inverse(length-k, length-1) inverse(0, length-1) } 洗牌 # /* 洗牌(shuffle) Fisher-Yates 随机选择, 删除, 插入新数组 */ func shuffle(arr []int) { rand.Seed(time.Now().UnixNano()) length := len(arr) result := make([]int, length) for i := 0; i \u0026lt; length; i++ { k := rand.Intn(len(arr)) result[i] = arr[k] arr = append(arr[:k], arr[k+1:]...) } } /* 洗牌 Knuth-Durstenfeld 随机选择, 放尾部 */ func shuffle2(arr []int) { rand.Seed(time.Now().UnixNano()) length := len(arr) for i := length - 1; i \u0026gt;= 0; i-- { k := rand.Intn(i + 1) arr[k], arr[i] = arr[i], arr[k] } fmt.Print(arr) } /* 洗牌 Inside-Out Algorithm 复制到新数组 遍历原数组位置i, 随机插入新数组(新数组位置i存插入前数据) */ func shuffle3(arr []int) { rand.Seed(time.Now().UnixNano()) length := len(arr) result := make([]int, length) for i, v := range arr { result[i] = v } for i := 0; i \u0026lt; length; i++ { k := rand.Intn(i + 1) result[i] = result[k] result[k] = arr[i] } fmt.Print(result) } 有序数组去重 # /* 有序数组去重 时间 n，空间 n */ func RemoveDuplicates(arr []int) int { if arr == nil || len(arr) == 0 { return 0 } if len(arr) == 1 { return 1 } end := len(arr) - 1 list0 := list.New() for i := 0; i \u0026lt;= end; { if i == end { list0.PushBack(arr[i]) i++ } else { j := i + 1 if arr[i] == arr[j] { for j \u0026lt;= end \u0026amp;\u0026amp; arr[i] == arr[j] { j++ } } list0.PushBack(arr[i]) i = j } } eleInd := 0 for ele := list0.Front(); nil != ele; ele = ele.Next() { arr[eleInd] = ele.Value.(int) eleInd++ } return eleInd } /* .. 时间 n，空间 1 */ func RemoveDuplicates2(arr []int) int { if arr == nil || len(arr) == 0 { return 0 } if len(arr) == 1 { return 1 } length := len(arr) num := 1 for i, tmp := 1, arr[0]; i \u0026lt; length; i++ { if arr[i] != tmp { arr[num] = arr[i] tmp = arr[i] num++ } } return num } 数组积水 # // 无论中间多少高低柱子，当前点积水量都是min(最左, 最右)高度 func savewater(arr []int) int { point_l := 0 max_l := arr[0] point_r := len(arr) - 1 max_r := arr[len(arr)-1] volume := 0 for point_l \u0026lt; point_r { if max_l \u0026lt; max_r { point_l++ if max_l \u0026lt; arr[point_l] { max_l = arr[point_l] } else { volume = volume + max_l - arr[point_l] } } else { point_r-- if max_r \u0026lt; arr[point_r] { max_r = arr[point_r] } else { volume = volume + max_r - arr[point_r] } } } return volume } test func main() { arr := []int{1, 2, 3, 4, 2, 1, 1, 5, 3, 2,4} volume := savewater(arr) fmt.Println(volume) } 字符串 # 字符统计 # /* 字符统计 */ func charSum(s string) { sumMap := make([]int, 26) for _, c := range s { sumMap[c-97]++ } fmt.Print(sumMap) } 最后一词长度 # func LastWordLen(s string) int { isLetter := func(c uint8) bool { if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) || (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) { return true } else { return false } } length := len(s) if length \u0026lt; 1 { return 1 } pos := length - 1 for pos \u0026gt;= 0 { if isLetter(s[pos]) { break } else { pos-- } } retLen := 0 for pos \u0026gt;= 0 { if !isLetter(s[pos]){ break } else { pos-- retLen++ } } return retLen } 翻转词序 # /* 翻转词序 */ func ReverseWords(s []rune) { reverse := func(start int, end int) { for start \u0026lt; end { s[start], s[end] = s[end], s[start] start++ end-- } } if s == nil || len(s) \u0026lt;= 1 { return } n := len(s) i := 0 for i \u0026lt; n { j := i for j \u0026lt; n { if s[j] == \u0026#39; \u0026#39; { break } else { j++ } } reverse(i, j-1) for j \u0026lt; n \u0026amp;\u0026amp; s[j] == \u0026#39; \u0026#39; { j++ } i = j } reverse(0, n-1) } test func TestReverseWords(t *testing.T) { assert := assert.New(t) s := []rune(\u0026#34;in the world\u0026#34;) ReverseWords(s) assert.Equal([]rune(\u0026#34;world the in\u0026#34;), s) } 同字异序 # const ALPHABET_LENGHT = 26 /* 是否同字异序, 如eel, lee */ func Anagram(source string, target string) bool { if len(source) != len(target) { return false } length := len(source) table1 := make([]int, ALPHABET_LENGHT) table2 := make([]int, ALPHABET_LENGHT) for i := 0; i \u0026lt; length; i++ { table1[source[i]-\u0026#39;a\u0026#39;]++ table2[target[i]-\u0026#39;a\u0026#39;]++ } for i := 0; i \u0026lt; ALPHABET_LENGHT; i++ { if table1[i] != table2[i] { return false } } return true } count and say # /* 题目解释：原题的意思就是用一个新的字符串描述上一个字符串，用数字表示上一个： 当n=1时：输出1； 当n=2时，解释1，1读作1个 ，表示为11； 当n=3时，解释上一个11，读作2个1，表示为21；（注意相同数字的描述） 当n=4时，解释上一个21，读作1个2，一个1，表示为1211； 当n=5时，解释上一个1211，读作1个1，1个2，2个1，表示为111221； 当n=6时，解释上一个111221，读作3个1，2个2，1个1，表示为312211； 时间 n^3, 空间 n^2, n是输入的值 */ func CountAndSay(n int) string { if n \u0026lt;= 0 { return \u0026#34;\u0026#34; } if n == 1 { return \u0026#34;1\u0026#34; } if n == 2 { return \u0026#34;11\u0026#34; } s := \u0026#34;11\u0026#34; result := \u0026#34;\u0026#34; for i := 3; i \u0026lt;= n; i++ { temp := s[0] count := 1 for j := 1; j \u0026lt; len(s); j++ { // len的时间复杂度在for中越来越接近n^2 if s[j] == temp { count++ } else { // result的长度越来越接近n^2 result += strconv.Itoa(count) + strconv.Itoa(int(temp-48)) count = 1 temp = s[j] } } result += strconv.Itoa(count) + strconv.Itoa(int(temp-48)) s = result result = \u0026#34;\u0026#34; } return s } 回文 # /* 回文 */ func IsPalindrome(s string) bool { for i, j := 0, len(s)-1; i \u0026lt; j; i, j = i+1, j-1 { if s[i] != s[j] { return false } } return true } /* 回文数 1. 计算位 2. 循环到half 2.1 判断高低位余数。 如 num = 12321, 则 t = 10000 第一步 1 == (12321 / 10000) % 10 == 12321 % 10 t /= 10 , 12321 /= 10 第二步 2 == (12321 ／ 1000) % 10 == 1232 % 10 判断成功 */ func IsPalindromeNum(num int) bool { if num \u0026lt; 10 { return true } countWei := func() int { num := num count := 0 for num \u0026gt; 0 { num /= 10 count++ } return count } wei := countWei() t := math.Pow(10, float64(wei-1)) half := wei / 2 n := num for i := 0; i \u0026lt; half; i++ { if (num/int(t))%10 == n%10 { t /= 10 n /= 10 } else { return false } } return true } /* 最长回文子串 时间 n^3 */ func LongestPalindrome(s string) string { isPalindrome := func(start int, end int) bool { for start \u0026lt; end { if s[start] != s[end] { return false } start++ end-- } return true } length := len(s) from, to, max := 0, 0, 0 for i := 0; i \u0026lt; length; i++ { for j := i; j \u0026lt; length; j++ { if isPalindrome(i, j) \u0026amp;\u0026amp; (j-i) \u0026gt; max { from, to = i, j max = to - from } } } return s[from : to+1] } /* 中心扩展法 1 循环所有元素i（i为中心） 2 循环向两边扩展 start, end。(start=i, end=i+1查找偶数串) 2.1 记录left, right回文子串 3 记录此i中心边缘子串是否最大 *2 ..(start=i-1, end=i+1查找奇数串) *3 .. 时间 n^2，空间 1 */ func LongestPalindrome2(s string) string { maxLeft, maxRight, max := 0, 0, 1 length := len(s) for i := 0; i \u0026lt; length; i++ { start, end, length1 := i, i+1, 0 left, right := start, end for start \u0026gt;= 0 \u0026amp;\u0026amp; end \u0026lt; length { if s[start] == s[end] { left, right, length1 = start, end, length1+2 start, end = start-1, end+1 } else { break } } if length1 \u0026gt; max { maxLeft, maxRight, max = left, right, length1 } start, end, length1 = i-1, i+1, 1 left, right = start, end for start \u0026gt;= 0 \u0026amp;\u0026amp; end \u0026lt; length { if s[start] == s[end] { left, right, length1 = start, end, length1+2 start, end = start-1, end+1 } else { break } } if length1 \u0026gt; max { maxLeft, maxRight, max = left, right, length1 } } return s[maxLeft : maxRight+1] } test func TestLongestPalindrome(t *testing.T) { assert := assert.New(t) assert.Equal(\u0026#34;woabcbaow\u0026#34;, LongestPalindrome(\u0026#34;sdbsdaswoabcbaowe\u0026#34;)) } func TestLongestPalindrome2(t *testing.T) { assert := assert.New(t) assert.Equal(\u0026#34;woabcbaow\u0026#34;, LongestPalindrome2(\u0026#34;sdbsdaswoabcbaowe\u0026#34;)) } 模式匹配 # /* 模式匹配，brute force法 时间 m*n，空间1 */ func BruteForce(s string, matcher string) int { m := len(s) n := len(matcher) for i := 0; i \u0026lt; m; i++ { count := 0 for j := 0; j \u0026lt; n \u0026amp;\u0026amp; i+j \u0026lt; m; j++ { if s[i+j] != matcher[j] { break } else { count++ } } if count == n { return i } } return -1 } /* 时间m+n */ func KMP() { } 图 # BFS(breadth first search) # DFS(depth first search) # A* # 启发式搜索 Dijkstra # Bellman-Ford # Floyd-Warshall # 走迷宫 # /* 检测方向 -\u0026gt; 走 -\u0026gt; 递归 -\u0026gt; 回退 */ const ( UP = iota DOWN LEFT RIGHT ) const MAX = 10 type Direction int var m = [MAX][MAX]int{ {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 0, 0, 0, 1, 0, 1, 1, 1, 1}, {1, 0, 1, 0, 1, 0, 1, 1, 1, 1}, {1, 0, 1, 0, 0, 0, 0, 0, 1, 1}, {1, 0, 1, 0, 1, 1, 0, 1, 1, 1}, {1, 0, 1, 0, 0, 1, 0, 1, 1, 1}, {1, 0, 1, 1, 0, 1, 0, 0, 0, 1}, {1, 0, 1, 1, 1, 1, 1, 1, 0, 1}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 1}, {1, 0, 1, 1, 1, 1, 1, 1, 0, 1}, } func printM() { emt := \u0026#34; #R\u0026#34; print(\u0026#34; \u0026#34;) for j := 0; j \u0026lt; MAX; j++ { fmt.Printf(\u0026#34; %d\u0026#34;, j) } fmt.Println() for i := 0; i \u0026lt; MAX; i++ { fmt.Printf(\u0026#34;%d\u0026#34;, i) for j := 0; j \u0026lt; MAX; j++ { fmt.Printf(\u0026#34;%c \u0026#34;, emt[m[i][j]]) } fmt.Println() } } func move(x *int, y *int, d Direction) { switch d { case UP: *x-- break case DOWN: *x++ break case LEFT: *y-- break case RIGHT: *y++ break } } func inspect(x int, y int, d Direction) bool { move(\u0026amp;x, \u0026amp;y, d) if x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= MAX || y \u0026gt;= MAX || m[x][y] != 0 { return false } return true } func printProcess(n int) { fmt.Printf(\u0026#34;步数:%d\\n\u0026#34;, n) printM() } func maze(s [2]int, e [2]int, n int) { if s[0] == e[0] \u0026amp;\u0026amp; s[1] == e[1] { printProcess(n) } for i := Direction(0); i \u0026lt; 4; i++ { if inspect(s[0], s[1], i) { tmpX, tmpY := s[0], s[1] move(\u0026amp;tmpX, \u0026amp;tmpY, i) m[tmpX][tmpY] = 2 maze([2]int{tmpX, tmpY}, e, n+1) m[tmpX][tmpY] = 0 } } } func main() { s, e := [2]int{9, 1}, [2]int{9, 8} m[s[0]][s[1]] = 2 maze(s, e, 0) println() } 动态规划 # 背包问题 # 背包有大小，物品有大小和价值，向背包装最大价值物品 最长公共子串 # 捏小球 # /* 重量不同多个小球，合并用力为重量和。两两合并到剩一个，总用力最小。写代码求最优 公式 max[n] = max[n-1] + min2(arr) 每次捏重量最小两球，都达到全局最优 */ func cutMin(arr []int) (int, []int) { min := 0 for ind := range arr { if arr[ind] \u0026lt; arr[min] { min = ind } } v := arr[min] return v, append(arr[:min], arr[min+1:]...) } func pinch(arr []int) int { if len(arr) == 1 { return 0 } v1, arr := cutMin(arr) v2, arr := cutMin(arr) return v1 + v2 + pinch(append(arr, v1+v2)) } func main() { print(pinch([]int{2, 3, 1, 4})) } 分类与回归 # 分类是编组，回归是预测 k最近邻(KNN, k-nearest neighbours) # 实现 特征抽取 应用 推荐系统 贝叶斯 # 概率算法 # 布隆过滤器 # 介绍 判断值一定不存在，或可能存在 高效插入和查询 占空间中，hash占空间大 实现 bitmap，多个hash函数 插入值计算多个hash, bit数组位置变1 查找值计算多个hash, 找bit数组位置是否全为1 不可删除 拆分到多bitmap时，key先hash到bitmap 应用 redis用setbit()和getbit() hyperLogLog # 介绍 来值, 去重计数(基数) 占空间小, hash占空间大 实现 来值, 计算hash再转bit数组，取前导0的数量n。 比较保存所有n的最大值为max 基数就为 2^(max+1) o-\u0026gt; 减误差, 用桶 分桶m个，来值的bit数组为, 前几位映射到桶, 后面位记录前导0数量 # 分桶数根据需要的RSD(相对标准误差)来计算 每桶有个max 基数为 桶数x2^(avg(max1+1, max2+1...)) # LogLog算法avg用平均数, hyperLogLog的avg用调和平均数 基数乘一个常数来修正到具体值 # 常数用桶数计算: switch(log2(桶数)), 分情况取参数v, 常数就为 参数x桶数^2 o-\u0026gt; 减误差, 数量小时预测偏大问题 算出基数小于(5/2)*桶数时 基数为 桶数xlog2(桶数/空桶数) 应用 redis用pfadd()和pfcount() 线性规划 # 图算法是线性规划的子集 单纯形法(simplex) # 每一次迭代比前次更优 hash # 介绍 将任意长度二进制值映射到较短固定长度二进制值。改一个值会生成不同的哈希 同一个哈希(散列)的二进制值是不存在的 常见的有: md5, sha, sha1, sha256, sha512, RSA-SHA 问题 冲突，拉链 填装因子: 元素数/总位置数 散列函数 傅里叶变换 # 描述 所有波都可以用多个正弦波叠加表示 应用 声音中分离出噪声、人声 图像增大高频信号提高对比度，相机找高频分量最大来自动对焦 加密 # 签名 公钥 dsa ecdsa rsa 散列 sha 特点 sha-0, sha-1已发现缺陷。用sha-2, sha-3和bcrypt 局部修改敏感 应用 比较文件 计算比较密码 diffie-hellman 特点 双方不需知道加密算法 公钥和私钥，客户用公钥加密，服务端用私钥解密 种群统计 # /* 统计二进制串置位(位值是1)数 8位全1数为255, 缓存0-255数的置位数到pc。值为0,1,1,2,1,2,... byte()会截断8位，如byte(256) = 0 byte(x\u0026gt;\u0026gt;(0*8))得到x低8位截断数值，byte(x\u0026gt;\u0026gt;(1*8))得到x低9-16位截断数值 累加8段数值在pc中映射的置位数，得到x的置位数 时间 n/8 */ func Count(x uint64) int { var pc [256]byte for i := range pc { pc[i] = pc[i/2] + byte(i\u0026amp;1) } count := int(pc[byte(x\u0026gt;\u0026gt;(0*8))] + pc[byte(x\u0026gt;\u0026gt;(1*8))] + pc[byte(x\u0026gt;\u0026gt;(2*8))] + pc[byte(x\u0026gt;\u0026gt;(3*8))] + pc[byte(x\u0026gt;\u0026gt;(4*8))] + pc[byte(x\u0026gt;\u0026gt;(5*8))] + pc[byte(x\u0026gt;\u0026gt;(6*8))] + pc[byte(x\u0026gt;\u0026gt;(7*8))]) return count } 资源分配 # token bucket # 令牌桶 通过多少流量，删除多少令牌 突发流量 丢弃 排队 特殊标记发送，网络过载时丢弃加标记的包 过程 产生令牌 消耗令牌 判断数据包是否通过 作用 限制平均传输速率，允许突发传输 leaky bucket # 漏桶 作用 强行限制数据传输速率 max-min fairness # 最大最小公平算法, 加权分配 dominant resource fairness (DRF) # 一种 max-min fairness实现，可以多资源分配 分布式算法 # 特点 分布性，并发性 一致性hash # 负载 取余hash 服务器号 % 节点数 # 容错性和扩展性不好 一致性hash 建立环坐标, hash每个ip到坐标, 称为节点 hash每个请求到坐标，顺序向后找第一个节点处理 均匀一致性hash 设置虚拟节点, 使请求分配尽量均匀 虚拟槽 # redis 建固定数个槽, 节点负责多个槽，请求映射到槽 paxos # 共识(consensus)算法 角色 proposer # 提案发起者 acceptor # 提案投票者 learner # 提案chosen后，同步到其它acceptor 第一阶段 proposer向超过半数acceptor发送prepare(带编号和value) acceptor收到prepare, 编号最大时回复promise(带上之前最大value), 小则不理会 第二阶段 proposer收到超过半数promise, 选取最大value, 发送accept acceptor收到accept, 编号同自身时更新value, 回复accepted raft # 共识算法 角色 leader # 接受请求，向follower同步请求日志并通知提交日志 follower candidate # leader选举中的临时角色 过程 开始一个leader,其它follower leader挂掉，一个follower timeout变为candidate, 发送选举请求(RequestVote) 超一半同意，该节点变leader, 并发送heartbeat持续刷新timeout 两个candidate未过半，等timeout后重试 旧leader重连，选举编号小，自动变follower BFT(拜占庭算法) # 在部分捣乱中达成一致 总数大于3m, 背叛m，可达成一致 PBFT(实用拜占庭算法) pre-prepare prepare commit map-reduce 映射函数 归并函数 NP问题 # 介绍 polynomial problem(p问题), 可以在多项式时间内解决的问题 non-deterministic polynomial problem(np, 非确定性多项式问题)，指可以在多项式时间内得到一个解的问题 non-deterministic polynomial hard problem(np-hard, np-hard问题)很难找到多项式时间算法的问题 non-deterministic polynomial complete problem(npc，np完全问题)很难找到多项式时间算法的np问题, 包含np-hard np完全问题的某些特点 # 到处都是np完全问题, 有时与普通问题差别不大 不能再细分成小问题，且必须考虑所有可能的情况 涉及\u0026quot;所有组合\u0026quot; 涉及序列且难解决 # 旅行商问题 涉及集合且难解决 # 广播台集合 可转换为集合覆盖问题或旅行商问题 旅行商问题 # # TSP, travelling salesman problem, 组合优化中的np困难问题 介绍 遍历n地点，找总路程最短的路径 分别以n地点开始，找下个起点(n-1个), 时间复杂度为O(n!)。方向变路程不变时为n!/2 近似求解 "},{"id":106,"href":"/docs/cache/soft_arch/","title":"软考架构师","section":"Cache","content":" 计算机基础 # 冯诺依曼 输入、输出、存储器(中心)、运算器控制器(CPU) 硬件图 主机(运算器、控制器、主存) 存储器: 主存、辅存 I/O设备 CPU 指令: 操作码, 地址码 运算器 ALU: 算逻运算 PSW状态寄存器 ACC MQ\tX 加 被加数、和\t加数 减\t被减数、差\t减数 乘\t乘积高位\t乘数、乘积低位\t被乘数 除\t被除数、余数\t商\t除数 控制器 CU: 控制单元 时序部件: 时钟控制 ID: 指令译码器 IR: 指令寄存器,即将执行的指令,查MAR PC: 程序计数器,下条指令地址 存储体 MAR: 地址寄存器, 现在集成到了CPU MDR: 数据寄存器, 指令存到IR 主存 存储单元: 存1字节, 唯一地址用16进制数表示 总线 地址总线: 长度表示n位二进制数地址数 数据总线: 长度表示一次处理多少位，叫作1个字的长度 存储器 分类 位置 内存(主存) 外存(辅存) 材料 半导体 静态: 双稳态触发器 动态: 依靠电容上的电荷存储，主存 磁介质: 磁性材料的不同状态存储，外存 光: 利用光斑、晶像的变化表示信息，外存 工作方式 读/写RAM 只读 固定ROM: 用户不可写 可编程PROM: 用户写1次 可擦除可编程EPROM: 可多次编程，紫外线擦除 电擦除可编程EEPROM: 可多次编程，电擦除 闪存: 接近EEPROM 访问方式 按地址访问的 按内容访问的 寻址方式 随机RAM: 按地址访问任一单元，主存 顺序SAM: 访问时按顺序查找目标地址，磁带 直接DAM: 按照数据块所在位置访问，磁盘 相联：按照内容进行访问，Cache 校验码 类别 奇偶校验码 只能发现奇数个位出错 海明码 奇偶校验、分组校验 n为数据位个数，求校验位个数k: 2^k \u0026gt;= n+k+1 CRC循环冗余校验码 码距: 任意两个码字的最小距离 检测出e个误码，要求码距d\u0026gt;=e+1 纠正t个误码，要求码距d\u0026gt;=2t+1 指令 指令周期 执行 顺序执行 重叠执行 流水线 建立时间: 第一条指令执行完毕时间 流水线周期: 部件(取指、分析、执行)执行时间最长的一段 全部执行完时间 理论公式: (t1+t2+...+tk) + (n-1)*t 实践公式: (k+n-1)*t 吞吐率: 指令条数/执行时间 最大吞吐率: 1/流水线周期时间 加速比: 不使用流水线时间/使用流水线时间 高速缓存 局部性原理 时间局部性: 经常使用 空间局部性: 相临空间内容 架构 地址总线、数据总线 地址映射、变换机构 直接映像: 放到cache第0页。简单，但不灵活，块冲突率高 离cpu近时用 全相联映像: 灵活但变换复杂 离cpu远时用 组相联映像: 组间直接映像, 主存区映射到cache页, 组内全相联映像。 离cpu近时用 主存装入或替换 平均访问时间: ta=Hctc+(1-HC)tm 写策略 写直达(write-through): 同步修改主存 写回法(write-back): cache被替换时写主存 标记法: 有效位1未修改,0时读主存 替换算法 随机算法 先进先出(FIFO) 近期最少使用(LRU) 最不经常使用(LFU): 有时间窗口的LRU 磁盘存储器 磁盘、磁头、磁道、扇区、数据块、柱面 存取时间: 寻道时间 + 等待时间 + 读/写时间(可忽略) 计算机系统结构分类 Flynn分类法 指令流: 执行的指令序列 数据流: 指令流调用的数据序列, 包括输入数据和中间结果 Flynn类别 单指令流单数据流(SISD) 单指令流多数据流(SIMD) 多指令流单数据流(MISD): 少见 多指令流多数据流(MIMD) 指令系统 复杂指令系统(CISC) 指令多, 大概100-250条 只有20%常用 寻址方式多(5-20种) 变长指令电路复杂 直接交互主存速度慢 用微程序而非硬布线逻辑电路控制 精简指令系统(RISC) 指令数量少 寻址方式少，通常只有寄存器寻址、立即数寻址、相对寻址 指令长度固定 硬布线逻辑控制为主 流水线技术 优化的编译器，编译简化 交互CPU寄存器, 一般32个以上 总线 位置分类 内部 外部 功能分类 地址 数据 控制 数据线多少分类 并行: 速率高，近距离传输(内部部件系统总线) 串行: 速率不高，长距离传输 磁盘阵列 RAID 0: 无冗余无校验, 存储性能最高 RAID 1: 磁盘镜像阵列 RAID 2: 海明码纪错, 增加3个校验盘提供单纠错和双验错。大量数据时I/O性能高，应用少 RAID 3、4: 奇偶校验码, 3采用位交叉, 4采用块交叉。3适用大型文件且I/O需求不频繁, 4适用大型文件读取 RAID 5: 无独立校验盘，校验信息分布在组内所有盘上，用户实际空间是N-1块盘。大批量和小批量数据的读写性能好了，适用I/O需求频繁的应用。应用多 RAID 6: 独立数据盘+2个独立的分布式校验盘，用户实际空间是N-2块。效率一般，应用少 RAID 7: 独立存储计算机，带操作系统和管理工具 RAID 10: RAID 1+0结合。RAID 0下挂RAID 1, 应用多 操作系统基础 # 处理机管理 进程状态 三状态: 运行、就绪、阻塞 组成: 程序、数据、PCB(进程唯一标识) PCB结构 线性方式 链接方式 索引方式 前驱图: 有向无循环图 PV操作 加锁(P操作信号量-1, 可能锁别的进程), 信号量为0时产生临界区 解锁(V操作信号量+1, 发现信号量为负时唤醒别的进程) 同步问题 缓冲区满时不写空时不读，每个时刻只能一个操作(存或取) 关键操作前P，关键操作后V 两个信号量,加互斥信号量 存储器管理 逻辑地址、物理地址 静态重定位: 绝对地址=相对地址+程序存放的内存起始地址 运行前确定映射关系 装入后不能移动 占用连续的内存空间 动态重定位: 绝对地址=重写位寄存器的值(BR)+逻辑地址寄存器的值(VR)。硬件加寄存器实现地址转换 程序占用的内存空间可动态变化 不要求连续的内存空间 便于多进程共享代码 存储管理 分区管理: 主存用户区划分区域，每个区域分配给一个用户，并限制用户只能在区域中 固定分区: 空间浪费 可变分区: 根据程序大小选择合适分区 首次适应算法 最佳适应算法 最差适应算法 可重定位分区 分页管理 逻辑地址 页号: 20位 页内地址: 12位 物理地址 块号 块内地址: 等于页内地址 页表 硬件生成 页起始地址、页长度 分段管理 逻辑地址: 段号、段内地址 物理地址 段表: 基址、段长 段页式管理 逻辑地址: 段号、页号、页内地址 物理地址: 虚拟存储 请求分页 请求分段 请求段页式 设备管理: 输入输出控制方式 程序控制: 串行 无条件传送 程序查询 中断: 并行 DMA(直接内存访问): 设备访问内存，CPU不能访问内存 文件管理 文件索引 一个节点占4字节 直接索引: 检索范围小 间接索引 一级 二级 使用情况: bitmap标记 字长x字编号 计算机网络基础 # OSI七层 应用层 HTTP、Telnet、FTP、SMTP、NFS 表示层 JPEG、ASCII、GIF、DES、MPEG 会话层 RPC、SQL 传输层 TCP、UDP、SPX 网络层 IP、IPX、ICMP 链路层 MAC(媒介访问层)、LLC(逻辑链路层) IEEE802.3/.2、HDLC、PPP、ATM 物理层 RS232、V.35、RJ-45、FDDI IP协议 IPV4: 32位 A类: 0开头: 1-126 B类: 10开头: 128-191 C类: 110开头: 192-223 D类: 1110开头: 224-239, 组播 E类: 1110开头: 240-255, 保留 子网 三级IP地址: 子网号主机号中借出来 子网掩码 A类地址的: 255.0.0.0 B类地址的: 255.255.0.0 C类地址的: 255.255.255.0 IPV4数据报 版本 首部长度 区分服务 总长度: 2^16-1=65535字节 标识 标志: DF不分片, MF: 片未分完 片偏移 生存时间 协议 首部校验和 可选字段 填充: 达到4的倍数 IPV6: 128位，共8段用:分开, 每段4个16进制数 支持单播/多播/组播/任播 支持自动配置 IPV4过渡IPV6 双协议栈 遂道 NAT-PT IPV6数据报 版本 流量分类: 相当于区分服务 流标签 有效负载长度: 除基本首部外的字节数 下一头部: 相当于协议 跳数限制: 相当于生存时间 TCP/UDP TCP 数据报标记序号 确认、校验、定时器，重传 窗口机制流量调整 TCP协议 校验和: 校验所有数据 UDP 无连接 尽最大努力交付 面向报文 无拥塞控制 支持1对1、1对多、多对1通信 首部小，只有8字节。TCP20字节 UDP协议 校验和: 不校验或校验头部 网络设计 接入层: 收集用户信息如Ip、MAC、访问日志。管理功能如MAC地址、计费管理 汇聚层: 网络访问策略控制，数据包处理、过滤、寻址 核心层: 双机冗余热备份 出口层 综合布线系统 工作区子系统: 插座 水平子系统: 楼层, 接入管理子系统 管理子系统 垂直(干线)子系统: 主设备间至各层管理间 设备间子系统: 连接跳线架及支撑硬件，防雷电，是中心单元 建筑群子系统: 楼间连线 域名和地址 DNS: UDP协议 结构 根: 用.表示 顶级域: com, edu, gov 二级域: baidu 子域: 最多63个字符 主机 域名 服务器 主域名服务器: 本区域名解析 辅助域名服务器: 备份 缓存域名服务器: 缓存查询结果 转发域名服务器: 非本地缓存中没有的，先查自身缓存，没有时转发到指定域名服务器 查询方式 递归 本服务器解析名字 迭代 问别的服务器 设备 中继器: 物理层，信号再生和发送,只直到扩展传输距离的作用，个数有限(以太网4个) 网桥: 数据链路层, 物理地址转发，只能连接相同MAC层的网络 路由器: 网络层 网关: 4-7层 集线器: 多端口中继器 二层交换机: 数据链路层，传统交换机，多端口网桥 三层交换机: 网络层，带路由功能的二层交换机 多层交换机: 4-7层，带协议转换 网络存储 DAS: 直接附加存储, 设备通过SCSI电缆直接连到服务器，无操作系统存储的操作依赖于服务器。也叫作SAS(服务器附加存储) NAS: 网络附加存储, 不再通过I/O总线附属特定服务器，而是通过网络接口与网络直接相连，用户通过网络访问。专用的文件服务器，即插即用 SAN: 存储区域网络, 专用交换机连接磁盘阵列与服务器 数据库基础 # 结构 开发人员: 三级模式，DBMS管理 内模式: 内部视图, 只有一个 概念模式: 概念视图, 公共视图, 只有一个 外模式: 外部视图, 可以多个 最终用户: 单用户 主从 分布式 客户-服务器 浏览器-应用服务器/数据库服务器 独立性 逻辑独立性: 数据的逻辑独立性 模式改变时，只改变映像 物理独立性 存储结构改变，只改变映像 数据模型 概念数据模型: E-R图 基本数据模型: 计算机的观点来建模，用于DBMS实现 分类 层次模型 网状模型 关系模型 面向对象模型 关注 数据结构 数据操作 数据约束条件 主属性非空 参照完整性: 外键，可以空但不能没有 用户定义完整性 概念 关系: 表名 元组: 记录 属性: 列 域: 取值范围 关键字: 一组唯一标识元组的属性 关系模式: 表结构 关系代数 U: 并 -: 差 n: 交 x: 笛卡尔积 o: 选择, 取得符合条件的行 π: 投影, 取得符合条件的列 \u0026gt;\u0026lt;: 连接 等值连接: 笛卡尔积筛选属性相等的元组 自然连接: 等值连接去重复的列 外连接 左外连接 右外连接 完全外连接 函数依赖 X-\u0026gt;Y X函数确定Y Y函数依赖于X 平凡 X-\u0026gt;Y Y不包含于X，X-\u0026gt;Y非平凡函数依赖 X-\u0026gt;Y Y包含于X，X-\u0026gt;Y平凡函数依赖 完全 完全函数依赖: 条件都用上, 完全依赖于主键 部分函数依赖: 条件过剩, 对主键有传递依赖 传递依赖 Armstrong公理 自反律: 内部包含的关系, Y属于X属于U，则X-\u0026gt;Y 增广律: X-\u0026gt;Y被F蕴含，则XZ-\u0026gt;YZ被F蕴含 传递律: 推导, X-\u0026gt;Y, Y-\u0026gt;Z, 则X-\u0026gt;Z 合并规则: X-\u0026gt;Y, X-\u0026gt;Z，则X-\u0026gt;YZ 伪传递规则: X-\u0026gt;Y, WY-\u0026gt;Z，则WX-\u0026gt;Z 分解规则: X-\u0026gt;Y, Z属于Y, 则X-\u0026gt;Z 超键: 主键和其它键组合 主键: 无多余属性 候选键: 无多余属性可成为主键的键 外键: 关联其它表主键 主属性非主属性: 主键中的属性是主属性 全码: 属性全是主键 规范化: 拆分表 1NF: 每个属性(列)不可再分 不满足后果 冗余大 插入入异常、删除异常、修改异常 2NF: 非主属性不完全依赖主键，即有对主键的部分依赖，不满足 3NF: 有非主属性的传递依赖不完全依赖主键(比如依赖其它非主键属性)，不满足 BC范式: 主键包含依赖的所有决定性因素(所有主属性) 不满足后果 冗余大 插入异常、删除异常 修改复杂 4NF: 没有多值属性 5NF 无损连接, 函数依赖性 设计 规划阶段: 必要性、可行性 需求分析: 产出需求规格说明书、数据字典 调查重点是\u0026quot;数据\u0026quot;、\u0026quot;处理\u0026quot; 数据字典: 数据项、数据流、数据存储、数据加工(结构化语言、判定数、判定表) 概念设计: E-R图, 不依赖DBMS 局部E-R图，实体联系，消除冲突(属性冲突、结构冲突、命名冲突)成全局E-R图 逻辑设计: 逻辑模型，产出关系模式 实体-\u0026gt;关系 属性-\u0026gt;属性 复合属性、多值属性、派生属性、BLOB型属性、联系属性 关键字-\u0026gt;关键字 物理设计: 建立物理模型, create table 反规范化 增加冗余列、派生列 重新组表 分割表: 水平分割、垂直分割 事务管理ACID 原子性Atomicity 一致性Consistency 隔离性Isolation 持久性Durability 并发控制 封锁 排他锁(X) 共享锁(S) 协议 一级: 加X锁 二级: 加S锁，读完后释放 三级: 加S锁，事务结束释放 两段: 封锁阶段(扩展)加锁，释放阶段(收缩) 解锁 可串行化，但可能死锁 分布式数据库 特点 分布性、统一性、透明性 相对集中式数据库优点 坚固性好 可扩充性好 可改善性能 自治性好 问题 异构数据库集成复杂 分布透明性 分片透明: 透明性的最高层次 位置透明: 用户需要了解分片，但不用了解存储场地 局部数据透明: 需要了解分片和存储场地，不必了解局部场地的数据类型 故障恢复 事务故障: 系统扫描日志恢复 系统故障 正向扫描日志，已提交的redo, 未提交的undo 撤销队列的事务撤销 重做队列重做 介质故障: 装入新副本，redo 计算机病毒: 装入新副本，redo 检查点恢复 建立检查点时刻所有正在执行的事务清单 找到最后一个检查点, redo, undo 备份 物理备份: 冷备、热备 逻辑备份 备份类型 完全备份 增量备份: 需要恢复上次完全备份后的所有增量 差异备份: 每次备份上次完全备份的差异 数据仓库 特点 面向主题的、集成的、相对稳定的、反映历史变化的 数据库是面向即时的 建立 自顶向下 自底向上 混合法 数据挖掘 流程 问题定义，建立数据挖掘库，分析数据，调整数据，模型化，评价和解释 方式 关联分析，序列分析，分类分析，聚类分析，预测，时间序列 NoSQL ACID CAP Consistency Availability Partition tolerance BASE Basically available Soft state Eventually consistent 类型 键值 列族: 关心的是属性列，适合分析 列族，列限定符，行键，时间戳 文档 图 专业知识 # 软件工程 # 历史 1960年软件危机: 价格贵、质量差、不符合用户需求、文档不完整、可维护性差 1946-1956: 程序设计时代 1956-1968: 程序系统时代 1968: 软件工程时代 过程 需求分析: 效果图 用例图 软件设计 类图 活动图 状态图 软件实现 软件交付 生命周期 定义 定义问题、可行性研究、需求分析 开发 概要设计、详细设计、编码、测试 运维 更正性维护、适应性维护、预防性维护、完善性维护 消亡 报废 遗留系统 开发方法 开发风范分类 自顶向下 自底向上 性质分类 形式化 基于数学，一般用于一致性检查、类型检查、有效性验证、行为预测、设计求精验证 包括: 有限状态机、Petri网、VDM语言、Z语言等 非形式化 结构化: 面向过程 结构化方法 设计 分析(SA, Structured Analysis) 适用面向过程、数据流 数据流图DFD: 功能 数据流 存储和实体, 实体实体间必须经过加工。看输入输出是否缺失 分类: 写、读、输入、输出 加工 实现: 结构化语言、判定表、判定树 分类: 黑洞、奇迹、灰洞 数据存储 外部实体: 人、物品、其它系统 状态转换图STD: 数据字典 条目: 数据流、数据项、数据存储、基本加工 程序设计 特点 目标清晰 工作阶段化 文档规范 设计方法结构化 缺点 串行开发周期长 要求需求明确, 难以适应变化 很少考虑数据结构 要向上回溯所以要文档齐全 面向对象 喷泉模型 面向对象方法 步骤: 分析、设计、实现、维护、演化 特点 过程节点无间隙 迭代 V模型: 测试模型, 基准于瀑布模型 编码: 单元测试 详细设计: 集成测试 概要设计: 系统测试 需求分析: 验收测试 实现: 对象标识、对象属性、对象方法、对象消息 分类: 面向对象分析OOA, 面向对象设计OOD, 面向对象程序设计OOP 方法 Coad/Yourdon: OOA,OOD, 不需要表示法的转换 Booch 开发模型 静态模型: 逻辑模型(类图、对象图)，物理模型(模块图、进程图) 动态模型: 状态图、顺序图 OMT: 建模的思想 对象模型(对象图)，动态模型(状态图)，功能模型(DFD) OOSE 用例取代了DFD 分析 功能模型: 用例图(取代DFD数据流图) 组成: 参与者、用例、通信关联 方法: 识别参与者(外部实体): 人、物、其它系统、时钟 合并需求获得用例 细化用例描述: 用例名称、简要说明、事件流(主事件流、备选事件流)、非功能性需求、前置条件、后置条件、扩展点、优先级 调整用例模型: 用例间关系调整 包含关系(属于依赖关系): 基用例指向子用例 扩展关系(属于依赖关系): 扩展用例指向基用例 泛化关系(继承关系): 子用例指向父用例 行为模型: 活动图、顺序图、状态图(取代状态转换图) 数据模型: 类图(取代ER图) 步骤 定义概念类: 显而易见的类、明显无意义的类、不确定的类 发现类: 名词短语法 发现用例: 动词 确定类之间的关系: 形成领域模型 关联 聚合、组合、 依赖、泛化、实现 为类添加职责 建立交互图 设计 用例图表示需求 用例模型提炼领域模型，用例的实现用交互图 领域模型和用例图形成类图 包图和类图形成体系结构图 构件(组件)化开发: 装配式思想 RAD快速应用开发; 基于瀑布模型 步骤 规划 设计实现, 不断迭代 运行 不适合新技术, 因为适用性窄还好拆成熟构件 UP/RUP统一过程模型: 基于面向对象，比较重型 内容组织 核心工作过程 核心过程工作流 商业建模 需求 分析和设计 实现 支持工作过程 测试 部署 配置和变更管理 项目管理 环境 时间组织 阶段 初始: 明确项目规模、评估项目风险、制定项目计划、阶段技术评审 细化: 确定架构、制定构建阶段计划、建立支持环境、选择构件、阶段技术评审 构建: 详细设计，编码、测试、集成 交付: 全面测试、补充文档、产品移交用户 迭代: 每个步骤都有迭代 思想 用例驱动 以架构为中心 迭代 增量 4+1视图 逻辑视图: 类图、对象图、状态图、协作图 进程(过程)视图: 活动图 实现(开发)视图: 包图、组件图 物理视图 场景(用例视图) 连接件 构件和对象 构件: 包含对象可独立部署、是组装单元、没有外部可见状态 对象: 有唯一标志，具有外部可见状态，封装了自己的状态和行为 构件与类 构件不一定包含类，一个类只属于一个构件 构件间消息通过接口 面向服务: 构件化开发发展而来 SOA: 可跨平台 组成: ESB SO方法 操作层 服务层: 操作分组 业务流程层: 服务编排 原型法: 需求不明确时 原型(演化)模型 原型-\u0026gt;交流-\u0026gt;快速计划、构建、交付 优点 引导出高质量产品要求 缺点 用户接触未稳定功能，对开发失去信心 螺旋模型 每一圈: 原型模型、瀑布模型 有风险: 适用大项目复杂项目, 需要风险分析 功能划分 水平原型: 行为原型，用于界面 垂直原型: 结构化原型，用于复杂算法 结果划分 抛弃式: 探索式，解决需求不确定性 演化式: 逐步演化，用于易于升级和优化的场合 敏捷: 小和快 特点 以人为本 与用户协作 面对面沟通 尽早发布增量 小而自主的团队 规模小的项目 极限编程XP 特点 更短的周期，更早反馈 迭代的计划编制 测试先行, 自动测试来监控开发进度, 口头交流 团队紧密合作 并列争求法Scrum product backlog -\u0026gt; sprint backlog sprint周期4周 daily meeting 燃尽图 评审会 开发方法与开发模型 开发方法为指导思想, 可以多模型 开发模型为图形化表示，具体开发过程 适用范围分类 整体性方法 局部性方法 过程管理 人员、技术设备、过程 能力成熟度模型CMM 初始级 可重复级: 有项目管理过程，对成、进度、功能跟踪 已定义级: 文档化、标准化，形成标准软件过程 已管理级: 可预测，软件过程和产品质量有度量标准 优化级: 持续改进 能力成熟度模型集成CMMI 初始级 已管理级: 有监督和控制 已定义级: 更严谨更积极的管理 已量化级: 可预测性高 持续优化级: 过程与技术改进，关注整体绩效 连续式模型 CL0未完成级: 未执行 CL1已执行级: 特定目标 CL2已管理级: 管理过程制度化 CL3已定义级: 已定义过程的制度化 CL4定量管理级: 可定量管理的过程的制度化 CL5优化级: 使用量化(统计学) 系统分析 # 初始需求 -\u0026gt; 逻辑模型，产出系统需求规格说明书 步骤 详细调查: 收集资料、开调查会、个别访问、书面调查、抽样调查、现场观摩、参加业务实践 现有系统分析: 获得物理模型，建立逻辑模型，建立新系统逻辑模型、推出新系统物理模型 组织结构分析: 组织结构图，组织结构调查 系统功能分析: 功能体系图，功能流程图 业务流程分析: 价值链分析法，客户关系分析，供应链分析法，基于ERP的分析法，业务流程重组 业务流程建模 建模方式 自顶向下: 企业任务目标出发 自底向上: 分析现有系统 描述方法 形式化描述: 严谨可读性差 图示化描述 建模方法 标杆瞄准 IDEF DEMO: 交互模型、业务流程模型、事务模型、行为模型、事实模型、互约束模型 Petri: 流程 业务流程建模语言(文本类和图元类): UML、BPEL(文本类)、BPML(文本类, BPMI补充了图元)、BPMN、XPDL(文本+图元) 基于服务的BPM 数据与数据流程分析 收集数据，分类编码排放 按业务流程自顶向下整理 分类 确定类型 数据属性分析 静态分析: 类型、取值范围、业务量、哪些业务使用、重要程度紧急程度 动态分析: 动态特征: 固定值属性、固定个体变动属性、随机变动属性 存储分布 流程分析: 与组织结构无关 组成: 输入、输出、流动、传递、处理、存储 步骤 收集输入报表、存储介质 明确各处理过程的方法 调查数据制作单位、报送单位、存储单位、发生频率、发生的高峰时间和高峰量 数据类型、长度、取值范围 结构化开发(SA)方法: 使用DFD 面向对象(OO)方法: 使用对象交互，对象持久化 需求规格说明书 设计阶段依据， 验收标准之一 结构化方法 组成 结构化分析: 分解与抽象原则，数据流图, 系统逻辑模型 结构化设计: 模块独立性准则、软件结构优化准则 结构化程序设计: 特点 不适合大型项目 要求需求清晰 结构化分析：数据流图，系统逻辑图、划清人机界限 数据流图平衡: 数据流条数一致 父图和子图 子图内部 数据字典 结构化设计: 系统结构、接口、数据、过程 模块化 外部特性: 接口和功能定义 内部特性: 局部数据和程序代码 注意点 抽象化 过程 数据 控制 自顶向下 信息隐蔽: 可修改性、可测试、可移植性 模块独立 模块原则 模块大小适中 扇入扇出要合理: 扇入大表示复用高，扇出大表示复杂高 深度和宽度适当: 层数和每层的模块数 内聚类型: 由高到低 功能: 单一功能 顺序: 元素相关顺序执行 通信: 元素集中在一个数据结构的区域上 过程: 元素相关，按次序执行 瞬时: 在同一时间间隔内执行(如初始化) 逻辑: 逻辑相关的一组任务 偶然: 没有关系或松散关系的任务 耦合类型: 由低到高 非直接: 没有直接联系 数据: 参数表传递简单数据 标记: 数据结构的一部分借助接口传递 控制: 传递的信息可以控制内部逻辑 外部: 与软件外环境相关 公共: 多模块引用同一全局数据区 内容: 访问另一模块内部数据、不通过正常入口转到另一模块内部、代码重叠、一个模块多个入口 软件架构设计 # 软件架构(体系结构) 接入层 网关层 业务服务层 支撑服务 平台服务 基础设施层 生命周期 需求分析: 需求模型，软件架构模型（可追踪到需求模型） 设计: 组成元素，体系结构描述语言ADL，4+1视图 实现: 项目组织结构，配置管理，中间件，程序设计语言，逐步细化 构件组装阶段、部署、后开发 基于架构的软件设计方法ABSD 商业，功能(视角视图)，非功能(质量) 体系结构开发模型 需求: 需求获取，生成类图，对类进行分组，把类打包成构件，需求评审 设计: 提出体系结构模型，映射构件，分析构件的相互作用，产生体系结构，设计评审 文档化: 规格说明，质量设计说明书 复审 演化 三个基础 功能的分解 选择体系结构风格 软件模板的使用 结构风格 系统家族 一个词汇表: 构件，连接件类型 一组约束: 构件、连接件组合方式 反映领域中众多系统共有的结构、语义特性 数据流风格 流动: 自由流动、近线性流动、有限循环流动 类型 批处理风格: 粒度大，顺序执行，完整传输, 延迟高，无并发 管道过滤器风格(如编译器): 粒度小，增量传输, 实时, 可以并发 调用返回风格 类型 主程序子程序(开发语言) 面向对象 层次 独立构件风格 进程通信: 点对点，异步同步，远程调用 事件驱动: 隐式调用，分离的交互，一对多，基于事件触发器，异步 虚拟机风格 解释器 基于规则的系统 仓库(数据共享)风格 数据库系统 黑板系统: 语音识别 超文本系统 闭环(过程)控制: 数据流风格 空调，巡航系统 C2风格: 层次架构风格 构件顶部底部都是连接件 特定领域软件体系结构DSSA 层次 领域开发环境(领域架构师) 领域特定应用开发环境(应用工程师) 应用执行环境(操作员) 过程 领域分析 领域设计 领域实现 参与角色: 领域专家, 领域分析人员，领域设计人员，领域实现人员 二层及三层C/S架构风格 二层：客户机，服务器 三层: 表示层，功能层，数据层 B/S J2EE 客户层：Applet Web层: Servlet 业务逻辑层：EJB(Entity, Session, Message) 持久层：ORM 多层架构优缺点 优点 可以只关注某层 容易替换成新实现 降低层与无尾熊依赖 利于标准化 利于各层逻辑复用 扩展性强，不同层负责不同的层面 安全性高，用户只能通过逻辑层访问 项目结构更清楚，分工更明确，有利于后期的维护和升级 缺点 严格的分层可能有性能问题 清晰的分层架构并不总容易 MVP: View和Model没有交互，都通过Presenter MVVM: ViewModel双向绑定 SOA 实现 注册中心，服务者，消费者 ESB 作用 服务连接整合 描述服务元数据，服务注册管理 服务请求者提供者间传递数据, 并进行数据转换: 支持同步、异步 发现、路由、匹配、选择。安全支持、服务质量、可管理性、负载均衡 技术 SOAP: 简单对象访问协议 WSDL: Web服务描述语言 UDDI: 统一描述、发现和集成 微服务 分层 基础设施 平台服务 支撑服务 业务服务 网关层 接入层 质量属性 特点 非功能性需求 不同的软件项目，关注不同的质量属性 质量属性之间可能 相互抑制 评价 性能: 刺激源，刺激，制品，环境，响应，响应度量指标 提升 资源需求 减少资源占用: 改进算法，减少计算开销 减少处理事件的数量: 控制事件到来的速率，控制采样频率 控制资源的使用: 限制执行时间，限制队列大小 资源管理 并发机制: 多核，多线程 增加资源 资源仲裁 先来先服务 固定优先级 动态优先：时限时间最早优先，轮转调度 可靠性：容错，健壮性 可用性 安全性 提升 抵抗攻击 身份验证，授权，维护数据机密性，维护数据完整性, 限制暴露，限制访问 检测攻击: 入侵检测 恢复: 恢复状态，识别攻击者 可修改性: 可维护性，可扩展性，结构重组，可移植性 提升 局部化修改: 高内聚低耦合，预测变更，模块通用 防止连锁反应: 信息隐藏，维持现有接口，限制通信路径, 使用中介(数据、服务(桥接，工厂，代理)) 推迟绑定时间: 运行时注册, 多态, 配置文件 功能性 可变性 互操作性 质量场景组成部分: 可用性 刺激源: 故障(系统内部或外部) 刺激: 出错，系统崩溃 制品: 计算、存储、网络 环境: 正常，降级 响应 响应度量指标 可用性提升 错误检测: 心跳, Ping/echo, 异常 错误恢复: 表决, 冗余, 检查点回滚, 下线, 事务 错误避免: 进程监控 辅助条件 敏感点 权衡点 风险点 架构评估 调查问卷/检查表 基于场景 架构权衡分析法ATAM: 对质量属性做评价和折中 质量效应树 评估参与者: 评估小组，项目决策者，项目干系人 步骤 描述介绍阶段: 描述ATAM方法，描述业务动机，描述架构 调查分析阶段: 确定架构方法，生成质量属性效用树，分析架构方法 测试阶段: 讨论场景和对场景分级，分析架构方法 报告阶段: 讨论场景和对场景分级 软件架构分析方法SAAM: 场景优先级分类 成本收益分析方法CBAM 基于度量 系统设计 # 分类 体系结构设计 数据设计 接口设计 过程设计 结构化设计 概要设计: 确定结构 模块: SC系统结构图 模块，模块间调用关系与通信，模块间层次结构 详细设计: 实现细节 流程设计 程序流程图 IPO图: 每个模块内部流程 N-S图：五种控制结构(顺序型，选择型，while循环型，until循环型，多分支选择型) 问题分析图PAD: 相对N-S图可以展示递归 过程设计语言PDL: 伪代码 判定表, 判定树 面向对象设计 面向对象 UML # 4种事务 结构: 名词 行为: 动词 分组: 包 注释: 注释 视图 用例图 参与者 用例: 基用例，子用例 边界 关系: 包含，扩展(基用例不一定执行子用例)，泛化 类图 类：实体类(名词)，控制类(执行)，边界类(用户系统交互) 关系 依赖 泛化 多态 参数多态 包含多态: 用于子类型，需要运行时类型检查 强制多态: 编译时强行变类型 过载多态: 同名在不同上下文有不同类型 关联: 双向，单向，自关联，多重关联 组合，聚合 实现 对象图 交互图 序列图 通信图/协作图: 不强调时间 状态图 活动图 构件图/组件图 部署构件: dll 工作产品构件: 源代码 执行构件: 执行后得到的构件 组合结构图 部署图 包图 分类 静态模型: 用例图，类图，对象图，构件图，部署图 动态模型: 状态图，活动图，顺序图，协作图 设计模式: 类模式，对象模式 创建型 工厂方法(类) 抽象工厂 建造者 原型 单例模式 适配器 桥接: 抽象与实现分离 组合 装饰 外观 享元 代理 责任链 解释器 模板方法 命令 迭代器 中介者 备忘录 观察者/发布订阅 状态 策略 访问者 结构型 行为型 可靠性分析与设计 # 指标 平均无故障时间MTTF 平均故障修改时间MTTR 平均故障间隔时间MTBF=MTTF+MTTR 串联系统 关联系统 冗余 结构冗余: 硬件冗余，软件冗余 静态冗余: 三模冗余，多模冗余 奇数个，表决器 动态冗余: 检测到错误用备用模块替代 混合冗余：先静态后动态 信息冗余: 检错码，纠错码 时间冗余: 重复执行 冗余附加: 冗余资源 软件容错技术 N版本程序设计：一种静态故障屏蔽，用前向恢复的策略 组，版本，表决器 恢复块方法 主块，备用块 防卫式程序设计 双机容错技术 主设备，从设备, 故障切换 服务器两块网卡，一块对外服务，一块与另外服务器连接 方式 双机热备: 从设备不工作只监控 双机互备: 服务不同同时工作，可互相替代 双机双工: 服务相同集群方式工作 集群技术 服务器组，对外网络，心跳信号，磁盘阵列 类型 高性能计算集群 负载均衡集群: 集中式，分布式 高可用性集群 高并发下的高可用技术 CDN 负载均衡 HTTP: 重定向两次请求 DNS: 基于地理位置返回不同IP, 但可能缓存导致访问失败 NAT: 速度比反向代理快, 但大文件 反向代理 负载均衡算法 轮询法 优点：简单高效，易于水平扩展 缺点：木桶原理，集群性能瓶颈于性能差的服务器 随机法 源地址hash法 优点: 可干预请求方向 缺点: 容易负载不均衡 加权轮询法 加权随机法 键值范围法 优点：水平扩展容易 缺点：容易负载不均衡 动态负载均衡 最小连接数法 优点：根据节点状况实时变化 缺点：提高了复杂度 最快响应速度法 观察模式法 性能评价指标 计算机 主频/时钟频率 外频*倍频 主频的倒数: 脉冲/CPU时钟周期 机器周期: 若干时钟周期 指令周期：若干机器周期 CPI: 指令平均时钟周期 MIPS: 每秒百万条指令平均执行速度, 主频/CPI 阿姆达尔解决方案 网络 操作系统 数据库管理系统 Web服务器 性能评估方法 时钟频率法 指令执行速度法MIPS 等效指令速度法 数据处理速率法PDR 综合理论性能法 基准程序法 软件测试 # 测试目的：发现错误 测试类型 动态 黑盒 等价类划分: 等价的数据合并 边值分析 错误猜测 因果图 功能图 白盒 基本路径 循环覆盖 单循环，嵌套循环 逻辑覆盖 语句覆盖，判定覆盖，条件覆盖，判定/条件覆盖，条件组合覆盖，点覆盖，边覆盖，路径覆盖 灰盒: 表征性现象，判断内部运行状态 静态 桌前检查 代码审查 代码走查 测试阶段 单元测试 集成/组装/联合测试 概要设计阶段计划 自顶向下，自底向上，混合/三明治 冒烟/版本验证/提交测试 确认测试 有效性测试, 需求分析阶段计划 类型：内部确认测试，Alpha测试，Beta测试，验收测试 系统测试 软件，硬件，网络，外部支持硬件、软件、数据等系统元素结合 系统分析阶段(需求分析阶段)完成计划 包括：功能测试，健壮性测试，性能测试, 用户界面测试，安全性测试，安装与反安装测试 回归测试 性能测试 目的 评估系统的能力，识别体系中的弱点，系统调优，检测软件中的问题，验证稳定性和可靠性 分类 负载压力测试：超负荷情况 强度测试: 资源低的情况下运行情况 容量测试: 同时在线的最大用户数 指标: 客户端，网络，服务器 第三方测试 面向对象测试 层次 算法层 类层 模板层 系统层 方案 逻辑覆盖 等价划分 边界值分析 错误推测 软件维护 软件生命周期 规划 开发: 分析，设计，实施，验收 运维 解散/升级 类型 改正性维护 适应性维护 完善性维护 预防性维护 安全性保密性设计 # 安全防范体系层次 物理层 系统层 网络层 应用层 安全管理 数据加密 对称加密: 分组密码，序列密码 DES: 分组密码, 3DES IDEA: 明文密文64，密钥128 非对称加密 RSA, 公私钥 认证技术 确保发送者接收者的真实性，报文的完整性 数字签名 非对称加密 杂凑算法: 摘要(MD5), 安全散列算法(SHA) 数字证书: X.509 身份认证: 口令，动态口令，生物特征 密钥管理体制 KMI密钥管理基础设施 适用于 开放网的PKI(公钥基础设施) 规模化专用网的SPK(种子化公钥) 通信与网络安全 防火墙 功能类型：包过滤型，电路级网关型，应用网关型，代理服务型，状态检测型，自适应代理型 实现模式：宿主机模式，屏蔽主机模式，屏蔽子网模式 安全协议 SSL HTTPS PGP: 邮件加密 IPSec: 防止Sniffer、数据篡改、身份欺骗等应用层攻击、中间人攻击、拒绝服务攻击 入侵检测与入侵防护IDS 基于数据源分类：基于主机的IDS, 基于网络的IDS 基于检测方法：异常检测，误用检测 入侵防护系统IPS 访问控制 自主访问控制DAC：ACL, 不能组上间接访问 强制访问控制MAC 基于角色的访问控制RBAC 基于任务的访问控制TBAC 基于对象的访问控制OBAC 中间件 # 功能 客户机和之间的连接和通信 提供应用层不同服务之间的互操作机制, 以及应用层与数据库之间的连接和控制机制 提供多层架构的应用开发和运行平台，以及应用开发框架 屏蔽硬件、操作系统、网络和数据库的差异 负载均衡, 高可用 通用的服务，避免重复工作 类型 通信处理(消息) 事务处理(交易) 数据存取管理 Web服务器 安全 跨平台和架构 专用平台 网络 应用服务器 J2EE: 建立标准，控制构件生命周期 构件: 应用客户端、EJB、Servlets和JSP、Applet 构成：容器，组件，服务 分层 表示层 业务逻辑层(中间层、领域层) 实体Bean: 表映射到对象 会话Bean: 与客户端交互 有状态，无状态 消息驱动Bean 数据访问层 .NET 分层 通用语言运行时CLR: 受控代码 基础类库 ADO.NET: XML支持, 数据缓冲区 ASP.NET 通用语言规范 企业应用集成EAI 分类 应用集成 业务过程集成 数据集成: 单一数据库 Java企业应用框架 MVC 进阶知识 # 信息系统基础 # 控制论：维纳 信息论：香农 认识论: 主观角度 质量属性：精确性，完整性，可靠性，及时性，经济性，可验证性，安全性 信息化 层次：产品，企业，产业，国民经济，社会生活 主体：全体社会成员 空域：政治、经济、文化、军事、社会生活一切领域 时域: 长期的过程 资源是核心，信息技术应用是龙头，信息网络是基础，信息技术和产业是国家信息化建设基础，人才是关键，政策法规和标准规范是保障 战略纲要 2017-2020：网信先行 2025: 技术先进，产业发达，应用领先，网络安全 21世纪中叶：网络强国，引领全球信息化发展 两化融合: 信息化和工业化 电子政务: G2G: 政府对政府 G2B: 政府对企业 G2C: 政府对公民 G2E: 政府对公务员 电子商务 发展 原始电子商务 现代电子商务：使用了EDI(电子数据交换) 结构 网络 网络基础设施 多媒体内容和网络出版的基础设施 FAX, E-mail, EDI, HTTP 报文和信息传播的基础设施 目录服务、安全、认证、电子付款 商业服务的基础设施 电子商务应用 类型 网络划分 EDI(电子数据交换)商务 Internet(互联网)商务 Intranet(企业内部网)商务 Extranet(企业外部网)商务 交易内容划分 直接电子商务 无形商品 各种服务 间接电子商务 有形商品 相关服务 交易对象规划 O2O: 线上购买线下 C2C: 淘宝 B2C: 京东 B2B 阶段: 电子数据交换(EDI), 基本的电子商务，电子交易集市，协同商务 基本原则 企业主体，政府推动。统筹兼顾，虚实结合。着力创新，注重实效。规范发展，保障安全。 支撑保障体系 企业信息化 大吃小变为快吃慢 原则: 效益原则、一把手原则、中长期与短期建设相结合原则、规范化和标准化原则，以人为本原则 \u0026quot;两网一站四库十二金\u0026quot;工程 政务内网(物理隔离)，政务外网(逻辑隔离) 中华人民共和国政府网站 基础信息库：人口库，法人库，资源地理，宏观经济 办公业务资源系统，宏观经济管理系统，金税，金审，金财，金融监管，金关，金盾，金保，金农，金水，金质 信息系统 集成 生命周期 立项 开发: 分析、设计、实施、验收 运维: 纠错性维护，适应性维护，预防性维护，完善性维护 消亡 IT服务管理ITSM 低成本高质量，以服务为中心, 以客户为中心提供服务, 可准确计价 原理：“二次转换” 梳理: 技术管理转化为流程管理 打包: 流程管理转化为服务管理 服务级别管理SLA 事件管理，问题管理 监理：四控三管一协调 质量控制、进度控制、投资控制、变更控制 安全管理、合同管理、信息管理 项目组织协调 IT服务构成ITSS 四要素PPTR 人员 过程 技术 资源 软件工程 需求分析与定义 需求必须可以被验证 目标：检测和解决需求之间的冲突，发现系统的边界，详细描述系统需求 软件设计 软件测试 配置管理 权限：Read, Check, Add, Destroy 过程管理: 项目启动和范围定义，项目规划，项目实施、项目监控与评审、项目收发与关闭 软件开发工具 软件复用 面向对象系统分析与设计 对象：标识、状态、行为 UML 5种视图: 用例视图，逻辑视图，实现视图，过程视图，部署视图 应用集成技术 数据仓库: 面向主题，集成的，相对稳定的，反映历史变化的 WebService 不适合场景: 单机应用，局域网应用 适合场景: 跨防火墙，应用程序集成，B2B集成，软件重用 软件中间件 数据库访问: ODBC, JDBC 远程过程调用RPC 面向消息中间件MOM: IBM的MQSeries 分布式对象中间件: OMG的CORBA, Java的RMI/EJB, Microsoft的DCOM 事务中间件: IBM/BEA的Tuxedo, JavaEE的EJB 网络技术 OSI七层协议 TCP/IP体系的四层协议：网络接口层，网际层，传输层，应用层 网络分类 地理分类：局域网，城域网，广域网 链路传输控制技术：以太网(总线争用)，令牌网，FDDI网，ATM网(异步传输模式), 帧中继网，ISDN(综合业务数据网) 拓扑结构：总线型，星型，树型，环型，网状 数据交换：电路交换，分组交换，ATM交换，全光交换，标记交换 接入：光纤，同轴电缆，铜线，无线 无线网络：无线个域网，无线局域网，无线城域网，蜂窝移动通信网 存储技术 与个人计算机差异：多用户多任务 技术：DAS, NAS, SAN 机房 综合布线系统 6个子系统 分区: 主机区，存储器区，数据输入区，数据输出区，通信区，监控调度区 供电：双回路供电，三相五线制 接地方式: 交流工作接地，安全工作接地，直流工作接地，防雷接地 温湿度 开机: A级机房 温度: 夏季23度, 冬季20度 湿度: 45%-65% 停机 RJ45接头需求量：m = nx4 + nx4x15%, m为总需求量，n为信息点总量，nx4x15%为富余量 信息模块需求量：m = n + nx3%, m为总需求量，n为信息点总量，nx3%为富余量 曲率半径 光缆30cm, 同轴粗电缆30cm, 同轴细电缆20cm 暗敷管路 应直线为主 弯曲时曲率半径不小于管外径的6倍(暗管外径大于50mm，不小于10倍) 转弯夹角不小于90度，不应有两个以上弯曲(应设在弯管段落两端，长度不超过15m, 段落内不应有S形弯或U形弯) 段长超过20m，应装接头箱(接头盒或过渡盒) 规划、设计和实施 局域网主要是交换以太网 拓扑结构考虑主要因素: 地理环境，传输介质，传输距离，可靠性 汇聚层是否存在，取决于网络规模的大小 网络通信设备选型：核心交换机选型，汇聚层/接入层交换机选型，远程接入与访问设备选型 安全 要素: 机密性，完整性，可用性，可控性，可审查性 工作：制定安全策略，用户验证，加密，访问控制，审计，管理 典型网络攻击步骤：信息收集，试探寻找突破口，实施攻击，消防记录，保留访问权限 安全的5个等级：用户自主保护级，系统审计保护级, 安全标记保护级, 结构化保护级，访问验证保护级 基本属性：完整性，可用性，保密性，可控性，可靠性 活动: 定义策略，定义范围，风险评估，确定管理目标和管理措施，准备适用性申明 等级保护(破坏后): 定级，备案，安全建设整改，等级评测，安全检查 风险保护：秘密，机密，绝密 大数据 特点5V: Volume(大量), Velocity(高速), Variety(多样), Value(价值), Veracity(真实性) 5个环节: 数据准备，存储，计算，分析，知识展现 关键技术: HDFS, HBase, MapReduce, Chukwa 云计算 分层 设施层：供电，制冷，布线 资源层 物理资源：服务器，存储设备，网络，数据库 虚拟资源：虚拟主机，虚拟块/对象存储，虚拟网络 资源控制层 分布式资源调度: 分布式算法，控制锁机制，消息队列 资源管理: 虚拟机管理，分布式文件系统，分布式数据库 服务层 IaaS: VDC, VDL PaaS: 开发环境，运行环境 SaaS: CRM, OA 物联网 分层 感知层: 物物之间信息传输 网络层: 标准化程序最高 应用层 关键技术 感知层为关键 产品和传感器(条码、RFID，传感器)自动化识别技术 无线传输技术(WLAN, Bluetooth, ZigBee, UWB) 自组织组网技术 中间件技术 移动互联网: 移动通信网络+互联网内容和应用 特征：接入移动性，时间碎片性，生活相关性，终端多样性 关键技术: SOA Web2.0, HTML5, Android, iOS, Windows Phone 首席信息官CIO(IT行业可合并到CTO) 业务专家，IT专家，管理专家 职责 提供信息帮助企业决策 帮助企业制定中长期发展战略 有效管理IT部门 制定信息系统 发展规划 建立积极的IT文化 ##　项目管理 组成：项目开发计划，范围管理，进度管理，成本管理，软件配置管理，质量管理，人力资源管理，风险管理，信息文档管理 制约因素: 范围，进度，成本，质量 本质：认识本质，找出规律，有效管理 生命周期: 概念阶段，开发阶段，实施阶段，结束阶段 目标：成果性目标，约束性目标 开发计划 作用：展望未来，实施依据，确定团队成员和责任范围，促进团队交流，明确奋斗目标 内容：工作计划，人员组织计划，设备采购和资源供应计划，配置管理计划，进度计划，成本计划，质量计划，风险计划，文档计划，支持计划 监控： 设置里程碑 正规和非正规 事前控制，事中控制，事后控制 直接控制，间接控制 编制: 指南：引言，项目概述，实施计划，支持条件，专题计划要点 过程：逐渐求精 范围管理 产品范围(产品需求)，工作范围(工作计划) 范围管理计划4W1H 需求管理 收集需求 挖掘真实需求：显性利益，关系维护和交往，情感感受和信任 需求跟踪矩阵 从来源连接到可交付成果 用于验收 需求文件描述单一需求如何满足，用于生成范围说明书 范围说明书 工作分解结构WBS 词典 结果 范围确认：确认可交付成果 范围控制 范围变更的压力 范围蔓延 进度管理 内容 1谋: 规划进度管理 4备: 备定义出清单: 活动清单，里程碑清单 备排序出路线: 排列活动顺序 备资源出参数: 项目资源管理-估算活动资源 备历时出长短: 活动持续时间 2反复: 反复进行进度计划编制更新 反复进行进度控制与优化 进度管理计划 活动定义 活动清单 里程碑清单 活动排序 提前量滞后量 四种依赖关系 强制性依赖: 工作中固有的依赖 选择性依赖: 经验和编好定义，无必然规律 外部依赖: 项目组与项目组外 内部依赖: 项目活动之间 活动时间估算 三点估算PERT 进度计划 总时差 自由时差 浮动时间 关键路线 赶工(时间压缩)，快速跟进(改逻辑关系为并行) 资源平衡 资源平滑 进度控制 成本管理 包含：规划成本管理, 成本估算，制定预算，成本控制 概念 储备：应急储备(已知的未知, 估算阶段)，管理储备(无知, 预算阶段) 学习曲线 质量成本 成本估算 类比估算(自上而下) 自下而上 参数估算 成本预算 项目总预算 = 成本基线BAC(基础成本 + 应急储备金) + 管理储备 成本控制 挣值 实际成本(AC)，计划值(PV)，挣值(EV) 进度绩效, 成本绩效 配置管理 CMMI: 9部分 配置标识 确定配置项: 配置项命名，配置项描述 基线(里程碑): 功能基线，指派基线，产品基线; 发行基线，构造基线 建立配置管理系统 配置库：开发库，受控库，产品库 变更控制 变更控制系统 变更控制委员会CCB 变更控制流程 利用配置库实现变更控制 版本控制 配置审核 配置状态报告 质量管理 基础 核心概念 客户发现缺陷：代价最大 趋势和新兴实践 客户满意，持续改进，管理层责任，与供应商互利合作 概述 遵从组织质量体系QS 制定质量计划QP 实施质量管理QM, 包含QA 落实质量控制QC 坚持持续改进QI ISO9000质量管理体系: 关注程序的高质量 八项原则 规划质量管理 质量管理体系 质量成本 一致性成本: 预防成本，评估成本 不一致性成本: 内部失败成本，外部失败成本 管理质量 质量报告 亲和图，因果图，流程图，直方图，帕累托图，矩阵图，散点图 控制质量 控制图 人力资源管理 规划资源管理 组织结构图和职位描述 责任分配矩阵RAM 估算活动资源 获取资源 资源日历 建设团队 一般成长规律BruceTuckmans模型：形成，震荡，规范，成熟，解散 权力类型：正式，惩罚，奖励，专家，参考 激励理论 马斯洛,需求层次5个：生理，安全，社会需求，尊重，自我实现 海兹伯格，激励理论：保健因素，激励因素 麦克格利格, X理论，Y理论 期望理论 Z理论 成就动机理论 冲突管理 管理学原理 彼得原理: 组织中每个人都可能朝不适合他的岗位发展 光环效应：一个人某方面好，往往被认为其他方面也好 墨菲定律 帕金森定律：无论给多少时间，事情总是要拖到最后一刻才能完成 布鲁克斯定律：为一个延误的项目增加人员，将导致更多的延误 手表定律：有两块手表且走时不相同, 就不知道时间了 KISS法则 黄金法则：你期望别人怎样对待你，你也要怎样对待别人 控制资源 风险管理 已知风险，未知风险 已知的已知风险：直接成本 已知的未知风险：应急储备 未知的未知风险：管理储备 概念 风险责任人，次生风险，残余风险，弹回计划，权变措施，风险承受力，风险临界值 概述 规则风险管理 识别风险: 风险登记册 实施定性风险分析: 优先级排序, 风险登记册 实施定量风险分析: 敏感性分析，龙卷风图，决策树分析，蒙特卡罗技术 规划风险应对 实施风险应对 监督风险 文档管理 质量等级 1级文档：最底限度文档 2级文档：内部文档 3级文档：工作文档 4级文档：正式文档 文档标准: 开发文档，产品文档，管理文档 测试报告 技术报告 开发总结报告 项目管理网络图 单代号网络图(工作在节点上) 双代号网络图(工作在线上) 关键路线 紧前工作, 紧后工作，虚工作 时标网络图 计算 最早开始，最迟开始，最早结束，最迟结束 总时差：不影响总工期, ls-es, lf-ef 自由时差: 不影响紧后工作, es-ef 施工 依次施工, 平行施工, 流水施工 压缩 有充足备用资源的工作 对质量和安全影响不大的工作 所需增加成本最少的工作\n嵌入式 # 微处理器体系 哈弗体系: 地址总线数据总线，每程序独立 冯诺依曼体系 硬件 核心 控制器 运算器 寄存器 微控制器MCU: CPU + 片内内存 + 片内外设 微处理器MPU: CPU 数字信号处理器DSP: 哈弗结构 片上系统SoC: 片内再编程 多核处理器 三种运行方式 非对称多处理AMP: 不同操作系统 对称多处理SMP: 一个操作系统 混合多处理BMP: 可指定某任务在某核运行 队列调度 全局队列 局部队列：每个CPU一个队列 嵌入式操作系统EOS 特点：微型化，代码质量高，专业化，实时性强，可裁减可配置 嵌入式实时操作系统RTOS 硬实时：规定时间必须完成 软实时：按优先级完成即可 系统设计 交叉编译 低功耗: 编译优化技术，软硬件协同设计，算法优化 软件 特点: 规模小，开发难度大，实时性和可靠性要求高，固化存储 层次：硬件抽象层，操作系统层，应用支撑层，应用层 板级支持包BSP 应用数学 # 运筹学 最大流问题, 动态规划, 线性规划 补充 # 技术 # 大数据 特点5A 大量Volume, 多样Variety, 价值Value, 高速Velocity, 真实性Veracity 架构: 采集，存储，计算，分析，展现 关键环节 采集: ETL 存储: 结构化SQL, 非结构化NoSQL 管理：分布式并行处理技术MapReduce 分析与挖掘 关键技术 HDFS: 分布式文件系统 HBase: 分布式面向列的开源数据库，非结构化存储 MapReduce: 管理技术，不会并行编程的情况下，程序运行在分布式系统 Chukwa: 分布式系统的数据收集系统 Flume: 日志采集、聚合、传输 Kafka: Producer, Consumer Spark: 与Hadoop相似的集群计算环境 云计算 特点：超大规模, 虚拟化, 高可靠，通用性，高可扩展性，按需服务，廉价，潜在危险性 三种服务类型 基础设施IaaS: 处理，存储，网络，其它基本计算资源 平台PaaS: 操作系统，编程语言的运行环境，数据库，Web服务器 软件SaaS 核心 资源池 云操作系统 云平台接口 关键技术 网格计算: 子任务式计算, 基础技术Web Service基于SOA 虚拟化: 传统的集群计算和分区计算的结合。基础设施虚拟化，网络虚拟化，存储虚拟化 应用 公有云，私有云，混合云 物联网 两项关键技术：嵌入式，传感器 架构： 感知层: 信息采集和物物之间的信息传输 采集：传感器、条码、二维码、RFID、音视频 传输：远近距离数据传输，自组织组网，协同信息处理，信息采集中间件 网络层: 有线或无线，编码、认证，传输。标准化程序最高 应用层: 提供应用，是根本目标 移动互联网 网络是核心，内容和应用是根本 产业领域：关键应用服务平台，网络平台，移动智能终端软件平台、硬件平台、原材料元器件, 安全控制 关键技术 SOA: 粗粒度松耦合 Web2.0 HTML5: 扩展了API使Web应用成为RIA可以在网页上调试和修改 Android, iOS, Windows Phone 人工智能 国家规划 2020年与世界先进水平同步 2025年部分技术与应用达到世界领先水平 2030年总体领先，成为世界主要人工智能创新中心 主要成果 语音识别，计算机视觉，机器学习，机器人技术，自然语言处理, 自识别自学习，人机对弈，自动工程，知识工程 区块链技术 分布式数据存储，点对点传输，共识机制，加密算法 特征：开放，共识，去中心化，去信任机制，交易透明，双方匿名，不可篡改，可追溯 技术应用 链式数据结构, 密码学分布式账本 解决“双花”问题 解决拜占庭将军问题 数值货币，智能合约 商品防伪、食品安全溯源，全生命周期记录 版权确权 核心技术 分布式账本/去中心化 哈希加密/防篡改 非对称加密/数字签名 共识算法(博弈论)/全民记账: 工作量证明POW 特点 去中心化 自治: 机器节点自治 集体维护 开放性 安全性 匿名性：机器节点间匿名 完全透明 互联网+: 行业间合力 六大特征: 跨界融合，创新驱动，重塑结构，尊重人性，开放生态，连接一切 2015.3李克强提出 两化融合的升级版本 工业化、信息化 战略融合，资源融合，虚实结合，信息技术与工业设备融合 制造业服务化：以制造为中心转向以服务为中心 《互联网+先进制造业指导意见》: 推动互联网由消费领域向生产领域拓展 智慧中国 借助虚拟化、云计算、物联网、SOA架构等技术，形成\u0026quot;智慧\u0026quot;中国 智慧城市：整合城市资源 概念 传感器或信息采集设备采集 网络将数据关联 共享与智能挖掘变成知识 结合信息技术知识应用到各行各业 五层: 物联感知层，通信网络层，计算与存储层，数据及服务支撑层，智慧应用层 三个支撑体系：安全保障，建设和运营管理，标准规范 数据仓库 ETL, 数据集市, OLAP服务，前端工具 特点 面向主题, 集成的，相对稳定的，反应历史变化的 数据挖掘分类 分类: 决策树（ID3、C4\\5、K最近邻、贝叶斯、人工神经网络、支持向量机） 聚类: K-means, Apriori, DBSCAN 序列模式分析: 因果关系 关联分析: 隐藏关系 离群点分析: 异常检测 回归分析: 两种以上变量是否依赖 数据挖掘方法: 决策树，神经网络，遗传算法，关联规则挖掘算法 商业智能 商业分析和建模 OLAP 存储方式 ROLAP: 基于关系数据库 MOLAP: 基于多维数据库 HOLAP: 基于混合数据 四阶段: 预处理，建立数据仓库，数据分析，数据展现 实现步骤：需求分析，数据仓库建模，数据抽取，建立商业智能分析报表，用户培训和数据模拟测试，系统改进和完善 虚拟化 5G 关键技术：超密集异构网络，自组织网络技术，内容分发网络，设备到设备通信D2D, M2M通信，信息中心网络ICN 项目管理网络图 # PERT图 标准化与知识产权 # 著作权 内容 著作权法: 计算机保护条例 不论是否发表 不适用具有司法性质的文件，及其官方正式译文 署名权，修改权，保护作品完整权的保护期不受限制 专利法: 专利法实施细则 商标法: 商标法实施细则 商业秘密权 特征：无体性，专有性，地域性，时间性 计算机保护条例 权利：发表权，署名权，修改权，复制权，发行权，出租权，信息网络传播权，翻译权 专利权法 不授予专利权：科学发现，智力活动的规则和方法，疾病的诊断和治疗方法，动物和植物品种，用原子核变换方法获得的物质，印刷标识作用的设计 发明专利20年，设计专利10年，申请日开始算 商标法 需要商标：烟草制品, 没有人用药品了 不能用作商标的 国家标识，外国标识, 国际组织 县级以上行政区划的地名 或公众知晓的外国地名 公众熟知的商标，可请求驰名商标保护 协商不成，抽签决定 有效期，核准注册之日起计算10年 期满前12个月续展，6个月宽展期 必需用在核准使用的地方 商业秘密权 相比著作权 主体不专有 客体：技术信息和经营信息 保护期不具有确定性 无须国家审批，产生之日自动取得 知识产权 内容 著作权法: 计算机保护条例 不论是否发表 不适用具有司法性质的文件，及其官方正式译文 专利法: 专利法实施细则 商标法: 商标法实施细则 商业秘密权 特征：无体性，专有性，地域性，时间性 论文背 # 论文结构 大纲 理论 实践 总结(10分钟) 架构风格 数据流 管理过滤器 批处理 调用返回 主子程序 面向对象 分层 虚拟机 解释器 规则 独立构件 进程通信 事件驱动 仓库 数据库系统 黑板 超文本系统 分布式 技术 服务治理: 服务拆分、调用、发现、依赖、关键度定义 架构软件管理: 架构版本管理，整体架构生命周期管理，服务编排、聚合、事务处理 DevOps: 环境构建，持续集成，持续部署 自动化运维: 自动伸缩，故障迁移，配置管理，状态管理 资源调度管理: 云计算IaaS的计算、存储、网络等资源调度、隔离、管理 整体架构监控: 三层系统(应用层、中间件层、基础层)的监控 流量控制: 流量控制，负载均衡，服务路由，熔断，降级，限流，灰度发布功能 优势 可用性：冗余无单点 模块化: 提高模块重用度，系统扩展性提高 开发发布速度提高：模块拆分可以并行 高并发 技术 负载均衡: 随机，轮询，加权轮询，一致性哈希，最小连接，自适应 分布式微服务 缓存机制 分布式关系型数据库: 垂直分表，水平分表，框架(Proxy模式，Client模式) 分布式消息队列 CDN: 镜像+缓存+整体负载均衡 其它：分布式文件系统，大数据，NoSQL，NewSQL，分布式锁 "},{"id":107,"href":"/docs/architect/summary/","title":"这些年我做过的技术","section":"架构","content":"13年毕业以来，做技术有9年了。加上大学4年学计算机，已经13年的时间做技术了。虽然没什么成就，但也想学别人写出来看一看，起码也为自己的时间做一个交代。\n背景经历 # 2009年-2013年：上学幻想期。幻想的意思是，那时技术是学来玩的，大部分时间在搞Linux，安装各种多系统和发行版，配Conky, 配各种Compiz 3D桌面，安装各种攻击工具。还买了《深入Linux内核架构》、《鸟哥的Linux私房菜》、《Linux与UNIX Shell编程指南》、《算法导论》可惜最终基础没看多少，大概与牛人的差距就是从看不完这些书体现出来的。\n2013年-2015年: 入门乱学期。毕业后在C++与Java中做了Java。从此书变成了Java系列，还去学了Java线下课。可能天生的好奇心体现了出来，Java工作不久就用刚流行的Node.js改造了公司的消息推送程序，又学起了新兴的WebGL与Three.js。还改用Dell的平板装了Linux来开发。可能做的东西太过于玄幻，成为了公司的架构师。\n2015年-2018年: 技术学习期。可能源于对各种技术的探索，走上了全栈开发的道路，用Node.js做起了Proxy和后端，全栈体系里用MongoDB做了业务库，并在前端不断寻求Web3D的应用，还扬言计算机交互必将从一维的Command和二维的Window发展到三维的3D界面，被打脸到现在。之后做了Golang的企业微服务，自我感觉到此才算学会了负起责任,真的承担了TeamLeader的责任与架构师工作，从追求各种代码的特性和代码的优雅，转到了追求设计的优雅，并开始系统研究各种中间件。\n2018年-至今: 架构探索期。此期间的职位头衔是基础服务架构师、技术专家和架构师Manager。得益于知识的全面性和折腾的各种经验，主要做了几件事。一是从0到1的基础服务平台建设，二是解决中型SaaS系统开发维护中的各种问题，三是设计各种微服务系统并给咨询方出解决方案。技术方向一个是系统设计，另一个是折腾K8S和DevOps与测试的各种问题。折腾的方向似乎升级到了战略性，IoT、AI、湖仓一体、区块链、元宇宙。然后惊奇的发现技术栈竟然挺吻合，阻碍没想象中的大，大概得益于多年用Linux工作的基础和什么都折腾一下的经历。\n思维方式 # 业务经验很重要，各个行业的经验要小心全面的积累下来，甚至比技术更重要一些，因为它更贴近实用，也有更长久的不变性。 技术实现方面设计是主题，可能设计能力是评价一个工程师最主要的方面，当然前提是有写可靠代码的能力。 基础知识是演绎的关键，凡是别人说学这个有什么用的，一定要抓紧学一学。 靠工具解决问题 大型系统的提效，完善测试是关键。可能这就是所说的抓手，也是降本增效的着力点。它前边直接对应需求，后边促进运维体系和开发体系。并本身体现出系统质量。 企业知识库是核心，体现知识的结构化和历史变化，降低了沟通成本并提供了信息一致性保障。 持续关注业界解决方案，有渠道无遗漏的过重要信息，保持敏感性。 后记 # 互联网公司陷入增长瓶颈\n但AI的应用发展日新月异 其实元宇宙的概念很好的统一了现在科技应用的增长点，创造了需求 当然马斯克代表的多行星发展的方向暂时与我没有关系 量子计算似乎也有了可工业化的迹象 我首先要避免的是变成修蒸汽机的人\u0026ndash;只会解决曾经的问题。其次要成为完整的人，在技术外的场景也寻求人生的意义。 "}]