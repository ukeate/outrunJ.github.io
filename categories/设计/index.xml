<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计 on outrun的笔记</title>
    <link>https://runout.run/categories/%E8%AE%BE%E8%AE%A1/</link>
    <description>Recent content in 设计 on outrun的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 11 Nov 2022 15:49:15 +0800</lastBuildDate>
    <atom:link href="https://runout.run/categories/%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>产品规划</title>
      <link>https://runout.run/docs/architect/method/product_plan/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/architect/method/product_plan/</guid>
      <description>&lt;h1 id=&#34;云服务&#34;&gt;&#xA;  云服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;本质&#xA;    批发转零售&#xA;    帮助别人成功而成功&#xA;    产品型转服务型&#xA;优势&#xA;    轻，方便&#xA;    全&#xA;    可计算&#xA;现象&#xA;    外包被淘汰&#xA;行业&#xA;    OS of business&#xA;功能&#xA;    产品功能，样板&#xA;    开发体验，文档&#xA;    组件收费，容量收费，节省的成本收费&#xA;    数据直接做决策&#xA;    分类&#xA;        service&#xA;            # 基础服务&#xA;        plugins&#xA;            # 基础服务组合&#xA;        app&#xA;            # plugins组合&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;产业互联网&#34;&gt;&#xA;  产业互联网&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%a7%e4%b8%9a%e4%ba%92%e8%81%94%e7%bd%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;供应链&#34;&gt;&#xA;  供应链&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%9b%e5%ba%94%e9%93%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;为什么&#xA;    大厂核心&#xA;        各节点(库存)周转&#xA;是什么&#xA;    资源 -&amp;gt; 渠道 -&amp;gt; 用户&#xA;        反馈用户真实需求&#xA;        上游关注制造业&#xA;        下游关注erp&#xA;    批量(精), 个性化(敏)&#xA;&#xA;    物流, 资金流(现金流), 信息流&#xA;    库存管理&#xA;        应对变化(保质期)&#xA;        求零库存&#xA;    供应商&#xA;        评级&#xA;        物流, 成本&#xA;        难点&#xA;            打通&#xA;怎么样&#xA;    成本、利用率&#xA;    可靠性, 反应力, 柔性(补错)&#xA;    感知、预测&#xA;    赋能&#xA;    重点&#xA;        按时制造&#xA;    难点&#xA;        协调(协议)&#xA;步骤&#xA;    单品上下游延伸&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;人工智能&#34;&gt;&#xA;  人工智能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;优化、预测&#xA;    拟合函数, 高阶微积分, 梯度下降&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;元宇宙&#34;&gt;&#xA;  元宇宙&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%83%e5%ae%87%e5%ae%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;传媒营销&#34;&gt;&#xA;  传媒营销&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%a0%e5%aa%92%e8%90%a5%e9%94%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;媒体&#34;&gt;&#xA;  媒体&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%aa%92%e4%bd%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;场景控制&#xA;    3CAD&#xA;        character&#xA;        camera&#xA;        control&#xA;        art direction&#xA;特效&#xA;    会场散射光束（博物馆）&#xA;    雾中焦点的竖光（saber的剑）&#xA;    画线的光点（最终幻想）&#xA;    密集的星星，远近缩放，光圈(tree.js官网）&#xA;    水滴带动整个屏幕的亮度(fate stay night)&#xA;    蓝色光影交错（fate stay night）&#xA;    秒针声强调时间(fate stay night)&#xA;    单帧卡动画渲染气氛(fsn)&#xA;    黑白画面到彩色画面(madlife 集锦[dream on])&#xA;    黑白画面彩色涟漪(冰果)&#xA;    地面的雾影(fsn)&#xA;    音乐重节拍时出现隐形单位/人(fsn)&#xA;    转动的星空光点线加云(fsn结尾)&#xA;    沙的立体塑型(秦时明月)&#xA;    红辣椒的分镜&#xA;网站效果&#xA;    图片向下拉，上面模糊小，下面清晰大，有一种震撼感&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>人员</title>
      <link>https://runout.run/docs/architect/manage/organize/people/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/architect/manage/organize/people/</guid>
      <description>&lt;h1 id=&#34;人-事-团队&#34;&gt;&#xA;  人, 事, 团队&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ba-%e4%ba%8b-%e5%9b%a2%e9%98%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;人&#xA;    业内口碑&#xA;    成分&#xA;        技能，素质，精神&#xA;    行动&#xA;        感性，理性，惯性&#xA;    发展&#xA;        上限&#xA;        下限&#xA;    成本&#xA;        低成本召回&#xA;事&#xA;    知原理&#xA;    是什么，为什么，怎么样，拆解&#xA;    事与团队&#xA;        事造就团队，好团队不一定出好成果&#xA;团队&#xA;    存在合理性&#xA;        有目标，成员能力认可，成员感性认可&#xA;        小精英团队，才能解决问题&#xA;    分配事&#xA;        因特质分配，如稳定，峰值，沟通&#xA;    成果评价&#xA;        产出判断&#xA;        分配利益和荣耀&#xA;        时间和代码量评价不了程序员的工作, 可以匿名互评(口碑)&#xA;    团队提升&#xA;        培训无意义，自觉成长&#xA;    成员&#xA;        项目经理&#xA;        设计&#xA;        开发&#xA;            测试人员&#xA;        运维&#xA;        系统工程师&#xA;            设计、实现产品&#xA;        数据分析师&#xA;        技术总监&#xA;        架构师&#xA;            权衡, 出方案&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;职工&#34;&gt;&#xA;  职工&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%8c%e5%b7%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;态度&#xA;    把握分寸&#xA;    靠谱(事事有交代)&#xA;    负责(顾全局)&#xA;    主动&#xA;    超出预期&#xA;    负责态度, 提高团队效率，而非自己效率   # 严肃判断&#xA;沟通&#xA;    及早沟通、同步&#xA;    文档 &amp;gt; 邮件 &amp;gt; im &amp;gt; 电话&#xA;        # 即时性相反&#xA;    留响应时间, 同组 -&amp;gt; 跨组 -&amp;gt; 跨部门 -&amp;gt; 跨公司&#xA;    明确通知人时, 邮件, im特殊指定&#xA;文档&#xA;    周报&#xA;    文档简单有计划，为节省向别人解释的时间&#xA;    建设性意见(提选择题)&#xA;    只交“产品”: 背景清晰, 扼要, 完整, 引入独有经验&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工程师&#34;&gt;&#xA;  工程师&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e7%a8%8b%e5%b8%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;本质&#xA;    解决问题&#xA;普遍问题&#xA;    技能: 工具使用(写工具), 表面学习, 笨办法, 不会读文档, 只会知识迁移&#xA;    设计: 不知经典设计, 不知设计哲学, 不知目的, 无法反应需求, 没有品位, 读不懂设计&#xA;    知识更新: 学不动, 基础差(用二手资料), 无认知体系(认为都是新东西), 重复学习无用知识&#xA;    沟通: 不专业(不用专业名词), 不主动, 不沟通对方, 不抓重点, 思路不连贯, 阅历不足(不会写文档), 不问为什么&#xA;能力&#xA;    特点&#xA;        知识、经验、技能、协作         # (1+天赋)x知识x工程习惯&#xA;        犯错(多做多错)&#xA;    方法&#xA;        抽象                        # 设计就是从升维中拆分和简化&#xA;        沉淀                        # 没有沉淀的学习不好回顾修改, 像没有测试的代码&#xA;        品位&#xA;    优点，缺点                      # 找潜质, 并非此长彼短，是两个维度,有一定抑制作用&#xA;        创造力，纪律&#xA;        勤奋，聪明&#xA;        稳定，峰值&#xA;        深度，速度&#xA;        细节，大局&#xA;开发&#xA;    考虑工作的复用性&#xA;    加入项目，需要可对所有代码修改&#xA;    善用工具&#xA;    自己的事主动跟进&#xA;owner&#xA;    自我负责, 自我驱动, 持续改进&#xA;    能部署, 能手工排查问题，手工修复数据, 开发调试工具, 数据修复工具&#xA;    模块职责单一, 明白当前负责和极限性能&#xA;    能降级, 知道下游调用和降级影响。了解上游依赖和上游降级影响&#xA;    配好log、监控、告警, 告警及时响应&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;架构师&#34;&gt;&#xA;  架构师&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%b6%e6%9e%84%e5%b8%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;场景/用例/问题 -&amp;gt; 方案/方案权衡 -&amp;gt; 落地路径&#xA;分级&#xA;    初级&#xA;        代码&#xA;            命名：精确性、简单性、一致性、区别性、业务性&#xA;            逻辑: 缩进、换行&#xA;            代码体积: 行、方法、类&#xA;        抽象能力&#xA;        边界&#xA;    中级&#xA;        流量、并发等&#xA;    高级&#xA;        理解业务核心价值、业务实现方式&#xA;        业务技术支撑方式&#xA;        业务趋势&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;创始人&#34;&gt;&#xA;  创始人&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%a7%8b%e4%ba%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;心态: 平常心&#xA;职责: 找到善于解决问题的人，做好善于定义问题的人&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;艺术家&#34;&gt;&#xA;  艺术家&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%89%ba%e6%9c%af%e5%ae%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;岗位&#34;&gt;&#xA;  岗位&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b2%97%e4%bd%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;项目经理(pm, project manager)&#xA;技术经理(tm, technical manager)&#xA;产品设计经理(pdm, product design manager)&#xA;运营经理(pom)&#xA;测试经理(qam)&#xA;客服经理(csm, customer success manager)&#xA;开发组长(tl, team leader)&#xA;架构师(pa)&#xA;开发工程师(de, development engineer)&#xA;数据库管理员(dba, database administrator)&#xA;系统管理员(sa)&#xA;界面设计师(ui, user interface)&#xA;用户体验设计师(ue, user experience)&#xA;产品运营师(po, product operator)&#xA;产品设计师(pd, product designer)&#xA;测试工程师(qa, quality assurance)&#xA;配置管理员(pcm)&#xA;发布员(pb)&#xA;软件过程专员(sqa, software quality assurance)&#xA;运维工程师(sre, site reliability engineer)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;招聘&#34;&gt;&#xA;  招聘&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8b%9b%e8%81%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;双向选择&#xA;精确率&amp;amp;召回率&#xA;方面&#xA;    沟通&#xA;    喜欢技术，逻辑能力, 编码能力, 设计能力&#xA;    基本概念, 边界考虑充足, 进阶答案, 衍生问题的解决&#xA;    是否有自己思考，对自己负责&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>演说</title>
      <link>https://runout.run/docs/basic/speach/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/basic/speach/</guid>
      <description>&lt;h1 id=&#34;要素&#34;&gt;&#xA;  要素&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a6%81%e7%b4%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;环境的设计&#xA;&#x9;安全&#xA;&#x9;规模小&#xA;改变被动传输为主动接受&#xA;&#x9;交互、提问与思考&#xA;&#x9;团队、竞争、奖励&#xA;控制场面&#xA;&#x9;引导&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>组织</title>
      <link>https://runout.run/docs/architect/manage/organize/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/architect/manage/organize/</guid>
      <description>&lt;h1 id=&#34;组织&#34;&gt;&#xA;  组织&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e7%bb%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;系统划分与组织划分&#xA;    康威定律&#xA;        系统架构是公司组织架构的反映&#xA;        按业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚低耦合，减少沟通成本&#xA;        沟通出现问题，考虑调整组织架构&#xA;        在该拆分时拆分&#xA;为了简单&#xA;    开发和运维分离&#xA;    业务和基础架构分离&#xA;    无状态和有状态分离&#xA;    业务间乘法(正交)而非加法                # 升维的特点, 正交叠加&#xA;    多层抽象, 不断隐去底层(约定大于配置)    # 升维的特点, 抽象观察&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;管理&#34;&gt;&#xA;  管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;责任&#34;&gt;&#xA;  责任&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%a3%e4%bb%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;提供&#xA;    问题: 定义, 分解, 什么是问题, 前人如何处理&#xA;        # 工程为解决问题&#xA;    思考: 方向, 为了解决问题, 找到关键, 找到应学知识&#xA;        # 创造性工作要思考&#xA;    体系: 领域的体系, 领域体系形成原因, 为了高效思考和学习, 有体系的做事&#xA;    参考: 参考书籍, 如何筛选, 如何搜索, 社区&#xA;不提供&#xA;    知识点, 答案, 规定, 代码&#xA;分任务&#xA;    出问题，写相关文档&#xA;    砸需求，看弹性&#xA;    任务列表: 难度, 优先级, 排期, 地平线目标, 现状, wishlist&#xA;    nice to have给新人&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;方法&#34;&gt;&#xA;  方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;人员&#xA;    TeamLeader -&amp;gt; Owner&#xA;    需求磨砺核心业务资产(事情成就精英团队，而非精英团队成就事)&#xA;问题定义&#xA;    完成不动点需求&#xA;        正交、简单(要求想清楚、灵活)&#xA;    维护概念完整性、一致性(纯洁)&#xA;        术语不变、不矛盾、不重叠&#xA;        考虑上下游&#xA;代码问题&#xA;    问题原因：开发的碎片化(重复的代码、由于不知道或怕改错)&#xA;    解决方法&#xA;        代码Review，集体评审&#xA;        持续集成(*lint, CI/CD): 早合并、自动构建、测试&#xA;    问题管理&#xA;        需求池&#xA;            优先级、排期、checklist、周update&#xA;        文档知识库(Confluence, Notion)&#xA;        问题追踪（Jira)&#xA;        迭代(周冲刺, hackson)&#xA;产出评估角度&#xA;    口碑、解决问题。&#xA;        良心，内驱力&#xA;    Owner,  鼓励设计、技术自由(开发人员诉求技术，厌倦业务)&#xA;    效率第一: 加班是能力问题&#xA;        时间，代码量&#xA;    犯错问题: 总会犯错，多做多错&#xA;        不能赶期，不怕delay&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;制度&#34;&gt;&#xA;  制度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%b6%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;模型&#34;&gt;&#xA;  模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;开发模型&#34;&gt;&#xA;  开发模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%8f%91%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;TDD(test-driven development)&#xA;    先单元测试&#xA;BDD(behavior-driven development)&#xA;    TDD的变种, 重点描述行为&#xA;面向需求&#xA;    组织上小而全&#xA;    开发全栈减少沟通&#xA;    设计上面向领域&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;迭代模型&#34;&gt;&#xA;  迭代模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;极限编程（XP）  # eXtreme Programming&#xA;    4大价值&#xA;        沟通：鼓励口头沟通，提高效率&#xA;        简单：够用就好&#xA;        反馈：及时反馈、通知相关人&#xA;        勇气：拥抱变化，敢于重构&#xA;    5个原则&#xA;        快速反馈&#xA;        简单性假设&#xA;        逐步修改&#xA;        提倡更改（小步快跑）&#xA;        优质工作（质量是前提）&#xA;    5个工作&#xA;        阶段性冲刺&#xA;        冲刺计划会议&#xA;        每日站立会议&#xA;        冲刺后review&#xA;        回顾会议&#xA;结对编程&#xA;PDCA循环质量管理&#xA;    Plan, Do, Check, Act&#xA;FMEA&#xA;    分析潜在的失效模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;工程模型&#34;&gt;&#xA;  工程模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e7%a8%8b%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;历史&#xA;    程序设计阶段1946-1955  节省空间&#xA;    软件设计阶段1956-1970  硬件发展，软件危机&#xA;    软件工程阶段1970-今    组件化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;瀑布模型&#34;&gt;&#xA;  瀑布模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%80%91%e5%b8%83%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 每一次执行工作流的深度不同&#xA;可行性分析&#xA;    实现会不会复杂，尽量简单&#xA;需求分析&#xA;    分类&#xA;        生存点&#xA;        痒点&#xA;        兴奋点&#xA;    # 不会按时交付（只完成主要，然后延期，用户测试）&#xA;    客户沟通，同类产品比较，行业标准&#xA;    功能&#xA;        正确, 可行, 必要, 有序, 明确, 一致&#xA;    性能&#xA;    完善, 简短&#xA;设计&#xA;    先出成果再优化&#xA;    任务分配(进度条)&#xA;    命名标准&#xA;    文档&#xA;    可移植、可维护易扩展&#xA;    排期&#xA;实现&#xA;测试&#xA;运维&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;螺旋模型&#34;&gt;&#xA;  螺旋模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%9e%ba%e6%97%8b%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 边分析边开发边交付（一环一环向目标实现）&#xA;敏捷开发&#xA;    项目面临的问题&#xA;        人员流动&#xA;        代码维护&#xA;    种类&#xA;        极限编程(xp)&#xA;    特点&#xA;        简易、交流、回馈&#xA;    方法&#xA;        解耦低速设备，提高响应速度&#xA;迭代&#xA;    迭代周期&#xA;        一个迭代周期中不新添加需求&#xA;        一个迭代周期中包含多次迭代&#xA;        一个阶段的结束称之为里程碑&#xA;    初始化阶段增量&#xA;        项目启动&#xA;        建立业务模型&#xA;        定义业务问题域&#xA;        找出主要风险因素&#xA;        定义项目需求的外延&#xA;        创建业务问题域的相关说明文档&#xA;    细代阶段增量&#xA;        高层的分析与设计&#xA;        建立项目的基础框架&#xA;        监督主要的风险因素&#xA;        制订达成项目目标的创建计划&#xA;    构建阶段增量&#xA;        代码及功能的实现&#xA;    移交阶段增量&#xA;        向用户发布产品&#xA;        beta测试(alpha测试是内部测试， beta测试是用户测试)&#xA;        执行性能调优，用户培训和接收测试&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;转型&#34;&gt;&#xA;  转型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bd%ac%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;流程&#xA;    (2-4)周实地调研痛点&#xA;    确定目标&#xA;        要求: 领先、高效、高品质&#xA;        列出实际问题&#xA;    评估&#xA;        cmmi(敏捷成熟度模型): 代码、架构、工具&#xA;    实施变化&#xA;        战略&#xA;        试点团队(灰部应用于组织): 完成产品指标&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具功能&#34;&gt;&#xA;  工具功能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7%e5%8a%9f%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;控制面板&#xA;    项目&#xA;    分配给我&#xA;    活动日志&#xA;人员&#xA;    团队&#xA;    权限&#xA;项目&#xA;    配置&#xA;        事务&#xA;            类型&#xA;            布局            # 列表项，详细项&#xA;            时间追踪&#xA;            配置链接关系&#xA;            优先级&#xA;            解决方案&#xA;        工作流              # 对不同项目和事务类型, 配置状态转换图&#xA;        页面方案            # 对不同项目和事务类型，不同状态转换时，配置字段布局&#xA;        自定义字段          # 对不同页面&#xA;        权限&#xA;            权限&#xA;            角色、应用程序、组、用户、项目负责人、当前经办人、自定义字段值等&#xA;事务(issue)&#xA;    状态&#xA;        todo, 正在进行, done&#xA;        打开, 已重新打开, 已解决, 已关闭&#xA;        backlog, in review, selected for development, building, build broken&#xA;        waiting for support, respond to customer, escalate, cancel, canceled, done&#xA;        waiting for approval, work in progress&#xA;        [工作流状态]&#xA;    类别&#xA;        待办&#xA;        正在进行&#xA;        完成&#xA;        无类别&#xA;    名称&#xA;        长篇故事(史诗)&#xA;        故事&#xA;            分类: 需求, 设计&#xA;            验收条件&#xA;        任务, 子任务, 缺陷, 新增功能, 改进&#xA;        服务请求, 服务请求审批, 问题, 事件(系统中断)&#xA;    订单&#xA;        全局顺序&#xA;    属性&#xA;        经办人，报告人&#xA;        优先级&#xA;            highest, hign, medium, low, lowest&#xA;    链接&#xA;        clones&#xA;        is cloned by&#xA;        duplicates&#xA;        is duplicated by&#xA;        blocks&#xA;        is blocked by&#xA;        causes&#xA;        is caused by&#xA;        relates to&#xA;    csv导入&#xA;    筛选器&#xA;        未清, 我发起, 已完成, 最近&#xA;    活动&#xA;        评论, 历史, 工作日志&#xA;冲刺(sprint)&#xA;    状态&#xA;        待办, 进行, 完成&#xA;发布&#xA;    版本&#xA;报告(report)&#xA;    敏捷&#xA;        燃耗图, 燃尽图, 版本报告, 长篇故事报告, 控制图，长篇故事燃尽图, 发布燃尽图&#xA;        冲刺报告, 速率表&#xA;        累积流程图&#xA;    事务&#xA;        饼图, 单次分组, 解决时间, 平均周期, 事务持续时间, 已创建已解决对比, 最新创建&#xA;    预测&#xA;        版本工作量, 人员工作量, 时间跟踪&#xA;    其它&#xA;        工作负荷&#xA;服务台(itsm)&#xA;    分类&#xA;        对内&#xA;        对外&#xA;    途径&#xA;        邮件, 帮助中心, 小程序&#xA;    队列&#xA;        分类&#xA;        状态workflow&#xA;        经办人&#xA;    客户&#xA;    报告&#xA;系统&#xA;    审计日志&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>身体</title>
      <link>https://runout.run/docs/basic/body/</link>
      <pubDate>Wed, 10 Oct 2018 20:12:11 +0800</pubDate>
      <guid>https://runout.run/docs/basic/body/</guid>
      <description>&lt;h1 id=&#34;造型期&#34;&gt;&#xA;  造型期&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%a0%e5%9e%8b%e6%9c%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;体态&#xA;    高低肩&#xA;    骨盆前倾&#xA;体能&#xA;    心肺&#xA;    变速有氧：4、6、8各2min， 30min以上&#xA;力量&#xA;核心训练&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;健身计划&#34;&gt;&#xA;  健身计划&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%81%a5%e8%ba%ab%e8%ae%a1%e5%88%92&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;目标&#xA;指导&#xA;    FITT&#xA;        Frequency: 一周3-5次&#xA;        Intensity:&#xA;            有氧&#xA;                心率: 123-142&#xA;            无氧&#xA;                动作&#xA;                间歇&#xA;                个数&#xA;                重量&#xA;        Time:&#xA;            60min力量 + 30min有氧&#xA;        Type:&#xA;            热身&#xA;            抗阻力训练&#xA;            拉伸&#xA;阶段&#xA;    适应期(1-2月)&#xA;        心肺功能: 功率&#xA;        核心力量&#xA;            保护腰：呼吸 + 静态&#xA;            内脂&#xA;        力量训练&#xA;            动作规范&#xA;            蹲、推、拉、举、旋转&#xA;    进阶期(2-3月)&#xA;        消耗 &amp;gt; 摄入&#xA;        七大肌肉群：胸、肩、背、腹、腿、臀、手臂&#xA;            三分化、四分化&#xA;        爆发力&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>代码</title>
      <link>https://runout.run/docs/architect/code/</link>
      <pubDate>Wed, 10 Oct 2018 17:40:53 +0800</pubDate>
      <guid>https://runout.run/docs/architect/code/</guid>
      <description>&lt;h1 id=&#34;人类认知原理&#34;&gt;&#xA;  人类认知原理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ba%e7%b1%bb%e8%ae%a4%e7%9f%a5%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    模拟执行&#xA;负担&#xA;    概念量&#xA;        封装粒度大&#xA;        多态、运行时多态、静态多态&#xA;        临时状态&#xA;        用工作流, 而非队列&#xA;        日志(event)搜索/集中/回放&#xA;        抽出权限层&#xA;        非轻量级&#xA;            胶水层厚&#xA;            无稳定方案, 复用困难&#xA;    流程长度&#xA;最好&#xA;    单线程                  # 不插入行为&#xA;    上下文集中&#xA;        this.scene.commit()集中状态转移时间线&#xA;    单一方式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;软件设计原则&#34;&gt;&#xA;  软件设计原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;统一原则&#34;&gt;&#xA;  统一原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%9f%e4%b8%80%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;观念&#xA;    KISS(keep it simple stupid)&#xA;    YAGNI(You Ain’t Gonna Need It)&#xA;    取好名字占设计一半&#xA;    约定大于配置&#xA;    并发的世界，并发的软件&#xA;        分布式的世界，分布式的软件&#xA;        不可预测的世界，容错性强的软件&#xA;        复杂的世界，简单的软件&#xA;    代码即数据&#xA;        物体上绑定行为数据&#xA;        传递代码数据(函数一等公民)&#xA;    防御性编程&#xA;        接口前validator&#xA;        启动时自检断言&#xA;        异常处理&#xA;        不可过度&#xA;设计&#xA;    solid原则&#xA;        单一职则(single responsibility)&#xA;            一个类负责一个功能&#xA;        开闭(open/closed)&#xA;            对扩展开放，对修改关闭，如接口, 如数组扩展结构体状态&#xA;        里氏替换原则(liskov substitution)&#xA;            子类继承超类的所有&#xA;        接口分离(interface segregation)&#xA;            最小功能隔离&#xA;        依赖反转(dependency inversion)&#xA;            低层依赖高层, 具体依赖抽象&#xA;    非侵入     # non-intrusion&#xA;        将功能推入代码，而非代码拿到功能&#xA;        代码实现接口，而非继承类&#xA;    拆分&#xA;        边界&#xA;        正交&#xA;    unix rules&#xA;        模块化(modularity)          # 模块由精心设计的接口连接&#xA;        清晰化(clarity)             # 可读性、可维护性&#xA;        组合(composition)&#xA;        分离(separation)&#xA;        简单(simplicity)&#xA;        节俭(parsimony)             # 越小越好&#xA;        透明(transparency)          # log, tracing&#xA;        鲁棒(robustness)&#xA;        可展示(representation)      # 逻辑简单，数据复杂&#xA;        最小惊吓(least surprise)     # 少打破用户预期&#xA;        安静(silence)&#xA;        修复(repair)                # 产生足够报错&#xA;        经济(economy)               # 减少开发时间&#xA;        生成(generation)            # 避免手写, 用高阶抽象生成代码&#xA;        优化(optimization)            # 优化和收益平衡&#xA;        分化(diversity)             # 一开始设计不限制、优雅开放灵活&#xA;        扩展(extensibility)         # 协议可扩展&#xA;优化&#xA;    需要时再优化，设计时考虑扩展性&#xA;    dry(don&#39;t repeat yourself), 不可过度&#xA;    找瓶颈&#xA;产出&#xA;    设计清晰&#xA;    选型简单&#xA;    代码精炼&#xA;    抽象优雅&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;代码风格&#34;&gt;&#xA;  代码风格&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;命名&#xA;    包名类名为名词, 方法名为动词&#xA;    参数、方法名称在上下文语义中合理 , 像写文章一样&#xA;    横向代码单屏内分行&#xA;性能&#xA;    避免嵌套循环，特别是数据库操作&#xA;结构&#xA;    # 高内聚，低耦合&#xA;    抽取方法&#xA;    业务逻辑分层&#xA;    框架无侵入性&#xA;技巧&#xA;    注释驱动写复杂业务&#xA;    自解释代码&#xA;安全&#xA;    密码二次验证&#xA;    离机锁屏&#xA;    用户名、密码、ip、端口不提交&#xA;    代码安全, 如sql注入, XSS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;代码质量&#34;&gt;&#xA;  代码质量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;代码&#xA;    功能、结构、资源&#xA;非遗留代码&#xA;    写了测试&#xA;改代码&#xA;    bug&#xA;    重构&#xA;        # 只改结构&#xA;    确定修改点&#xA;        找出测试点&#xA;        解依赖&#xA;            伪/仿对象&#xA;            接缝&#xA;                全局函数&#xA;                    提取重写方法&#xA;                宏预处理&#xA;                替换连接的代码&#xA;                对象&#xA;                    # 耦合对象不好初始化&#xA;                    子类化重写方法&#xA;                    接口提取&#xA;                    创建简化接口&#xA;                    创建简化类与对象，引用原对象&#xA;                    暴露静态方法&#xA;                    对象提取公共方法，只测公共方法&#xA;                传方法参数&#xA;        写测试&#xA;    优化&#xA;        # 只改资源&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;具体实现原则&#34;&gt;&#xA;  具体实现原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xA;  数据结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;状态机解决流程问题&#xA;AST解决主义问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;面向对象object-oriented&#34;&gt;&#xA;  面向对象(Object Oriented)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1object-oriented&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;特性&#xA;ooad&#xA;    # Object Oriented Analysis and Design&#xA;    ooa     # analysis&#xA;        建立针对业务问题域的清晰视图&#xA;        列出核心任务&#xA;        针对问题域建立公共词汇表&#xA;        列出针对问题域的最佳解决方案&#xA;    ood     # design&#xA;        细化类关系，明确可见性&#xA;        增加属性&#xA;        分配职责(方法)&#xA;        消息驱动系统中消息传递方式&#xA;        局部应用设计模式&#xA;        类图时序图&#xA;    oop     # program&#xA;        抽象: abstract&#xA;            接口&#xA;                无实现&#xA;                可多重继承&#xA;            抽象类&#xA;                可以有私有方法变量&#xA;                实现部分方法&#xA;        封装: encapsulation&#xA;            # 数据和方法绑定&#xA;        继承: inheritance&#xA;        多态: polymorphism&#xA;            overload为编译时&#xA;            override为运行时&#xA;        关联: association&#xA;            # has a&#xA;            双向关联&#xA;                两个类互相知道对方公共属性和操作&#xA;            单向关联（大多数）&#xA;                一个类知道另一个类的公共属性和操作&#xA;            聚合: aggregation&#xA;                a包含b, b可以不在a创建时创建&#xA;            组合: composition&#xA;                比聚合强，a包含b, b在a创建时创建&#xA;        内聚与耦合: cohesion &amp;amp; coupling&#xA;            # 高内聚低耦合&#xA;        依赖: dependency&#xA;            # use a&#xA;        泛化: generalization&#xA;            # is a&#xA;            泛型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数式&#34;&gt;&#xA;  函数式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;数组&#xA;    [1, 1, 3, 5, 5].reduce(function(x, y){ return x + y;})&#xA;    [1, 4, 9].map(function(num){return num * 2;})&#xA;高阶函数(higher-order function)&#xA;    操作函数的函数, 接收函数作为参数, 返回函数&#xA;不完全函数(partial function)&#xA;    一次调用拆成多次调用，每次调用返回一个函数，如f(1,2)(3,4)(5,6)&#xA;        # 每次调用叫做不完全调用(partial application)&#xA;不变式&#xA;    循环不变式&#xA;        用于形式化证明正确性&#xA;        描述&#xA;            有循环变量&#xA;            算法初始、保持、终止时, 某特性不变, 如选择排序中, arr[0,...,j-1]一直有序&#xA;    类(或数据类型)不变式&#xA;        并发时, 不变的成员关系&#xA;            如, 并发临界区(同时只能一个线程占用)&#xA;cps(continuation passing style)&#xA;    传入处理函数, 处理函数中传处理函数&#xA;curry&#xA;    f(1,2,3)改写成f(1).f(2).f(3)&#xA;thunk&#xA;    触发函数, 如 f(){_f(1)}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>工程</title>
      <link>https://runout.run/docs/architect/project/ddd/</link>
      <pubDate>Wed, 10 Oct 2018 17:39:31 +0800</pubDate>
      <guid>https://runout.run/docs/architect/project/ddd/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;&#x9;Domain-driven Design&#xA;    针对传统软件开发流程（分析-设计-编码）各阶段业务割裂问题，一开始定义好领域&#xA;目标&#xA;    维护概念完整性(纯洁)，避免语义泄露和腐化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;概念&#34;&gt;&#xA;  概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;领域（Domain）&#xA;界限上下文（Bounded Context）&#xA;领域模型（Domain Model）&#xA;领域通用语言&#xA;分层架构&#xA;    展示层、应用层、领域层、基础设施层&#xA;最佳实践&#xA;    关联尽量少、尽量单项、尽量降低整体复杂度&#xA;    实体（Entity）&#xA;        领域中的唯一标识，属性尽量少&#xA;    值对象（Value Object）&#xA;        没有唯一标识，属性值不变&#xA;    领域服务（Domain Service）&#xA;        协调多个领域对象，只有方法没有状态&#xA;        应用层服务、领域层服务、基础层服务&#xA;    聚合、聚合根（Aggregate, Aggregate Root）&#xA;        聚合定义了一组有内聚关系的对象集合，聚合根是对聚合引用的唯一元素&#xA;        修改聚合必须在事务级别&#xA;        70%的聚合只有一个实体, 30%有2到3个实体。&#xA;        只有一个实体时，实体就是聚合根。多实体时思考哪个对象有独立存在的意义，且可与外部直接交互&#xA;    工厂（Factory）&#xA;        工厂模式&#xA;    仓储（Repository）&#xA;        持久化到DB，管理对象&#xA;        只对聚合设计仓储&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;建模&#34;&gt;&#xA;  建模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;原则&#34;&gt;&#xA;  原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;简单、容易、清晰&#xA;使用不动点&#xA;领域专注&#xA;聚合内强一致，跨聚合最终一致&#xA;内部概念完整一致(unification)&#xA;&#x9;术语不变、不矛盾、不重叠&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据模型do&#34;&gt;&#xA;  数据模型（DO）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8bdo&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;失血&#xA;&#x9;DO和DAO无业务逻辑，纯数据&#xA;贫血&#xA;&#x9;持久化逻辑在DAO中&#xA;充血&#xA;&#x9;service很薄，持久化的逻辑在DO中，无DAO或与DO双向依赖&#xA;肿胀&#xA;&#x9;无service，全部逻辑放DO&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分析设计&#34;&gt;&#xA;  分析设计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90%e8%ae%be%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分析模型&#34;&gt;&#xA;  分析模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 业务领域分析, 不考虑代码&#xA;问题&#xA;&#x9;含意不完整，不可图形或文字表达，错误假设&#xA;&#x9;会深入某细节&#xA;&#x9;忽略某细节直到设计或实现, 如持久化、性能&#xA;目标&#xA;&#x9;领域模型&#xA;&#x9;架构设计&#xA;事件风暴                    # 是开发建模，不是用户需求故事&#xA;&#x9;准备&#xA;&#x9;&#x9;功能确认: 近期milestone&#xA;&#x9;&#x9;找正确的人: 领域专家, 前后端，架构师&#xA;&#x9;&#x9;引导者: 准备资料, 排程, 时间, 2/3时间预警&#xA;&#x9;事件风暴&#xA;&#x9;&#x9;领域事件: 用户可感知状态&#xA;&#x9;&#x9;分支小组 -&amp;gt; 个人发散 -&amp;gt; 小组一致 -&amp;gt; 整体一致        # 不能一致表示准备不足&#xA;&#x9;&#x9;逻辑顺序 -&amp;gt; 最终流程&#xA;&#x9;命令风暴                # 为什么, 分色&#xA;&#x9;&#x9;事件触发原因、方式&#xA;&#x9;&#x9;用户角色&#xA;&#x9;&#x9;读模型: 用户前置需求&#xA;&#x9;&#x9;写模型: 动词&#xA;&#x9;&#x9;描述&#xA;&#x9;聚合&#xA;&#x9;&#x9;取名, 分职责&#xA;&#x9;持续探索&#xA;领域模型一开始就结合编码设计    # 设计围绕模型, 模型受设计反馈改善&#xA;&#x9;开发时意识到模型变更, 会保持完整性&#xA;&#x9;每个开发在修改前需要了解模型&#xA;&#x9;面向对象更易于建模, 过程化易于流程，如数学&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;重构&#34;&gt;&#xA;  重构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8d%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;要求&#xA;&#x9;设计灵活&#xA;&#x9;使用经过验证的构造&#xA;目标&#xA;&#x9;领域理解更深、更清晰&#xA;&#x9;&#x9;深刻(incisive)、深层(deep)的模型&#xA;&#x9;技术的动机的代码转换&#xA;实现&#xA;&#x9;小幅可控&#xA;&#x9;基于测试&#xA;&#x9;突破&#xA;&#x9;&#x9;新的概念或抽象&#xA;&#x9;&#x9;隐含的概念被凸显&#xA;&#x9;&#x9;&#x9;倾听领域语言&#xA;&#x9;&#x9;&#x9;过分复杂是因为关键点被替代&#xA;&#x9;&#x9;&#x9;领域文献        # 深层视图&#xA;&#x9;&#x9;&#x9;约束            # 表达不变量&#xA;&#x9;&#x9;&#x9;过程(process)   # 面向对象中的面向过程, 多个过程时用策略&#xA;&#x9;&#x9;&#x9;规约            # 测试对象返回布尔值, 重构成对象而非写在application&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;战略建模&#34;&gt;&#xA;  战略建模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%88%98%e7%95%a5%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 形成上下文映射图&#xA;问题空间&#xA;&#x9;领域                                            # 与公司组织关联&#xA;&#x9;&#x9;子域                                        # 最好对应一个限界上下文&#xA;&#x9;&#x9;&#x9;核心域(core domain)                     # 项目动机, 公司核心竞争力, 尽量小, 最高优先级&#xA;&#x9;&#x9;&#x9;通用子域(generic subdomain)             # 作用于整个系统的支撑子域&#xA;&#x9;&#x9;&#x9;支撑子域                                # 重要非核心&#xA;&#x9;集成&#xA;&#x9;&#x9;合作关系(partnership)                       # 同时成功失败&#xA;&#x9;&#x9;共享内核(shared kernel)                     # 小型内核, 持续集成功能&#xA;&#x9;&#x9;客户/供应(customer-supplier development)    # 上下游&#xA;&#x9;&#x9;遵从(conformist)                            # 下游遵从上游&#xA;&#x9;&#x9;防腐层(anticorruption layer)                # 翻译转换领域服务&#xA;&#x9;&#x9;开放主机服务(open host service)             # 公开协议，子系统访问&#xA;&#x9;&#x9;发布语言(published language)                # dsl, 通常与开放主机服务一起&#xA;&#x9;&#x9;分隔(separate way)                          # 声明无关联&#xA;&#x9;&#x9;大泥球(big ball of mud)                     # 已有纠缠的系统，隔离出来&#xA;解决方案空间&#xA;&#x9;通用语言&#xA;&#x9;&#x9;一个限界上下文一个通用语言&#xA;&#x9;&#x9;清晰(概念无二义性), 简洁                    # 如卖家和买家都叫用户，就是不清晰。如用type标记用户是卖家或买家，就是不简洁。所以直接用两个对象&#xA;&#x9;限界上下文                  # 条件的集合&#xA;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;确保术语含义明确&#xA;&#x9;&#x9;&#x9;切分规模, 易于保持领域纯洁&#xA;&#x9;&#x9;&#x9;设定进化框架而非模块，包含模块&#xA;&#x9;&#x9;考虑因素&#xA;&#x9;&#x9;&#x9;团队组织结构&#xA;&#x9;&#x9;&#x9;应用特定部分惯例、物理表现&#xA;&#x9;&#x9;挑战&#xA;&#x9;&#x9;&#x9;团队开发碎片化      # 写重复的代码，由于不知道或怕改错&#xA;&#x9;&#x9;&#x9;持续集成&#xA;&#x9;&#x9;&#x9;&#x9;早合并&#xA;&#x9;&#x9;&#x9;&#x9;自动构建测试    # 检测不一致&#xA;&#x9;&#x9;模块&#xA;&#x9;&#x9;&#x9;作用&#xA;&#x9;&#x9;&#x9;&#x9;降低模型规模复杂度&#xA;&#x9;&#x9;&#x9;&#x9;代码高内聚低耦合&#xA;&#x9;&#x9;&#x9;设计&#xA;&#x9;&#x9;&#x9;&#x9;通信性内聚(communicational cohesion)&#xA;&#x9;&#x9;&#x9;&#x9;功能性内聚(functional cohesion)&#xA;&#x9;&#x9;&#x9;&#x9;每模块统一接口&#xA;&#x9;&#x9;&#x9;&#x9;名称反映深层理解&#xA;&#x9;&#x9;&#x9;&#x9;灵活性，进化性&#xA;&#x9;上下文映射                  # 领域间集成关系&#xA;&#x9;&#x9;模式&#xA;&#x9;&#x9;&#x9;共享内核(shared kernel)                 # 为减少重复, 共享领域子集，多方测试&#xA;&#x9;&#x9;&#x9;客户-供应商(customer-supplier)          # 做反馈的需求, 需求测试, 自动化验收&#xA;&#x9;&#x9;&#x9;顺从者                                  # 供应商不做需求, 客户用适配器对接组件&#xA;&#x9;&#x9;&#x9;防腐层(anticorruption layer)            # 双向领域模型转换器, 保持内部模型纯洁&#xA;&#x9;&#x9;&#x9;&#x9;从前&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;原始数据(api, db)无模型无语义的处理&#xA;&#x9;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;对外多门面(facade)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;每个门面一个适配器(adapter)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;适配器间用转换器(translator)&#xA;&#x9;&#x9;&#x9;隔离通道(separate way)&#xA;&#x9;&#x9;&#x9;开放主机服务(open host service)         # 实现开放服务协议&#xA;&#x9;&#x9;&#x9;提炼                                    # 多次重构后还很大&#xA;&#x9;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;分离基本概念和普通概念, 提炼核心域和子域&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;子域&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;使用第三方服务&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;外包&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;修改已有模型&#xA;&#x9;六边形架构&#xA;&#x9;&#x9;领域模型简洁自治&#xA;&#x9;&#x9;对外适配器防腐, 保护限界上下文              # 如面向接口&#xA;&#x9;&#x9;&#x9;消息, 内存, 数据库&#xA;&#x9;&#x9;&#x9;soap, rest&#xA;&#x9;CQRS(command query responsibility segregationg)             # 修改只记事件(日志), 查询时计算&#xA;&#x9;&#x9;查询方式&#xA;&#x9;&#x9;&#x9;单数据库/读写分离，查询时计算事件&#xA;&#x9;&#x9;&#x9;读写分离, 读库异步计算事件保存冗余, 读库负载均衡&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;战术建模&#34;&gt;&#xA;  战术建模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%88%98%e6%9c%af%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 组成限界上下文&#xA;领域&#xA;&#x9;实体(entity)                # 标识和延续性, 有id, 持续变化。&#xA;&#x9;值对象(value object)        # 无id, 只有属性, 最好不可变(可共享)。尽量建模值对象。可包含实体引用或值对象。&#xA;&#x9;生命周期&#xA;&#x9;&#x9;聚合(aggregate)         # 定义对象所有权和边界&#xA;&#x9;&#x9;&#x9;简化&#xA;&#x9;&#x9;&#x9;&#x9;关联            # 可导航到的关联&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;1对1        # 对象引用&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;1对n        # 包含集合&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;n对n        # 删除关联，关系加约束或转换 &#xA;&#x9;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;&#x9;一致性&#xA;&#x9;&#x9;&#x9;&#x9;强化不变量&#xA;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;聚合根(root)    # 聚合根间是最终一致性&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;是个实体,有id&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;外部访问的唯一对象&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;向外传递副本&#xA;&#x9;&#x9;工厂(factory)           # 在领域中没有定义, 但程序需要&#xA;&#x9;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;&#x9;并非对象创建对象&#xA;&#x9;&#x9;&#x9;&#x9;对象创建存在自有知识&#xA;&#x9;&#x9;&#x9;&#x9;创建过程原子性&#xA;&#x9;&#x9;&#x9;&#x9;对已有持久化对象重建并修复&#xA;&#x9;&#x9;&#x9;问题&#xA;&#x9;&#x9;&#x9;&#x9;外部访问根内对象，需关联不必要的根实体&#xA;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;不用工厂&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;构造不复杂&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;不涉及其它对象&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;客户希望用策略创建&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;类是具体类型, 无层级&#xA;&#x9;&#x9;&#x9;&#x9;聚合根提供方法&#xA;&#x9;&#x9;&#x9;&#x9;单独工厂        # 违反了封装原则, 但保持了简单&#xA;&#x9;&#x9;资源库(repository)      # 内存假象&#xA;&#x9;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;&#x9;不关联根获取对象引用&#xA;&#x9;&#x9;&#x9;&#x9;不暴露细节, 会减少领域专注&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;防止代码扩散&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;减少变更修改&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;维护聚合封装性&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;容易的基础设施被滥用, 产生除聚合根外导航&#xA;&#x9;&#x9;&#x9;实现&#xA;&#x9;&#x9;&#x9;&#x9;封装所有获取对象逻辑&#xA;&#x9;&#x9;&#x9;&#x9;基础设施, 全局可访问&#xA;&#x9;&#x9;&#x9;&#x9;不同对象不同策略访问、存储      # 领域与基础设施解耦&#xA;&#x9;&#x9;&#x9;&#x9;接口是领域模型, 实现像基础设施&#xA;&#x9;&#x9;&#x9;&#x9;参数筛选或规约(specification)筛选(筛选器)&#xA;entity&#xA;&#x9;介绍&#xA;&#x9;&#x9;entity即状态&#xA;&#x9;&#x9;应用开发即处理entity的表现&#xA;&#x9;主从&#xA;&#x9;&#x9;主存储(可变)                    # 关键是选择主存储&#xA;&#x9;&#x9;&#x9;多派生一致性好保障&#xA;&#x9;&#x9;&#x9;派生表达业务的难易成度&#xA;&#x9;&#x9;只读派生(representation, 不可变)&#xA;&#x9;&#x9;&#x9;多份存储, 一致性&#xA;&#x9;&#x9;&#x9;派生, 合并, 转化&#xA;&#x9;类型&#xA;&#x9;&#x9;东西(可变)                      # 单据叠加成东西, 东西叠加成东西&#xA;&#x9;&#x9;单据(可变)                      # 事件叠加成单据&#xA;&#x9;&#x9;事件(event, 不可变)&#xA;&#x9;&#x9;命令(command, 不可变)&#xA;&#x9;&#x9;视图(view model, 不可变)&#xA;&#x9;&#x9;子集(subset, 不可变)&#xA;&#x9;&#x9;视图(aggregation, 不可变)&#xA;&#x9;&#x9;表单(可变)                      # 是主存储&#xA;&#x9;物理介质&#xA;&#x9;&#x9;OLTP(mysql)                     # 点查询&#xA;&#x9;&#x9;OLAP(clickHouse)                # 范围查询&#xA;&#x9;&#x9;queue(kafka)                    # 顺序读, 低延迟&#xA;&#x9;&#x9;业务服务                        # 业务逻辑, 像虚拟的表&#xA;&#x9;分组entity主存储(BC, bounded context)&#xA;&#x9;&#x9;目的&#xA;&#x9;&#x9;&#x9;分解&#xA;&#x9;&#x9;&#x9;&#x9;管理复杂度&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;系统&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;组织部门&#xA;&#x9;&#x9;&#x9;&#x9;实现内部一致性&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;概念, 数据&#xA;&#x9;&#x9;&#x9;对主存储进行受控的修改&#xA;&#x9;&#x9;边界entity                          # 用于集成，不一定是主存储&#xA;&#x9;&#x9;&#x9;形式&#xA;&#x9;&#x9;&#x9;&#x9;授权、binlog、工作流、视图数据、租户作为其它租户user&#xA;&#x9;&#x9;&#x9;&#x9;东西、单据、event&#xA;&#x9;&#x9;&#x9;介质&#xA;&#x9;&#x9;&#x9;&#x9;queue, 带权限db, rpc虚拟表&#xA;&#x9;&#x9;&#x9;触发&#xA;&#x9;&#x9;&#x9;&#x9;queue, ui, api&#xA;&#x9;&#x9;&#x9;&#x9;触发由worker托管, 输入是queue或rpc socket&#xA;&#x9;&#x9;粒度&#xA;&#x9;&#x9;&#x9;分entity&#xA;&#x9;&#x9;&#x9;分步骤&#xA;&#x9;&#x9;&#x9;分entity字段&#xA;&#x9;&#x9;&#x9;原则&#xA;&#x9;&#x9;&#x9;&#x9;BC尽可能少而大&#xA;&#x9;&#x9;关系&#xA;&#x9;&#x9;&#x9;时间错开&#xA;&#x9;&#x9;&#x9;&#x9;外键关系                    # BC挂载到BC, 如后台系统与计费系统的定价, 运营人员与服务系统的配置, 流程节点系统对流程的依赖&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;rpc, 数据库, 数据复制&#xA;&#x9;&#x9;&#x9;&#x9;报表关系&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;时效性高&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;一般做复制              # 所以边界entity是数据变更event&#xA;&#x9;&#x9;&#x9;&#x9;触发关系                    # fire and forget&#xA;&#x9;&#x9;&#x9;&#x9;交棒关系&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;下游给上游command/event, 上游触发&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;上游实现降级            # 下游不可用时，安慰语&#xA;&#x9;&#x9;&#x9;时间同时&#xA;&#x9;&#x9;&#x9;&#x9;accountable/responsible关系                 # 负责人与实现人&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;原则&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;accountable尽量小&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;只调度&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;与responsible的边界entity是rpc虚拟表, 请求command, 返回event&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;补偿实现一致                    # 如超卖&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;responsible提供自己界面         # accountable不控制&#xA;&#x9;&#x9;&#x9;&#x9;抢资源关系&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;锁服务&#xA;服务(service)                   # 无法划分对象的动作, 无状态。按功能分组, 多对象的连接点&#xA;&#x9;可在application, domain, infrastructure&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;最终一致性建模&#34;&gt;&#xA;  最终一致性建模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;in-memory&#34;&gt;&#xA;  In-Memory&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#in-memory&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;聚合根在内存，同步最新状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事件溯源event-sourcing&#34;&gt;&#xA;  事件溯源（Event Sourcing）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e4%bb%b6%e6%ba%af%e6%ba%90event-sourcing&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;&#x9;没有CRUD，只有Append Event。数据不可变&#xA;&#x9;对象最新状态通过事件溯源获得&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;actor&#34;&gt;&#xA;  Actor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#actor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;通过Mailbox取代调用，保证消息线性处理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;edaevent-driven-architecture&#34;&gt;&#xA;  EDA(Event-driven Architecture)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#edaevent-driven-architecture&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;节点只处理逻辑，节点间Event通信&#xA;是最终一致性的架构&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cqrs&#34;&gt;&#xA;  CQRS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cqrs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;&#x9;Command Query Responsibility Seperation&#xA;&#x9;CQ接口分离、代码分离，分别设计&#xA;概念&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;项目结构&#34;&gt;&#xA;  项目结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;用户接口(user interface)&#xA;应用(application)                   # 尽可能小。数据验证，事务。故事, 表达出操作的事情&#xA;    application service&#xA;    unit work&#xA;    presentation model&#xA;领域(domain)                        # 专注领域。准确定义业务对象&#xA;    aggregate, entity, value object&#xA;    domain service, domain event&#xA;基础设施(infrastructure)            # 辅助层&#xA;    repository&#xA;    global support&#xA;项目文件&#xA;    [ui]&#xA;        mall                            # 商城api&#xA;    [saleDomain]&#xA;        [application]&#xA;            mall.application            # 分模块，讲述故事&#xA;                CartService&#xA;                    GetCart()&#xA;                BuyService&#xA;                    Buy()&#xA;            mall.application.domainEventSubscribers         # 订阅domain事件&#xA;        [domain]&#xA;            mall.domain                 # 不大而全，要求刚好满足需求&#xA;                cartModule&#xA;                    entity&#xA;                        CartItem&#xA;                    aggregate&#xA;                        Cart&#xA;                valueObject&#xA;                    Product&#xA;                    SellingPriceCart&#xA;                IDomainServices&#xA;                IRemoteServices         # 访问远程资源接口&#xA;                    IUserService&#xA;                    ISellingPriceService&#xA;                IRepositories           # 仓储接口&#xA;                    ICartRepository&#xA;            mall.domain.events          # 领域事件, 用于实现最终一致性&#xA;            mall.domainService          # 操作domain的无状态方法&#xA;                ConfirmUserCartExistedDomainService&#xA;    [sellingPriceDomain]                # 与saleDomain合作关系, sale请求sellingPrice定价&#xA;        [appication]&#xA;            mall.application.SellingPrice&#xA;                dto&#xA;                    CalculatedCartDTO&#xA;                mapper&#xA;                    ValueObjectToDTO&#xA;        [domain]&#xA;    [infrastructure]&#xA;        mall.infrastructure             # 通用类库&#xA;            domainCore                  # mail.domain base方法&#xA;                AggregateRoot&#xA;                    Cart&#xA;                Entity&#xA;                    CartItem&#xA;                ValueObject&#xA;                    Product&#xA;                IUnitOfWork             # 仓储事务&#xA;            domainEventCore&#xA;                DomainEvent&#xA;                DomainEventBus&#xA;                DomainEventSubscriber&#xA;                IDomainEvent&#xA;                IDomainEventSubscriber&#xA;        mall.infrastructure.repositories                # 仓储&#xA;            CartSqlServerRepository&#xA;        mall.infrastructure.translators                 # 防腐层, 访问远程资源实现&#xA;            user&#xA;                UserAdapter             # 请求原始结果&#xA;                UserService&#xA;                UserTranslator          # 转换原始结果&#xA;模块结构&#xA;&#x9;api: controller&#xA;&#x9;biz: 特异业务&#xA;&#x9;&#x9;manager&#xA;&#x9;&#x9;converter&#xA;&#x9;core: 公用业务&#xA;&#x9;&#x9;model&#xA;&#x9;&#x9;&#x9;entity&#xA;&#x9;&#x9;&#x9;bo&#xA;&#x9;&#x9;service&#xA;&#x9;&#x9;&#x9;repository&#xA;&#x9;common&#xA;&#x9;&#x9;dal&#xA;&#x9;&#x9;&#x9;dataobject&#xA;&#x9;&#x9;&#x9;&#x9;do&#xA;&#x9;&#x9;&#x9;dao&#xA;&#x9;&#x9;&#x9;mapper&#xA;&#x9;&#x9;service&#xA;&#x9;&#x9;&#x9;facade&#xA;&#x9;&#x9;&#x9;&#x9;dto: facade和controller用&#xA;&#x9;&#x9;&#x9;&#x9;service: 服务间api&#xA;&#x9;&#x9;&#x9;&#x9;validate&#xA;&#x9;&#x9;&#x9;integration&#xA;&#x9;&#x9;&#x9;&#x9;service&#xA;&#x9;&#x9;shared&#xA;&#x9;&#x9;&#x9;dto: 项目内部公用&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Java设计模式</title>
      <link>https://runout.run/docs/architect/code/design_mode/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/architect/code/design_mode/</guid>
      <description>&lt;h1 id=&#34;六个原则&#34;&gt;&#xA;  六个原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ad%e4%b8%aa%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;单一职责原则(SRP, Single Responsibility Principle)&#xA;    一个类只做一件事，应该只有一个引起它修改的原因&#xA;开闭原则(OCP, Open-Close Principle)&#xA;    对修改封闭，对扩展开放&#xA;里氏替换原则(LSP, the Liskov Substitution Principle)&#xA;    子类可以完全替换父类。也就是继承只扩展新功能&#xA;依赖倒置原则(DIP, the Dependency Inversion Principle)&#xA;    细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定&#xA;接口隔离原则(ISP, the Interface Segregation Principle)&#xA;    客户端不依赖它不需要的接口。冗余依赖应该将接口拆分&#xA;迪米特法则（最少知道原则）(LoD, Law of Demeter)&#xA;    一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;构建型&#34;&gt;&#xA;  构建型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e5%bb%ba%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;工厂方法factory-method&#34;&gt;&#xA;  工厂方法(Factory Method)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95factory-method&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 简单工厂, 根据参数创建不同的类&#xA;# 静态工厂，单例工厂&#xA;public interface Sender{&#xA;    public void Send();&#xA;}&#xA;public class MySender implements Sender{&#xA;    @Override&#xA;    public void Send(){}&#xA;}&#xA;public SenderFactory {&#xA;    public static Sender produceStatic() {&#xA;        return new MySender();&#xA;    }&#xA;    public Sender produce(){&#xA;        return new MySender();&#xA;    }&#xA;    public Sender produce(int i){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&#xA;# 工厂子类继承工厂接口, 不同产品对应不同工厂&#xA;public interface AbstractFactory {&#xA;    public MySender produce();&#xA;}&#xA;public class MyFactory implements AbstractFactory {&#xA;    @Override&#xA;    public MySender produce(){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;抽象工厂abstract-factory&#34;&gt;&#xA;  抽象工厂(Abstract Factory)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82abstract-factory&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 生产抽象产品&#xA;public interface AbstractFactory {&#xA;    public Sender produce();&#xA;}&#xA;public class MyFactory implements AbstractFactory {&#xA;    @Override&#xA;    public Sender produce(){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;单例singleton&#34;&gt;&#xA;  单例(Singleton)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e4%be%8bsingleton&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;确保只有一个实例&#xA;    # 大多有资源管理器的功能&#xA;    # 反射机制会使所有单例失效：私有构造方法可以被访问&#xA;应用&#xA;    线程池&#xA;    缓存&#xA;    日志对象&#xA;    对话框&#xA;    打印机&#xA;    显卡驱动程序&#xA;o-&amp;gt; 饿汉&#xA;public class Singleton {&#xA;    public static Singleton instance = new Singleton();&#xA;    private Singleton(){}&#xA;    public static Singleton getInstance(){&#xA;        return instance;&#xA;    }&#xA;}&#xA;o-&amp;gt; 懒汉式&#xA;public class Singleton {&#xA;    private static Singleton single=null;&#xA;    private Singleton() {}&#xA;    public synchronized  static Singleton getInstance() {&#xA;        if (single == null) {&#xA;            single = new Singleton();&#xA;        }&#xA;        return single;&#xA;    }&#xA;}&#xA;o-&amp;gt; 懒汉，双重检测(DCL)&#xA;    # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。&#xA;    # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized&#xA;public class Singleton {&#xA;    private static volatile Singleton singleton = null;&#xA;        # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。&#xA;    private Singleton(){}&#xA;    public static Singleton getInstance(){&#xA;        if (singleton == null) {&#xA;            // t1,t2并发进入&#xA;            synchronized (Singleton.class) {&#xA;                // t1释放后，t2进入&#xA;                if (singleton == null) {&#xA;                    singleton = new Singleton();&#xA;                }&#xA;            }&#xA;        }&#xA;        return singleton;&#xA;    }&#xA;}&#xA;o-&amp;gt; map注册&#xA;    # 学Spring，将类名注册&#xA;public class Singleton {&#xA;    private static Map&amp;lt;String,Singleton&amp;gt; map = new HashMap&amp;lt;String,Singleton&amp;gt;();&#xA;    static{&#xA;        Singleton single = new Singleton();&#xA;        map.put(single.getClass().getName(), single);&#xA;    }&#xA;    protected Singleton(){}&#xA;    public static Singleton getInstance(String name) {&#xA;        if(name == null) {&#xA;            name = Singleton.class.getName();&#xA;        }&#xA;        if(map.get(name) == null) {&#xA;            map.put(name, (Singleton) Class.forName(name).newInstance());&#xA;        }&#xA;        return map.get(name);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;建造者builder&#34;&gt;&#xA;  建造者(Builder)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bb%ba%e9%80%a0%e8%80%85builder&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 提供工厂方法，建造内部复合对象&#xA;o-&amp;gt;&#xA;public class Builder {&#xA;    private List&amp;lt;Sender&amp;gt; list = new ArrayList&amp;lt;Sender&amp;gt;();&#xA;    public void produceMailSender() {&#xA;        list.add(new MailSender())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;原型prototype&#34;&gt;&#xA;  原型(Prototype)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%9e%8bprototype&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 复制原型来创建新对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;结构型&#34;&gt;&#xA;  结构型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;适配器adapter&#34;&gt;&#xA;  适配器(Adapter)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%82%e9%85%8d%e5%99%a8adapter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 用来匹配接口&#xA;o-&amp;gt; 类&#xA;public class Source(){&#xA;    public void method1(){}&#xA;}&#xA;public interface Targetable {&#xA;    public void method1()&#xA;    public void method2()&#xA;}&#xA;public class Adapter extends Source implements Targetable {&#xA;    @Override&#xA;    public void method2(){}&#xA;}&#xA;o-&amp;gt; 对象&#xA;public class Wrapper implements Targetable {&#xA;    private Source source;&#xA;    public Wrapper(Source source){&#xA;        super();&#xA;        this.source = source;&#xA;    }&#xA;    @Override&#xA;    public void method1(){&#xA;        source.method1()&#xA;    }&#xA;    @Override&#xA;    public void method2(){}&#xA;}&#xA;o-&amp;gt; 接口&#xA;public abstract class AbstractTarget implements Targetable {&#xA;    @Override&#xA;    public void method1(){}&#xA;}&#xA;public class Adapter extends AbstractTarget {&#xA;    @Override&#xA;    public method2(){}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;桥接bridge&#34;&gt;&#xA;  桥接(Bridge)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%a5%e6%8e%a5bridge&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 分离抽象和具体(两个维度发展)分别继承，抽象聚合(桥接)具体&#xA;public abstract class Gift {&#xA;    GiftImpl impl;&#xA;}&#xA;public class Flower extends GiftImpl {}&#xA;public class WarmGift extends Gift {&#xA;    public WarmGift(GiftImpl impl) {&#xA;        this.impl = impl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;组合composite&#34;&gt;&#xA;  组合(Composite)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e5%90%88composite&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 树状结构&#xA;abstract class Node{}&#xA;class LeafNode extends Node{}&#xA;class BranchNode extends Node{&#xA;    List&amp;lt;Node&amp;gt; nodes = new ArrayList&amp;lt;&amp;gt;();&#xA;}&#xA;&#xA;tree(Node b, int depth) {&#xA;    b.print();&#xA;    if (b instanceof BranchNode) {&#xA;        for (Node n : ((BranchNode)b).nodes){&#xA;            tree(n, depth+1)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;装饰decorator&#34;&gt;&#xA;  装饰(Decorator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a3%85%e9%a5%b0decorator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 持有被装饰实例，实现同一接口&#xA;public interface Sourceable {&#xA;    public void method();&#xA;}&#xA;public class Source implements Sourceable {&#xA;    @Override&#xA;    public void method(){}&#xA;}&#xA;public class Decorator implements Sourceable {&#xA;    private Sourceable source;&#xA;    public Decorator(Sourceable source) {&#xA;        super();&#xA;        this.source = source;&#xA;    }&#xA;    @Override&#xA;    public void method() {&#xA;        source.method();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;门面facade&#34;&gt;&#xA;  门面(Facade)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%a8%e9%9d%a2facade&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 对外接待&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中介者mediator&#34;&gt;&#xA;  中介者(Mediator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e4%bb%8b%e8%80%85mediator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 内部都只关联它，如mq&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;享元flyweight&#34;&gt;&#xA;  享元(Flyweight)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ab%e5%85%83flyweight&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 共享元数据&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;代理&#34;&gt;&#xA;  代理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 静态代理，实现同装饰&#xA;class TankTimeProxy implements Movable {&#xA;    Movable m;&#xA;    @Override&#xA;    public void move(){&#xA;        m.move();&#xA;    }&#xA;}&#xA;&#xA;# 动态代理，Proxy调asm生成代理类&#xA;Tank tank = new Tank();&#xA;Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader()), &#xA;    new Class[]{Movable.class},&#xA;    new Hander(tank)&#xA;);&#xA;class Handler implements InvocationHandler {&#xA;    Tank tank;&#xA;    @Override&#xA;    public Object invoke(Object proxy, Method method, Object[] args) {&#xA;        return method.invoke(tank, args);&#xA;    }&#xA;}&#xA;&#xA;// 动态代理, CGLIB调asm，由于是继承，所以final类不能代理&#xA;Enhancer enhancer = new Enhancer();&#xA;enhancer.setSuperclass(Tank.class);&#xA;enhancer.setCallback(new TimeMethodInterceptor());&#xA;Tank tank = (Tank)enhancer.create();&#xA;tank.move();&#xA;class TimeMethodInterceptor implements MethodInterceptor {&#xA;    @Override&#xA;    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) {&#xA;        return methodProxy.invokeSuper(o, objects);&#xA;    }&#xA;}&#xA;&#xA;// Spring AOP: aspect指定代理类, pointcut指定被代理方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;行为型&#34;&gt;&#xA;  行为型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%8c%e4%b8%ba%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;观察者&#34;&gt;&#xA;  观察者&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%82%e5%af%9f%e8%80%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Observer, 对象变化，对观察者广播&#xA;public interface Observer {&#xA;    public void update();&#xA;}&#xA;public class Observer1 implements Observer {&#xA;    @Override&#xA;    public void update(){}&#xA;}&#xA;public interface Subject{&#xA;    public void add(Observer observer);&#xA;    public void del(Observer observer);&#xA;    public void notifyObservers();&#xA;    public void operate()&#xA;}&#xA;public abstract class AbstractSubject implements Subject {&#xA;    private Vector&amp;lt;Observer&amp;gt; vector = new Vector&amp;lt;Observer&amp;gt;();&#xA;    @Override&#xA;    public void add(Observer observer) {&#xA;        vector.add(observer);&#xA;    }&#xA;    @Override&#xA;    public void del(Observer observer) {&#xA;        vector.remove(observer);&#xA;    }&#xA;    @Override&#xA;    public void notifyObservers(){&#xA;        Enumeration&amp;lt;Observer&amp;gt; enumo = vector.elements();&#xA;        while (enumo.hasMoreElements()) {&#xA;            enumo.nextElement().update();&#xA;        }&#xA;    }&#xA;}&#xA;public class MySubject extends AbstractSubject {&#xA;    @Override&#xA;    public void operate() {&#xA;        notifyObservers();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模板方法templatemethod&#34;&gt;&#xA;  模板方法(TemplateMethod)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95templatemethod&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 钩子函数&#xA;abstract class F {&#xA;    public void m() {&#xA;        op1();&#xA;    }&#xA;    abstract void op1();&#xA;}&#xA;class C1 extends F {&#xA;    @Override&#xA;    void op1(){}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;状态state&#34;&gt;&#xA;  状态(State)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8a%b6%e6%80%81state&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 状态便于扩展, 方法不便扩展。如果相反用switch&#xA;public class MM {&#xA;    MMState state;&#xA;    public void smile(){&#xA;        state.smile();&#xA;    }&#xA;}&#xA;public abstract class MMState {&#xA;    abstract void smile();&#xA;}&#xA;public class MMHappyState extends MMState {&#xA;    @Override&#xA;    void smile(){}&#xA;}&#xA;&#xA;# FSM例子，线程状态&#xA;public class Thread_ {&#xA;    ThreadState_ state;&#xA;    void move(Action a) { state.move(a);}&#xA;}&#xA;abstract class ThreadState_ {&#xA;    abstract void move(Action a);&#xA;}&#xA;public class NewState extends ThreadState_ {&#xA;    private Thread_ t;&#xA;    @Override&#xA;    void move(Action a) {&#xA;        if (&amp;quot;start&amp;quot;.equals(a.msg)) {&#xA;            t.state = new RunningState(t);&#xA;        }&#xA;    }&#xA;}&#xA;public class Action {&#xA;    String msg;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;迭代器iterator&#34;&gt;&#xA;  迭代器(Iterator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e5%99%a8iterator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;public interface Iterator&amp;lt;E&amp;gt; {&#xA;    boolean hasNext();&#xA;    E next();&#xA;}&#xA;public interface Collection&amp;lt;E&amp;gt; {&#xA;    Iterator&amp;lt;E&amp;gt; iterator();&#xA;}&#xA;class List&amp;lt;E&amp;gt; implements Collection&amp;lt;E&amp;gt; {&#xA;    private class Itr&amp;lt;E&amp;gt; implements Iterator&amp;lt;E&amp;gt; {&#xA;        @Override&#xA;        public boolean hasNext(){}&#xA;        @Override&#xA;        public E next(){}&#xA;    }&#xA;    @Override&#xA;    public Iterator iterator(){&#xA;        return new Itr();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;策略&#34;&gt;&#xA;  策略&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ad%96%e7%95%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# strategy, 封装多个算法类, 更换策略，调用方式一致&#xA;o-&amp;gt;&#xA;public interface ICalculator {&#xA;    public int calculate(String exp);&#xA;}&#xA;public class Minus extends AbstractCaculator implements ICalculator {&#xA;    @Override&#xA;    public int calculate(String exp) {&#xA;        int arrayInt[] = split(exp, &amp;quot;-&amp;quot;);&#xA;        return arrayInt[0] - arrayInt[1];&#xA;    }&#xA;}&#xA;public class AbstractCalculator {&#xA;    public int[] split(String exp, String opt) {&#xA;        String[] array = exp.split(opt);&#xA;        int arrayInt[] = new int[2];&#xA;        arrayInt[0] = Integer.parseInt(array[0]);&#xA;        arrayInt[1] = Integer.parseInt(array[1]);&#xA;        return arrayInt;&#xA;    }&#xA;}&#xA;Icalculator cal = new Minus();&#xA;cal.calculate(exp);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;备忘录memento&#34;&gt;&#xA;  备忘录(Memento)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%87%e5%bf%98%e5%bd%95memento&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 快照&#xA;# Java序列化, ProtoBuf库&#xA;class C implements Serializable {&#xA;    private transient List&amp;lt;Object&amp;gt; list;&#xA;}&#xA;ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&amp;quot;&amp;quot;)));&#xA;oos.writeObject(o1)&#xA;oos.writeObject(o2)&#xA;ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&amp;quot;&amp;quot;)));&#xA;o1 = ois.readObject();&#xA;o2 = ois.readObject();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;命令command&#34;&gt;&#xA;  命令(Command)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4command&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 别名Action或Transaction&#xA;# 配合组合实现宏命令, 配合责任链实现undo，配合备忘录实现事务回滚&#xA;abstract class Command {&#xA;    abstract void do();&#xA;    abstract void undo();&#xA;}&#xA;class InsertCommand extends Command {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;责任链chain-of-responsibility&#34;&gt;&#xA;  责任链(Chain of Responsibility)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%a3%e4%bb%bb%e9%93%bechain-of-responsibility&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;interface Filter {&#xA;    boolean doFilter(Msg m);&#xA;}&#xA;class HTMLFilter implements Filter {}&#xA;class FilterChain implements Filter{&#xA;    List&amp;lt;Filter&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;();&#xA;    public boolean doFilter(Msg msg){&#xA;        for (Filter f : filters) {&#xA;            if (!f.doFilter(msg)) {&#xA;                return false;&#xA;            }&#xA;        }&#xA;        return true;&#xA;    }&#xA;    public FilterChain add(Filter f) {&#xA;        filters.add(f);&#xA;        return this;&#xA;    }&#xA;}&#xA;FilterChain fc = new FilterChain();&#xA;FilterChain fc2 = new FilterChain();&#xA;Filter f = new Filter();&#xA;fc.add(f).add(fc2);&#xA;&#xA;# ServletFilter&#xA;Filter1 implements Filter {&#xA;    void doFilter(req, resp, chain) {&#xA;        chain.doFilter(req, resp);&#xA;    }&#xA;}&#xA;FilterChain implements Filter {&#xA;    List&amp;lt;Filter&amp;gt; filters;&#xA;    int curIndex = 0;&#xA;    void doFilter(req, resp){&#xA;        curIndex++;&#xA;        if (curIndex &amp;lt; filters.size()) {&#xA;            filters[curIndex].doFilter(req, resp, this);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;访问者visitor&#34;&gt;&#xA;  访问者(Visitor)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%bf%e9%97%ae%e8%80%85visitor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 内部结构不变，访问方式扩展&#xA;interface Visitor {&#xA;    void visitCpu(CPU cpu);&#xA;} &#xA;class Visitor1 implements Visitor {&#xA;    double price = 0.0;&#xA;    @Override&#xA;    void visitCpu(CPU cpu) {&#xA;        price += cpu.getPrice() * 0.9;&#xA;    }&#xA;}&#xA;class Computer {&#xA;    Part cpu;&#xA;    void accept(Visitor v) {&#xA;        this.cpu.accept(v);&#xA;    }&#xA;}&#xA;abstract class Part {&#xA;    abstract void accept(Visitor v);&#xA;    abstract double getPrice();&#xA;}&#xA;class CPU extends Part {&#xA;    @Override&#xA;    void accept(Visitor v){&#xA;        v.visitCpu(this);&#xA;    }&#xA;}&#xA;&#xA;Visitor p = new Visitor1();&#xA;new Computer().accept(p);&#xA;p.price;&#xA;&#xA;# Java类AST编译器Visitor, ASM&#xA;// 打印&#xA;class ClassPrinter extends ClassVisitor {&#xA;    @Override&#xA;    MethodVisitor visitMethod(){&#xA;        print(name + &amp;quot;()&amp;quot;);&#xA;        retrun null;&#xA;    }&#xA;}&#xA;ClassPrinter cp = new ClassPrinter();&#xA;ClassReader cr = new ClassReader(&amp;quot;java.lang.Runnable&amp;quot;);&#xA;cr.accept(cp, 0);&#xA;&#xA;// 生成类&#xA;ClassWriter cw = new ClassWriter(0);&#xA;cw.visitMethod(ACC_PULIC + ACC_ABSTRACT, &amp;quot;compareTo&amp;quot;, &amp;quot;(Ljava/lang/Object;)I&amp;quot;, null, null).visitEnd();&#xA;cw.visitEnd();&#xA;MyClassLoader cl = new MyClassLoader();&#xA;byte[] b = cw.toByteArray();&#xA;Class c = cl.defineClass(&amp;quot;pkg.Comparable&amp;quot;, b, 0, b.length);&#xA;&#xA;// 代理类&#xA;ClassReader cr = new ClassReader();&#xA;ClassWriter cw = new ClassWriter(0);&#xA;ClassVisitor cv = new ClassVisitor(ASM4, cw) {&#xA;    @Override&#xA;    public MethodVisitor visitMethod() {&#xA;        MethodVisitor mv = super.visitMethod(); &#xA;        return new MethodVisitor(ASM4, mv) {&#xA;            @Override&#xA;            public void visitCode(){&#xA;                visitMethodInsn(INVOKESTATIC, &amp;quot;TimeProxy&amp;quot;, &amp;quot;before&amp;quot;, &amp;quot;()v&amp;quot;, false);&#xA;                super.visitCode();&#xA;            }&#xA;        }&#xA;    }&#xA;};&#xA;cr.accept(cv, 0);&#xA;cw.toByteArray();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;解释器intepreter&#34;&gt;&#xA;  解释器(Intepreter)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%87%8a%e5%99%a8intepreter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 解释出AST&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;其它补充&#34;&gt;&#xA;  其它补充&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b6%e5%ae%83%e8%a1%a5%e5%85%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;元素模式&#xA;    # 抽象各模式成元素，简化表示&#xA;actor&#xA;    # 消息通信&#xA;reactor&#xA;    # 事件轮循，注册回调，如libevent&#xA;proactor&#xA;    # 注册事件回调，os通知触发回调&#xA;惰性求值&#xA;    链式定义(配方)，后自动触发(js tick调度)终止操作&#xA;dsl测试(如jasmine.js)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
