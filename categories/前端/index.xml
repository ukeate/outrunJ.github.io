<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on outrun的笔记</title>
    <link>https://runout.run/categories/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on outrun的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 22 Sep 2021 21:45:53 +0800</lastBuildDate>
    <atom:link href="https://runout.run/categories/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bootstrap</title>
      <link>https://runout.run/docs/middleware/library_frontend/bootstrap/</link>
      <pubDate>Thu, 11 Oct 2018 09:39:11 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/bootstrap/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;在jquery基础上的组件框架&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;移动&#34;&gt;&#xA;  移动&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a7%bb%e5%8a%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;css&#34;&gt;&#xA;  css&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#css&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局&#xA;        container&#xA;                # div, 唯一包裹容器&#xA;        container-fluid&#xA;                # 占全部视口&#xA;栅格&#xA;        # 必须放在row内&#xA;        col-xs-1&#xA;                # 适用于大于等于分界点的屏幕&#xA;                ## 大于12的最后那个col另起一行排列&#xA;                # xs &amp;lt; 768px 宽度, container 最大宽度: 自动&#xA;                # sm &amp;gt;= 768px, 750px&#xA;                # md &amp;gt;= 992px, 970px&#xA;                # lg &amp;gt;= 1200px, 1170px&#xA;        &#xA;        col-md-offset-4&#xA;                # 向右偏移4&#xA;        col-md-pull-9&#xA;                # 向后推9, 改变元素的顺序&#xA;        col-md-push-3&#xA;        &#xA;        o-&amp;gt; mixin&#xA;        make-row&#xA;                如 .wrapper {.make-row();}&#xA;        make-xs-column&#xA;        make-sm-column-offset&#xA;        make-sm-column-push&#xA;        make-sm-column-pull&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;样式&#34;&gt;&#xA;  样式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b7%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;muted&#xA;        # 文本颜色&#xA;        text-warning&#xA;        text-error&#xA;        text-info&#xA;        text-success&#xA;text-left&#xA;        # 文本左对齐&#xA;        text-center&#xA;        text-right&#xA;        text-justify&#xA;        text-nowrap&#xA;        text-lowercase&#xA;        text-uppercase&#xA;        text-capitalize&#xA;&#xA;bg-primary&#xA;        # p&#xA;        bg-success&#xA;        bg-info&#xA;        bg-warning&#xA;        bg-danger&#xA;&#xA;success&#xA;        # 状态类&#xA;        # table行颜色, control-group div&#xA;        error&#xA;        danger&#xA;        warning&#xA;        info&#xA;        active&#xA;has-warning&#xA;        # div元素&#xA;        # 适用class: control-label, form-control, help-block&#xA;        has-error&#xA;        has-success&#xA;has-feedback&#xA;        # div, &#xA;&#xA;pull-right&#xA;        # 任意元素向右浮动&#xA;        pull-left&#xA;navbar-right&#xA;        # 导航条中向右浮动&#xA;        navbar-left&#xA;clearfix&#xA;        # 清除浮动&#xA;&#xA;initialism&#xA;        # 缩略语样式, abbr标签&#xA;small&#xA;        # small标签的样式&#xA;lead&#xA;        # p标签，突出显示&#xA;blockquote-reverse&#xA;        # blockquote标签使用, 内容右对齐&#xA;&#xA;disabled&#xA;        # btn, input, 只disable样式&#xA;        o-&amp;gt; 适用的class&#xA;        radio&#xA;        radio-inline&#xA;        checkbox&#xA;        checkbox-inline&#xA;        o-&amp;gt; 适用的标签&#xA;        fieldset&#xA;&#xA;inline&#xA;        # 行内ul, checkbox&#xA;&#xA;center-block&#xA;        # 任意元素, 水平居中&#xA;&#xA;show&#xA;        # 任意元素显示&#xA;        hidden&#xA;&#xA;.sr-only&#xA;        # 任意元素, 辅助技术支持的文本, 隐藏当前元素&#xA;        sr-only-focusable&#xA;                # 元素有焦点时显示出来&#xA;&#xA;visible-xs-block&#xA;        # 只对xs屏幕可见&#xA;        visible-xs-inline&#xA;        visible-xs-inline-block&#xA;hidden-xs&#xA;        # 对xs屏隐藏&#xA;visible-print-block&#xA;        # 对打印机可见&#xA;        visible-print-inline&#xA;        visible-print-inline-block&#xA;hidden-print&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;table&#34;&gt;&#xA;  table&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#table&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;table&#xA;        # table样式&#xA;table-responsive&#xA;        # div元素，包裹table样式后，创建响应式表格，带有滚动条&#xA;table-striped&#xA;        # 斑马纹样式&#xA;table-bordered&#xA;        # 边框圆角&#xA;table-hover&#xA;        # 行悬停样式&#xA;table-condensed&#xA;        # 内补减半使更紧凑&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;form&#34;&gt;&#xA;  form&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#form&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;form-search&#xA;        # form标签中添加，其中有input&#xA;        search-query&#xA;                # search中的input的样式&#xA;form-actions&#xA;        # div元素, 内部按钮自动缩进&#xA;form-inline&#xA;        # 行内表单&#xA;form-actions&#xA;        # div元素，按钮列表，和表单其它元素对齐&#xA;form-horizontal&#xA;        # 元素右对齐左浮动的表单&#xA;form-group&#xA;        # form中的div元素&#xA;        form-control&#xA;                # input, textarea, select&#xA;                o-&amp;gt; 支持的input类型&#xA;                text&#xA;                password&#xA;                datetime&#xA;                datetime-local&#xA;                date&#xA;                month&#xA;                time&#xA;                week&#xA;                number&#xA;                email&#xA;                url        &#xA;                search&#xA;                tel        &#xA;                color    &#xA;        form-control-static&#xA;                # p标签，用来代input显示文本  &#xA;        control-group&#xA;                control-label&#xA;                controls&#xA;        input-group&#xA;                input-group-addon&#xA;                        # span&#xA;                form-control&#xA;                        # 同外&#xA;        glyphicon-ok&#xA;                # input元素或input-group的div元素后的span, 添加input内的图标&#xA;                # 联合使用 class: glyphicon, form-control-feedback; &#xA;                ## 属性 aria-hidden=&amp;quot;true&amp;quot;&#xA;                glyphicon-warning-sign&#xA;                glyphicon-remove&#xA;                &#xA;checkbox&#xA;        # div, label&#xA;radio&#xA;        # div, label&#xA;checkbox-inline&#xA;        # div&#xA;radio-inline&#xA;        # div&#xA;&#xA;controls&#xA;        # div元素，为input增加合适的间距, 浮动它们缩减空白，再清除浮动&#xA;        controls-row&#xA;                # 排一行，增加合适间距&#xA;&#xA;input-mini&#xA;        input-small&#xA;        input-medium&#xA;        input-large&#xA;        input-xlarge&#xA;        input-xxlarge&#xA;input-sm&#xA;        # input, select, 高度&#xA;        input-lg&#xA;form-group-sm&#xA;        # class为form-group的div, 高度&#xA;        form-group-lg&#xA;        &#xA;input-prepend&#xA;        # 前缀input, 可与input-append组合&#xA;        add-on&#xA;                # span标签&#xA;        btn&#xA;        span2&#xA;                # input标签&#xA;input-append&#xA;&#xA;input-block-level&#xA;        # 块级input&#xA;uneditable-input&#xA;        # span元素模拟不可编辑input&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;小件&#34;&gt;&#xA;  小件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%8f%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;btn&#xA;        # a, button, input&#xA;btn-group&#xA;        # div标签 按钮下拉菜单&#xA;        dropdown-toggle&#xA;                # 要赋加自定义属性data-toggle=&amp;quot;dropdown&amp;quot;来关联执行js&#xA;        dropdown-menu&#xA;                # ul标签&#xA;btn-primary&#xA;        # 按钮样式&#xA;        btn-info&#xA;        btn-success&#xA;        btn-warning&#xA;        btn-danger&#xA;        btn-inverse&#xA;        btn-link&#xA;        btn-default&#xA;btn-lg&#xA;        btn-sm&#xA;        btn-xs&#xA;btn-block&#xA;        # 块级按钮&#xA;&#xA;span1&#xA;        # input元素, select元素&#xA;        span2&#xA;        span3&#xA;        span4&#xA;        span5&#xA;help-inline&#xA;        # span元素，帮助文本&#xA;help-block&#xA;        # span元素, 块显示帮助&#xA;&#xA;img-rounded&#xA;        # img, 图片样式&#xA;        img-circle&#xA;        img-polaroid&#xA;img-responsive&#xA;        # img, 图片响应式&#xA;&#xA;caret&#xA;        # span标签, 下箭头&#xA;close&#xA;        # button, 关闭图&#xA;&#xA;&#xA;list-unstyled&#xA;        # 无样式列表&#xA;dl-horizontal&#xA;        # dl列表水平描述&#xA;pre-scrollable&#xA;        # pre标签内容滚动&#xA;text-overflow&#xA;        # 截断改写数据, 可能会垂直显示&#xA;text-hide&#xA;        # h1, 将元素的文本内容替换为背景图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;导航&#34;&gt;&#xA;  导航&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%bc%e8%88%aa&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;div role=&amp;quot;navigation&amp;quot;&#xA;        # 如果作为导航条, 父元素加属性，或者用nav标签&#xA;        &amp;lt;ul class=&amp;quot;nav nav-tabs&amp;quot;&#xA;                # nav-pills 改成胶囊样式&#xA;                # nav-stacked 改成垂直&#xA;                # nav-justified 自适应宽度&#xA;                &amp;lt;li role=&amp;quot;presentation&amp;quot; class=&amp;quot;active&amp;quot;&#xA;                        # disabled&#xA;                &amp;lt;li role=&amp;quot;presentation&amp;quot; class=&amp;quot;dropdown&amp;quot;&#xA;                        &amp;lt;a class=&amp;quot;dropdown-toggle&amp;quot; role=&amp;quot;button&amp;quot; &#xA;                                data-toggle=&amp;quot;dropdown&amp;quot;&#xA;                                aria-haspopup=&amp;quot;true&amp;quot; aria-expanded=&amp;quot;false&amp;quot; &#xA;                        &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot;&#xA;&#xA;&amp;lt;nav class=&amp;quot;navbar navbar-default&amp;quot;&#xA;        # 添加navbar-fixed-top可以冻结到顶部&#xA;        ## 设置body{padding-top: 70px;}来使内容不被遮盖&#xA;        ## navbar-fixed-bottom, 同样要设置padding-bottom&#xA;        ## navbar-static-top 向下滚动就消失&#xA;        # navbar-inverse 反色&#xA;        &amp;lt;div class=&amp;quot;container-fluid&amp;quot;&#xA;                &amp;lt;div class=&amp;quot;navbar-header&amp;quot;&#xA;                        &amp;lt;a class=&amp;quot;navbar-brand&amp;quot;&#xA;                                &amp;lt;img alt=&amp;quot;Brand&amp;quot;&#xA;                                        # 图标&#xA;                        &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;navbar-toggle collapsed&amp;quot;&#xA;                                data-toggle=&amp;quot;collapse&amp;quot; &#xA;                                data-target=&amp;quot;#bs&amp;quot;&#xA;                                aria-expanded=&amp;quot;false&amp;quot;&#xA;                                &amp;lt;span class=&amp;quot;icon-bar&amp;quot;&#xA;                                        # 放隐藏菜单的&#xA;                                &amp;lt;span class=&amp;quot;icon-bar&amp;quot;&#xA;                                &amp;lt;span class=&amp;quot;icon-bar&amp;quot;&#xA;                        &amp;lt;a class=&amp;quot;navbar-brand&amp;quot;&#xA;                &amp;lt;button type=&amp;quot;button&amp;quot; class=&amp;quot;btn btn-default navbar-btn&amp;quot;&#xA;                        # navbar-btn可以上按钮垂直居中&#xA;                &amp;lt;p class=&amp;quot;navbar-text&amp;quot;&#xA;                &amp;lt;div class=&amp;quot;collapse navbar-collapse&amp;quot; id=&amp;quot;bs&amp;quot;&#xA;                        &amp;lt;ul class=&amp;quot;nav navbar-nav&amp;quot;&#xA;                                &amp;lt;li&amp;gt;&amp;lt;a&#xA;                        &amp;lt;form class=&amp;quot;navbar-form navbar-left&amp;quot; role=&amp;quot;search&amp;quot;&#xA;                                # navbar-form自动垂直对齐，折叠&#xA;                                # navbar-left 让正确对齐，由pull-left mixin而来&#xA;                                &amp;lt;div class=&amp;quot;form-group&amp;quot;&#xA;                                        &amp;lt;input class=&amp;quot;form-control&amp;quot;&#xA;                                &amp;lt;button class=&amp;quot;btn btn-default&amp;quot;&#xA;                        &amp;lt;ul class=&amp;quot;nav navbar-nav navbar-right&amp;quot;&#xA;                        &amp;lt;p class=&amp;quot;navbar-text navbar-right&amp;quot;&#xA;                                # 不支持多个navbar-right&#xA;                                &amp;lt;a class=&amp;quot;navbar-link&amp;quot;&#xA;&#xA;&amp;lt;ol class=&amp;quot;breadcrumb&amp;quot;&#xA;        # 面包屑&#xA;        &amp;lt;li&#xA;        &amp;lt;li class=&amp;quot;active&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;图标&#34;&gt;&#xA;  图标&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be%e6%a0%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;icon-white&#xA;        # 反色为白色&#xA;fa-dashboard&#xA;        # 配合fa使用                &#xA;        fa-fw&#xA;                # 小左箭头&#xA;fa-lg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;默认渲染&#34;&gt;&#xA;  默认渲染&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%bb%98%e8%ae%a4%e6%b8%b2%e6%9f%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt; ... &amp;lt;h6&amp;gt;&#xA;&amp;lt;small&amp;gt;&#xA;&amp;lt;p&amp;gt;&#xA;&amp;lt;mark&amp;gt;&#xA;&amp;lt;del&amp;gt;&#xA;&amp;lt;s&amp;gt;&#xA;&amp;lt;ins&amp;gt;&#xA;&amp;lt;u&amp;gt;&#xA;&amp;lt;small&amp;gt;&#xA;&amp;lt;strong&amp;gt;&#xA;&amp;lt;em&amp;gt;&#xA;&amp;lt;abbr&amp;gt;&#xA;&amp;lt;address&amp;gt;&#xA;&amp;lt;blockquote&amp;gt;&#xA;        &amp;lt;p&amp;gt;&#xA;        &amp;lt;footer&amp;gt;&#xA;                &amp;lt;cite&amp;gt;&#xA;&amp;lt;ul&amp;gt;&#xA;        &amp;lt;li&amp;gt;&#xA;&amp;lt;ol&amp;gt;&#xA;        &amp;lt;li&amp;gt;&#xA;&amp;lt;dl&amp;gt;&#xA;        &amp;lt;dt&amp;gt;&#xA;        &amp;lt;dd&amp;gt;&#xA;&amp;lt;code&amp;gt;&#xA;&amp;lt;kbd&amp;gt;&#xA;&amp;lt;pre&amp;gt;&#xA;&amp;lt;var&amp;gt;&#xA;&amp;lt;samp&amp;gt;&#xA;        # 程序输出&#xA;属性&#xA;        aria-label&#xA;                # input元素, 替代label&#xA;        aria-labelledby&#xA;        title&#xA;                # 辅助功能阅读&#xA;        aria-describedby&#xA;                # input 辅助阅读&#xA;        disabled&#xA;        readonly&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;less&#34;&gt;&#xA;  less&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#less&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;@baseFontSize&#xA;        @font-size-base&#xA;        # 全局font-size基准，计算出所有页面元素的margin, padding, line-height, 改变bootstrap默认样式&#xA;@baseLineHeight&#xA;        @line-height-base&#xA;        # 同上, line-height基准&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;table-responsive&amp;quot;&amp;gt;&#xA;        &amp;lt;table class=&amp;quot;table table-striped table-bordered table-hover&amp;quot;&amp;gt;&#xA;                # table table-condensed 紧凑型表格&#xA;                &amp;lt;thead&amp;gt;&#xA;                        &amp;lt;tr&amp;gt;&#xA;                                &amp;lt;th&amp;gt;标题&#xA;                &amp;lt;tbody&amp;gt;&#xA;                        &amp;lt;tr class=&amp;quot;active&amp;quot;&amp;gt;&#xA;                                # success info warning danger&#xA;&amp;lt;/div&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;scrollspy&#xA;    介绍&#xA;            监测滚动到目前页面锚点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;bootInit&#xA;    介绍&#xA;            检测bootstrap标签语法，不支持扩展插件&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Threejs</title>
      <link>https://runout.run/docs/middleware/library_frontend/threejs/</link>
      <pubDate>Thu, 11 Oct 2018 07:58:16 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/threejs/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;协调程序加载项的类库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;var preload = new createjs.LoadQueue(false, &amp;quot;assets/&amp;quot;);&#xA;var plugin= {&#xA;        getPreloadHandlers: function(){&#xA;                return{&#xA;                        types: [&amp;quot;image&amp;quot;],&#xA;                        callback: function(src){&#xA;                                var id = src.toLowerCase().split(&amp;quot;/&amp;quot;).pop().split(&amp;quot;.&amp;quot;)[0];&#xA;                                var img = document.getElementById(id);&#xA;                                return {tag: img};&#xA;                        }&#xA;                }&#xA;        }&#xA;}&#xA;preload.installPlugin(plugin);&#xA;preload.loadManifest([&#xA;        &amp;quot;Autumn.png&amp;quot;,&#xA;        &amp;quot;BlueBird.png&amp;quot;,&#xA;        &amp;quot;Nepal.jpg&amp;quot;,&#xA;        &amp;quot;Texas.jpg&amp;quot;&#xA;]);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;涉及dom&#34;&gt;&#xA;  涉及dom&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%89%e5%8f%8adom&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;        window.innerWidth&#xA;        window.innerHeight&#xA;事件&#xA;        window.addEventListener(&#39;resize&#39;, onWindowResize, false);&#xA;                function onWindowResize(){&#xA;                        camera.aspect = window.innerWidth / window.innerHeight;&#xA;                        camera.updateProjectionMatrix();&#xA;                        renderer.setSize(window.innerWidth, window.innerHeight);&#xA;                        controls.handleResize();&#xA;                }&#xA;三大组件&#xA;    场景(scene)&#xA;            var scene = new THREE.Scene();&#xA;    相机(camera)&#xA;            var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);                                        # 透视相机&#xA;    渲染器(renderer)&#xA;            var renderer = new THREE.WebGLRenderer();&#xA;            renderer.setSize(window.innerWidth, window.innerHeight);&#xA;            document.body.appendChild(renderer.domElement);                        # domElement 是画布&#xA;            render( scene, camera, renderTarget, forceClear )                        ＃ renderTarget默认是前面设置的renderer  size, forceClear自动清除(设置为false也会清除)&#xA;版本&#xA;    THREE.VERSION&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;renderer&#34;&gt;&#xA;  renderer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#renderer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);                # 透视摄像机&#xA;    camera.position.x = 0;&#xA;    camera.position.y = 0;&#xA;    camera.position.z = 600;                                                                # 相机位置&#xA;    camera.up.x = 0;&#xA;    camera.up.y = 1;&#xA;    camera.up.z = 0;                                                                        # 相机&amp;quot;上&amp;quot;的方向&#xA;    camera.lookAt({x:0, y:0, z:0});                                                                # 视野中心坐标&#xA;    camera.setViewOffset(fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight)&#xA;            # 相机的有效显示部分&#xA;&#xA;WebGLRenderer &#xA;    renderer = new THREE.WebGLRenderer({ antialias: false});&#xA;                    # 抗锯齿为false。true时显示更清晰，更耗cpu&#xA;            renderer.setClearColorHex( 0x000000, 1);&#xA;            renderer.setSize(window.innerWidth, window.innerHeight);&#xA;                    # 设置渲染器的宽度和高度&#xA;            renderer.autoClear = false;&#xA;            renderer.sortObjects = false;&#xA;            &#xA;            renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);&#xA;                    # 设置一个渲染目标&#xA;            renderTarget.minFilter = THREE.LinearFilter;&#xA;            renderTarget.magFilter = THREE.NearestFilter;&#xA;            postBloom = new BloomEffect(renderer, renderTarget, window.innerWidth, window.innerHeight, 4);&#xA;&#xA;            renderer.shadowMapEnabled = true;&#xA;                    # 开启显示阴影&#xA;                    ## 要显示阴影，还要设置物体castShadow = true; receiveShadow = true;&#xA;                    ## shadowMap是一张记录每个像素用于比较遮挡关系的texture&#xA;            renderer.shadowMapSoft = true;&#xA;                    # 可以使阴影更加平滑，产生更少的锯齿&#xA;            renderer.shadowCameraNear = 3;&#xA;            renderer.shadowCameraFar = camera.far;&#xA;            renderer.shadowCameraFov = 50;&#xA;                    # 表示摄像机近平面、远平面、角度的值。在摄像机范围内的物体产生阴影&#xA;            renderer.shadowMapBias = 0.0039;&#xA;            renderer.shadowMapDarkness = 0.5;&#xA;                    # 表示阴影的透明度, 0是完全透明&#xA;            renderer.shadowMapWidth = 512;&#xA;            renderer.shadowMapHeight = 512;&#xA;                    # 指定阴影渲染面的大小&#xA;                    ## 根据shadermap原理，阴影需要先绘制在一个缓冲区中，再根据缓冲区计算阴影。这就是缓冲区的大小。&#xA;&#xA;            container = document.createElement(&#39;div&#39;);&#xA;            document.body.appendChild(container);&#xA;            container.appendChild(renderer.domElement);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;camera&#34;&gt;&#xA;  camera&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#camera&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    camera = new THREE.Camera(60, 1, 1, 6500);&#xA;    camera.position.z = -85;&#xA;    camera.position.y = 40;&#xA;    camera.aspect = window.innerWidth / window.innerHeight;&#xA;&#xA;    cameraTarget = new THREE.Object3D();&#xA;            # 相机目标&#xA;    cameraTarget.position.y = 10;&#xA;    cameraTarget.position.z = 6000;&#xA;    camera.target = cameraTarget;&#xA;&#xA;    camera.updateProjectionMatrix();&#xA;PerspectiveCamera&#xA;    THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);                # 透视摄像机&#xA;    camera.position.x = 0;&#xA;    camera.position.y = 0;&#xA;    camera.position.z = 600;                                                                # 相机位置&#xA;    camera.up.x = 0;&#xA;    camera.up.y = 1;&#xA;    camera.up.z = 0;                                                                        # 相机&amp;quot;上&amp;quot;的方向&#xA;    camera.lookAt({x:0, y:0, z:0});                                                                # 视野中心坐标&#xA;    camera.setViewOffset(fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight)&#xA;            # 相机的有效显示部分&#xA;OrthographicCamera&#xA;    OrthographicCamera(left, right, top, bottom, near, far)&#xA;            # 左右上下远近&#xA;controls&#xA;    contorls = new THREE.FirstPersonControls(camera);&#xA;    contorls.movementSpeed = 20;                                        # 移动速度&#xA;    controls.lookSpeed = 0.05;                                                # 转头速度&#xA;    controls.lookVertical = true;                                                # 是否允许抬头或低头&#xA;PathControls        # 路径相机&#xA;    controls = new THREE.PathControls(camera);&#xA;    controls.createDebugPath = true;&#xA;            # 是否显示轨道&#xA;            ## scene.add(controls.debugPath)来添加显示&#xA;    controls.waypoints = [[-500, 0, 0], [0, 200, 0], [500, 0, 0]];&#xA;            # 路径的转折点，非转折点用插值来计算&#xA;    controls.duration = 28;&#xA;            # 轨道的一头到另一头的运动时间(ms), 默认是10 * 1000&#xA;    controls.useConstantSpeed =true;&#xA;            # 设置为匀速运行&#xA;    controls.lookSpeed = 0.06;&#xA;            # 转头速度, 默认是0.005。数越大，转头越快&#xA;            ##页面显示帧数越快, 转头越快&#xA;    controls.lookVertical = true;&#xA;            # 是否可以上下转头&#xA;    controls.lookHorizontal = true;&#xA;            # 是否可以左右转头&#xA;    controls.verticalAngleMap = {srcRange: [0, 2 * Math.PI], dstRange:[1.1, 3.8]};&#xA;    controls.horizontalAngleMap = {srcRange: [0, 2 * Math.PI], dstRange: [0.3, Math.PI - 0.3]};&#xA;    controls.lon = 180;&#xA;&#xA;    controls.init();&#xA;    scene.add( controls.animationParent );&#xA;            # 用THREE.js提供的Animation类来插值改变相机位置和方向&#xA;            ## pathControls类中有initAnimationPath函数将动作转换为关键帧，存到了parentAnimation属性中&#xA;            ### THREE.AnimationHandler中的add函数，把scene中的parentAnimation中的关键帧动作键入THREE.JS的动画引擎中。动画引擎会自动在关键帧之间插值，来决定关键帧中物体(如相机)的位置、大小、缩放等。&#xA;&#xA;    function  render(){&#xA;            controls.update(delta);&#xA;            THREE.AnimationHandler.update(delta);&#xA;                    ### 让动画引擎动起来&#xA;    }&#xA;TrackballControls   # 轨迹球相机&#xA;    介绍&#xA;            追踪相机, 轨迹球相机&#xA;    作用&#xA;            控制相机，左键旋转，右键平移，滚轮缩放&#xA;    api&#xA;            THREE.TrackballControls = function (object, domElement)&#xA;                    # object一般是传入相机这个变量&#xA;                    # domElement为在哪个div中监听鼠标事件, 默认为document&#xA;&#xA;    controls = new THREE.TrackballControls(camera);&#xA;            # 传入相机作为参数来控制相机&#xA;    controls.rotateSpeed = 5.0;&#xA;            # 旋转的速度&#xA;    controls.zoomSpeed = 5;&#xA;            # 缩放的速度&#xA;    controls.panSpeed = 2;&#xA;            # 平移的速度&#xA;    controls.noZoom = false;&#xA;            # 不允许放大&#xA;    controls.noPan = false;&#xA;            # 不允许右键摇镜头&#xA;    controls.staticMoving = false;&#xA;            #  是否静态移动, false时移动镜头会有弹性&#xA;    controls.dynamicDampingFactor = 0.3;&#xA;            # 阻力系数&#xA;            ## 旋转时慢慢停下来是这个系数起作用&#xA;&#xA;    function animate(){&#xA;            requestAnimationFrame(animate);&#xA;            controls.update();&#xA;                    # 完成更新相机属性的工作&#xA;            rederer.render(scene, camera);&#xA;            stats.update();&#xA;    }&#xA;FlyControls     # 飞行相机&#xA;FirstPersonControls     # 第一人称相机&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;scene&#34;&gt;&#xA;  scene&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#scene&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    scene = new THREE.Scene();  # 场景&#xA;            scene.add(meshCube);&#xA;            scene.add(light);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;light&#34;&gt;&#xA;  light&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#light&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    // light.position.x = x;&#xA;    light.position.set(0, 0, 300).normalize();;        &#xA;            # 坐标, 向量化为1&#xA;&#xA;    scene.add(light);                        &#xA;PointLight  # 点光源&#xA;    var light = new THREE.PointLight(0x00FF00);&#xA;DirectionalLight    # 方向光&#xA;    var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125);&#xA;            # 0.125是颜色的密度, 和透明度差不多, 这里表示很淡很淡的白色&#xA;    scene.add(dirLight)&#xA;AmbientLight    # 环境光&#xA;    scene.add(new THREE.AmbientLight(0x111111));&#xA;SpotLight   # 聚光灯&#xA;    light = new THREE.SpotLight(0xffffff, 1.25);&#xA;        light.target.position.set(0, 0, 0);&#xA;        light.castShadow = true;&#xA;                # 显现阴影，默认不显现&#xA;                ## 显现阴影还要对renderer进行设置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;object&#34;&gt;&#xA;  object&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#object&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;mesh&#34;&gt;&#xA;  mesh&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mesh&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    var mesh = THREE.Mesh(geometry, material);                                                                # mesh模型&#xA;            mesh.position.x= x;&#xA;            mesh.rotation.x = rx;&#xA;            scene.add(meshCube);&#xA;    方法&#xA;            mesh1.addChild(mesh2)&#xA;                    # mesh2加入mesh1, 组成一个Mesh&#xA;            &#xA;    api&#xA;            mesh.scale.multiplyScalar(0.35)&#xA;                    # 让x y z方向缩放系数到原模型的0.35倍&#xA;line&#xA;    THREE.Line( geometry, material, THREE.LinePieces );                                                ＃ 线&#xA;            scene.add(line);&#xA;    例子&#xA;            var line_material = new THREE.LineBasicMaterial({color: 0x303030}),&#xA;            geometry = new THREE.Geometry(),&#xA;            floor = -75, step = 25;&#xA;            for( var i = 0; i &amp;lt;= 40; i++){&#xA;                    geometry.vertices.push(new THREE.Vector3(-500, floor, i * step - 500));&#xA;                    geometry.vertices.push(new THREE.Vector3(500, floor, i * step - 500));&#xA;&#xA;                    geometry.vertices.push(new THREE.Vector3(i * step - 500, floor,- 500));&#xA;                    geometry.vertices.push(new THREE.Vector3(i * step - 500, floor, 500));&#xA;            }&#xA;            var line = new THREE.Line(geometry, line_material, THREE.LinePieces);&#xA;            scene.add(line);&#xA;MorphAnimMesh&#xA;    介绍&#xA;            动画网格模型&#xA;            包含几个动画帧(一极动画模型)，通过播放帧来看动画。&#xA;            可以设置帧数，播放到哪一帧，顺播还是倒播。&#xA;    THREE.MorphAnimMesh = function (geometry, material){&#xA;            THREE.Mesh.call(this, geometry, material);&#xA;                    # 调用基类构造函数&#xA;            this.duration = 1000;&#xA;                    # 完成所有帧的时间(milliseconds)&#xA;            this.mirroredLoop = false;&#xA;                    # 表示镜像循环(是否循环播放)&#xA;            this.time = 0;&#xA;                    # 当前播放时间&#xA;            this.lastKeyframe = 0;&#xA;                    # 上一帧&#xA;            this.currentKeyframe = 0;&#xA;                    # 当前播放的帧&#xA;            this.direction = 1;&#xA;                    # 表示从前向后播放, -1是从后向前&#xA;            this.directionBackwards = false;&#xA;                    # 是否倒播&#xA;            this.setFrameRange(0, this.geometry.morphTargets.length - 1);&#xA;                    # 设置最小帧和最大帧&#xA;                    ## 这里开始帧是0, 结束帧是 总帧数 - 1&#xA;    }&#xA;    方法&#xA;            THREE.MorphAnimMesh.prototype.setDirectionForward = function(){&#xA;                    this.direction = 1;&#xA;                            # 1是前进, -1是后退&#xA;                    this.directionBackwords = false;&#xA;                            # false表示前进&#xA;            }&#xA;                    # 计算下一帧是哪一帧时，根据上面两个变量计算&#xA;            THREE.MorphAnimMesh.prototype.setDirectionBackward&#xA;            THREE.MorphAnimMesh.prototype.setAnimationLabel = function(label, start, end){&#xA;                    if( !this.geometry.animations) this.geometry.animation = {};&#xA;                    this.geometry.animations[label] = {start: start, end: end};&#xA;            }&#xA;                    # 设置帧分组标签(为了给每组设置不同的播放速度)&#xA;            THREE.MorphAnimMesh.playAnimation(&#39;A&#39;, 33)&#xA;                    # 播放标签为&#39;A&#39;的组动画，帧数(fps)为33帧/秒&#xA;            THREE.MorphAnimMesh.prototype.updateAnimation = function(delta&#xA;                    # delta表示实际浏览器每次刷新的间隔时间&#xA;                    # 作用: 主要更新lastKeyframe&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;mesh组件&#34;&gt;&#xA;  mesh组件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mesh%e7%bb%84%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;geometry&#34;&gt;&#xA;  geometry&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#geometry&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        geometry表示形状&#xA;THREE.Geometry();&#xA;        # 空几何体&#xA;        geometry.vertices.push(p1);&#xA;        # p1是一个点&#xA;        geometry.vertices.push(p2);&#xA;        geometry.colors.push( color1, color2 );&#xA;&#xA;属性&#xA;        vertices&#xA;                # 顶点数组&#xA;        colors&#xA;        morphColors&#xA;                # 加载json模型后存储颜色的地方&#xA;        faces        &#xA;                # 面数组&#xA;                color&#xA;        faceVertexUvs&#xA;                # 面法线数组&#xA;                方法&#xA;                        set                # 设置纹理坐标&#xA;                                faceVertexUvs[0][2][0].set(0, 0)&#xA;                                faceVertexUvs[0][2][1].set(0, 0)&#xA;                                faceVertexUvs[0][2][2].set(0, 0)&#xA;                                faceVertexUvs[0][2][3].set(0, 0)&#xA;                                        # 设置第2个面(顶面)的纹理坐标全部为0，这样就去掉了这个面的纹理坐标&#xA;                                        # 第一维表示第几种纹理，第二维表示第几个面，第三维表示第几个顶点的纹理坐标&#xA;BufferGeometry&#xA;    一般编程中&#xA;            物体的形状可以用一个类Geometry来表示&#xA;            物体顶点内容如果放到缓冲区中，可以new分配连续的内存&#xA;            物体和内存是分离的&#xA;    Tree.js中&#xA;            物体和内存统一起来，形成了THREE.BufferGeometry&#xA;            THREE.BufferGeometry = Buffer + THREE.Geometry&#xA;            BufferGeometry是自由度最高的geometry类型&#xA;                    自由指定每个顶点的位置、颜色、法线(影响光照)&#xA;                    Buffer就是将顶点位置数组、顶点颜色数组等放在一个缓冲区中，加快加载与运行速度。&#xA;                            Buffer的这些缓冲区存储在BufferGeometry的属性attributes集合对象里面&#xA;                                    # attributes初始化时为空 this.attributes = {};&#xA;    api&#xA;            var geometry = new THREE.BufferGeometry();&#xA;                    # THREE.BufferGeometry = function()&#xA;IcosahedronGeometry&#xA;    二十面体&#xA;&#xA;    radius = 200&#xA;    geometry = new THREE.IcosahedronGeometry(radius, 1);&#xA;    faceIndices = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];&#xA;    for(var i = 0; i &amp;lt; geometry.faces.length; i++){&#xA;            f = geometry.faces[i];&#xA;                    # 得到第i个面&#xA;            n = (f instanceof THREE.Face3) ? 3 : 4;&#xA;                    # 判断每个面由几个点组成&#xA;                    # 每个点可以由f.a, f.b, f.c, f.d得到&#xA;            for(var j = 0; j &amp;lt; n; j++){&#xA;                    vertexIndex = f[faceIndices[j]];&#xA;                            # 得到点在geometry中的索引&#xA;                    p = geometry.vertices[vertexIndex];&#xA;                            # 得到点&#xA;                    f.vertexColors[j] = color;&#xA;                            # 给面的顶点赋值&#xA;                            ## 顶点默认颜色为白色&#xA;            }&#xA;    }&#xA;SphereGeometry&#xA;    var geometry = new THREE.SphereGeometry(70, 32, 16);&#xA;            # 70是半径, 32和16表示横向和纵向球体由多少线分割&#xA;BoxGeometry&#xA;    介绍&#xA;            原来的CubeGeometry&#xA;    长立方体&#xA;            THREE.CubeGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments)&#xA;                    # 参数分别表示x y z轴长度和分别在x y z轴上被分成了几份&#xA;CylinderGeometry&#xA;    圆柱体&#xA;            THREE.CylinderGeometry(100, 150, 400);&#xA;PlaneGeometry   # 平面&#xA;TextGeometry&#xA;    介绍&#xA;            可以从字体文件中生成字体几何体&#xA;&#xA;    THREE.TextGeometry = function(text, parameters)&#xA;            # text是要显示的文字&#xA;            # parameters包括&#xA;            ## size: &amp;lt;float&amp;gt; 字体大小, 如80号是小字体&#xA;            ## height: &amp;lt;float&amp;gt; 厚度&#xA;            ## curveSegments: &amp;lt;int&amp;gt; 一条曲线上点的数目, 越多越精细&#xA;            ## font: &amp;lt;string&amp;gt; 使用字体的名称&#xA;            ## weight: &amp;lt;string&amp;gt; `取值normal或bold, 如果字体中没有bold, 整个程序会崩溃&#xA;            ## style: &amp;lt;string&amp;gt; 取值normal或italics(斜体), 没有italics也会崩溃&#xA;&#xA;    使用&#xA;            在typeface上转换自己的字体&#xA;                    http://typeface.neocracy.org/fonts.html&#xA;                    # 要求字体的签名是TrueType或OpenType&#xA;                    # 在Convert Font页面选择要转换的字,可以加快转换,也减少生成js文件的大小&#xA;            var text3d = new THREE.TextGeometry(&#39;要显示的字&#39;, {&#xA;                    size: 120,&#xA;                    height: 30,&#xA;                    curveSegments: 3,&#xA;                    font: &#39;simhei&#39;,&#xA;                    face: &#39;simhei&#39;,&#xA;                    weight: &#39;normal&#39;&#xA;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;material&#34;&gt;&#xA;  material&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#material&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    THREE.LineBasicMaterial( parameters );                                                        # 线材质&#xA;        参数&#xA;                Color：线条的颜色，用16进制来表示，默认的颜色是白色。&#xA;                Linewidth：线条的宽度，默认时候1个单位宽度。&#xA;                Linecap：线条两端的外观，默认是圆角端点，当线条较粗的时候才看得出效果，如果线条很细，那么你几乎看不出效果了。&#xA;                Linejoin：两个线条的连接点处的外观，默认是“round”，表示圆角。&#xA;                VertexColors：定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值。（如果关于插值不是很明白，可以QQ问我，QQ在前言中你一定能够找到，嘿嘿，虽然没有明确写出）。&#xA;                Fog：定义材质的颜色是否受全局雾效的影响。&#xA;                    uniforms: 传入着色器中的固定变量, 如&#xA;                            {&#xA;                                    scale: {type: &#39;v2&#39;, value: new THREE.Vector2()}&#xA;                            }&#xA;    THREE.MeshBasicMaterial({color: 0x00ff00});                                                        # mesh材质&#xA;MeshBasicMaterial&#xA;    介绍&#xA;            是three.js中最基本的材质&#xA;    功能&#xA;            将mesh渲染成线框模式或平面模式&#xA;                    # 平面模式指表面渲染比较平整&#xA;    api&#xA;            new THREE.MeshBasicMaterial({&#xA;                    color: 0xffaa00, &#xA;                    transparent: true, &#xA;                            # 标志为true时颜色A分量(alpha)才起作用&#xA;                    blending: THREE.AdditiveBlending&#xA;                            # 混合方式, 对应OpenGL ES中不同混合方式。表示怎么与背景结合&#xA;                            ## OpenGL中有一个颜色缓冲区，存放每次渲染的颜色(目标颜色)，新颜色(源颜色)可以与它混合，形成最新的颜色。&#xA;                            ## 可以是THREE.NoBlending = 0&#xA;                            ### 不混合。直接用新颜色覆盖以前的颜色&#xA;                            ## THREE.NormalBlending = 1&#xA;                            ### 将源颜色与目标颜色通过透明度正常混合&#xA;                            ## THREE.AdditiveBlending = 2&#xA;                            ### 加法混合&#xA;                            ## THREE.SubtractiveBlending = 3&#xA;                            ### 减法混合&#xA;                            ## THREE.MultiplyBlending = 4&#xA;                            ### 乘法混合&#xA;                            ## THREE.CustomBlending = 5&#xA;                            ### 自定义混合&#xA;            });&#xA;            new THREE.MeshBasicMaterial({&#xA;                    color: 0xffaa00, &#xA;                    wireframe: true&#xA;            });&#xA;            new THREE.MeshBasicMaterial({&#xA;                    map: texture, &#xA;                    transparent: true&#xA;            });&#xA;&#xA;MeshNormalMaterial&#xA;    只支持以THREE.FlatShading模式来渲染Mesh, 不支持将Mesh渲染为线框模式&#xA;&#xA;MeshLambertMaterial&#xA;    在灰暗或不光滑的表面产生的均匀散射而形成的材质类型。向各个方向均反射光线。如白纸&#xA;&#xA;    new THREE.MeshLambertMaterial({&#xA;            color: 0xff6600,                                # 材质的颜色&#xA;            ambient: 0xff2200,                                # 受环境光情况&#xA;            envMap: textureCube,                                # 环境纹理，会将环境纹理映射到材质身上&#xA;            combine: THREE.MixOperation,                # 与环境材质之间的混合方式&#xA;            reflectivity: 0.3                                        # 对反射光的反射系数&#xA;    })&#xA;    new THREE.MeshLambertMaterial({map:texture, transparent: true})&#xA;            # 带透明的兰伯特材质, 可以看到球体另一边的颜色&#xA;    new THREE.MeshLambertMaterial({color: 0xdddddd, shading: THREE.FlatShading})&#xA;            # 灰色，非平滑&#xA;    new THREE.MeshLambertMaterial({color: 0xdddddd, shading: THREE.SmoothShading})&#xA;            # 灰色，平滑&#xA;    new THREE.MeshLambertMaterial({color: 0x666666, emissive: 0xff0000, ambient: 0x000000, shading: THREE.SmoothShading})&#xA;            # emissive表示自发光&#xA;&#xA;MeshPhongMaterial&#xA;    有明显高光区，适用于湿滑的，表面具有光泽的物体。如: 玻璃，水滴等&#xA;    特点&#xA;            会产生高光(球某一点在光线下特别亮)&#xA;    THREE.MeshPhongMaterial({ambient: 0x030303, color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.FloatShading})&#xA;&#xA;    THREE.MeshPhongMaterial({ambient:0x030303, color:0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.SmoothShading, map: texture, transparent: true})&#xA;&#xA;    THREE.MeshPhongMaterial({color: 0x000000, specular: 0x666666, emissive: 0xff0000, ambient: 0x000000, shininess: 10, shading: THREE.SmoothShading, opacity: 0.9, transparent: true})&#xA;MeshDepthMaterial&#xA;    支持一些尝试测试的效果&#xA;MeshFaceMaterial&#xA;    面材质，它是一个材质数组。&#xA;    有且仅有一个成员数组materials, 用来存放一组材质。&#xA;            这组材质会被geometry的不同面所使用，来做到同一个物体不同面使用不同材质的效果。&#xA;            每一个面使用什么材质由geometry中的索引决定&#xA;ShaderMaterial&#xA;    使用&#xA;            material = new THREE.ShaderMaterial({&#xA;                    uniforms: uniforms,&#xA;                            # 一致变量数组，传递到两个着色器中使用&#xA;                    vertexShader: document.getElementById(&#39;vertexShader&#39;).textContent,&#xA;                            # 顶点着色器的代码&#xA;                    fragmentShader: document.getElementById(&#39;fragmentShader&#39;).textContent&#xA;                            # 片元着色器代码&#xA;            });&#xA;            uniforms = {&#xA;                    time: {type: &#39;f&#39;, value: 1.0},&#xA;                            # 表示时间， f 代表浮点型&#xA;                    resolution: {type: &#39;v2&#39;, value: new THREE.Vector2() }&#xA;                            # 表示浏览器窗口的宽度和高度，v2代表二维向量&#xA;            }                # 该一致变量在绘制过程中不会改变，在顶点shader与片元shader之间用相同名字来共享&#xA;                            ## 一致变量在不同图元中会改变&#xA;            uniforms.resolution.value.x = window.innerWidth&#xA;            uniforms.time.value += 0.005&#xA;                            # 通过value改变uniforms中变量的值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;texture&#34;&gt;&#xA;  texture&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#texture&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;例子&#xA;        var geometry = new THREE.PlaneGeometry( 500, 300, 1, 1 );&#xA;        geometry.vertices[0].uv = new THREE.Vector2(0,0);&#xA;        geometry.vertices[1].uv = new THREE.Vector2(2,0);&#xA;        geometry.vertices[2].uv = new THREE.Vector2(2,2);&#xA;        geometry.vertices[3].uv = new THREE.Vector2(0,2);&#xA;                                        # 平面有4个纹理坐标。由顶点的成员nv表示，nv是一个二维向量，对应到纹理坐标&#xA;&#xA;        var texture = THREE.ImageUtils.loadTexture(&amp;quot;textures/a.jpg&amp;quot;,null,function(t){});&#xA;        var material = new THREE.MeshBasicMaterial({map:texture});&#xA;&#xA;        var mesh = new THREE.Mesh( geometry,material );&#xA;        scene.add( mesh );&#xA;&#xA;例子2(canvas)&#xA;        var geometry = new THREE.CubeGeometry(150, 150, 150);&#xA;        texture = new THREE.Texture(canvas);&#xA;                                        # 默认情况下，纹理被均匀地分配到四边形的各个顶点上。&#xA;        var material = new THREE.MeshBasicMaterial({map: texture});&#xA;        texture.needsUpdate = true;&#xA;                                        # 如果canvas中有动画的话，要设置纹理更新。而且每requestAnimationFrame渲染一帧动画，都要对texture.needsUpdate设置一遍true。如果不更新，显示黑色正方体。&#xA;                                        ## 黑色正方体原因: js异步运行,canvas绘制时钟需要时间, three.js已经开始渲染图形了，这时候canvas没有绘制完成，就显示材质本身的颜色。&#xA;        mesh = new THREE.Mesh(geometry, material);&#xA;        scene.add(mesh);&#xA;Mapping&#xA;    UVMapping&#xA;Filter&#xA;    LinearFilter&#xA;Wrapping&#xA;    RepeatWrapping&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;color&#34;&gt;&#xA;  Color&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#color&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;THREE.Color()&#xA;THREE.Color( 0x444444 );       &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;vector3&#34;&gt;&#xA;  Vector3&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#vector3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;THREE.Vecotor3(4,8,9);                                                                        &#xA;THREE.Vector3();&#xA;point1.set(4,8,9);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;quaternion&#34;&gt;&#xA;  Quaternion&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#quaternion&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍　&#xA;        四元组&#xA;api&#xA;        THREE.Quaternion = function(x, y, z, w){&#xA;                this._x = x || 0;&#xA;                this._y = y || 0;&#xA;                this._z = z || 0;&#xA;                this._w = (w !== undefined) ? w : 1;&#xA;        }&#xA;        setFromAxisAngle: function(axis, angle)&#xA;                # Quaternion的静态方法&#xA;                ## axis是向量，表示轴, angle表示弧度&#xA;                ## 返回一个四元组&#xA;        setFromEuler: function(euler, update)&#xA;                # 欧拉角转为四元组&#xA;        setFromRotationMatrix: function(m)&#xA;                # 把矩阵转为欧拉角&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;fog&#34;&gt;&#xA;  fog&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fog&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;scene.fog = new THREE.Fog(0x999999, 0.1, 8000);&#xA;THREE.Fog = function(hex, near, far)&#xA;    # hex为颜色, near是雾开始的地方, far是雾结束的地方&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;object3d&#34;&gt;&#xA;  Object3D&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#object3d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;new THREE.Object3D();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;ray&#34;&gt;&#xA;  Ray&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ray&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        一条射线&#xA;&#xA;ray = new THREE.Ray(camera.position);&#xA;        # 传入起点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;particle&#34;&gt;&#xA;  particle&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#particle&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;particleSystem = new THREE.ParticleSystem(particles, material);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;utils&#34;&gt;&#xA;  utils&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#utils&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;ImageUtils&#xA;    loadTextureCube([&amp;quot;&amp;quot;, &amp;quot;&amp;quot;]);&#xA;ShaderUtils&#xA;    var shader = lib[&amp;quot;cube&amp;quot;]&#xA;UniformsUtils&#xA;    clone(shader.uniforms)&#xA;GeometryUtils&#xA;    merge = function(geometry1, object2/* mesh | geometry */){ ... }&#xA;        # geometry1是合成后的对象，第二个是要合并的对象，如果是mesh，就取mesh中的geometry对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;filter&#34;&gt;&#xA;  filter&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#filter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;LinearFilter&#xA;NearestFilter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;effect&#34;&gt;&#xA;  effect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#effect&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;BloomEffect&#xA;    postBloom = new BloomEffect(renderer, renderTarget, window.innerWidth, window.innerHeight, 4);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;helper&#34;&gt;&#xA;  helper&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#helper&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 辅助对象一键打开或关闭&#xA;        # 将所有辅助对象放到helps数组中&#xA;    var help = [];&#xA;    helps.push(helper);&#xA;    helps.push(faceNormalsHelper);&#xA;    helps.push(vertexNormalsHelper);&#xA;&#xA;    window.addEventListener(&#39;keydown&#39;, onKeyDown, false);&#xA;&#xA;    function setVisible(visible){&#xA;            for(var i = 0; i &amp;lt; helps.length; i++){&#xA;                    helps[i].visible = visible;&#xA;            }&#xA;    }&#xA;&#xA;    function onKeyDown(event){&#xA;            switch(event.keyCode){&#xA;                    case 65: /*A*/&#xA;                            setVisible(false);&#xA;                            break;&#xA;                    case 83: /*S*/&#xA;                            setVisible(true);&#xA;                            break;&#xA;            }&#xA;    }&#xA;GridHelper&#xA;    介绍&#xA;            网格辅助类, 绘制网格和网格线颜色&#xA;&#xA;    api&#xA;            THREE.GridHelper = function(size, step)&#xA;                    # size定义网格正方形边长, step是间隔距离&#xA;    使用&#xA;            var helper = new THREE.GridHelper(200, 10);&#xA;            helper.setColors(0x0000ff, 0x808080);&#xA;                    # 第一个是x y z轴颜色, 第二个是其它线条颜色&#xA;            helper.position.y = -150;&#xA;            scene.add(helper);&#xA;BoxHelper&#xA;    介绍&#xA;            长方体包围盒, 椭圆包围盒, 包围物体用于检查碰撞或辅助设计中表示选中&#xA;&#xA;    使用&#xA;            var boxHelper = new THREE.BoxHelper(mesh);&#xA;            scene.add(boxHelper);&#xA;FaceNormalsHelper&#xA;    介绍&#xA;            辅助画法线&#xA;&#xA;    api&#xA;            FaceNormalsHelper(object, size, hex, linewidth)&#xA;&#xA;    使用&#xA;            var faceNormalsHelper = new THREE.FaceNormalsHelper(mesh, 10)&#xA;VertexNormalsHelper&#xA;    介绍&#xA;            辅助画顶点法线&#xA;WireframeHelper&#xA;    介绍&#xA;            将模型转换为线框图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;物件&#34;&gt;&#xA;  物件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%a9%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Mirror&#xA;    介绍&#xA;            模拟一个镜子, 放在那, 就反射它前面的景物&#xA;            原理是一个平面, 上面的材质不断变化&#xA;&#xA;    o-&amp;gt; api&#xA;    THREE.Mirror = function(renderer, camera options)&#xA;            renderer是渲染器&#xA;            camera最好是透视相机&#xA;            options&#xA;                    textureWidth&#xA;                    textureHeight&#xA;                    clipBias&#xA;                    color&#xA;                    debugMode&#xA;    o-&amp;gt; 使用&#xA;    var planeGeo = new THREE.PlanneGeometry(100.1, 100.1);&#xA;            # 定义平面&#xA;    groundMirror = new THREE.Mirror(&#xA;            # 定义镜面&#xA;            renderer,&#xA;            camera,&#xA;            {clipBias: 0.003,&#xA;            textureWidth: WIDTH,&#xA;            textureHeight: HEIGHT,&#xA;                    # 表示内存中生成纹理的大小, 最好和屏幕一样大, 否则有mosaic&#xA;            debugMode: true}&#xA;                    # 开启调试模式会有辅助线&#xA;    );&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;animationhandler&#34;&gt;&#xA;  AnimationHandler&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#animationhandler&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        主要负责动画的插值和播放&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;shader&#34;&gt;&#xA;  shader&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shader&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;EffectComposer&#xA;    介绍&#xA;            用于渲染复杂效果, 例如将一个场景作为纹理传入, 例如用着色器将场景某部分模糊或发光处理&#xA;            原理是将画面在一个临时缓冲区先画出来,再将大量效果组合. 一般是用着色器来实现&#xA;&#xA;    使用&#xA;            composer = new THREE.EffectComposer(render);&#xA;                    # 可以是WEBGLRenderer或CanvasRenderer&#xA;                    ## 第二个参数是renderTarget(渲染目标), 没有时默认生成一个&#xA;                    ### renderTarget是gpu的内部对象,用来暂存绘制结果&#xA;            composer.addPass(new THREE.RenderPass(scene, camera));&#xA;                    # 第一个效果通常是RenderPass, 它将渲染结果放入效果链中&#xA;                    ## 将结果渲染到gpu的一个帧缓冲区(临时内存)&#xA;                    ## pass中有enable成员变量, 只有为true时该pass才起作用&#xA;            var effect = new THREE.ShaderPass(THREE.DotScreenShader);&#xA;                    # DotScreenShader是examples/js/shaders中的一个&#xA;                    ## 它定义了一些一致变量, 每个帧循环操作它们来控制渲染效果&#xA;            effect.uniforms[&#39;scale&#39;].value = 4;&#xA;            composer.addPass(effect);&#xA;            var effect = new THREE.ShaderPass(THREE.RGBShiftShader);&#xA;            effect.uniforms[&#39;amount&#39;].value = 0.0015;&#xA;            effect.renderToScreen = true;&#xA;            composer.addPass(effect);&#xA;                    # 通过addPass加效果到效果链passes中&#xA;                    ## 添加顺序重要,后一个效果会作用于前一个效果&#xA;            composer.render()&#xA;                    # 用它替换render.render(scene, camera)&#xA;                    ## 遍历所有通道, 可以传入参数delta, 表示帧与帧之间渡过的时间&#xA;    api&#xA;        方法&#xA;                insertPass(pass, index)&#xA;                        # 将某一个通道插入指定的位置&#xA;                &#xA;        对象&#xA;                WebGLRenderTarget(width, height, options)&#xA;                        # width是缓冲区的宽度, height是缓冲区的高度, options是参数&#xA;                RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha)&#xA;                        # overrideMaterial表示一种材质, 它会覆盖先前设置的材质&#xA;                        # clearColor表示每一次帧缓冲绘制前的底色. 用于清除上一次绘制结果&#xA;                        # clearAlpha是0或1, 表示清除透明色&#xA;                        ## this.enabled属性表示是否启用该pass&#xA;                        方法&#xA;                                render(renderer, writeBuffer, readBuffer, delta)&#xA;                DotScreenShader&#xA;                        # 点阵屏效果, 就是报纸中点阵的印刷效果&#xA;                RGBShiftShader&#xA;                        # 变化颜色分量RGBA, 如A点的R值不显示, 而取B点的R值&#xA;                        ## angle表示偏移角度&#xA;                        ## amount表示AB的长度. 由于纹理坐标为0到1, 所以0.005会有很多像素&#xA;                BloomPass(n)&#xA;                        # 像素点膨胀模糊, 像墨水渗出&#xA;                        # n 是模糊的程度&#xA;                FilmPass(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale)&#xA;                        # 依赖FilmShader.js. 整个场景灰白, 或像lcd荧光屏在屏幕上看到线条等屏幕效果&#xA;                        ## noiseIntensity 表示杂点的密度, 值越大杂点越多&#xA;                        ## scanlinesIntensity 是扫描线的密度, 值越大扫描线透明度越小&#xA;                        ## scanlinesCount 扫描线的数量&#xA;                        ## grayscale 如果true表示黑白显示&#xA;                        var effectFilm = new THREE.FilmPass(0.35, 0.75, 2048, false);&#xA;                        effectFilm.renderToScreen = true;&#xA;                        composer.addPass(effectFilm);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;projector&#34;&gt;&#xA;  projector&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#projector&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        包含各种矩阵&#xA;        提供重要且简单的函数，进行二维和三维之间的转换&#xA;&#xA;函数&#xA;        this.unprojectVector = function(vector, camera)&#xA;                # 归一化空间中的点&#xA;                ## 归一化是将(-1, -1, -1)到(1, 1, 1)中的某个点还原成三维中的某个点&#xA;                # vector是需要归一化的那个点，要归一化成(-1, -1)到(1, 1)空间的点&#xA;                ## z 是没有意义的，通常设置为1&#xA;                # camera是当前相机，有了相机才能计算当前投影。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;扩展&#34;&gt;&#xA;  扩展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%a9%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;性能&#34;&gt;&#xA;  性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;statsjs&#34;&gt;&#xA;  stats.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#statsjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;官网&#xA;        https://github.com/mrdoob/stats.js &#xA;视图                        # 点击切换&#xA;        fps                # 上一秒的帧数&#xA;        ms                # 一帧的毫秒数&#xA;使用&#xA;        引入stats.js文件&#xA;        init中&#xA;                var stats = new Stats();&#xA;                stats.setMode(1); // 0: fps, 1: ms&#xA;                // 将stats的界面对应左上角&#xA;                stats.domElement.style.position = &#39;absolute&#39;;&#xA;                stats.domElement.style.left = &#39;0px&#39;;&#xA;                stats.domElement.style.top = &#39;0px&#39;;&#xA;                document.body.appendChild( stats.domElement );&#xA;        treeStart中&#xA;                setInterval( function () {&#xA;                    stats.begin();&#xA;                    // 你的每一帧的代码&#xA;                    stats.end();&#xA;                }, 1000 / 60 );&#xA;        &#xA;        或&#xA;        init中&#xA;                stats = new Stats();&#xA;                stats.domElement.style.position = &#39;absolute&#39;;&#xA;                stats.domElement.style.left = &#39;0px&#39;;&#xA;                stats.domElement.style.top = &#39;0px&#39;;&#xA;        animation中&#xA;                stats.update();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;动画引擎&#34;&gt;&#xA;  动画引擎&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e7%94%bb%e5%bc%95%e6%93%8e&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;tweenjs&#34;&gt;&#xA;  tween.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tweenjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;官网&#xA;        https://github.com/sole&#xA;介绍&#xA;        开源的缓动类&#xA;使用&#xA;        引入tween.js&#xA;        &#xA;        initObject之后调用&#xA;                function initTween()&#xA;                {&#xA;                    new TWEEN.Tween( mesh.position)&#xA;                            .to( { x: -400 }, 3000 ).repeat( Infinity ).start();&#xA;                }&#xA;        animation中&#xA;                requestAnimationFrame(animation);&#xA;                    TWEEN.update();&#xA;使用2(雾的far的缓动)&#xA;        scene.tween = new TWEEN.Tween(scene.fog, false)&#xA;                # 对scene.fog的属性进行操作&#xA;                .to({far: 1500}, 6000)&#xA;                        # 在6秒种内将scene.fog.far变为1500&#xA;                .easing(TWEEN.Easing.Sinusoidal.EaseOut)&#xA;                .delay(6000)&#xA;                        # 缓动在调用start()后，等待6秒执行&#xA;                .onComplete(function(){&#xA;                        # 缓动执行完成后(far= 1500后)的回调函数&#xA;                }).start();&#xA;        &#xA;        scene.tweenBack = new TWEEN.Tween(scene.fog, false)&#xA;                .delay(2000)&#xA;                .to({far: 15000}, 10000)&#xA;                .easing(TWEEN.Easing.Sinusoidal.EaseOut);&#xA;&#xA;        scene.tween.chain(scene.tweenBack);&#xA;&#xA;使用3(相机的左右[-500, 500]摇动)&#xA;                # 缓动链&#xA;        camera.tween = new TWEEN.Tween(camera.position, false)&#xA;                .to({x: 500}, 6000)&#xA;                .easing(TWEEN.Easing.Sinusoidal.EaseInOut)&#xA;                .start();&#xA;&#xA;        camera.tweenBack = new TWEEN.Tween(camera.position, false)&#xA;                .easing(TWEEN.Easing.Sinusoidal.EaseInOut)&#xA;                .to({x: -500}, 6000)&#xA;&#xA;        camera.tween.chain(camera.tweenBack);&#xA;        camera.tweenBack.chain(camera.tween);&#xA;                # 两个动画彼此加入了自己的缓动链中，两个动画可以交替执行&#xA;TWEEN.Easing&#xA;    TWEEN.Easing.Sinusoidal.EaseOut&#xA;            # Sinusoidal是正弦曲线的缓动&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;loader&#34;&gt;&#xA;  Loader&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#loader&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;VTKLoader&#xA;    var loader = new THREE.VTKLoader();&#xA;    loader.addEventListener(&#39;load&#39;, function(event){&#xA;            var geometry = event.content;&#xA;            var mesh = new THREE.Mesh(geometry, material);&#xA;            mesh.position.setY( - 0.09);&#xA;            scene.add(mesh);&#xA;    });&#xA;    loader.load(&amp;quot;models/vtk/bunny.vtk&amp;quot;);&#xA;JSONLoader&#xA;    THREE.JSONLoader.prototype.load = functiono(url, callback, texturePath)&#xA;        # url是json文件的地址&#xA;        # callback在异步加载完后执行&#xA;        # texturePath 纹理路径，没有这个参数时，在当前路径下寻找默认纹理。&#xA;BinaryLoader&#xA;    使用&#xA;            var loader = new THREE.BinaryLoader(true);&#xA;            document.body.appendChild(loader.statusDomElement);&#xA;                    # 实时显示加载进度&#xA;&#xA;    THREE.BinaryLoader = function(showStatus){&#xA;            THREE.Loader.call(this, showStatus);&#xA;                    # showStatus表示是否显示进度条&#xA;    }&#xA;    THREE.BinaryLoader.prototype.load = function(url, callback, texturePath, binaryPath)&#xA;            # url是js文件的路径&#xA;            # callback 当url中数据加载完成后调用。callback中接收geometry作为参数&#xA;            # texturePath 纹理路径，不指定默认放在url同文件夹下，或无纹理。&#xA;            # binaryPath 二进制文件的路径，不指定时，根据url地址中的文件来加载。&#xA;&#xA;ColladaLoader&#xA;UTF8Loader&#xA;    介绍&#xA;            导入 google WebGL-Loader格式的高压缩文件&#xA;SceneLoader&#xA;    介绍&#xA;            导入各物体、变换层级、材质、纹理、相机、光源的统一js文件，其中有其它js的url引用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;controls&#34;&gt;&#xA;  Controls&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#controls&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;见Camara&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;detector&#34;&gt;&#xA;  Detector&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#detector&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;if(! Detector.webgl) Detector.addGetWebGLMessage();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;convert_obj_three.py&#xA;    介绍&#xA;            转换obj文件为three.js二进制文件&#xA;&#xA;    python convert_boj_three.py -i alien2.obj -o alien2_bin.js -t binary&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;着色器&#34;&gt;&#xA;  着色器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9d%80%e8%89%b2%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        一种二进制码，在绘制场景之前做一些事。操作在显卡中进行&#xA;        对每一个顶点或者片元执行一次着色器，这个操作并行执行&#xA;        浏览器底层只支持着色器&#xA;        three.js底层是着色器实现的，所以着色器能实现一些three.js无法实现的功能，并能提高three.js的性能&#xA;优势与性能&#xA;        1. 处理大量数据能力。顶点着色器为每一个顶点确定位置，片元着色器为每个片元确定颜色，数据量非常庞大&#xA;                # 一个3d游戏中，一帧几十万个三角形。显示器分辨率1280x1024, 有1310720个像素，每一帧由片元着色器处理。&#xA;                ## 每个顶点位置与每个片元颜色几乎同时计算完成&#xA;webgl着色器分类&#xA;        # 无论在opengl, openes, dx中，都分为顶点着色器和片元着色器&#xA;        顶点着色器&#xA;                对顶点进行操作，如&#xA;                                改变顶点的位置和大小&#xA;        片元着色器&#xA;                定义屏幕中各点的颜色&#xA;                顶点之间的颜色也被一起处理了(插值)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;顶点着色器&#34;&gt;&#xA;  顶点着色器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a1%b6%e7%82%b9%e7%9d%80%e8%89%b2%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        接收三维点坐标，处理为二维坐标并输出&#xA;        THREE.ShaderMaterial用来定义着色器，着色器材质用着色器程序去控制几何体的顶点和颜色&#xA;内置变量&#xA;        gl_Position&#xA;three.js注入变量&#xA;        postion&#xA;                # gl_Position = vec4(position, 1.0);&#xA;        uv&#xA;使用&#xA;        &amp;lt;script id=&amp;quot;vertexShader&amp;quot; type=&amp;quot;x-shader/x-vertex&amp;quot;&amp;gt;&#xA;                # type只是通用标记为顶点着色器, 不起作用&#xA;                void main(){&#xA;                        # 类似c语言, 着色器有一个main函数&#xA;                        ## 每个顶点在计算时，都会执行main函数&#xA;                        gl_Position = vec4(position, 1.0);&#xA;                                # 将计算顶点最终位置的结果放在gl_Position中&#xA;                                ## 这个位置被称为设备归一化坐标&#xA;                                ## gl_Position是默认变量，不必声明就可用，gl_Position一定要赋值&#xA;                                ## 顶点着色器最主要作用就是给gl_Position赋值&#xA;                                # 作用:&#xA;                                ## gl_Position 是相机投影之后的坐标&#xA;                                ## 顶点的位置传给position, 通过我们变换, 再赋值给gl_Position&#xA;                                ## position中的值来源如mesh.vertices.push(new THREE.Vector3(x, -y, 0))&#xA;                }&#xA;        &amp;lt;/script&amp;gt;&#xA;例子&#xA;    void main(){&#xA;            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);&#xA;    }                # projectionMatrix是投影矩阵，modelViewMatrix是模型视图矩阵&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;片元着色器&#34;&gt;&#xA;  片元着色器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%87%e5%85%83%e7%9d%80%e8%89%b2%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        一个片元对应一个像素，对其输出一个颜色值。&#xA;                # 将顶点着色器输出的二维点坐标转化为待处理的像素并传递给片元着色器的过程，称为图元光栅化&#xA;        颜色会受到光照, 阴影等影响, 所以片元着色器大多处理这些物理效果&#xA;&#xA;内置变量&#xA;        gl_FragColor&#xA;                #  输出的一个像素的颜色, vec4类型, 红 绿 蓝 透明&#xA;        gl_FragCoord&#xA;                #只读变量,保存了片元相对窗口的坐标位置&#xA;                ## x, y, z, 1/w   其中z表示片元深度, z越大越深&#xA;&#xA;输入&#xA;        varying0, varying1, .... , varyingn&#xA;                #用户自定义的易变变量&#xA;        uniforms&#xA;                # 一致变量. 在js, 顶点着色器, 片元着色器中传递数据, 一次渲染中数据不变&#xA;        临时变量&#xA;&#xA;        gl_Position&#xA;                # 当前片段(像素)的位置&#xA;        gl_FrontFacing&#xA;                # 表示每个顶点的大小&#xA;        gl_PointSize&#xA;                # 当前片段来自三角形的正面还是背面. 该变量只是为了节省性能&#xA;        采样器&#xA;&#xA;使用&#xA;        &amp;lt;script id=&amp;quot;fragmentShader&amp;quot; type=&amp;quot;x-shader/x-fragment&amp;quot;&amp;gt;&#xA;                void main(){&#xA;                        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);&#xA;                                ＃ 表示片元颜色，是RGBA&#xA;                }&#xA;        &amp;lt;/script&amp;gt;&#xA;例子&#xA;    uniform vec2 resolution;&#xA;    uniform float time;&#xA;    float a = 1.0, b = 1.0, c = 1.0;&#xA;    float t;&#xA;    void main (){&#xA;            t = time;&#xA;            a = abs(sin(t));&#xA;            b = abs(cos(t));&#xA;            c = abs(sin(t) * cos(t));&#xA;            gl_FragColor = vec4(vec3(a, b, c), 1.0);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;变量&#34;&gt;&#xA;  变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;变量分类&#xA;        attributes(属性变量)                        # 保存顶点独有数据，如顶点的位置&#xA;                attributes vec3 pos;&#xA;        uniform(一致变量)                                # 一帧渲染过程中保持不变，如光照方向&#xA;                uniform vec3 a;&#xA;        varying(易变变量)                                # 比较容易变化的变量，用来在顶点着色器与片元着色器之间传递数据&#xA;                varying vec3 a;&#xA;类型&#xA;        vec2&#xA;                # 二维变量&#xA;        vec3&#xA;                # 三维变量&#xA;        vec4&#xA;        mat4&#xA;        sampler2D&#xA;        float&#xA;传递关系&#xA;        attribute        -&amp;gt;        顶点着色器        -&amp;gt;        varying        -&amp;gt;        图元光栅化        -&amp;gt;        varying        -&amp;gt;        片元着色器        -&amp;gt;        gl_FragColor&#xA;        uniform        -&amp;gt;        顶点着色器        -&amp;gt;        gl_Position        -&amp;gt;        图元光栅化        -&amp;gt;        gl_Position        -&amp;gt;        片元着色器        -&amp;gt;        gl_FragColor&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;思路&#34;&gt;&#xA;  思路&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;animate动画&#34;&gt;&#xA;  animate动画&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#animate%e5%8a%a8%e7%94%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;window.requestAnimationFrame(callback)&#xA;        # 返回id, 传给window.cancelAnimationFrame()取消该次动画&#xA;        ## 原理&#xA;        ### 传递浏览器回调函数，浏览器调用它更新画面。&#xA;        #### 与setInterval()不同之处在于自动控制了时间。对方法调用进行了优化。页面失去选中时动画自动暂停。&#xA;        ### 回调函数中　调用了requestAnimation(callback)来循环调用&#xA;        ### 通常执行callback函数来开始动画&#xA;        # 最原始的是window.setTimout()或者window.setInterval()来更新元素的位置&#xA;        ## 更新频率要达到每秒60次&#xA;animation&#xA;    function threeStart() {&#xA;                initThree();&#xA;                initCamera();&#xA;                initScene();&#xA;                initLight();&#xA;                initObject();&#xA;                animation();&#xA;&#xA;            }&#xA;    function animation() {&#xA;                //rend＋                                                                                                                                                                                                                erer.clear();&#xA;                camera.position.x = camera.position.x + 1;&#xA;                renderer.render(scene, camera);&#xA;                requestAnimationFrame(animation);&#xA;            }&#xA;    或&#xA;    function animation()&#xA;                {&#xA;                    mesh.position.x-=1;&#xA;                    renderer.render(scene, camera);&#xA;                    requestAnimationFrame(animation);&#xA;                }&#xA;render&#xA;    function animate(){&#xA;            for(var i = 0; i &amp;lt; apps.length; ++i){&#xA;                    apps[i].animate();&#xA;            }&#xA;            requestAnimationFrame(animate);&#xA;    }&#xA;    function App(...){&#xA;            this.animate = function(){&#xA;                    render();&#xA;                    stats.update();&#xA;            }&#xA;            function render(){&#xA;                    camera.position.x += (mouseX - camera.position.x) * 0.05;&#xA;                    camera.position.y += (-mouseY - camera.position.y) * 0.05;&#xA;                            # 相机位置随鼠标移动&#xA;                            ## mouseX, mouseY为自定义的全局变量&#xA;                    camera.lookAt(scene.postion);&#xA;                    renderer.render(scene, camera);&#xA;            }&#xA;    }&#xA;render计算&#xA;    var mouseX = 0, mouseY = 0;&#xA;    document.addEventListener(&#39;mousemove&#39;, onDocumentMouseMove, false);&#xA;    function onDocumentMouseMove(event){&#xA;            mouseX = (event.clientX - windowHalfX);&#xA;            mouseY = (event.clientY - windowHalfY);&#xA;    }&#xA;相机旋转&#xA;    围绕y轴, 半径1000的圆作圆周运动。&#xA;            var timer = 0.0001 * Date.now();&#xA;                    # 用当前时间作弧度&#xA;            camera.position.x = Math.cos(timer) * 1000;&#xA;            camera.position.z = Math.sin(timer) * 1000;&#xA;            camera.lookAt(scene.position);&#xA;自发光变化&#xA;    material.emissive.setHSV(0.54, 1, 0.7 * (0.5 + 0.5 * Math.sin(35 * timer)));&#xA;引擎&#xA;    组成&#xA;            定义与初始化相机&#xA;            定义与初始化场景&#xA;            定义与初始化光&#xA;            定义与初始化渲染器&#xA;            定义与初始化性能监视器&#xA;            定义鼠标事件, 窗口缩放事件&#xA;                    ele.addEventListener(&#39;mousedown&#39;, ...)&#xA;                    ele.addEventListener(&#39;mouseup&#39;, ...)&#xA;                    ele.addEventListener(&#39;mousemove&#39;, ...)&#xA;                    window.addEventListener(&#39;resize&#39;, ...)&#xA;            播放音乐&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;结构&#34;&gt;&#xA;  结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;定义App类&#xA;    App类将相机，视图，灯光等场景代码封装，为了场景的代码的重用&#xA;            # 场景重新new&#xA;    例子1, 视口app&#xA;            function App( containerId, fullWidth, fullHeight, viewX, viewY, viewWidth, viewHeight )&#xA;对象池&#xA;    介绍&#xA;            用过的对象保存起来，下次需要时重复使用。&#xA;            减少频繁创建对象所造成的内存开销和cpu开销&#xA;    自定义ObjectPool.js&#xA;            function ObjectPool(){&#xA;                    this.pool = new Array();&#xA;                    this.avail = new Array();&#xA;                            # 可用在pool中的索引，pool中对象不在使用，待再利用时放入avail中&#xA;            }&#xA;            ObjectPool.prototype.createObject = function(){&#xA;                    return new Object();&#xA;            }&#xA;                    #  创建一个多态的对象(如一个豆径)，需要重载,&#xA;            ObjectPool.prototype.returnObject = function(poolId){&#xA;                    this.avail.push(poolId);&#xA;            }&#xA;                    # 标记为可再利用&#xA;            ObjectPool.prototype.getObject = function(){&#xA;                    if(this.avail.length ==0){&#xA;                            var o = this.createObject();&#xA;                            o.poolId = this.pool.length;&#xA;                            this.pool.push(o);&#xA;                            this.avail.push(o.poolId);&#xA;                    }&#xA;                    var poolId = this.avail.pop();&#xA;                    return this.pool[poolId];&#xA;            }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;控制&#34;&gt;&#xA;  控制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;resize&#xA;    window.addEventListener( &#39;resize&#39;, onWindowResize, false );&#xA;&#xA;    function onWindowResize( event ) {&#xA;            SCREEN_WIDTH = window.innerWidth;&#xA;            SCREEN_HEIGHT = window.innerHeight;&#xA;&#xA;            renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );&#xA;            camera.aspect = 0.5 * SCREEN_WIDTH / SCREEN_HEIGHT;&#xA;            camera.updateProjectionMatrix();&#xA;                    # 产生透视投影矩阵&#xA;    }&#xA;鼠标射线&#xA;    mouse = new THREE.Vector3(0, 0, 1);&#xA;    projector = new THREE.Projector();&#xA;    ray = new THREE.Ray(camera.position);&#xA;&#xA;    function onDocumentMouseMove(event){&#xA;            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;&#xA;            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;&#xA;                    # 取得鼠标的位置，并将其转换为-1到1之间(归一化)&#xA;            ray.direction = projector.unprojectVector(mouse.clone(), camera);&#xA;                    # 得到当前鼠标指向二维的点在程序三维中的位置&#xA;            ray.direction.subSelf(camera.position).normalize();&#xA;                    # 鼠标所在的点送去相机所在的点，得到相机指向鼠标所在点的向量并规范化&#xA;            intersects = ray.intersectObject(plane);&#xA;                    # 计算射线与模型的相交点数组&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;场景&#34;&gt;&#xA;  场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;天空盒&#xA;    两种实现&#xA;            立方体内部贴纹理&#xA;            椭球内部贴纹理&#xA;    立方体天空盒&#xA;            var r = &#39;textures/cube/Bridge2&#39;;&#xA;            var urls = [r + &#39;posx.jpg&#39;, r + &#39;negx.jpg&#39;, r + &#39;posy.jpg&#39;, r + &#39;negy.jpg&#39;, r + &#39;posz.jpg&#39;, r + &#39;negz.jpg&#39;];&#xA;            var textureCube = THREE.ImageUtils.loadTextureCube(urls);&#xA;            textureCube.format = THREE.RGBFormat;&#xA;                    # 设置图片格式，此格式不需要透明度。节约内存又加快渲染速度&#xA;            var shader = THREE.ShaderLib[&#39;cube&#39;];&#xA;                    # ShaderLib与three.js引擎的一个数组, 其中的cube存放的是立方体贴图的shader&#xA;            shader.uniforms[&#39;tCube&#39;].value = textureCube;&#xA;                    # 纹理给shader着色器&#xA;            var material = new THREE.ShaderMaterial({&#xA;                    fragmentShader: shader.fragmentShader,&#xA;                    vertexShader: shader.vertexShader,&#xA;                    uniforms: shader.uniforms,&#xA;                    depthWrite: false,&#xA;                    side: THREE.BackSide&#xA;            });        # 用ShaderMaterial材质包装shader&#xA;            mesh = new THREE.Mesh(new THREE.CubeGeometry(100, 100, 100), 22, material);&#xA;            sceneCube.add(mesh);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;性能-1&#34;&gt;&#xA;  性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;概要&#xA;        3d设计的精髓在于性能优化&#xA;        使用连续内存(如数组)将加速程序运行，不连续内存将增加读取时寻址的时间。&#xA;使用&#xA;    $(document).ready(&#xA;            function(){&#xA;                    var container = document.getElementById(&amp;quot;container&amp;quot;);&#xA;                    var app = new MineCraftApp();&#xA;                    app.init({container: container});&#xA;                            # container属性 表示最后渲染结果外层的div&#xA;                    app.run();&#xA;            }&#xA;    );&#xA;App&#xA;    介绍&#xA;            封装了three.js的一些基本操作, 如&#xA;                    创建渲染场景&#xA;                    创建相机&#xA;                    控制画布缩放&#xA;                    鼠标输入&#xA;            对three.js进行了面向对象的封装，可以面向对象编程&#xA;    函数&#xA;            prototype.init(param)&#xA;                    # 初始化&#xA;                    ## 参数是一个键值对对象&#xA;                    ## 一个WebGLRenderer渲染器&#xA;                    ## 一个场景 THREE.Scene()&#xA;                    ## 一个透视投影 THREE.PerspectiveCamera&#xA;                    ## 一个投影器 THREE.Projector()&#xA;                    ## 一些鼠标键盘的操作&#xA;            prototype.run = function(){&#xA;                    # 是渲染循环，会不断被调用&#xA;                    ## 调用每一个Sim.Object的update&#xA;                    this.update();&#xA;                    this.renderer.render(this.scene, this.camera);&#xA;                    var that = this;&#xA;                    requestAnimationFrame(function(){that.run(); });&#xA;                            # run的帧循环&#xA;            }&#xA;                    &#xA;            prototype.addObject&#xA;                    # 将Sim.Object对象加入场景中&#xA;            prototype.removeObject&#xA;                    # 将Sim.Object对象从场景移出&#xA;&#xA;    属性&#xA;            renderer&#xA;            scene&#xA;            camera&#xA;            objects&#xA;                    # 场景中的所有可视对象&#xA;Publisher&#xA;    介绍&#xA;            一个事件驱动模型&#xA;            Sim.Publisher用于&#xA;                    记录事件&#xA;                    发送事件&#xA;                    处理事件&#xA;            当事件发生时，它遍历注册的回调列表，调用每一个注册的函数&#xA;    函数&#xA;            prototype.subscribe = function(message, subscriber, callback)&#xA;                    # 发起订阅&#xA;                    ## message表示事件名&#xA;                    ## 放callback函数的类&#xA;                    ## 事件发生时的执行回调函数&#xA;            prototype.unsubscribe = function(message, subscriber, callback)&#xA;                    # 取消订阅, 删除MessageTypes数组中事件名对就的链表中的一节点&#xA;                    ## message值为null, false, undefined时表示删除整个链表(不删除事件)&#xA;            prototype.publish = function(message)&#xA;                    # 触发事件&#xA;    属性&#xA;            MessageTypes&#xA;                    # 事件与其处理函数的集合&#xA;                    ## 形如 messageType[&#39;remove&#39;] = [subscriber, callback] -&amp;gt; [subscriber, callback]&#xA;                    ### &#39;remove&#39;是事件名, subscriber是订阅者, callback是订阅者该事件的回调方法&#xA;                    ### -&amp;gt; 是链表的意思&#xA;Object&#xA;    介绍&#xA;            sim.js所有封装类的基类, 派生于Sim.Publisher&#xA;            可以表示大多数对象(自定义的对象派生于它)&#xA;    方法&#xA;            prototype.setPosition&#xA;                    # 设置object3D对象的位置&#xA;            prototype.setScale&#xA;            prototype.setVisible&#xA;            prototype.update&#xA;                    # 更新该对象和它的children&#xA;                    ## 在每一次渲染循环时调用,用来产生自己的动画&#xA;            prototype.addChild&#xA;                    # 添加子对象, 如汽车添加轮子&#xA;            prototype.removeChild&#xA;    属性&#xA;            object3D&#xA;                    # 用于保存three.js中的Object3D对象&#xA;            children&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;框架&#34;&gt;&#xA;  框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;sim&#34;&gt;&#xA;  sim&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sim&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    封装three.js大量重复工作&#xA;            如设置渲染器，循环重绘，向场景添加Mesh等&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;physijs&#34;&gt;&#xA;  physi.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#physijs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        基于three.js上构建的物理引擎&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;voxeljs&#34;&gt;&#xA;  voxel.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#voxeljs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        像素方块游戏开发(minecraft)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;例子来自webgl中文网&#34;&gt;&#xA;  例子(来自webgl中文网)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%8b%e5%ad%90%e6%9d%a5%e8%87%aawebgl%e4%b8%ad%e6%96%87%e7%bd%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;16万个三角形&#34;&gt;&#xA;  16万个三角形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#16%e4%b8%87%e4%b8%aa%e4%b8%89%e8%a7%92%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;定义&#xA;        o-&amp;gt; triangles = 160000&#xA;        o-&amp;gt; 每个三角形有３个顶点, 一个顶点三个float表示，共triangles * 3 * 3个float&#xA;                # 用数组存放&#xA;        o-&amp;gt; 每个顶点一个法向量，一个三角形３个法向量&#xA;&#xA;赋值&#xA;        o-&amp;gt; 所有三角形顶点应该在一个以原点为中心的正方体内&#xA;        o-&amp;gt; 三角形的位置在正方体内随机分布&#xA;实现&#xA;        var geometry = new THREE.BufferGeometry();&#xA;        geometry.attributes = {&#xA;                        index:{&#xA;                                itemSize: 1,&#xA;                                array: new Uint16Array(triangles * 3),&#xA;                                numItems: triangles * 3&#xA;                        },&#xA;                                # 索引&#xA;                                ## 每一个数组元素的聚会范围是[0, 65535],如果顶点数超过65535,必须通过geometry的offset成员来进一步设置偏移量。&#xA;                                ### 65535是16位整型&#xA;                        position: {&#xA;                                itemSize: 3,&#xA;                                array: new Float32Array(triangles * 3 * 3),&#xA;                                numItems: triangles * 3 * 3&#xA;                        },&#xA;                                # 位置&#xA;                        normal:{&#xA;                                itemSize: 3,&#xA;                                array: new Float32Array(triangle * 3 * 3),&#xA;                                numItems: triangles * 3 * 3&#xA;                        },&#xA;                                # 法线&#xA;                        color: {&#xA;                                itemSize: 3,&#xA;                                        # 一项目(元)由几个字节组成&#xA;                                array: new Float32Array(triangles * 3 * 3),&#xA;                                        # 实际存项目的内存数组&#xA;                                numItems: triangles * 3 * 3&#xA;                                        # 有多少个项目&#xA;                        }&#xA;                                # 颜色&#xA;                }&#xA;                        # Uint16Array分配指定个数的16位无符号整数，寝值为0&#xA;                        ##  如果内存紧张，无法分配时则引发异常&#xA;                        ## api uint16Array = new Uint16Array(length);&#xA;                        ### uint16Array = new Uint16Array(array);&#xA;                        # 位置，用Vector3来表示，共有triangles * 3个Vector3&#xA;                        ## 每个Vector3有x, y, z三个分量组成, 所以顶点需要triangles * 3 * 3个浮点数表示。&#xA;                        # 法线, 一个点对应一个法线, 由x, y, z三个float组成，所以需要triangles    * 3 * 3个float&#xA;                        # 颜色, 每个顶点一种颜色，颜色由R, G, B组成，所以需要triangles * 3 * 3个float&#xA;                var n = 800, n2 = n/2;&#xA;                        # n是正方体的边长&#xA;                # 为三角形顶点赋随机值，后计算每个顶点的法向量&#xA;                ## positions数组每隔9个是一个三角形&#xA;                ## normals数组每隔9个是一个三角形&#xA;                # 随机生成颜色，赋给顶点&#xA;                ## colors数组每隔9个是一个三角形&#xA;&#xA;                # 给geometry设置索引和偏移量&#xA;                ## 索引对应到点，所以有triangles * 3个&#xA;                ### 索引从0开始&#xA;&#xA;                # 将BufferGeometry和材质组成mesh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;人物粒子&#34;&gt;&#xA;  人物粒子&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ba%e7%89%a9%e7%b2%92%e5%ad%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;生成粒子&#xA;        var vertices = geometry.vertices;&#xA;        var mesh = new THREE.ParticleSystem(geometry, new THREE.ParticleBasicMaterial({size: 3, color: c}));&#xA;        mesh.scale.x = mesh.scale.y = mesh.scale.z = scale;&#xA;        mesh.position.x = mesh.position.y = mesh.position.z = position;&#xA;渲染&#xA;        render()&#xA;        mesh.geometry.verticesNeedUpdate = true;&#xA;                # 如果不刷新，渲染出来的顶点位置不会改变&#xA;        renderer.clear();&#xA;        composer.render(0.01);&#xA;                # composer为THREE.EffectComposer, 效果组合器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;多视口&#34;&gt;&#xA;  多视口&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e8%a7%86%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;viewport&#xA;注意&#xA;        视口的坐标为归一化的坐标。左上角是(0, 0), 右下角是(1, 1)&#xA;阴影贴图&#xA;    canvas画阴影&#xA;    阴影纹理&#xA;            var shadowTexture= new THREE.Texture(canvas);&#xA;            shadowTexture.needsUpdate = true;&#xA;                    # 表示纹理是新纹理，在绘制的时候，需要更新到材质上&#xA;            var shadowMaterial = new THREE.MeshBasicMaterial({map:shadowTexture});&#xA;平面和线框同时显示&#xA;    材质wireframe属性只有true和false,所以要创建2个不同材质的相同物体&#xA;&#xA;    THREE.SceneUtils.createMultiMaterialObject(geometry, materials)&#xA;            # 传递一个几何体和材质数组，几何体每一个材质组合成一个Mesh, 将Mesh加入组group对象中，返回组对象。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;杰克与豆径&#34;&gt;&#xA;  杰克与豆径&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%b0%e5%85%8b%e4%b8%8e%e8%b1%86%e5%be%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;主要内容&#xA;        天空盒&#xA;        生长效果&#xA;                树叶的生长&#xA;                树干变形&#xA;                音乐渲染控制生长&#xA;        对象池&#xA;设计&#xA;        鼠标操作&#xA;        植物模型&#xA;                plant&#xA;                        豆干，豆径(leaf3.js)，豆叶(leaf5.js)&#xA;                        豆径豆叶的材质&#xA;        植物生长&#xA;        阴天、晴天&#xA;                天空材质&#xA;&#xA;        相机动画&#xA;音乐&#xA;    &amp;lt;audio id=&amp;quot;audio&amp;quot; preload=&amp;quot;auto&amp;quot; loop&amp;gt;&#xA;                    # 预加载音乐并循环播放&#xA;            &amp;lt;source src=&amp;quot;a.mp3&amp;quot; type=&amp;quot;audio/mpeg&amp;quot;&amp;gt;&#xA;    &amp;lt;/audio&amp;gt;&#xA;&#xA;    &amp;lt;script&amp;gt;&#xA;            audio = document.getElementById(&#39;audio&#39;);&#xA;            audio.play();&#xA;    &amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;流动立方体&#34;&gt;&#xA;  流动立方体&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81%e5%8a%a8%e7%ab%8b%e6%96%b9%e4%bd%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;设计&#xA;        从相机到鼠标发射射线, 与射线相交的点，就是选中物体的某个点&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;我的世界&#34;&gt;&#xA;  我的世界&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%88%91%e7%9a%84%e4%b8%96%e7%95%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;MineCraftApp = function(){&#xA;        Sim.App.call(this);&#xA;}&#xA;MineCraftApp.prototype = new Sim.App();&#xA;&#xA;MineCraftApp.prototype.init = function(param){&#xA;        Sim.App.prototype.init.call(this, param);&#xA;                # 调用父类的init函数，在父类中初始化相机, 场景等类&#xA;        # 性能监视器&#xA;        # 天空盒&#xA;        # 相机控制类&#xA;        # 场景中的一个个小物体&#xA;}&#xA;$(document).ready(&#xA;        function(){&#xA;                var container = document.getElementById(&amp;quot;container&amp;quot;);&#xA;                var app = new MineCraftApp();&#xA;                app.init({container: container});&#xA;                        # container属性 表示最后渲染结果外层的div&#xA;                app.run();&#xA;        }&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;汽车换装&#34;&gt;&#xA;  汽车换装&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b1%bd%e8%bd%a6%e6%8d%a2%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;设计&#xA;        汽车类&#xA;                更换s汽车模型&#xA;                更换汽车各部分颜色&#xA;        两个相机&#xA;        两个场景&#xA;        三种光源&#xA;        天空盒&#xA;        渲染器&#xA;        效率监听器&#xA;        初始化各种材质&#xA;汽车类&#xA;        veyron: {&#xA;                name: &#39;布加迪威龙&#39;,&#xA;                url: &#39;obj/veyron/VeyronNoUv_bin.js&#39;,&#xA;                author: &#39;布加迪威龙&#39;,&#xA;                init_rotation: [0, 0, 0],&#xA;                scale: 5.5,&#xA;                init_materials: 4,&#xA;                body_materials: [2],&#xA;                object: null,&#xA;                buttons: null,&#xA;                materials: null&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分形&#34;&gt;&#xA;  分形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uniforms = {&#xA;        scale: {type: &#39;v2&#39;, value: new THREE.Vector2()},&#xA;        c: {type: &#39;v2&#39;, value: new THREE.Vector2()}&#xA;}&#xA;material = new THREE.ShaderMaterial({&#xA;        uniforms: uniforms,&#xA;        vertexShader: document.getElementById(&#39;vertexShader&#39;).textContent,&#xA;        fragmentShader: document.getElementById(&#39;fragmentShader&#39;).textContent&#xA;});&#xA;mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.0), material);&#xA;        # 用 2 * 2 的平面来覆盖浏览器窗口&#xA;function onWidowResize(event){&#xA;        renderer.setSize(window.innerWidth, window.innerHeight);&#xA;        uniforms.scale.value.x = window.innerWidth / 2;&#xA;        uniforms.scale.value.y = window.innerHeight;&#xA;}&#xA;&#xA;o-&amp;gt; 片元着色器中代码 &#xA;uniform vec2 c;&#xA;uniform vec2 scale;&#xA;void main(void){&#xA;        float R = (gl_FragCoord.x - scale.x) / scale.y;&#xA;        float I = (gl_FragCoord.y - scale.x) / scale.y;&#xA;        float R2 = R * R, I2 = I * I;&#xA;        int mm;&#xA;        for(int m =0; m &amp;lt; 255; m++){&#xA;                I = (R + R) * I + c.y; R = R2 - I2 + c.x; R2 = R * R; I2 = I * I; mm = m;&#xA;                if(abs((I2) / (I + R)) &amp;gt; 10.) break;&#xA;        }&#xA;        if(mm == 254) gl_FragColor = vec4(0., 0., 0., 1.);&#xA;        else{&#xA;                float a = float(mm);&#xA;                a = mod(a, 15.) / 5.;&#xA;                gl_FragColor = vec4(max(0., abs(a - 1.5) - .5)),&#xA;                        max(0., 1. - abs(a - 1.)),&#xA;                        max(0., 1. - abs(a - 2.)),&#xA;                        1.);&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;镜像分形&#34;&gt;&#xA;  镜像分形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%95%9c%e5%83%8f%e5%88%86%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        镜面反射场景&#xA;&#xA;var mirrorMesh = new THREE.Mesh(planeGeo, groundMirror.material);&#xA;        # groundMirror.material是THREE.Mirror中定义的材质. 会在每次update(或者render)过程中变化&#xA;        ## groundMirror.updateTextureMatrix()&#xA;        ## groundMirror.render() 要在update或render前重新渲染镜子的纹理.&#xA;        ### 多面镜子时, 如上一个个更新会有干扰, 要用下面代码更新&#xA;        ### groundMirror.renderWithMirror(verticalMirror);&#xA;        ### verticalMirror.renderWithMirror(groundMirror);&#xA;mirrorMesh.add(groundMirror);&#xA;mirrorMesh.rotateX(-Math.PI / 2);&#xA;scene.add(mirrorMesh);&#xA;&#xA;THREE.ShaderLib[&#39;mirror&#39;] = {&#xA;        uniforms: {&#xA;                mirrorColor: {&#xA;                        type: &#39;c&#39;,&#xA;                        value: new THREE.Color(0x7F7F7F)&#xA;                },&#xA;                mirrorSampler: {type: &#39;t&#39;, value: null},&#xA;                textureMatrix: {type: &#39;m4&#39;, value: new THREE.Matrix4()}&#xA;        },&#xA;        vertexShader: [&#xA;                &#39;uniform mat4 textureMatrix;&#39;,&#xA;                &#39;varying vec4 mirrorCoord;&#39;,&#xA;                &#39;void main() {&#39;,&#xA;                        &#39;vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);&#39;,&#xA;                        &#39;vec4 worldPosition = modelMatrix * vec4(position, 1.0);&#39;,&#xA;                        &#39;mirrorCoord = textureMatrix * worldPosition;&#39;,&#xA;                        &#39;gl_Position = projectionMatrix * mvPosition;&#39;,&#xA;                &#39;}&#39;&#xA;        ].join(&#39;&#39;\n),&#xA;        fragmentShader: [&#xA;                &#39;uniform vec3 mirrorColor;&#39;,&#xA;                &#39;uniform sampler2D mirrorSampler;&#39;,&#xA;                &#39;varying vec4 mirrorCoord;&#39;,&#xA;                &#39;float blendOverlay(float base, float blend){&#39;,&#xA;                        &#39;return (base &amp;lt; 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)));&#39;,&#xA;                &#39;}&#39;,&#xA;                &#39;void main(){&#39;,&#xA;                        &#39;vec4 color = texture2DProj(mirrorSampler, mirrorCoord);&#39;,&#xA;                        &#39;color = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, mirrorColor.b), 1.0);&#39;,&#xA;                        &#39;gl_FragColor = color;&#39;,&#xA;                &#39;}&#39;&#xA;        ].join(&#39;\n&#39;)&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;文字&#34;&gt;&#xA;  文字&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e5%ad%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    原理: 每个要显示的文字生成mesh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;小地图&#34;&gt;&#xA;  小地图&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%8f%e5%9c%b0%e5%9b%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        实现方式1, 在天空直接用正投影相机&#xA;                # 实现简单,但渲染效果差,占很多cpu时间(重新绘制一次整个场景)&#xA;        实现方式2, 用正投影相机, 但用画大地图的数据来绘制&#xA;                # 小地图渲染用很少时间, 因为复杂模型都用小方块或图片代替了&#xA;&#xA;o-&amp;gt; 实现&#xA;        camera.lookAt(scene.position);&#xA;        camera2.lookA(scene.position);&#xA;&#xA;        renderer2 = new THREE.CanvasRenderer();&#xA;                # 两个WebGLRenderer位置重叠时,会渲染不正常(其中一个全黑)&#xA;        renderer2.setSize(200, 150);&#xA;&#xA;        renderer.render(scene, camera);&#xA;        renderer2.render(scene, camera2);&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Angular</title>
      <link>https://runout.run/docs/middleware/library_frontend/angular/</link>
      <pubDate>Thu, 11 Oct 2018 07:47:51 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/angular/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;google发布&#xA;提倡SPA(Single Page Apps), 运行快，一次加载&#xA;mvvm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;前端mvc&#xA;双向数据绑定&#xA;指令和语义化标签&#xA;模块化工具&#xA;依赖注入&#xA;html模板&#xA;常用工具封装，如$http $cookies $location&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;directive&#34;&gt;&#xA;  directive&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#directive&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内置&#xA;    ng-app                      # 声明app名, 在最外层&#xA;    ng-submit                   # &amp;lt;form ng-submit=&amp;quot;submit()&amp;quot;&amp;gt;&#xA;    ng-controller&#xA;    ng-repeat                   # $index返回当前引用的元素序号，$first, $middle, $last 返回布尔值&#xA;    ng-model                    # 绑定当前元素的值&#xA;    ng-click&#xA;        ng-eventhandler=&amp;quot;expression&amp;quot;类的指令可以在所有浏览器中有相同的行为，angular将会屏蔽差异性&#xA;        不会在全局命名空间中进行操作，指定的表达式只能访问元素控制器作用域范围内的函数和数据&#xA;    ng-bind&#xA;    ng-change&#xA;    &amp;lt;form ng-submit=&amp;quot;aaFunc()&amp;quot;&amp;gt; # 会阻止浏览器默认的提交操作&#xA;    ng-dblclick&#xA;    ng-show&#xA;    ng-hide&#xA;    ng-class                    # 可以是类名字符串，空格分隔，可以是类名数组，可以是类名到布尔值的映射&#xA;        ng-class=&amp;quot;{true: &#39;active&#39;, false: &#39;inactive&#39;}[isActive]&amp;quot;&#xA;        ng-class=&amp;quot;{&#39;selected&#39;: isSelected, &#39;car&#39;: isCar}&amp;quot;&#xA;    ng-style                    # templete中写css不好维护&#xA;    ng-src=&amp;quot;/images/cats/{{favoriteCat}}&amp;quot;       # src，href属性中简单使用templete,由于浏览器优先并行加载图片和其它内容,angular没有机会拦截到数据绑定请求，所以无法运行&#xA;    ng-href&#xA;    ng-options&#xA;        &amp;lt;select ng-model=&amp;quot;x&amp;quot; ng-options=&amp;quot;(m.a + &#39; - &#39; + m.b) group by m.c for (key, m) in opts&amp;quot;&amp;gt;&#xA;自定义&#xA;    angular.module(&#39;CAT.TryDrt&#39;, [])&#xA;    .directive(&#39;hello&#39;, function(){&#xA;        return {&#xA;            restrict: &#39;E&#39;,                          # E: element, A:attribute, C:class, M: comment&#xA;            template: &#39;&amp;lt;div&amp;gt;Hello world&amp;lt;/div&amp;gt;&#39;,     # 标签内容&#xA;            replace: true                           # 表示替换原标签&#xA;        }&#xA;    });&#xA;&#xA;    &amp;lt;hello&amp;gt;&amp;lt;/hello&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;controller&#34;&gt;&#xA;  controller&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#controller&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    通过ng-controller&#xA;    router中绑定到动态加载的dom模板片段上&#xA;作用&#xA;    初始化页面状态&#xA;    通过$scope对象暴露数据模型给视图&#xA;    监视模型变化，并采取相应动作&#xA;嵌套&#xA;    原理是$scope的继承&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;templete&#34;&gt;&#xA;  templete&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#templete&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用范围&#xA;    页面中&#xA;    value、class、style属性&#xA;表达式                      # 自定义的解释器而非eval执行&#xA;    + - * / %&#xA;    == != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;=&#xA;    &amp;amp;&amp;amp; || !&#xA;    \^ &amp;amp; |&#xA;    $scope中暴露的函数&#xA;            # 但不是视图的职责，也不利于测试&#xA;    {} []&#xA;filter&#xA;    使用&#xA;        expression | filterName : parameter1 : parameter2 : ...&#xA;        可以多次过滤, 11.2 | currency | number:0 会显示$11&#xA;&#xA;    currency                # 数字过滤成美元&#xA;    date&#xA;    number&#xA;    uppercase&#xA;&#xA;    自定义&#xA;        homeModule.filter(&#39;titleCase&#39;, function(){&#xA;            var titleCaseFilter = function (input){&#xA;                var words = input.split(&#39; &#39;);&#xA;                for(var i = 0; i &amp;lt; words.length; i++){&#xA;                    words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1);&#xA;                }&#xA;                return words.join(&#39; &#39;);&#xA;            };&#xA;            return titleCaseFilter;&#xA;        })&#xA;&#xA;        {{pageHeading | titleCase}}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;module&#34;&gt;&#xA;  module&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#module&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;api&#xA;    angular&#xA;        module(&#39;todoApp&#39;, [])       # 数组中传入依赖的外部模块名&#xA;        controller(&#39;TodoListController&#39;, function(){&#xA;            var todoList = this;&#xA;            todoList.todos = [{a:&#39;a1&#39;},{a:&#39;a2&#39;}];&#xA;            todoList.addTode = function(){}&#xA;        });&#xA;        value()&#xA;        service()&#xA;        config()&#xA;        factory(&#39;globalInterceptor&#39;, GlobalInterceptor)&#xA;        run()&#xA;        angular.ent($(&#39;.container&#39;)).scope().fetchDept()    # 得到element的scope&#xA;&#xA;    o-&amp;gt; 例子&#xA;    angular.module(&#39;project&#39;, [&#39;ngRoute&#39;, &#39;firebase&#39;])&#xA;    .value(&#39;fbURL&#39;, &#39;https://ng-projects-list.firebaseio.com/&#39;)&#xA;    .service(&#39;fbRef&#39;, function(fbURL){return new Firebase(fbURL)&#xA;    })&#xA;    .service(&#39;fbAuth&#39;, function...)&#xA;    .config(function($routeProvider){&#xA;        var resolveProjects = {&#xA;            projects: function(Projects){&#xA;                return ...&#xA;            }&#xA;        };&#xA;    })&#xA;&#xA;    o-&amp;gt;&#xA;    xxxModule.config(function ($routeProvider) {&#xA;        $routeProvider&#xA;        .when(&#39;url&#39;, {controller: aController, templateUrl: &#39;/path/to/template&#39;})&#xA;        .when(..)&#xA;        .otherwise(..);&#xA;    })&#xA;&#xA;    o-&amp;gt;&#xA;    someModule.config(function($routeProvider){&#xA;        $routeProvider.&#xA;            when(&#39;url&#39;, {controller: aController, templateUrl: &#39;/path/to/template&#39;}).&#xA;            when(...) ...&#xA;            otherwise(...)&#xA;    })&#xA;&#xA;第三方module&#xA;    ngCookies&#xA;    ngAnimate&#xA;    &#39;ngWebSocket&#39;&#xA;    angularJwt&#xA;    ngclipboard&#xA;    react.name&#xA;    &#39;flow&#39;&#xA;        # 文件上传&#xA;    &#39;flowchart&#39;&#xA;        # 流程图&#xA;    ngTouch&#xA;    &#39;angular-carousel&#39;&#xA;        # 图片轮换, 可移动端&#xA;&#xA;    FBAngular.name&#xA;        # 全屏&#xA;    ngMaterial&#xA;        # 响应式布局&#xA;    ngMdIcons&#xA;        # 图标&#xA;    angularSocialshare&#xA;        # 社交分享&#xA;    &#39;pascalprecht.translate&#39;&#xA;        # 国际化&#xA;    &#39;mdColorPicker&#39;&#xA;        # 颜色选择器&#xA;    &#39;ngMaterialDateRangePicker&#39;&#xA;        # 日期选择器&#xA;    mdPickers&#xA;        # 日期选择器&#xA;    ngSanitize&#xA;        # html过滤&#xA;    vAccordion&#xA;        # 折叠菜单&#xA;    &#39;dndLists&#39;&#xA;        # 拖拽&#xA;    mdDataTable&#xA;        # 表格&#xA;    fixedTableHeader&#xA;        # 表头固定&#xA;    &#39;material.components.expansionPanels&#39;&#xA;        # 可扩展panel&#xA;    &#39;mdSteppers&#39;&#xA;        # 步骤图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内置&#xA;    $rootScope          # 全局作用域&#xA;    $scope&#xA;    $scope.$watch&#xA;        监控属性或函数&#xA;        $watch(watchFn, watchAction, deepWatch)&#xA;            # angular的表达式(如$scope.xxx)或字符串，函数或表达式，布尔。返回一个函数，用来注销watcher&#xA;            # watch中的函数会翻倍执行，来检测模型中的变更已经被完整地进行了传播。会把所有被监控的属性都复制一份，再与当前值比较，看是否发生了变化。&#xA;            ## 最多运行10次，如果10次中watchFn的值都发生变化，则可能有循环依赖。&#xA;            ## Object.observe()会优化这一点，在支持此函数的地方自动使用它。&#xA;        $watch($scope.totalCart, calculate)&#xA;            # totalCart是函数&#xA;        $watch(&#39;items&#39;, calculate)&#xA;            # items是$scope.items数组&#xA;        $watch(function(){&#xA;            for($scope.items)&#xA;            $scope.bill.totalCartNum = total;&#xA;        })&#xA;        # 如果监控多个属性可以&#xA;        ## 监控这些属性连接起来的表达式&#xA;        ## deepWatch这些属性的数组&#xA;    $scope.$apply&#xA;        # 在所有绑定关系都获得刷新，所有变化都反映到了视图上时懒惰调用，angular定时提醒这个服务&#xA;        # 自主修改dom后，只是在$apply中注册并不调用，如果想马上得到angular双向绑定后的结果，要手动调用$apply&#xA;        # 触发完digest循环后执行回调&#xA;        $scope.$apply(function () {})&#xA;    $scope.$digest&#xA;        # 只是触发digest循环&#xA;        $scope.$digest()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;服务&#34;&gt;&#xA;  服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内置&#xA;    $location&#xA;    $log&#xA;    $http&#xA;    $route&#xA;    $routeProvider&#xA;    $urlRouterProvider&#xA;    $stateProvider&#xA;    $locationProvider&#xA;    $timeout&#xA;    $parse&#xA;        var submitHandler = $parse(attrs.ngSubmit)(scope);&#xA;        submitHandler();&#xA;    $q                  # node q, 并发控制&#xA;    $injector           # get注入的模块&#xA;创建服务&#xA;    provider&#xA;        # 创建可配置的服务&#xA;    factory&#xA;        # 创建不可配置的服务&#xA;    service&#xA;        # 创建不可配置的服务，比较简单&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;浏览器插件&#34;&gt;&#xA;  浏览器插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8f%e8%a7%88%e5%99%a8%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Batarang&#xA;    # 调试&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Jquery</title>
      <link>https://runout.run/docs/middleware/library_frontend/jquery/</link>
      <pubDate>Thu, 11 Oct 2018 07:34:03 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/jquery/</guid>
      <description>&lt;h1 id=&#34;对象命名方式&#34;&gt;&#xA;  对象命名方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%91%bd%e5%90%8d%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;var $a = $(&amp;quot;#inputID&amp;quot;);        &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;选择器选择多个时形成数组&#34;&gt;&#xA;  选择器（选择多个时形成数组）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%89%e6%8b%a9%e5%99%a8%e9%80%89%e6%8b%a9%e5%a4%9a%e4%b8%aa%e6%97%b6%e5%bd%a2%e6%88%90%e6%95%b0%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;基本选择器&#xA;    $(&amp;quot;#inputID&amp;quot;);                # id选择&#xA;    $(&amp;quot;input&amp;quot;); // 标签名,默认获取第一个                # 标签名选择&#xA;        $(&amp;quot;.className&amp;quot;); // 按样式名定位                # 样式名选择&#xA;        $(&amp;quot;#div1ID,.myClass,p&amp;quot;);                # 选择多个&#xA;        $(&amp;quot;*&amp;quot;);                        # 所有元素&#xA;层级选择器&#xA;    $(&amp;quot;form input&amp;quot;)                        # form所有后代元素中input元素的个数&#xA;    $(&amp;quot;form&amp;gt;input&amp;quot;)                        # form子元素中input元素个数，不包括下层元素&#xA;    $(&amp;quot;form+input&amp;quot;)                        # form同级并且下面的第一个input元素&#xA;    $(&amp;quot;form~input&amp;quot;)                        # form同级并且下面的所有input元素&#xA;子元素选择器                # 只选择一个&#xA;    $(&amp;quot;ul li:first&amp;quot;)                # ul中第一个子元素li&#xA;    $(&amp;quot;ul li:last&amp;quot;)                        # ul中最后一个子元素li&#xA;    $(&amp;quot;input:not(:checked)&amp;quot;)                        # input标签中所有未选中的元素&#xA;    $(&amp;quot;table tr:even&amp;quot;)                # 表格的奇数行（索引号为偶数）&#xA;    $(&amp;quot;table tr:odd&amp;quot;)                # 表格的偶数行（索引号为奇数）&#xA;    $(&amp;quot;table tr:eq(1)&amp;quot;)                # table中索引号等于1的行&#xA;    $(&amp;quot;table tr:gt(0)&amp;quot;)                # table中索引号大于0的行（不包括0）&#xA;    $(&amp;quot;table tr:lt(2)&amp;quot;)                # table中索引号小于2的行（不包括2）&#xA;    $(&amp;quot;:header&amp;quot;)                        # 匹配如 h1, h2, h3之类的标题元素&#xA;内容选择器&#xA;    $(&amp;quot;div:contains(&#39;Join&#39;)&amp;quot;)                # div 标签的html()中包含&#39;Join&#39;字符串的元素&#xA;    $(&amp;quot;p:empty&amp;quot;)                        # p 标签的html()的内容为空的元素&#xA;    $(&amp;quot;div:has(p)&amp;quot;)                        # div标签中包含p标签的该div标签&#xA;    $(&amp;quot;p:parent&amp;quot;);                        # 非空的p标签元素，即p为父元素&#xA;可见性选择器&#xA;    $(&amp;quot;tr:hidden&amp;quot;)                        # 查找隐藏的tr元素，如&amp;lt;tr style=&amp;quot;display:none&amp;quot;&amp;gt;&#xA;                                                                                                    &amp;lt;td&amp;gt;Value 1&amp;lt;/td&amp;gt;&#xA;                                                                                            &amp;lt;/tr&amp;gt;&#xA;    $(&amp;quot;tr:visible&amp;quot;)                        # 查找可见的tr元素&#xA;属性选择器&#xA;    $(&amp;quot;div[id]&amp;quot;)                        # 含有id属性的div元素&#xA;    $(&amp;quot;input[name=&#39;newsletter&#39;]&amp;quot;)                        # 所有name属性是newsletter的input元素&#xA;    $(&amp;quot;input[name!=&#39;newsletter&#39;]&amp;quot;)                        # 所有name属性不是newsletter的input元素&#xA;    $(&amp;quot;input[name^=&#39;news&#39;]&amp;quot;)                                # name以&#39;news&#39;开始的input元素&#xA;    $(&amp;quot;input[name$=&#39;leter&#39;]&amp;quot;)                                # name 以&#39;letter&#39;结尾的input元素&#xA;    $(&amp;quot;input[name*=&#39;news&#39;]&amp;quot;)                                # name包含&#39;news&#39;的input元素&#xA;    $(&amp;quot;input[id][name$=&#39;leter&#39;]&amp;quot;)                        # 含有id属性，并且它的name属性是以&amp;quot;letter&amp;quot;结尾的input 元素&#xA;子元素选择器&#xA;    $(&amp;quot;ul li:first-child&amp;quot;);                        # 匹配多个ul中的第一个子li元素的li元素集合&#xA;    $(&amp;quot;ul li:last-child&amp;quot;);                                # 匹配多个ul中的最后一个子li元素的li元素集合&#xA;    $(&amp;quot;ul li:nth-child(1)&amp;quot;);                        # 匹配多个ul中的第一个子li元素的li元素集合,注意：标记从1开始(eq 从0开始)&#xA;    $(&amp;quot;ul li:only-child&amp;quot;);                                # 匹配多个ul中的只有一个li元素的li元素集合&#xA;表单选择器&#xA;    $(&amp;quot;:input&amp;quot;);        # 所有input元素，包括select textarea button等&#xA;    $(&amp;quot;:text&amp;quot;);        # 所有文本框&#xA;    $(&amp;quot;:password&amp;quot;);    # 密码框&#xA;    $(&amp;quot;:radio&amp;quot;);        # 单选框&#xA;    $(&amp;quot;:checkbox&amp;quot;);    # 复选框&#xA;    $(&amp;quot;:submit&amp;quot;);      # 提交按钮&#xA;    $(&amp;quot;:image&amp;quot;);        # 有提交功能的图片&#xA;    $(&amp;quot;:reset&amp;quot;);        # 重置按钮&#xA;    $(&amp;quot;:button&amp;quot;);      # 按钮，包括&amp;lt;button&amp;gt;&amp;lt;/button&amp;gt;&#xA;    $(&amp;quot;:file&amp;quot;);        # 文件域&#xA;    $(&amp;quot;:input:hidden&amp;quot;);    # 隐藏域&#xA;表单对象属性&#xA;    $(&amp;quot;:input:enabled&amp;quot;);        # 所有可用的input元素&#xA;    $(&amp;quot;:input:disabled&amp;quot;)        # 所有不可用的input元素&#xA;    $(&amp;quot;:checkbox:checked&amp;quot;);    # 所有已选中的checkbox(有checked属性的)元素    $(&amp;quot;:checkbox:not(:checked)&amp;quot;);  未选中的checkbox&#xA;    $(&amp;quot;:select option:selected&amp;quot;);      # 所有已选中的option元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;基础函数&#34;&gt;&#xA;  基础函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;对象访问&#xA;    size()          # 同length,返回元素个数&#xA;    length          # 同size(),返回元素个数&#xA;    get(index)      # 取得一个匹配的元素,从0开始&#xA;    each(function(){});                        # 遍历调用该方法的元素数组中的元素，其中的this代表循环中的每一个元素&#xA;    &#xA;属性&#xA;    val()                              # value属性的值，或option元素之间的值&#xA;    val(&amp;quot;&amp;quot;)                        # 设置value的值&#xA;    var([&amp;quot;Multiple2&amp;quot;, &amp;quot;Multiple3&amp;quot;]);        # 设置select 下option的值&#xA;    html()                                # 相当于innerHTML ,同样不支持xml&#xA;    attr(&amp;quot;&amp;quot;)                        # 查找属性&#xA;    attr(&amp;quot;checked&amp;quot;,&amp;quot;checked&amp;quot;)                # 设置checked属性的值为&amp;quot;checked&amp;quot;&#xA;    removeAttr(&amp;quot;align&amp;quot;);                # 删除属性&#xA;    样式类（css）&#xA;        addClass(&amp;quot;myClass&amp;quot;);          # 添加 css 样式&#xA;        removeClass(&amp;quot;myClass&amp;quot;);        # 删除样式&#xA;        toggleClass(&amp;quot;myClass&amp;quot;);        # 切换样式，有变无，无变有&#xA;        hasClass(&amp;quot;myClass&amp;quot;)            # 返回是否有样式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;筛选&#34;&gt;&#xA;  筛选&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ad%9b%e9%80%89&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;过滤&#xA;        eq(index)                                                # 从0开始的第index元素&#xA;        is(expr)                                                # 判断元素中是否有符合expr的元素（如&amp;quot;form&amp;quot;），有则返回true,无则返回false&#xA;        first()                                                        # 第一个元素&#xA;        last()                                                        # 最后一个元素&#xA;        filter(expr)                                        # 筛选出符合表达式的集合&#xA;        has(expr)                                                # 保留符合expr的元素，去掉不符合的&#xA;        not(expr)                                                # 删除符合expr的元素，与has相反&#xA;查找&#xA;    find(&amp;quot;&amp;quot;);                      # 搜索所有与指定表达式匹配的后代元素&#xA;    children()                      # 取得所有直接子元素，不包含后代&#xA;    next()                          # 下一个同级兄弟&#xA;    prev();                        # 上一个同级兄弟&#xA;    parent(&amp;quot;&amp;quot;)                      # 含着所有匹配元素的唯一父元素 ,可以用选择器筛选&#xA;    parents(&amp;quot;p&amp;quot;)                    # $(&amp;quot;span&amp;quot;).parents(&amp;quot;p&amp;quot;) 每个span的所有是p元素的祖先元素&#xA;    nextAll()                      # 之后所有同级兄弟&#xA;    prevAll()                      # 之前所有同级兄弟&#xA;    siblings()                      # 上下的所有同级兄弟&#xA;对象处理&#xA;    replaceWith()                  # $(&amp;quot;p&amp;quot;).replaceWith(&amp;quot;&amp;lt;b&amp;gt;Paragraph. &amp;lt;/b&amp;gt;&amp;quot;); 替换p节点为自制的粗体节点&#xA;    remove()                        # 自己删除自己&#xA;    clone()                        # 复制自己  clone(true) 会复制行为&#xA;    内部插入&#xA;        append(content)            # 元素内部之后添加元素，相当于appendChild()&#xA;        prepend(content)            # 元素内部之前添加元素&#xA;    外部插入&#xA;        after(content)              # 元素同级之后插入&#xA;        before(content)            # 元素同级之前插入&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;事件函数&#34;&gt;&#xA;  事件函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e4%bb%b6%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;change(fn)              # $(&amp;quot;select&amp;quot;).change(function(){})  dom 中的onchange事件，元素内容变化时触发&#xA;submit(fn)              # $(&amp;quot;form&amp;quot;).submit(function(){})  选中表单提交时触发，多用于简单检测输入&#xA;                # 该事件函数中写return false;代表不提交表单&#xA;focus(fn)              # $(&amp;quot;:text&amp;quot;).focus();      将光标定位到input text表单中&#xA;select(fn)              # 选中  如 $(function(){  $(&amp;quot;:text&amp;quot;).select(); $(&amp;quot;:text&amp;quot;).focus(); })  页面加载时定位光标到input text文本域，并选中其中的文字        &#xA;mouseover(fn)           &#xA;mouseout(fn)&#xA;mousemove(function(e){})          # 鼠标移动时执行 ie 中已经定义参数，不用传递，直接用event，event.clientX,event.clientY分别得到鼠标的x,y坐标&#xA;keyup(fn)                  # ie 中 event.keyCode得到按键编码(firefox 中传递参数e,e.which得到按键编码)&#xA;ready(fn)              # $(document).ready(fn) 相当于window.load()事件，但可以写多个&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;css函数&#34;&gt;&#xA;  css函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#css%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    css(&amp;quot;background-color&amp;quot;,&amp;quot;red&amp;quot;);                # 设置style属性&#xA;    addClass(&amp;quot;myClass&amp;quot;)                                # 添加css样式&#xA;removeClass(&amp;quot;myClass&amp;quot;)              # 删除样式&#xA;toggleClass(&amp;quot;myClass&amp;quot;)              # 切换样式，有则删除，无则添加&#xA;hasClass(&amp;quot;myClass&amp;quot;)                # 是否有样式，返回true或false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;效果函数&#34;&gt;&#xA;  效果函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%88%e6%9e%9c%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;slideUp(speed,fn)      # 向上滑动,如$(&amp;quot;div&amp;quot;).slideUp(200);&#xA;slideToggle(speed,fn)  # 滑上滑下切换,如$(&amp;quot;div&amp;quot;).slideToggle(200);&#xA;&#xA;show(speed,fn)          # 元素从无到有动画显示出来&#xA;hide(speed,fn)          # 元素从有到无隐藏起来&#xA;toggle(speed,fn)        # 有则无，无则有隐藏、显示元素&#xA;fadeIn(speed,fn)        # 淡入显示图片&#xA;fadeOut(speed,fn)      # 淡出隐藏图片&#xA;animate(styles,speed,easing,callback)                # 自定义动画。只有数字值可创建动画（比如 &amp;quot;margin:30px&amp;quot;）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具函数&#34;&gt;&#xA;  工具函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;$.trim(str)            # 去除str字符串开头和结尾的空白&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;其它函数&#34;&gt;&#xA;  其它函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b6%e5%ae%83%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;serialize()            # 序列表单内容为字符串  ajax提交表单时可以        var sendData = $(&amp;quot;form&amp;quot;).serialize();  给sendData赋值传递表单信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;特殊使用&#34;&gt;&#xA;  特殊使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e6%ae%8a%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;$(document)    # 得到document区  ，可以定义事件，如$(document).mousemove(fn);&#xA;                $(document).ready(fn); 相当于$(fn)&#xA;$(fn)          # 相当于window.load ,在页面加载时执行，可以写多个，（而window.load只能一个生效，后面的会覆盖前面的）&#xA;$(&amp;quot;&amp;lt;div id=&#39;2013&#39;&amp;gt;ss&amp;lt;/idv&amp;gt;&amp;quot;);      # 创建一个元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;与dom之间的转换&#34;&gt;&#xA;  与dom之间的转换&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8edom%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    var $input = $(inputElemenet); // 注意，没有双引号&#xA;    var inputElement = $input.get(0); // jquery相当于存储了dom对象的数组 &#xA;      var inputElement = $input[0];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;ajax&#34;&gt;&#xA;  ajax&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ajax&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;load(url)                      # $(&amp;quot;span&amp;quot;).css(&amp;quot;color&amp;quot;,&amp;quot;red&amp;quot;).load(url)        无参以get方式提交，返回的值直接作为&amp;lt;span&amp;gt;标签内的文本节点值&#xA;load(url,sendData);            # 有参以post的方式提交&#xA;                                ## var sendData = {&amp;quot;username&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;password&amp;quot;:&amp;quot;psw&amp;quot;};  sendData的内容用json的语法写&#xA;load(url,sendData,function(backData,textStatus,ajax){});          # 加上处理返回值的函数,服务器返回数据时调用此函数&#xA;                                                                  ##  其中backData是返回的字符串,textStatus是响应头状态码的值对应的信息（success代表200）,ajax是ajax引擎对象&#xA;                                                                  ##  &amp;lt;span&amp;gt;标签的文本节点的值仍会被改变&#xA;                                                                  ##  可以只写一个参数：backData，参数的名字可以任意更改&#xA;$.get(url,sendData,function(backData,textStatus,ajax){});          # 用get方式提交ajax模拟的表单&#xA;$.post(url,sendData,function(backData,textStatus,ajax){});          # 用post方式提交ajax模拟的表单 响应头 content-type = &amp;quot;application/x-www-form-urlencoded&amp;quot; 会自动设置好&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;jquery提供&#xA;    fixedtableheader&#xA;    tablesort&#xA;    tools&#xA;    ui&#xA;    hashchange&#xA;        控制浏览器的前进后退到一个页面中(不必刷新)&#xA;    easing&#xA;        jquery的动画扩展, 比如动画执行的速度曲线&#xA;代码&#xA;    icanhaz&#xA;    mustache&#xA;功能&#xA;    fileupload&#xA;    treeview&#xA;        文件&#xA;                jquery.treeview.js                        # treeview插件简化板&#xA;                jquery.treeview.edit.js                # 可编辑的菜单&#xA;                jquery.treeview.css                        # treeview可选使用的样式&#xA;                &#xA;        使用&#xA;                $(&amp;quot;#root&amp;quot;).treeview({                        # $(&amp;quot;#root&amp;quot;)是顶层ul元素&#xA;                        /* 展开还是收起, 默认为false 展开*/&#xA;                        collapsed: true,&#xA;                        /* 唯一的, 当前菜单打开的时候其他菜单收缩*/&#xA;                        unique: true,&#xA;                        /*动态加载菜单（接收json数据）*/&#xA;                        url: &amp;quot;source.do&amp;quot;&#xA;                });&#xA;                        # 动态加载菜单时接收的数据格式为&#xA;                                [&#xA;                                {&#xA;                                &amp;quot;text&amp;quot;: &amp;quot;1. Pre Lunch (120 min)&amp;quot;,&#xA;                                &amp;quot;expanded&amp;quot;: true,&#xA;                                &amp;quot;classes&amp;quot;: &amp;quot;important&amp;quot;,&#xA;                                &amp;quot;children&amp;quot;:&#xA;                                [&#xA;                                {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;1.1 The State of the Powerdome (30 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;1.2 The Future of jQuery (30 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;1.2 jQuery UI - A step to richnessy (60 min)&amp;quot;&#xA;                                }&#xA;                                ]&#xA;                                },&#xA;                                {&#xA;                                &amp;quot;text&amp;quot;: &amp;quot;2. Lunch  (60 min)&amp;quot;&#xA;                                },&#xA;                                {&#xA;                                &amp;quot;text&amp;quot;: &amp;quot;3. After Lunch  (120+ min)&amp;quot;,&#xA;                                &amp;quot;children&amp;quot;:&#xA;                                [&#xA;                                {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.1 jQuery Calendar Success Story (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.2 jQuery and Ruby Web Frameworks (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.3 Hey, I Can Do That! (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.4 Taconite and Form (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.5 Server-side JavaScript with jQuery and AOLserver (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.6 The Onion: How to add features without adding features (20 min)&amp;quot;,&#xA;                                        &amp;quot;id&amp;quot;: &amp;quot;36&amp;quot;,&#xA;                                        &amp;quot;hasChildren&amp;quot;: true&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.7 Visualizations with JavaScript and Canvas (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.8 ActiveDOM (20 min)&amp;quot;&#xA;                                },&#xA;                                        {&#xA;                                        &amp;quot;text&amp;quot;: &amp;quot;3.8 Growing jQuery (20 min)&amp;quot;&#xA;                                }&#xA;                                ]&#xA;                                }&#xA;                                ]&#xA;                                        # &amp;quot;expanded&amp;quot;: true 代表这个结点下的child是展开的。&#xA;                                        # 返回的json字符串中的双引号必须是双引号。&#xA;                                        ## 初次请求时传递数据 root=source,点击节点申请数据时传递id值，如3.6中有id为36，且hasChildren:true,点击后传递36，我们再据此返回相应json数据。&#xA;                        &#xA;                &#xA;                引入css文件，根据其中的样式对页面进行设置&#xA;    validate&#xA;        使用&#xA;                验证写在&amp;lt;head&amp;gt;中时，要写在页面加载中（$(function{})）                # 否则读取&amp;lt;head&amp;gt;时，页面还没有加载，没有表单&#xA;                验证完成触发事件&#xA;                        失败事件：errorPlacement:function(error,element){}                        # error是错误消息，element是求救消息的js对象 &#xA;                        成功事件：success:function(label){}                        # label是显示消息的js对象&#xA;                远程验证：发送ajax请求到指定url                # 自动传递验证名与验证值，ie中get请求调用浏览器缓存，所以用户回退字符时不提交。所以用post方式发送请求&#xA;                                                                        ## 返回&amp;quot;true&amp;quot;表示成功，&amp;quot;false&amp;quot;表示失败&#xA;                        remote:{&#xA;                                url:&amp;quot;/outrun/servlet/JqueryValidateServlet&amp;quot;,&#xA;                                type:&amp;quot;post&amp;quot;&#xA;                        }&#xA;                简单例子：&#xA;                        $(&amp;quot;form&amp;quot;).validate({&#xA;                                debug:true,&#xA;                                rules:{&#xA;                                        name:{&#xA;                                                required:true,&#xA;                                                rangelength:[6,12]&#xA;                                        },&#xA;                                },&#xA;                                messages:{&#xA;                                        name:{&#xA;                                                required:&amp;quot;用户名必填&amp;quot;,&#xA;                                                rangelength:$.format(&amp;quot;用户名长度必须在{0}-{1}之间&amp;quot;)&#xA;                                        },&#xA;                                }&#xA;                        });&#xA;&#xA;        兼容：&#xA;                不同validate验证框架要求不同的jquery版本&#xA;                validate1.5.2配jquery1.3&#xA;                &#xA;        经验&#xA;                默认情况是丢失焦点验证,如果验证失败则 在失败的文本框每次输入数据都会触发onkeyup&#xA;                        设置        onkeyup:false&#xA;                        &#xA;        样式&#xA;                默认是class=&amp;quot;error&amp;quot;的样式，可以在页面中自定义.error{}样式取代，但是这样除了出错信息的样式修改外，用户输入信息的样式也会修改&#xA;                错误信息是以添加&amp;lt;label&amp;gt;标签的形式显示的，所以可以添加&amp;lt;label&amp;gt;标签的样式，如form label{}&#xA;    acccordion  下拉菜单&#xA;    autocomplete    自动补全(用索引库)&#xA;    password Vlidation 密码强度&#xA;    prettdate 日期插件&#xA;    message 消息框&#xA;报表&#xA;    highcharts&#xA;    jscharts&#xA;    am charts&#xA;        对象与属性&#xA;            对象                # 静态创建&#xA;                AmCharts.AmSerialChart()                 序列图&#xA;                        属性&#xA;                                dataProvider        数据&#xA;                                        # 接收json数据&#xA;                                categoryAxis        横坐标&#xA;                                        属性&#xA;                                                labelRotation          横坐标显示名角度&#xA;                                                gridPosition                网格的起始位置,&amp;quot;start&amp;quot;表示开始处&#xA;                                                dashLength                值为数字，网格中垂直线虚线程度 ，0代表实线&#xA;                                categoryField        横坐标显示名(dataProvider数据中的字段名)&#xA;                                depth3D        3D图形深度&#xA;                                angle                3D图形角度(左上俯角)&#xA;                                creditsPosition        未购买之前的商标位置，如&amp;quot;top-right&amp;quot;表示右上。&#xA;                        方法&#xA;                                write(&amp;quot;chartdiv&amp;quot;)                # 要绘图div的id属性值&#xA;                AmCharts.AmPieChart()                饼图&#xA;                AmCharts.AmSerialChart()         雷达图&#xA;                AmCharts.AmXYChart()                离散图&#xA;                AmCharts.AmLegend()                图例&#xA;                AmCharts.ValueAxis()                纵坐标&#xA;                        # 通过 AmCharts对象中图对象的addValueAxis()方法给图添加本属性&#xA;                        属性&#xA;                                title                        纵坐标标题&#xA;                                dashLength                值为数字，网格中水平线虚线程度 ，0代表实线&#xA;                AmCharts.AmGraph()                图形&#xA;                        # 通过 AmCharts对象中图对象的addGraph()方法给图添加本属性&#xA;                        属性&#xA;                                colorField                值为dataProvider提供数据中的字段名，表示数据在报表中的颜色&#xA;                                valueField                值为dataProvider提供数据中的字段名，表示占有数值的多少&#xA;                                balloonText                鼠标悬停时气球中的内容，用[[value]], [[description]], [[percents]], [[open]], [[category]] 等标记来引用数据&#xA;                                                        也可以用html标签，如： &amp;quot;&amp;lt;span style=&#39;font-size:14px&#39;&amp;gt;[[category]]: &amp;lt;b&amp;gt;[[value]]&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt;&amp;quot;&#xA;                                lineAlpha                0或1，代表数据图形是否有边界&#xA;                                fillAlpha                代表数据图形是否透明，0为透明&#xA;                                &#xA;                        AmSerialChart中AGraph的属性&#xA;                                type                        数据图形的形状，如&amp;quot;column&amp;quot;代表方块柱状图&#xA;                AmCharts.ChartCursor()                光标&#xA;                        # 通过 AmCharts对象中图对象的addChartCursor()方法给图添加本属性&#xA;                        属性&#xA;                                cursorAlpha                0或1，是否显示鼠标跟随线&#xA;                                zoomable                true或false 是否可以用鼠标选中来放大&#xA;                                categoryBalloonEnabled                        true或false 是否跟随鼠标显示横坐标种类名&#xA;            方法2                # 动态创建&#xA;                AmCharts.makeChart(&amp;quot;&amp;quot; , json);&#xA;                        参数1 : 要产生图形的div的id&#xA;                        参数2 : json格式的产生条件&#xA;                                type : 图形类型，如&amp;quot;pie&amp;quot;&#xA;                                dataProvider : 图形数据&#xA;                                titleField : 需要显示的种类名对应在dataProvider中的字段名&#xA;                                valueField : 需要显示的权重对应在dataProvider中的字段名&#xA;                                legend : json数据，图例的产生条件&#xA;                                        align : 对齐条件，如&amp;quot;center&amp;quot;&#xA;                                        markerType : 图例的形状，如&amp;quot;circle&amp;quot;&#xA;        使用1&#xA;                var chart;&#xA;                var chartData = [ {&#xA;                        &amp;quot;country&amp;quot; : &amp;quot;USA&amp;quot;,&#xA;                        &amp;quot;visits&amp;quot; : 4025,&#xA;                        &amp;quot;color&amp;quot; : &amp;quot;#FF0F00&amp;quot;&#xA;                }, {&#xA;                        &amp;quot;country&amp;quot; : &amp;quot;China&amp;quot;,&#xA;                        &amp;quot;visits&amp;quot; : 1882,&#xA;                        &amp;quot;color&amp;quot; : &amp;quot;#FF6600&amp;quot;&#xA;                } ];&#xA;&#xA;                AmCharts.ready(function() {&#xA;                                        // SERIAL CHART&#xA;                                        chart = new AmCharts.AmSerialChart();&#xA;                                        chart.dataProvider = chartData;&#xA;                                        chart.categoryField = &amp;quot;country&amp;quot;;&#xA;                                        // the following two lines makes chart 3D&#xA;                                        chart.depth3D = 20;&#xA;                                        chart.angle = 30;&#xA;&#xA;                                        // AXES&#xA;                                        // category&#xA;                                        var categoryAxis = chart.categoryAxis;&#xA;                                        categoryAxis.labelRotation = 0;&#xA;                                        categoryAxis.gridPosition = &amp;quot;start&amp;quot;;&#xA;&#xA;                                        // value&#xA;                                        var valueAxis = new AmCharts.ValueAxis();&#xA;                                        valueAxis.title = &amp;quot;Visitors&amp;quot;;&#xA;                                        chart.addValueAxis(valueAxis);&#xA;&#xA;                                        // GRAPH&#xA;                                        var graph = new AmCharts.AmGraph();&#xA;                                        graph.valueField = &amp;quot;visits&amp;quot;;&#xA;                                        graph.colorField = &amp;quot;color&amp;quot;;&#xA;                                        graph.balloonText = &amp;quot;&amp;lt;span style=&#39;font-size:14px&#39;&amp;gt;[[category]]: &amp;lt;b&amp;gt;[[value]]&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt;&amp;quot;;&#xA;                                        graph.type = &amp;quot;column&amp;quot;;&#xA;                                        graph.lineAlpha = 0;&#xA;                                        graph.fillAlphas = 1;&#xA;                                        chart.addGraph(graph);&#xA;&#xA;                                        // CURSOR&#xA;                                        var chartCursor = new AmCharts.ChartCursor();&#xA;                                        chartCursor.cursorAlpha = 0;&#xA;                                        chartCursor.zoomable = false;&#xA;                                        chartCursor.categoryBalloonEnabled = false;&#xA;                                        chart.addChartCursor(chartCursor);&#xA;&#xA;                                        chart.creditsPosition = &amp;quot;top-right&amp;quot;;&#xA;&#xA;                                        // WRITE&#xA;                                        chart.write(&amp;quot;chartdiv&amp;quot;);&#xA;                                });&#xA;        使用2&#xA;                AmCharts.makeChart(&amp;quot;chartdiv&amp;quot;, {&#xA;                        type: &amp;quot;pie&amp;quot;,&#xA;                        dataProvider: [{&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Czech Republic&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 156.9&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Ireland&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 131.1&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Germany&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 115.8&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Australia&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 109.9&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Austria&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 108.3&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;UK&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 65&#xA;                        }, {&#xA;                            &amp;quot;country&amp;quot;: &amp;quot;Belgium&amp;quot;,&#xA;                                &amp;quot;litres&amp;quot;: 50&#xA;                        }],&#xA;                        titleField: &amp;quot;country&amp;quot;,&#xA;                        valueField: &amp;quot;litres&amp;quot;,&#xA;                        balloonText: &amp;quot;[[title]]&amp;lt;br&amp;gt;&amp;lt;span style=&#39;font-size:14px&#39;&amp;gt;&amp;lt;b&amp;gt;[[value]]&amp;lt;/b&amp;gt; ([[percents]]%)&amp;lt;/span&amp;gt;&amp;quot;,&#xA;                        legend: {&#xA;                            align: &amp;quot;center&amp;quot;,&#xA;                            markerType: &amp;quot;circle&amp;quot;&#xA;                        }&#xA;&#xA;                    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;习惯&#34;&gt;&#xA;  习惯&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b9%a0%e6%83%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;命名方式规律&#xA;        jquery.插件名.功能名.js&#xA;        &#xA;存储&#xA;        网站js/下        分子文件夹存放不同插件的文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;自定义&#34;&gt;&#xA;  自定义&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;函数&#xA;        jQuery.extend(object);          # 直接调用&#xA;        jQuery.fn.extend(object);      # 对象调用 $.extend($.fn,{})或$fn.extend({})&#xA;例子&#xA;        $.extend({&#xA;                max : function(a, b) {&#xA;                        return a &amp;gt; b ? a : b;&#xA;                },&#xA;                min : function(a, b) {&#xA;                        return a &amp;lt; b ? a : b;&#xA;                }&#xA;        });&#xA;        $.fn.extend({&#xA;                max1 : function(a, b) {&#xA;                        return a &amp;gt; b ? a : b;&#xA;                }&#xA;        });&#xA;        $.extend($.fn, {&#xA;                min1 : function(a, b) {&#xA;                        return a &amp;lt; b ? a : b;&#xA;                }&#xA;        })&#xA;        alert($.max(1, 2));&#xA;        alert($(&amp;quot;html&amp;quot;).max1(2, 1));&#xA;        alert($(&amp;quot;html&amp;quot;).min1(1, 2));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;问题&#34;&gt;&#xA;  问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;页面中引用jquery&#xA;        只能用&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;的形式，而不能用&amp;lt;script/&amp;gt;的形式&#xA;        引用的src必须写相对路径&#xA;        引用的&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;代码必须写在使用之前&#xA;        webroot/web-inf/不能用相对路径访问webRoot/下的文件，所以不能包含jquery文件。所以要用${pageContext.request.contextPath}/来访问&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jquery-mobile&#34;&gt;&#xA;  jquery mobile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jquery-mobile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>React</title>
      <link>https://runout.run/docs/middleware/library_frontend/react/</link>
      <pubDate>Thu, 11 Oct 2018 07:32:08 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/react/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;facebook推出的用于build user interfaces 的类库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; webpack&#xA;# webpack.config.js&#xA;var webpack = require(&#39;webpack&#39;)&#xA;module.exports = {&#xA;        devtool: &#39;inline-source-map&#39;,&#xA;        entry: [&#39;webpack/hot/dev-server&#39;, __dirname + &#39;/app/main.js&#39;],&#xA;        output: {&#xA;                path: __dirname + &#39;/build&#39;,&#xA;                filename: &#39;bundle.js&#39;&#xA;        },&#xA;        module: {&#xA;                loaders: [&#xA;                        {&#xA;                                test: /\.(js|jsx)$/,&#xA;                                exclude: /node_modules/,&#xA;                                loader: &#39;babel-loader&#39;,&#xA;                        }&#xA;                ]&#xA;        },&#xA;        plugins: [&#xA;                new webpack.HotModuleReplacementPlugin(),&#xA;                new webpack.DefinePlugin({&#xA;                        &#39;process.env&#39;: {&#xA;                                NODE_ENV: JSON.stringify(&#39;production&#39;)&#xA;                        }&#xA;                })&#xA;        ],&#xA;        devServer: {&#xA;                contentBase: __dirname + &#39;/build&#39;,&#xA;                historyApiFallback: true,&#xA;                inline: true,&#xA;                port: 3031,&#xA;        }&#xA;}&#xA;&#xA;# index.html&#xA;&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;&amp;lt;script src=&amp;quot;bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&#xA;&#xA;o-&amp;gt; browser&#xA;# index.html&#xA;&amp;lt;script src=&amp;quot;build/react.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;build/react-dom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;script src=&amp;quot;browser.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;        &amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;        &amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt;&#xA;                ReactDOM.render(&#xA;                        &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&#xA;                        document.getElementById(&#39;example&#39;)&#xA;                )&#xA;        &amp;lt;/script&amp;gt;&#xA;&amp;lt;/body&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ReactDOM&#xA;        render&#xA;                render(&#xA;                        &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&#xA;                        document.getElementById(&#39;example&#39;)&#xA;                )&#xA;React&#xA;        # createClass&#xA;        createClass({&#xA;                getInitialState () {return {liked: false}},&#xA;                handleClick(event) {&#xA;                        this.setState({liked: !this.state.liked})&#xA;                },&#xA;                getDefaultProps () {&#xA;                        # 设定属性默认值&#xA;                        return {title: &#39;Hello&#39;}&#xA;                },&#xA;                propTypes: {&#xA;                        # 限定属性的类型&#xA;                        title: React.PropTypes.string,isRequired&#xA;                },&#xA;                render () {return &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;}&#xA;        })&#xA;        # createElement&#xA;        createElement(&#39;h1&#39;, {title: &#39;a&#39;}, &#39;b&#39;)&#xA;        # Component&#xA;        class List extends React.Component{&#xA;                constructor() {super()}&#xA;                render() {return ()}&#xA;        }&#xA;        &#xA;this&#xA;        # 代表当前标签&#xA;        props&#xA;                # 属性&#xA;                children&#xA;                        # 代表所有子节点的text&#xA;                        # 没有子节点, 是undefined, 有一个子节点, 是Object, 多个子节点是array&#xA;                        # React.Children来处理children&#xA;        refs&#xA;                # 获取dom&#xA;        state&#xA;jsx&#xA;    介绍&#xA;            &amp;lt; 开头解析为html, { 开头解析为js&#xA;    例子&#xA;    # Profile.jsx&#xA;    import React from &#39;react&#39;;&#xA;    export default Class Profile extends React.Component {&#xA;            constructor (props) {&#xA;                    super(props)&#xA;                    this.state = {&#xA;                            list: [1,2,3],&#xA;                            activeIndex: -1&#xA;                    }&#xA;            },&#xA;            activate (index) {&#xA;                    this.setState({activeIndex: index})&#xA;            },&#xA;            render () {&#xA;                    const {list, activeIndex} = this.state&#xA;                    const lis = list.map((item, index) =&amp;gt; {&#xA;                            const cls = index === activeIndex ? &#39;active&#39; : &#39;&#39;&#xA;                            return (&#xA;                                    &amp;lt;li key={index} className={cls} onClick={() =&amp;gt; this.activate(index)}&amp;gt;&amp;lt;/li&amp;gt;&#xA;                            )&#xA;                    })&#xA;                    return (&amp;lt;ul&amp;gt;{lis}&amp;lt;/ul&amp;gt;)&#xA;            }&#xA;    }&#xA;&#xA;&#xA;    o-&amp;gt;&#xA;    &amp;lt;div&amp;gt;&#xA;    {/*注释*/}&#xA;    {&#xA;            names.map((name) =&amp;gt; {return &amp;lt;div&amp;gt;{name}&amp;lt;/div&amp;gt;})&#xA;    }&#xA;    &amp;lt;/div&amp;gt;&#xA;&#xA;    o-&amp;gt; ref&#xA;    &amp;lt;input ref=&amp;quot;domNam&amp;quot;&amp;gt;&#xA;&#xA;    o-&amp;gt; 事件&#xA;    &amp;lt;p onClick={this.handleClick}&amp;gt;&#xA;&#xA;    o-&amp;gt; 属性&#xA;    &amp;lt;Profile {...props} name=&#39;a&#39;&amp;gt;&#xA;            # 后面的覆盖前面的&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;react-big-calendar&#xA;    日历&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;JSXTransformer&#xA;        # 浏览器中引入，编译jsx&#xA;https://babeljs.io/repl/&#xA;        # 在线编译jsx&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>前端</title>
      <link>https://runout.run/docs/middleware/library_frontend/</link>
      <pubDate>Wed, 10 Oct 2018 14:51:24 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/library_frontend/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;AJAX&#xA;    # Asynchronous JavaScript and XML&#xA;    特点&#xA;        异步，提升了用户体验&#xA;            局部刷新&#xA;        优化传输，减少了数据和带宽&#xA;        客户端运行，承担服务器压力&#xA;    XMLHttpRequest&#xA;        # IE5首次引入&#xA;        readyState&#xA;            0 未初始化, 1 正在加载, 2 已加载, 3 交互中, 4 完成&#xA;        status      # 服务器http状态码&#xA;        responseXML     # 响应结果，表示为xml&#xA;        responseText    # 响应结果，表示为串&#xA;        open(&amp;quot;method&amp;quot;, url)&#xA;        send()&#xA;        abort()     # 停止当前请求&#xA;&#xA;        创建&#xA;            new ActiveXObject()     # IE&#xA;            new XMLHttpRequest()        # firefox&#xA;        callback种类&#xA;            onSuccess&#xA;            onFailure&#xA;            onUninitialized&#xA;            onLoading&#xA;            onLoaded&#xA;            onInteractive&#xA;            onComplete&#xA;            onException&#xA;jsonp&#xA;    来源&#xA;        js在浏览器有同源策略(Same-Origin Policy), 只访问同一域下文件&#xA;        &amp;lt;script&amp;gt;标签没有同源策略限制&#xA;    原理&#xA;        编程时&#xA;            客户端注册callback f(), 名字传给服务器&#xA;            跨域服务器以文本方式写js函数, 并构造应传的json数据, 函数中调用f(json)&#xA;        运行时&#xA;            动态添加&amp;lt;script&amp;gt;标签, 请求跨域服务器的js函数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;开发框架&#34;&gt;&#xA;  开发框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;模块化&#34;&gt;&#xA;  模块化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;bower&#xA;browserify&#xA;require.js&#xA;mod.js&#xA;        # 百度模块化开发工具&#xA;curl.js&#xA;        # amd load&#xA;sea.js&#xA;when&#xA;        # amd 加载&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;测试&#34;&gt;&#xA;  测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;vConsole    # APP HTML页面显示console按钮，打印请求参数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;bigpipe&#34;&gt;&#xA;  bigpipe&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bigpipe&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    facebook的页面异步加载框架&#xA;    不同于ajax的http调用，需要更多的网线连接。bigpipe与当前页面共用http连接&#xA;&#xA;使用&#xA;    前端&#xA;        &amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;script src=&amp;quot;underscore.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;script src=&amp;quot;bigpipe.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;div id=&amp;quot;body&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;        &amp;lt;script type=&amp;quot;text/template&amp;quot; id=&amp;quot;tpl_body&amp;quot;&amp;gt;&#xA;                &amp;lt;div&amp;gt;&amp;lt;%=articles%&amp;gt;&amp;lt;/div&amp;gt;&#xA;        &amp;lt;/script&amp;gt;&#xA;        &amp;lt;script&amp;gt;&#xA;        var bigpipe = new Bigpipe()&#xA;        bigpipe.ready(&#39;articles&#39;, function(data) {&#xA;                $(&#39;#body&#39;).html(_.render($(&#39;#tpl_body&#39;).html(), {articles: data}))&#xA;        })&#xA;        &amp;lt;/script&amp;gt;&#xA;&#xA;    服务器端&#xA;        app.get(&#39;/profile&#39;, function (req, res) {&#xA;            if (!cache[layout]) {&#xA;                    cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), &#39;utf8&#39;)&#xA;            }&#xA;            res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;})&#xA;            res.write(render(complie(cache[layout])))&#xA;            ep.all(&#39;users&#39;, &#39;articles&#39;, function () {&#xA;                    res.end()&#xA;            })&#xA;            ep.fail(function(err) {&#xA;                    res.end()&#xA;            })&#xA;            db.getData(&#39;sql1&#39;, function (err, data) {&#xA;                    data = err ? {} : data&#xA;                    res.write(&#39;&amp;lt;script&amp;gt;bigpipe.set(&amp;quot;articles&amp;quot;, &#39; + JSON.stringify(data) + &#39;);&amp;lt;/script&amp;gt;&#39;)&#xA;            })&#xA;        })&#xA;&#xA;    nodejs使用&#xA;        &#39;use strict&#39;&#xA;        var BigPipe = require(&#39;bigpipe&#39;);&#xA;        var bigpipe = BigPipe.createServer(8080, {&#xA;            pagelets: __dirname + &#39;/pagelets&#39;,&#xA;                # 页面路径&#xA;            dist: __dirname + &#39;/dist&#39;&#xA;                # 静态资源路径&#xA;        });&#xA;        o-&amp;gt; 开启https&#xA;        var bigpipe = BigPipe.createServer(443, {&#xA;            key: fs.readFileSync(__dirname + &#39;/ssl.key&#39;, &#39;utf-8&#39;),&#xA;            cert: fs.readFileSync(__dirname + &#39;/ssl.cert&#39;, &#39;utf-8&#39;)&#xA;        });&#xA;        o-&amp;gt; 嫁接&#xA;        var server = require(&#39;http&#39;).createServer(),&#xA;            BigPipe = require(&#39;bigpipe&#39;);&#xA;        var bigpipe = new BIgPipe(server, {options});&#xA;        bigpipe.listen(8080, function listening(){&#xA;            console.log(&#39;listening on port 8080.&#39;);&#xA;        });&#xA;&#xA;        bigpipe.define(&#39;../pagelets&#39;, function done(err){&#xA;        });        # 合并pagelets, 结束后调用done&#xA;        o-&amp;gt; AMD 方式define，与链式编程&#xA;        bigpipe.define([Pagelet1, Pagelet2, Pagelet3], function done(err){&#xA;        }).define(&#39;../more/pagelets&#39;, function done(err){});&#xA;        # bigpipe.before来添加中间件, remove来删除中间件, disable、enable来跳过和重新启用中间件&#xA;        # bigpipe.use来引用插件&#xA;api&#xA;    BigPipe所有组件继承EventEmitter interface&#xA;功能&#xA;    pagelets&#xA;        var Pagelet = require(&#39;bigpipe&#39;).Pagelet;&#xA;                # var Pagelet = require(&#39;pagelet&#39;);&#xA;        Pagelet.extend({&#xA;                js: &#39;client.js&#39;,&#xA;                css: &#39;sidebar.styl&#39;,&#xA;                view: &#39;templ.jade&#39;,&#xA;                name: &#39;sidebar‘,            // 唯一路由路径&#xA;                get: function get(){&#xA;                        // 接收get请求时的业务逻辑&#xA;                }&#xA;        }).on(module);&#xA;                # 自动写 module.export部分来导出&#xA;        # traverse方法自动调用来递归找additional child pagelets, 要手动指定名称时手动调用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;脚手架&#34;&gt;&#xA;  脚手架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%84%9a%e6%89%8b%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;yeoman&#xA;        # google和外部贡献团队合作开发，通过grunt和bower包装一个易用的工作流。由yo(脚手架), grunt(构建), bower(包管理)三部分组成&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;webpack&#34;&gt;&#xA;  webpack&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#webpack&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 介绍&#xA;        模块打包&#xA;&#xA;# 命令&#xA;        npm i -g webpack&#xA;        npm i css-loader style-loader&#xA;        webpack ./entry.js bundle.js&#xA;                # --progress&#xA;                # --colors&#xA;                # --watch&#xA;                # --module-bind&#xA;                ## jade, &#39;css=style!css&#39;&#xA;                webpack ./entry.js bundle.js --module-bind &#39;css=style!css&#39;&#xA;                webpack&#xA;                        # use webpack.config.js&#xA;        npm i webpack-dev-server -g&#xA;        webpack-dev-server&#xA;                # --progress --colors&#xA;                # --hot 热部署&#xA;                # 启动一个express在8080端口&#xA;# 配置&#xA;    # webpack.config.js&#xA;&#xA;    var webpack = require(&#39;webpack&#39;)&#xA;    var merge = require(&#39;webpack-merge&#39;)&#xA;    var path = require(&#39;path&#39;)&#xA;    var HtmlwebpackPlugin = require(&#39;html-webpack-plugin&#39;)&#xA;&#xA;    var ROOT_PATH = path.resolve(__dirname)&#xA;    var APP_PATH = path.resolve(ROOT_PATH, &#39;app&#39;)&#xA;    var BUILD_PATH = path.resolve(ROOT_PATH, &#39;build&#39;)&#xA;&#xA;    var baseWebpackConfig = {&#xA;            entry: {&#xA;                    app: path.resolve(APP_PATH, &#39;app.jsx&#39;)&#xA;            },&#xA;            output: {&#xA;                    path: BUILD_PATH,&#xA;                    filename: &#39;[name].js&#39;,&#xA;                        chunkFilename: &#39;[id].chunk.js&#39;,&#xA;                    publicPath: &#39;/&#39;,&#xA;                            # 浏览器路径&#xA;            },&#xA;            devtool: &#39;eval-source-map&#39;,&#xA;            devServer: {&#xA;                contentBase: path.resolve(ROOT_PATH, &#39;build&#39;) ,&#xA;                historyApiFallback: true,&#xA;                inline: true,&#xA;                port: 3031&#xA;        }&#xA;            resolve: {&#xA;                    extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.vue&#39;, &#39;jsx&#39;],&#xA;                        # 这样可以在js import 中加载扩展名&#xA;                    fallback: [path.join(__dirname, &#39;../node_modules&#39;)],&#xA;                    alias: {&#xA;                            &#39;src&#39;: path.resolve(__dirname, &#39;../src&#39;),&#xA;                            &#39;assets&#39;: path.resolve(_dirname, &#39;../src/assets&#39;),&#xA;                            &#39;components&#39;: path.resolve(__dirname, &#39;../src/components&#39;)&#xA;                    }&#xA;            },&#xA;            resolveLoader: {&#xA;                    fallback: [path.join(__dirname, &#39;../node_modules&#39;)]&#xA;            },&#xA;            module: {&#xA;                preLoaders: [&#xA;                        {&#xA;                                test: /\.jsx?$/,&#xA;                                loaders: [&#39;eslint&#39;],&#xA;                                include: APP_PATH&#xA;                        }&#xA;                ]&#xA;                    loaders: [&#xA;                    {&#xA;                            test: /\.vue$/,&#xA;                            loader: &#39;vue&#39;&#xA;                    },&#xA;                    {&#xA;                            test: /\.js$/,&#xA;                            loader: &#39;babel&#39;,&#xA;                            include: projectRoot,&#xA;                            exclude: /node_modules/&#xA;                    },&#xA;                    {&#xA;                            test: /\.json$/,&#xA;                            loader: &#39;json&#39;&#xA;                    },&#xA;                    {&#xA;                            test: /\.html$/,&#xA;                            loader: &#39;vue-html&#39;&#xA;                    },&#xA;                    {&#xA;                            test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,&#xA;                            loader: &#39;url&#39;,&#xA;                            query: {&#xA;                                    limit: 10000,&#xA;                                    name: path.posix.join(&#39;static&#39;, &#39;img/[name].[hash:7].[ext]&#39;)&#xA;                            }&#xA;                    },&#xA;                    {&#xA;                            test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,&#xA;                            loader: &#39;url&#39;,&#xA;                            query: {&#xA;                                    limit: 10000,&#xA;                                    name: path.posix.join(&#39;static&#39;, &#39;fonts/[name].[hash:7].[ext]&#39;)&#xA;                            }&#xA;                    }&#xA;                    ]&#xA;            },&#xA;        plugins: [&#xA;                    new HtmlwebpackPlugin({title: &#39;a&#39;})&#xA;            ]&#xA;    }&#xA;    module.exports = merge(baseWebpackConfig, {&#xA;    })&#xA;# 插件&#xA;    内置&#xA;            # 通过webpack.BannerPlugin获得&#xA;            bannerPlugin&#xA;    htmlWebpackPlugin&#xA;    hotModuleReplacement&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;grunt&#34;&gt;&#xA;  grunt&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#grunt&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        压缩js代码&#xA;        合并js文件&#xA;        单元测试&#xA;        js代码检查&#xA;        监控文件修改重启任务&#xA;命令&#xA;        grunt dist&#xA;                # 重新生成dist目录，将编译后的css,js放入&#xA;        grunt watch&#xA;                # 监测less源码文件改动，自动重新编译为css&#xA;        grunt test&#xA;                # 运行测试用例&#xA;        grunt docs&#xA;                # 编译并测试&#xA;        grunt 重新构建所有内容并运行测试用例&#xA;安装&#xA;        # grunt模块以grunt-contrib-开头&#xA;        npm i -g grunt grunt-init grunt-cli&#xA;&#xA;例子&#xA;    o-&amp;gt;&#xA;    // Gruntfile.js&#xA;    module.exports = function (grunt) {&#xA;            grunt.loadNpmTasks(&#39;grunt-contrib-clean&#39;)&#xA;            grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;)&#xA;            grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;)&#xA;            grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;)&#xA;            grunt.loadNpmTasks(&#39;grunt-replace&#39;)&#xA;&#xA;            grunt.initConfig({&#xA;                    pkg: grunt.file.readJSON(&#39;package.json&#39;),&#xA;                    jshint: {&#xA;                            all: {&#xA;                                    src: [&#39;Gruntfile.js&#39;, &#39;src/**/*.js&#39;, &#39;test/**/*.js&#39;],&#xA;                                    options: {&#xA;                                            jshintrc: &#39;jshint.json&#39;&#xA;                                    }&#xA;                            }&#xA;                    },&#xA;                    clean: [&#39;lib&#39;],&#xA;                    concat: {&#xA;                            htmlhint: {&#xA;                                    src: [&#39;src/core.js&#39;, &#39;src/reporter.js&#39;, &#39;src/htmlparser.js&#39;, &#39;src/rules/*.js&#39;],&#xA;                                    dest: &#39;lib/htmlhint.js&#39;&#xA;                            }&#xA;                    },&#xA;                    uglify: {&#xA;                            htmlhint: {&#xA;                                    options: {&#xA;                                            banner: &#39;a&#39;,&#xA;                                            beautify: {&#xA;                                                    ascii_only: true&#xA;                                            }&#xA;                                    },&#xA;                                    files: {&#xA;                                            &#39;lib/&amp;lt;%= pkg.name %&amp;gt;.js&#39;: [&#39;&amp;lt;%= concat.htmlhint.dest %&amp;gt;&#39;]&#xA;                                    }&#xA;                            }&#xA;                    },&#xA;                    relace: {&#xA;                            htmlhint: {&#xA;                                    files: {&#39;lib/htmlhint.js&#39;: &#39;lib/htmlhint.js&#39;},&#xA;                                    options: {&#xA;                                            prefix: &#39;@&#39;,&#xA;                                            variables: {&#xA;                                                    &#39;VERSION&#39;: &#39;&amp;lt;%= pkg.version %&amp;gt;&#39;&#xA;                                            }&#xA;                                    }&#xA;                            }&#xA;                    }&#xA;            })&#xA;            grunt.registerTask(&#39;dev&#39;, [&#39;jshint&#39;, &#39;concat&#39;])&#xA;            grunt.registerTask(&#39;default&#39;, [&#39;jshint&#39;, &#39;clean&#39;, &#39;concat&#39;, &#39;uglify&#39;, &#39;replace&#39;])&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;gulp&#34;&gt;&#xA;  gulp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gulp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        自动化构建项目工具&#xA;使用&#xA;    安装&#xA;            npm install --global gulp&#xA;                    # npm install --save-dev gulp&#xA;            // gulpfile.js 在项目根目录&#xA;            var gulp = require(&#39;gulp&#39;);&#xA;            gulp.task(&#39;default&#39;, function () {&#xA;                    // 默认任务代码&#xA;            })&#xA;    命令&#xA;            shell&amp;gt; gulp&#xA;                    # gulp &amp;lt;task&amp;gt; &amp;lt;othertask&amp;gt;&#xA;插件&#xA;    gulp-dom-src&#xA;            合并src, 改写html&#xA;    gulp-if&#xA;    gulp-useref&#xA;    gulp-usemin&#xA;    gulp-htmlreplace&#xA;    google-closure-compiler&#xA;    gulp-add-src&#xA;    gulp-autoprefixer&#xA;    gulp-changed&#xA;    gulp-clean&#xA;    gulp-clean-css&#xA;    gulp-concat&#xA;    gulp-concat-css&#xA;    gulp-consolidate&#xA;    gulp-html-replace&#xA;            # 替换html内容&#xA;    gulp-htmlmin&#xA;    gulp-imagemin&#xA;    gulp-less&#xA;    gulp-make-css-url-version&#xA;    gulp-minify-css&#xA;    gulp-rev-append&#xA;    gulp-uglify&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;fis&#34;&gt;&#xA;  fis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        npm的形式发布&#xA;        百度前端工具框架，为前端开发提供底层架构&#xA;        所有js文件都用模块书写，一个文件一个模块&#xA;                F.module(name, function(require, exports){}, deps);&#xA;&#xA;安装&#xA;        npm install -g fis&#xA;命令&#xA;    fis install                        # 安装模块&#xA;    fis release                        # 编译和发布, -h 查看帮助&#xA;                            ## 默认会调整资源引用的相对路径到绝对路径&#xA;                            ### 不想对路径做调整，可以使用spt工具https://github.com/fouber/spt&#xA;                            ## --optimize 或 -o 压缩。--md5对不同静态资源生成版本，也可以配置时间戳&#xA;                            ## --dest 或 -d。指定项目发布配置，在执行编译后发布。可以远程发布、发布多个&#xA;                            ## --pack 开启打包处理&#xA;                            ## -omp 简化 --optimize --md5 --pack&#xA;                            ## --watch 或 -w 自动监听文件修改，自动编译&#xA;                            ### 该监视考虑了各种嵌入关系, a.css中嵌入了b.css, b修改时会重构这两个文件&#xA;                            ### --live 或 -L 。在-w基础上实现，监视到修改后自动刷新浏览器页面&#xA;    fis server start                # 启动本地调试服务器&#xA;                            ## -p [port] 指定新端口&#xA;                            ## --type node 如果没有java, php环境，指定用node环境启动&#xA;    fis server stop&#xA;    fis server open                # 查看默认产出目录&#xA;配置&#xA;    o-&amp;gt;&#xA;    fis.config.set(&#39;pack&#39;, {&#xA;            &#39;pkg/lib.js&#39;: [&#xA;                    &#39;/lib/mod.js&#39;,&#xA;                    &#39;/modules/underscore/**.js&#39;,&#xA;                    &#39;modules/backbone/**.js&#39;&#xA;            ]&#xA;    });                # 文件合并成lib.js，但是不替换页面中的静态资源引用&#xA;                    ## 为了替换引用，使用fis的后端静态资源管理来加载引用，或者用fis-postpackager-simple插件&#xA;    o-&amp;gt;&#xA;    fis.config.set(&#39;roadmap.path&#39;, [{&#xA;            reg: &#39;**.css&#39;,&#xA;            useSprite: true&#xA;    }]);                # 为所有样式资源开启csssprites, 该插件在fis中内置&#xA;    fis.config.set(&#39;settings.spriter.csssprites.margin&#39;, 20);                # 设置图片合并间距&#xA;                                                    ## 要在要合并的图片引用路径后面加?__sprite来标识&#xA;                                                    ## 被合并图片中的小图, background-position来分图的情况也支持&#xA;组件&#xA;    yogurt&#xA;        基于express 的nodejs框架&#xA;    fis-plus&#xA;        fis + php + smarty&#xA;    gois&#xA;        fis + go + margini&#xA;    jello&#xA;        fis + java + velocity&#xA;    pure&#xA;        纯前端框架&#xA;&#xA;插件&#xA;    fis-postpackager-simple&#xA;        介绍&#xA;                fis-plus和yogurt不需要&#xA;        安装&#xA;                npm install -g fis-postpackager-simple&#xA;        配置&#xA;                // fis-conf.js&#xA;                fis.config.set(&#39;modules.postpackager&#39;, &#39;simple&#39;);                        # 打包时自动更改静态资源引用&#xA;                fis.config.set(&#39;settings.postpackager.simple.autoCombine&#39;, true)        # 开启按页面自动合并css, js文件&#xA;    fis-parser-less&#xA;        介绍&#xA;                less模板&#xA;                npm install -g fis-parser-less&#xA;        配置&#xA;                fis.config.set(&#39;modules.parser.less&#39;, &#39;less&#39;);&#xA;                        # &#39;modules.parser.less&#39;表示后缀名less的文件，&#39;less&#39;表示用fis-parser-less编译&#xA;                fis.config.set(&#39;roadmap.ext.less&#39;, css)&#xA;                        # 将less文件编译为css&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;写法&#34;&gt;&#xA;  写法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%99%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;jquery&#xA;prototype&#xA;    $()     # 简写document.getElementById()&#xA;    $F()    # 返回表单&#xA;    $A()    # 参数转成数组对象&#xA;mootools&#xA;    # 浏览器原生对象扩展&#xA;underscore&#xA;    # 函数式&#xA;underscore-contrib&#xA;    # 扩展underscore&#xA;ramda&#xA;    # 函数式，较正确&#xA;lodash&#xA;    # 函数式&#xA;functional javascript&#xA;bilby&#xA;    # 函数式库，包含dispatch, 蹦床, monadic, validator等&#xA;allong.es&#xA;    # 提供函数组合子&#xA;sweet&#xA;    # 支持宏&#xA;zepto&#xA;    # 小型jquery&#xA;kissy&#xA;    # 小型jquery&#xA;rxjs&#xA;    # 微软开发，将异步流捕获成值的库&#xA;tangram&#xA;    # 百度前端工具集&#xA;qwrap&#xA;    # 360前端工具集&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;解释器&#34;&gt;&#xA;  解释器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%87%8a%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;typescript&#xA;    # 扩展语言&#xA;coffeescript&#xA;    # 扩展语言&#xA;system.js&#xA;    介绍&#xA;        一个垫片库, 浏览器端l加载es6模块、AMD模块、CommonJS模块 到es5。内部调用traceur&#xA;&#xA;    &amp;lt;script src=&#39;system.js&#39;&amp;gt;&amp;lt;/script&amp;gt;&#xA;    &amp;lt;script&amp;gt;&#xA;        System.import(&#39;./app&#39;).then(function(m) {&#xA;            # app.js是一个es6模块&#xA;            m.f()&#xA;        })&#xA;    &amp;lt;/script&amp;gt;&#xA;traceur&#xA;    介绍&#xA;        在线转换，将ES6代码编译为ES5&#xA;    使用&#xA;        npm install -g traceur&#xA;        traceur /path/es6                                # 运行ES6文件&#xA;        traceur --script /path/es6 --out /path/es5        # 转换&#xA;babel&#xA;    使用&#xA;        npm install -g babel-cli&#xA;        npm install --save babel-core babel-preset-es2015&#xA;        // .babelrc&#xA;        {&#xA;            &amp;quot;presets&amp;quot;: [&amp;quot;es2015&amp;quot;],&#xA;            &amp;quot;env&amp;quot;: {&#xA;                &amp;quot;dev&amp;quot;: {&#xA;                    # 在NODE_ENV=dev时使用特性&#xA;                    &amp;quot;presets&amp;quot;: [&amp;quot;react-hmre&amp;quot;]&#xA;                }&#xA;            }&#xA;        }&#xA;        babel-node&#xA;        babel es6.js&#xA;            # babel es6.js -o es5.js&#xA;            # babel -d build source -s&#xA;            ## -s 是产生source-map&#xA;    插件&#xA;        babel-preset-react-hmre&#xA;            # react热加载&#xA;            .babelrc中配置 &amp;quot;react-hmre&amp;quot;&#xA;transpiler&#xA;    介绍&#xA;        google的es6模块加载转为CommonJS或AMD模块加载的工具&#xA;    使用&#xA;        npm install -g es6-module-transpiler&#xA;        compile-modules convert es6.js es5.js&#xA;            # compile-modules convert -o out.js file1.js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据绑定&#34;&gt;&#xA;  数据绑定&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;mobx&#xA;    # 状态管理，应用(ui, 数据, 服务器)状态可自动获得&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;终端&#34;&gt;&#xA;  终端&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%88%e7%ab%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;跨平台&#34;&gt;&#xA;  跨平台&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b7%a8%e5%b9%b3%e5%8f%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;atom electron&#xA;node-webkit&#xA;atom-shell&#xA;nw.js&#xA;polymer&#xA;    # 构建在底层的html扩展，构建跨desktop, mobile等平台的web应用&#xA;mpx&#xA;    # 小程序框架&#xA;wepy&#xA;    # 小程序&#xA;taro&#xA;    # 生成多端&#xA;chameleon&#xA;uniapp&#xA;    # vue到多端&#xA;mpvue&#xA;    # vue小程序&#xA;megalo&#xA;    # vue小程序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;运行时跨平台&#34;&gt;&#xA;  运行时跨平台&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e8%b7%a8%e5%b9%b3%e5%8f%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;微信小程序&#xA;华为快应用&#xA;react native&#xA;rax&#xA;weex&#xA;fuse&#xA;nativeScript&#xA;tabris&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;android&#34;&gt;&#xA;  android&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#android&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;结构&#xA;    applications:                                                        如browser&#xA;    application framework(相当于api):                        如window manager&#xA;    libraries(库):                                                        如openGL,SQLite&#xA;            runtime(运行环境):                                                core libraries + Dalvik VM&#xA;    linux kernel(系统api):                                        如wifi Driver&#xA;android sdk&#xA;    命令&#xA;        platform-tools/adb&#xA;            adb install *.apk                                      # 当前模拟器中安&#xA;    装软件&#xA;&#xA;            adb remount&#xA;            adb shell&#xA;            su                                                      # 当前模拟器中执&#xA;    行linux命令&#xA;&#xA;        tools/emulator-arm @test                                    # 启动一个模拟器&#xA;框架&#xA;    atlas&#xA;        # 阿里开源的android native容器化组件框架&#xA;    webview&#xA;    litho&#xA;        # 声明式ui&#xA;    jetpack compose&#xA;        # 声明式ui&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;ios&#34;&gt;&#xA;  ios&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ios&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;componentKit&#xA;    # 声明式ui&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;功能&#34;&gt;&#xA;  功能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%9f%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;格式&#34;&gt;&#xA;  格式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%bc%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uglifyjs2&#xA;    # 序列化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模板&#34;&gt;&#xA;  模板&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e6%9d%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    引擎的一个优点就是可以直接把数据渲染到js中使用&#xA;优点&#xA;    可以把动态页面的模板缓存起来，第一次请求之后，只需要更新数据&#xA;        # 应该可以后端nginx缓存静态模板来提高性能&#xA;&#xA;velocity&#xA;    # java模板&#xA;ejs&#xA;hogan.js&#xA;handlebars&#xA;    # 写法类似anglarjs模板&#xA;jstl&#xA;    # java模板&#xA;less&#xA;    # css模板&#xA;stylus&#xA;    # css模板&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;swig&#34;&gt;&#xA;  swig&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#swig&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;{% autoescape true %} {{ myvar }} {% endautoescape %}&#xA;&#xA;{% block body %} ... {% endblock %}&#xA;&#xA;{% if false %}&#xA;{% elseif true%}&#xA;{% else %}&#xA;{% endif %}&#xA;&#xA;{% extends &amp;quot;./layout.html&amp;quot; %}&#xA;&#xA;{% filter uppercase %} oh hi, {{ name }} {% endfilter %}                # =&amp;gt; OH HI, PAUL&#xA;{% filter replace(&amp;quot;.&amp;quot;, &amp;quot;!&amp;quot;, &#39;g&amp;quot;) %} Hi. My name is Paul. {% endfilter %}        # =&amp;gt; Hi! My name is Paul!&#xA;&#xA;{% for x in obj %}&#xA;        {% if loop.first %}&amp;lt;ul&amp;gt;{% endif %}&#xA;        &amp;lt;li&amp;gt;{{ loop.index }} - {{ loop.key }}: {{ x }}&amp;lt;/li&amp;gt;&#xA;        {% if loop.last %}&amp;lt;/ul&amp;gt;{% endif %}&#xA;{% endfor %}&#xA;{% for key, val in arr|reverse %}&#xA;{{ key }} -- {{ val }}&#xA;{% endfor %}&#xA;&#xA;{% import &#39;./formmacros.html&#39; as forms %}&#xA;{{ form.input(&amp;quot;text&amp;quot;, &amp;quot;name&amp;quot;) }}                        # =&amp;gt; &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot;&amp;gt;&#xA;{% import &amp;quot;../shared/tags.html&amp;quot; as tags%}&#xA;{{ tags.stylesheet(&#39;global&#39;)}}                        // =&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/global.css&amp;quot;&amp;gt;&#xA;&#xA;{% include &amp;quot;./partial.html&amp;quot; %}&#xA;{% include &amp;quot;./partial.html&amp;quot; with my_obj only%}&#xA;{% include &amp;quot;/this/file/does/not/exist&amp;quot; ignore missing%}&#xA;&#xA;{% macro input(type, name, id, label, value, error)%}&#xA;        &amp;lt;label for=&amp;quot;{{ name }}&amp;quot;&amp;gt;{{ label }}&amp;lt;/label&amp;gt;&#xA;        &amp;lt;input type=&amp;quot;{{ type }}&amp;quot; name=&amp;quot;{{ name }}&amp;quot; id=&amp;quot;{{ id }}&amp;quot; value=&amp;quot;{{ value }}&amp;quot; {% if error%} class=&amp;quot;error&amp;quot; {% endif %}&amp;gt;&#xA;{% endmacro %}&#xA;{{ input(&amp;quot;text&amp;quot;, &amp;quot;fname&amp;quot;,  &amp;quot;fname&amp;quot;, &amp;quot;First Name&amp;quot;, fname.value, fname.errors) }}&#xA;&#xA;{% extends &amp;quot;./foo.html&amp;quot; %}&#xA;{% block content %}&#xA;        My content&#xA;        {% parent %}&#xA;{% endblock %}&#xA;&#xA;{% raw %}{{ foobar }}{% endraw %}&#xA;&#xA;{% set foo = &amp;quot;anything!&amp;quot;%}&#xA;{{ foo }}&#xA;&#xA;{% spaceless %}&#xA;        {% for num in foo %}&#xA;        &amp;lt;li&amp;gt;{{ loop.index }}&amp;lt;/li&amp;gt;&#xA;        {% endfor %}&#xA;{% endspaceless %}                                # 除去空白&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;显示&#34;&gt;&#xA;  显示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%be%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;highcharts&#xA;nvd3.js&#xA;    # svg报表&#xA;echarts&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;d3&#34;&gt;&#xA;  d3&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#d3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    数据可视化, 使用svg, css3&#xA;使用&#xA;    node&#xA;        npm install d3&#xA;        //&#xA;        var d3 = require(&#39;d3&#39;), jsdom = require(&#39;jsdom&#39;);&#xA;        var document = jsdom.jsdom(),&#xA;            svg = d3.select(document.body).append(&#39;svg&#39;);&#xA;    web&#xA;        &amp;lt;script src=&amp;quot;//d3js.org/d3.v3.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;script&amp;gt;d3.version&amp;lt;/script&amp;gt;&#xA;d3对象&#xA;    // 选择器&#xA;    event&#xA;    mouse&#xA;    select&#xA;    selectAll&#xA;    selection&#xA;    touch&#xA;    touches&#xA;    // 过渡&#xA;    ease&#xA;            # ease对象&#xA;    timer&#xA;            flush&#xA;    interpolate&#xA;            # interpolate对象&#xA;    interpolateArray&#xA;    interpolateHcl&#xA;    interpolateHsl&#xA;    interpolateLab&#xA;    interpolateNumber&#xA;    interpolateObject&#xA;    interpolateRgb&#xA;    interpolateRound&#xA;    interpolateString&#xA;    interpolateTransform&#xA;    interpolateZoom&#xA;    interpolators&#xA;    transition&#xA;    // 数组&#xA;    ascending&#xA;    bisectLeft&#xA;    bisector&#xA;    bisectRight&#xA;    bisect&#xA;    descending&#xA;    deviation&#xA;    entries&#xA;    extent&#xA;    keys&#xA;    map&#xA;    max&#xA;    mean&#xA;    median&#xA;    merge&#xA;    min&#xA;    nest&#xA;    pairs&#xA;    permute&#xA;    quantile&#xA;    range&#xA;    set&#xA;    shuffle&#xA;    sum&#xA;    transpose&#xA;    values&#xA;    variance&#xA;    zip&#xA;    // 数学&#xA;    random&#xA;    transform&#xA;    // 请求&#xA;    csv&#xA;    html&#xA;    json&#xA;    text&#xA;    tsv&#xA;    xhr&#xA;    xml&#xA;    // 格式化&#xA;    format&#xA;    formatPrefix&#xA;    requote&#xA;    round&#xA;    // 本地化&#xA;    locale&#xA;    // 颜色&#xA;    hcl&#xA;    hsl&#xA;    lab&#xA;    rgb&#xA;    // 命名空间&#xA;    ns&#xA;    // 内部&#xA;    dispatch&#xA;    functor&#xA;    rebind&#xA;    // 比例尺&#xA;    scale&#xA;    // 时间&#xA;    time&#xA;    // 布局&#xA;    layout&#xA;    // 地理&#xA;    geo&#xA;    // 几何&#xA;    geom&#xA;    // 行为&#xA;    behavior&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;效果&#34;&gt;&#xA;  效果&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%88%e6%9e%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;touch.js&#xA;    # 触摸&#xA;move.js&#xA;    # div运动&#xA;swiper&#xA;    # 滑动效果&#xA;&#xA;cordova&#xA;    # 访问原生设备，如摄像头、麦克风等&#xA;egret.js&#xA;    # 使用TypeScript的HTML5开发引擎, 一套完整的HTML5游戏开发解决方案&#xA;tweenMax&#xA;    # 扩展TweenLite, 用于制作html5动画&#xA;juliusjs&#xA;    # 语音识别&#xA;babylon&#xA;    # microsoft webgl框架&#xA;cubicVR&#xA;    # 高性能webgl框架, paladin游戏引擎的一部分&#xA;scenejs&#xA;    # webgl模型&#xA;glge&#xA;    # webgl框架&#xA;pose&#xA;    # mvvm&#xA;react-motion&#xA;    # mvvm&#xA;react-transition-group&#xA;    # mvvm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;视频&#34;&gt;&#xA;  视频&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%86%e9%a2%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ezuikit&#xA;    # 萤石sdk, 直播, 监控, 支持多平台&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;应用框架&#34;&gt;&#xA;  应用框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;显示-1&#34;&gt;&#xA;  显示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%be%e7%a4%ba-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;bootstrap&#xA;flutter&#xA;    # google移动端框架, 声明式ui&#xA;extjs&#xA;    介绍&#xA;        2.0之前是免费的，但有内在泄漏总是&#xA;        GPLv3版本后收费&#xA;&#xA;    Sencha&#xA;        1.是ExtJS、jQTouch(一个用于手机浏览器的jquery插件) 以及 Raphael（一个网页上绘制矢量图形的js库） 三个项目合并而成的一个开源项目。&#xA;        2.Sencha Touch 是全球领先的应用程序开发框架，其设计旨在充分&#xA;            利用HTML5、CSS3 和Javascript 来实现最高级别的功能、灵活性和优化。&#xA;            Sencha Touch 是针对下一代具有触摸屏设备的跨平台框架。&#xA;jquery ui&#xA;dojo&#xA;    # 语法较难用&#xA;easy ui&#xA;    文件&#xA;        jquery.js&#xA;        easyui.js&#xA;        easyui-lang-zh_CN.js&#xA;        easyui.css&#xA;        icon.css&#xA;layui&#xA;    # 模块化ui&#xA;mini ui&#xA;    # 收费&#xA;wijmo&#xA;    # 收费&#xA;dwz&#xA;    # 卖文档&#xA;vaadin&#xA;    # apache webkit&#xA;foundation&#xA;    # 响应式，移动优先&#xA;boilerplate&#xA;    # h5模板&#xA;meteor&#xA;    # 融合前后端, 后端node&#xA;knockout&#xA;    # mvvm, 利于单页应用&#xA;&#xA;jingle&#xA;    # 手机&#xA;ionic&#xA;    # angular手机框架&#xA;framework7&#xA;    # ios(兼容android)组件&#xA;mui&#xA;    # 手机&#xA;zui&#xA;    # 手机，类bootstrap&#xA;frozenui&#xA;    # 手机&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数据可视化&#34;&gt;&#xA;  数据可视化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%8f%af%e8%a7%86%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;highcharts&#xA;chart.js&#xA;    # api不好用&#xA;three.js&#xA;d3&#xA;    # 太底层, 概念已陈旧&#xA;mapbox&#xA;    # 地图&#xA;echarts&#xA;    # 开源&#xA;recharts&#xA;    # 新出现&#xA;v-charts&#xA;    # vue+echarts, 饿了么开发&#xA;superset&#xA;    # apache&#xA;antv&#xA;    # 蚂蚁金服, 图表丰富&#xA;thingJS&#xA;    # 3d建模&#xA;cityBuilder&#xA;    # 3d建模&#xA;dataV&#xA;    # 收费, 阿里&#xA;sugar&#xA;    # 收费, 百度&#xA;云图&#xA;    # 收费, 腾讯&#xA;fineReport&#xA;    # 收费, 帆软, 大屏&#xA;tableau&#xA;    # 收费, 大屏&#xA;easyV&#xA;    # 收费, 袋鼠云&#xA;&#xA;gitDataV&#xA;    # https://github.com/HongqingCao/GitDataV&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;富应用&#34;&gt;&#xA;  富应用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%8c%e5%ba%94%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;react&#xA;angular&#xA;    # google开发, mvvm&#xA;    ng(core module)包含的核心组件&#xA;        directive   # 指令&#xA;            ngClick&#xA;            ngInclude&#xA;            ngRepeat&#xA;        service     # 服务, 依赖注入后使用&#xA;            $compile&#xA;            $http&#xA;            $location&#xA;        filter      # 过滤器，转换模板数据&#xA;            filter&#xA;            date&#xA;            currency&#xA;            lowercase&#xA;        function    # 函数&#xA;            angular.copy()&#xA;            angular.equals()&#xA;            angular.element()&#xA;    组件&#xA;        ngRoute     # url后#地址(hash) 来实现单面路由&#xA;            使用&#xA;                引入angular-route.js&#xA;                依赖注入ngRoute模块&#xA;            服务&#xA;                $routeParams    # 解析路由参数&#xA;                $route          # 构建url, view, controller的关系&#xA;                $routeProvider  # 配置&#xA;            指令&#xA;                ngView      # 路由模板插入视图&#xA;        ngAnimate   # 动画效果&#xA;            使用&#xA;                引入angular-animate.js&#xA;                注入ngAnimate&#xA;            服务&#xA;                $animate    # 触发&#xA;            css动画   # 用nganimate结构定义，通过引用css到html模板触发&#xA;            js动画    # 用module.animation注册，通过引用css到html模板触发&#xA;        ngResource  # 动画&#xA;        ngMock      # 动画&#xA;        ngTouch     # 触摸&#xA;        ngAria      # 帮助制作自定义模块&#xA;        ngCookies&#xA;riot&#xA;ember&#xA;vue&#xA;    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;        {{ message }}&#xA;    &amp;lt;/div&amp;gt;&#xA;&#xA;    var app = new Vue({&#xA;        el: &#39;#app&#39;,&#xA;        data: {&#xA;            message: &amp;quot;hi&amp;quot;&#xA;        },&#xA;        created: function () {}&#xA;    })&#xA;backbone&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;效果-1&#34;&gt;&#xA;  效果&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%88%e6%9e%9c-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;three.js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;createjs&#34;&gt;&#xA;  createjs&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#createjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# easeljs&#xA;    介绍&#xA;        处理canvas&#xA;    使用&#xA;        var stage = new createjs.Stage(&amp;quot;canvasName&amp;quot;);&#xA;        stage.x = 100;&#xA;        stage.y = 100;&#xA;        var text = new createjs.Text(&amp;quot;Hello&amp;quot;, &amp;quot;36px Arial&amp;quot;, &amp;quot;#777&amp;quot;);&#xA;        stage.addChild(text);&#xA;        stage.update();&#xA;# tweenjs&#xA;    介绍&#xA;        处理动画调整和js属性&#xA;    使用&#xA;        var circle = new createjs.Shape();&#xA;        circle.graphics.beginFill(&amp;quot;#FF0000&amp;quot;).drawCircle(0, 0, 50);&#xA;        stage.addChild(circle);&#xA;        createjs.Tween.get(circle, {loop: true})&#xA;            .wait(1000)&#xA;            .to({scaleX: 0.2, scaleY: 0.2})&#xA;            .wait(1000)&#xA;            .to({scaleX:1, scaleY:1}, 1000, createjs.Ease.bounceInOut)&#xA;        createjs.Ticker.setFPS(20);&#xA;        createjs.Ticker.addEventListener(&amp;quot;tick&amp;quot;, stage);&#xA;# soundjs&#xA;    介绍&#xA;        简化处理音频&#xA;    使用&#xA;        var displayStatus;&#xA;        displayStatus = document.getElementById(&amp;quot;status&amp;quot;);&#xA;        var src = &amp;quot;1.mp3&amp;quot;;&#xA;        createjs.Sound.alternateExtensions = [&amp;quot;mp3&amp;quot;];&#xA;        createjs.Sound.addEventListener(&amp;quot;fileload&amp;quot;, playSound());&#xA;        createjs.Sound.registerSound(src);&#xA;        displayStatus.innerHTML = &amp;quot;Waiting for load to complete&amp;quot;;&#xA;&#xA;        function playSound(event){&#xA;            soundIntance = createjs.Sound.play(event.src);&#xA;            displayStatus.innerHTML = &amp;quot;Playing source: &amp;quot; + event.src;&#xA;        }&#xA;&#xA;# preloadjs&#xA;    介绍&#xA;        协调程序加载项的类库&#xA;    使用&#xA;        var preload = new createjs.LoadQueue(false, &amp;quot;assets/&amp;quot;);&#xA;        var plugin= {&#xA;            getPreloadHandlers: function(){&#xA;                return{&#xA;                    types: [&amp;quot;image&amp;quot;],&#xA;                    callback: function(src){&#xA;                        var id = src.toLowerCase().split(&amp;quot;/&amp;quot;).pop().split(&amp;quot;.&amp;quot;)[0];&#xA;                        var img = document.getElementById(id);&#xA;                        return {tag: img};&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;        preload.installPlugin(plugin);&#xA;        preload.loadManifest([&#xA;            &amp;quot;Autumn.png&amp;quot;,&#xA;            &amp;quot;BlueBird.png&amp;quot;,&#xA;            &amp;quot;Nepal.jpg&amp;quot;,&#xA;            &amp;quot;Texas.jpg&amp;quot;&#xA;        ]);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;游戏&#34;&gt;&#xA;  游戏&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b8%b8%e6%88%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;cocos2dx&#xA;    # 跨平台游戏&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
