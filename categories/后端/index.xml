<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>后端 on outrun的笔记</title>
    <link>https://runout.run/categories/%E5%90%8E%E7%AB%AF/</link>
    <description>Recent content in 后端 on outrun的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 23 Apr 2022 22:18:41 +0800</lastBuildDate>
    <atom:link href="https://runout.run/categories/%E5%90%8E%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java响应式编程</title>
      <link>https://runout.run/docs/pl/java/java_reactive/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/java_reactive/</guid>
      <description>&lt;h1 id=&#34;java响应式层级&#34;&gt;&#xA;  Java响应式层级&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e5%93%8d%e5%ba%94%e5%bc%8f%e5%b1%82%e7%ba%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Level 0: Thread &amp;amp; Runnable (Java 1+)&#xA;Level 1: ExecutorService, Callable, Future (Java 5+)&#xA;Level 2: ForkJoinPool (Java 7+)&#xA;Level 3: CompletableFuture (Java 8+)&#xA;Level 4: reactive streams, Flow (Java 9+)&#xA;Level 5: HTTP/2 client (Java 11+)&#xA;Level 6: Reactive libraries (RxJava, Reactor)&#xA;Level 7: Reactive services (Vert.x, Spring, Kafka)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;flow&#34;&gt;&#xA;  Flow&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#flow&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Flow.Publisher&#xA;Flow.Subscriber&#xA;Flow.Subscription&#xA;&#x9;# link publisher和subscriber&#xA;Flow.Processor&#xA;&#x9;# subscriber和publisher的act&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;reactivex&#34;&gt;&#xA;  ReactiveX&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reactivex&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Flux&#xA;Mono&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;rxjava&#34;&gt;&#xA;  RxJava&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rxjava&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;模型&#x9;&#xA;&#x9;Observable&#xA;&#x9;Subscriber&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;reactor&#34;&gt;&#xA;  Reactor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reactor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;vertx&#34;&gt;&#xA;  Vert.x&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#vertx&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;akka&#34;&gt;&#xA;  AKKA&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#akka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://runout.run/docs/middleware/container/nginx/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/container/nginx/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;结构&#xA;    一个主进程(root权限运行)和多个工作进程(普通权限运行)&#xA;优点&#xA;    异步非阻塞&#xA;    非常稳定&#xA;    反向代理&#xA;        后端服务io能力不高，nginx buffer http请求直到完整，再发送到后端。同样buffer响应&#xA;    相对apache&#xA;        轻量&#xA;        apache阻塞&#xA;        占资源低&#xA;        模块化设计&#xA;        社区活跃, bug少&#xA;多进程模型&#xA;    使用epoll&#xA;    多worker处理，业务阻塞时切换调度, 结束阻塞时分配&#xA;模块&#xA;    handler&#xA;    filter&#xA;    upstream&#xA;    load-balance&#xA;功能&#xA;    http&#xA;       可以保持session， 相同的ip分配到同一个服务器上&#xA;       缓存静态页面到内存，建立索引与自动索引&#xA;       反向代理&#xA;       负载均衡&#xA;       模块化&#xA;           过滤器&#xA;               gzipping, byte ranges, chunked responses, SSI-filter&#xA;       支持SSL与TLS SNI&#xA;    imap/pop3代理&#xA;命令&#xA;    nginx -c /etc/nginx/nginx.conf&#xA;    nginx -s quit&#xA;    nginx -s stop&#xA;    nginx -s reload&#xA;            # 重载设置&#xA;            ## service nginx reload&#xA;    nginx -v&#xA;            # 查看版本&#xA;            ## -V&#xA;    nginx -t [-c nginx.conf]&#xA;            # 检查配置文件是否正确&#xA;    nginx -h&#xA;            # 查看帮助&#xA;            ## -?&#xA;&#xA;    pkill -9 nginx&#xA;    kill -HUP `nginx.pid`&#xA;            # 平滑重启。尝试解析配置文件，成功时应用新配置(否则继续使用旧配置)，运行新的工作进程并从容关闭旧工作进程&#xA;            ## 继续为当前连接客户提供服务&#xA;            # 支持 QUIT TERM INT USR1(重新打开日志文件，切割日志时用) USR2(平滑升级可执行程序) WINCH(从容关闭工作进程)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;http://nginx.org/en/docs/dirindex.html&#xA;域&#xA;        main http server location&#xA;&#xA;worker_rlimit_nofile 51200;&#xA;        # worker最大打开文件数的限制, 不设时为系统限制&#xA;pid        /var/run/nginx.pid;&#xA;        # nginx.pid文件中存储当前nginx主进程的pid&#xA;例子&#xA;    user www-data;&#xA;    worker_processes 4;&#xA;    pid /run/nginx.pid;&#xA;&#xA;    events {&#xA;        worker_connections 768;&#xA;        # multi_accept on;&#xA;    }&#xA;&#xA;    http {&#xA;&#xA;        ##&#xA;        # Basic Settings&#xA;        ##&#xA;&#xA;        sendfile on;&#xA;        tcp_nopush on;&#xA;        tcp_nodelay on;&#xA;        keepalive_timeout 65;&#xA;        types_hash_max_size 2048;&#xA;        # server_tokens off;&#xA;&#xA;        server_names_hash_bucket_size 64;&#xA;        # server_name_in_redirect off;&#xA;&#xA;        include /etc/nginx/mime.types;&#xA;        default_type application/octet-stream;&#xA;&#xA;        ##&#xA;        # Logging Settings&#xA;        ##&#xA;&#xA;        access_log /var/log/nginx/access.log;&#xA;        error_log /var/log/nginx/error.log;&#xA;&#xA;        ##&#xA;        # Gzip Settings&#xA;        ##&#xA;        gzip on;&#xA;        gzip_disable &amp;quot;msie6&amp;quot;;&#xA;&#xA;        # gzip_vary on;&#xA;        # gzip_proxied any;&#xA;        # gzip_comp_level 6;&#xA;        # gzip_buffers 16 8k;&#xA;        # gzip_http_version 1.1;&#xA;        # gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;&#xA;&#xA;        ##&#xA;        # nginx-naxsi config&#xA;        ##&#xA;        # Uncomment it if you installed nginx-naxsi&#xA;        ##&#xA;&#xA;        #include /etc/nginx/naxsi_core.rules;&#xA;&#xA;        ##&#xA;        # nginx-passenger config&#xA;        ##&#xA;        # Uncomment it if you installed nginx-passenger&#xA;        ##&#xA;&#xA;        #passenger_root /usr;&#xA;        #passenger_ruby /usr/bin/ruby;&#xA;&#xA;        ##&#xA;        # Virtual Host Configs&#xA;        ##&#xA;        include /etc/nginx/conf.d/*.conf;&#xA;        include /etc/nginx/sites-enabled/*;&#xA;    }&#xA;&#xA;    #mail {&#xA;    #      # See sample authentication script at:&#xA;    #      # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript&#xA;    #&#xA;    #      # auth_http localhost/auth.php;&#xA;    #      # pop3_capabilities &amp;quot;TOP&amp;quot; &amp;quot;USER&amp;quot;;&#xA;    #      # imap_capabilities &amp;quot;IMAP4rev1&amp;quot; &amp;quot;UIDPLUS&amp;quot;;&#xA;    #&#xA;    #      server {&#xA;    #              listen    localhost:110;&#xA;    #              protocol  pop3;&#xA;    #              proxy      on;&#xA;    #      }&#xA;    #&#xA;    #      server {&#xA;    #              listen    localhost:143;&#xA;    #              protocol  imap;&#xA;    #              proxy      on;&#xA;    #      }&#xA;    #}&#xA;&#xA;&#xA;    o-&amp;gt; app.zlycare.com&#xA;    server {&#xA;        listen 80;&#xA;        listen [::]:80;&#xA;&#xA;        server_name app-test.zlycare.com www.app-test.zlycare.com;&#xA;&#xA;        # access log file&#xA;        access_log /home/zlycare/data/app-zlycare-com.log;&#xA;&#xA;        location / {&#xA;                gzip on;&#xA;                default_type text/plain;&#xA;                charset utf-8;&#xA;                root /home/zlycare/app/zlydoc-cloud/public;&#xA;                index index.html;&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; web.zlycare.com&#xA;    server {&#xA;        listen 80;&#xA;        listen [::]:80;&#xA;&#xA;        server_name web-test.zlycare.com www.web-test.zlycare.com;&#xA;&#xA;        # access log file&#xA;        access_log /home/zlycare/data/web.zlycare.log;&#xA;&#xA;        location / {&#xA;            proxy_pass http://127.0.0.1:8082;&#xA;            #proxy_redirect off;&#xA;            proxy_set_header Host $host;&#xA;            proxy_set_header X-Real-IP $remote_addr;&#xA;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; sdk.com&#xA;    server {&#xA;        listen 80;&#xA;&#xA;        server_name 10.162.201.58;&#xA;&#xA;        # access log file&#xA;        access_log /home/zlycare/data/app-zlycare-com.log;&#xA;&#xA;        location / {&#xA;            gzip on;&#xA;            default_type text/plain;&#xA;            charset utf-8;&#xA;            root /opt/sdk/nginx;&#xA;            index index.html;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;代理&#34;&gt;&#xA;  代理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;nginx&#xA;    server{&#xA;        resolver x.x.x.x;&#xA;        listen 82;&#xA;        location / {&#xA;            proxy_pass http://$http_host$request_uri;&#xA;        }&#xA;    }&#xA;&#xA;    不能有hostname, 必须有resolver, 即DNS服务器ip&#xA;    $http_host和$request_uri是nginx系统变量&#xA;用户机器&#xA;    export http_proxy=http://nginx-ip:82&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;反向代理&#34;&gt;&#xA;  反向代理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;upstream backend {&#xA;    hash $consistent_key consistent&#xA;    server 192.168.61.1:9080 weight=1&#xA;    server 192.168.61.1:9090 weight=2&#xA;}&#xA;location / {&#xA;    proxy_pass http://backend&#xA;    set $consistent_key $arg_cat;                       # 从cat参数取值&#xA;    if ($consistent_key = &amp;quot;&amp;quot;) {&#xA;        set $consistent_key $request_uri;&#xA;    }&#xA;}&#xA;&#xA;上游服务器, 权重越高分配越多&#xA;请求/时，代理到backend配置的上游服务器&#xA;负载均衡算法&#xA;    round-robin(轮询)&#xA;    ip-hash&#xA;        ip_hash&#xA;    hash key/hash key consistent        # hash和一致性hash&#xA;        hash $uri&#xA;    least_conn                          # 最小连接数服务器&#xA;    least_time                          # 最小平均响应时间, 商业版&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;php&#34;&gt;&#xA;  php&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#php&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;conf/nginx.conf&#xA;    server{&#xA;        location / {&#xA;            proxy_pass http://127.0;&#xA;            proxy_redirect default;&#xA;            proxy_http_version 1.1;&#xA;            proxy_set_header Upgrade $http_upgrade;&#xA;            proxy_set_header Connection $http_connection;&#xA;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;            proxy_set_header Host $http_host;&#xA;        }&#xA;    }&#xA;&#xA;default.conf&#xA;    server {&#xA;        listen      80;&#xA;        server_name  epinkr.com www.epinkr.com;&#xA;        #server_name  localhost;&#xA;        if ( $host != &#39;www.epinkr.com&#39; )&#xA;        {&#xA;            rewrite ^/(.*)$ http://www.epinkr.com/$1 permanent;&#xA;        }&#xA;        #root    /home/qipin/deploy;&#xA;        index  index.php index.html index.htm;&#xA;&#xA;        #charset koi8-r;&#xA;        #access_log  /var/log/nginx/log/host.access.log  main;&#xA;&#xA;        location = / {&#xA;            root  /home/qipin/deploy;&#xA;        #    index  index.html index.htm;&#xA;            fastcgi_pass  127.0.0.1:9000;&#xA;            fastcgi_index  index.php;&#xA;            fastcgi_param SCRIPT_FILENAME $document_root/index.php;&#xA;            include        fastcgi_params;&#xA;        }&#xA;&#xA;        location / {&#xA;            root  /home/qipin/deploy;&#xA;            index  index.html index.htm;&#xA;        }&#xA;&#xA;        location /photo {&#xA;            root  /home/qipin/data;&#xA;        #    return 402;&#xA;        #    rewrite ^\/yuepin\/(.*) /$1 last;&#xA;        }&#xA;&#xA;        location ~ ^\/(\w+)\/css\/ {&#xA;            root  /home/qipin/deploy;&#xA;            rewrite ^\/(\w+)\/css\/(.*)  /css/$2 last;&#xA;        }&#xA;&#xA;        location ~ ^\/(\w+)\/img\/ {&#xA;            root  /home/qipin/deploy;&#xA;            rewrite ^\/(\w+)\/img\/(.*)  /img/$2 last;&#xA;        }&#xA;&#xA;        location ~ ^\/(\w+)\/js\/ {&#xA;            root  /home/qipin/deploy;&#xA;            rewrite ^\/(\w+)\/js\/(.*)  /js/$2 last;&#xA;        }&#xA;&#xA;        location ~ ^\/user\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/user\/(\w+)  /php/user/user_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/company\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/company\/(\w+)  /php/company/company_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/vendor\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/vendor\/(\w+)  /php/vendor/vendor_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/person\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/person\/(\w+)  /php/person/person_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/get\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;            rewrite ^\/get\/(\w+)  /php/yp_$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/(\w+)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #  return 402;&#xA;            rewrite ^\/(\w+)$  /php/$1.php last;&#xA;        }&#xA;&#xA;        location ~ ^\/php\/(\w*\.php)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 403;&#xA;            fastcgi_pass  127.0.0.1:9000;&#xA;            fastcgi_index  index.php;&#xA;            fastcgi_param SCRIPT_FILENAME $document_root/php/$1;&#xA;            include        fastcgi_params;&#xA;        }&#xA;&#xA;        location ~ ^\/php\/(\w+)\/(\w*\.php)$ {&#xA;            root  /home/qipin/deploy;&#xA;        #    return 403;&#xA;        #    try_files $uri =404;&#xA;            fastcgi_pass  127.0.0.1:9000;&#xA;            fastcgi_index  index.php;&#xA;            fastcgi_param SCRIPT_FILENAME $document_root/php/$1/$2;&#xA;            include        fastcgi_params;&#xA;        }&#xA;&#xA;        #location /qipin/ {&#xA;        #    root  /home/qipin/deploy;&#xA;        #    return 402;&#xA;        #    index  index.html;&#xA;        #    rewrite ^\/qipin\/(.*) /$1 last;&#xA;        #}&#xA;&#xA;        #error_page  404              /404.html;&#xA;&#xA;        # redirect server error pages to the static page /50x.html&#xA;        #&#xA;        error_page  500 502 503 504  /50x.html;&#xA;        location = /50x.html {&#xA;            root  /usr/share/nginx/html;&#xA;        }&#xA;&#xA;        # proxy the PHP scripts to Apache listening on 127.0.0.1:80&#xA;        #&#xA;        #location ~ \.php$ {&#xA;        #    proxy_pass  http://127.0.0.1;&#xA;        #}&#xA;&#xA;        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000&#xA;        #&#xA;        #location ~ \.php$ {&#xA;        #    root          html;&#xA;        #    fastcgi_pass  127.0.0.1:9000;&#xA;        #    fastcgi_index  index.php;&#xA;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;&#xA;        #    include        fastcgi_params;&#xA;        #}&#xA;&#xA;        # deny access to .htaccess files, if Apache&#39;s document root&#xA;        # concurs with nginx&#39;s one&#xA;        #&#xA;        #location ~ /\.ht {&#xA;        #    deny  all;&#xA;        #}&#xA;    }&#xA;&#xA;ssl.conf&#xA;    #HTTPS server&#xA;    #&#xA;    #server {&#xA;    #    listen      443 ssl;&#xA;    #    server_name  localhost;&#xA;&#xA;    #    ssl_certificate      /etc/nginx/cert.pem;&#xA;    #    ssl_certificate_key  /etc/nginx/cert.key;&#xA;&#xA;    #    ssl_session_cache shared:SSL:1m;&#xA;    #    ssl_session_timeout  5m;&#xA;&#xA;    #    ssl_ciphers  HIGH:!aNULL:!MD5;&#xA;    #    ssl_prefer_server_ciphers  on;&#xA;&#xA;    #    location / {&#xA;    #        root  /usr/share/nginx/html;&#xA;    #        index  index.html index.htm;&#xA;    #    }&#xA;    #}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;HttpLimitReqModul&#xA;    介绍&#xA;        限制单个ip一段时间的连接数&#xA;    http{&#xA;        limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;&#xA;        server {&#xA;            location {&#xA;                limit_req zone=allips burst=5 nodelay;&#xA;            }&#xA;        }&#xA;    }&#xA;HttpLimitConnModul&#xA;    介绍&#xA;        限制单个ip的并发连接数&#xA;HttpLimitZoneModul&#xA;    介绍&#xA;        限制ip连接内存大小&#xA;&#xA;    http {&#xA;        limit_conn_zone $binary_remote_addr zone=namea:10m;&#xA;            # $binary_remote_addr 同一客户端ip地址&#xA;            # 1.1.18前是limit_zone&#xA;        limit_conn_zone $server_name zone=nameb:10m;&#xA;            # $server_name 同一server的名字&#xA;        server {&#xA;            location {&#xA;                limit_conn  namea 20;&#xA;                limit_conn nameb 20;&#xA;                    # 并发连接数&#xA;                limit_rate 100k;&#xA;                    # 下载速度&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Nodejs</title>
      <link>https://runout.run/docs/middleware/container/nodejs/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/container/nodejs/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    commonJS规范&#xA;    javascript书写(v8引擎)&#xA;        js设计之初就可以运行在后端&#xA;        v8&#xA;            成熟的事件驱动模式&#xA;            没有i/o库, 没有历史包袱&#xA;            v8性能好&#xA;    单线程&#xA;        不用在意多线程状态同步(没有死锁, 没有上下文切换)&#xA;        无法利用多核, 错误时应用退出，计算密集时无法调度   # child_process解决&#xA;    事件驱动(event-driven), 回调&#xA;        event loop&#xA;            [while(true)] -&amp;gt; watcher -&amp;gt; handles&#xA;            watcher产生事件后, event loop取到并执行其handle(回调函数)&#xA;            event loop每一周询问多个watcher是否有事件&#xA;            event loop中没有watcher时进程退出&#xA;        http模块就是启动了一个watcher,所以执行后进程不结束&#xA;            其它watcher有 timer, fs, udp/req, process&#xA;        不同操作系统中event driven的实现:&#xA;            windows: IOCP&#xA;            Linux: epoll&#xA;            Mac:kqueue&#xA;    非阻塞io(non-blocking i/o model)&#xA;        io与数据处理分离（所以必须异步）&#xA;        线程池结合event-driven实现&#xA;    异步io&#xA;        go语言有协程(coroutine)而node.js没有，协程可以同步式编程&#xA;            # 有第三方协程模块&#xA;        promise(commonJs的规范, 其实现有whenJs, Q)&#xA;            # 书写难度降低&#xA;        eventProxy      # 朴灵&#xA;        async/step&#xA;commonJS&#xA;    模块&#xA;        var math = require(&#39;math&#39;)  # 缓存优先，核心模块优先。依次找.js, .node, .json&#xA;        exports.add = function(){}&#xA;    二进制&#xA;    Buffer&#xA;    字符集编码&#xA;    I/O流&#xA;    进程环境&#xA;    文件&#xA;    套接字&#xA;    单元测试&#xA;    web网关&#xA;    包管理&#xA;        package.json&#xA;        bin&#xA;        lib&#xA;        doc&#xA;        test&#xA;实现技术&#xA;    libev的windows与linux接口实现&#xA;    c++扩展&#xA;事件循环    # 生产者消费者模型&#xA;    执行一次称为Tick&#xA;    询问观察者(文件、网络等)是否有待处理事件, 有关联回调执行回调&#xA;        # 观察者先idle, 再io, 再check&#xA;        通过请求对象实现，绑定回调、运行参数、执行标志&#xA;层次&#xA;    javascript&#xA;    v8&#xA;    node&#xA;    libuv&#xA;    *nix/ windows                # 分别编译&#xA;应用&#xA;    I/O密集服务&#xA;    cpu密集用c/c++扩展，用子进程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;node --v8-options | grep harmony&#xA;    # 查看支持的es6特性&#xA;npm&#xA;    介绍&#xA;        cnpm是一个alibaba开发维护的，提供私有npm注册服务&#xA;    -v      # 版本&#xA;    install     # 安装，会执行package.json中scripts的勾子命令&#xA;        -g&#xA;    uninstall&#xA;    config&#xA;        list    # 查看项目的默认设置。registry属性指向npm官方资源位置&#xA;        set registry http://192.168.1.20:7001&#xA;            # 设置源&#xA;    test        # package.json中scripts的test&#xA;&#xA;    o-&amp;gt; 搭建cnpm服务器&#xA;        git clone https://github.com/cnpm/cnpmjs.org.git&#xA;        cd cnpmjs.org&#xA;        npm install npm -g&#xA;            # 升级npm的版本&#xA;        npm install&#xA;        创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码&#xA;        config/index.js中注释bindingHost来对外网开放&#xA;        node --harmony_generators dispatch.js&#xA;            # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问&#xA;    o-&amp;gt; 使用私有库&#xA;        npm install ape-algorithm --registry=http://192.168.1.20:7001&#xA;            # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份&#xA;&#xA;    设置&#xA;         ~/.npmrc&#xA;            registry=http://192.168.1.20:7001&#xA;                # 淘宝翻墙库 https://registry.npm.taobao.org/&#xA;n&#xA;node-gyp    # 编译c/c++模块&#xA;nvm&#xA;cnpm&#xA;    介绍&#xA;        cnpm是一个alibaba开发维护的，提供私有npm注册服务&#xA;    安装&#xA;        npm install cnpm&#xA;            # 可以像使用npm一样使用&#xA;        cnpm sync gulp&#xA;            # npm 中发布的包在cnpm中有延时，可以用这个命令来手动同步&#xA;    搭建cnpm服务器&#xA;        git clone https://github.com/cnpm/cnpmjs.org.git&#xA;        cd cnpmjs.org&#xA;        npm install npm -g&#xA;            # 升级npm的版本&#xA;        npm install&#xA;        创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码&#xA;        config/index.js中注释bindingHost来对外网开放&#xA;        node --harmony_generators dispatch.js&#xA;            # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问&#xA;    使用私有库&#xA;        npm install ape-algorithm --registry=http://192.168.1.20:7001&#xA;            # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份&#xA;    项目设置私有库&#xA;        npm config list&#xA;            # 查看项目的默认设置。registry属性指向npm官方资源位置&#xA;        npm config set registry http://192.168.1.20:7001&#xA;    用户设置私有库&#xA;        // ~/.npmrc&#xA;        registry=http://192.168.1.20:7001&#xA;            # 另外，淘宝翻墙库 https://registry.npm.taobao.org/&#xA;调试&#xA;    o-&amp;gt; 代码中插入断点&#xA;        debugger;&#xA;    o-&amp;gt; 以debug模式运行&#xA;        # debug模式运行时, help查看可用命令&#xA;        node debug app.js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;package.json&#xA;    name                # 包名&#xA;    description         # 简介&#xA;    version             # 版本&#xA;    keywords            # 搜索关键词&#xA;    maintainers         # 维护者&#xA;    contributors        # 代码贡献者&#xA;    bugs                # 反馈bug的地址&#xA;    licenses            # 许可证&#xA;    repositories        # 托管代码地址&#xA;    dependencies        # 依赖包&#xA;    homepage            # 该包网站&#xA;    os                  # 操作系统支持列表&#xA;    cpu                 # cpu架构支持列表&#xA;    engine              # 支持的js引擎, 如ejs&#xA;    builtin             # 内建在底层系统的哪些组件上&#xA;    directories         # 目录说明&#xA;    implements          # 实现了commonJS哪些规范&#xA;    scripts             # 脚本命令&#xA;        preinstall&#xA;        install&#xA;        uninstall&#xA;        test&#xA;    author              # 包作者&#xA;    bin                 # 全局安装时，命令安装的位置&#xA;    main                # require()包时入口，默认找index&#xA;    devDependencies     # 开发时需要的依赖&#xA;&#xA;    o-&amp;gt;&#xA;    {&#xA;        &amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;,&#xA;        &amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;,&#xA;        &amp;quot;keywords&amp;quot;: [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;],                     # npm search时用&#xA;        &amp;quot;description&amp;quot;: &amp;quot;A testing package&amp;quot;,&#xA;        &amp;quot;os&amp;quot;: [&amp;quot;linux&amp;quot;, &amp;quot;darwin&amp;quot;],&#xA;        &amp;quot;author&amp;quot;: &amp;quot;outrun&amp;lt;outrun@mail.com&amp;gt;&amp;quot;,&#xA;        &amp;quot;dependencies&amp;quot;: {&#xA;            &amp;quot;express&amp;quot;: &amp;quot;^1.0.0&amp;quot;,&#xA;            &amp;quot;redis&amp;quot;: &amp;quot;&amp;gt;= 0.6.7&amp;quot;&#xA;        },&#xA;        &amp;quot;devDependencies&amp;quot;: {&#xA;            &amp;quot;grunt&amp;quot;: &amp;quot;^0.4.5&amp;quot;&#xA;        },&#xA;        &amp;quot;main&amp;quot;: &amp;quot;index&amp;quot;,&#xA;        &amp;quot;bin&amp;quot;: {&#xA;            &amp;quot;test&amp;quot;: &amp;quot;./bin/test.js&amp;quot;&#xA;        },&#xA;        &amp;quot;scripts&amp;quot;: {&#xA;            &amp;quot;start&amp;quot;: &amp;quot;node server.js&amp;quot;,&#xA;            &amp;quot;test&amp;quot;: &amp;quot;vows test/*.js&amp;quot;,               # &amp;quot;grunt test&amp;quot; &amp;quot;mocha test&amp;quot; &amp;quot;make test&amp;quot; &amp;quot;make test-all&amp;quot;&#xA;            &amp;quot;preinstall&amp;quot;: &amp;quot;./configure&amp;quot;,&#xA;            &amp;quot;install&amp;quot;: &amp;quot;make &amp;amp;&amp;amp; make install&amp;quot;,&#xA;            &amp;quot;uninstall&amp;quot;: &amp;quot;&amp;quot;&#xA;        },&#xA;        &amp;quot;engines&amp;quot;: {&#xA;            &amp;quot;node&amp;quot;: &amp;quot;5.0.0&amp;quot;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;异步api&#34;&gt;&#xA;  异步api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;I/O操作api&#xA;setTimeout() setInterval()&#xA;    定时器插入观察者的红黑树中, tick时迭代定时器，如果超时就形成事件&#xA;        # 如果前一个tick耗时大，定时会拖后&#xA;        # 比较浪费性能&#xA;process.nextTick()&#xA;    回调放入队列，下tick全部执行, 位于idle观察者&#xA;setImmediate()&#xA;    回调放入链表, 每tick执行一个，位于check观察者，晚于idle&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;宿主对象&#34;&gt;&#xA;  宿主对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%bf%e4%b8%bb%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;global      #全局对象&#xA;    root    # 指向自己&#xA;    BLOBAL # 指向自己&#xA;&#xA;    setTimeout()&#xA;    setInterval()&#xA;    clearTimeout()&#xA;    clearInterval()&#xA;process     #当前进程&#xA;    argv    # 获得命令行参数数组&#xA;        title       # node&#xA;        version     # v0.12.2&#xA;    事件&#xA;        process.on(&amp;quot;uncaughtException&amp;quot;,function(e){&#xA;            console.log(&amp;quot;error:&amp;quot;+e);&#xA;        });&#xA;buffer&#xA;    特点&#xA;        node中buffer不属于v8, 使用c++扩展编写。所以可以使用高于1.4g的内存&#xA;        一个元素一字节&#xA;        8kb之内为小对象，slab机制分配内存, 先申请后分配。大于8kb的创建SlowBuffer对象&#xA;        pool的实现方式&#xA;    字符编码类型&#xA;        # 默认编码UTF-8, 一个buffer只能有一个编码&#xA;        ascii&#xA;        utf-8&#xA;        utf-16le/ucs-2&#xA;        base64&#xA;        binary&#xA;        hex&#xA;&#xA;    length&#xA;&#xA;    write()&#xA;        # write(str, [offset], [length], [encoding])&#xA;    toString()&#xA;        # toString([encoding], [start], [end])&#xA;    isEncoding()&#xA;        # 指定编码是否支持转换&#xA;    copy()&#xA;        # 复制自身到另一个buffer的某位置&#xA;        buf.copy(buffer, 0)&#xA;    concat()  #静态方法&#xA;        concat(chunks, size)&#xA;            # chunks中为buffer数组, size为总大小&#xA;    使用&#xA;        new Buffer(100)&#xA;        new Buffer(&#39;a&#39;, &#39;UTF-8&#39;)&#xA;console     #控制台&#xA;    log(&#39;&#39;,obj)&#xA;        console.log(&#39;[%s] listening on http://127.0.0.1:%d&#39;, app.setting.env, port)&#xA;module&#xA;    Module.exports真正的接口，导出的是一个类型&#xA;    exports是Module.exports的包装，导出的是Object类型的对象&#xA;promise     # 0.11.x后加入的全局对象&#xA;    使用&#xA;        # 复制&#xA;        var jadeTemplate = new Promise(function(resolve, reject) {&#xA;        fs.readFile(path.join(__dirname, &#39;views/article.jade&#39;), function(err, data) {&#xA;            if (err) {&#xA;            reject(err.message);&#xA;            } else {&#xA;            resolve(data.toString());&#xA;            }&#xA;        });&#xA;        });&#xA;&#xA;        var localData = new Promise(function(resolve, reject) {&#xA;        fs.readFile(path.join(__dirname, &#39;static/shuffle.json&#39;), function(err, data) {&#xA;            if (err) {&#xA;            reject(err.message);&#xA;            } else {&#xA;            resolve(JSON.parse(data.toString()));&#xA;            }&#xA;        });&#xA;        });&#xA;&#xA;        Promise&#xA;        .all([jadeTemplate, localData])&#xA;        .then(function(value) {&#xA;            console.log(jade.compile(value[0])(value[1]));&#xA;        });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内置lib&#34;&gt;&#xA;  内置lib&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%aelib&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;http&#34;&gt;&#xA;  http&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#http&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    继承自net模块&#xA;    EventEmitter实例&#xA;事件&#xA;    服务端&#xA;        connection&#xA;        request&#xA;        close&#xA;        checkContinue&#xA;            # 发送较大数据时，先发送Expect: 100-continue请求头，此时触发&#xA;        connect&#xA;        upgrade&#xA;            # 要求升级连接协议时&#xA;        clientError&#xA;            # 客户端触发error事件时触发&#xA;    客户端&#xA;        response&#xA;        socket&#xA;            # 建立连接时触发&#xA;        connect&#xA;            # 响应200时触发&#xA;        upgrade&#xA;        continue&#xA;&#xA;globalAgent     # 重用http长连接，实际是个连接池，默认有5个并发&#xA;    sockets&#xA;        # 连接数&#xA;    requests&#xA;        # 处于等待状态的请求数&#xA;&#xA;createServer(onRequest).listen(8888, func);                # 创建服务器并启动&#xA;    request&#xA;        req.setEncoding(&amp;quot;utf8&amp;quot;)&#xA;        var postData = &amp;quot;&amp;quot;;&#xA;        req.addListener(&amp;quot;data&amp;quot;, function(postDataChunk){&#xA;            postData += postDataChunk;&#xA;        });&#xA;        req.addListener(&amp;quot;end&amp;quot;, function(){&#xA;            route(handle, pathname, res, postData);&#xA;        });                                # 拼接post请求数据&#xA;        req.rawBody&#xA;            # post来的原生数据&#xA;        req.destroy()&#xA;            # 放弃请求，停止招收&#xA;&#xA;    response&#xA;        res.setHeader(&#39;WWW-Authenticate&#39;, &#39;Basic realm=\&amp;quot;Tomcat Manager Application\&amp;quot;&#39;)&#xA;        res.writeHead(200, {&amp;quot;Content-Type&amp;quot;: &amp;quot;text/html&amp;quot;});&#xA;            # 调用setHeader多次，调用writeHead后才写入&#xA;        res.write(&amp;quot;&amp;quot;);&#xA;        res.write(file,?&amp;quot;binary&amp;quot;);?&#xA;        res.end();&#xA;request(options, fn)        # 发起客户端请求&#xA;    # options中有 host, hostname, port, localAddress(使用本地的哪个网卡), socketPath(本地套接字文件路径), method, path, headers, auth(被计算成请求头的Authorization部分), agent(并发连接数，默认5)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;https&#34;&gt;&#xA;  https&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#https&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    nodejs&#xA;    申请ca证书&#xA;    访问端口为443&#xA;使用&#xA;    express -e nodejs-https&#xA;    cd nodejs-https &amp;amp;&amp;amp; npm install&#xA;    git --version&#xA;    openssl version -a&#xA;    openssl genrsa -out privatekey.pem 1024&#xA;        # 生成证书文件&#xA;    openssl req -new -key privatekey.pem -out certrequest.csr&#xA;        # 通过私钥生成CSR证书签名&#xA;    openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem&#xA;        # 通过私钥和证书签名生成证书文件&#xA;        ## 这时生成了三个文件: certificate.pem, certrequest.csr, privatekey.pem&#xA;        ### 分别是: 证书文件, CSR证书签名, 私钥&#xA;        ## 由于证书是自己创建的，没有经过第三方机构验证，用户访问时会出现警告提示&#xA;    服务器&#xA;        var https = require(&#39;https&#39;)&#xA;            , fs = require(&#39;fs&#39;);&#xA;        var options = {&#xA;            key: fs.readFileSync(&#39;./privatekey.pem&#39;),&#xA;            cert: fs.readFileSync(&#39;./certificate.pem&#39;)&#xA;        };&#xA;        https.createServer(options, app).listen(3011, function(){&#xA;            console.log(&#39;Https server listening on port: &#39; + 3011);&#xA;        });&#xA;    客户端&#xA;        var options = {&#xA;            hostname: &#39;localhost&#39;,&#xA;            port: 8000,&#xA;            path: &#39;/&#39;,&#xA;            method: &#39;GET&#39;,&#xA;            key: fs.readFileSync(&#39;./keys/client.key&#39;),&#xA;            cert: fs.readFileSync(&#39;./keys/client.crt&#39;),&#xA;            ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]&#xA;                # 设置rejectUnauthorized: false 来忽略ca验证&#xA;        }&#xA;        options.agent = new https.Agent(options)&#xA;&#xA;        var req = https.request(options, function (res) {&#xA;            res.setEncoding(&#39;utf-8&#39;)&#xA;            res.on(&#39;data&#39;, function (d) {&#xA;                console.log(d)&#xA;            })&#xA;        })&#xA;        req.end()&#xA;&#xA;        req.on(&#39;error&#39;, function(e){&#xA;            console.log(e)&#xA;        })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;net&#34;&gt;&#xA;  net&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#net&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    处理tcp请求&#xA;    socket是EventEmitter的Stream实例&#xA;注意&#xA;    默认开启Nagle, 会合并小数据成一个数据包延迟发送&#xA;        socket.setNoDelay(true)关闭Nagle&#xA;    并不是每次write都触发data事件, 关掉Nagle后，可能接收到多个小数据包后触发一次data&#xA;&#xA;服务器事件&#xA;    listening&#xA;    connection&#xA;    close&#xA;    error&#xA;连接事件&#xA;    data&#xA;    end&#xA;    connect&#xA;    drain&#xA;        # 任意一端调用write时触发&#xA;    error&#xA;    close&#xA;    timeout&#xA;&#xA;o-&amp;gt; 基本服务&#xA;# telnet来测试&#xA;var net = require(&#39;net&#39;)&#xA;&#xA;var server = net.createServer(function (socket) {&#xA;    socket.on(&#39;data&#39;, function (data) {&#xA;        socket.write(&#39;a&#39;)&#xA;    })&#xA;&#xA;    socket.on(&#39;end&#39;, function () {&#xA;        console.log(&#39;disconnected.&#39;)&#xA;    })&#xA;&#xA;    socket.write(&#39;welcome&#39;)&#xA;})&#xA;&#xA;server.listen(8124, function () {&#xA;    console.log(&#39;server bound&#39;)&#xA;})&#xA;&#xA;o-&amp;gt; 基本服务2&#xA;var server = net.createServer()&#xA;server.on(&#39;connection&#39;, function (socket) {})&#xA;server.listen(8124)&#xA;&#xA;o-&amp;gt; 监听&#xA;server.listen(&#39;/tmp/echo.sock&#39;)&#xA;    # nc -U /tmp/echo.sock 来测试&#xA;&#xA;o-&amp;gt; 客户端&#xA;var client = net.connect({port: 8124}, function () {&#xA;    console.log(&#39;client connected&#39;)&#xA;    client.write(&#39;a&#39;)&#xA;})&#xA;&#xA;client.on(&#39;data&#39;, function (data) {&#xA;    console.log(data.toString())&#xA;    client.end()&#xA;})&#xA;&#xA;client.on(&#39;end&#39;, function() {&#xA;    console.log(&#39;disconnected.&#39;)&#xA;})&#xA;&#xA;o-&amp;gt; 客户端&#xA;var client = net.connect({path: &#39;/tmp/echo.sock&#39;})&#xA;&#xA;o-&amp;gt; 管道&#xA;var server = net.createServer(function (socket) {&#xA;    socket.write(&#39;a&#39;)&#xA;    socket.pipe(socket)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dgram&#34;&gt;&#xA;  dgram&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dgram&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    处理udp&#xA;    socket是EventEmitter实例&#xA;&#xA;o-&amp;gt; 服务&#xA;var dgram = require(&#39;dgram&#39;)&#xA;&#xA;var server = dgram.createSocket(&#39;udp4&#39;)&#xA;&#xA;server.on(&#39;message&#39;, function (msg, rinfo) {&#xA;    console.log(msg + &#39;from&#39; + rinfo.address + &#39;:&#39; +)&#xA;})&#xA;&#xA;server.on(&#39;listening&#39;, function () {&#xA;    var address = server.address()&#xA;    console.log(&#39;listening &#39; + address.address + &#39;:&#39; + address.port)&#xA;})&#xA;&#xA;server.bind(41234)&#xA;&#xA;o-&amp;gt; 客户端&#xA;var message = new Buffer(&#39;a&#39;)&#xA;var client = dgram.createSocket(&#39;udp4&#39;)&#xA;client.send(message, 0, message.length, 41234, &#39;localhost&#39;, function (err, bytes) {&#xA;    client.close()&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;events&#34;&gt;&#xA;  events&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#events&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    几乎所有对象的父类&#xA;使用&#xA;    var events = require(&#39;events&#39;)&#xA;        , util = require(&#39;util&#39;);&#xA;    function Obj(){events.EventEmitter.cal(this);}&#xA;    util.inherits(Obj, events.EventEmitter);&#xA;        # Obj.prototype.__proto__ = events.EventEmitter.prototype;&#xA;    Obj.prototype.write = function (data) {this.emit(&#39;data&#39;, data);};&#xA;&#xA;    var obj = new Obj();&#xA;    obj.on(&#39;data&#39;, function (data) {console.log(&#39;Received data&#39;, data);})&#xA;        # obj.once&#xA;    obj.write(&#39;hello&#39;);&#xA;&#xA;setMaxListeners(0)&#xA;    # 侦听器过多不警告&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;path&#34;&gt;&#xA;  path&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#path&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;os&#34;&gt;&#xA;  os&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#os&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    totalmem&#xA;    freemem&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;fs&#34;&gt;&#xA;  fs&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;fs.readFile(&amp;quot;tmp/test.png&amp;quot;, &amp;quot;binary&amp;quot;, function(error, file){&#xA;});&#xA;fs.writeFile(&#39;target.png&#39;, &#39;binary&#39;, function(err){&#xA;})&#xA;fs.exists(filePath, function(exists){&#xA;        if(exists){}&#xA;})&#xA;fs.unlink(filePath, function(err){&#xA;})&#xA;fs.renameSync(files.upload.path,?&amp;quot;/tmp/test.png&amp;quot;);                # 写入文件(阻塞)&#xA;&#xA;o-&amp;gt; 流读写&#xA;var reader = fs.createReadStream(&#39;in.txt&#39;)&#xA;        # 第二个参数为设置, highWaterMark: 每次读取的size, encoding: 编码&#xA;var writer = fs.createWriteStream(&#39;out.txt&#39;)&#xA;reader.on(&#39;data&#39;, function (chunk) {&#xA;        writer.write(chunk)&#xA;})&#xA;reader.on(&#39;end&#39;, function() {&#xA;        writer.end()&#xA;})&#xA;&#xA;var reader = fs.createReadStream(&#39;in.txt&#39;)&#xA;var writer = fs.createWriteStream(&#39;out.txt&#39;)&#xA;reader.pipe(writer)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;sys&#34;&gt;&#xA;  sys&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sys&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;process&#34;&gt;&#xA;  process&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#process&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;argv&#xA;    # 启动时参数&#xA;pid&#xA;    # 当前进程的pid&#xA;&#xA;once()&#xA;    once(&#39;SIGINT&#39;, function () {})&#xA;        # ctrl + c&#xA;memoryUsage()&#xA;    # 查看v8内存使用量&#xA;    # 其中rrs是resident set size, 是常驻内存的部分，其他在swap或文件系统中&#xA;kill()&#xA;    # process.kill(pid[, signal])&#xA;on()&#xA;    # 事件触发&#xA;&#xA;o-&amp;gt;&#xA;process.on(&#39;SIGTERM&#39;, function () {&#xA;    console.log(&#39;Got a SIGTERM, exiting...&#39;)&#xA;    process.exit(1)&#xA;})&#xA;&#xA;o-&amp;gt;&#xA;process.on(&#39;uncaughtException&#39;, function () {&#xA;    logger.error(err)&#xA;    process.send({act: &#39;suicide&#39;})&#xA;        # 向主进程发送信号&#xA;    worker.close(function () {&#xA;        process.exit(1)&#xA;    })&#xA;&#xA;    setTimeout(function () {&#xA;        # 长连接断开需要时间较久, 超时自动退出&#xA;        process.exit(1)&#xA;    }, 5000)&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;module&#34;&gt;&#xA;  module&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#module&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;exports&#xA;parent&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;stream&#34;&gt;&#xA;  stream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    继承EventEmitter, 处理文件之类的流&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;tls&#34;&gt;&#xA;  tls&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tls&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    建立在tls/ssl上的加密tcp&#xA;    使用openssl来构建证书和测试&#xA;&#xA;o-&amp;gt; 服务器&#xA;var tls = require(&#39;tls&#39;)&#xA;var fs = require(&#39;fs&#39;)&#xA;&#xA;var options = {&#xA;        key: fs.readFileSync(&#39;./keys/server.key&#39;),&#xA;        cert: fs.readFileSync(&#39;./keys/server.crt&#39;),&#xA;        requestCert: true,&#xA;        ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]&#xA;}&#xA;&#xA;var server = tls.createServer(options, function (stream) {&#xA;        console.log(&#39;server connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;)&#xA;        stream.write(&#39;welcome!\n&#39;)&#xA;        stream.setEncoding(&#39;utf8&#39;)&#xA;        stream.pipe(stream)&#xA;})&#xA;server.listen(8000, function () {&#xA;        console.log(&#39;server bound&#39;)&#xA;})&#xA;&#xA;o-&amp;gt; 客户端&#xA;var options = {&#xA;        key: fs.readFileSync(&#39;./keys/client.key&#39;),&#xA;        cert: fs.readFileSync(&#39;./keys/client.crt&#39;),&#xA;        ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]&#xA;}&#xA;&#xA;var stream = tls.connect(8000, options, function () {&#xA;        console.log(&#39;client connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;)&#xA;                # 证书是否通过&#xA;        process.stdin.pipe(stream)&#xA;})&#xA;&#xA;stream.setEncoding(&#39;utf8&#39;)&#xA;stream.on(&#39;data&#39;, function (data) {&#xA;        console.log(data)&#xA;})&#xA;stream.on(&#39;end&#39;, function () {&#xA;        server.close()&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;child_process&#34;&gt;&#xA;  child_process&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#child_process&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    可以创建新的node进程&#xA;spawn(command[, args][a options])&#xA;    # command执行的命令&#xA;    # args参数列表&#xA;    options 环境变量对象, 包括7个属性&#xA;        cwd 子进程当前工作目录&#xA;        env 环境变量键值对&#xA;        stdio 子进程stdio配置&#xA;        customFds 子进程stdio使用的文件标示符&#xA;        detached 进程组的主控制&#xA;        uid 用户进程id&#xA;        进程组id&#xA;&#xA;    var du = child.spawn(&#39;du&#39;, [&#39;-sh&#39;, &#39;/disk1&#39;]);&#xA;    du.stdout.on(&#39;data&#39;, function(data){})&#xA;    du.stderr.on(&#39;data&#39;, function(data){})&#xA;    du.on(&#39;exit&#39;, function(code){})&#xA;exec(&#39;&#39;)&#xA;    # 对spawn的友好封装, 增加了shell命令解析&#xA;    child.exec(&#39;cat *.js | ws&#39;, function(error, stdout, stderr){})&#xA;execFile(command[, args])&#xA;    # 执行可执行文件，不解析args,防止了exec参数注入的风险&#xA;    child.execFile(&#39;/bin/ls&#39;, [&#39;-l&#39;, &#39;.&#39;], function(err, result){})&#xA;fork()&#xA;    # 同spawn, 但建立ipc(进程通信, inter-process communication)&#xA;    var n = child.fork(&#39;./son.js&#39;);&#xA;    n.on(&#39;message&#39;, function(){&#xA;        console.log(&#39;Main listen: &#39;, m);&#xA;    });&#xA;    n.send({hello: &#39;i am parent&#39;});&#xA;    // son.js&#xA;    process.on(&#39;message&#39;, function(m){&#xA;        console.log(&#39;Son listen: &#39;, m);&#xA;    });&#xA;    process.send({hello: &#39;i am child&#39;});&#xA;子进程对象&#xA;    send()&#xA;        # 发送消息和句柄，句柄可以是&#xA;        ## net.Socket, net.Server, net.Native(c++层面的tcp套接字或IPC管道), dgram.Socket, dgram.Native&#xA;    kill()&#xA;        # 向子进程发送SIGTERM信号&#xA;    事件&#xA;        message&#xA;        error&#xA;        exit&#xA;        close&#xA;        disconnect&#xA;&#xA;o-&amp;gt; cpu核数worker&#xA;    o-&amp;gt; master.js&#xA;    var fork = require(&#39;child_process&#39;).fork&#xA;    var cpus = require(&#39;os&#39;).cpus()&#xA;    for (var i = 0; i &amp;lt; cpus.length; i++){&#xA;        fork(&#39;./worker.js&#39;)&#xA;    }&#xA;&#xA;    o-&amp;gt; worker.js&#xA;    var http = require(&#39;http&#39;)&#xA;    http.createServer(function(req, res){...}).listen(Math.round((1+Math.random()) * 1000), &#39;127.0.0.1&#39;)&#xA;&#xA;o-&amp;gt; spawn&#xA;var spawn = require(&#39;child_process&#39;).spawn&#xA;free = spawn(&#39;free&#39;, [&#39;-m&#39;])&#xA;free.stdout.on(&#39;data&#39;, function (data) {})&#xA;free.stderr.on(&#39;data&#39;, function (data) {})&#xA;free.on(&#39;exit&#39;, function (code, signal) {})&#xA;&#xA;o-&amp;gt; fork&#xA;    # 需要至少30ms, 10M启动一个v8实例&#xA;var fork = require(&#39;child_process&#39;).fork&#xA;var cpus = require(&#39;os&#39;).cpus()&#xA;for (var i = 0; i &amp;lt; cpus.length; i++) {&#xA;        fork(&#39;./worker.js&#39;)&#xA;}&#xA;&#xA;o-&amp;gt; 通信&#xA;    # 只有子进程是node进程时才可以通信&#xA;var cp = require(&#39;child_process&#39;)&#xA;var n = cp.fork(__dirname + &#39;/sub.js&#39;)&#xA;&#xA;n.on(&#39;message&#39;, function (m) {&#xA;    console.log(&#39;PARENT got message: &#39;, m)&#xA;})&#xA;n.send({a: 1})&#xA;&#xA;process.on(&#39;message&#39;, function (m) {&#xA;    console.log(&#39;CHILD got message:&#39;, m)&#xA;})&#xA;process.send({b: 2})&#xA;&#xA;o-&amp;gt; 句柄通信&#xA;    # 节省了代理建立socket浪费的文件描述符&#xA;var child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;)&#xA;var server = require(&#39;net&#39;).createServer()&#xA;server.on(&#39;connection&#39;, function (socket) {&#xA;    socket.end(&#39;handled by parent \n&#39;)&#xA;})&#xA;server.listen(1337, function () {&#xA;    child.send(&#39;server&#39;, server)&#xA;})&#xA;// child.js&#xA;process.on(&#39;message&#39;, function (m, server) {&#xA;    if (m === &#39;server&#39;) {&#xA;        server.on(&#39;connection&#39;, function (socket) {&#xA;            socket.end(&#39;handled by child \n&#39;)&#xA;        })&#xA;    }&#xA;})&#xA;&#xA;o-&amp;gt; 句柄负载http&#xA;    # 对描述符是抢占式的&#xA;var cp = require(&#39;child_process&#39;)&#xA;var child1 = cp.fork(&#39;child.js&#39;)&#xA;var child2 = cp.fork(&#39;child.js&#39;)&#xA;&#xA;var server = require(&#39;net&#39;).createServer()&#xA;server.listen(1337, function () {&#xA;    child1.send(&#39;server&#39;, server)&#xA;    child2.send(&#39;server&#39;, server)&#xA;    server.close()&#xA;})&#xA;// child.js&#xA;var http = require(&#39;http&#39;)&#xA;var server = http.createServer(function (req, res) {&#xA;    res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;})&#xA;    res.end(&#39;handled by child, pid is &#39; + process.pid + &#39;\n&#39;)&#xA;})&#xA;process.on(&#39;message&#39;, function (m, tcp) {&#xA;    if (m === &#39;server&#39;) {&#xA;        tcp.on(&#39;connection&#39;, function (socket) {&#xA;            server.emit(&#39;connection&#39;, socket)&#xA;        })&#xA;    }&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;cluster&#34;&gt;&#xA;  cluster&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cluster&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    child_process和net模块的组合&#xA;        cluster启动时，内部启动tcp服务器&#xA;        fork()时，将tcp服务器socket文件描述符发给worker, 实现共享端口&#xA;isWorker&#xA;    判断process.env是否值为NODE_UNIQUE_ID&#xA;isMaster&#xA;    判断cluster.isWorker&#xA;事件&#xA;    fork            # fork时&#xA;    online          # 工作进程创建好后&#xA;    listening       # 工作进程调listen()后&#xA;    disconnect      # 主进程和工作进程IPC通道断开后&#xA;    exit            # 所有工作进程退出后&#xA;    setup           # cluster.setupMaster()执行后&#xA;&#xA;o-&amp;gt; cpu核数worker&#xA;var cluster = require(&#39;cluster&#39;)&#xA;cluster.setupMaster({&#xA;    exec: &amp;quot;worker.js&amp;quot;&#xA;})&#xA;&#xA;var cpus = require(&#39;os&#39;).cpus()&#xA;for (var i = 0; i &amp;lt; cpus.length; i++) {&#xA;    cluster.fork()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;domain&#34;&gt;&#xA;  domain&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#domain&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    用于异步异常捕获&#xA;    绑定方式&#xA;        隐式绑定: 把domain上下文中定义的变量，自动绑定到domain对象&#xA;        显式绑定: 把不是domain上下文中定义的变量，以代码的方式绑定到domain对象&#xA;members     # 已加入domain对象的域定时器和事件发射器的数组&#xA;&#xA;create()                # 返回一个domain对象&#xA;run(fn)                 # 在domain上下文中执行一个函数，并隐式绑定所有事件、定时器和低级请求&#xA;add(emitter)            # 显式的增加事件&#xA;remove(emitter)         # 删除事件&#xA;bind(callback)          # 以return为封闭callback函数　&#xA;intercept(callback)     # 同bind, 但返回第一个参数&#xA;enter()                 # 进入一个异步调用的上下文，绑定到domain&#xA;exit()                  # 退出当前的domain, 切换到不同的链的异步调用的上下文中，对应domain.enter()&#xA;dispose()               # 释放一个domain对象，让node进程回收这部分资源&#xA;使用&#xA;    var domain = require(&#39;domain&#39;);&#xA;    function async_error(){&#xA;        setTimeout(function(){&#xA;            var r = Math.random() * 10;&#xA;            console.log(&#39;random num is &#39; + r);&#xA;            if(r &amp;gt; 5)&#xA;                throw new Error(&#39;Error: random num &#39; + r + &#39; &amp;gt; 5&#39;);&#xA;        }, 10);&#xA;    }&#xA;    var d = domain.create();&#xA;    d.on(&#39;error&#39;, function(err){&#xA;        console.log(err);&#xA;    });&#xA;    setInterval(function(){&#xA;        d.run(async_err);&#xA;    }, 1000);&#xA;未绑定不捕获&#xA;    代码&#xA;        var domain = require(&#39;domain&#39;);&#xA;        var EventEmitter = require(&#39;events&#39;).EventEmitter;&#xA;&#xA;        var e = new EventEmitter();&#xA;&#xA;        var timer = setTimeout(function(){&#xA;            e.emit(&#39;data&#39;);&#xA;        }, 10);&#xA;&#xA;        function next(){&#xA;            e.once(&#39;data&#39;, function(){&#xA;                throw new Error(&#39;Receive data error!&#39;);&#xA;            });&#xA;        }&#xA;&#xA;        var d = domain.create();&#xA;        d.on(&#39;error&#39;, function(err){&#xA;            console.log(err);&#xA;        });&#xA;        d.run(next);&#xA;    原因&#xA;        timer和e两个关键对象在初始化时都没有在domain范围内。当next函数中抛出异常时, 没有处于domain的包裹中&#xA;&#xA;    修改&#xA;        ...&#xA;        d.add(e);&#xA;        d.add(timer);&#xA;        d.run(next);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;外部lib&#34;&gt;&#xA;  外部lib&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%96%e9%83%a8lib&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;url&#34;&gt;&#xA;  url&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#url&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;parse()&#xA;    pathname&#xA;&#xA;    url.parse(req.url)&#xA;    url.parse(req.url, true) 会parse出query对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;querystring&#34;&gt;&#xA;  querystring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#querystring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;parse()&#xA;    querystring.parse(url.parse(req.url).query)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;crypto&#34;&gt;&#xA;  crypto&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#crypto&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    加密并生成各种散列&#xA;    利用openssl库来实现，提供openssl中一系列哈希方法，包括hmac, cipher, decipher, 签名和验证等方法的封装&#xA;使用&#xA;    var crypto = require(&#39;crypto&#39;);&#xA;    console.log(crypto.getHashes());                                    # 打印支持的所有hasp算法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;node-gyp&#34;&gt;&#xA;  node-gyp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#node-gyp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;编译C++模块的编译工具&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;util&#34;&gt;&#xA;  util&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#util&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    var util = require(&#39;util&#39;);&#xA;方法&#xA;    inherits(Sub, Base)                # 对象间原型继承，Sub 仅继承Base原型中定义 的函数&#xA;    inspect(obj)                # 任意对象转换为字符串&#xA;    log(string)                        # 带时间戳的log&#xA;    format(&#39;%s:%s&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)                // &#39;a:b c&#39;&#xA;        # format(&#39;%s:%s&#39;, &#39;a&#39;)                // &#39;a:%s&#39;&#xA;        # format(1, 2, 3)                        // &#39;1 2 3&#39;&#xA;    is系列&#xA;        isArray(obj)&#xA;        isRegExp(obj)&#xA;        isDate(obj)&#xA;        isError(obj)&#xA;        isBoolean(obj)&#xA;        isNull(obj)&#xA;        isNullOrUndefined(obj)&#xA;        isNumber(obj)&#xA;        isString(obj)&#xA;        isSymbol(obj)&#xA;        isUndefined(obj)&#xA;        isObject(obj)&#xA;        isFunction(obj)&#xA;        isPrimitive(obj)&#xA;            # 是否基本类型&#xA;        isBuffer(obj)&#xA;        deprecate(foo, &#39;foo() is deprecated, use bar() instead&#39;);&#xA;            # 标记为过时, 调用foo()时显示后面的话&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;zlib&#34;&gt;&#xA;  zlib&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#zlib&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    提供压缩方法，如gzip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;全局属性&#34;&gt;&#xA;  全局属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a8%e5%b1%80%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    并非挂在global下的属性，但可以直接使用&#xA;&#xA;__dirname&#xA;    # 在任何模块内获取当前模块文件的绝对路径&#xA;__filename&#xA;    # 当前在执行的js文件路径&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;异常捕获&#xA;    process.on(&amp;quot;uncaughtException&amp;quot;,function(e){&#xA;        logger.error(&amp;quot;error:&amp;quot;+e);&#xA;    });&#xA;    process.on(&#39;unhandledRejection&#39;, function (err, p) {&#xA;        console.error(err.stack)&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Spring Cloud</title>
      <link>https://runout.run/docs/middleware/distributed/spring_cloud/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/middleware/distributed/spring_cloud/</guid>
      <description>&lt;h1 id=&#34;亿级流量&#34;&gt;&#xA;  亿级流量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%bf%e7%ba%a7%e6%b5%81%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;流量接入层&#34;&gt;&#xA;  流量接入层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81%e9%87%8f%e6%8e%a5%e5%85%a5%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;二级域名&#xA;    泛域名&#xA;    A记录&#xA;dns解析&#xA;    udp&#xA;        向网关请求dns解析&#xA;    httpDNS&#xA;        用ip请求http服务, 返回域名解析的ip&#xA;        因为用ip请求，适合app，不适合网页&#xA;lvs + keepalive             # 多lvs时用dns负载&#xA;nginx&#xA;    openresty&#xA;        kong&#xA;动静分离&#xA;    cdn&#xA;        dns动态域名解析&#xA;        cdn分发服务&#xA;            源服务拉取FastDFS&#xA;            CDN节点分发&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;web服务层&#34;&gt;&#xA;  WEB服务层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web%e6%9c%8d%e5%8a%a1%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;webflux&#xA;    不基于重量的servlet标准&#xA;    基于netty&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;eureka&#34;&gt;&#xA;  Eureka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eureka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    @EnableEurekaServer&#xA;    application.properties&#xA;        eureka.client.register-with-eureka=false                # 是否注册自己&#xA;        eureka.client.fetch-registry=false                      # 是否拉取eureka&#xA;        eureka.client.service-url.defaultZone=http://localhost:7900/eureka/         # 设置注册中心的URL&#xA;        eureka.instance.hostname=euk1.com&#xA;        spring.application.name=EurekeServer                    # eureka集群中各节点要同名&#xA;行为&#xA;    register                    # 注册&#xA;    renew                       # 通过心跳, 默认30s。三次失败删除实例&#xA;    fetch registry              # 拉注册的信息&#xA;    cancel                      # 发取消请求，删除实例&#xA;    time lag                    # 同步时间延迟&#xA;    communication mechanism     # 通讯机制，默认jersey和jackson&#xA;功能&#xA;    唯一标识                        # service id&#xA;        主机名:application.name:端口&#xA;    提供RestAPI, 可多终端接入&#xA;问题&#xA;    一致性问题方案&#xA;        Eureka间不同步，client向多个Eureka提交&#xA;        Enreka间同步，Eureka强可用性弱一致性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    spring boot基础上构建，快速构建分布式系统, 全家桶&#xA;    面向云环境架构(云原生)    # 适合在docker和paas部署&#xA;功能&#xA;    配置管理&#xA;    服务发现&#xA;    熔断&#xA;    智能路由&#xA;    微代理&#xA;    控制总线&#xA;    全局锁&#xA;    决策竞选&#xA;    分布式会话&#xA;    集群状态管理&#xA;子项目&#xA;    spring cloud netflix    # 对netflix oss套件整合&#xA;        eureka     # 服务治理(注册、发现)&#xA;        hystrix    # 容错管理&#xA;        ribbon     # 软负载均衡(客户端)&#xA;        feign      # 基于hystrix和ribbon，服务调用组件&#xA;        zuul       # 网关，智能路由、访问过滤&#xA;        archaius   # 外部化配置&#xA;    基础&#xA;        spring cloud starters       # 基础依赖, 高版本取消&#xA;        spring cloud commons&#xA;    服务&#xA;        spring cloud consul         # 封装consul(服务发现与配置, 与docker无缝)&#xA;        spring cloud cluster        # 抽象zookeeper, redis, hazelcast, consul的选举算法和通用状态模式实现接口&#xA;        spring cloud cloudfoundry   # 与pivotal cloudfoundry整合&#xA;        spring cloud aws            # 整合aws&#xA;        spring cloud zookeeper      # 整合zookeeper&#xA;        spring cloud cli            # groovy中快速创建应用&#xA;        spring cloud task           # 任务&#xA;    配置&#xA;        spring cloud config         # 应用配置外部化, 推送客户端配置, 支持git存储&#xA;    消息&#xA;        spring cloud bus            # 消息总线，传播集群状态变化来触发动作，如刷新配置&#xA;        spring cloud stream         # 声明式发送、接收消息&#xA;    监控&#xA;        spring cloud sleuth         # 跟踪&#xA;    安全&#xA;        spring cloud security       # 应用安全控制, zuul代理中OAuth2中继器&#xA;    测试&#xA;        spring cloud contract       # 契约测试, 可用groovy和yaml定义&#xA;版本&#xA;    用命名不用版本号，因为有多子项目版本，易混淆&#xA;    命名用伦敦地铁站用，字母表排序&#xA;缺点&#xA;    难于追查框架问题&#xA;    非二进制通信协议&#xA;    适合中小团队&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;modules&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-common&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-provider-book&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-service-discovery&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-api-gateway&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-consumer-book&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-monitor-dashboard&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-aggregator&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-zipkin-server&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-admin-server&amp;lt;/module&amp;gt;&#xA;        &amp;lt;module&amp;gt;spring-cloud-config-server&amp;lt;/module&amp;gt;&#xA;    &amp;lt;/modules&amp;gt;&#xA;    &amp;lt;parent&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;relativePath/&amp;gt;&#xA;    &amp;lt;/parent&amp;gt;&#xA;    &amp;lt;dependencyManagement&amp;gt;&#xA;        &amp;lt;dependencies&amp;gt;&#xA;            &amp;lt;dependency&amp;gt;&#xA;                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;&#xA;                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;&#xA;                &amp;lt;version&amp;gt;Edgware.SR3&amp;lt;/version&amp;gt;&#xA;                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;&#xA;                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;&#xA;            &amp;lt;/dependency&amp;gt;&#xA;        &amp;lt;/dependencies&amp;gt;&#xA;    &amp;lt;/dependencyManagement&amp;gt;&#xA;    &amp;lt;repositories&amp;gt;&#xA;        &amp;lt;repository&amp;gt;&#xA;            &amp;lt;id&amp;gt;spring-releases&amp;lt;/id&amp;gt;&#xA;            &amp;lt;url&amp;gt;https://repo.spring.io/libs-release&amp;lt;/url&amp;gt;&#xA;        &amp;lt;/repository&amp;gt;&#xA;    &amp;lt;/repositories&amp;gt;&#xA;    &amp;lt;pluginRepositories&amp;gt;&#xA;        &amp;lt;pluginRepository&amp;gt;&#xA;            &amp;lt;id&amp;gt;spring-releases&amp;lt;/id&amp;gt;&#xA;            &amp;lt;url&amp;gt;https://repo.spring.io/libs-release&amp;lt;/url&amp;gt;&#xA;        &amp;lt;/pluginRepository&amp;gt;&#xA;    &amp;lt;/pluginRepositories&amp;gt;&#xA;application.yml&#xA;    spring:&#xA;        profiles: peer1                         # bean的逻辑组&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;组件&#34;&gt;&#xA;  组件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;dependencyManagement&#xA;    spring-cloud-dependencies&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-spring-boot&#34;&gt;&#xA;  spring cloud spring boot&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-spring-boot&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;spring-cloud-eureka&#34;&gt;&#xA;  spring cloud eureka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-eureka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    生产者向eureka注册, 周期发送心跳(默认30s)&#xA;    eureka服务间同步注册信息&#xA;    消费者请求地址，缓存本地&#xA;    eurake接收生产者心跳超时, 设置为down, 推送状态到消费者&#xA;    eurake短期down过多生产者，进入自我保护不再down&#xA;组件&#xA;    spring-cloud-starter-[netflix-]eureka-server&#xA;&#xA;application.yml&#xA;    eureka:&#xA;        instance:&#xA;            hostname: localhost                 # 实例主机名&#xA;        client:&#xA;            registerWithEureka: false           # 当前服务不注册&#xA;            fetchRegistry: false                # 不获取注册信息&#xA;            serviceUrl:                         # server地址&#xA;                defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/&#xA;bootstrap.yml                                   # 基础配置, 待拉取config&#xA;&#xA;注解&#xA;    @EnableEurekaServer                         # 修饰Application类&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-ribbon&#34;&gt;&#xA;  spring cloud ribbon&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-ribbon&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    ribbon:&#xA;        eureka:&#xA;            enabled: false                      # 禁止从eureka获得注册列表&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-hystrix&#34;&gt;&#xA;  spring cloud hystrix&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-hystrix&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 单个服务监控&#xA;hystrix dashboard&#xA;    路径&#xA;        /hystrix&#xA;        /hystrix.stream                         # 至少请求一次接口，才有数据&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-turbine&#34;&gt;&#xA;  spring cloud turbine&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-turbine&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 多服务监控&#xA;application.yml&#xA;    turbine:&#xA;        aggregator:&#xA;            clusterConfig: default                                  # 此监控器名&#xA;        appConfig: erp-consumer-metadb, erp-consumer                # 目标服务名&#xA;        clusterNameExpression: new String(&amp;quot;default&amp;quot;)                # 名称匹配表达式&#xA;路径&#xA;    /turbine.stream&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-feign&#34;&gt;&#xA;  spring cloud feign&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-feign&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    feign:&#xA;        hystrix:&#xA;            enabled: true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-zuul&#34;&gt;&#xA;  spring cloud zuul&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-zuul&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 默认会用ribbon负载均衡&#xA;application.yml&#xA;    zuul:&#xA;        prefix: /v1&#xA;        routes:&#xA;            hiapi:&#xA;                path: /hiapi/**&#xA;                serviceId: erp-consumer-metadb&#xA;                # url: http://localhost:8762  # 这样写不会做负载均衡&#xA;                # serviceId: hiapi-v1&#xA;&#xA;    ## 手动url负载均衡&#xA;    # ribbon: &#xA;    #   eureka:&#xA;    #     enabled: false&#xA;    # hiapi-v1:&#xA;    #   ribbon:&#xA;    #     listOfServers: http://localhost:8762,http://localhost:8763&#xA;案例&#xA;    过滤&#xA;        import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;&#xA;        @Component&#xA;        public class MyFilter extends ZuulFilter {&#xA;&#xA;            private static Logger log = LoggerFactory.getLogger(MyFilter.class);&#xA;&#xA;            @Override&#xA;            public String filterType() {&#xA;                return PRE_TYPE;&#xA;            }&#xA;&#xA;            @Override&#xA;            public int filterOrder() {&#xA;                return 0;&#xA;            }&#xA;&#xA;            @Override&#xA;            public boolean shouldFilter() {&#xA;                return true;&#xA;            }&#xA;&#xA;            @Override&#xA;            public Object run() {&#xA;                RequestContext ctx = RequestContext.getCurrentContext();&#xA;                HttpServletRequest request = ctx.getRequest();&#xA;                log.info(String.format(&amp;quot;%s &amp;gt;&amp;gt;&amp;gt; %s&amp;quot;, request.getMethod(), request.getRequestURL().toString()));&#xA;                Object accessToken = request.getParameter(&amp;quot;token&amp;quot;);&#xA;                if (accessToken == null) {&#xA;                    log.warn(&amp;quot;token is empty&amp;quot;);&#xA;        //&#xA;        //            ctx.setSendZuulResponse(false);&#xA;        //            ctx.setResponseStatusCode(401);&#xA;        //            try {&#xA;        //                ctx.getResponse().getWriter().write(&amp;quot;token is empty&amp;quot;);&#xA;        //            }catch (Exception e){&#xA;        //&#xA;        //            }&#xA;                    return null;&#xA;                }&#xA;                log.info(&amp;quot;ok&amp;quot;);&#xA;                return null;&#xA;            }&#xA;        }&#xA;    熔断&#xA;        @Component&#xA;        public class MyFallbackProvider implements ZuulFallbackProvider {&#xA;            @Override&#xA;            public String getRoute() {&#xA;                return &amp;quot;*&amp;quot;;&#xA;            }&#xA;&#xA;            @Override&#xA;            public ClientHttpResponse fallbackResponse() {&#xA;                return new ClientHttpResponse() {&#xA;                    @Override&#xA;                    public HttpStatus getStatusCode() throws IOException {&#xA;                        return HttpStatus.OK;&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public int getRawStatusCode() throws IOException {&#xA;                        return 200;&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public String getStatusText() throws IOException {&#xA;                        return &amp;quot;OK&amp;quot;;&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public void close() {&#xA;&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public InputStream getBody() throws IOException {&#xA;                        return new ByteArrayInputStream(&amp;quot;error, I&#39;m the fallback&amp;quot;.getBytes());&#xA;                    }&#xA;&#xA;                    @Override&#xA;                    public HttpHeaders getHeaders() {&#xA;                        HttpHeaders headers = new HttpHeaders();&#xA;                        headers.setContentType(MediaType.APPLICATION_JSON);&#xA;                        return headers;&#xA;                    }&#xA;                };&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-config&#34;&gt;&#xA;  spring cloud config&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-config&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;config-server&#xA;    application.yml&#xA;        server:&#xA;            port: 9012&#xA;        spring:&#xA;            application:&#xA;                name: erp-config-server&#xA;            cloud:&#xA;                config:&#xA;                server:&#xA;                    native:&#xA;                        search-locations: classpath:/shared             # 读取路径&#xA;            profiles:&#xA;                active: native                                          # 本地读取&#xA;    shared/config-client-dev.yml                                        # 文件名为 [客户端服务名]-[profile变量]&#xA;        server:&#xA;            port: 9013&#xA;        foo: foo version 1&#xA;    地址&#xA;        localhost:9012/config-client/dev                                # 查看分发给服务的配置&#xA;config-client&#xA;    spring:&#xA;        application:&#xA;            name: erp-config-client&#xA;        cloud:&#xA;            config:&#xA;                uri: http://localhost:9012&#xA;                fail-fast: true&#xA;        profiles:&#xA;            active: dev&#xA;注解&#xA;    @RefreshScope                           # 热更新&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-bus&#34;&gt;&#xA;  spring cloud bus&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-bus&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    spring:&#xA;        rabbitmq:&#xA;            host: localhost&#xA;            port: 5672&#xA;            username: outrun&#xA;            password: asdf&#xA;            publisher-confirms: true&#xA;            virtual-host: /&#xA;    management:&#xA;        security:&#xA;            enabled: false&#xA;路径&#xA;    POST /bus/refresh                       # 从新拉配置, 其它服务也触发同步&#xA;        ?destination=appName:*.*            # 指定刷新服务名下实例&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-cloud-stream&#34;&gt;&#xA;  spring cloud stream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-stream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;spring-cloud-sleuth&#34;&gt;&#xA;  spring cloud sleuth&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-sleuth&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    zipkin:&#xA;        base-url: http://localhost:9014&#xA;    sleuth:&#xA;        sampler:&#xA;            percentage: 1.0&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
