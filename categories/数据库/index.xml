<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on ukeate的笔记</title>
    <link>https://ukeate.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 01 Jan 2025 08:50:36 -0700</lastBuildDate>
    <atom:link href="https://ukeate.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据库</title>
      <link>https://ukeate.com/docs/db/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ukeate.com/docs/db/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据库类型&#xA;    关系型数据库&#xA;    模糊型数据库&#xA;        # 存放模糊数据，提供函数&#xA;        如模糊数，包括模糊区间数，模糊中心数，模糊集合数&#xA;        隶属函数&#xA;    统计数据库&#xA;        # 管理统计数据&#xA;        这类数据库包含有大量的数据记录，但其目的是向用户提供各种统计汇总信息，而不是提供单个记录的信息。&#xA;    网状数据库(层次数据库)&#xA;        # 处理以记录类型为结点的网状数据模型&#xA;        处理方法是将网状结构分解成若干棵二级树结构，称为系。&#xA;    演绎数据库&#xA;        # 指具有演绎推理能力&#xA;        实现&#xA;            数据库管理系统&#xA;            规则管理系统&#xA;        外延数据库&#xA;            将推理用的事实数据存放在数据库中&#xA;        内涵数据库&#xA;            用逻辑规则定义要导出的事实&#xA;        主要研究内容: 如何有效地计算逻辑规则推理。&#xA;            递归查询的优化&#xA;            规则的一致性维护&#xA;&#xA;其它数据存储方式&#xA;    文件系统&#xA;        版本控制&#xA;    保存持久状态&#xA;        CQRS(command query responsibility segregation)&#xA;            查询(query)&#xA;            命令(command)&#xA;            领域模型(domain model)&#xA;            领域事件(domain event)&#xA;    对象数据库&#xA;趋势&#xA;    分布式new sql  # tidb&#xA;    Polyglot persistence (混合持久化)&#xA;        # 将对不同数据库的操作封装成服务&#xA;&#xA;事务隔离级别&#xA;    读未提交（Read Uncommitted）  # 读其它事务未提交的数据&#xA;        现象&#xA;            不允许更新丢失&#xA;            允许脏读(dirty read)               # 事务中读到不存在数据, 是其它事务修改中的数据&#xA;        原理&#xA;            可同时读&#xA;            不同时写，多事务写&#xA;        实现&#xA;            排他写锁&#xA;    读提交（Read Committed）                    # 读其它事务提交的数据&#xA;        现象&#xA;            不允许脏读&#xA;            允许不可重复读(nonRepeatable read)   # 事务中前后查询不一致&#xA;        原理&#xA;            可同时读&#xA;            单事务写&#xA;        实现&#xA;            瞬间共享读锁&#xA;            排他写锁&#xA;    可重复读（Repeatable Read）                  # 读到的数据加锁，解决不可重复读问题&#xA;        现象&#xA;            不允许脏读&#xA;            不允许不可重复读&#xA;            允许幻读(phantom read)               # 事务中存在未生效行，是其它事务的插入或删除&#xA;        原理&#xA;            读到的数据(加锁)不写&#xA;            单事务写&#xA;        实现      # 读涉及范围加锁&#xA;            共享读锁&#xA;            排他写锁&#xA;    序列化（Serializable）       # 或叫串行化&#xA;        原理&#xA;            事务序列化执行&#xA;        实现&#xA;            读锁写锁互斥&#xA;事务特点(ACID)&#xA;    原子性(atomicity)          # 什么都做或都不做&#xA;    一致性(correspondence)     # 事务前后数据库状态一致, 事务中断时也不会有暂时状态&#xA;    隔离性(isolation)          # 事务间不干扰&#xA;    持久性(durability)         # 提交结果是永久的&#xA;索引存储&#xA;    B+ tree&#xA;    LSM(log-structured merge) tree&#xA;    fractal tree&#xA;OLTP和OLAP&#xA;    CAP(一致性、可用性、分区容错性)中, OLTP要求ca或cp, OLAP要求ap&#xA;    OLTP要求写优化, OLAP要求查优化&#xA;    OLTP要求优化latency, OLAP要求优化throughput&#xA;    OLTP基于row, OLAP基于column&#xA;    OLTP看中IOPS, OLAP看中data-size传输&#xA;分布式数据库&#xA;    面临问题&#xA;        ACID&#xA;        CAP&#xA;        scale out&#xA;        self-healing&#xA;        运维友好&#xA;        sql&#xA;        事务&#xA;        性能&#xA;        api用明文或二进制&#xA;        升级方案&#xA;        硬件，网络，网络模型，存储模型，语言&#xA;        分布式协议，压缩方案，ha，api，运维方案，存储计算分离，缓存方案&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;rds&#34;&gt;&#xA;  rds&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rds&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# relational database service&#xA;缺点&#xA;    阻抗失谐    # 和内存中的模型存在差异&#xA;安全&#xA;    sql注入   # 应该写符号编译sql&#xA;范式&#xA;    # Normal Form 用于避免冗余数据&#xA;    第一范式(1NF)&#xA;        列不可再细分列(原子性)&#xA;    第二范式(2NF)&#xA;        必须有主键，允许联合主键&#xA;        其它列依赖完整主键(不能只依赖一部分)&#xA;    第三范式(3NF)&#xA;        其它列直接依赖主键(非传递依赖，如A依赖B, B依赖主键)&#xA;实例&#xA;    postgres&#xA;    sqlserver&#xA;    mysql&#xA;    mariadb&#xA;    percona&#xA;        # mysql分支, Oracle发布的最接近官方mysql的发行版&#xA;    drizzle&#xA;        # mysql分支&#xA;    oracle&#xA;    db2&#xA;    oceandb&#xA;    h2database&#xA;        # java编写，可嵌入java使用&#xA;    tidb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sqlite&#34;&gt;&#xA;  sqlite&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sqlite&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;命令&#xA;    sqlite3 数据库文件&#xA;语法&#xA;    .table              # 查看所有表&#xA;    .schema             # 查看建表语句&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sql&#34;&gt;&#xA;  sql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;语法&#xA;    注释&#xA;        --      # 单行注释&#xA;        /**/    # 多行注释&#xA;    单引号&#xA;        字符串大小写敏感&#xA;    双引号&#xA;        转日期时, 双引号直接显示。to_char(sysdate,&#39;yyyy &amp;quot;年&amp;quot; mm &amp;quot;月&amp;quot; dd &amp;quot;日&amp;quot; day&#39;)&#xA;    表别名不加as关键字, 有别名后原名无效&#xA;    oracle&#xA;        ||      # 管道符号&#xA;            select ename || &#39;的薪水是&#39; || sal from emp;&#xA;定义(DDL, data definition language)&#xA;    create database db1             # create or replace&#xA;        default character set utf8          # 默认编码&#xA;        collate utf8_general_ci;    # 校对规则(排序), ci(case insensitive)大小写不敏感, cs(case sensitive)大小写敏感&#xA;    create table `tb1`(           # create or replace&#xA;        `id` int unsigned unique not null auto_increment,&#xA;            # `id` int unsigned not null primary key,&#xA;        `id2` int unsigned,&#xA;        `name` varchar(20),&#xA;        `age` int unsigned,&#xA;        `birthday` date,&#xA;        primary key(`id`),          # 主键&#xA;        key idx_tb1_name (`name`),   # 索引&#xA;        foreign key(`id2`) references `tb2`(id) on delete cascade on update cascade     # 外键、级联删除、级联更新, 不要用&#xA;        )character set utf8 collate utf8_general_ci&#xA;        engine=innodb default charset=utf8;&#xA;    create table person like student;           # 复制表结构&#xA;    create table emp1 as select * from emp;     # 复制内容&#xA;    create view tb1_v (a,b) as select a, b from tb1 #  create or replace&#xA;    create synonym tb2 for tb1;     # 同义词&#xA;&#xA;    drop database db1;&#xA;    drop table tb1&#xA;        purge;              # 加purge不放入回收站&#xA;    drop synonym tb1;&#xA;&#xA;    truncate table tbq;&#xA;&#xA;&#xA;    alter database db1&#xA;        character set gbk&#xA;        collate gbk_chinese_ci;        # 更改数据库的编码&#xA;    alter table tb1&#xA;        add column sex char(1);&#xA;    alter table tb1&#xA;        add constraint pr_id primary key (id);   # 添加主键&#xA;    alter table tb1&#xA;        add constraint fk_id2 foreign key (st_id) references tb2(id);  # 添加外键&#xA;    alter table tb1&#xA;        rename to tb2;&#xA;    alter table tb1&#xA;        change sex gender char(1);      # 只能改名，但类型必须写&#xA;    alter table tb1&#xA;        modify birthday varchar(20);    # 只能改类型&#xA;    alter table tb1&#xA;        convert to character set utf8 collate utf8_general_ci;  # 转换表编码&#xA;    alter table tb1&#xA;        drop column name;&#xA;    alter table field1&#xA;        auto_increment = 5;             # 更改自增长初始值&#xA;&#xA;&#xA;    rename table tb1 to tb2;&#xA;&#xA;    desc tb1;&#xA;&#xA;&#xA;    mysql&#xA;        use db1&#xA;&#xA;        source a.sql            # 批执行&#xA;&#xA;        show status [from schema_name];         # 服务器状态&#xA;        show databases;&#xA;        show create database db1;&#xA;        show tables;&#xA;        show create table tb1;&#xA;        show processlist                        # 查看当前连接&#xA;        show VARIABLES LIKE &amp;quot;general_log%&amp;quot;      # 查看变量　&#xA;            &amp;quot;version&amp;quot;                           # 显示版本&#xA;            &amp;quot;autocommit&amp;quot;                        # 事务开启状态 0 off 1 on, set autocommit=off 或 0&#xA;        show character set                      # 显示所有字符集&#xA;&#xA;&#xA;&#xA;        select @@sql_mode                       # 查看变量&#xA;        select @@tx_isolation                   # 查看事务隔离级别&#xA;        select&#xA;        select VERSION()                        # 显示版本&#xA;&#xA;        set sql_mode = &#39;&#39;                       # sql_mode定义支持的sql语法，数据校验。&#xA;        set names &#39;gbk&#39;;                        # 设置终端编码, 等价character_set_client=gbk 与 character_set_results=gbk&#xA;        set global general_log = &#39;ON&#39;           # 设置记录所有sql&#xA;&#xA;    oracle&#xA;        create table tb1 (&#xA;            sex char(1) check(sex in (0, 1))        # check约束&#xA;        show user                   # 显示用户名&#xA;        show recyclebin             # 回收站&#xA;        purge recyclebin            # 闪回文件&#xA;        oracle表创建时自动添加伪列&#xA;            rowid       # 唯一，指向当前记录&#xA;            rownum      # 唯一，字段列名, 从1开始，永远连续。&#xA;                # 支持比较符号 &amp;lt;, &amp;lt;=(可以比较=1)。取别名后可以比较 &amp;gt;, =&#xA;&#xA;&#xA;操作(DML, data manipulation language)&#xA;    # 和DQL, data query language, select、from、where&#xA;    insert into tb1&#xA;        values (3, &#39;a&#39;, null);&#xA;    insert into tb1&#xA;        select * from tb2;&#xA;    insert into tb1(name)&#xA;        values (&#39;a&#39;),(&#39;b&#39;);&#xA;    insert into tb1(a, b)&#xA;        select c, d from tb2&#xA;&#xA;    update tb1&#xA;        set name=&#39;a&#39;&#xA;&#xA;    delete from tb1&#xA;&#xA;&#xA;    select * from outrun.employee;      # 限定数据库名&#xA;    select field1 as f1 from tb1 as t1&#xA;    select a, b into tb2 from tb1;&#xA;    select distinct (a+b) as c from tb1&#xA;        # select distinct sum(price) as s&#xA;    子查询&#xA;        # 要求数量和类型匹配&#xA;        # 不能利用索引(join可以), 不形成笛卡尔积&#xA;&#xA;        where a &amp;lt; (select max(a) from tb2)&#xA;            # 单行符号 =、&amp;lt;、&amp;gt;&#xA;        where a in ()&#xA;            # 多行符号 in、any、all&#xA;            where a &amp;lt; any ()    # 小于一个就true&#xA;            where a &amp;lt; all ()    # 小于所有才true&#xA;&#xA;&#xA;&#xA;    where a=1 and b=2                   # where后不能出现列的别名，可以出现表的别名&#xA;        a=1 or b=2&#xA;            # &amp;lt;&amp;gt;表示!=&#xA;            # =可设置日期&#xA;        a in (1,2)&#xA;            # a not in (1,2)&#xA;        a between 1 and 2&#xA;            # a not between 1 and 2&#xA;        a like &#39;a%&#39;&#xA;            # 不能用*&#xA;            # % 匹配任意个字符&#xA;            # _ 匹配一个字符&#xA;            # \ 转义 _ 或 %&#xA;        a regexp &#39;^.*d.*$&#39;&#xA;            # 匹配正则&#xA;        a is null&#xA;    order by    # null看作最大值&#xA;        a asc   # 升序&#xA;        a desc  # 降序&#xA;    group by&#xA;        select a, count(b), avg(c) from tb1     # group by的select元素都是聚合函数&#xA;            where b &amp;gt; 0&#xA;            group by a&#xA;            having count(b) &amp;gt; 2                 # having使用聚合函数条件&#xA;        select a from tb1                       # 子查询&#xA;            where b in (select b from tb2 where c=&#39;c&#39;)&#xA;            group by a&#xA;            having count(distinct b) = (select count(*) from tb2 where c=&#39;c&#39;)&#xA;&#xA;&#xA;    select执行过程&#xA;        # 每步都产生虚拟表&#xA;        from 组装数据&#xA;            join&#xA;            on&#xA;        where 筛选&#xA;        group by 划分&#xA;        # with,  with是sql server的语法&#xA;        计算聚合函数&#xA;        having 筛选&#xA;        计算表达式&#xA;        select 字段&#xA;            distinct&#xA;        order by 排序&#xA;        top&#xA;&#xA;    oracle&#xA;        insert into tb1 values(&amp;amp;id, &#39;&amp;amp;s&#39;)                   # &amp;amp;是占位符，字符型数据加&#39;&#39;&#xA;        alter table tb1 rename column field1 to field2&#xA;&#xA;    常用&#xA;        分页&#xA;            select * from tb1 limit 0,1         # mysql, 从0开始，查找1条&#xA;&#xA;&#xA;            select * from                       # oracle&#xA;                (select rownum r, a from tb1 where rownum&amp;lt;=20)&#xA;            where r &amp;gt; 10&#xA;&#xA;            select * from                       # oracle,  效率低&#xA;                (select  rownum rn, a from tb1)&#xA;            where rn between 21 and 40&#xA;&#xA;&#xA;            select rownum,emp.* from emp        # oracle, 效率低&#xA;                where rownum &amp;lt;=4&#xA;            minus&#xA;            select rownum,emp.* from emp&#xA;                where rownum &amp;lt;=2;&#xA;&#xA;控制(DCL data control language)&#xA;&#xA;    grant all privileges on db1.tb1         # 授权&#xA;        # grant insert,delete,update,select,create on db1.tb1&#xA;        to &#39;user1&#39;@&#39;host1&#39;          # localhost本地 , %代表远程&#xA;        identified by &#39;pwd1&#39;&#xA;        with grant option;          # 有授权权限&#xA;    grant select any table      # oracle&#xA;        to user1&#xA;    revoke select any table     # oracle&#xA;        from user1&#xA;&#xA;    revoke privilege ON db1.tb1 from &#39;user1&#39;@&#39;host1&#39;;       # 撤销权限&#xA;    flush privileges;        # 提交授权修改, oracle不用flush直接生效&#xA;&#xA;&#xA;    oracle&#xA;        alter user user1 account unlock             # 解锁用户&#xA;        alter user user1 identified by user1        # 改密码&#xA;        conn / as sysdba                            # 换角色&#xA;&#xA;事务&#xA;    start transaction;&#xA;    savepoint a;&#xA;    rollback to [savepoint] a;&#xA;    rollback;&#xA;    commit;&#xA;&#xA;聚合函数&#xA;    avg()&#xA;    count()&#xA;    max()&#xA;    min()&#xA;    sum()&#xA;&#xA;&#xA;连接(join)&#xA;    内连接(inner)&#xA;        # 带条件的交叉连接&#xA;        # 只查出符合条件的记录&#xA;        select * from tb1 a         # 显示&#xA;            inner join tb2 b&#xA;            on a.c_id=b.c_id&#xA;        select * from tb1 a, tb2 b  # 隐示&#xA;            where a.c_id=b.c_id&#xA;        自连接     # 表中有层次关系。自连接无中间表, 效率快&#xA;            select a.c, b.d from course as a, course as b&#xA;                where a.c=b.d&#xA;    外连接(outer)&#xA;        # 以一表为基准，查另一表&#xA;        # 可查出不符合条件的记录(另一表无对应值，标记成null)&#xA;        左外连接&#xA;            # 以左为基准&#xA;            select * from tb1 as a&#xA;                left [outer] join tb2 as b&#xA;                on a.c_id=b.c_id&#xA;&#xA;            select a.c_id       # oracle&#xA;            from tb1 a, tb2 b&#xA;            where a.c_id = b.c_id(+)&#xA;        右外连接&#xA;                right [outer] join&#xA;        全外连接&#xA;            # full [outer] join, 只oracle支持&#xA;            # 先左连接再右连接，取的是交集&#xA;            select * from a&#xA;                full join b&#xA;                on a.c_id=b.c_id&#xA;    交叉连接(cross)     # 笛卡尔积&#xA;        # 有where条件时，会先生成where查出的两个表&#xA;        select * from tb1 a&#xA;            [cross] join tb2 b&#xA;            where a.c_id = b.c_id;&#xA;    自然连接(natural)&#xA;        # 自动检查相同名称的列，类型会隐式转换，不能指定显示列(或用*)、不能用on语句&#xA;        # 每种连接名称前加natural都是自然连接&#xA;        select * from tb1 a&#xA;            natural innter join tb2 b&#xA;集合&#xA;    # 数量,类型匹配&#xA;    # 前语句别名可用,后语句别名不可用&#xA;    select a, b from tb1&#xA;        union [all] select a, b from tb2    # 并集, all 允许重复&#xA;            # intersect 交集&#xA;            # minus 差集&#xA;&#xA;约束(constraint)&#xA;    not null&#xA;    unique&#xA;    primary key&#xA;        primary key unique, not null auto_increment&#xA;        primary key(col1, col2)     # 联合主键&#xA;    foreign key&#xA;        constraint fk_id2&#xA;            foreign key(id2) references tb2(id)&#xA;                # 被引用的列要建索引&#xA;                # 被引用的记录不可删除&#xA;                # 被引用的值要级联修改&#xA;            on update cascade&#xA;            on delete cascade&#xA;                # 级联约束&#xA;    检查约束    # oracle支持&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;存储过程&#34;&gt;&#xA;  存储过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;优势&#xA;    高效, 首次运行进行预编译&#xA;    模块化&#xA;    更快执行，大量sql时，比sql快&#xA;    减少网络流量&#xA;    安全机制&#xA;        针对过程授权&#xA;        调用时看不到语句信息和数据&#xA;        避免sql注入     # 参数视为文字&#xA;        可对过程加密&#xA;劣势&#xA;    不可移植&#xA;    需要专人维护&#xA;    逻辑变更时修改不灵活&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;触发器&#34;&gt;&#xA;  触发器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a6%e5%8f%91%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;用途&#xA;    表级联更改&#xA;    实现比check约束复杂的逻辑&#xA;    强制执行业务规则&#xA;    评估修改后表状态，执行操作&#xA;基础&#xA;    同一表不能建立2个相同类型触发器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;视图&#34;&gt;&#xA;  视图&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%86%e5%9b%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    优点&#xA;        简化查询&#xA;        提供独立访问&#xA;        限制访问&#xA;    查看时，生成sql查看, 有即时性&#xA;    更新视图表级联&#xA;        不能更新的视图包含元素&#xA;            组函数&#xA;            distinct&#xA;            group by&#xA;            rownum&#xA;    grant可授权&#xA;    不能与表名重名&#xA;    mysql保存在information_schema.views中&#xA;    删除不放回收站&#xA;&#xA;    CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]       # TEMPTABLE是临时表，不能更新&#xA;        VIEW view_name [(column_list)]&#xA;        AS select_statement&#xA;        [WITH [CASCADED | LOCAL] CHECK OPTION]                      # 通过该视图更改的数据，可再通过该视图查看到(满足视图的限制)&#xA;    o-&amp;gt;&#xA;    CREATE VIEW test.v AS SELECT * FROM t;&#xA;    o-&amp;gt;&#xA;    CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;                # 可以计算&#xA;    o-&amp;gt;&#xA;    CREATE VIEW v AS SELECT CHARSET(CHAR(65)), COLLATION(CHAR(65));                # 可以联合&#xA;    o-&amp;gt;&#xA;    CREATE ALGORITHM = MERGE VIEW v_merge (vc1, vc2)&#xA;        AS SELECT c1, c2 FROM t1 WHERE c3 &amp;gt; 100&#xA;&#xA;        查询解释&#xA;            SELECT * FROM v_merge WHERE vc1 &amp;lt; 100; 会执行&#xA;            SELECT c1, c2 FROM t WHERE (c3 &amp;gt; 100) AND (c1 &amp;lt; 100);&#xA;&#xA;&#xA;    ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]&#xA;        VIEW view_name [(column_list)]&#xA;        AS select_statement&#xA;        [WITH [CASCADED | LOCAL] CHECK OPTION]              # CASCADED 忽略主外键关系&#xA;&#xA;    DROP VIEW [IF EXISTS]&#xA;        view_name [, view_name] ...&#xA;        [RESTRICT | CASCADE]&#xA;&#xA;    SHOW CREATE VIEW view_name&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;索引&#34;&gt;&#xA;  索引&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    第一次查询时创建&#xA;    加快查询的速度，表删除时索引自动删除&#xA;    primary key 与 unique 自动建立&#xA;命中&#xA;    where 中添加对应索引的条件， 只能从前向后命中&#xA;是否使用&#xA;    使用&#xA;        分布广&#xA;        经常在where中出现&#xA;        表经常访问&#xA;    不使用&#xA;        表小&#xA;        不经常出现的列&#xA;        经常更新的字段&#xA;类型&#xA;    index&#xA;    unique&#xA;    primary key&#xA;&#xA;CREATE INDEX index_name ON table_name (column_list)         # 创建索引，primary key已有索引&#xA;CREATE UNIQUE INDEX index_name ON table_name (column_list)&#xA;&#xA;ALTER TABLE table_name ADD INDEX index_name (column_list) # 创建索引，列名逗号分隔。index_name缺省时，根据第一个索引列取名&#xA;ALTER TABLE table_name ADD UNIQUE (column_list)&#xA;ALTER TABLE table_name ADD PRIMARY KEY (column_list)&#xA;&#xA;DROP INDEX index_name ON talbe_name&#xA;ALTER TABLE table_name DROP INDEX index_name        # 等价于前一个&#xA;ALTER TABLE table_name DROP PRIMARY KEY&#xA;&#xA;show index from tb1;&#xA;show keys from tb1;&#xA;    Table         # 表的名称。&#xA;    Non_unique    # 如果索引不能包括重复词，则为0。如果可以，则为1。&#xA;    Key_name      # 索引的名称。&#xA;    Seq_in_index  # 索引中的列序列号，从1开始。&#xA;    Column_name   # 列名称。&#xA;    Collation     # 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。&#xA;    Cardinality   # 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。&#xA;    Sub_part      # 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。&#xA;    Packed        # 指示关键字如何被压缩。如果没有被压缩，则为NULL。&#xA;    Null          # 如果列含有NULL，则含有YES。如果没有，则该列含有NO。&#xA;    Index_type    # 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。&#xA;    Comment       # 更多评注。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;序列&#34;&gt;&#xA;  序列&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%8f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 共享对象唯一的数值，不一定连续&#xA;create sequence tb1_seq&#xA;    INCREMENT BY 10              # 步长是10&#xA;    START WITH 120               # 从120开始&#xA;    MAXVALUE 9999                # 最大到9999&#xA;    NOCACHE                      # 不缓存序列的值（缓存是先创建很多再取出，不缓存则是什么时候取，什么时候创建）&#xA;    NOCYCLE;                     # 到最大值的时候是否循环&#xA;&#xA;select seq.nextval from dual                # nextval下一个序列 currval当前序列  第一次使用必须是nextval&#xA;insert into emp(id) vallues(seq.nextval);   # 使用&#xA;alter sequence tb1_seq increment by 10;&#xA;    start with 100;                         # 错误 ，不能变更启动序列，只能在创建序列时指定&#xA;drop sequence seq&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;性能优化&#34;&gt;&#xA;  性能优化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;设计&#xA;    库&#xA;        分库&#xA;            拆微服务&#xA;            主从      # master不拆，slave树形&#xA;            索引与数据分库&#xA;    表&#xA;        不要代价高的关系(外键、级联)&#xA;        字段可冗余，为了提高性能，但要考虑同步。不能是频繁修改的字段，不是varchar和text&#xA;        单表行数超过500万或意表容量超过2GB，才分库分表&#xA;        分表  # 垂直分字段，水平分记录&#xA;            表名加hash到多表&#xA;            partitioning key字段分表    # proxy网关分流&#xA;                时间&#xA;                地点&#xA;            建lookup table查找对应表&#xA;            冷热分离&#xA;        用表变量代替临时表&#xA;        表变量数据大时，只有主键索引&#xA;        大量重复引用大型表或常用表数据时，可创建临时表。一次性事件，最好导出表&#xA;        临时表时数据大时, 用select into代替create table, 避免log过多&#xA;        临时表最后要先truncate, 再drop, 避免表较长时间锁定&#xA;    类型&#xA;        尽量not null&#xA;        数字类型尽量用&#xA;        char存几乎定长字符串类型&#xA;        varchar变长字符串，不预先分配空间，长度不要超过5000&#xA;        text存大于5000,独立出表用主键对应，避免影响其它字段索引效率&#xA;        bool用unsigned tinyint&#xA;        小数类型用decimal，不用float double&#xA;            # float和double存储的时候，存在精度损失的问题&#xA;            # 长度超过decimal范围，拆成整数和小数分开存&#xA;        合适的字符长度，不但节约表空间，节约索引存储，更提升检索速度&#xA;            unsigned tinyint    0到255&#xA;            unsigned smallint    0到65535&#xA;            unsigned int    0到42.9亿&#xA;            unsigned bigint    0到10的19次方&#xA;    索引&#xA;        有唯一特性，都建唯一索引&#xA;            # insert速度损耗可以忽略，但明显提高查找速度&#xA;            # 不建唯一索引，总会有脏数据产生&#xA;        where与order by涉及的列建索引&#xA;        建组合索引时，区分度最高的在左边&#xA;            where a=? and b=? ，a列几乎接近唯一值，只需要建idx_a索引&#xA;            非等号和等号混合时，等号是最左边，如where a&amp;gt;? and b=?, 那么b在索引最前列&#xA;        字段值大量重复时，索引作用不大&#xA;        索引降低insert与update效率&#xA;        索引数据列少更新           # 数据列为表存储方式，更新会调整整表存储&#xA;        varchar建索引，要指定索引长度&#xA;            一般字符串数据，长度为20的索引，区分度高达90%以上&#xA;            count(distinct left(列名，索引长度)) / count(*)来计算&#xA;语句&#xA;    where放弃索引，全盘扫描&#xA;        比较符&#xA;            in      # in元素尽量控制在1000内&#xA;            not in&#xA;            # exists代替in&#xA;                select num from a where num in(selct num from b)    改为&#xA;                select num from a where exists(select 1 from b where num=a.num)&#xA;            is null&#xA;            is not null&#xA;            &amp;lt;&amp;gt;&#xA;            or&#xA;            like &#39;%a&#39;模糊开头&#xA;&#xA;        where对字段用表达式或运行函数&#xA;            where num/2=100 改为&#xA;            where num = 100*2&#xA;&#xA;            where year(admin_time)&amp;gt;2014 改为&#xA;            where admin_time&amp;gt;&#39;2014-01-01&#39;&#xA;        where使用参数       # 因为运行时解析局部变量，访问计划在编译时进行&#xA;            select id from t where num=@num 改为&#xA;            select id from t with(index(索引名)) where num=@num    # 强制使用索引&#xA;    select&#xA;        不要写无意义查询&#xA;            select a into #t from t where 1=1 改为&#xA;            create table #t&#xA;        不要select *             # 增加查询分析器解析成本，增减字段容易与resultMap不一致&#xA;        不select for update      # 长期锁定行(游标默认都用)&#xA;            不要用游标&#xA;    函数&#xA;        使用count(*)统计行数&#xA;            用count(distinct col1, col2)来计算不重复&#xA;        sum(col)会返回null，如下解决&#xA;            SELECT IF(ISNULL(SUM(g)), 0, SUM(g)) FROM table1&#xA;        使用ISNULL()来判断NULL&#xA;            # NULL与任何值比较都为NULL&#xA;业务&#xA;    sql优化至少到range级别&#xA;        # explain结果type=&#xA;        # all 全表扫描&#xA;        # index 扫描整个索引表，几乎相当于全表扫描&#xA;        # range 用索引选择范围&#xA;        # ref 非唯一索引扫描&#xA;        # eq_ref 唯一索引扫描&#xA;        # consts 索引一下就找到，单表中最多有一个匹配行(主键或唯一索引), 在优化阶段即可读取到数据&#xA;        # system 表只有一行&#xA;    库&#xA;        不在数据库写逻辑           # 不使用存储过程, 难调试和扩展，没有移植性&#xA;        正确锁类型                # 隐式锁、显式锁、行锁、页锁、范围锁、表锁、数据库锁&#xA;        全球化用utf-8，要使用表情，用utfmb4&#xA;            SELECT LENGTH(&amp;quot;轻松工作&amp;quot;) 返回 12&#xA;            SELECT CHARACTER_LENGTH(&amp;quot;轻松工作&amp;quot;) 返回4&#xA;    事务&#xA;        不要多阶段提交             # 更好的拆分表，而不多阶段提交延长单一数据库生命&#xA;        避免大事务&#xA;        连接释放&#xA;    crud&#xA;        TRUNCATE快，但无事务不触发trigger, 不要在开发代码中使用&#xA;        修改数据时，先select，避免误删除和修改&#xA;        分页时count为0直接返回&#xA;        用覆盖索引来变相加快查询，如explain的结果，命中时出现using index&#xA;        避免返回大量数据&#xA;        order by注意利用索引的有序性，order by最后的字段是组合索引的最后，避免file_sort&#xA;            如 where a=? and b=? order by c; 索引 a_b_c&#xA;            有范围查找时，有序性无法利用，如 where a&amp;gt;10 order by b&#xA;    联合&#xA;        多表联合查询拆分多个query     # 容易锁表和阻塞&#xA;        禁止三表join&#xA;            join的字段类型要一致&#xA;            被关联的字段需要有索引&#xA;            注意sql性能&#xA;        join时，小结果驱动大结果      # left join小表在左&#xA;            优化前&#xA;                select * from admin&#xA;                left join log on admin.admin_id = log.admin_id&#xA;                where log.admin_id&amp;gt;10&#xA;            优化后&#xA;                select * from&#xA;                    (select * from admin where admin_id&amp;gt;10) T1&#xA;                left join log on T1.admin_id = log.admin_id&#xA;mysql&#xA;    引擎选择&#xA;    limit 1&#xA;        只查一条时，加limit 1, 引擎会找到一条马上返回&#xA;    limit基数大用between, 分页时要找到id, 避免offset之前全查的问题&#xA;        优化前&#xA;            select * from admin order by id limit 10000,10&#xA;        优化后&#xA;            select * from admin where id between 10000 and 10010 order by id&#xA;        子查询id&#xA;            select a.* from 表1 a, (select id from 表1 where 条件 limit 100000,20) b where a.id=b.id&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;nosql&#34;&gt;&#xA;  nosql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#nosql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    aggregate-oriented (面向聚合)&#xA;        键值&#xA;        文档&#xA;        列族&#xA;    relationship-oriented (面向关系)&#xA;        图&#xA;特点&#xA;    少约束(schemaless)&#xA;    应用程序数据库（作为微服务的数据库来解耦）&#xA;    聚合(aggregate)&#xA;        # 领域驱动设计中提出&#xA;        # 图除外&#xA;    图支持事务&#xA;    牺牲一部分一致性和持久性&#xA;问题&#xA;    存在不一致窗口&#xA;    会话一致性问题&#xA;兼容&#xA;    物化视图来处理更新&#xA;    实时BI, 来更新中间关系聚合&#xA;    一致性&#xA;        锁&#xA;        条件更新(更新前检查)&#xA;            版本戳&#xA;                # http 中的etag&#xA;        写入仲裁与读取仲裁&#xA;            复制因子大于某值时认为写入完成&#xA;            读取多于某值个节点数据并相同时，认为读到最新数据&#xA;        用zookeeper等外部“事务”程序库同步读写操作&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;图&#34;&gt;&#xA;  图&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    领域&#xA;    关系是一等公民&#xA;    大部分不支持分布式&#xA;    Gremlin，Cypher 查询语言&#xA;适用&#xA;    互联数据&#xA;    运输等基于位置的服务&#xA;    推荐引擎&#xA;不适用&#xA;    经常更新&#xA;工具&#xA;    flockDB&#xA;            # 仅支持单深度关系及邻接表&#xA;    hyperGraphDB&#xA;    infiniteGraph&#xA;    allegroGraph&#xA;    orientdb&#xA;    pregel&#xA;        # google图数据库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;neo4j&#34;&gt;&#xA;  neo4j&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#neo4j&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    使用zookeeper&#xA;特点&#xA;    完全兼容ACID&#xA;    主从复制&#xA;    副本从节点&#xA;        从节点写数据，先同步到主节点, 再由主节点分发&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;配置&#xA;dbms.connector.bolt.enabled=true&#xA;dbms.connector.bolt.listen_address=0.0.0.0:7687&#xA;dbms.connector.http.enabled=true&#xA;dbms.connector.http.listen_address=0.0.0.0:7474&#xA;# 远程访问&#xA;cql&#xA;数据类型&#xA;boolean&#xA;byte                    # 8位整数&#xA;short                   # 16位整数&#xA;int                     # 32位整数&#xA;long                    # 64位整数&#xA;float                   # 32位浮点数&#xA;double                  # 64位浮点数&#xA;char                    # 16位字符&#xA;string&#xA;命令&#xA;create                  # 创建, 自动生成&lt;id&gt;属性, 最大约为35亿&#xA;CREATE (dept:Dept:Dept2 { deptno:1,name:&amp;ldquo;a&amp;rdquo;})&#xA;# 节点名:多标签 {属性}&#xA;CREATE (p1:Profile1)-[r1:LIKES]-&amp;gt;(p2:Profile2)&#xA;# 2节点,1关系&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mongodb</title>
      <link>https://ukeate.com/docs/db/mongodb/</link>
      <pubDate>Thu, 11 Oct 2018 16:00:15 +0800</pubDate>
      <guid>https://ukeate.com/docs/db/mongodb/</guid>
      <description>&lt;h1 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    数据结构json(bson)&#xA;    易写入，易修改&#xA;    c++编写&#xA;    分布式&#xA;    介于关系数据库 和 非关系数据库之间&#xA;    查询语句强&#xA;    支持索引&#xA;    bson格式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;注意&#34;&gt;&#xA;  注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    document不能大于4Mb&#xA;    可以非安全模式异步马上成功&#xA;    每个连接用队列存储命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据结构定义&#34;&gt;&#xA;  数据结构定义&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    collection                                        # 表&#xA;            document                                # 记录&#xA;                    field(key, value)                # 字段(field)与值(value)&#xA;    与关系型数据库的区别&#xA;            document中的field不要key俱全或一样&#xA;            find()命令查询&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;bson的数据类型&#34;&gt;&#xA;  bson的数据类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bson%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    ＃bson 是json的扩展&#xA;     # 增加了数据类型&#xA;     # 把json数据转换成二进制码存到文件&#xA;    null&#xA;    boolean&#xA;    undefined&#xA;    数组                                # 如{gps: [20, 56]}&#xA;    32位和64位整数                # shell中不支持&#xA;                                    ## node.js python java等高级语言的驱动中支持&#xA;    64位浮点                        # shell使用的全是这种类型, 如{x:3.14}&#xA;    utf-8                                # 字符串类型&#xA;    ObjectID&#xA;    Date                                # 如{x:new Date()}&#xA;    正则                                # 如{x:/uspcat/i}&#xA;    javascript块代码                # 如{x:function(){}}&#xA;                                    ## 相当于存储过程&#xA;    内嵌文档                        # 如{x: {xx: &amp;quot;a&amp;quot;}}&#xA;    二进制                                # shell中不能使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;objectid&#34;&gt;&#xA;  ObjectId&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#objectid&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    大小&#xA;            12字节&#xA;            显示为24个十六进制字符&#xA;            # 空间换时间的思想&#xA;    细节&#xA;            前4字节是unix时间戳&#xA;            后3字节集群machine hash&#xA;            后2字节pid&#xA;            后3字节inc自增计数器, 在前面都相等时全局自增&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命名&#34;&gt;&#xA;  命名&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e5%90%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    数据库与集合名&#xA;            不能是空字符串&#xA;            特殊字符&#xA;                    &#39; (空格) , $ / \ \0&#xA;            应该全小写&#xA;            小于64字节&#xA;            数据库名不与保留库名相同，如&#xA;                    admin, local, config&#xA;    集合名&#xA;            db-text合法，但不能db.db-text得到，要db.getCollection(&amp;quot;db-text&amp;quot;).text得到&#xA;                    # db-text 会认为是减法&#xA;                    ## 数据库名可以是db-text&#xA;            可以a.b来命名来划分子集合&#xA;                    不能以system.开头命名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;collection&#xA;        增&#xA;                save&#xA;                        # 不存在时插入，存在时更新&#xA;                        # {$ref: &#39;user&#39;, $id: 1} 来保存引用&#xA;                insert&#xA;        删&#xA;                remove(&#39;id&#39;: &#39;bar&#39;)        # 删除一条数据&#xA;                                                                        #remove()删除所有数据&#xA;                drop()                                # 删除persons collection, 不释放文件空间&#xA;                dropIndexes()                        # 删除所有索引&#xA;        改&#xA;                update(finder, updater, options或upser, multi)&#xA;                        # $set&#xA;                        # {age: {$gt: 18}, $isolated : 1} $isolated事务隔离该字段到本语句执行结束, does not work with sharded clusters&#xA;                findAndModify&#xA;        查&#xA;                findOne()&#xA;                find(finder, filter)&#xA;                        # limit(3).skip(10).sort({name: -1, age: 1})&#xA;                        ## sort({$natural: 1}) 固定集合排序&#xA;                        # explain() 返回带统计信息的文档&#xA;                        ## 是否用到索引，耗时，需要扫描多少文件&#xA;                        # hint({}) 强制使用某索引查询&#xA;                        # null可以匹配null, 也可以匹配{$exists: false}        &#xA;                        # 正则可以匹配自身，也可以模式字符串&#xA;                count()                                # document的条数&#xA;                aggregate&#xA;&#xA;db&#xA;        # 默认存在的数据库admin, config, local&#xA;        sources&#xA;                # 从节点中设置的源collection&#xA;        help()&#xA;        persons.help()&#xA;                # 显示某集合的帮助&#xA;        auth(&#39;username&#39;, &#39;pwd&#39;)&#xA;                # 切换用户&#xA;        addUser()&#xA;                # addUser(&#39;admin&#39;, &#39;asdf&#39;)&#xA;                # addUser(&#39;readonly&#39;, &#39;asdf&#39;, true)&#xA;        listCommands()&#xA;        shutdownServer()&#xA;        eval()&#xA;                # 执行&#xA;        stats()                                        &#xA;                # 当前数据库的状态&#xA;                ## 包括名称，collection数，索引数等&#xA;        createCollection()&#xA;                # {&#39;user&#39;, {capped: true, size: 100, max: 10}} &#xA;                ## 创建固定集合, 100字节, 文档数上限为10&#xA;                ## 固定集合插入快，不能删除，无_id, 有尾部游标&#xA;        getCollection(&amp;quot;persons&amp;quot;).text&#xA;                # 同db.persons        &#xA;        dropDatabase()&#xA;                # 删除当前数据库        &#xA;        repairDatabase()&#xA;                # 释放空间&#xA;        serverStatus()&#xA;                # 返回数据库的metrics 数据&#xA;        serverStatus().metrics.cursor&#xA;                # 返回指针信息&#xA;        ensureIndex({x: 1, y: -1}, {name: &#39;xy&#39;})&#xA;                # 建立x的升序, y的降序联合索引&#xA;                # 只使用索引的前部, 即对x的查询可以用该索引&#xA;                # {&amp;quot;gps&amp;quot;: &#39;2d&#39;} {&#39;gps&#39;: &#39;2dsphere&#39;}&#xA;                ## 支持gps写成 [0, 0] {x: 0, y: 0} {latitude: 0, longitude: 0} 格式&#xA;                # 可以索引内嵌文档&#xA;                # {unique: true} 来建立唯一索引&#xA;                # {dropDups: true} 将唯一索引中重复的文档都删掉&#xA;        dropIndexes&#xA;        system&#xA;                indexes&#xA;                        # 保留集合，索引&#xA;                namespaces&#xA;                        # 也包含索引信息&#xA;                js&#xA;                        insert({_id: &#39;fn&#39;, value: function() {}})&#xA;                                # 用db.eval(&#39;fn()&#39;) 执行&#xA;        runCommand()&#xA;                # {&#39;dropIndexes&#39;: &#39;col&#39;, &#39;index&#39;: &#39;ind&#39;}&#xA;                # 可以返回命名执行的状态信息&#xA;                {buildInfo: 1}&#xA;                {collStats: &#39;user&#39;}&#xA;                {distinct: &#39;user&#39;, key: a, query: {b: 0}}&#xA;                {drop: &#39;user&#39;}&#xA;                {dropDatabase: 1}&#xA;                {dropIndexes: &#39;user&#39;, index: &#39;ind&#39;}&#xA;                {getLastError: 1}&#xA;                        # 上次更新的作用信息&#xA;                        {getLastError: 1, w: 3}&#xA;                                # 阻塞复制，有3个节点&#xA;                {isMaster: 1}&#xA;                {findAndModify: &#39;user&#39;, query: {a: 0}, sort: {a: 1}, update: {$set: {a: 1}}}&#xA;                {listCommands: 1}&#xA;                {listDatabases: 1}&#xA;                {ping: 1}&#xA;                {renameCollection: &#39;user&#39;, to: &#39;user1&#39;}&#xA;                {repairDatabase: 1}&#xA;                        # 修复并压缩当前数据库&#xA;                {serverStatus: 1}&#xA;                        # globalLock: 全局写入锁占用了多少时间&#xA;                        # mem: 内存映射了多少数据&#xA;                        # indexCounters: B树磁盘检索(misses)和内存检索(hits)的次数&#xA;                        # backgroundFluhing: 后台做了多少次fsync及用的时间&#xA;                        # opcounters: 每种主要操作的次数&#xA;                        # asserts: 断言的次数&#xA;                {convertToCapped: &#39;user&#39;, size: 100}&#xA;                        # 转为固定集合&#xA;                {fsync: 1, lock: 1}&#xA;                        # 缓冲写入磁盘，并加写入锁。后可以直接复制磁盘数据来备份&#xA;                        # db.$cmd.sys.unlock.findOne() 解锁&#xA;                        # db.currentOp() 查看为空时已解锁&#xA;                {resync: 1}&#xA;                        # 从节点重新同步&#xA;                {collMod: &#39;users&#39;, usePowerOf2Sizes: true}&#xA;                        # 每次增大空间总是2的倍数，适用于常写的集合&#xA;rs&#xA;        isMaster&#xA;        slaveOk&#xA;dcl&#xA;        help                                        # 显示帮助&#xA;        show dbs                                # 显示所有数据库&#xA;        use mydb                                # 选择数据库(默认为test)&#xA;                                                ## 如果没有该数据库，则创建(插入第一条数据时实际创建)&#xA;        db                                        # 显示当前数据库名&#xA;        show collections                        # 查看当前数据库的collections&#xA;        db.eval()                                # 执行shell语法字符串&#xA;&#xA;        用户管理命令&#xA;                use test                                # 选择需要添加用户的数据库&#xA;                db.addUser(&#39;name&#39;,&#39;pwd&#39;)                # 第三个参数代表是否只读 true代表是 ,  false代表否&#xA;                                                        ## db 代表本数据库，也就是test&#xA;                db.system.users.find()                        # 查看用户列表&#xA;                db.auth(&#39;name&#39;,&#39;pwd&#39;)                # 用户认证，反回１代表认证成功&#xA;                db.removeUser(&#39;name&#39;)&#xA;                show users                                # 查看所有用户&#xA;&#xA;                        # 注&#xA;                                权限生效需要mongod　以　-auth参数启动&#xA;                                admin数据库中的user是超级管理员 , 其他数据库中的user只限于本数据库&#xA;&#xA;ttl(time to live)&#xA;        # mongodb每1分钟检查一次数据删除&#xA;        db.log_events.ensureIndex({&amp;quot;createdAt&amp;quot;: 1}, {expireAfterSeconds: 3600 })&#xA;        db.log_events.insert({&#xA;                &amp;quot;createdAt&amp;quot;: new Date(),&#xA;                &amp;quot;logEvent&amp;quot;: 2,&#xA;                &amp;quot;logMessage&amp;quot;: &amp;quot;Success!&amp;quot;&#xA;        })&#xA;                # 插入的这条数据在1小时后删除&#xA;        db.log_events.ensureIndex({&amp;quot;expireAt&amp;quot;: 1}, {expireAfterSeconds: 0})        &#xA;        db.log_events.insert({&#xA;                &amp;quot;expireAt&amp;quot;: new Date(&#39;July 22, 2013 14:00:00&#39;),&#xA;                &amp;quot;logEvent&amp;quot;: 2,&#xA;                &amp;quot;logMessage&amp;quot;: &amp;quot;Success!&amp;quot;&#xA;        })&#xA;                # 插入的这条数据在July 22, 2013 14:00:00删除&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;aggregate&#34;&gt;&#xA;  aggregate&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aggregate&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;mapReduce(&#xA;        function() {emit(this.cust_id, this.amount);},&#xA;                # map&#xA;        function(key, values) {return Array.sum(values)},&#xA;                # reduce&#xA;        {&#xA;                query: {status: &#39;A&#39;},&#xA;                        # query&#xA;                out: &#39;order_totals&#39;&#xA;                        # output&#xA;        } &#xA;)&#xA;&#xA;distinct()&#xA;&#xA;count()&#xA;&#xA;group({&#xA;        key: {a: 1},&#xA;                # $keyf: function(x) {return x.category} 定义分组函数&#xA;        cond: {a: {$lt: 3}}.&#xA;        $reduce: function(cur, result) {result.count += cur.count},&#xA;        initial: {count: 0},&#xA;        finalize: function (prev) {}&#xA;})&#xA;        # 返回的文档 {retval: [], count: 0, keys: 0, ok: 0}&#xA;aggregate([&#xA;        {$redact: {$cond: {&#xA;                if: {$eq: [&#39;$level&#39;, 5]},&#xA;                then: &#39;$$PRUNE&#39;,&#xA;                else: &#39;$$DESCEND&#39;&#xA;        }}}&#xA;        {$match: {status: &#39;A&#39;}},&#xA;        {$geoNear: {...}},&#xA;        {$project: {name: {$toUpper: &#39;$_id&#39;}, _id: 0}},&#xA;        {$unwind: &#39;$sizes&#39;},&#xA;        {$group: {_id: &#39;$state&#39;, totalPop: {$sum: &#39;$pop&#39;}}},&#xA;        {$skip: 10},&#xA;        {$limit: 5},&#xA;        {$sort: {age: -1}},&#xA;        {$out: &#39;authors&#39;}&#xA;])&#xA;&#xA;例子&#xA;    o-&amp;gt; 得到tags数组的长度&#xA;    db.users.aggregate([{&#xA;            $group: {&#xA;                    _id: &#39;$username&#39;,&#xA;                    tags_count: {$first: {$size: &#39;$tags&#39;}}&#xA;            }&#xA;    }])&#xA;    db.users.aggregate([{&#xA;            $project: {&#xA;                    tags_count: {$size: &#39;$tags&#39;}&#xA;            }&#xA;    }])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;expressions&#34;&gt;&#xA;  expressions&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#expressions&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;$and&#xA;$or&#xA;$not&#xA;$setEquals&#xA;$setIntersection&#xA;$setUnion&#xA;$setDefference&#xA;$setIsSubset&#xA;$anyElementTrue&#xA;$allElementsTrue&#xA;$cmp&#xA;$eq&#xA;$gt&#xA;$gte&#xA;$lt&#xA;$lte&#xA;$ne&#xA;$add&#xA;$subtract&#xA;$multiply&#xA;$divide&#xA;$mod&#xA;$concat&#xA;$substr&#xA;$toLower&#xA;$toUpper&#xA;$strcasecmp&#xA;$meta&#xA;$size&#xA;$map&#xA;$let&#xA;$literal&#xA;$dayOfYear&#xA;$dayOfMonth&#xA;$dayOfWeek&#xA;$year&#xA;$month&#xA;$week&#xA;$hour&#xA;$minute&#xA;$second&#xA;$millisecond&#xA;$dateToString&#xA;$cond&#xA;$ifNull&#xA;$sum&#xA;$avg&#xA;$first&#xA;$last&#xA;$max&#xA;$min&#xA;$push&#xA;$addToSet&#xA;$near&#xA;$within&#xA;$box&#xA;$center&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局函数&#xA;        printjson&#xA;        connect(&#39;localhost:27017/mydb&#39;)&#xA;                # 连接另一个服务器&#xA;        runProgram&#xA;对象类型&#xA;        cursor&#xA;                hasNext()&#xA;                        # 立即返回前100个数据与4Mb数据的较小者。取数据时直接读缓存&#xA;                next()&#xA;                forEach&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;复制&#34;&gt;&#xA;  复制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%8d%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;复制&#xA;        mongod --master --oplogSize 100&#xA;        mongod --slave --source localhost:27017&#xA;                # --source指定主节点&#xA;                # --only 指定只复制特定的数据库&#xA;                # --slavedelay 主从复制时的延时&#xA;                # --fastsync 从节点是主节点快照时，加这个选项，同步速度快&#xA;                # --autoresync 重新同步&#xA;                # --oplogSize 主节点oplog的大小&#xA;        db.sources.insert({host: &#39;localhost:27017&#39;})&#xA;                # 从节点设置主节点&#xA;&#xA;副本集&#xA;        #  没有主节点，集群自己选举主节点&#xA;        # 数据太多从节点会自动停止同步&#xA;        mongod --dbpath &#39;/var/local/mongo1&#39; --port 27017 --replSet rs0&#xA;                # 三个实例replSet 名必叫 rs0&#xA;        use admin&#xA;        rs.initiate({&#xA;                _id: &#39;a&#39;,&#xA;                members: [{&#xA;                        _id: 1,&#xA;                        host: &#39;localhost1:27017&#39;&#xA;                }, {&#xA;                        _id: 2,&#xA;                        host: &#39;localhost1:27018&#39;&#xA;                }]&#xA;        })&#xA;                # 其中一台执行初始化&#xA;        rs.add(&#39;localhost:27019&#39;)&#xA;        rs.status()&#xA;        db.getMongo().setSlaveOk()&#xA;        rs.isMaster()&#xA;        rs.conf()&#xA;        db.getReplicationInfo()&#xA;        db.printReplicationInfo()&#xA;        db.printSlaveReplicationInfo()&#xA;        use local        &#xA;        db.addUser(&#39;name&#39;, &#39;pwd&#39;)&#xA;                # 复制认证时用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分片&#34;&gt;&#xA;  分片&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e7%89%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;mongods --port 3000 --configdb localhost:27017&#xA;        # 多个地址用,隔开&#xA;        # 每个片都就是副本集&#xA;mongo localhost:3000/admin&#xA;db.runCommand({addshard: &#39;localhost:27017‘, allowLocal: true})&#xA;        # 在localhost上运行时, 要设allowLocal&#xA;        # &#39;a/localhost:27017&#39; 让mongo知道这个片所在的副本集&#xA;db.runCommand({enablesharding: &#39;db1&#39;})&#xA;db.runCommand({shardcollection: &#39;db1.user&#39;, key: {_id: 1}})&#xA;db.printShardingStatus()&#xA;db.runCommand({removeshard: &#39;localhost:27017&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;shell&#34;&gt;&#xA;  shell&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shell&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;mongo 127.0.0.1:27017/admin&#xA;        # 启动sell , 默认数据库为test&#xA;mongod –port 10000 –fork –logpath= logpath=/data/mongodb/log/mongodb.log -- logappend -- dbpath=/data/mongodb/data/db –config ~/.mongodb.conf &#xA;        # 启动服务 -auth开启身份验证&#xA;        # --rest 开启http管理，其端口号比mongo端口号大1000&#xA;        ## --nohttpinterface关闭http管理&#xA;        # --bindip localhost 设置只能有某ip访问&#xA;        # --noscripting 完全禁止服务端js执行&#xA;        # --repair 启动并修复&#xA;        # 不要发送SIGKILL信号关闭(kill -9), 应发送SIGINT或SIGTERM&#xA;        mongod --remove                                &#xA;                # 结束服务&#xA;        // mongodb.conf&#xA;                port = 5586&#xA;                fork = true&#xA;                logpath = mongodb.log&#xA;mongodump --host 127.0.0.1 --port 27017 --out ./dir/name&#xA;        # 备份数据库&#xA;mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径&#xA;mongorestore --host 127.0.0.1 --port 27017 --directoryperdb ./dir/name&#xA;        # mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径&#xA;        # --drop 是先删除现有的数据&#xA;mongoexport -d tank -c users -o /home/outrun/mongo&#xA;        # 导出整张表&#xA;        ## mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 -f 字段 -q 条件导出 --csv -o 文件名&#xA;        # mongoexport -d tank -c users --csv -f uid,name,sex -o tank/users.csv &#xA;        ## 导出表的部分字段&#xA;        # mongoexport -d tank -c users -q &#39;{uid:{$gt:1}}&#39; -o tank/users.json&#xA;        ## 根据条件导出数据&#xA;mongoimport -d tank -c users --upsert tank/users.dat&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsert --drop 文件名 &#xA;        ## 还原整表导出的非csv文件,  --upsert 表示插入或更新现有数据&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsertFields 字段 --drop 文件名&#xA;        ## 还原部分字段导出的文件, --upsertFields跟upsert一样&#xA;        ## 如 mongoimport -d tank -c users  --upsertFields uid,name,sex  tank/users.dat&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --type 类型 --headerline --upsert --drop 文件名  &#xA;        ## 还原导出的csv文件&#xA;        ## mongoimport -d tank -c users --type csv --headerline --file tank/users.csv&#xA;mongofiles put foo.txt&#xA;        # 使用gridfs&#xA;        list&#xA;        get foo.txt&#xA;        search&#xA;                # 按文件名查找&#xA;        delete foo.txt&#xA;mongostat&#xA;        # 实时输出mongo状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;java-client&#34;&gt;&#xA;  java client&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java-client&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;1.导入mongo-java-drver-2.9.3.jar&#xA;2.api&#xA;        Mongo m = new Mongo(&amp;quot;localhost&amp;quot;, 27017);&#xA;        DB db = m.getDB(&amp;quot;mydb&amp;quot;);&#xA;        boolean auth = db.authenticate(&amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;.toCharArray());&#xA;        System.out.println(&amp;quot;身份认证&amp;quot; + auth);&#xA;        // 获得所有数据库名&#xA;        for (String s : m.getDatabaseNames()) {&#xA;                System.out.println(&amp;quot;db : &amp;quot; + s);&#xA;        }&#xA;        // 删除数据库&#xA;        m.dropDatabase(&amp;quot;my_new_db&amp;quot;);&#xA;        // 获得collection列表&#xA;        Set&amp;lt;String&amp;gt; colls = db.getCollectionNames();&#xA;        for (String s : colls) {&#xA;                System.out.println(&amp;quot;collection : &amp;quot; + s);&#xA;        }&#xA;        // 获得一个collection&#xA;        DBCollection coll = db.getCollection(&amp;quot;testCollection&amp;quot;);&#xA;        // 创建document(包括内嵌文档)&#xA;        DBObject doc = new BasicDBObject().append(&amp;quot;appendField&amp;quot;, &amp;quot;appendField&amp;quot;);&#xA;        doc.put(&amp;quot;name&amp;quot;, &amp;quot;MongoDB&amp;quot;);&#xA;        doc.put(&amp;quot;type&amp;quot;, &amp;quot;database&amp;quot;);&#xA;        doc.put(&amp;quot;count&amp;quot;, 1);&#xA;        DBObject info = new BasicDBObject();&#xA;        info.put(&amp;quot;x&amp;quot;, 203);&#xA;        info.put(&amp;quot;y&amp;quot;, 102);&#xA;        doc.put(&amp;quot;info&amp;quot;, info);&#xA;        // 插入文档&#xA;        coll.insert(doc);&#xA;        // 查询文档&#xA;        DBObject doc2 = coll.findOne();&#xA;        System.out.println(doc2);&#xA;        // 统计文档数&#xA;        long count = coll.getCount();&#xA;        System.out.println(count);&#xA;        // 用游标遍历&#xA;        DBCursor cursor = coll.find();&#xA;        while (cursor.hasNext()) {&#xA;                DBObject object = cursor.next();&#xA;                System.out.println(object);&#xA;        }&#xA;        // 查询&#xA;        DBObject query = new BasicDBObject();&#xA;        query.put(&amp;quot;i&amp;quot;, 71);&#xA;        cursor = coll.find(query);&#xA;        // 条件查询&#xA;        query = new BasicDBObject();&#xA;        query.put(&amp;quot;i&amp;quot;, new BasicDBObject(&amp;quot;$gt&amp;quot;, 50)); // i&amp;gt;50&#xA;        cursor = coll.find(query);&#xA;        // 创建索引&#xA;        coll.createIndex(new BasicDBObject(&amp;quot;i&amp;quot;, 1)); // 1代表升序 , -1是降序&#xA;        // 查询索引&#xA;        List&amp;lt;DBObject&amp;gt; list = coll.getIndexInfo();&#xA;                for (DBObject index : list) {&#xA;                System.out.println(&amp;quot;索引 : &amp;quot; + index);&#xA;        }&#xA;类型&#xA;    // 自动生成的唯一ID&#xA;    ObjectId id = new ObjectId();&#xA;    System.out.println(id);&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Postgre SQL</title>
      <link>https://ukeate.com/docs/db/postgresql/</link>
      <pubDate>Thu, 11 Oct 2018 15:34:29 +0800</pubDate>
      <guid>https://ukeate.com/docs/db/postgresql/</guid>
      <description>&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;initdb                          # 初始化数据库&#xA;    --locale en_US.UTF-8 &#xA;    -D &#39;data&#39;&#xA;postgres                        # 启动数据库&#xA;    -D 目录&#xA;    -p 6543&#xA;pg_ctl start                    # 控制数据库: start, stop等&#xA;    -D data &#xA;    -l a.log &#xA;postmaster&#xA;    -D /data&#xA;psql&#xA;    -d db1&#xA;    -h localhost &#xA;    -p 5432&#xA;    -U 用户名&#xA;    -W                          # 强制要求验证密码&#xA;    -f 导入sql命令文件, 或者在末尾加 &amp;lt; a.sql 来导入&#xA;    -L 导出日志文件&#xA;&#xA;    o-&amp;gt;&#xA;    psql -U outrun -f pg.sql db1                    # 导入数据&#xA;pg_dump                         # 导出数据库&#xA;    -f                          # 指定文件&#xA;    -U                          # 用户&#xA;    -E UTF8                     # 编码&#xA;    -h localhost&#xA;    -n public                   # 指定schema&#xA;    -a                          # 只导数据，没有schema&#xA;    -F t                        # 压缩成tar&#xA;&#xA;    o-&amp;gt;&#xA;    pg_dump -U outrun -f pg.sql db1                 # 导出数据, -t tb1 导出表&#xA;pg_restore&#xA;    o-&amp;gt;&#xA;    pg_restore -U outrun -d db1 pg.tar              # 导入压缩的数据&#xA;createdb                        # 创建数据库并指定 owner&#xA;    -hlocalhost -Upostgres -O 用户名 数据库名                        &#xA;dropdb&#xA;    -U user dbname&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;特色sql&#34;&gt;&#xA;  特色sql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e8%89%b2sql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;元命令&#xA;    \?                          # postgre命令&#xA;    \h                          # sql命令&#xA;    \l                          # 列出数据库&#xA;    \q                          # 退出&#xA;    \c 数据库名                 # 切换数据库&#xA;    \d name                     # 查看序列、表、视图、索引&#xA;        \dS+                    # 详情&#xA;    \du                         # 查看角色&#xA;    \dt                         # 查看所有表&#xA;        \dtS+                   # 详情&#xA;    \ds                         # 查看序列&#xA;    \i a.sql                    # 执行sql文件&#xA;    \o a.log                    # 日志文件&#xA;    \password                   # 更换密码&#xA;    \x                          # 开启/关闭竖排显示&#xA;&#xA;    [sql] \gdesc                # 快速显示结果列名和类型&#xA;数据类型&#xA;    serial                      # 4字节，自增序列&#xA;        bigserial               # 8字节&#xA;    text default &#39;&#39;::text&#xA;    bigint default 0            # 8字节&#xA;        smallint                # 2字节&#xA;        int, integer            # 4字节&#xA;        decimal                 # 变长, 声明精度，精确&#xA;        numeric                 # 同上&#xA;        float&#xA;        real                    # 4字节，变精度，不精确&#xA;        double precision        # 8字节，变精度，不精确&#xA;&#xA;    boolean default false&#xA;    text[]                      # text数组&#xA;    date&#xA;    time&#xA;    timestamp with time zone&#xA;    interval&#xA;    &#xA;    bytea                       # 二进制&#xA;&#xA;    money&#xA;    uuid&#xA;约束&#xA;    constraint user_id primary key (id)&#xA;    constraint user_m_id unique(m_id)&#xA;    constraint fk_b_id foreign key (b_id) references tbb(id)&#xA;        MATCH SIMPLE&#xA;        ON UPDATE NO ACTION&#xA;        ON DELETE NO ACTION&#xA;dcl&#xA;    create database db1&#xA;        owner outrun&#xA;    create user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;    create role 用户名 with password &#39;密码&#39; login&#xA;        # 创建用户。role关键词可以省略&#xA;&#xA;    drop database db1&#xA;    drop table tablename;&#xA;&#xA;    alter database abc RENAME TO cba;&#xA;    alter database 数据库名 owner to 用户名&#xA;        # 更改数据库 owner&#xA;    alter table tb &#xA;        add primary key (id)&#xA;        add foreign key(b_id) references tb(id) on update cascade on delete cascade&#xA;        add column c1 text&#xA;        alter column id type int using id::integer&#xA;        rename c1 to c2&#xA;            drop constraint fk_b_id foreign key (b_id) references tbb(id)&#xA;        drop [column] name&#xA;        owner to outrun&#xA;            # 更改表 owner&#xA;    &#xA;    alter role 用户名 with login                     # 添加权限&#xA;        password &#39;asdf&#39;                             # with password &#39;asdf&#39;, 修改密码&#xA;        VALID UNTIL &#39;JUL 7 14:00:00 2012 +8&#39;        # 设置角色有效期&#xA;        login, superuser, createdb, createrole, replication, inherit&#xA;&#xA;    grant all privileges on database 数据库名 to 用户名&#xA;        # 授权数据库权限&#xA;ddl &#xA;    insert into tb(&amp;quot;desc&amp;quot;) values (&#39;a&#39;); &#xA;模糊查询&#xA;    ~                       # 匹配正则，大小写相关&#xA;        除&#39;a$&#39; &#39;^a&#39;的正则都只适合pg_trgm的gin索引&#xA;    ~*                      # 匹配正则，大小写无关&#xA;    !~                      # 不匹配该正则&#xA;    !~*&#xA;    ~ &#39;^a&#39;&#xA;        like &#39;a%&#39;&#xA;    ~ &#39;a$&#39;&#xA;    ~ &#39;ab.c&#39;&#xA;        like &#39;%ab_c%&#39;&#xA;&#xA;o-&amp;gt; 视图 &#xA;CREATE VIEW myview &#xA;AS &#xA;SELECT city, temp_lo, temp_hi, prcp, date, location &#xA;FROM weather, cities &#xA;WHERE city = name;&#xA;&#xA;o-&amp;gt; 建表&#xA;create table dwh_timestamp_meta&#xA;(&#xA;&amp;quot;id&amp;quot; serial NOT NULL,&#xA;&amp;quot;id&amp;quot; serial primary key,&#xA;&amp;quot;c_id&amp;quot; serial references cities(id),&#xA;&amp;quot;mongo_document_name&amp;quot; text default &#39;&#39;::text,&#xA;&amp;quot;last_update_time&amp;quot; bigint default 0,&#xA;&amp;quot;execute_time&amp;quot; timestamp with time zone,&#xA;constraint pk_id primary key(id)&#xA;)&#xA;with (&#xA;oids=false&#xA;);&#xA;&#xA;o-&amp;gt; 序列&#xA;create table a(&#xA;    id bigint primary key&#xA;);&#xA;create sequence a_id_seq&#xA;    start with 1&#xA;    increment by 1&#xA;    no minvalue&#xA;    no maxvalue&#xA;    cache 1;&#xA;alter table a alter column id set default nextval(&#39;a_id_seq&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据字典&#34;&gt;&#xA;  数据字典&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ad%97%e5%85%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;pg_roles                        # 角色信息&#xA;pg_database                     # 数据库信息&#xA;information_schema&#xA;    select column_name from information_schema.columns where table_schema=&#39;public&#39; and table_name=&#39;ad&#39;;&#xA;        # 表的所有列名&#xA;pg_stat_user_tables&#xA;    select relname from pg_stat_user_tables;&#xA;        # 所有表名&#xA;pg_stat_activity                # 活动状态&#xA;    SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE datname=&#39;garbage&#39; AND pid&amp;lt;&amp;gt;pg_backend_pid();&#xA;        # 查看数据库活动连接&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据库目录&#xA;    /usr/lib/systemd/system/postgresql.service&#xA;jdbc&#xA;    driver : org.postgresql.Driver&#xA;    url : jdbc:postgresql://localhost:5432/postgres&#xA;    初始用户名 : postgres&#xA;    初始数据库 : postgres&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储过程&#34;&gt;&#xA;  存储过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;drop function change_type1();&#xA;create or replace function change_type1()&#xA;returns int as&#xA;$body$&#xA;DECLARE&#xA;    r mongo_keys_type%rowtype;&#xA;    begin&#xA;    for r in select * from mongo_keys_type where type=&#39;number&#39;&#xA;    loop&#xA;        EXECUTE &#39;alter table &amp;quot;&#39; || r.&amp;quot;mongo_collection_name&amp;quot; || &#39;&amp;quot; alter &amp;quot;&#39; || r.&amp;quot;key&amp;quot; || &#39;&amp;quot; type decimal&#39;;&#xA;    END LOOP;&#xA;    return 0;&#xA;    end&#xA;$body$&#xA;language &#39;plpgsql&#39;;&#xA;&#xA;select change_type1()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;授权&#xA;    grant all privileges on database &#39;db1&#39; to &#39;outrun&#39;&#xA;    alter role &#39;outrun&#39; createdb&#xA;    alter role &#39;outrun&#39; superuser&#xA;创建用户&#xA;    create user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;    create role &#39;outrun&#39; createdb password &#39;asdf&#39; login&#xA;修改密码&#xA;    alter user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
