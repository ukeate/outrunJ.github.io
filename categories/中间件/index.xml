<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>中间件 on ukeate的笔记</title>
    <link>https://ukeate.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/</link>
    <description>Recent content in 中间件 on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 01 Jan 2025 08:50:36 -0700</lastBuildDate>
    <atom:link href="https://ukeate.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>中间件</title>
      <link>https://ukeate.com/docs/middleware/</link>
      <pubDate>Wed, 10 Oct 2018 14:36:50 +0800</pubDate>
      <guid>https://ukeate.com/docs/middleware/</guid>
      <description>&lt;h1 id=&#34;容器服务&#34;&gt;&#xA;  容器服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%b9%e5%99%a8%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;tomcat&#34;&gt;&#xA;  tomcat&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tomcat&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;## 介绍&#xA;    tomcat从7开始默认就是nio的&#xA;## 配置&#xA;    bin/startup.bat&#xA;            set JAVA_HOME=&#xA;                            # 设置tomcat运行jdk&#xA;    context.xml&#xA;        &amp;lt;Loader delegate=&amp;quot;true&amp;quot;/&amp;gt;&#xA;                # true表示使用java加载器的代理模式&#xA;                ## false代表永远先在Web应用程序中寻找&#xA;    web.xml&#xA;        Content-Type: text/x-zim-wiki&#xA;        Wiki-Format: zim 0.4&#xA;        Creation-Date: 2013-08-04T19:40:08+08:00&#xA;&#xA;        ====== web.xml文件 ======&#xA;        Created Sunday 04 August 2013&#xA;&#xA;        &amp;lt;servlet&amp;gt;&#xA;                &amp;lt;servlet-name&amp;gt;&#xA;                &amp;lt;servlet-class&amp;gt;&#xA;                &amp;lt;load-on-startup&amp;gt;1&#xA;                &amp;lt;init-param&amp;gt;&#xA;                        &amp;lt;param-name&amp;gt;&#xA;                        &amp;lt;param-value&amp;gt;&#xA;        &amp;lt;servlet-mapping&amp;gt;&#xA;                &amp;lt;servlet-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;&#xA;&#xA;        &amp;lt;welcome-file-list&amp;gt;&#xA;                &amp;lt;welcome-file&amp;gt;&#xA;&#xA;        &amp;lt;filter&amp;gt;&#xA;                &amp;lt;filter-name&amp;gt;&#xA;                &amp;lt;filter-class&amp;gt;&#xA;                &amp;lt;init-param&amp;gt;&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;                &amp;lt;filter-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;&#xA;&#xA;        &amp;lt;mime-mapping&amp;gt;&#xA;                &amp;lt;extension&amp;gt;bmp&#xA;                &amp;lt;mime-type&amp;gt;image/bmp&#xA;&#xA;        &amp;lt;error-page&amp;gt;&#xA;                &amp;lt;exception-type&amp;gt;异常类的完全限定名 /&amp;lt;error-code&amp;gt;错误码&#xA;                &amp;lt;location&amp;gt;以“/”开头的错误处理页面路径&#xA;&#xA;## 启动顺序&#xA;    web.xml中配置的启动顺序&#xA;            监听器&#xA;            过滤器&#xA;            servlet&#xA;                    load-on-startup属性值越小越先启动&#xA;&#xA;    tomcat的加载过程：        # 分析启动日志得到&#xA;            启动http协议&#xA;            启动catalina&#xA;            启动servlet引擎&#xA;            加载xml配置文件&#xA;            初始化日志配置&#xA;            初始化ContextListener&#xA;            初始化SessionListener&#xA;            部署web项目&#xA;                    spring监听器，加载xml配置(开始spring自己的日志记录)&#xA;                            实例化bean&#xA;                                    初始化c3p0连接池的记录显示&#xA;                                    初始化LocalSessionFactoryBean的记录显示&#xA;                    application监听器(监听器按配置顺序启动)&#xA;                    struts过滤器，加载xml配置(开始struts自己的日志记录)&#xA;                            struts-default.xml&#xA;                                    根据其中配置的bean属性加载类，并记录了日志&#xA;                            struts-plugin.xml                # 里面有加载spring-struts-plugin包&#xA;                                    初始化struts-spring 集成&#xA;                            struts.xml&#xA;## 目录&#xA;    LICENSE&#xA;    NOTICE&#xA;    RELEASE-NOTES&#xA;    RUNNING.txt&#xA;    bin&#xA;            bootstrap.jar&#xA;            commons-daemon.jar&#xA;            tomcat-juli.jar&#xA;            tomcat-native.tar.gz&#xA;            commons-daemon-native.tar.gz&#xA;            catalina.bat&#xA;            shutdown.bat&#xA;            startup.bat&#xA;            cpappend.bat&#xA;            digest.bat&#xA;            setclasspath.bat&#xA;            tool-wrapper.bat&#xA;            version.bat&#xA;            catalina.sh&#xA;            shutdown.sh&#xA;            startup.sh&#xA;            digest.sh&#xA;            setclasspath.sh&#xA;            tool-wrapper.sh&#xA;            version.sh&#xA;            catalina-tasks.xml&#xA;    conf&#xA;            catalina.policy&#xA;            catalina.properties&#xA;            logging.properties&#xA;            context.xml&#xA;            server.xml&#xA;            tomcat-users.xml&#xA;            web.xml&#xA;            Catalina&#xA;                    localhost&#xA;                            host-manager.xml&#xA;                            manager.xml&#xA;    lib&#xA;            annotations-api.jar&#xA;            catalina.jar&#xA;            catalina-ant.jar&#xA;            catalina-ha.jar&#xA;            catalina-tribes.jar&#xA;            el-api.jar&#xA;            jasper.jar&#xA;            jasper-el.jar&#xA;            jasper-jdt.jar&#xA;            jsp-api.jar&#xA;            servlet-api.jar&#xA;            tomcat-coyote.jar&#xA;            tomcat-dbcp.jar&#xA;            tomcat-i18n-es.jar&#xA;            tomcat-i18n-fr.jar&#xA;            tomcat-i18n-ja.jar&#xA;    log&#xA;            catalina.2013-07-28.log等等&#xA;    webapps&#xA;            ROOT&#xA;                    WEB-INF&#xA;                            web.xml&#xA;            docs&#xA;            examples&#xA;            manager&#xA;            host-manager&#xA;    tmp&#xA;    work&#xA;&#xA;    发布&#xA;            conf/server.xml 中8080端口 位置&#xA;            &amp;lt;Context path=&amp;quot;/bbs&amp;quot; reloadable=&amp;quot;true&amp;quot; docBase=&amp;quot;E:\workspace\bbs&amp;quot; workDir=&amp;quot;E:\workspace\bbs\work&amp;quot; /&amp;gt;&#xA;&#xA;    发布war文件：&#xA;            localhost:8080 -&amp;gt; tomcat manager -&amp;gt; WAR file to deploy&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;netty&#34;&gt;&#xA;  netty&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#netty&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    JBOSS提供，由Trustin Lee开发，比mina晚&#xA;    java开源框架&#xA;对比java nio&#xA;    java原生nio有bug(epoll bug)且编写困难, 网络可靠性自己处理&#xA;    netty设计优雅，使用方便，高性能、稳定&#xA;原理&#xA;    基于socket的数据流处理&#xA;        # socket数据流不是a queue of packets , 而是a queue of bytes, 所以分次传输的数据会成为a bunch of bytes&#xA;例子&#xA;    Handler&#xA;        ChannelHandler&#xA;            ChannelOutboundHandler&#xA;                    ChannelOutboundHandlerAdapter                        # 可作Encoder&#xA;                    MessageToByteEncoder&#xA;            ChannelInboundHandler                # 提供可重写的事件&#xA;                    ChannelInboundHandlerAdapter&#xA;                    ByteToMessageDecoder        # easy to deal with fragmentation issue&#xA;                            事件&#xA;                                    decode(ctx, in, out)                        # 内部处理过数据，堆积到了buffer(in)&#xA;                                                                            ## out中add了数据, 表示decode成功，则执行后抛弃in中数据&#xA;                                                                            # decode会被循环调用直到有一次out中没有add东西&#xA;                    ReplayingDecoder&#xA;                    事件&#xA;                            channelRead()                # 从client接收到数据时调用，数据的类型是ByteBuf&#xA;                                                    ## ByteBuf是 reference-counted object&#xA;                                                    ## 必须用ReferenceCountUtil.release(msg)或((ByteBuf) msg).release()来明确释放&#xA;                            exceptionCaught()        # 当抛出Throwable对象时调用&#xA;                            channelActive()                # as soon as a connection is established&#xA;            方法&#xA;                    handlerAdded()&#xA;                    handlerRemoved()&#xA;        ByteBuf&#xA;            方法&#xA;                    buf.writeBytes(m)                # 将m[ByteBuf]中的数据 cumulate into buf[ 定长的ByteBuf, 如ctx.alloc().buffer(4) ]&#xA;                    isReadable()                        # 返回ByteBuf中data的长度&#xA;        ChannelHandlerContext                # 用于触发一些i/o事件&#xA;            方法&#xA;                    write(msg)                # msg在flush后自动realease&#xA;                            write(msg, promise)                                # promise是ChannelPromise的对象，用来标记msg是否确切地写入到管道中&#xA;                    flush()&#xA;                    writeAndFlush(msg)                                        # 返回ChannelFuture&#xA;                    alloc()                                                        # 分配缓冲区来包含数据&#xA;        ByteBufAllocator&#xA;            buffer(4)                        # 返回存放32-bit Integer的ByteBuf&#xA;    Server&#xA;        EventLoopGroup&#xA;            NioEventLoopGroup                # 多线程 i/o eventloop&#xA;            方法&#xA;                    shutdownGracefully()                                                # 返回Funture类来通知group是否完全关闭并且所有group的channels都关闭&#xA;        ServerBootstrap                        # 建server的帮助类，链式编程&#xA;                                            ## 可以直接用Channel来建server&#xA;            方法&#xA;                group(bossGroup, workerGroup)                                # boss接收连接，worker处理boss中的连接&#xA;                        group(workerGroup)                                        # 只有一个参数时，该group即作boss也作worker&#xA;                channel(NioServerSocketChannel.class)                        # 用来接收连接的channel的类型&#xA;                        channel(NioSocketChannel.class)                        # create client-side channel&#xA;                childHandler(channelInitializer)                                # 新接收的channel总执行本handler&#xA;                                                                                ## 只有workerGroup时不用&#xA;                option(ChannelOption.SO_BACKLOG, 128)                        # channel实现的参数&#xA;                childOption(channelOption.SO_KEEPALIVE, true)                # option设置boss, childOption设置worker&#xA;                                                                                ## 在只有workerGroup时不用childOption,因为它没有parent&#xA;                bind(port)                                                        # 开始接收连接，返回的是ChannelFuture&#xA;                                                                                    ## 绑定网卡上的所有port端口，可以bind多次到不同的端口&#xA;        ChannelInitializer                        # 帮助设置channel, 如设置channel的pipeline中的handler&#xA;            实例&#xA;                new　ChannelInitializer&amp;lt;SocketChannel&amp;gt;(){&#xA;                        @Override&#xA;                        public void initChannel(SocketChannel ch) throws Exception{&#xA;                                ch.pipeline().addLast(new DiyHandler());&#xA;                        }&#xA;                }&#xA;        ChannelFuture&#xA;            方法&#xA;                sync()&#xA;                channel()                                                        # 返回Channel&#xA;                addListener(channelFutureListener)&#xA;        Channel&#xA;                closeFuture()                                                        # 返回ChannelFuture&#xA;        ChannelFutureListener&#xA;            实例&#xA;                new ChannelFutureListener(){&#xA;                    // 当请求结束时通知&#xA;                    @Override&#xA;                    public void operationComplete(ChannelFuture future){&#xA;                        assert f == future;&#xA;                        ctx.close();&#xA;                    }&#xA;                }&#xA;    client&#xA;        Bootstrap                        # for non-server channels such as a client-side or connectionless channel&#xA;            connect(host, port)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;netty-tcnative&#34;&gt;&#xA;  netty-tcnative&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#netty-tcnative&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        tomcat native 的分支&#xA;特点&#xA;        简化本地库的分配和连接&#xA;        可以maven配置dependency&#xA;        提供openssl的支持&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jetty&#34;&gt;&#xA;  jetty&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jetty&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 是开源的servlet容器，基于java, 可以给jsp和servlet提供运行环境&#xA;# jetty容器可以实例化成一个对象，迅速为一些独立运行(stand-alone)的java应用提供网络和web连接&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;apache&#34;&gt;&#xA;  apache&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#apache&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# http容器，可容纳php, python。一请求一线程&#xA;安装&#xA;    pacman -S apache&#xA;    mkdir /srv/http&#xA;    chown http:http /srv/http&#xA;编译安装&#xA;    ./configure&#xA;        --prefix=/全路径/install_path&#xA;        --with-apxs2=/全路径/apxs            # 模块&#xA;    make&#xA;    make install&#xA;命令&#xA;    httpd&#xA;        -f                                  # 指定配置&#xA;        -t                                  # 配置检查&#xA;        -k&#xA;            start&#xA;            restart&#xA;            graceful&#xA;            stop&#xA;            graceful-stop&#xA;    apachectl&#xA;        graceful                            # 重载配置&#xA;        -f /全路径/httpd.conf                # 指定配置&#xA;        -t                                  # 配置检查&#xA;配置&#xA;    /etc/httpd/conf/httpd.conf&#xA;        DocumentRoot &amp;quot;/srv/http&amp;quot;            # 项目路径&#xA;        Listen                              # 端口&#xA;案例&#xA;    php&#xA;        docker解决&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;lighttpd&#34;&gt;&#xA;  lighttpd&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lighttpd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;meteor&#34;&gt;&#xA;  meteor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#meteor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 包装node&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ringojs&#34;&gt;&#xA;  ringojs&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ringojs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# jvm上commonJs规范的服务器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;mina&#34;&gt;&#xA;  mina&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mina&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;apache提供， 由Trustin Lee开发，比netty更早&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;tomcat-native&#34;&gt;&#xA;  tomcat native&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tomcat-native&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 基于apr(apache portable runtime)技术，让tomcat在操作系统级别的交互上做的更好&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;tinyhttpd&#34;&gt;&#xA;  tinyHttpd&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tinyhttpd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;resin&#34;&gt;&#xA;  resin&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#resin&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 收费, 类似tomcat的java容器，性能提升&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;uwsgi&#34;&gt;&#xA;  uwsgi&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#uwsgi&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 一个web服务器，实现了wsgi, uwsgi, http等协议&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;weblogic&#34;&gt;&#xA;  weblogic&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#weblogic&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# oracle&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;was&#34;&gt;&#xA;  was&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#was&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# ibm服务器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gunicon&#34;&gt;&#xA;  gunicon&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gunicon&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# python wsgi http server&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;nodejs&#34;&gt;&#xA;  node.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#nodejs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;openresty&#34;&gt;&#xA;  OpenResty&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#openresty&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 基于Nginx扩展&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;tengine&#34;&gt;&#xA;  Tengine&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tengine&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 基于Nginx扩展&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据库访问&#34;&gt;&#xA;  数据库访问&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%bf%e9%97%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;druid&#34;&gt;&#xA;  Druid&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#druid&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;sharding-jdbc&#34;&gt;&#xA;  Sharding JDBC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sharding-jdbc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;缓存&#34;&gt;&#xA;  缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;缓存失效策略&#xA;&#x9;FIFO(First Input First Output)&#xA;&#x9;LRU(Least Recently Used)&#xA;&#x9;LFU(Least Frequently Used)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;客户端缓存&#34;&gt;&#xA;  客户端缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%a2%e6%88%b7%e7%ab%af%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Header&#xA;&#x9;Cache-Control: no-cache, no-store, max-age=0, must-revalidate&#xA;&#x9;Vary: Accept-Encoding&#xA;&#x9;Vary: Origin&#xA;&#x9;Vary: Access-Control-Request-Method&#xA;&#x9;Vary: Access-Control-Request-Headers&#xA;&#x9;Vary: Origin&#xA;&#x9;Vary: Access-Control-Request-Method&#xA;&#x9;Vary: Access-Control-Request-Headers&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;本地缓存&#34;&gt;&#xA;  本地缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%ac%e5%9c%b0%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Ehcache&#xA;&#x9;堆内、堆外、磁盘三级缓存，可按容量制定缓存策略&#xA;&#x9;可按时间、次数制定过期策略&#xA;Guava Cache&#xA;&#x9;堆内缓存&#xA;Nginx本地缓存&#xA;Nginx PageSpeed插件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;缓存服务&#34;&gt;&#xA;  缓存服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;HTTP&#xA;&#x9;Nuster&#xA;&#x9;&#x9;基于HAProxy的HTTP缓存服务器&#xA;&#x9;Varnish&#xA;&#x9;&#x9;3台Varnish代替12台Squid&#xA;&#x9;Squid&#xA;Memcached&#xA;Redis&#xA;Tair&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置服务发现&#34;&gt;&#xA;  配置、服务发现&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;apollo&#34;&gt;&#xA;  Apollo&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#apollo&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 支持推、拉模式更新&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;eureka&#34;&gt;&#xA;  Eureka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eureka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;nacos&#34;&gt;&#xA;  Nacos&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#nacos&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;rpc&#34;&gt;&#xA;  RPC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rpc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;dubbo&#34;&gt;&#xA;  Dubbo&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dubbo&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;thrift&#34;&gt;&#xA;  Thrift&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#thrift&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;grpc&#34;&gt;&#xA;  gRPC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#grpc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;消息队列&#34;&gt;&#xA;  消息队列&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;消息重发&#xA;    状态表记录消息状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pulsar&#34;&gt;&#xA;  pulsar&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pulsar&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 雅虎开源, 存储和服务分离，高可用存储, 支持流&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;rabbitmq&#34;&gt;&#xA;  rabbitMQ&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rabbitmq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    erlang开发, 重量级&#xA;    支持协议多，AMQP、XMPP、SMTP、STOMP&#xA;    Broker构架        # 消息在中心队列排队&#xA;install&#xA;        yum install rabbitmq-server&#xA;命令&#xA;        添加用户:&#xA;                rabbitmqctl add_user rainbird password&#xA;        添加权限:&#xA;                rabbitmqctl set_permissions -p &amp;quot;/&amp;quot; rainbird &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot;&#xA;        删除测试用户:&#xA;                rabbitmqctl delete_user guest&#xA;原理&#xA;    虚拟主机 virtual host: 用户通过虚拟主机进行权限控制(如禁止A组访问B组的交换机)&#xA;            ＃ 默认虚拟主机为&amp;quot;/&amp;quot;&#xA;            队列 queue: 由生产者(producers)通过程序建立，再通过消费者(consuming)连接取走&#xA;                    消息:&#xA;                            路由键 routing key&#xA;            交换机 exchange: 负责把消息放入队列&#xA;                    绑定 binding(路由规则): 如指明交换机中具有路由键&amp;quot;X&amp;quot;的消息要到名为&amp;quot;Y&amp;quot;的队列中去&#xA;                            # 如果同一个键对应多个队列，则复制后分别发送&#xA;&#xA;    功能&#xA;            持久化&#xA;                    队列和交换机创建时指定标志durable,指定队列和交换机重启生重建&#xA;                            ＃ 如果绑定了durable的队列和durable的交换机，该绑定自动保留&#xA;                            ＃ non-durable的交换机与durable的队列不能绑定&#xA;                            ＃ 一但创建durable标志，不能修改&#xA;                    消息发布到交换机时，指定标志Delivery Mode=2,这样消息会持久化&#xA;使用(原文http://adamlu.net/rabbitmq/tutorial-one-python)&#xA;        安装python 与插件支持&#xA;                pip&#xA;                python-pip git&#xA;                python-pika&#xA;        rabbitmq-server start&#xA;        send.py&#xA;            #!/usr/bin/env python&#xA;            import pika&#xA;&#xA;            connection = pika.BlockingConnection(pika.ConnectionParameters(&#xA;                    host=&#39;localhost&#39;))&#xA;            channel = connection.channel()&#xA;&#xA;            channel.queue_declare(queue=&#39;hello&#39;)&#xA;&#xA;            channel.basic_publish(exchange=&#39;&#39;,&#xA;                                routing_key=&#39;hello&#39;,&#xA;                                body=&#39;Hello World!&#39;)&#xA;            print &amp;quot; [x] Sent &#39;Hello World!&#39;&amp;quot;&#xA;            connection.close()&#xA;                    receive.py&#xA;                            #!/usr/bin/env python&#xA;            import pika&#xA;&#xA;            connection = pika.BlockingConnection(pika.ConnectionParameters(&#xA;                    host=&#39;localhost&#39;))&#xA;            channel = connection.channel()&#xA;&#xA;            channel.queue_declare(queue=&#39;hello&#39;)&#xA;&#xA;            print &#39; [*] Waiting for messages. To exit press CTRL+C&#39;&#xA;&#xA;            def callback(ch, method, properties, body):&#xA;                print &amp;quot; [x] Received %r&amp;quot; % (body,)&#xA;&#xA;            channel.basic_consume(callback,&#xA;                                queue=&#39;hello&#39;,&#xA;                                no_ack=True)&#xA;&#xA;            channel.start_consuming()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jafka&#34;&gt;&#xA;  jafka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jafka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基于kafka, 快速持久化(O(1)时间开销)&#xA;    高吞吐，一台普通服务器 100k/s&#xA;    完全分布式，Broker, Producer, Consumer原生支持分布式，自动负载均衡&#xA;    支持hadoop并行加载&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;kafka&#34;&gt;&#xA;  kafka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    apache子项目，scala语言编写, 发布订阅队列&#xA;    相对activeMQ轻量&#xA;特点&#xA;    push/pull队列架构，适合异构集群&#xA;    分布式, 高吞吐率, 易扩展&#xA;    支持数据并行到hadoop&#xA;    分区有序&#xA;    批量压缩, 零拷贝, 内存缓冲, 磁盘顺序写入&#xA;    可持久化&#xA;工具&#xA;    manager # 监控&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;nsq&#34;&gt;&#xA;  nsq&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#nsq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    go&#xA;工具&#xA;    admin   # 监控&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;memcacheq&#34;&gt;&#xA;  memcacheQ&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#memcacheq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;zeromq&#34;&gt;&#xA;  zeroMQ&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#zeromq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;activemq&#34;&gt;&#xA;  activeMQ&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#activemq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    apache子项目, 类似zeroMQ&#xA;通信方式&#xA;    点到点&#xA;        不成功时保存在服务端&#xA;    发布订阅&#xA;        不成功消息丢失&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;beanstalkd&#34;&gt;&#xA;  beanstalkd&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#beanstalkd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;mqtt&#34;&gt;&#xA;  mqtt&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mqtt&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 最早由ibm提供的，二进制消息的mq&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;emqttd&#34;&gt;&#xA;  emqttd&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#emqttd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    mqtt broker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;apollo-1&#34;&gt;&#xA;  apollo&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#apollo-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    apache mqtt broker&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;metaq&#34;&gt;&#xA;  metaq&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#metaq&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 阿里mq&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;定时任务&#34;&gt;&#xA;  定时任务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cron&#34;&gt;&#xA;  Cron&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cron&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;xxl-job&#34;&gt;&#xA;  XXL Job&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xxl-job&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;quartz&#34;&gt;&#xA;  quartz&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#quartz&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# java作业调度&#xA;配置applicationContext_job.xml&#xA;    job             # 任务内容&#xA;    jobDetail       # 调度方案&#xA;    trigger         # 时间&#xA;    scheduler       # jobDetail和trigger的容器&#xA;状态监控&#xA;    # 用日志表记录&#xA;    运行中&#xA;        JobListener监听器&#xA;    暂停中&#xA;        scheduler.pauseTrigger()&#xA;    等待中&#xA;        创建job时&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;celery&#34;&gt;&#xA;  celery&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#celery&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# python&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;rundeck&#34;&gt;&#xA;  rundeck&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rundeck&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储服务&#34;&gt;&#xA;  存储服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;存储的概念和术语&#xA;    scsi: 小型计算机系统接口(Small Computer System Interface)&#xA;    fc: 光纤通道(Fibre channel)&#xA;    das: 直连式存储(Direct-Attached Storage)&#xA;    nas: 网络接入存储(Network-Attached Storage)&#xA;    san: 存储区域网络(Storage Area Network)&#xA;        连接设备: 路由,  光纤交换机, 集线器(hub)&#xA;        接口: scsi fc&#xA;        通信协议: ip scsi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;iscsi&#34;&gt;&#xA;  iscsi&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#iscsi&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# internet scsi&#xA;优点&#xA;    可以网络传输&#xA;    服务器数量无限&#xA;    在线扩容．动态部署&#xA;架构&#xA;    控制器架构: 专用数据传输芯片．专用RAID数据校验芯片．专用高性能cache缓存和专用嵌入式系统平台&#xA;    iscsi连接桥架构:&#xA;        前端协议转换设备(硬件)&#xA;        后端存储(scsi磁盘阵列．fc存储设备)&#xA;    pc架构&#xA;        存储设备搭建在pc服务器上，通过软件管理成iscsi, 通过网卡传输数据&#xA;        实现&#xA;            以太网卡 + initiator软件&#xA;            toe网卡 + initiator软件&#xA;            iscsi HBA卡&#xA;iscsi系统组成&#xA;    iscsi initiator 或　iscsi hba&#xA;    iscsi target&#xA;    以太网交换机&#xA;    一台或多台服务器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;fastdfs&#34;&gt;&#xA;  fastdfs&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fastdfs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 开源分布式文件系统&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cdn&#34;&gt;&#xA;  cdn&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cdn&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    流量不大时带宽比cdn便宜, 流量大时cdn便宜。&#xA;    界限为250Mbps左右，价格在9k/month&#xA;价格     50TB/月        100TB/月&#xA;阿里云   3.8w/月        6.9w/月&#xA;盛大云   9k/月          1.7w/月&#xA;网宿&#xA;蓝汛&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;aws-s3&#34;&gt;&#xA;  AWS S3&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aws-s3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;命令&#xA;    aws&#xA;        s3&#xA;            cp --recursive bin s3://meiqia/crm-module/search/bin&#xA;                # 级联复制&#xA;            sync s3://meiqia/crm-module/search/bin bin&#xA;                # 下载&#xA;            rm --recursive s3://meiqia/crm-module/search&#xA;                # 级联删除&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;网关&#34;&gt;&#xA;  网关&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e5%85%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;zuul&#34;&gt;&#xA;  Zuul&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#zuul&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;spring-cloud-gateway&#34;&gt;&#xA;  Spring Cloud Gateway&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-gateway&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;kong&#34;&gt;&#xA;  Kong&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kong&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 基于OpenResty&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;日志&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;elk&#34;&gt;&#xA;  ELK&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elk&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# elasticsearch, logstash, kibana&#xA;FileBeat&#xA;    命令&#xA;    filebeat --environment systemd -c /etc/filebeat/filebeat.yml --path.home /usr/share/filebeat --path.config /etc/filebeat --path.data /var/lib/filebeat --path.logs /var/log/filebeat&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;logio&#34;&gt;&#xA;  log.io&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#logio&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;dns服务&#34;&gt;&#xA;  DNS服务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dns%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;nscd&#34;&gt;&#xA;  Nscd&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#nscd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;DNS本地缓存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;实时计算&#34;&gt;&#xA;  实时计算&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e6%97%b6%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;阿里云Flink&#xA;&#x9;集群&#xA;&#x9;&#x9;计算单元&#xA;&#x9;&#x9;vertex拓扑&#xA;&#x9;名词&#xA;&#x9;&#x9;DataHub源表&#xA;&#x9;&#x9;RDS维表&#xA;&#x9;&#x9;RDS结果表&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>支撑-分布式</title>
      <link>https://ukeate.com/docs/middleware/distributed/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://ukeate.com/docs/middleware/distributed/</guid>
      <description>&lt;h1 id=&#34;名词&#34;&gt;&#xA;  名词&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8d%e8%af%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Alb        automaticLoopBack 自动回环，虚拟接口&#xA;sdn        software defined network 软件定义网络&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;serverless&#34;&gt;&#xA;  Serverless&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#serverless&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;knative&#xA;    # google开源，serverless标准化方案，基于kubernetes和istio&#xA;    模块&#xA;        build&#xA;        serving&#xA;        eventing&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;servicemesh&#34;&gt;&#xA;  ServiceMesh&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#servicemesh&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;service-fabric&#34;&gt;&#xA;  Service Fabric&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#service-fabric&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 微软&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;istio&#34;&gt;&#xA;  Istio&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#istio&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;#google IBM, lyft开源，基于envoy&#xA;组成&#xA;    数据面板&#xA;    控制面板&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;knative&#34;&gt;&#xA;  Knative&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#knative&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    管理kubernetes, Istio&#xA;模块&#xA;    build&#xA;    serve&#xA;        config&#xA;        route&#xA;    event&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;traefik&#34;&gt;&#xA;  Traefik&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#traefik&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# go实现，多后台如kubernetes, swarm, marathon, mesos&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;linkerd&#34;&gt;&#xA;  Linkerd&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linkerd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# buoyant出品&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;conduit&#34;&gt;&#xA;  Conduit&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#conduit&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 面向kubernetes轻量化mesh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;fingle&#34;&gt;&#xA;  Fingle&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fingle&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# twitter出品&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;envoy&#34;&gt;&#xA;  Envoy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#envoy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# lyft出品&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;nginmesh&#34;&gt;&#xA;  Nginmesh&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#nginmesh&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# nginx推出&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;paas&#34;&gt;&#xA;  PaaS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#paas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# platform as a service&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cloudstack&#34;&gt;&#xA;  CloudStack&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cloudstack&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 托管在apache的开源、高可用、高扩展性的云计算平台&#xA;# 支持主流hypervisors&#xA;# 一个开源云计算解决方案，可以加速iaaS的部署、管理、配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cloudfoundry&#34;&gt;&#xA;  CloudFoundry&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cloudfoundry&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# pivotal开源, 根据应用模板，动态生成很多tomcat, mysql, nosql, 动态控制这些实例的启停。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;openstack&#34;&gt;&#xA;  OpenStack&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#openstack&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 云操作系统，管理虚拟资源&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;container-orchestration&#34;&gt;&#xA;  Container Orchestration&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#container-orchestration&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;dubbo&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;spring cloud&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;kubernetes&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;配置管理&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;config&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;kubernetes configMap&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;服务发现&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zookeeper&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;eureka, consul, zookeeper&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;kubernetes services&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;负载均衡&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;自带&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;ribbon&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;kubernetes services&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;网关&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;zuul&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;kubernetes services&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分布式追踪&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;spring cloud sleuth&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;open tracing&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;容错&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;不完善&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;hystrix&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;kubernetes health check&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;通信方式&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;rpc&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;http, message&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;安全模块&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;spring cloud security&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;分布式日志&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;ELK&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;EFK&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;任务管理&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;spring batch&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;kubernetes jobs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;kubernetes&#34;&gt;&#xA;  Kubernetes&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kubernetes&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# google开源的，borg的发展，在docker技术上，管理容器化应用&#xA;特点&#xA;    不限语言&#xA;    无侵入, 服务只写业务&#xA;    适合微服务                       # 调整服务副本数, 横向扩容&#xA;    无缝迁移到公有云                  # cluster ip实现不改配置迁移&#xA;    自动化资源管理&#xA;        服务发现，用dns解析服务名&#xA;        内嵌负载均衡&#xA;        部署实施&#xA;        治理&#xA;        监控&#xA;        故障发现、自我修复&#xA;        透明服务注册、发现&#xA;        服务滚动升级、在线扩容, 根据负载自动扩容缩容&#xA;        可扩展资源自动调度、多粒度资源配额&#xA;    多层安全防护、准入&#xA;    多租户&#xA;    完善的工具&#xA;&#xA;    pod运行容器&#xA;    etcd保存所有状态&#xA;架构&#xA;    cluster&#xA;        master&#xA;            api server              # 对外http rest接口, 管理资源对象(pod, RC, service)增删改查&#xA;            controller manager      # 管理控制器, node, pod, endpoint, namespace, serviceAccount, resourceQuota自动化管理&#xA;            scheduler               # 接收controller manager命令执行pod调度&#xA;            etcd                    # 配置&#xA;        node                        # 一master多node&#xA;            特点&#xA;                node宕机，pod调度到其它节点&#xA;            pod                     # 一node几百个pod, 基本操作单元，代表一个运行进程，内部封装一个(或多个紧密相关的)容器。&#xA;                特点&#xA;                    pod内通信高效，放密切相关服务进程&#xA;                    可以判断一组相关容器的状态(用pause)&#xA;                    pause解决共享ip、容器通信、共享文件的问题&#xA;                    pod间通信用虚拟二层协议(flannel, openvswitch)实现&#xA;                    普通pod在etcd存储，再调度到某node实例化，静态pod在node中存储，在node实例化&#xA;                    对pod可进行资源(cpu,内存)限额&#xA;                label               # 标签，用标签选择器选择。key和value由用户指定，可附加到node, pod, service, rc等&#xA;                pause容器            # 根容器，共享网络栈、挂载卷&#xA;            docker/rocket           # 容器&#xA;            kubelet                 # master监视pod, 创建、修改、监控、删除&#xA;            kube-proxy              # 代理pod接口&#xA;            fluentd                 # 日志收集、存储、查询&#xA;            kube-dns                # 服务dns解析&#xA;概念&#xA;    service                         # 服务网关&#xA;        特点&#xA;            唯一名字&#xA;            唯一虚拟ip(cluster ip, service ip, vip)                  # 可多端口，每端口有名字&#xA;            提供远程服务              # 目前socket&#xA;            应用到一组pod&#xA;    event                           # 探针检测失败记录，用于排查故障&#xA;    rc                              # replication controller&#xA;        副本数&#xA;        筛选标签&#xA;        pod模板&#xA;        改变pod镜像版本，滚动升级&#xA;    replica set                     # 1.2 rc升级, 支持基于集合的标签选择。被deployment使用&#xA;    deployment                      # pod编排, rc升级&#xA;        特点&#xA;            查看pod部署进度&#xA;    HPA                             # horizontal pod autoscaler, 自动扩容缩容&#xA;        指标&#xA;            cpu utilization percentage                              # 1分钟内利用率平均值&#xA;            应用自定义指标(tps, qps)&#xA;    volume&#xA;        emptyDir&#xA;        hostPath&#xA;        gcePersistentDisk&#xA;        awsElasticBlockStore&#xA;        NFS&#xA;        persistent volume&#xA;        namespace&#xA;        annotation&#xA;动作&#xA;    扩容&#xA;        创建rc自动创建pod, 调度到合适的node&#xA;            pod定义&#xA;            副本数&#xA;            监控label                # 筛选pod得到数量&#xA;命令&#xA;    kubectl&#xA;        --help                      # 帮助, 各命令之后都可加&#xA;        version&#xA;        cluster-info&#xA;        logs&#xA;            kubectl logs --tail=1000 appID1&#xA;                # 查看日志&#xA;        run&#xA;        exec&#xA;            kubectl exec -it appID1 /bin/sh&#xA;                # 交互命令进入app&#xA;        create&#xA;            -f mysql-rc.yaml        # 创建rc&#xA;            -f mysql-svc.yaml       # 创建service&#xA;        set &#xA;            image&#xA;        get&#xA;            rc                      # 查看rc&#xA;            pods&#xA;            pod&#xA;                -o&#xA;                    wide            # 显示详情，有node name&#xA;                o-&amp;gt;&#xA;                kubectl get pod -l app=app1 -o wide&#xA;                    # 查看pod app状态&#xA;            services&#xA;            svc                     # 查看service, 包含cluster ip&#xA;            nodes&#xA;            endpoints               # service pod的ip:端口&#xA;            deployments&#xA;        describe                    # 详情&#xA;            node&#xA;            pods&#xA;            deployments&#xA;        expose&#xA;        label&#xA;        delete&#xA;        scale                       # pod扩容或缩容&#xA;            --replicas=2&#xA;        autoscale                   # 创建hpa对象&#xA;            deployment&#xA;        rolling-update              # pod滚动升级&#xA;        rollout&#xA;            status&#xA;            undo&#xA;        apply                       # 应用配置&#xA;            -f&#xA;        proxy&#xA;    kubelet&#xA;    kube-apiserver&#xA;    kube-proxy&#xA;    kube-scheduler&#xA;    kubeadm&#xA;    kube-controller-manager&#xA;    hyperkube&#xA;    apiextensions-apiserver&#xA;    mounter&#xA;镜像&#xA;    kube-apiserver&#xA;    kube-controller-manager&#xA;    kube-scheduler&#xA;    kube-proxy&#xA;    pause&#xA;    etcd&#xA;    coredns&#xA;配置&#xA;    用yaml或json定义&#xA;    pod&#xA;        kind: Pod                   # 表明是Pod&#xA;        metadata:&#xA;            name: myweb             # pod名&#xA;            labels:&#xA;                name: myweb         # 标签&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-cloud&#34;&gt;&#xA;  Spring Cloud&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;mesos&#34;&gt;&#xA;  Mesos&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mesos&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# twitter, apache开源的分布式资源管理框架, 两级调度器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;dubbo&#34;&gt;&#xA;  Dubbo&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dubbo&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    阿里开源，分布式服务框架，rpc方案，soa治理&#xA;功能&#xA;    远程通讯    # 多协议，多种长连接nio框架封装&#xA;    集群容错    # 负载均衡，容错，地址路由，动态配置&#xA;    自动发现    # 注册中心&#xA;节点&#xA;    容器(container)&#xA;    提供者(provider)&#xA;    消费者(consumer)&#xA;    注册中心(registry)&#xA;    监控中心(monitor)&#xA;    调用关系&#xA;        容器启动提供者&#xA;        提供者注册&#xA;        消费者订阅&#xA;        注册中心返回地址列表, 长连接更新&#xA;        消费者软负载均衡挑选列表中提供者&#xA;        提供者和消费者累计调用次数和时间，定时发送到监控中心&#xA;容错机制&#xA;    failover    # 默认，失败自动切换&#xA;    failfast    # 立即报错，用于幂等写操作&#xA;    failsafe    # 忽略&#xA;    failback    # 定时重发&#xA;    forking     # 并行多个取最快(any)&#xA;    broadcast   # 逐个多个，异常退出&#xA;连接方式&#xA;    广播      # 不需要中心节点，适用开发测试, 地址段224.0.0.0 - 239.255.255.255&#xA;        服务端配置 applicationContext-service.xml&#xA;            &amp;lt;dubbo:application name=”taotao-manager-service” /&amp;gt;&#xA;            &amp;lt;dubbo:registry address=”multicast://224.5.6.7:1234” /&amp;gt;&#xA;            &amp;lt;dubbo:protocol name=”dubbo” port=”20880” /&amp;gt;&#xA;            &amp;lt;dubbo:service interface=”com.taotao.manager.service.TestService” ref=”testServiceImpl” /&amp;gt;&#xA;        客户端配置 springMVC.xml&#xA;            &amp;lt;dubbp:application name=”taotao-manager-web” /&amp;gt;&#xA;            &amp;lt;dubbo:registry address=”multicast://224.5.6.7:1234” /&amp;gt;&#xA;            &amp;lt;dubbo:service interface=”com.taotao.manager.service.TestService” id=”testService”&#xA;            timeout=”10000000” /&amp;gt;&#xA;    直连&#xA;        服务端配置&#xA;            &amp;lt;dubbo:application name=”taotao-manager-service” /&amp;gt;&#xA;            &amp;lt;dubbo:registry address=”N/A” /&amp;gt;&#xA;            &amp;lt;dubbo:protocol name=”dubbo” port=”20880” /&amp;gt;&#xA;            &amp;lt;dubbo:service interface=”com.taotao.manager.service.TestService” ref=”testServiceImpl” /&amp;gt; applicationContext-service.xml&#xA;        客户端配置 springMVC.xml&#xA;            &amp;lt;dubbp:application name=”taotao-manager-web” /&amp;gt;&#xA;            &amp;lt;dubbo:service interface=”com.taotao.manager.service.TestService” id=”testService”&#xA;            timeout=”10000000” /&amp;gt;&#xA;注册中心&#xA;    zookeeper&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;dubbox&#34;&gt;&#xA;  Dubbox&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dubbox&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    当当网扩展Dubbo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;netflix-oss&#34;&gt;&#xA;  Netflix OSS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#netflix-oss&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;orleans&#34;&gt;&#xA;  orleans&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#orleans&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# .NET&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hsf&#34;&gt;&#xA;  HSF&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hsf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# high-speed service framework, 阿里出品， socket直连&#xA;特点&#xA;    不增加中间点(稳定，高度可伸缩)&#xA;结构&#xA;    注册服务信息，推送服务地址&#xA;    基于osgi&#xA;组件&#xA;    服务提供者&#xA;    消费者&#xA;    地址服务器&#xA;    配置服务器               # 分布式配置&#xA;    规则服务(diamond)       # 设置(黑白名单，认证，权重，限流)与推送&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;nscale&#34;&gt;&#xA;  NScale&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#nscale&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 可扩展容器，用node.js和docker实现&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;armada&#34;&gt;&#xA;  Armada&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#armada&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# python微服务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;soa&#34;&gt;&#xA;  SOA&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#soa&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 面向服务架构 service oriented architecture&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;eai&#34;&gt;&#xA;  EAI&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eai&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Enterprise Application Integration 建立底层结构将异构应用集成&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;esb&#34;&gt;&#xA;  ESB&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#esb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Enterprise Service Bus 企业服务总线， 是连接中枢&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;rpc&#34;&gt;&#xA;  RPC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rpc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 远程过程调用 remote procedure call&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;thrift&#34;&gt;&#xA;  Thrift&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#thrift&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;cxf&#34;&gt;&#xA;  CXF&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cxf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;常识&#xA;    自己内部整合spring(但是不耦合)&#xA;支持的协议&#xA;    soap1.1/1.2&#xA;    post/http&#xA;    restful&#xA;    http&#xA;使用&#xA;    导入cxf包&#xA;    方法1      # 不支持注解&#xA;        String address=&amp;quot;http://localhost:8888/hello&amp;quot;;&#xA;            ServerFactoryBean factoryBean=new ServerFactoryBean();&#xA;            factoryBean.setAddress(address);&#xA;            factoryBean.setServiceBean(new MyWS());&#xA;            factoryBean.create();&#xA;    方法2      # 支持注解,wsdl文件中类型不再单独schema文件&#xA;        ServerFactoryBean factoryBean = new JaxWsServerFactoryBean      # java and xml web service&#xA;    日志    # 记录握手信息(访问wsdl文件)&#xA;            ## 看日志记录得到 soap&#xA;        serverFactoryBean.getInInterceptors().add(new LoggingInInterceptor());&#xA;        serverFactoryBean.getOutInterceptors().add(new LoggingOutInterceptor());&#xA;整合spring&#xA;    o-&amp;gt; cxf2.4.4.jar/schemas/jaxws.xsd中找到命名空间&amp;quot;http://cxf.apache.org/jaxws&amp;quot;&#xA;    o-&amp;gt; 配置applicationContext.xml，加入cxf的命名空间http://cxf.apache.org/jaxws,schema地址为http://cxf.apache.org/schemas/jaxws.xsd。&#xA;        并且在eclipse中配置schema约束文件的路径&#xA;            # 该xsd约束文件的url地址用的是包地址,不规范&#xA;    o-&amp;gt; applicationContext.xml中配置&#xA;        &amp;lt;bean id=&amp;quot;studentService&amp;quot; class=&amp;quot;test.spring.StudentServiceImpl&amp;quot;/&amp;gt;&#xA;            # 用于：自身调用，被spring引用&#xA;        &amp;lt;jaxws:server serviceClass=&amp;quot;test.spring.StudentService&amp;quot; address=&amp;quot;/student&amp;quot;&amp;gt;&#xA;            # address配置服务的名称即可(web.xml的servlet中配置了服务的实际访问地址)&#xA;            ## serviceClass配置的才是真正的服务，既然它是接口，那么webService注解也应该写在接口上&#xA;            &amp;lt;jaxws:serviceBean&amp;gt;&#xA;                &amp;lt;ref bean=&amp;quot;studentService&amp;quot;/&amp;gt;&#xA;            &amp;lt;jaxws:inInterceptors&amp;gt;&#xA;                &amp;lt;bean class=&amp;quot;org.apache.cxf.interceptor.LoggingInInterceptor&amp;quot; /&amp;gt;&#xA;            &amp;lt;jaxws:outInterceptors&amp;gt;&#xA;                &amp;lt;bean class=&amp;quot;org.apache.cxf.interceptor.LoggingOutInterceptor&amp;quot; /&amp;gt;&#xA;    o-&amp;gt; web.xml中配置servlet&#xA;         &amp;lt;servlet&amp;gt;&#xA;              &amp;lt;servlet-name&amp;gt;springWS&#xA;              &amp;lt;servlet-class&amp;gt;org.apache.cxf.transport.servlet.CXFServlet        # 在cxf-2.4.4.jar包中&#xA;              &amp;lt;load-on-startup&amp;gt;1&#xA;         &amp;lt;servlet-mapping&amp;gt;&#xA;              &amp;lt;servlet-name&amp;gt;springWS&#xA;              &amp;lt;url-pattern&amp;gt;/ws/*&#xA;    o-&amp;gt; web.xml中配置spring监听器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;grpc&#34;&gt;&#xA;  GRPC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#grpc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;protobuf&#34;&gt;&#xA;  Protobuf&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#protobuf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 通信协议&#xA;命令&#xA;    protoc -I. -I-I$GOPATH/src  --go_out=plugins=grpc:. *&#xA;        # -I import目录&#xA;    protoc --grpc-gateway_out=.&#xA;插件&#xA;    安装&#xA;        # go build 出protoc-gen-go后，放入go/bin下&#xA;    protoc-gen-go&#xA;        # 编译proto文件&#xA;    protoc-gen-grpc-gateway&#xA;        # http服务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;rmi&#34;&gt;&#xA;  RMI&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rmi&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# java远程调用 remote method invocation&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hessian&#34;&gt;&#xA;  Hessian&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hessian&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 是caucho公司的开源协议,基于http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;burlap&#34;&gt;&#xA;  Burlap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#burlap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# caucho公房的开源协议,基于http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;httpinvoker&#34;&gt;&#xA;  HttpInvoker&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#httpinvoker&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# spring提供的协议，必须用spring&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;web-service&#34;&gt;&#xA;  Web Service&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web-service&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# soap通讯&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;粘合层&#34;&gt;&#xA;  粘合层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b2%98%e5%90%88%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;治理服务发现&#34;&gt;&#xA;  治理(服务发现)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b2%bb%e7%90%86%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;zookeeper&#34;&gt;&#xA;  Zookeeper&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#zookeeper&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    google chubby的开源实现。用于服务发现&#xA;    保证CP&#xA;    分布式, hadoop中hbase的组件&#xA;    fast paxos算法        # paxos存在活锁问题, fast paxos通过选举产生leader, 只有leader才能提交proposer&#xA;功能&#xA;    配置维护&#xA;    域名服务&#xA;    分布式同步&#xA;    组服务&#xA;    分布式独享锁、选举、队列&#xA;流程&#xA;    选举leader        # 多种算法, leader有最高执行ID&#xA;    同步数据&#xA;    大多数机器得到响应follow leader&#xA;exhibitor&#xA;    # supervisor for zk&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;eureka&#34;&gt;&#xA;  Eureka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eureka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Netflix，保证AP&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;consul&#34;&gt;&#xA;  Consul&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#consul&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Apache，保证CA&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;etcd&#34;&gt;&#xA;  Etcd&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#etcd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# kubernetes用，保证CP&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;路由控制&#34;&gt;&#xA;  路由控制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b7%af%e7%94%b1%e6%8e%a7%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;负载均衡策略&#xA;    随机、轮询、调用延迟判断、一致性哈希、粘滞连接&#xA;本地路由优先策略&#xA;    优先JVM（injvm），优先相同物理机（innative）&#xA;配置方式&#xA;    统一注册表、本地配置、动态下发&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spring-cloud-config&#34;&gt;&#xA;  Spring Cloud Config&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-config&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;diamond&#34;&gt;&#xA;  Diamond&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#diamond&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 淘宝&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;archaius&#34;&gt;&#xA;  Archaius&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#archaius&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# netflix&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;disconf&#34;&gt;&#xA;  Disconf&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#disconf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 百度&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;qconf&#34;&gt;&#xA;  QConf&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#qconf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 360&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;任务&#34;&gt;&#xA;  任务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;elastic-job&#34;&gt;&#xA;  Elastic-Job&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elastic-job&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 当当网&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;azkaban&#34;&gt;&#xA;  Azkaban&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#azkaban&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# linkedin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-cloud-task&#34;&gt;&#xA;  Spring Cloud Task&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-task&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;跟踪&#34;&gt;&#xA;  跟踪&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b7%9f%e8%b8%aa&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;zipkin&#34;&gt;&#xA;  zipkin&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#zipkin&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# twitter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;opentracing&#34;&gt;&#xA;  Opentracing&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#opentracing&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;hydra&#34;&gt;&#xA;  Hydra&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hydra&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 京东&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-cloud-sleuth&#34;&gt;&#xA;  Spring Cloud Sleuth&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-cloud-sleuth&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h2 id=&#34;监控&#34;&gt;&#xA;  监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spyjs&#34;&gt;&#xA;  Spy.js&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spyjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# webstorm用的监控工具&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;alinode&#34;&gt;&#xA;  Alinode&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#alinode&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 朴灵写的运行时性能管理工具&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;oneapm&#34;&gt;&#xA;  OneAPM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#oneapm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 监控node性能&#xA;功能&#xA;    接口响应时间&#xA;    数据库方法时间&#xA;    外部服务时间&#xA;    单请求的耗时比&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;容错&#34;&gt;&#xA;  容错&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%b9%e9%94%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;hystrix&#34;&gt;&#xA;  Hystrix&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hystrix&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;功能&#xA;    服务线程隔离、信号量隔离&#xA;    降级: 超时、资源不足&#xA;    熔断: 自动降级、快速恢复&#xA;    请求缓存、请求合并&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;代理&#34;&gt;&#xA;  代理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;gearman&#34;&gt;&#xA;  Gearman&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gearman&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 分布式计算, 把工作委派给其他机器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;hazelcast&#34;&gt;&#xA;  Hazelcast&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hazelcast&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 基于内存的数据网格，用于分布式计算&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;twemproxy&#34;&gt;&#xA;  Twemproxy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#twemproxy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;redis/memcache分片代理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;高可用&#34;&gt;&#xA;  高可用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e5%8f%af%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# high-availability linux&#xA;目标&#xA;    reliability: 可靠性&#xA;    availability: 可用性&#xA;    serviceability: 可服务性&#xA;        ras: remote access service(远程服务访问)&#xA;术语&#xA;    节点(node): 唯一主节点，多个备用节点&#xA;    资源(resource): 是节点可控制的实体，主节点发生故障时，可以被其它节点接管&#xA;        例如:&#xA;            磁盘分区&#xA;            文件系统&#xA;            ip地址&#xA;            应用程序服务&#xA;            nfs文件系统&#xA;    事件(event): 集群中可能发生的事件&#xA;        例如:&#xA;            系统故障&#xA;            网络连通故障&#xA;            网卡故障&#xA;            应用程序故障&#xA;    动作(action): 事件发生时ha的响应方式&#xA;        例如: 用shell 脚本对资源进行转移&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;心跳&#34;&gt;&#xA;  心跳&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%83%e8%b7%b3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;heartbeat&#34;&gt;&#xA;  HeartBeat&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#heartbeat&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;2.0模块&#xA;    heartbeat: 节点间通信检测模块&#xA;    ha-logd: 集群事件日志服务&#xA;    CCM(Consensus CLuster Membership): 集群成员一致性管理模块&#xA;    LRM(Local Resource Manager): 本地资源管理模块&#xA;    Stonith Daemon: 使出现问题的节点从集群资源中脱离&#xA;    CRM(Cluster Resource management): 集群资源管理模块&#xA;    Cluster policy engine: 集群策略引擎&#xA;            用于实现节点与资源之间的管理与依赖关系&#xA;    Cluster transition  engine: 集群转移引擎&#xA;&#xA;3.0拆分之后的组成部分&#xA;    Heartbeat: 负责节点之间的通信&#xA;    Cluster Glue: 中间层，关联Heartbeat 与 Pacemaker,包含LRM 与 stonith&#xA;    Resource Agent: 控制服务启停，监控服务状态脚本集合，被LRM调用&#xA;    Pacemaker: 也就是曾经的CRM，包含了更多的功能&#xA;        管理接口:&#xA;            crm shell&#xA;            一个使用ajax web 的web窗口&#xA;            hb_gui图形工具&#xA;            DRBD-MC, 一个基于java的工具&#xA;&#xA;版本差异&#xA;    与1.x相比，2.1.x版本变化&#xA;        保留原来所有功能&#xA;        自动监控资源&#xA;        对各资源组进行独立监控&#xA;        同时监控系统负载&#xA;            自动切换到负载低的node上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;keepalived&#34;&gt;&#xA;  Keepalived&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#keepalived&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;vrrp&#xA;    # virtual router redundancy protocol 虚拟路由器冗余协议&#xA;    # 解决静态路由出现的闪单点故障问题，它能够保证网络的不间断．稳定运行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;负载&#34;&gt;&#xA;  负载&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%9f%e8%bd%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# load balance&#xA;方法&#xA;        dns轮循&#xA;&#xA;        java nio&#xA;        erlang语言&#xA;        linux epoll&#xA;        bsd kqueue&#xA;        消息队列、事件通知&#xA;        c/c++下ace, boost.asio, libev(libevent)&#xA;        服务器mina, jetty, node.js, netty&#xA;        java协程框架 quasar kilim&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;haproxy&#34;&gt;&#xA;  Haproxy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#haproxy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;监控页面&#xA;        /status&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;tengine&#34;&gt;&#xA;  Tengine&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tengine&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 淘宝基于nginx修改，添加了功能&#xA;监控&#xA;    /upstream_status&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;openresty&#34;&gt;&#xA;  OpenResty&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#openresty&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 淘宝改的nginx, lua工具&#xA;安装&#xA;    yum install -y gcc gcc-c++ kernel-devel readline-devel pcre-devel openssl-devel openssl zlib zlib-devel pcre-devel&#xA;    wget openresty-1.9.15.1.tar.gz&#xA;    ./configure --prefix=/opt/openresty --with-pcre-jit --with-ipv6 --without-http_redis2_module --with-http_iconv_module -j2&#xA;    make &amp;amp;&amp;amp; make install&#xA;    ln -s /opt/openresty/nginx/sbin/nginx /usr/sbin&#xA;    /opt/openresty/nginx/conf/nginx.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;varnish&#34;&gt;&#xA;  Varnish&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#varnish&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 反向代理, http缓存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;traffic-server&#34;&gt;&#xA;  Traffic Server&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#traffic-server&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# apache 缓存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;squid&#34;&gt;&#xA;  Squid&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#squid&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;配置文件&#xA;    /etc/squid/squid.conf&#xA;代理类型&#xA;    普通代理&#xA;    透明代理&#xA;    反向代理&#xA;缓存&#xA;    动态资源&#xA;    静态资源&#xA;参考资料&#xA;    squid 透明代理详解&#xA;配置&#xA;    # squid.conf&#xA;    http_port 3128                                                # squid服务端口&#xA;    icp_port 3130                                                # udp端口,用来接收和发送ICP消息&#xA;    cache_dir ufs /var/spool/squid                                # 缓存目录, 写入方式有aufs与ufs两种,aufs使用大量线程异步进行磁盘i/o操作&#xA;    cache_access_log /var/log/squid/access.log&#xA;    cache_log /var/log/squid/cache.log&#xA;    cache_store_log /var/log/squid/store.log&#xA;    pid_filename /var/run/squid.pid                        # 日志文件位置&#xA;&#xA;    #auth_param basic children 5&#xA;    #auth_param basic realm Squid proxy-caching web server&#xA;    #auth_param basic credentialsttl 2 hours                 # 关闭认证，认证一般不需要&#xA;&#xA;    cache_effective_user squid&#xA;    cache_effective_group squid&#xA;    cache_mgr youraccount@your.e.mail                        # 设置squid用户及用户组、管理员账号&#xA;&#xA;    cache_mem 128 MB                                        # 运行内存配置&#xA;&#xA;    cache_swap_low 90&#xA;    cache_swap_high 95&#xA;    maximum_object_size 4096 KB                        ＃ 与磁盘容量相关的配置，90、95为百分比，磁盘大时4096 KB可以改成32768 KB&#xA;&#xA;    maximum_object_size_in_memory 8 KB                ＃ 内存缓存资料大小&#xA;&#xA;    以下为定义acl(访问控制列表)&#xA;            ＃ 语法为:acl&amp;lt;acl&amp;gt; &amp;lt;acl名称&amp;gt; &amp;lt;acl类型&amp;gt; &amp;lt;配置的内容&amp;gt;&#xA;    acl All src 0/0&#xA;    acl Manager proto cache_object  acl Localhost src 127.0.0.1/32&#xA;    acl Safe_ports port 80 21 443 563 70 210 280 488 591 777 1025-65535&#xA;    acl SSL_ports 443 563&#xA;    acl CONNECT method CONNECT&#xA;    acl MyNetwork src 192.168.0.0/16&#xA;&#xA;    以下为利用前面定义的acl,定义访问控制规则&#xA;    http_access allow Manager Localhost&#xA;    http_access deny Manager&#xA;    http_access deny !Safe_ports&#xA;    http_access deny CONNECT SSL_ports&#xA;    http_access allow MyNetwork&#xA;    http_access deny All&#xA;&#xA;    例子: 禁止访问sina&#xA;    acl sina dstdomain .sina.com.cn .sina.com&#xA;    http_access deny sina&#xA;    或&#xA;    acl sina dst 58.63.236.26 58.63.236.27 58.63.236.28 58.63.236.29 58.63.236.30 58.63.236.31 58.63.236.32 58.63.236.33 58.63.236.34 58.63.236.35 58.63.236.36 58.63.236.37 58.63.236.38 58.63.236.39 58.63.236.49 58.63.236.50&#xA;    http_access deny sina&#xA;    或&#xA;    acl sina dst www.sina.com.cn&#xA;    http_access deny sina&#xA;&#xA;    例子: 禁止来自某些ip的访问&#xA;    acl zhang src 192.168.63.6/32&#xA;    http_access deny zhang&#xA;&#xA;    例子: 禁止在某些时段访问&#xA;    acl Working_hours MTWHF 08:00-17:00&#xA;    http_access allow Working_hours&#xA;    http_access deny !Working_hours&#xA;&#xA;    例子: 禁止某个代理客户建立过多连接&#xA;    acl OverConnLimit maxconn&#xA;    http_access deny OverConnLimit&#xA;&#xA;    定义与其它代理服务器的关系,语法: &amp;lt;cache_peer&amp;gt; &amp;lt;主机名称&amp;gt; &amp;lt;类别&amp;gt; &amp;lt;http_port&amp;gt; &amp;lt;icp_port&amp;gt; &amp;lt;其它参数&amp;gt;&#xA;    cache_peer 192.168.60.6 parent 4480 7 no-query default&#xA;&#xA;    #设置与其它代理服务器的关系: &amp;lt;cache_peer_access&amp;gt; &amp;lt;上层 Proxy &amp;gt; &amp;lt;allow|deny&amp;gt; &amp;lt;acl名称&amp;gt;&#xA;    #cache_peer_access 192.168.60.6 allow aclxxx&#xA;    #cache_peer_access 192.168.60.6 deny !aclxxx&#xA;    coredump_dir /var/spool/squid                                        # 崩溃存储目录&#xA;使用&#xA;    step1 检查配置文件&#xA;        squid -k parse&#xA;    step2  初始化cache 目录&#xA;        squid -z(X)                                # X会显示过程&#xA;    step3 启动squid&#xA;        service squid start&#xA;        或&#xA;        /usr/local/squid/sbin/squid -sD&#xA;    停止squid&#xA;        squid -k shutdown&#xA;    重新载入配置&#xA;        squid -k reconfigure&#xA;    滚动日志&#xA;        squid -k rotate&#xA;案例&#xA;    透明代理&#xA;        step1 检查配置文件&#xA;            squid -k parse&#xA;        step2  初始化cache 目录&#xA;            squid -z(X)                                # X会显示过程&#xA;        step3 启动squid&#xA;            service squid start&#xA;            或&#xA;            /usr/local/squid/sbin/squid -sD&#xA;        停止squid&#xA;            squid -k shutdown&#xA;        重新载入配置&#xA;            squid -k reconfigure&#xA;        滚动日志&#xA;            squid -k rotate&#xA;    代理&#xA;        squid.conf&#xA;            http_port 3128&#xA;            http_access allow all&#xA;            或&#xA;            http_port 3128&#xA;            http_access deny all前面添加&#xA;            acl 192.168.0.42 src 192.168.0.0/24&#xA;            http_access allow 192.168.0.42                        ＃ 192.168.0.42为允许的ip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;lvs&#34;&gt;&#xA;  LVS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lvs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    第四层开始负载(可以建立到三层负载)&#xA;&#xA;    第四层负载&#xA;        socket进必须连lvs&#xA;&#xA;模式&#xA;    tun&#xA;        # lvs负载均衡器将请求包发给物理服务器，后者将应答包直接发给用户&#xA;    net&#xA;        # 请求和应答都经过lvs&#xA;    dr&#xA;        # 不要隧道结构的tun&#xA;使用&#xA;    DR模式 centos6&#xA;    yum install-y gcc gcc-c++ makepcre pcre-devel kernel-devel openssl-devel libnl-devel popt-devel&#xA;    modprobe -l |grep ipvs&#xA;        # 检查内核是否集成&#xA;    echo &amp;quot;1&amp;quot; &amp;gt; /proc/sys/net/ipv4/ip_forward&#xA;        # 开启路由转发&#xA;    安装ipvsadm&#xA;        http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz&#xA;    安装keepalived&#xA;        http://www.keepalived.org/software/keepalived-1.2.7.tar.gz&#xA;        ./configure --prefix=/usr/local/keepalived&#xA;&#xA;        cp  /usr/local/keepalived/etc/rc.d/init.d/keepalived        /etc/init.d/&#xA;        cp /usr/local/keepalived/etc/sysconfig/keepalived        /etc/sysconfig/&#xA;        mkdir /etc/keepalived/&#xA;        cp /usr/local/keepalived/etc/keepalived/keepalived.conf        /etc/keepalived/&#xA;        cp /usr/local/keepalived/sbin/keepalived        /usr/sbin/&#xA;&#xA;        o-&amp;gt; 配置文件/etc/keepalived/keepalived.conf&#xA;        ! Configuration File forkeepalived&#xA;        global_defs {&#xA;        notification_email {&#xA;        test@sina.com    #故障接受联系人&#xA;        }&#xA;        notification_email_from admin@test.com  #故障发送人&#xA;        smtp_server 127.0.0.1  #本机发送邮件&#xA;        smtp_connect_timeout 30&#xA;        router_id LVS_MASTER  #BACKUP上修改为LVS_BACKUP&#xA;        }&#xA;        vrrp_instance VI_1 {&#xA;        state MASTER    #BACKUP上修改为BACKUP&#xA;        interface eth0&#xA;        virtual_router_id 51  #虚拟路由标识，主从相同&#xA;        priority 100  #BACKUP上修改为90&#xA;        advert_int 1&#xA;        authentication {&#xA;        auth_type PASS&#xA;        auth_pass 1111  #主从认证密码必须一致&#xA;        }&#xA;        virtual_ipaddress {    #Web虚拟IP（VTP）&#xA;        172.0.0.10&#xA;        }&#xA;        }&#xA;        virtual_server 172.0.0.10 80 { #定义虚拟IP和端口&#xA;        delay_loop 6    #检查真实服务器时间，单位秒&#xA;        lb_algo rr      #设置负载调度算法，rr为轮训&#xA;        lb_kind DR      #设置LVS负载均衡DR模式&#xA;        persistence_timeout 50 #同一IP的连接60秒内被分配到同一台真实服务器&#xA;        protocol TCP    #使用TCP协议检查realserver状态&#xA;        real_server 172.0.0.13 80 {  #第一个web服务器&#xA;        weight 3          #节点权重值&#xA;        TCP_CHECK {      #健康检查方式&#xA;        connect_timeout 3 #连接超时&#xA;        nb_get_retry 3    #重试次数&#xA;        delay_before_retry 3  #重试间隔/S&#xA;        }&#xA;        }&#xA;        real_server 172.0.0.14 80 {  #第二个web服务器&#xA;        weight 3&#xA;        TCP_CHECK {&#xA;        connect_timeout 3&#xA;        nb_get_retry 3&#xA;        delay_before_retry 3&#xA;            }&#xA;        }&#xA;        }&#xA;&#xA;        service keepalived restart&#xA;&#xA;    启动脚本 /etc/init.d/real.sh&#xA;        #description : start realserver&#xA;        VIP=172.0.0.10&#xA;        . /etc/init.d/functions&#xA;        case &amp;quot;$1&amp;quot; in&#xA;        start)&#xA;        /sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up&#xA;        echo &amp;quot;1&amp;quot; &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_ignore&#xA;        echo &amp;quot;2&amp;quot; &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_announce&#xA;        echo &amp;quot;1&amp;quot; &amp;gt;/proc/sys/net/ipv4/conf/all/arp_ignore&#xA;        echo &amp;quot;2&amp;quot; &amp;gt;/proc/sys/net/ipv4/conf/all/arp_announce&#xA;        echo &amp;quot;LVS RealServer Start OK&amp;quot;&#xA;        ;;&#xA;        stop)&#xA;        /sbin/ifconfig lo:0 down&#xA;        echo &amp;quot;0&amp;quot; &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_ignore&#xA;        echo &amp;quot;0&amp;quot; &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_announce&#xA;        echo &amp;quot;0&amp;quot; &amp;gt;/proc/sys/net/ipv4/conf/all/arp_ignore&#xA;        echo &amp;quot;0&amp;quot; &amp;gt;/proc/sys/net/ipv4/conf/all/arp_announce&#xA;        echo &amp;quot;LVS RealServer Stoped OK&amp;quot;&#xA;        ;;&#xA;        *)&#xA;        echo &amp;quot;Usage: $0 {start|stop}&amp;quot;&#xA;        exit 1&#xA;        esac&#xA;&#xA;    o-&amp;gt; 开机启动&#xA;        chmod +x /etc/init.d/real.sh&#xA;        /etc/init.d/real.sh start&#xA;        echo &amp;quot;/etc/init.d/real.sh start&amp;quot; &amp;gt;&amp;gt; /etc/rc.local&#xA;    o-&amp;gt; 测试&#xA;        service httpd start&#xA;        echo &amp;quot;1&amp;quot; &amp;gt; /var/www/html/index.html&#xA;        service iptables stop&#xA;        setenforce 0&#xA;            # 关闭selinux&#xA;    o-&amp;gt; 其他命令&#xA;        ipvsadm -ln&#xA;            # 集群中服务器ip信息&#xA;        ip addr&#xA;            # 显示VIP当前绑定的服务器&#xA;        tail -f /var/log/messages&#xA;            # 日志&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据库&#34;&gt;&#xA;  数据库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;读写分离&#34;&gt;&#xA;  读写分离&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;MySQL主从复制&#xA;Haproxy + 多Slave&#xA;DRBD + Heartbeat + MySQL&#xA;MySQL Cluster&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分片&#34;&gt;&#xA;  分片&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e7%89%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;问题&#xA;    事务&#xA;    Join&#xA;    迁移&#xA;    扩容&#xA;    ID生成&#xA;    分页&#xA;方案&#xA;    事务补偿        # 数据对账：基于日志对比、同步标准数据源&#xA;    分区            # MySQL机制分文件存储，客户端无感知&#xA;    分表            # 客户端管理分表路由&#xA;    分库&#xA;        为什么 &#xA;            单库无法承接连接数时分库，MySQL单库5千万条，Oracle单库一亿条&#xA;        策略&#xA;            数值范围&#xA;            取模&#xA;            日期&#xA;框架&#xA;    Sharding-JDBC&#xA;    TSharding&#xA;代理&#xA;    Atlas&#xA;    MyCAT&#xA;    Vitess&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分布式文件系统&#34;&gt;&#xA;  分布式文件系统&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;HDFS            # 批量读写，高吞吐量，不适合小文件&#xA;FastDFS         # 轻量级，适合小文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;一致性&#34;&gt;&#xA;  一致性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e8%87%b4%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;CAP&#xA;    一致性&#xA;        强一致性、弱一致性（秒级），最终一致性&#xA;    可用性&#xA;    分区容错性（网络故障）&#xA;BASE&#xA;    Basically Available（基本可用），Soft state（软状态），Eventually consistent（最终一致性）&#xA;幂等性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分布式锁&#34;&gt;&#xA;  分布式锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;算法&#xA;    PAXOS&#xA;    Zab&#xA;        # Zookeeper使用&#xA;    Raft&#xA;        # 三角色：Leader（领袖），Follower（群众），Candidtate（候选人）&#xA;    Gossip&#xA;        # Cassandra使用&#xA;实现方式&#xA;    数据库&#xA;        有单点问题&#xA;    缓存&#xA;        非阻塞性能好&#xA;        有锁不释放问题&#xA;        实现&#xA;            RedLock setnx&#xA;            Memcached add&#xA;    Zookeeper&#xA;        有序临时节点，集群透明解决单点问题，锁被释放，锁可重入&#xA;        性能不如缓存，吞吐量随集群规模变大而下降&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;一致性哈希&#34;&gt;&#xA;  一致性哈希&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;扩容映射&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分布式事务&#34;&gt;&#xA;  分布式事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    两阶段提交、多阶段提交&#xA;    TCC事务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;atomikos&#34;&gt;&#xA;  Atomikos&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#atomikos&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h1 id=&#34;id生成器&#34;&gt;&#xA;  ID生成器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#id%e7%94%9f%e6%88%90%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Snowflake算法           # Twitter&#xA;    41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)&#xA;MySQL自增ID + &amp;quot;REPLACE INTO XXX:SELECT LAST_INSERT_ID();&amp;quot;&#xA;    # Flicker&#xA;MongoDB ObjectId&#xA;    不能自增&#xA;UUID&#xA;    无序，过长，影响检索性能&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>前端</title>
      <link>https://ukeate.com/docs/middleware/library_frontend/</link>
      <pubDate>Wed, 10 Oct 2018 14:51:24 +0800</pubDate>
      <guid>https://ukeate.com/docs/middleware/library_frontend/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;AJAX&#xA;    # Asynchronous JavaScript and XML&#xA;    特点&#xA;        异步，提升了用户体验&#xA;            局部刷新&#xA;        优化传输，减少了数据和带宽&#xA;        客户端运行，承担服务器压力&#xA;    XMLHttpRequest&#xA;        # IE5首次引入&#xA;        readyState&#xA;            0 未初始化, 1 正在加载, 2 已加载, 3 交互中, 4 完成&#xA;        status      # 服务器http状态码&#xA;        responseXML     # 响应结果，表示为xml&#xA;        responseText    # 响应结果，表示为串&#xA;        open(&amp;quot;method&amp;quot;, url)&#xA;        send()&#xA;        abort()     # 停止当前请求&#xA;&#xA;        创建&#xA;            new ActiveXObject()     # IE&#xA;            new XMLHttpRequest()        # firefox&#xA;        callback种类&#xA;            onSuccess&#xA;            onFailure&#xA;            onUninitialized&#xA;            onLoading&#xA;            onLoaded&#xA;            onInteractive&#xA;            onComplete&#xA;            onException&#xA;jsonp&#xA;    来源&#xA;        js在浏览器有同源策略(Same-Origin Policy), 只访问同一域下文件&#xA;        &amp;lt;script&amp;gt;标签没有同源策略限制&#xA;    原理&#xA;        编程时&#xA;            客户端注册callback f(), 名字传给服务器&#xA;            跨域服务器以文本方式写js函数, 并构造应传的json数据, 函数中调用f(json)&#xA;        运行时&#xA;            动态添加&amp;lt;script&amp;gt;标签, 请求跨域服务器的js函数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;开发框架&#34;&gt;&#xA;  开发框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;模块化&#34;&gt;&#xA;  模块化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;bower&#xA;browserify&#xA;require.js&#xA;mod.js&#xA;        # 百度模块化开发工具&#xA;curl.js&#xA;        # amd load&#xA;sea.js&#xA;when&#xA;        # amd 加载&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;测试&#34;&gt;&#xA;  测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;vConsole    # APP HTML页面显示console按钮，打印请求参数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;bigpipe&#34;&gt;&#xA;  bigpipe&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bigpipe&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    facebook的页面异步加载框架&#xA;    不同于ajax的http调用，需要更多的网线连接。bigpipe与当前页面共用http连接&#xA;&#xA;使用&#xA;    前端&#xA;        &amp;lt;script src=&amp;quot;jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;script src=&amp;quot;underscore.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;script src=&amp;quot;bigpipe.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;div id=&amp;quot;body&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;        &amp;lt;script type=&amp;quot;text/template&amp;quot; id=&amp;quot;tpl_body&amp;quot;&amp;gt;&#xA;                &amp;lt;div&amp;gt;&amp;lt;%=articles%&amp;gt;&amp;lt;/div&amp;gt;&#xA;        &amp;lt;/script&amp;gt;&#xA;        &amp;lt;script&amp;gt;&#xA;        var bigpipe = new Bigpipe()&#xA;        bigpipe.ready(&#39;articles&#39;, function(data) {&#xA;                $(&#39;#body&#39;).html(_.render($(&#39;#tpl_body&#39;).html(), {articles: data}))&#xA;        })&#xA;        &amp;lt;/script&amp;gt;&#xA;&#xA;    服务器端&#xA;        app.get(&#39;/profile&#39;, function (req, res) {&#xA;            if (!cache[layout]) {&#xA;                    cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), &#39;utf8&#39;)&#xA;            }&#xA;            res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;})&#xA;            res.write(render(complie(cache[layout])))&#xA;            ep.all(&#39;users&#39;, &#39;articles&#39;, function () {&#xA;                    res.end()&#xA;            })&#xA;            ep.fail(function(err) {&#xA;                    res.end()&#xA;            })&#xA;            db.getData(&#39;sql1&#39;, function (err, data) {&#xA;                    data = err ? {} : data&#xA;                    res.write(&#39;&amp;lt;script&amp;gt;bigpipe.set(&amp;quot;articles&amp;quot;, &#39; + JSON.stringify(data) + &#39;);&amp;lt;/script&amp;gt;&#39;)&#xA;            })&#xA;        })&#xA;&#xA;    nodejs使用&#xA;        &#39;use strict&#39;&#xA;        var BigPipe = require(&#39;bigpipe&#39;);&#xA;        var bigpipe = BigPipe.createServer(8080, {&#xA;            pagelets: __dirname + &#39;/pagelets&#39;,&#xA;                # 页面路径&#xA;            dist: __dirname + &#39;/dist&#39;&#xA;                # 静态资源路径&#xA;        });&#xA;        o-&amp;gt; 开启https&#xA;        var bigpipe = BigPipe.createServer(443, {&#xA;            key: fs.readFileSync(__dirname + &#39;/ssl.key&#39;, &#39;utf-8&#39;),&#xA;            cert: fs.readFileSync(__dirname + &#39;/ssl.cert&#39;, &#39;utf-8&#39;)&#xA;        });&#xA;        o-&amp;gt; 嫁接&#xA;        var server = require(&#39;http&#39;).createServer(),&#xA;            BigPipe = require(&#39;bigpipe&#39;);&#xA;        var bigpipe = new BIgPipe(server, {options});&#xA;        bigpipe.listen(8080, function listening(){&#xA;            console.log(&#39;listening on port 8080.&#39;);&#xA;        });&#xA;&#xA;        bigpipe.define(&#39;../pagelets&#39;, function done(err){&#xA;        });        # 合并pagelets, 结束后调用done&#xA;        o-&amp;gt; AMD 方式define，与链式编程&#xA;        bigpipe.define([Pagelet1, Pagelet2, Pagelet3], function done(err){&#xA;        }).define(&#39;../more/pagelets&#39;, function done(err){});&#xA;        # bigpipe.before来添加中间件, remove来删除中间件, disable、enable来跳过和重新启用中间件&#xA;        # bigpipe.use来引用插件&#xA;api&#xA;    BigPipe所有组件继承EventEmitter interface&#xA;功能&#xA;    pagelets&#xA;        var Pagelet = require(&#39;bigpipe&#39;).Pagelet;&#xA;                # var Pagelet = require(&#39;pagelet&#39;);&#xA;        Pagelet.extend({&#xA;                js: &#39;client.js&#39;,&#xA;                css: &#39;sidebar.styl&#39;,&#xA;                view: &#39;templ.jade&#39;,&#xA;                name: &#39;sidebar‘,            // 唯一路由路径&#xA;                get: function get(){&#xA;                        // 接收get请求时的业务逻辑&#xA;                }&#xA;        }).on(module);&#xA;                # 自动写 module.export部分来导出&#xA;        # traverse方法自动调用来递归找additional child pagelets, 要手动指定名称时手动调用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;脚手架&#34;&gt;&#xA;  脚手架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%84%9a%e6%89%8b%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;yeoman&#xA;        # google和外部贡献团队合作开发，通过grunt和bower包装一个易用的工作流。由yo(脚手架), grunt(构建), bower(包管理)三部分组成&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;webpack&#34;&gt;&#xA;  webpack&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#webpack&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 介绍&#xA;        模块打包&#xA;&#xA;# 命令&#xA;        npm i -g webpack&#xA;        npm i css-loader style-loader&#xA;        webpack ./entry.js bundle.js&#xA;                # --progress&#xA;                # --colors&#xA;                # --watch&#xA;                # --module-bind&#xA;                ## jade, &#39;css=style!css&#39;&#xA;                webpack ./entry.js bundle.js --module-bind &#39;css=style!css&#39;&#xA;                webpack&#xA;                        # use webpack.config.js&#xA;        npm i webpack-dev-server -g&#xA;        webpack-dev-server&#xA;                # --progress --colors&#xA;                # --hot 热部署&#xA;                # 启动一个express在8080端口&#xA;# 配置&#xA;    # webpack.config.js&#xA;&#xA;    var webpack = require(&#39;webpack&#39;)&#xA;    var merge = require(&#39;webpack-merge&#39;)&#xA;    var path = require(&#39;path&#39;)&#xA;    var HtmlwebpackPlugin = require(&#39;html-webpack-plugin&#39;)&#xA;&#xA;    var ROOT_PATH = path.resolve(__dirname)&#xA;    var APP_PATH = path.resolve(ROOT_PATH, &#39;app&#39;)&#xA;    var BUILD_PATH = path.resolve(ROOT_PATH, &#39;build&#39;)&#xA;&#xA;    var baseWebpackConfig = {&#xA;            entry: {&#xA;                    app: path.resolve(APP_PATH, &#39;app.jsx&#39;)&#xA;            },&#xA;            output: {&#xA;                    path: BUILD_PATH,&#xA;                    filename: &#39;[name].js&#39;,&#xA;                        chunkFilename: &#39;[id].chunk.js&#39;,&#xA;                    publicPath: &#39;/&#39;,&#xA;                            # 浏览器路径&#xA;            },&#xA;            devtool: &#39;eval-source-map&#39;,&#xA;            devServer: {&#xA;                contentBase: path.resolve(ROOT_PATH, &#39;build&#39;) ,&#xA;                historyApiFallback: true,&#xA;                inline: true,&#xA;                port: 3031&#xA;        }&#xA;            resolve: {&#xA;                    extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.vue&#39;, &#39;jsx&#39;],&#xA;                        # 这样可以在js import 中加载扩展名&#xA;                    fallback: [path.join(__dirname, &#39;../node_modules&#39;)],&#xA;                    alias: {&#xA;                            &#39;src&#39;: path.resolve(__dirname, &#39;../src&#39;),&#xA;                            &#39;assets&#39;: path.resolve(_dirname, &#39;../src/assets&#39;),&#xA;                            &#39;components&#39;: path.resolve(__dirname, &#39;../src/components&#39;)&#xA;                    }&#xA;            },&#xA;            resolveLoader: {&#xA;                    fallback: [path.join(__dirname, &#39;../node_modules&#39;)]&#xA;            },&#xA;            module: {&#xA;                preLoaders: [&#xA;                        {&#xA;                                test: /\.jsx?$/,&#xA;                                loaders: [&#39;eslint&#39;],&#xA;                                include: APP_PATH&#xA;                        }&#xA;                ]&#xA;                    loaders: [&#xA;                    {&#xA;                            test: /\.vue$/,&#xA;                            loader: &#39;vue&#39;&#xA;                    },&#xA;                    {&#xA;                            test: /\.js$/,&#xA;                            loader: &#39;babel&#39;,&#xA;                            include: projectRoot,&#xA;                            exclude: /node_modules/&#xA;                    },&#xA;                    {&#xA;                            test: /\.json$/,&#xA;                            loader: &#39;json&#39;&#xA;                    },&#xA;                    {&#xA;                            test: /\.html$/,&#xA;                            loader: &#39;vue-html&#39;&#xA;                    },&#xA;                    {&#xA;                            test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,&#xA;                            loader: &#39;url&#39;,&#xA;                            query: {&#xA;                                    limit: 10000,&#xA;                                    name: path.posix.join(&#39;static&#39;, &#39;img/[name].[hash:7].[ext]&#39;)&#xA;                            }&#xA;                    },&#xA;                    {&#xA;                            test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,&#xA;                            loader: &#39;url&#39;,&#xA;                            query: {&#xA;                                    limit: 10000,&#xA;                                    name: path.posix.join(&#39;static&#39;, &#39;fonts/[name].[hash:7].[ext]&#39;)&#xA;                            }&#xA;                    }&#xA;                    ]&#xA;            },&#xA;        plugins: [&#xA;                    new HtmlwebpackPlugin({title: &#39;a&#39;})&#xA;            ]&#xA;    }&#xA;    module.exports = merge(baseWebpackConfig, {&#xA;    })&#xA;# 插件&#xA;    内置&#xA;            # 通过webpack.BannerPlugin获得&#xA;            bannerPlugin&#xA;    htmlWebpackPlugin&#xA;    hotModuleReplacement&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;grunt&#34;&gt;&#xA;  grunt&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#grunt&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        压缩js代码&#xA;        合并js文件&#xA;        单元测试&#xA;        js代码检查&#xA;        监控文件修改重启任务&#xA;命令&#xA;        grunt dist&#xA;                # 重新生成dist目录，将编译后的css,js放入&#xA;        grunt watch&#xA;                # 监测less源码文件改动，自动重新编译为css&#xA;        grunt test&#xA;                # 运行测试用例&#xA;        grunt docs&#xA;                # 编译并测试&#xA;        grunt 重新构建所有内容并运行测试用例&#xA;安装&#xA;        # grunt模块以grunt-contrib-开头&#xA;        npm i -g grunt grunt-init grunt-cli&#xA;&#xA;例子&#xA;    o-&amp;gt;&#xA;    // Gruntfile.js&#xA;    module.exports = function (grunt) {&#xA;            grunt.loadNpmTasks(&#39;grunt-contrib-clean&#39;)&#xA;            grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;)&#xA;            grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;)&#xA;            grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;)&#xA;            grunt.loadNpmTasks(&#39;grunt-replace&#39;)&#xA;&#xA;            grunt.initConfig({&#xA;                    pkg: grunt.file.readJSON(&#39;package.json&#39;),&#xA;                    jshint: {&#xA;                            all: {&#xA;                                    src: [&#39;Gruntfile.js&#39;, &#39;src/**/*.js&#39;, &#39;test/**/*.js&#39;],&#xA;                                    options: {&#xA;                                            jshintrc: &#39;jshint.json&#39;&#xA;                                    }&#xA;                            }&#xA;                    },&#xA;                    clean: [&#39;lib&#39;],&#xA;                    concat: {&#xA;                            htmlhint: {&#xA;                                    src: [&#39;src/core.js&#39;, &#39;src/reporter.js&#39;, &#39;src/htmlparser.js&#39;, &#39;src/rules/*.js&#39;],&#xA;                                    dest: &#39;lib/htmlhint.js&#39;&#xA;                            }&#xA;                    },&#xA;                    uglify: {&#xA;                            htmlhint: {&#xA;                                    options: {&#xA;                                            banner: &#39;a&#39;,&#xA;                                            beautify: {&#xA;                                                    ascii_only: true&#xA;                                            }&#xA;                                    },&#xA;                                    files: {&#xA;                                            &#39;lib/&amp;lt;%= pkg.name %&amp;gt;.js&#39;: [&#39;&amp;lt;%= concat.htmlhint.dest %&amp;gt;&#39;]&#xA;                                    }&#xA;                            }&#xA;                    },&#xA;                    relace: {&#xA;                            htmlhint: {&#xA;                                    files: {&#39;lib/htmlhint.js&#39;: &#39;lib/htmlhint.js&#39;},&#xA;                                    options: {&#xA;                                            prefix: &#39;@&#39;,&#xA;                                            variables: {&#xA;                                                    &#39;VERSION&#39;: &#39;&amp;lt;%= pkg.version %&amp;gt;&#39;&#xA;                                            }&#xA;                                    }&#xA;                            }&#xA;                    }&#xA;            })&#xA;            grunt.registerTask(&#39;dev&#39;, [&#39;jshint&#39;, &#39;concat&#39;])&#xA;            grunt.registerTask(&#39;default&#39;, [&#39;jshint&#39;, &#39;clean&#39;, &#39;concat&#39;, &#39;uglify&#39;, &#39;replace&#39;])&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;gulp&#34;&gt;&#xA;  gulp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gulp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        自动化构建项目工具&#xA;使用&#xA;    安装&#xA;            npm install --global gulp&#xA;                    # npm install --save-dev gulp&#xA;            // gulpfile.js 在项目根目录&#xA;            var gulp = require(&#39;gulp&#39;);&#xA;            gulp.task(&#39;default&#39;, function () {&#xA;                    // 默认任务代码&#xA;            })&#xA;    命令&#xA;            shell&amp;gt; gulp&#xA;                    # gulp &amp;lt;task&amp;gt; &amp;lt;othertask&amp;gt;&#xA;插件&#xA;    gulp-dom-src&#xA;            合并src, 改写html&#xA;    gulp-if&#xA;    gulp-useref&#xA;    gulp-usemin&#xA;    gulp-htmlreplace&#xA;    google-closure-compiler&#xA;    gulp-add-src&#xA;    gulp-autoprefixer&#xA;    gulp-changed&#xA;    gulp-clean&#xA;    gulp-clean-css&#xA;    gulp-concat&#xA;    gulp-concat-css&#xA;    gulp-consolidate&#xA;    gulp-html-replace&#xA;            # 替换html内容&#xA;    gulp-htmlmin&#xA;    gulp-imagemin&#xA;    gulp-less&#xA;    gulp-make-css-url-version&#xA;    gulp-minify-css&#xA;    gulp-rev-append&#xA;    gulp-uglify&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;fis&#34;&gt;&#xA;  fis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        npm的形式发布&#xA;        百度前端工具框架，为前端开发提供底层架构&#xA;        所有js文件都用模块书写，一个文件一个模块&#xA;                F.module(name, function(require, exports){}, deps);&#xA;&#xA;安装&#xA;        npm install -g fis&#xA;命令&#xA;    fis install                        # 安装模块&#xA;    fis release                        # 编译和发布, -h 查看帮助&#xA;                            ## 默认会调整资源引用的相对路径到绝对路径&#xA;                            ### 不想对路径做调整，可以使用spt工具https://github.com/fouber/spt&#xA;                            ## --optimize 或 -o 压缩。--md5对不同静态资源生成版本，也可以配置时间戳&#xA;                            ## --dest 或 -d。指定项目发布配置，在执行编译后发布。可以远程发布、发布多个&#xA;                            ## --pack 开启打包处理&#xA;                            ## -omp 简化 --optimize --md5 --pack&#xA;                            ## --watch 或 -w 自动监听文件修改，自动编译&#xA;                            ### 该监视考虑了各种嵌入关系, a.css中嵌入了b.css, b修改时会重构这两个文件&#xA;                            ### --live 或 -L 。在-w基础上实现，监视到修改后自动刷新浏览器页面&#xA;    fis server start                # 启动本地调试服务器&#xA;                            ## -p [port] 指定新端口&#xA;                            ## --type node 如果没有java, php环境，指定用node环境启动&#xA;    fis server stop&#xA;    fis server open                # 查看默认产出目录&#xA;配置&#xA;    o-&amp;gt;&#xA;    fis.config.set(&#39;pack&#39;, {&#xA;            &#39;pkg/lib.js&#39;: [&#xA;                    &#39;/lib/mod.js&#39;,&#xA;                    &#39;/modules/underscore/**.js&#39;,&#xA;                    &#39;modules/backbone/**.js&#39;&#xA;            ]&#xA;    });                # 文件合并成lib.js，但是不替换页面中的静态资源引用&#xA;                    ## 为了替换引用，使用fis的后端静态资源管理来加载引用，或者用fis-postpackager-simple插件&#xA;    o-&amp;gt;&#xA;    fis.config.set(&#39;roadmap.path&#39;, [{&#xA;            reg: &#39;**.css&#39;,&#xA;            useSprite: true&#xA;    }]);                # 为所有样式资源开启csssprites, 该插件在fis中内置&#xA;    fis.config.set(&#39;settings.spriter.csssprites.margin&#39;, 20);                # 设置图片合并间距&#xA;                                                    ## 要在要合并的图片引用路径后面加?__sprite来标识&#xA;                                                    ## 被合并图片中的小图, background-position来分图的情况也支持&#xA;组件&#xA;    yogurt&#xA;        基于express 的nodejs框架&#xA;    fis-plus&#xA;        fis + php + smarty&#xA;    gois&#xA;        fis + go + margini&#xA;    jello&#xA;        fis + java + velocity&#xA;    pure&#xA;        纯前端框架&#xA;&#xA;插件&#xA;    fis-postpackager-simple&#xA;        介绍&#xA;                fis-plus和yogurt不需要&#xA;        安装&#xA;                npm install -g fis-postpackager-simple&#xA;        配置&#xA;                // fis-conf.js&#xA;                fis.config.set(&#39;modules.postpackager&#39;, &#39;simple&#39;);                        # 打包时自动更改静态资源引用&#xA;                fis.config.set(&#39;settings.postpackager.simple.autoCombine&#39;, true)        # 开启按页面自动合并css, js文件&#xA;    fis-parser-less&#xA;        介绍&#xA;                less模板&#xA;                npm install -g fis-parser-less&#xA;        配置&#xA;                fis.config.set(&#39;modules.parser.less&#39;, &#39;less&#39;);&#xA;                        # &#39;modules.parser.less&#39;表示后缀名less的文件，&#39;less&#39;表示用fis-parser-less编译&#xA;                fis.config.set(&#39;roadmap.ext.less&#39;, css)&#xA;                        # 将less文件编译为css&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;写法&#34;&gt;&#xA;  写法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%99%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;jquery&#xA;prototype&#xA;    $()     # 简写document.getElementById()&#xA;    $F()    # 返回表单&#xA;    $A()    # 参数转成数组对象&#xA;mootools&#xA;    # 浏览器原生对象扩展&#xA;underscore&#xA;    # 函数式&#xA;underscore-contrib&#xA;    # 扩展underscore&#xA;ramda&#xA;    # 函数式，较正确&#xA;lodash&#xA;    # 函数式&#xA;functional javascript&#xA;bilby&#xA;    # 函数式库，包含dispatch, 蹦床, monadic, validator等&#xA;allong.es&#xA;    # 提供函数组合子&#xA;sweet&#xA;    # 支持宏&#xA;zepto&#xA;    # 小型jquery&#xA;kissy&#xA;    # 小型jquery&#xA;rxjs&#xA;    # 微软开发，将异步流捕获成值的库&#xA;tangram&#xA;    # 百度前端工具集&#xA;qwrap&#xA;    # 360前端工具集&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;解释器&#34;&gt;&#xA;  解释器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%87%8a%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;typescript&#xA;    # 扩展语言&#xA;coffeescript&#xA;    # 扩展语言&#xA;system.js&#xA;    介绍&#xA;        一个垫片库, 浏览器端l加载es6模块、AMD模块、CommonJS模块 到es5。内部调用traceur&#xA;&#xA;    &amp;lt;script src=&#39;system.js&#39;&amp;gt;&amp;lt;/script&amp;gt;&#xA;    &amp;lt;script&amp;gt;&#xA;        System.import(&#39;./app&#39;).then(function(m) {&#xA;            # app.js是一个es6模块&#xA;            m.f()&#xA;        })&#xA;    &amp;lt;/script&amp;gt;&#xA;traceur&#xA;    介绍&#xA;        在线转换，将ES6代码编译为ES5&#xA;    使用&#xA;        npm install -g traceur&#xA;        traceur /path/es6                                # 运行ES6文件&#xA;        traceur --script /path/es6 --out /path/es5        # 转换&#xA;babel&#xA;    使用&#xA;        npm install -g babel-cli&#xA;        npm install --save babel-core babel-preset-es2015&#xA;        // .babelrc&#xA;        {&#xA;            &amp;quot;presets&amp;quot;: [&amp;quot;es2015&amp;quot;],&#xA;            &amp;quot;env&amp;quot;: {&#xA;                &amp;quot;dev&amp;quot;: {&#xA;                    # 在NODE_ENV=dev时使用特性&#xA;                    &amp;quot;presets&amp;quot;: [&amp;quot;react-hmre&amp;quot;]&#xA;                }&#xA;            }&#xA;        }&#xA;        babel-node&#xA;        babel es6.js&#xA;            # babel es6.js -o es5.js&#xA;            # babel -d build source -s&#xA;            ## -s 是产生source-map&#xA;    插件&#xA;        babel-preset-react-hmre&#xA;            # react热加载&#xA;            .babelrc中配置 &amp;quot;react-hmre&amp;quot;&#xA;transpiler&#xA;    介绍&#xA;        google的es6模块加载转为CommonJS或AMD模块加载的工具&#xA;    使用&#xA;        npm install -g es6-module-transpiler&#xA;        compile-modules convert es6.js es5.js&#xA;            # compile-modules convert -o out.js file1.js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据绑定&#34;&gt;&#xA;  数据绑定&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%91%e5%ae%9a&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;mobx&#xA;    # 状态管理，应用(ui, 数据, 服务器)状态可自动获得&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;终端&#34;&gt;&#xA;  终端&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%88%e7%ab%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;跨平台&#34;&gt;&#xA;  跨平台&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b7%a8%e5%b9%b3%e5%8f%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;atom electron&#xA;node-webkit&#xA;atom-shell&#xA;nw.js&#xA;polymer&#xA;    # 构建在底层的html扩展，构建跨desktop, mobile等平台的web应用&#xA;mpx&#xA;    # 小程序框架&#xA;wepy&#xA;    # 小程序&#xA;taro&#xA;    # 生成多端&#xA;chameleon&#xA;uniapp&#xA;    # vue到多端&#xA;mpvue&#xA;    # vue小程序&#xA;megalo&#xA;    # vue小程序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;运行时跨平台&#34;&gt;&#xA;  运行时跨平台&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e8%b7%a8%e5%b9%b3%e5%8f%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;微信小程序&#xA;华为快应用&#xA;react native&#xA;rax&#xA;weex&#xA;fuse&#xA;nativeScript&#xA;tabris&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;android&#34;&gt;&#xA;  android&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#android&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;结构&#xA;    applications:                                                        如browser&#xA;    application framework(相当于api):                        如window manager&#xA;    libraries(库):                                                        如openGL,SQLite&#xA;            runtime(运行环境):                                                core libraries + Dalvik VM&#xA;    linux kernel(系统api):                                        如wifi Driver&#xA;android sdk&#xA;    命令&#xA;        platform-tools/adb&#xA;            adb install *.apk                                      # 当前模拟器中安&#xA;    装软件&#xA;&#xA;            adb remount&#xA;            adb shell&#xA;            su                                                      # 当前模拟器中执&#xA;    行linux命令&#xA;&#xA;        tools/emulator-arm @test                                    # 启动一个模拟器&#xA;框架&#xA;    atlas&#xA;        # 阿里开源的android native容器化组件框架&#xA;    webview&#xA;    litho&#xA;        # 声明式ui&#xA;    jetpack compose&#xA;        # 声明式ui&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;ios&#34;&gt;&#xA;  ios&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ios&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;componentKit&#xA;    # 声明式ui&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;功能&#34;&gt;&#xA;  功能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%9f%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;格式&#34;&gt;&#xA;  格式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%bc%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uglifyjs2&#xA;    # 序列化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模板&#34;&gt;&#xA;  模板&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e6%9d%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    引擎的一个优点就是可以直接把数据渲染到js中使用&#xA;优点&#xA;    可以把动态页面的模板缓存起来，第一次请求之后，只需要更新数据&#xA;        # 应该可以后端nginx缓存静态模板来提高性能&#xA;&#xA;velocity&#xA;    # java模板&#xA;ejs&#xA;hogan.js&#xA;handlebars&#xA;    # 写法类似anglarjs模板&#xA;jstl&#xA;    # java模板&#xA;less&#xA;    # css模板&#xA;stylus&#xA;    # css模板&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;swig&#34;&gt;&#xA;  swig&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#swig&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;{% autoescape true %} {{ myvar }} {% endautoescape %}&#xA;&#xA;{% block body %} ... {% endblock %}&#xA;&#xA;{% if false %}&#xA;{% elseif true%}&#xA;{% else %}&#xA;{% endif %}&#xA;&#xA;{% extends &amp;quot;./layout.html&amp;quot; %}&#xA;&#xA;{% filter uppercase %} oh hi, {{ name }} {% endfilter %}                # =&amp;gt; OH HI, PAUL&#xA;{% filter replace(&amp;quot;.&amp;quot;, &amp;quot;!&amp;quot;, &#39;g&amp;quot;) %} Hi. My name is Paul. {% endfilter %}        # =&amp;gt; Hi! My name is Paul!&#xA;&#xA;{% for x in obj %}&#xA;        {% if loop.first %}&amp;lt;ul&amp;gt;{% endif %}&#xA;        &amp;lt;li&amp;gt;{{ loop.index }} - {{ loop.key }}: {{ x }}&amp;lt;/li&amp;gt;&#xA;        {% if loop.last %}&amp;lt;/ul&amp;gt;{% endif %}&#xA;{% endfor %}&#xA;{% for key, val in arr|reverse %}&#xA;{{ key }} -- {{ val }}&#xA;{% endfor %}&#xA;&#xA;{% import &#39;./formmacros.html&#39; as forms %}&#xA;{{ form.input(&amp;quot;text&amp;quot;, &amp;quot;name&amp;quot;) }}                        # =&amp;gt; &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot;&amp;gt;&#xA;{% import &amp;quot;../shared/tags.html&amp;quot; as tags%}&#xA;{{ tags.stylesheet(&#39;global&#39;)}}                        // =&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/global.css&amp;quot;&amp;gt;&#xA;&#xA;{% include &amp;quot;./partial.html&amp;quot; %}&#xA;{% include &amp;quot;./partial.html&amp;quot; with my_obj only%}&#xA;{% include &amp;quot;/this/file/does/not/exist&amp;quot; ignore missing%}&#xA;&#xA;{% macro input(type, name, id, label, value, error)%}&#xA;        &amp;lt;label for=&amp;quot;{{ name }}&amp;quot;&amp;gt;{{ label }}&amp;lt;/label&amp;gt;&#xA;        &amp;lt;input type=&amp;quot;{{ type }}&amp;quot; name=&amp;quot;{{ name }}&amp;quot; id=&amp;quot;{{ id }}&amp;quot; value=&amp;quot;{{ value }}&amp;quot; {% if error%} class=&amp;quot;error&amp;quot; {% endif %}&amp;gt;&#xA;{% endmacro %}&#xA;{{ input(&amp;quot;text&amp;quot;, &amp;quot;fname&amp;quot;,  &amp;quot;fname&amp;quot;, &amp;quot;First Name&amp;quot;, fname.value, fname.errors) }}&#xA;&#xA;{% extends &amp;quot;./foo.html&amp;quot; %}&#xA;{% block content %}&#xA;        My content&#xA;        {% parent %}&#xA;{% endblock %}&#xA;&#xA;{% raw %}{{ foobar }}{% endraw %}&#xA;&#xA;{% set foo = &amp;quot;anything!&amp;quot;%}&#xA;{{ foo }}&#xA;&#xA;{% spaceless %}&#xA;        {% for num in foo %}&#xA;        &amp;lt;li&amp;gt;{{ loop.index }}&amp;lt;/li&amp;gt;&#xA;        {% endfor %}&#xA;{% endspaceless %}                                # 除去空白&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;显示&#34;&gt;&#xA;  显示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%be%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;highcharts&#xA;nvd3.js&#xA;    # svg报表&#xA;echarts&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;d3&#34;&gt;&#xA;  d3&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#d3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    数据可视化, 使用svg, css3&#xA;使用&#xA;    node&#xA;        npm install d3&#xA;        //&#xA;        var d3 = require(&#39;d3&#39;), jsdom = require(&#39;jsdom&#39;);&#xA;        var document = jsdom.jsdom(),&#xA;            svg = d3.select(document.body).append(&#39;svg&#39;);&#xA;    web&#xA;        &amp;lt;script src=&amp;quot;//d3js.org/d3.v3.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;        &amp;lt;script&amp;gt;d3.version&amp;lt;/script&amp;gt;&#xA;d3对象&#xA;    // 选择器&#xA;    event&#xA;    mouse&#xA;    select&#xA;    selectAll&#xA;    selection&#xA;    touch&#xA;    touches&#xA;    // 过渡&#xA;    ease&#xA;            # ease对象&#xA;    timer&#xA;            flush&#xA;    interpolate&#xA;            # interpolate对象&#xA;    interpolateArray&#xA;    interpolateHcl&#xA;    interpolateHsl&#xA;    interpolateLab&#xA;    interpolateNumber&#xA;    interpolateObject&#xA;    interpolateRgb&#xA;    interpolateRound&#xA;    interpolateString&#xA;    interpolateTransform&#xA;    interpolateZoom&#xA;    interpolators&#xA;    transition&#xA;    // 数组&#xA;    ascending&#xA;    bisectLeft&#xA;    bisector&#xA;    bisectRight&#xA;    bisect&#xA;    descending&#xA;    deviation&#xA;    entries&#xA;    extent&#xA;    keys&#xA;    map&#xA;    max&#xA;    mean&#xA;    median&#xA;    merge&#xA;    min&#xA;    nest&#xA;    pairs&#xA;    permute&#xA;    quantile&#xA;    range&#xA;    set&#xA;    shuffle&#xA;    sum&#xA;    transpose&#xA;    values&#xA;    variance&#xA;    zip&#xA;    // 数学&#xA;    random&#xA;    transform&#xA;    // 请求&#xA;    csv&#xA;    html&#xA;    json&#xA;    text&#xA;    tsv&#xA;    xhr&#xA;    xml&#xA;    // 格式化&#xA;    format&#xA;    formatPrefix&#xA;    requote&#xA;    round&#xA;    // 本地化&#xA;    locale&#xA;    // 颜色&#xA;    hcl&#xA;    hsl&#xA;    lab&#xA;    rgb&#xA;    // 命名空间&#xA;    ns&#xA;    // 内部&#xA;    dispatch&#xA;    functor&#xA;    rebind&#xA;    // 比例尺&#xA;    scale&#xA;    // 时间&#xA;    time&#xA;    // 布局&#xA;    layout&#xA;    // 地理&#xA;    geo&#xA;    // 几何&#xA;    geom&#xA;    // 行为&#xA;    behavior&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;效果&#34;&gt;&#xA;  效果&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%88%e6%9e%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;touch.js&#xA;    # 触摸&#xA;move.js&#xA;    # div运动&#xA;swiper&#xA;    # 滑动效果&#xA;&#xA;cordova&#xA;    # 访问原生设备，如摄像头、麦克风等&#xA;egret.js&#xA;    # 使用TypeScript的HTML5开发引擎, 一套完整的HTML5游戏开发解决方案&#xA;tweenMax&#xA;    # 扩展TweenLite, 用于制作html5动画&#xA;juliusjs&#xA;    # 语音识别&#xA;babylon&#xA;    # microsoft webgl框架&#xA;cubicVR&#xA;    # 高性能webgl框架, paladin游戏引擎的一部分&#xA;scenejs&#xA;    # webgl模型&#xA;glge&#xA;    # webgl框架&#xA;pose&#xA;    # mvvm&#xA;react-motion&#xA;    # mvvm&#xA;react-transition-group&#xA;    # mvvm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;视频&#34;&gt;&#xA;  视频&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%86%e9%a2%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ezuikit&#xA;    # 萤石sdk, 直播, 监控, 支持多平台&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;应用框架&#34;&gt;&#xA;  应用框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;显示-1&#34;&gt;&#xA;  显示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%be%e7%a4%ba-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;bootstrap&#xA;flutter&#xA;    # google移动端框架, 声明式ui&#xA;extjs&#xA;    介绍&#xA;        2.0之前是免费的，但有内在泄漏总是&#xA;        GPLv3版本后收费&#xA;&#xA;    Sencha&#xA;        1.是ExtJS、jQTouch(一个用于手机浏览器的jquery插件) 以及 Raphael（一个网页上绘制矢量图形的js库） 三个项目合并而成的一个开源项目。&#xA;        2.Sencha Touch 是全球领先的应用程序开发框架，其设计旨在充分&#xA;            利用HTML5、CSS3 和Javascript 来实现最高级别的功能、灵活性和优化。&#xA;            Sencha Touch 是针对下一代具有触摸屏设备的跨平台框架。&#xA;jquery ui&#xA;dojo&#xA;    # 语法较难用&#xA;easy ui&#xA;    文件&#xA;        jquery.js&#xA;        easyui.js&#xA;        easyui-lang-zh_CN.js&#xA;        easyui.css&#xA;        icon.css&#xA;layui&#xA;    # 模块化ui&#xA;mini ui&#xA;    # 收费&#xA;wijmo&#xA;    # 收费&#xA;dwz&#xA;    # 卖文档&#xA;vaadin&#xA;    # apache webkit&#xA;foundation&#xA;    # 响应式，移动优先&#xA;boilerplate&#xA;    # h5模板&#xA;meteor&#xA;    # 融合前后端, 后端node&#xA;knockout&#xA;    # mvvm, 利于单页应用&#xA;&#xA;jingle&#xA;    # 手机&#xA;ionic&#xA;    # angular手机框架&#xA;framework7&#xA;    # ios(兼容android)组件&#xA;mui&#xA;    # 手机&#xA;zui&#xA;    # 手机，类bootstrap&#xA;frozenui&#xA;    # 手机&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数据可视化&#34;&gt;&#xA;  数据可视化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%8f%af%e8%a7%86%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;highcharts&#xA;chart.js&#xA;    # api不好用&#xA;three.js&#xA;d3&#xA;    # 太底层, 概念已陈旧&#xA;mapbox&#xA;    # 地图&#xA;echarts&#xA;    # 开源&#xA;recharts&#xA;    # 新出现&#xA;v-charts&#xA;    # vue+echarts, 饿了么开发&#xA;superset&#xA;    # apache&#xA;antv&#xA;    # 蚂蚁金服, 图表丰富&#xA;thingJS&#xA;    # 3d建模&#xA;cityBuilder&#xA;    # 3d建模&#xA;dataV&#xA;    # 收费, 阿里&#xA;sugar&#xA;    # 收费, 百度&#xA;云图&#xA;    # 收费, 腾讯&#xA;fineReport&#xA;    # 收费, 帆软, 大屏&#xA;tableau&#xA;    # 收费, 大屏&#xA;easyV&#xA;    # 收费, 袋鼠云&#xA;&#xA;gitDataV&#xA;    # https://github.com/HongqingCao/GitDataV&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;富应用&#34;&gt;&#xA;  富应用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%8c%e5%ba%94%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;react&#xA;angular&#xA;    # google开发, mvvm&#xA;    ng(core module)包含的核心组件&#xA;        directive   # 指令&#xA;            ngClick&#xA;            ngInclude&#xA;            ngRepeat&#xA;        service     # 服务, 依赖注入后使用&#xA;            $compile&#xA;            $http&#xA;            $location&#xA;        filter      # 过滤器，转换模板数据&#xA;            filter&#xA;            date&#xA;            currency&#xA;            lowercase&#xA;        function    # 函数&#xA;            angular.copy()&#xA;            angular.equals()&#xA;            angular.element()&#xA;    组件&#xA;        ngRoute     # url后#地址(hash) 来实现单面路由&#xA;            使用&#xA;                引入angular-route.js&#xA;                依赖注入ngRoute模块&#xA;            服务&#xA;                $routeParams    # 解析路由参数&#xA;                $route          # 构建url, view, controller的关系&#xA;                $routeProvider  # 配置&#xA;            指令&#xA;                ngView      # 路由模板插入视图&#xA;        ngAnimate   # 动画效果&#xA;            使用&#xA;                引入angular-animate.js&#xA;                注入ngAnimate&#xA;            服务&#xA;                $animate    # 触发&#xA;            css动画   # 用nganimate结构定义，通过引用css到html模板触发&#xA;            js动画    # 用module.animation注册，通过引用css到html模板触发&#xA;        ngResource  # 动画&#xA;        ngMock      # 动画&#xA;        ngTouch     # 触摸&#xA;        ngAria      # 帮助制作自定义模块&#xA;        ngCookies&#xA;riot&#xA;ember&#xA;vue&#xA;    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&#xA;        {{ message }}&#xA;    &amp;lt;/div&amp;gt;&#xA;&#xA;    var app = new Vue({&#xA;        el: &#39;#app&#39;,&#xA;        data: {&#xA;            message: &amp;quot;hi&amp;quot;&#xA;        },&#xA;        created: function () {}&#xA;    })&#xA;backbone&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;效果-1&#34;&gt;&#xA;  效果&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%88%e6%9e%9c-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;three.js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;createjs&#34;&gt;&#xA;  createjs&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#createjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# easeljs&#xA;    介绍&#xA;        处理canvas&#xA;    使用&#xA;        var stage = new createjs.Stage(&amp;quot;canvasName&amp;quot;);&#xA;        stage.x = 100;&#xA;        stage.y = 100;&#xA;        var text = new createjs.Text(&amp;quot;Hello&amp;quot;, &amp;quot;36px Arial&amp;quot;, &amp;quot;#777&amp;quot;);&#xA;        stage.addChild(text);&#xA;        stage.update();&#xA;# tweenjs&#xA;    介绍&#xA;        处理动画调整和js属性&#xA;    使用&#xA;        var circle = new createjs.Shape();&#xA;        circle.graphics.beginFill(&amp;quot;#FF0000&amp;quot;).drawCircle(0, 0, 50);&#xA;        stage.addChild(circle);&#xA;        createjs.Tween.get(circle, {loop: true})&#xA;            .wait(1000)&#xA;            .to({scaleX: 0.2, scaleY: 0.2})&#xA;            .wait(1000)&#xA;            .to({scaleX:1, scaleY:1}, 1000, createjs.Ease.bounceInOut)&#xA;        createjs.Ticker.setFPS(20);&#xA;        createjs.Ticker.addEventListener(&amp;quot;tick&amp;quot;, stage);&#xA;# soundjs&#xA;    介绍&#xA;        简化处理音频&#xA;    使用&#xA;        var displayStatus;&#xA;        displayStatus = document.getElementById(&amp;quot;status&amp;quot;);&#xA;        var src = &amp;quot;1.mp3&amp;quot;;&#xA;        createjs.Sound.alternateExtensions = [&amp;quot;mp3&amp;quot;];&#xA;        createjs.Sound.addEventListener(&amp;quot;fileload&amp;quot;, playSound());&#xA;        createjs.Sound.registerSound(src);&#xA;        displayStatus.innerHTML = &amp;quot;Waiting for load to complete&amp;quot;;&#xA;&#xA;        function playSound(event){&#xA;            soundIntance = createjs.Sound.play(event.src);&#xA;            displayStatus.innerHTML = &amp;quot;Playing source: &amp;quot; + event.src;&#xA;        }&#xA;&#xA;# preloadjs&#xA;    介绍&#xA;        协调程序加载项的类库&#xA;    使用&#xA;        var preload = new createjs.LoadQueue(false, &amp;quot;assets/&amp;quot;);&#xA;        var plugin= {&#xA;            getPreloadHandlers: function(){&#xA;                return{&#xA;                    types: [&amp;quot;image&amp;quot;],&#xA;                    callback: function(src){&#xA;                        var id = src.toLowerCase().split(&amp;quot;/&amp;quot;).pop().split(&amp;quot;.&amp;quot;)[0];&#xA;                        var img = document.getElementById(id);&#xA;                        return {tag: img};&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;        preload.installPlugin(plugin);&#xA;        preload.loadManifest([&#xA;            &amp;quot;Autumn.png&amp;quot;,&#xA;            &amp;quot;BlueBird.png&amp;quot;,&#xA;            &amp;quot;Nepal.jpg&amp;quot;,&#xA;            &amp;quot;Texas.jpg&amp;quot;&#xA;        ]);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;游戏&#34;&gt;&#xA;  游戏&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b8%b8%e6%88%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;cocos2dx&#xA;    # 跨平台游戏&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>小功能</title>
      <link>https://ukeate.com/docs/middleware/library/</link>
      <pubDate>Wed, 10 Oct 2018 14:36:50 +0800</pubDate>
      <guid>https://ukeate.com/docs/middleware/library/</guid>
      <description>&lt;h1 id=&#34;名词&#34;&gt;&#xA;  名词&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8d%e8%af%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;dom                文档对象模型&#xA;dao                数据访问对象&#xA;ucs                unicode character set&#xA;utf                ucs Transformation Format&#xA;bmp                Basic Multilingual plane&#xA;bom                Byte Order Mark&#xA;asp                Active Server Pages&#xA;iis                Internet Information services&#xA;validate code                 验证码&#xA;tld                 tag library description&#xA;jsp                 java server page&#xA;xsd                XML Schemas Definition&#xA;suffix              后缀&#xA;ide                Integrated Development Environment&#xA;RIA                Rich internet Applications                富互联网应用（富客户端）C/S架构是胖客户端，B/S架构是瘦客户端。比如 flash就是ria(其它如js, SilverLight，unity3d，flash3d,adobe air,HTML5/css3，adobe Flex等)&#xA;JPA                Java Persistence API                        java持久层api&#xA;JDBC                Java DataBase Connectivity&#xA;DHTML                DynamicHTML&#xA;cvs                Concurrent Version System&#xA;svn                subversion&#xA;uml                UnifiedModelingLanguage&#xA;AJAX            Asynchronous JavaScript and XML&#xA;bnf                命令书写格式规范: 巴科斯范式&#xA;desc            description&#xA;capacity        容量&#xA;component       组件&#xA;association         联合&#xA;aggregation         聚合&#xA;composition         组合&#xA;alpha           开端&#xA;inherit         继承&#xA;dhtml           dynamic html ,是 html css 客户端script                        不是规范，是现有技术、标准的整合运用&#xA;css             Cascading Style Sheet   级联样式表&#xA;associated                交互的&#xA;perspective                视图&#xA;adapter         适配器&#xA;jit             just in time (compilation)&#xA;webdav          Web-based Distributed Authoring and Versioning        Web 分布式创作和版本管理 (WebDAV) 扩展了 HTTP/1.1 协议，允许客户端发布、锁定和管理 Web 上的资源&#xA;CMS             Content Management System        内容管理系统        它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。&#xA;constraint      约束&#xA;JSON            javascript object notation(标记)&#xA;OGNL            Object-Graph Navigation Language 对象图导航语言&#xA;jmf               java media frame java 媒体框架 是一个jar 包&#xA;dwr                Direct Web Remoting 是一个ajax框架。它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数，就像它就在浏览器里一样。&#xA;CXF                 apache的 Celtix + XFire,用于实现 web services的发布的使用&#xA;oa                Office Automation 办公自动化&#xA;dml                data manipulation language        数据操作语言&#xA;ddl                data definition language        数据定义语言&#xA;dcl                data control language                数据控制语言&#xA;ioc                inversion of control        控制反转（spring）&#xA;di                 dependence injection        依赖注入 （spring）&#xA;crud               增加(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete)&#xA;ssh                Secure Shell,由IETF制定，为建立在应用层和传输层基础上的安全协议。&#xA;pojo                pure old java object&#xA;oop                object oriented programming&#xA;aop                aspect oriented programming                面向切面编程&#xA;hdfs                Hierarchical Data Format        层次型资料格式（分布式存储）&#xA;ftp                File Transfer Protocol&#xA;ssl                Secure Sockets Layer 安全套接层。端口40&#xA;tls                Transport Layer Security 传输层安全(ssl的继任者)&#xA;https            Hypertext Transfer Protocol Secure 应用ssl作为应用层子层对数据进行压缩与解压。端口443&#xA;jsf                JavaServer Faces 是sun开发的web框架，相当于ssh(spring + struts + hibernate)&#xA;sns                Social Network Services        社会性网络服务&#xA;uml                Unified modeling language 统一建模语言&#xA;jta                java transaction api (hibernate中) java事务处理api&#xA;asm                Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。&#xA;                    汇编语言(Assembly Language)的扩展名&#xA;jsr                Java Specification Requests 是Java规范请求，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。jsr303:基于注解的java bean 验证&#xA;dto                data transfer object 数据传输对象&#xA;antlr             another tool for language recognition        一个开源的语法分析器&#xA;soap              simple object access protocol 简单对象访问协议&#xA;uefi              unified extensible firmware interface 统一可扩展固件接口&#xA;sso                single sign on 单点登录&#xA;erp                enterprise resource plan 企业资源计划&#xA;sap                Systems Applications and Products in Data Procession 企业系列软件(全世界排名第一的erp软件)&#xA;ssi                Server Side Include 服务器端嵌入&#xA;jmx                Java Management Extensions java管理扩展，是一个为应用程序、设备、系统等植入管理功能的框架。&#xA;jaas                Java Authentication Authorization Service Java验证和授权API&#xA;jca(J2C， J2CA)        Java Connector Architecture java连接器架构&#xA;jms                    Java Message Service java消息服务，用于在两个应用程序之间，或分布式系统中发送消息&#xA;jaf                    JavaBeans Activation Framework JAF是一个专用的数据处理框架，它用于封装数据，并为应用程序提供访问和操作数据的接口。JAF的主要作用在于让java应用程序知道如何对一个数据源进行查看、编辑和打印等操作。&#xA;jta                    Java Transaction API Java事务API,和jts为J2EE平台提供了分布式事务服务&#xA;jts                    Java Transaction Service java事务服务&#xA;scm                    Supply chain management 一种集成的管理思想和方法，执行供应商到最终用户的物流计划控制职能&#xA;ctr                    click-through-rate 网络广告&#xA;ioc/di                    inversion of control/ dependency injection&#xA;o2o                    online to offline 网站提供平台, 用户线下交易&#xA;cas                    central authentication service 单点登录&#xA;foobar                FTP Operation Over Big Address Records(RFC1545文档)ftp命令列表&#xA;modular              模块化&#xA;enumeration         计数&#xA;navigate            导航&#xA;fragment             碎片&#xA;posix                可移植的&#xA;intersection        截断&#xA;categories          类别&#xA;encounter           遭遇&#xA;recursion           递归&#xA;evaluate            评价&#xA;indent                缩进&#xA;collation         校对&#xA;schema              模式、图表&#xA;generate            生成&#xA;Presentation         描述&#xA;hierarchical         垂直分层&#xA;stereotype         策略&#xA;numerous            许多&#xA;KISS                keep it simple, stupid&#xA;cross-origin         跨域&#xA;CORS             Cross-Origin Resourse Sharing&#xA;NIH             not invented here 自己造轮子&#xA;mis                 management information system&#xA;crm                 customer relationship management&#xA;erp             enterprise resource planning&#xA;webRTC          web Real-Time Communication&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;库&#34;&gt;&#xA;  库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;日志&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;log4j&#xA;    # java&#xA;logback&#xA;    # log4j后续版本&#xA;slf4j&#xA;    # java&#xA;log4js&#xA;    # js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;格式模板&#34;&gt;&#xA;  格式|模板&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%bc%e5%bc%8f%e6%a8%a1%e6%9d%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;moment&#xA;    # js格式化时间&#xA;iconv&#xA;    # nodejs调用c++ libiconv库来转码&#xA;iconv-lite&#xA;    # nodejs实现的转码，比调用c++ 的iconv更高效&#xA;poi&#xA;    # java 文件处理&#xA;jFreeChart&#xA;    # java图表库&#xA;jackson&#xA;    # java json序列化&#xA;json-smart&#xA;    # java json&#xA;xstream&#xA;    # java xml序列化&#xA;pango2&#xA;    # 国际化模板&#xA;snakeyaml&#xA;    # java yaml&#xA;js-beautify&#xA;    # js, html格式化&#xA;xmlbeans&#xA;    # java xml&#xA;joda-time&#xA;    # java日期&#xA;dom4j&#xA;    # java dom &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;生成压缩加密计算特征&#34;&gt;&#xA;  生成|压缩|加密|计算特征&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90%e5%8e%8b%e7%bc%a9%e5%8a%a0%e5%af%86%e8%ae%a1%e7%ae%97%e7%89%b9%e5%be%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;simhash&#xA;    # google 文档hash&#xA;pygments&#xA;    # python 生成高亮html&#xA;mako&#xA;    # python 模板&#xA;jinja2&#xA;    # python 模板&#xA;freemarker&#xA;    # java 模板&#xA;proguard&#xA;    # java 混淆&#xA;snappy&#xA;    # google java 压缩&#xA;jbcrypt&#xA;    # java加密, scrypt更强&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;客户端邮件&#34;&gt;&#xA;  客户端|邮件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%a2%e6%88%b7%e7%ab%af%e9%82%ae%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;javamail&#xA;    # java mail&#xA;nodemailer&#xA;    # node mail&#xA;mailapi&#xA;    # java mail&#xA;c3p0&#xA;    # java rds 连接池&#xA;dbcp&#xA;    # java rds 连接池&#xA;druid&#xA;    # java rds 连接池。可监控sql执行性能，记sql日志&#xA;jdbc&#xA;    # java rds client&#xA;dbutil&#xA;hibernate&#xA;ef&#xA;    # .net orm&#xA;NHibernate&#xA;    # .net orm&#xA;peewee&#xA;    # python orm&#xA;node-mysql&#xA;mongoose&#xA;httpClient&#xA;    # java http&#xA;request&#xA;    # js http&#xA;superagent&#xA;    # js http&#xA;mybatis&#xA;hsqldb&#xA;    # java内置, 单文件/内存数据库&#xA;mqttv&#xA;    # java mqtt客户端&#xA;libthrift&#xA;    # java thrift&#xA;kafka-clients&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;领域语言&#34;&gt;&#xA;  领域语言&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%86%e5%9f%9f%e8%af%ad%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;lex&#xA;    # 生成词法分析程序&#xA;yacc&#xA;    # 生成自底向上语法分析程序&#xA;antlr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;图形&#34;&gt;&#xA;  图形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ccap&#xA;    # 基于c++的图形CImg库，就是一个CImg.h文件&#xA;canvas&#xA;    # node canvas&#xA;tesseract&#xA;    # node 验证码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;运维控制&#34;&gt;&#xA;  运维控制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e7%bb%b4%e6%8e%a7%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;later&#xA;    # nodejs corntab&#xA;glob&#xA;    # nodejs 匹配获得文件&#xA;rd&#xA;    # node 遍历文件&#xA;commander&#xA;    # node制作命令&#xA;mkdirp&#xA;    # node 递归makedir&#xA;fs-extra&#xA;    # node扩展fs包&#xA;testcontainers&#xA;    # java, 运行docker&#xA;jOptSimple&#xA;    # java, 命令解析&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;协议&#34;&gt;&#xA;  协议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;spring-websocket&#xA;    # java&#xA;httpcore-nio&#xA;    # java&#xA;grpc-context&#xA;    # java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;高可用--性能&#34;&gt;&#xA;  高可用 | 性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e5%8f%af%e7%94%a8--%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;retry&#xA;    # js retry&#xA;ehcache&#xA;    # 缓存&#xA;tagg&#xA;    # node线程池&#xA;cluster&#xA;    # node单机集群&#xA;fiber&#xA;    # node协程&#xA;driud&#xA;    # 连接池，阿里开源&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;akka&#34;&gt;&#xA;  akka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#akka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# scala并发、分布式、容错工具&#xA;使用&#xA;    system = ActorSystem.create(&amp;quot;hello&amp;quot;)&#xA;    system.actorOf() ## 前端 ### dwr&#xA;介绍&#xA;    java函数通过ajax映射到前端js调用&#xA;使用&#xA;    ajax框架&#xA;    1.导入jar包 dwr.jar&#xA;    2.web-inf/下的配置文件&#xA;        web.xml文件&#xA;            &amp;lt;servlet&amp;gt;&#xA;                &amp;lt;servlet-name&amp;gt;dwr-invoker&amp;lt;/servlet-name&amp;gt;&#xA;                &amp;lt;servlet-class&amp;gt;org.directwebremoting.servlet.DwrServlet&amp;lt;/servlet-class&amp;gt;&#xA;                        # 固定写法&#xA;                &amp;lt;init-param&amp;gt;&#xA;                        &amp;lt;param-name&amp;gt;debug&amp;lt;/param-name&amp;gt;&#xA;                        &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;&#xA;                &amp;lt;/init-param&amp;gt;&#xA;                &amp;lt;init-param&amp;gt;&#xA;                        &amp;lt;param-name&amp;gt;scriptCompressed&amp;lt;/param-name&amp;gt;        # 允许在javascript中执行&#xA;                        &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;&#xA;                &amp;lt;/init-param&amp;gt;&#xA;                &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;        # web工程启动时加载&#xA;            &amp;lt;/servlet&amp;gt;&#xA;            &amp;lt;servlet-mapping&amp;gt;&#xA;                &amp;lt;servlet-name&amp;gt;dwr-invoker&amp;lt;/servlet-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;/dwr/*&amp;lt;/url-pattern&amp;gt;&#xA;            &amp;lt;/servlet-mapping&amp;gt;&#xA;        dwr.xml文件&#xA;            &amp;lt;dwr&amp;gt;&#xA;                &amp;lt;allow&amp;gt;&#xA;                    &amp;lt;create creator=&amp;quot;new&amp;quot; javascript=&amp;quot;DWRUserAccess&amp;quot;&amp;gt;        # 生成js文件的名（页面中引用）&#xA;                            &amp;lt;param name=&amp;quot;class&amp;quot; value=&amp;quot;outrun.dwr.DWRUserAccess&amp;quot; /&amp;gt;                # 曝露的类&#xA;                    &amp;lt;/create&amp;gt;&#xA;                    &amp;lt;convert converter=&amp;quot;bean&amp;quot; match=&amp;quot;outrun.dwr.User&amp;quot; /&amp;gt;        # 注册实体类，可以在js中进行实例化&#xA;                &amp;lt;/allow&amp;gt;&#xA;            &amp;lt;/dwr&amp;gt;&#xA;    3.写outrun.dwr.DWRUserAccess中的方法&#xA;    4.页面调用&#xA;        test.html&#xA;            &amp;lt;script src=&amp;quot;/outrun/dwr/engine.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;            &amp;lt;script src=&amp;quot;/outrun/dwr/util.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;            &amp;lt;script src=&amp;quot;/outrun/dwr/interface/DWRUserAccess.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;            &amp;lt;SCRIPT LANGUAGE=&amp;quot;JavaScript&amp;quot;&amp;gt;&#xA;                DWRUserAccess.方法(参数,执行完运行的js函数)&#xA;                    # 参数可以是一个map,如&#xA;                        var userMap = {};&#xA;                        userMap.id = regForm.id.value;&#xA;                        userMap.password = regForm.password.value;&#xA;                        userMap.name = regForm.name.value;&#xA;                        userMap.email = regForm.email.value;&#xA;                        DWRUserAccess.save(userMap, saveFun);&#xA;                                # 其中的regForm是页面中的表单（的name属性,dom支持直接使用名字引用表单）&#xA;            &amp;lt;/SCRIPT&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;开发&#34;&gt;&#xA;  开发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;脚手架&#34;&gt;&#xA;  脚手架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%84%9a%e6%89%8b%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spring-boot&#34;&gt;&#xA;  spring boot&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;drapwizard&#34;&gt;&#xA;  drapWizard&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#drapwizard&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# java，类spring boot&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;写法&#34;&gt;&#xA;  写法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%99%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;traits-decorator&#xA;    # js mixin&#xA;q&#xA;    # js 流程控制&#xA;co&#xA;    # js generator to async&#xA;async&#xA;    # js 流程控制&#xA;thunkify&#xA;    # js函数Thunk化, 确保回调调用一次&#xA;step&#xA;    # async轻量库&#xA;wind&#xA;    # js定义的宏&#xA;streamline&#xA;    # 基于源代码编译来实现流程控制简化&#xA;eventproxy&#xA;    # js event回调&#xA;spring&#xA;    # java ioc&#xA;guice&#xA;# google的java ioc轻量框架&#xA;castle&#xA;    # .net ioc&#xA;spring.net&#xA;    # .net ioc&#xA;anko&#xA;    # go 代码解释器&#xA;antlr&#xA;    # java dsl&#xA;aopalliance&#xA;    # java aop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;ejb&#34;&gt;&#xA;  ejb&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ejb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    分布式，j2ee一部分&#xA;&#xA;组成&#xA;    会话bean(session)&#xA;    实体bean(entity)&#xA;    消息驱动bean(message driven)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;语言增强&#34;&gt;&#xA;  语言增强&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e8%a8%80%e5%a2%9e%e5%bc%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;guava&#34;&gt;&#xA;  guava&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#guava&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# google工具集&#xA;maven&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;组件&#xA;    o-&amp;gt; 增强&#xA;    Optional                            # null处理&#xA;    Preconditions                       # 准入检查&#xA;    Ordering&#xA;    Throwables&#xA;&#xA;    o-&amp;gt; 集合&#xA;    Multiset                            # 存重复元素&#xA;    Multimap                            # 多值&#xA;    BiMap                               # 双向映射&#xA;    Table                               # 两键一值&#xA;    Range                               # 连续值&#xA;    &#xA;    o-&amp;gt; 字符串&#xA;    Joiner&#xA;    Spilter&#xA;    CharMatcher&#xA;    CaseFormat&#xA;&#xA;    o-&amp;gt; 类型&#xA;    Objects&#xA;    Bytes&#xA;    Shorts&#xA;    Ints&#xA;    Longs&#xA;    Floats&#xA;    Doubles&#xA;    Chars&#xA;    Booleans&#xA;&#xA;    o-&amp;gt; 数学&#xA;    IntMath&#xA;    LongMath&#xA;    BigIntegerMath&#xA;&#xA;    o-&amp;gt; 高可用&#xA;    LoadingCache                        # 堆内缓存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;接口&#34;&gt;&#xA;  接口&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;luavit&#xA;    # lua实现, 类node&#xA;scotty&#xA;    # haskell&#xA;webapi&#xA;    # .net&#xA;meteor.js&#xA;    # 基于node.js + mongodb的网站开发平台，把这个基础构架延伸到浏览器端, 本地和远程数据通过DDP(Distributed Data Protocol)协议传输&#xA;restify&#xA;    # 基于nodejs的rest应用框架，去掉express中的 template, render等功能, 提供DTrace功能，方便调试&#xA;ssh&#xA;    # java&#xA;spring site&#xA;    # spring整合&#xA;tapestry&#xA;    # 基于servlet的mvc框架&#xA;jersey&#xA;    # java restful服务&#xA;naga&#xA;    # java nio&#xA;echo&#xA;    # go&#xA;beego&#xA;    # go&#xA;gorilla&#xA;    # go&#xA;gin&#xA;    # go，类express&#xA;iris&#xA;    # go, fasthttp的一种实现&#xA;tornado&#xA;    # python nio&#xA;web.py&#xA;twisted&#xA;    # event driven&#xA;flask&#xA;django&#xA;bottle&#xA;    # python wsgi&#xA;rails&#xA;    # ruby的web mvc开发框架&#xA;ror&#xA;    # ror(ruby on rails)&#xA;sinatra&#xA;    # 微型web&#xA;grape&#xA;    # 运行在rack或rails/sinatra配合使用的restful风格的ruby微框架&#xA;yii&#xA;    # php&#xA;laravel&#xA;    # php&#xA;codelgniter&#xA;    # php&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;restful&#34;&gt;&#xA;  RESTful&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#restful&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;connect&#34;&gt;&#xA;  connect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#connect&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    nodejs处理http中req、res的中间件框架&#xA;    中间件分类&#xA;        pre-request用来改写request原始数据&#xA;        request/response功能各异&#xA;        post-response全局异常处理，改写response数据等&#xA;内置中间件介绍&#xA;    logger&#xA;    csrf&#xA;    compress             # gzip压缩&#xA;    basicAuth            # basic认证&#xA;    body parser          # 请求内容解析&#xA;    json&#xA;    urlencoded           # application/x-www-form-urlencode请求解析&#xA;    multipart            # multipart/form-data请求解析&#xA;    timeout&#xA;    cookieParser&#xA;    session&#xA;    cookieSession&#xA;    methodOverride       # http伪造&#xA;    responseTime         # 计算响应时间&#xA;    staticCache          # 缓存&#xA;    directory            # 目录列表&#xA;    vhost                # 虚拟二级域名映射&#xA;    favicon&#xA;    limit                # 请求内容大小限制&#xA;    query                # url解析&#xA;    errorHandler         # 错误处理&#xA;使用&#xA;    var connect = require(&#39;connect&#39;);&#xA;    var app = connect()&#xA;        .use(connect.logger(&#39;dev&#39;))&#xA;        .use(function(req, res){&#xA;            res.end(&#39;hello world\n&#39;);&#xA;        })&#xA;        .listen(3000);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;express&#34;&gt;&#xA;  express&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#express&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;安装&#xA;    npm install -g express-generator&#xA;    npm install express -d                        # g代表安装到NODE_PATH的lib里面, d代表关联套件一起安装&#xA;cookie-parser&#xA;    使用&#xA;        var cookieParser = require(&#39;cookie-parser&#39;);&#xA;        app.use(cookieParser());&#xA;&#xA;        JSON.stringify(req.cookies);&#xA;        req.cookies.yourCookie&#xA;cookie-session&#xA;    使用&#xA;        var cookieSession = require(&#39;cookie-session&#39;);&#xA;        app.use(cookieSession())&#xA;        req.session = null&#xA;&#xA;express-session&#xA;    options可选参数&#xA;        name                        # 表示cookie中保存session的字段名称，默认为connect.sid&#xA;        store                        # session的存储方式，默认存放在内存中，也有redis、mongodb、等模块支持&#xA;        secret                        # 设置secrect来计算hash放在cookie中产生signedCookie，来防篡改&#xA;        genid                        # 规定产生一个新的session_id时所用的函数，默认用uid2这个包&#xA;        rolling                        # 每个请求都重新设置一个cookie，默认为false&#xA;        resave                        # 即使session没有被修改，也保存session的值&#xA;    使用&#xA;        var session = require(&#39;express-session&#39;);&#xA;        app.use(session(options));&#xA;&#xA;connect-redis&#xA;    使用&#xA;        var express = require(&#39;express&#39;);&#xA;        var session = require(&#39;express-session&#39;);&#xA;        var redisStore = require(&#39;connect-redis&#39;)(session);&#xA;&#xA;        app.use(session({&#xA;            store: new redisStore(),&#xA;            secret: &#39;somesecrettoken&#39;&#xA;        }));&#xA;serve-static&#xA;    # 静态文件&#xA;passport&#xA;    介绍&#xA;        登录验证中间件&#xA;        支持connect express sails等web框架&#xA;        支持Basic, Digest, OAuth(1.0和2.0的三种实现), Bearer等&#xA;    安装&#xA;        npm i passport&#xA;        npm i passport-local&#xA;    o-&amp;gt; 配置&#xA;    var express = require(&#39;express&#39;);&#xA;    var cookieParser = require(&#39;cookie-parser&#39;);&#xA;    var session = require(&#39;express-session&#39;);&#xA;    var flash = require(&#39;express-flash&#39;);&#xA;    var passport = require(&#39;passport&#39;);&#xA;&#xA;    ...&#xA;&#xA;    app.use(cookieParser());&#xA;    app.use(session({...}));&#xA;    app.use(passport.initialize());&#xA;    app.use(passport.session());&#xA;    app.use(flash())&#xA;&#xA;    passport.serializeUser(function (user, done) {&#xA;            done(null, user.id)&#xA;    })&#xA;    passport.deserializeUser(function (id, done) {&#xA;            User.findById(id, function (err, user) {&#xA;                    done(err, user)&#xA;            })&#xA;    })&#xA;&#xA;    app.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;, {&#xA;            # passport.authenticate是个登录中间件，通过就走后面回调，否则返回401&#xA;            # local是自定义的名称&#xA;            successRedirect: &#39;/&#39;,&#xA;            failureRedirect: &#39;/login&#39;,&#xA;            failureFlash: true,&#xA;    }, function (req, res) {&#xA;            res.redirect(&#39;/users/&#39; + req.user.username)&#xA;    }))&#xA;&#xA;    app.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;, function(err, user, info) {&#xA;            if (err) return next(err)&#xA;            if (!user) {&#xA;                    req.flash(&#39;errors&#39;, {msg: info.message})&#xA;                    return res.redirect(&#39;/login&#39;)&#xA;            }&#xA;            req.logIn(user, function (err) {})&#xA;    })(req, res, next))&#xA;    app.get(&#39;/logout&#39;, function(req, res) {&#xA;            req.logout()&#xA;            res.redirect(&#39;/&#39;)&#xA;    })&#xA;    app.get(&#39;/user&#39;, isAuthenticated, getUser)&#xA;    var isAuthenticated = function (req, res, next) {&#xA;            if (req.isAuthenticated()) {&#xA;                    return next()&#xA;            }&#xA;            res.redirect(&#39;/login&#39;)&#xA;    }&#xA;&#xA;&#xA;    o-&amp;gt; local验证&#xA;    var LocalStrategy = require(&#39;passport-local&#39;).Strategy&#xA;    passport.use(new LocalStrategy(&#xA;            function(username, password, done) {&#xA;                    User.findOne({username: username}, function(err, user) {&#xA;                            if (err) {return done (err)}&#xA;                            if (!user) {return done(null, false, {message: &#39;no user&#39;})}&#xA;                            if (!user.validPassword(password)) {...}&#xA;                            return done(null, user)&#xA;                    })&#xA;            }&#xA;    ))&#xA;&#xA;    o-&amp;gt; usernameField&#xA;    passport.use(new LocalStrategy({&#xA;            usernameField: &#39;email&#39;,&#xA;            passwordField: &#39;passwd&#39;&#xA;    }, function (username, password, done) {...}&#xA;    ))&#xA;&#xA;    o-&amp;gt; OAuth&#xA;    介绍&#xA;        第三方登录协议&#xA;        三个步骤&#xA;            1. 获取未授权的request token&#xA;            2. 获取用户授权的request token&#xA;            3. 用授权的request token换取access token&#xA;    使用&#xA;        网页上申请开发github应用&#xA;        npm install passport-github&#xA;            # 安装passport的github扩展&#xA;        // app.js&#xA;        passport.use(new GithubStrategy({        // 增加github认证策略&#xA;            clientID: &#39;XXXX&#39;,&#xA;            clientSecret: &#39;YYYY&#39;,        // 已从github上申请&#xA;            callbackURL: &#39;http://localhost:3000/auth/github/callback&#39;&#xA;        }, function(accessToken, refreshToken, profile, done){&#xA;            done(null, profile);&#xA;        }));&#xA;        // 定义路由&#xA;        app.all(&#39;/github&#39;, isLoggedIn);&#xA;        app.get(&#39;/github&#39;, user.github);&#xA;        app.get(&#39;/auth/github&#39;, passport.authenticate(&#39;github&#39;, {scope: &#39;email&#39;}));&#xA;        app.get(&#39;/auth/github/callback&#39;, passport.authenticate(&#39;github&#39;, {&#xA;            successRedirect: &#39;/github&#39;,&#xA;            failureRedirect: &#39;/&#39;&#xA;        }));&#xA;kraken&#xA;    介绍&#xA;        基于express之上的基于设置结构化代码工具&#xA;    功能&#xA;        post请求_csrf验证&#xA;&#xA;    基本用法&#xA;        &#39;use strict&#39;&#xA;        var express = require(&#39;express&#39;),&#xA;            kraken = require(&#39;kraken-js&#39;);&#xA;        var app = express();&#xA;        app.use(kraken());&#xA;        app.listen(8000);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;koa&#34;&gt;&#xA;  koa&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#koa&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    express原班人马打造的，更小，更健壮，更有表现力的web框架&#xA;    免除重复繁琐的回调函数嵌套，提高错误处理效率&#xA;    不绑定任何中间件，只是提供一个轻量优雅的函数库&#xA;    &amp;gt;=node0.11.16&#xA;配置&#xA;    app.name              # 应用名称&#xA;    app.env                  # 执行环境，默认是NODE_ENV 或 &#39;development&#39;&#xA;    app.proxy              # 决定哪些proxy header被加到信任列表中&#xA;    app.subdomainOffset      # 被忽略的.subdomains列表&#xA;    app.jsonSpaces          # 输出json时是否填充空格&#xA;    app.outputErrors        # 是否输出错误堆栈(err.stack)到stderr(app.env是&#39;test&#39;时，此值为false)&#xA;&#xA;使用&#xA;    $ npm install koa&#xA;    $ node --harmony app.js                        # 必需使用harmony模式运行程序&#xA;    var koa = require(&#39;koa&#39;);&#xA;    var app = koa();&#xA;    app.use(function *(){&#xA;        this.body = &#39;Hello World&#39;;&#xA;    });        # function*  声明的generator function支持yield&#xA;               ## yield是ES6定义的新语法&#xA;    app.listen(3000);&#xA;使用(downstream &amp;amp; upstream)&#xA;    var koa = require(&#39;koa&#39;);&#xA;    var app = koa();&#xA;&#xA;    // x-response-time&#xA;    app.use(function *(next){&#xA;    // (1) 进入路由&#xA;    var start = new Date;&#xA;    yield next;&#xA;    // (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间&#xA;    var ms = new Date - start;&#xA;    this.set(&#39;X-Response-Time&#39;, ms + &#39;ms&#39;);&#xA;    // (6) 返回 this.body&#xA;    });&#xA;&#xA;    // logger&#xA;    app.use(function *(next){&#xA;    // (2) 进入 logger 中间件&#xA;    var start = new Date;&#xA;    yield next;&#xA;    // (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间&#xA;    var ms = new Date - start;&#xA;    console.log(&#39;%s %s - %s&#39;, this.method, this.url, ms);&#xA;    });&#xA;&#xA;    // response&#xA;    app.use(function *(){&#xA;    // (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream&#xA;    this.body = &#39;Hello World&#39;;&#xA;    });&#xA;&#xA;    app.listen(3000);&#xA;&#xA;    this&#xA;        request&#xA;            header&#xA;            headers&#xA;            url&#xA;            accepts&#xA;        response&#xA;            header&#xA;            headers&#xA;            status&#xA;        cookies&#xA;            set(&#39;name&#39;, &#39;tobi&#39;, {signed: true})&#xA;                signed&#xA;                expires&#xA;                path&#xA;                domain&#xA;                secure&#xA;                httpOnly&#xA;            get&#xA;        type&#xA;        length&#xA;        path&#xA;        method&#xA;        state&#xA;        throw&#xA;        assert&#xA;    app&#xA;        use&#xA;        listen&#xA;        callback&#xA;        keys&#xA;        context&#xA;            db&#xA;中间件&#xA;    koa-router&#xA;    trie-router&#xA;    route&#xA;    basic-auth&#xA;    etag&#xA;    compose&#xA;    static&#xA;    static-cache&#xA;    session&#xA;    compress&#xA;    csrf&#xA;    logger&#xA;    mount&#xA;    send&#xA;    error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;实时&#34;&gt;&#xA;  实时&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e6%97%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;sockjs&#xA;        # node websock&#xA;postal&#xA;        # nodejs 在内存上构建的发布订阅框架&#xA;pusher&#xA;        # 发布订阅模式socketio框架&#xA;juggernaut&#xA;        # 基于socketio&#xA;datachannel.io&#xA;        # 基于socket.io和html5 webRTC的实时聊天室框架&#xA;faye-websocket-node&#xA;        # 扩展faye项目开发的websocket的一个实现, 非常简单，而且不依赖其他库&#xA;websocket-node&#xA;        # 一个简单的websocket库，支持draft-10及之前的各种版本, 支持同样是node的c/s交互模式&#xA;ejabberd&#xA;        # 基于erlang/OTP 的xmpp im 开源框架&#xA;singalR&#xA;        # .net sock服务&#xA;nsq&#xA;        # go&#xA;openfire&#xA;        # java, 性能较差, 最多单机10w并发&#xA;webrtc&#xA;        # c++实现的web视频聊天&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;socketio&#34;&gt;&#xA;  socket.io&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#socketio&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 介绍&#xA;    socket.io: 基于任何浏览器, mobile设备的&amp;quot;webSocket&amp;quot;&#xA;# 安装&#xA;        npm install socket.io&#xA;# 使用&#xA;        var socketIo = require(&#39;socket.io&#39;);&#xA;        socketIo.listen(app).on(&#39;connection&#39;, function (socket) {                # require(&#39;socket.io&#39;)(app);&#xA;                                                                        ## var io = require(&#39;socket.io&#39;)(80);&#xA;        socket.emit(&#39;news&#39;, { hello: &#39;world&#39; });&#xA;        socket.on(&#39;my other event&#39;, function (data) {&#xA;                console.log(data);&#xA;        });&#xA;        });&#xA;# api&#xA;    server&#xA;            io.on(&#39;connection&#39;, function(socket){});&#xA;            io.on(&#39;disconnect&#39;, function(){});&#xA;            socket.on(&#39;message&#39;, function(msg){});&#xA;    client-js&#xA;            socket = io.connect(url);&#xA;            socket.on(&#39;&#39;, function(json){});&#xA;            socket.send(json);&#xA;    io&#xA;            on(&#39;connection&#39;, function(socket){});&#xA;                    # disconnect&#xA;    socket&#xA;            on(&#39;disconnect&#39;, function(){ });&#xA;            socket.on(&#39;say to someone&#39;, function(id, msg){&#xA;                    socket.broadcast.to(id).emit(&#39;my message&#39;, msg);&#xA;            });&#xA;                    # Socket#id为内部指定的&#xA;    遍历用户&#xA;            var roster = io.sockets.clients(&#39;chatroom&#39;);&#xA;            roster.forEach(function(client){&#xA;                    console.log(&#39;Username: &#39; + client.nickname);&#xA;            });                        // 1.0之前版本可用&#xA;# 方案&#xA;    namespace&#xA;            server&#xA;                    var nsp = io.of(&#39;/my-namespace&#39;);&#xA;                    Onsp.emit(&#39;hi&#39;, &#39;everyone!&#39;);                # ns广播&#xA;            client&#xA;                    var socket = io(&#39;/my-namespace&#39;);&#xA;    room&#xA;            server&#xA;                    socket.join(&#39;some room&#39;);&#xA;                    io.to(&#39;some room&#39;).emit(&#39;some event&#39;):        # room广播&#xA;                    socket.leave(&#39;some room&#39;);&#xA;# 子模块&#xA;    socket.io-redis&#xA;        介绍&#xA;                用于从外部发消息，与socket.io-emitter一起使用&#xA;        使用&#xA;                var io = require(&#39;socket.io&#39;)(3000);&#xA;                var redis = require(&#39;socket.io-redis&#39;);&#xA;                io.adapter(redis({ host: &#39;localhost&#39;, port: 6379 }));&#xA;    socket.io-emitter&#xA;        介绍&#xA;                用于从外部发消息，与socket.io-redis一起使用&#xA;        使用&#xA;                var io = require(&#39;socket.io-emitter&#39;)();&#xA;                io.emit(&#39;time&#39;, new Date);&#xA;    socket.io-client&#xA;        介绍&#xA;                用于创建客户端来连接socket.io&#xA;        使用&#xA;                var iocl = require(&#39;socket.io-client&#39;);&#xA;                var socket = iocl.connect(&#39;127.0.0.1:5555&#39;);&#xA;                socket.on(&#39;connect&#39;, function(){&#xA;&#xA;                });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;展示&#34;&gt;&#xA;  展示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%95%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;titles&#xA;    # java apache的标签库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-mvc&#34;&gt;&#xA;  spring mvc&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;struts2&#34;&gt;&#xA;  struts2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#struts2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 基础&#xA;    介绍&#xA;        struts1和WebWork的发展&#xA;        引入值栈的概念     # 一次请求的参数和处理数据放在一个map结构中&#xA;    原理&#xA;        基于拦截器, 解耦servlet, 再提供自己的拦截器(interceptor)操作数据, 反射调用业务类&#xA;        FilterDispatcher通过配置文件来映射设置请求地址与处理类&#xA;            ActionMapper判断请求是否struts处理&#xA;            ActionProxy扩展实现方式(如web service)&#xA;            ConfigurationManager对应struts.xml配置文件&#xA;            ActionInvocation执行Action与拦截器&#xA;            Action处理请求，封装数据&#xA;                # Action是非单例的，效率低&#xA;    过滤器与拦截器&#xA;        过滤器基于回调，拦截器基于反射&#xA;        过滤器依赖servlet, 拦截器在struts中处理action&#xA;&#xA;# 思想&#xA;    Action类中的无侵入设计（新技术中不出现旧技术）：map代替了作用域&#xA;        ActionContext actionContext = actionContext.getContext()&#xA;        actionContext.getApplication()&#xA;        actionContext.getSession()&#xA;&#xA;        好处&#xA;            map是java中的api，不出现旧技术&#xA;            测试方便（ servlet不能测试，只能发布测试）&#xA;                # 注意：Action类中用到作用域map的方法也不能测试&#xA;&#xA;&#xA;# 结构&#xA;    apps: 例子程序&#xA;    docs:帮助文件&#xA;    lib:程序包&#xA;    src:源码&#xA;# 使用&#xA;    要求&#xA;        jdk5&#xA;        jsp2&#xA;        servlet api2.4&#xA;&#xA;    导入核心的8个包&#xA;        struts2-core-2.3.1.1.jar        # struts的过滤器&#xA;        xwork-core-2.3.1.1.jar                # 验证工具&#xA;        freemarker-2.3.18.jar                # 标签&#xA;        javassist-3.11.0.GA.jar                # 动态代理&#xA;        commons-fileupload-1.2.2.jar&#xA;        commons-io-2.0.1.jar                # 文件处理&#xA;        commons-lang-2.5.jar                # 基础包&#xA;        ognl-3.0.3.jar                                # 表达式语言&#xA;    web.xml文件中配置过滤器&#xA;        &amp;lt;filter&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;struts&amp;lt;/filter-name&amp;gt;&#xA;            &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-class&amp;gt;&#xA;        &amp;lt;/filter&amp;gt;&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;struts&amp;lt;/filter-name&amp;gt;&#xA;            &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&#xA;        &amp;lt;/filter-mapping&amp;gt;&#xA;    写jsp页面，get或post路径为struts2的名称空间、扩展名，被配置的struts2过滤器处理&#xA;    写Action类（继承ActionSupport类）&#xA;    配置src/struts.xml文件与src/struts.properties文件，映射类、方法等到请求路径，映射返回字符串到任何方式&#xA;&#xA;&#xA;# 核心包：8个&#xA;    struts2-core-2.3.1.1.jar        # struts的过滤器&#xA;    xwork-core-2.3.1.1.jar                # 验证工具&#xA;    freemarker-2.3.18.jar                # 标签&#xA;    javassist-3.11.0.GA.jar                # 动态代理&#xA;    commons-fileupload-1.2.2.jar&#xA;    commons-io-2.0.1.jar                # 文件处理&#xA;    commons-lang-2.5.jar                # 基础包&#xA;    ognl-3.0.3.jar                                # 表达式语言&#xA;&#xA;# 配置&#xA;    struts2以包的形式管理action 包名必须唯一，包里的每个action唯一&#xA;    使用步骤&#xA;        导入lib包&#xA;        写jsp&#xA;        编写Action方法&#xA;        web.xml中配置&#xA;            &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&#xA;            &amp;lt;url-pattern&amp;gt;/*&#xA;        ../xx_struts.xml中配置请求响应&#xA;        src/struts.xml 中引入配置文件&#xA;            &amp;lt;include file=&amp;quot;cn/itcast/javaee/cal/cal_struts.xml&amp;quot;/&amp;gt;&#xA;&#xA;    配置文件（配置包）路径&#xA;        重要路径：4个&#xA;            1./struts-default.xml[框架]&#xA;                # 是框架自带的abstract包（包括上传，下载，验证等），继承它以后可以用其中的功能&#xA;            2./org/apache/struts2/default.properties[框架]&#xA;            3.src/struts.xml # 必有&#xA;            4.src/struts.properties # 可选&#xA;        验证返回消息的配置文件&#xA;            struts2-core-2.3.1.1.jar包中的&#xA;                /org/apache/struts2/struts-messages.properties文件&#xA;&#xA;    xml 中配置的简化&#xA;        *&#xA;            o-&amp;gt; 只能在name 中写*_* 等&#xA;            o-&amp;gt; 引用第一个* 用{1}        引用第二个用{2} 以此类推&#xA;&#xA;&#xA;    类路径&#xA;        com.opensymphony.xwork2.ActionSupport  默认关联到的类&#xA;&#xA;    处理请求的扩展名配置&#xA;        # 扩展名配置只有一个会生效&#xA;        1./org/apache/struts2/default.properties&#xA;                struts.action.extension=action,,&#xA;                # 框架中初始的默认扩展名，最后的&#39;,&#39;代表了无扩展名&#xA;        2.src/struts.xml中&#xA;                &amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;do,,&amp;quot;&amp;gt;&#xA;                        # 必需配置&#xA;        3.src/struts.properties中&#xA;                        struts.action.extension=xx,yy&#xA;                        # 选择配置，优先级高&#xA;&#xA;    默认配置&#xA;        struts2内置了请求字符串与基本类型的相互转换，不用手工转换&#xA;&#xA;        /org/apache/struts2/default.properties文件中&#xA;                struts.i18n.encoding=UTF-8        # post方式请求响应的编码方式&#xA;                                                                        ## get方式的没有默认值，需要自己转码&#xA;                struts.action.extension=action,,  # 框架中初始的默认扩展名,最后的&#39;,&#39;代表了无扩展名&#xA;&#xA;        每个&amp;lt;package&amp;gt;标签中配置&#xA;        &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt; 为默认的拦截器&#xA;&#xA;    src/struts.xml配置文件&#xA;&#xA;    src/struts.properties配置文件&#xA;&#xA;# 原理流程&#xA;    请求/qq.action -&amp;gt; StrutsPreparedAndExecuteFilter（核心过滤器）-&amp;gt; 匹配扩展名 -&amp;gt; 匹配命名空间&#xA;        #（ 全限定名：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.class）&#xA;            -&amp;gt; src/struts.xml                -&amp;gt; name&#xA;                class&#xA;                method&#xA;            -&amp;gt; name&#xA;                type&#xA;                内容&#xA;            -&amp;gt; 响应&#xA;            -&amp;gt; 拦截器 -&amp;gt; ConfigAction类&#xA;&#xA;        # 1.部署时读取src/struts.xml和src/struts.properties文件，形成JavaBean对象&#xA;                # 两个文件同时存在时src/struts.properties文件为准&#xA;        ## 2.请求/*路径时，StrutsPreparedAndExecuteFilter过滤&#xA;        ## 3.获取JavaBean中的actionName ,actionClass, actionMethod, 执行方法&#xA;        ## 4.执行的返回值与resultName, resultType, resultContent进行比较&#xA;        ## 5.按resultType类型返回resultContent（路径和内容）&#xA;&#xA;# 缺点&#xA;    8个jar包，慢，servlet 快&#xA;    配置繁琐&#xA;# 编码&#xA;    struts2默认编码方式:utf-8&#xA;&#xA;    返回的图片相对路径中有中文时设置tomcat&#xA;        tomcat/conf/server.xml&#xA;            &amp;lt;Connector port=&amp;quot;8080&amp;quot; .. URIEncoding=&amp;quot;utf-8&amp;quot;/&amp;gt;&#xA;&#xA;        这时点击下载的请求路径中有中文时在以post方式提交 ,struts自动转码。若以get方式提交，需要在Action类的相应的get方法中转换url编码（iso8859-1）到u8&#xA;&#xA;        原理&#xA;                改了tomcat的内部编码以后，struts中的编码是u8，放在session 中，jsp支持u8,解释后发送的html中的编码没问题，查看没问题。&#xA;                下载post发送请求，浏览器请求的是url编码的u8,struts中也是u8执行下载&#xA;&#xA;                如果不改编码，struts 中是u8,如果以List方式放入session的话,session存储的是u8&#xA;                如果直接放入数据的话,session中存储的是8859-1,jsp取出数据需要转码为u8并设置自己的编码是u8,再发送给浏览器。&#xA;                浏览器这时获取图片正常,post方式提交的是u8,经过tomcat转换为8859-1,struts中自动转换编码到u8&#xA;                如果是以get方式提交请求，get中的中文在浏览器时进行url编码到8859-1,经过tomcat，再到struts,struts不对get方式的请自动进行转码&#xA;                向action类中注入参数时是8859-1编码,需要手动在action类中的属性的get方法中进行8859-1到u8的转码操作&#xA;# 内置对象&#xA;    struts中的6个内置对象&#xA;        # request请求进入struts中时创建，request请求结束时销毁。&#xA;        requestMap&#xA;        sessionMap&#xA;        applicationMap&#xA;        parameters&#xA;        attr                        # page -&amp;gt; request -&amp;gt; session -&amp;gt; application 的顺序查找&#xA;        valueStack                # 定义实例变量，直接放入valueStack的 list（栈） 中,map（值）很少向内存储数据&#xA;            # 定义的实例变量必须提供相应的get方法,否则ognl标签中取其数据时没有方法调用，就得不到它的值&#xA;            # list 中的值优先访问 ，但是map 中的值起决定作用&#xA;            # map中存放着一个大map,其中注入了所有页面的请求信息&#xA;                # requestMap sessionMap applicationMap 并不是真正的域对象，但最后通过拦截器放入到域对象中&#xA;&#xA;# 异常处理&#xA;    配置src/strut.xml 文件&#xA;        &amp;lt;global-results&amp;gt; 全局结果（用来跳转全局异常等）&#xA;        &amp;lt;global-exception-mappings&amp;gt; 全局异常&#xA;        &amp;lt;exception-mapping result=&amp;quot;nullJsp&amp;quot;        exception=&amp;quot;java.lang.NullPointerException&amp;quot; /&amp;gt;&#xA;            # &amp;lt;action&amp;gt;标签中的局部异常&#xA;            ## &amp;lt;action&amp;gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&amp;quot;nullJsp&amp;quot;的字符串交给本&amp;lt;action&amp;gt;标签中相应的&amp;lt;result&amp;gt;标签来处理&#xA;&#xA;&#xA;    处理机制&#xA;        o-&amp;gt; 多个异常时走子异常，父异常被忽略&#xA;        o-&amp;gt; 先处理小范围异常，大范围忽略&#xA;        o-&amp;gt;  如果异常没有处理，抛出到web服务器处理,web.xml的&amp;lt;error-page&amp;gt;&amp;lt;error-code&amp;gt;&amp;lt;location&amp;gt;&#xA;    全局异常&#xA;        xml文件中&#xA;            &amp;lt;global-results&amp;gt;&#xA;                &amp;lt;result name=&amp;quot;error&amp;quot;&amp;gt;&#xA;                    /error.jsp&#xA;                &amp;lt;/result&amp;gt;&#xA;            &amp;lt;/global-results&amp;gt;&#xA;            &amp;lt;global-exception-mappings&amp;gt;&#xA;                &amp;lt;exception-mapping result=&amp;quot;error&amp;quot; exception=&amp;quot;java.lang.Exception&amp;quot;/&amp;gt;&#xA;            &amp;lt;/global-exception-mappings&amp;gt;&#xA;        error.jsp页面中&#xA;            &amp;lt;%@ taglib prefix=&amp;quot;s&amp;quot; uri=&amp;quot;/struts-tags&amp;quot; %&amp;gt;&#xA;            异常信息：&amp;lt;s:property value=&amp;quot;exception.message&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;&#xA;            详细信息：&amp;lt;s:property value=&amp;quot;exceptionStack&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;&#xA;&#xA;&#xA;# 转递方式&#xA;    chain                        # action类之间转发&#xA;    dispatcher                # 转发到jsp&#xA;    freemarker&#xA;    httpheader&#xA;    redirect                # 重定向到页面&#xA;    redirectAction        # action 类之间重定向&#xA;    stream                        # 返回 InputStream流&#xA;    velocity&#xA;    xslt&#xA;    plainText&#xA;# Action类&#xA;    注意&#xA;        1.所有Action类都要继承ActionSupport类，否则execute方法返回的字符串不会回到struts拦截器再根据xml文件的配置进行转发&#xA;        2.action类是非单例的。        # 所有多实例的对象全部是因为有私有属性，否则全部应该是单例的&#xA;        3.action类放在栈的顶端，用于注入数据&#xA;&#xA;    传统方式得到request,response,servletContext,pageContext&#xA;        ServletActionContext.getPageContext()&#xA;        HttpServletRequest request = ServletActionContext.getRequest()&#xA;        ServletActionContext.getResponse()&#xA;        ServletActionContext.getServletContext();&#xA;&#xA;    优势&#xA;        实现与servlet的解耦&#xA;&#xA;    验证&#xA;        验证分类&#xA;                前台验证：javascript等&#xA;                后台验证：服务器&#xA;        struts2验证&#xA;                    后台验证&#xA;            1.代码式验证&#xA;            2.声明式验证:xml文件&#xA;&#xA;    ActionContext类&#xA;        调用方法&#xA;        ActionContext actionContext = ActionContext.getContext();&#xA;        得到内置对象        # 这几种得到作用域的方法均可以得到作用域中原有的值，也可以放入值&#xA;        request&#xA;                actionContext.put(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;);&#xA;        application&#xA;                Map&amp;lt;String,Object&amp;gt; applicationMap = actionContext.getApplication();&#xA;        session&#xA;                Map&amp;lt;String,Object&amp;gt; sessionMap = actionContext.getSession();&#xA;                        # 或 actionContext.get(&amp;quot;session&amp;quot;)得到，因为actionContext中存储着大map&#xA;        parameters&#xA;                Map&amp;lt;String,Object&amp;gt; parametersMap = actionContext.getParameters();&#xA;        valueStack&#xA;                ValueStack valueStack = actionContext.getValueStack()&#xA;                valueStack.getRoot()                        # 得到当前值栈的顺序&#xA;&#xA;    参数&#xA;        1.action类中可以直接创建属性与其get方法得到客户端get方法或post表单请求的参数(由struts2自动注入)&#xA;        2.action类中可以创建 JavaBean的属性来接收struts注入的参数，这时用户请求的参数名字要写成JavaBean名.JavaBean中的属性名（这样struts2会自动调用JavaBean的set方法来注入其中相应的参数 ）&#xA;## BaseAction&#xA;    作用&#xA;        权限管理&#xA;        存放常驻内存数据&#xA;        抽取常用的方法&#xA;# web.xml配置&#xA;    &amp;lt;filter&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;&#xA;        &amp;lt;filter-class&amp;gt; org.apache.struts2.dispatcher.FilterDispatcher &amp;lt;/filter-class&amp;gt;&#xA;        &amp;lt;init-param&amp;gt;&#xA;            &amp;lt;param-name&amp;gt;struts.action.extension&amp;lt;/param-name&amp;gt;&#xA;            &amp;lt;param-value&amp;gt;do&amp;lt;/param-value&amp;gt;&#xA;        &amp;lt;/init-param&amp;gt;&#xA;    &amp;lt;/filter&amp;gt;&#xA;    &amp;lt;filter-mapping&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;&#xA;        &amp;lt;url-pattern&amp;gt;*.json&amp;lt;/url-pattern&amp;gt;&#xA;    &amp;lt;/filter-mapping&amp;gt;&#xA;        # 设置全局过滤器，并且修改过滤扩展名&#xA;# default.properties&#xA;    src/struts.properties配置文件&#xA;        struts.custom.i18n.resources=struts    # 使自己的普通配置生效。如：/org/apache/struts2/struts-messages.properties文件的&#xA;            ## struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} &amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; {3}  属性，&amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; &amp;quot;{3}&amp;quot;是显示消息的占位符&#xA;            ## struts.action.extension=action,,可以不配置&#xA;            # 由于只加载properties文件，所以省略.properties&#xA;            ## =后面的是相对于src目录的文件&#xA;# ognl标签&#xA;    注意&#xA;        # jquery中不能定位ognl标签，而要用标签自己生成的id定位（看源码得到）&#xA;    使用：&#xA;        &amp;lt;%@ taglib uri=&amp;quot;/struts-tags&amp;quot; prefix=&amp;quot;s&amp;quot; %&amp;gt;&#xA;        tld映射文件路径&#xA;            struts2-core-2.3.1.1.jar包中&#xA;            /META-INF/struts-tags.tld&#xA;&#xA;    &#39;#&#39;出现的地方&#xA;        o-&amp;gt; 除ValueStack 之外的所有struts内置对象的取值前面都要加&#xA;        o-&amp;gt; 取JavaBean中的属性时要加 &#39;#&#39;，如&amp;quot;#user.username&amp;quot;,ValueStack中也不例外&#xA;        o-&amp;gt; 构造Map对象，Map：#{&#39;male&#39;:&#39;[男]&#39;,&#39;female&#39;:&#39;[女]&#39;}，构造radio和select标签，如&#xA;                        # &amp;lt;s:radio list=&amp;quot;#{&#39;male&#39;:&#39;aa&#39;,&#39;bb&#39;:&#39;cc&#39;}&amp;quot; name=&amp;quot;gender2&amp;quot; /&amp;gt;&#xA;        o-&amp;gt; 迭代数组或list集合&#xA;            集合的投影：userList.{username}&#xA;            集合的过滤：userList.{?#this.age&amp;gt;22}&#xA;&#xA;    主题与模板&#xA;        主题：为多个模板提供风格&#xA;            struts2-core-2.3.1.1.jar包中&#xA;                template中的四个主题&#xA;                    archive                # 其中是.vm文件，其它是.ftl文件。vm与ftl是两种视图技术&#xA;                        ajax        # 除此之外其它都不支持ajax&#xA;                        simple&#xA;                        xhtml&#xA;                    xhtml                # 默认主题,default.properties配置文件中定义&#xA;                    css_xhtml&#xA;                    simple&#xA;            修改主题&#xA;                1.struts.properties 中修改&#xA;                    struts.ui.theme=simple          # 针对当前webapp&#xA;                2.&amp;lt;s:form theme=&amp;quot;xhtml&amp;quot;&amp;gt;            # 只针对当前表单&#xA;                3.&amp;lt;s:textfield name=&amp;quot;username&amp;quot; theme=&amp;quot;simple&amp;quot;&amp;gt;  # 修改某个标签的属性&#xA;        模板：为标签提供样式&#xA;                做模板的技术freemarker&#xA;&#xA;    ognl标签的优点：自动排版、验证数据回显、国际化&#xA;&#xA;    所有标签：&#xA;        逻辑标签&#xA;            对 Map 集合的迭代：&#xA;                &amp;lt;s:iterator value=&amp;quot;#session.fileMap&amp;quot; var=&amp;quot;entry&amp;quot; status=&amp;quot;stat&amp;quot;&amp;gt;&#xA;                    &amp;lt;s:property value=&amp;quot;#entry.key&amp;quot;/&amp;gt;&#xA;                &amp;lt;s:if test=&amp;quot;#stat.count%4==0&amp;quot;&amp;gt;&amp;lt;/s:if&amp;gt;&#xA;                &amp;lt;/s:iterator&amp;gt;&#xA;            对 List 集合的迭代  List&amp;lt;User&amp;gt; userList&#xA;                普通迭代&#xA;                    &amp;lt;s:iterator var=&amp;quot;user&amp;quot; value=&amp;quot;userList&amp;quot;&amp;gt;      # 投影语法List&amp;lt;user&amp;gt;中的所有username&#xA;                    &amp;lt;s:property value=&amp;quot;#user.username&amp;quot;/&amp;gt;&#xA;                        投影语法&#xA;                    &amp;lt;s:iterator var=&amp;quot;username&amp;quot; value=&amp;quot;userList.{username}&amp;quot;&amp;gt;&#xA;                    &amp;lt;s:property/&amp;gt;                        # 这里不用写属性value=&amp;quot;username&amp;quot;就可以对page域中的username进行显示&#xA;                过滤语法&#xA;                    &amp;lt;s:iterator var=&amp;quot;user&amp;quot; value=&amp;quot;userList.{?#this.age&amp;gt;9}&amp;quot;&amp;gt;&#xA;                        # this代表当前被迭代的元素 ?#是所有 ^#是第一个 $#是最后一个  ?#...[0]按标记取&#xA;                    &amp;lt;s:property value=&amp;quot;#user.username&amp;quot; /&amp;gt;&#xA;        显示标签（UI标签）&#xA;            普通字符串中使用ognl&#xA;                jsp中用%{}      xml中用${}&#xA;                例如&#xA;                jsp中：&amp;lt;s:textfield label=&amp;quot;%{#attr.testValueStack}&amp;quot;/&amp;gt;&#xA;                xml中：&amp;lt;param name=&amp;quot;min&amp;quot;&amp;gt;4000&amp;lt;/param&amp;gt;&#xA;                                            &amp;lt;message&amp;gt;${min}&amp;lt;/message&amp;gt;&#xA;            普通信息&#xA;                &amp;lt;s:text name=&amp;quot;&amp;quot;/&amp;gt;&#xA;            输出值&#xA;                迭代器中&#xA;                        &amp;lt;s:property/&amp;gt;        # 直接输出被迭代的内容（简单）&#xA;                        &amp;lt;s:property value=&amp;quot;aa&amp;quot;/&amp;gt;&#xA;                        &amp;lt;s:property value=&amp;quot;#aa&amp;quot;/&amp;gt;&#xA;                普通&#xA;                        &amp;lt;s:property value=&amp;quot;username&amp;quot;/&amp;gt;      # 输出标签,得到valueStack中属性&#xA;                        &amp;lt;s:property value=&amp;quot;#request.name&amp;quot;/&amp;gt;                # 得到request域对象中的值&#xA;                                # request #session #application #parameters #attr&#xA;                                # &#39;#attr&#39;优先级：page,request,valueStack,session,application&#xA;            显示验证拦截器的验证信息集合中的数据：&#xA;                &amp;lt;s:fielderror/&amp;gt;                                                        # 显示所有错误信息&#xA;                &amp;lt;s:fielderror fieldName=&amp;quot;&amp;quot;/&amp;gt;                        # 显示验证返回的错误信息&#xA;            单选&#xA;                &amp;lt;s:radio list=&amp;quot;#{&#39;male&#39;:&#39;男&#39;,&#39;female&#39;:&#39;女&#39;}&amp;quot; name=&amp;quot;gender2&amp;quot; value=&#39;男&#39;&amp;gt;&#xA;                                # 自动加class id &amp;lt;label for=&amp;quot;gender2male&amp;quot;&amp;gt;等&#xA;                                # list键值对中male是实际值,男是显示值&#xA;                                # name是&amp;lt;input radio &amp;gt;的name属性&#xA;                                # value中是选中的项&#xA;            多选&#xA;                &amp;lt;s:select multiple=&amp;quot;true&amp;quot; list=&amp;quot;#{&#39;bj&#39;:&#39;北京&#39;,&#39;sh&#39;:&#39;上海&#39;,&#39;gz&#39;:&#39;广州&#39;}&amp;quot; name=&amp;quot;select1&amp;quot; value=&amp;quot;{&#39;sh&#39;,&#39;bj&#39;}&amp;quot;/&amp;gt;&#xA;            表单                        # 在ognl的标签中， struts的验证消息自动回显，不用加&amp;lt;s:fielderror/&amp;gt;标签&#xA;                &amp;lt;s:form action=&amp;quot;&amp;quot;&amp;gt;                # 默认中加上了 method=&amp;quot;post&amp;quot; action中加上了当前网站了contextPath路径&#xA;                        &amp;lt;s:textfield label=&amp;quot;用户名&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt;&#xA;                        &amp;lt;s:password label=&amp;quot;密码&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt;&#xA;                        &amp;lt;s:submit value=&amp;quot;登录&amp;quot; /&amp;gt;&#xA;            国际化                # 国际化一般放在整个网站的最后写&#xA;                                ##　伪国际化：将不同语言的页面放在不同文件夹中分别访问&#xA;                        # 国际化是通过i18n拦截器实现的&#xA;                1.创建国际化信息文件&#xA;                        message_zh_CH.properties      # 基名_语言名_国家名.properties&#xA;                                username=xxx&#xA;                                password=xxxx&#xA;                                submit=xx&#xA;                        message_en_US.properties&#xA;                        ..&#xA;                        message.properties                # 默认的显示语言&#xA;                                # 找伊拉克没有的话找本地区语言，本地语言没有的话找其它(默认的或美国等)&#xA;                2.struts.properties中引入国际化配置的属性文件&#xA;                        struts.custom,i18n.resources=struts2/tag/i18n/message        # 从src文件夹路径开始，只写基名&#xA;                3.验证消息国际化&#xA;                        message.properties文件中配置属性validationRequiredUsername=用户名错误&#xA;                        validation.xml文件中&#xA;                        &amp;lt;message key=&amp;quot;validationRequiredUsername&amp;quot;&amp;gt;&amp;lt;/message&amp;gt;&#xA;                4.jsp文件中用key属性代替 label属性(或其它在页面上显示信息的属性),key中写国际化信息文件中的key&#xA;                        &amp;lt;s:form action=&amp;quot;taglogin&amp;quot;&amp;gt;&#xA;                                &amp;lt;s:textfield key=&amp;quot;username&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt;&#xA;                                &amp;lt;s:password key=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt;&#xA;                                &amp;lt;s:submit key=&amp;quot;submit&amp;quot;/&amp;gt;&#xA;                        &amp;lt;/s:form&amp;gt;&#xA;                5.普通信息的国际化&#xA;                        message.properties中配置属性 normalMessage:普通信息&#xA;                        jsp中&amp;lt;s:text name=&amp;quot;normalMessage&amp;quot;/&amp;gt;&#xA;                6.测试&#xA;                        intername选项 -- 语言 改地区访问&#xA;&#xA;    xml文件中的ognl标签&#xA;            o-&amp;gt; ${aa}&#xA;                    1.调用转到该标签类的getAa()方法得到aa的值替换${aa}&#xA;                    2.本标签中name=&amp;quot;aa&amp;quot;的标签的文本节点的内容&#xA;            o-&amp;gt; {1}{2}{3}..{n}&#xA;                    匹配本标签中name=&amp;quot;*a*&amp;quot; 中的第n个‘*’,用于通配传递过来的参数的一部分的值&#xA;# ognl表达式&#xA;    ognl 开源，java写的免费标签,是struts2特有的&#xA;&#xA;    xml文件中&#xA;        ${Xxx}                取值栈中栈中的东西，如action类中的属性&#xA;        ${#Xxx}                取值栈中值的东西，如request,session域中的数据（其实就是老师说的内置对象【valueStack就是值栈】）&#xA;&#xA;    jsp文件中&#xA;        &amp;lt;s:iterator value=&amp;quot;#session.fileMap&amp;quot; var=&amp;quot;entry&amp;quot; status=&amp;quot;stat&amp;quot;&amp;gt;&#xA;            &amp;lt;s:property value=&amp;quot;#entry.key&amp;quot;/&amp;gt;&#xA;            &amp;lt;s:if test=&amp;quot;#stat.count%4==0&amp;quot;&amp;gt;&amp;lt;/s:if&amp;gt;&#xA;        &amp;lt;/s:iterator&amp;gt;&#xA;# strut.xml配置&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;!DOCTYPE struts PUBLIC&#xA;            &amp;quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&amp;quot;&#xA;            &amp;quot;http://struts.apache.org/dtds/struts-2.0.dtd&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;struts&amp;gt;&#xA;        &amp;lt;constant name=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/constant&amp;gt;&#xA;        &amp;lt;include file=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/include&amp;gt;&#xA;        &amp;lt;package name=&amp;quot;&amp;quot;&amp;gt;&#xA;                &amp;lt;interceptors&amp;gt;&#xA;                        &amp;lt;interceptor name=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/interceptor&amp;gt;&#xA;                        &amp;lt;interceptor-stack name=&amp;quot;&amp;quot;&amp;gt;&#xA;                                &amp;lt;interceptor-ref name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt;&#xA;                        &amp;lt;/interceptor-stack&amp;gt;&#xA;                &amp;lt;/interceptors&amp;gt;&#xA;                &amp;lt;default-interceptor-ref name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/default-interceptor-ref&amp;gt;&#xA;                &amp;lt;global-results&amp;gt;&#xA;                        &amp;lt;result name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;&#xA;                &amp;lt;/global-results&amp;gt;&#xA;                &amp;lt;global-exception-mappings&amp;gt;&#xA;                        &amp;lt;exception-mapping result=&amp;quot;&amp;quot; exception=&amp;quot;&amp;quot;/&amp;gt;&#xA;                &amp;lt;/global-exception-mappings&amp;gt;&#xA;                &amp;lt;action name=&amp;quot;&amp;quot;&amp;gt;&#xA;                        &amp;lt;param name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/param&amp;gt;&#xA;                        &amp;lt;result&amp;gt;&amp;lt;/result&amp;gt;&#xA;                        &amp;lt;result name=&amp;quot;input&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;&#xA;                        &amp;lt;exception-mapping result=&amp;quot;&amp;quot; exception=&amp;quot;&amp;quot;/&amp;gt;&#xA;                        &amp;lt;interceptor-ref name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt;&#xA;                &amp;lt;/action&amp;gt;&#xA;        &amp;lt;/package&amp;gt;&#xA;    &amp;lt;/struts&amp;gt;&#xA;&#xA;    设置&#xA;        &amp;lt;constant name=&amp;quot;struts.devMode&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;                # 开启debug模式&#xA;                                                                # debug模式，不用重启调试(添加新的方法要重启，方法中改代码不用重启)&#xA;        &amp;lt;constant name=&amp;quot;struts.i18n.encoding&amp;quot; value=&amp;quot;utf-8&amp;quot;/&amp;gt;&#xA;                                                                # 配置struts的编码&#xA;        &amp;lt;constant name=&amp;quot;struts.configuration.xml.reload&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;&#xA;                                                                # 配置本属性，可以使得改动struts配置文件不用重启应用服务器&#xA;        &amp;lt;constant name=&amp;quot;struts.multipart.saveDir&amp;quot; value=&amp;quot;/upload&amp;quot;/&amp;gt;&#xA;                                                                # 配置上传存储路径&#xA;        &amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;action,do&amp;quot; /&amp;gt;&#xA;                                                                    # 配置过滤路径&#xA;    详细解释&#xA;        o-&amp;gt; 存放路径src/&#xA;        o-&amp;gt; 可以在struts-2.3.15.1的src\apps\blank\src\main\resources\struts.xml中参考配置文件&#xA;        o-&amp;gt; &amp;lt;include file=&amp;quot;struts2/cal/cal_struts.xml&amp;quot;/&amp;gt;标签包含其它路径的xml配置文件&#xA;                        #　被include的文件不能再include其它文件&#xA;        o-&amp;gt; &amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;do,,&amp;quot;&amp;gt;&#xA;                默认值&#xA;                        default.properties中配置了默扩展名：struts.action.extension=action,,&#xA;                # 配置匹配到框架处理的扩展名，空逗号代表匹配没有扩展名&#xA;        o-&amp;gt; &amp;lt;package name=&amp;quot;xxPackage&amp;quot; extends=&amp;quot;struts-default&amp;quot; namespace=&amp;quot;/xx/&amp;quot;&amp;gt;&#xA;                默认值&#xA;                        namespace=&amp;quot;/&amp;quot;&#xA;                        extends=&amp;quot;struts-default&amp;quot;        # 不可省略&#xA;                # name是包的唯一标识，不可以写路径&#xA;                ## namespace 访问路径如/xx/a.do会匹配到该包执行其中的映射，按照域命名空间链的方式匹配，如：&#xA;                                                        /xx/yy/a.do也会匹配到该包，但是它优先匹配到/xx/yy的命名空间&#xA;                                                        /a.do 不会匹配到该包&#xA;                        注意：匹配/sys/*的名称空间是/sys 而非 /sys/&#xA;                ## struts的包有抽象包，普通包两种，通过继承可以加入包内容，相当于复制、粘贴&#xA;                ## 继承的包是struts-default，其路径是/struts-default.xml&#xA;                ## ，它定义了核心的bean和拦截器&#xA;        o-&amp;gt; &amp;lt;interceptors&amp;gt;&#xA;                        &amp;lt;interceptor name=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot;/&amp;gt;&#xA;                        &amp;lt;interceptor-stack name=&amp;quot;&amp;quot;&amp;gt;&#xA;                                &amp;lt;interceptor-ref name=&amp;quot;/&amp;quot;&amp;gt;&#xA;                                # 定义拦截器、定义拦截器栈（加入拦截器）&#xA;                                ## 拦截器栈中可以加栈&#xA;        o-&amp;gt; &amp;lt;default-interceptor-ref name=&amp;quot;&amp;quot;&amp;gt; 默认拦截器（可以用于验证用户登录）&#xA;        o-&amp;gt; &amp;lt;global-results&amp;gt; 全局结果（用来跳转全局异常等）&#xA;        o-&amp;gt; &amp;lt;global-exception-mappings&amp;gt; 全局异常&#xA;        o-&amp;gt; &amp;lt;action name=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot; method=&amp;quot;&amp;quot;&amp;gt;&#xA;                默认值&#xA;                        class=&amp;quot;com.opensymphony.xwork2.ActionSupport&amp;quot;&#xA;                        method=&amp;quot;execute&amp;quot;&#xA;                # name=&amp;quot;aa&amp;quot;时 .../aa.do的请求匹配到该方法执行&#xA;                ## class 是类字节码路径，method是其中的方法名&#xA;        o-&amp;gt; &amp;lt;param name=&amp;quot;aaa&amp;quot;&amp;gt;bbb&amp;lt;/param&amp;gt;&#xA;                调用 &amp;lt;action&amp;gt;标签中对象的实例的方法：setAaa(&amp;quot;bbb&amp;quot;);&#xA;        o-&amp;gt; &amp;lt;result name=&amp;quot;&amp;quot; type=&amp;quot;&amp;quot;&amp;gt;/ok.jsp&#xA;                默认值&#xA;                        name=&amp;quot;success&amp;quot;&#xA;                        type=&amp;quot;dispatcher&amp;quot;&#xA;                # name=&amp;quot;success&amp;quot;时，映射的method返回&amp;quot;success&amp;quot;时进入该result处理&#xA;                ## type是返回方式 ，如dispatcher redirect等&#xA;                        type的返回类型&#xA;                                dispatcher : 转发到jsp页面&#xA;                                redirect : 重定向到 jsp html 等页面&#xA;                                chain : Action 类之间的转发&#xA;                                redirectAction : Action 类之间的重定向&#xA;                                stream : 以 inputStream 的数据类型返回&#xA;                                        stream的参数                        # 可以从struts-default.xml文件中对应的stream参数对应的类的源码中查看其中的set方法找到要写参数的名称&#xA;                                                &amp;lt;param name=&amp;quot;contentType&amp;quot;&amp;gt;image/pjpeg&amp;lt;/param&amp;gt;                # 下载文件的类型                  另外如text/html; charset=utf-8返回给ajax异步数据&#xA;                                                &amp;lt;param name=&amp;quot;bufferSize&amp;quot;&amp;gt;2048&amp;lt;/param&amp;gt;                # 缓冲byte[]的大小，单位字节&#xA;                                                &amp;lt;param name=&amp;quot;contentDisposition&amp;quot;&amp;gt;attachment;filename=${uuidFileName}&amp;lt;/param&amp;gt;                # 设置下载响应头，只的下载时才设置。${uuidFileName}是一个OGNL表达式&#xA;                                                &amp;lt;param name=&amp;quot;inputName&amp;quot;&amp;gt;imageStream&amp;lt;/param&amp;gt;        # 框架调用传递给result标签结果字符串的对象中的getImageStream()方法，来获取InputStream流对象&#xA;                                                # 返回stream类型不指定返回的路径&#xA;                ## 标签间的内容：/ok.jsp 是响应的路径&#xA;        o-&amp;gt; &amp;lt;result name=&amp;quot;input&amp;quot; type=&amp;quot;&amp;quot;&amp;gt;/ok.jsp&#xA;                type中的参数                        # 可以从struts-default.xml配置文件中查到&#xA;                        dispatcher        # 转发&#xA;                        redirect        # 重定向&#xA;                        chain                # Action类之间转发，需要加参数，参数的名字&#xA;                                                ## ：struts-default.xml文件中找到&amp;quot;chain&amp;quot;对应的类，按快捷键ctrl + shift + T 关联类的源码文件，查找set方法改名即可&#xA;                                &amp;lt;param name=&amp;quot;actionName&amp;quot;&amp;gt;to&amp;lt;/param&amp;gt;&#xA;                                        # action标签的 name属性值&#xA;                                &amp;lt;param name=&amp;quot;namespace&amp;quot;&amp;gt;/&amp;lt;/param&amp;gt;&#xA;                                        # action的名称空间&#xA;                        redirectAction                # Action类之间重定向&#xA;&#xA;                # 各种拦截器不通过时默认的返回input，同时向request作用域中加入了相关错误信息供struts2的jsp标签进行显示&#xA;                ## 处理 返回值是input的返回信息跳转，就是处理拦截器拦截后的信息跳转&#xA;        o-&amp;gt; &amp;lt;exception-mapping result=&amp;quot;nullJsp&amp;quot;        exception=&amp;quot;java.lang.NullPointerException&amp;quot; /&amp;gt;&#xA;                # &amp;lt;action&amp;gt;标签中的局部异常&#xA;                ## &amp;lt;action&amp;gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&amp;quot;nullJsp&amp;quot;的字符串交给本&amp;lt;action&amp;gt;标签中相应的&amp;lt;result&amp;gt;标签来处理&#xA;        o-&amp;gt; &amp;lt;interceptor-ref name=&amp;quot;loginInterceptor&amp;quot;/&amp;gt;&#xA;                默认值&#xA;                        name=&amp;quot;defaultStack&amp;quot;&#xA;                # 指定在本&amp;lt;action&amp;gt;标签中使用的拦截器或拦截器栈&#xA;                ## 当指定了拦截器或拦截器栈以后，默认的defaultStack将会没有,此时defaultStack中的18个拦截器将不再执行&#xA;&#xA;    使用：OGNL对象图导航语言对标签中的路径进行动态设置&#xA;&#xA;# 验证&#xA;    struts2验证&#xA;        1.代码式: validate(),validateXxx()方法&#xA;                        # 单个验证与全部验证都存在时先单个验证，再全部验证，验证信息都加入验证信息集合&#xA;        2.声明式: Action类名-validation.xml&#xA;                                Action类名-&amp;lt;action标签的name属性&amp;gt;-validation.xml&#xA;                            # 单个验证与全部验证都存在时先全部验证，再单个验证，验证信息都加入验证信息集合&#xA;                    # 先声明验证，后代码验证&#xA;    参数驱动&#xA;        1.属性驱动: action中用属性收集表单参数&#xA;        2.模型驱动: javaBean收集参数&#xA;&#xA;    代码式（属性驱动）：&#xA;        步骤&#xA;        1.需要验证的Action类  继承 ActionSupport 类&#xA;                        # ActionSupport 类 实现了Validateable接口，该接口是验证接口&#xA;&#xA;        2.写验证方法&#xA;                1&amp;gt; public void validate()&#xA;                                # 方法重写（通用验证方法，本类中的所有其它方法执行前都执行）&#xA;&#xA;                2&amp;gt; public void validateXxxMethod()&#xA;                                # 或者自定义专用验证方法 xxxMethod为要验证的方法名，首字母要大写&#xA;&#xA;                        # 注意，通用、专用验证方法同时存在时，先执行专用验证方法，再执行通用验证方法&#xA;                        ## ，但是通用验证方法的错误消息无法加入到返回的错误集合中&#xA;&#xA;                3&amp;gt; this.addFieldError(&amp;quot;password&amp;quot;,&amp;quot;密码必填&amp;quot;);&#xA;&#xA;                        # 验证方法中添加错误信息到错误信息集合&#xA;                        ## addFieldError(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;)是从ActionSupport父类中继承的方法&#xA;&#xA;        3.jsp文件中通过验证标签：&#xA;                        &amp;lt;%@ taglib uri=&amp;quot;/struts-tags&amp;quot; prefix=&amp;quot;s&amp;quot;%&amp;gt;&#xA;                        &amp;lt;s:fielderror/&amp;gt;                # 显示所有错误信息&#xA;                        &amp;lt;s:fielderror fieldName=&amp;quot;password&amp;quot;/&amp;gt;&#xA;                显示验证出错信息&#xA;&#xA;        4.xml配置&#xA;            &amp;lt;!-- 验证错误信息处理 --&amp;gt;&#xA;                &amp;lt;result name=&amp;quot;input&amp;quot; type=&amp;quot;dispatcher&amp;quot;&amp;gt;&#xA;                        /error.jsp&#xA;                &amp;lt;/result&amp;gt;&#xA;                        # 写在需要验证的方法对应的标签中，验证错误时验证方法会优先返回&amp;quot;input&amp;quot;字符串&#xA;&#xA;&#xA;    声明式（属性驱动）：&#xA;        1.验证Action类继承ActionSupport&#xA;        2.验证Action类目录下配置文件&#xA;            Action类名-validation.xml&#xA;            Action类名-&amp;lt;action标签的name属性&amp;gt;-validation.xml&#xA;                # 放入此名字的配置文件就相当于加了验证，不需要做其它事情&#xA;                ## ，相当于分别向Actioin类中加入了validate()validateXxx()方法进行了相应验证&#xA;                文件内容&#xA;                &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;                    &amp;lt;!DOCTYPE validators PUBLIC&#xA;                    &amp;quot;-//Apache Struts//XWork Validator 1.0.3//EN&amp;quot;&#xA;                    &amp;quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&amp;quot;&amp;gt;&#xA;                    &amp;lt;validators&amp;gt;&#xA;                            &amp;lt;field name=&amp;quot;username&amp;quot;&amp;gt;                # 要验证的属性&#xA;                                    &amp;lt;field-validator type=&amp;quot;requiredstring&amp;quot;&amp;gt;&#xA;                                            &amp;lt;message&amp;gt;用户名必填&amp;lt;/message&amp;gt;&#xA;                                    &amp;lt;/field-validator&amp;gt;&#xA;                            &amp;lt;/field&amp;gt;&#xA;                            &amp;lt;field-validator type=&amp;quot;regex&amp;quot;&amp;gt;&#xA;                                    &amp;lt;param name=&amp;quot;expression&amp;quot;&amp;gt;^[\u3447-\uFA29]+$&amp;lt;/param&amp;gt;&#xA;                                    &amp;lt;message&amp;gt;UserAction2-validation==&amp;gt;必须写中文&amp;lt;/message&amp;gt;&#xA;                            &amp;lt;/field-validator&amp;gt;&#xA;                    &amp;lt;/validators&amp;gt;&#xA;&#xA;                            # xml文件的头在 xwork-core-2.3.1.1.jar包的&#xA;                                    xwork-validator-1.0.3.dtd中复制&#xA;                            ## 关联约束在&#xA;                                    \struts-2.3.15.1\src\xwork-core\src\main\resources\xwork-validator-1.0.3.dtd文件&#xA;                            ## &amp;lt;field-validator type=&amp;quot;&amp;quot;&amp;gt;的约束类型在xwork-core-2.3.1.1.jar包的&#xA;                                            /com/opensymphony/xwork2/validator/validators/default.xml文件中&#xA;                                                    # 16个规则&#xA;                                                    ## type=&amp;quot;regex&amp;quot;相当于调用了default.xml文件中配置的&#xA;                                                        ## RegexFieldValidator类的 setExpression方法&#xA;        3.jsp文件中通过验证标签（同上）&#xA;        4.xml配置（同上）&#xA;            # 出错信息&#xA;                1.验证文件名写错，无提示，不验证&#xA;                2.&amp;lt;field-validator type=&amp;quot;&amp;quot;&amp;gt;写错，有明显提示&#xA;                2.&amp;lt;field name=&amp;quot;salaryy&amp;quot;&amp;gt;写错，获取的salaryy为空。&#xA;&#xA;    声明式（模型驱动）&#xA;            1.创建bean对象，bean对象中封装属性&#xA;            2.验证Action类继承ActionSupport类，声明bean对象实例&#xA;            3.action类同目录 中  ：Action类名-&amp;lt;action标签的name属性&amp;gt;-validation.xml&#xA;                            # &amp;lt;field-validator type=&amp;quot;visitor&amp;quot;&amp;gt;&#xA;                    # bean类同目录中：bean类名-validation.xml配置验证文件&#xA;            4.jsp文件请求参数改为：action类中bean对象名.bean对象封装的属性名。用&amp;lt;s:fielderror/&amp;gt;标签得到返回的错误信息&#xA;            5.xml配置（同上）&#xA;&#xA;    原理&#xA;    StrutsPreparedAndExecuteFilter&#xA;        1.注入参数&#xA;                setUsername()&#xA;            setPassword()&#xA;        2.验证方法：validate()或validateXxx()&#xA;                        验证配置文件中验证：Action类名-validation.xml&#xA;        3.转发：根据验证成功或失败返回消息&#xA;                        验证集合无错误消息成功Action --&amp;gt; execute或同签名的方法&#xA;                        验证集合有错误消息失败&amp;lt;result name = &amp;quot;input&amp;quot; type=&amp;quot;dispatcher&amp;quot;&#xA;                                            register.jsp/login.jsp&#xA;# 过滤器&#xA;    StrutsPrepareAndExecuteFilter&#xA;        中查看Dispathcer类，从中找到配置struts-default.xml,struts-plugin.xml,struts.xml值的属性DEFAULT_CONFIGURATION_PATHS&#xA;        查找引用该属性的方法为init_TraditionalXmlConfigurations&#xA;        查看引用该方法的方法为init&#xA;        回头看StrutsPrepareAndExecuteFilter中初始化dispatcher对象的方法initDispatcher&#xA;                其中调用了dispatcher.init();方法来配置dispatcher&#xA;        由此可以知道struts在启动时加载了struts-default.xml,struts-plugin.xml,struts.xml配置文件&#xA;# 拦截器&#xA;    struts-core-2.3.1.1.jar包中的&#xA;        struts-default.xml文件中&#xA;                定义了32个interceptor（拦截器）&#xA;                        i18n    # 国际化&#xA;            token  # 表单重复提交&#xA;            validation  # 验证&#xA;            params  # 参数拦截器,向Action类中注入参数&#xA;            cookie&#xA;        interceptor-tack    # 拦截栈&#xA;                # 拦截栈中的拦截器的先后顺序有影响&#xA;                basicStack&#xA;            defaultStack    # 每个http请求都会经过该拦截栈&#xA;                            ## 其中的18个拦截器, &amp;lt;default-interceptor-ref&amp;gt;中定义&#xA;    原理&#xA;            拦截器仿照过滤器建立，内部实现原理是完全相同的&#xA;    执行流程&#xA;            拦截器构构造函数 -&amp;gt; action构造函数 -&amp;gt; 拦截器1 in -&amp;gt; 拦截器2 in -&amp;gt; demo -&amp;gt; 拦截器2 out -&amp;gt; 拦截器1 out&#xA;        exception拦截器最先进，最后出&#xA;    自定义拦截器&#xA;        1.定义Action类，继承Interceptor接口，重写生命周期方法&#xA;            public LoginInterceptor() {&#xA;            }&#xA;            public void destroy() {&#xA;            }&#xA;            public void init() {&#xA;            }&#xA;            public String intercept(ActionInvocation invocation)  {&#xA;            }&#xA;        2.配置struts.xml文件&#xA;            1&amp;gt; 定义拦截器、拦截器栈&#xA;                &amp;lt;interceptors&amp;gt;&#xA;                    &amp;lt;interceptor name=&amp;quot;loginInterceptor&amp;quot; class=&amp;quot;interceptor.LoginInterceptor&amp;quot;/&amp;gt;&#xA;                    &amp;lt;interceptor name=&amp;quot;roleInterceptor&amp;quot; class=&amp;quot;interceptor.RoleInterceptor&amp;quot;/&amp;gt;&#xA;                    &amp;lt;interceptor-stack name=&amp;quot;crmStack&amp;quot;&amp;gt;&#xA;                        &amp;lt;interceptor-ref name=&amp;quot;loginInterceptor&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt;&#xA;                        &amp;lt;interceptor-ref name=&amp;quot;roleInterceptor&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt;&#xA;                    &amp;lt;/interceptor-stack&amp;gt;&#xA;                &amp;lt;/interceptors&amp;gt;&#xA;            2&amp;gt; &amp;lt;action&amp;gt;标签中声明用到的拦截器或拦截器栈&#xA;                    &amp;lt;interceptor-ref name=&amp;quot;loginInterceptor&amp;quot; /&amp;gt;                # 此时默认的defaultStack拦截器栈会被替代掉&#xA;    自定义方法过滤拦截器&#xA;        # MethodFilterInterceptor继承AbstractInterceptor继承Interceptor，前两个是struts自己实现的自己的包装类&#xA;        ## 原理：自己实现intercept方法，实现对方法名的过滤。如果符合通过条件，则执行自己的doIntercept方法。所以要求用户重写doIntercept方法实现业务逻辑&#xA;        &amp;lt;interceptor name=&amp;quot;aloginInterceptor&amp;quot; class=&amp;quot;cn.it.shop.interceptor.AloginInterceptor&amp;quot;&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;excludeMethods&amp;quot;&amp;gt;*$&amp;lt;/param&amp;gt;                # 除了*$匹配的方法都执行此拦截器&#xA;                    ## includeMethods为包含匹配的方法执行拦截器&#xA;        &amp;lt;/interceptor&amp;gt;&#xA;    生命周期&#xA;        部署时初始化，每次符合&amp;lt;action&amp;gt;的请求时，执行拦截器&#xA;    拦截器Action 类&#xA;        o-&amp;gt; 继承Interceptor 接口&#xA;        o-&amp;gt; 重写生命周期方法&#xA;            String intercept(ActionInvocation invocation)方法中调用&#xA;                invocation.invoke() 放行&#xA;                invocation.getAction()得到当前的Action类&#xA;                invocation.getStack()得到值栈中的栈&#xA;                    # invocation用于调试18个拦截器&#xA;    具体拦截器&#xA;        struts-default.xml 文件中定义了32种拦截器&#xA;                alias&#xA;        autowiring&#xA;        chain&#xA;        conversionError&#xA;        cookie&#xA;        clearSession&#xA;        createSession&#xA;        debugging&#xA;        execAndWait&#xA;        exception&#xA;        fileUpload                                # 只用来验证已经注入的文件是否合格，合格则通过，不合格则不执行action类中对应请求的方法&#xA;        i18n&#xA;        logger&#xA;        modelDriven                                # 用于检查action类是否实现ModelDriven&amp;lt;T&amp;gt;接口，然后调用getModel()方法注入得到的对象到栈的项端。&#xA;        scopedModelDriven&#xA;        params                                        # 注入参数用，包括注入文件（级联注入文件的ContentType与FileName）&#xA;        actionMappingParams&#xA;        prepare&#xA;        staticParams&#xA;        scope&#xA;        servletConfig                                # 向自定义的实现RequestAware等接口的Action类（一般是BaseAction类）中注入request等相应的map对象&#xA;        timer&#xA;        token                                                # 防止重复提交&#xA;        tokenSession&#xA;        validation                                # 验证&#xA;        workflow&#xA;        store&#xA;        checkbox&#xA;        profiling&#xA;        roles&#xA;        annotationWorkflow&#xA;        multiselect&#xA;    数据传递&#xA;        o-&amp;gt; 拦截器不会向其它拦截器中注入参数，所以自定义拦截器中了参数要从request中获取&#xA;        o-&amp;gt; 如果想 显式的引用了自己的拦截栈，默认的拦截栈就不引用了，要自己引用，其中的注入参数拦截器向action类中注入参数&#xA;    技巧&#xA;        &amp;lt;interceptor-stack name=&amp;quot;defaultStack&amp;quot;&amp;gt;    # 对defaultStack进行替换，在它前面添加自定义的拦截器&#xA;        &amp;lt;interceptor-ref name=&amp;quot;aloginInterceptor&amp;quot;/&amp;gt;&#xA;        &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;/&amp;gt;&#xA;    拦截器中的ActionInvocation对象&#xA;        可以得到ActionContext&#xA;&#xA;# 文件处理&#xA;## 上传&#xA;    struts2文件上传步骤&#xA;        1.编写jsp文件&#xA;                1&amp;gt; post方式提交&#xA;                2&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file1&amp;quot;/&amp;gt; 要添加name属性&#xA;                3&amp;gt; post表单上传的编码方式是enctype=&amp;quot;multipart/formdata&amp;quot;&#xA;        2.创建Action类，不必继承任何类(但是如果不继承ActionSupport类的话，拦截器将不会返回提示消息)&#xA;                1&amp;gt; 定义参数        # 如果不接收上传文件名字符串数组而从文件对象中获取文件名的话，得到的文件名将会是乱码&#xA;                        private File[] image;                                                # 字段名&#xA;                        private String[] imageContentType;                        # 文件类型&#xA;                        private String[] imageFileName;                                # 文件名&#xA;                        private String uploadPath;&#xA;                                        # 前三个参数可以不是数组，在 struts-default.xml配置文件fileUpload拦截器对应的源码中可以找到定义规则：&#xA;                                                &amp;lt;li&amp;gt;[File Name] : File - the actual File&amp;lt;/li&amp;gt;&#xA;                                                &amp;lt;p/&amp;gt; &amp;lt;li&amp;gt;[FileName]ContentType : String - the content type of the file&amp;lt;/li&amp;gt;&#xA;                                                &amp;lt;p/&amp;gt;&amp;lt;li&amp;gt;[File Name]FileName : String - the actual name of the file uploaded(not the HTML name)&amp;lt;/li&amp;gt;&#xA;                                        # uploadPath是我们自定义的配置文件中注入过来的文件存储位置&#xA;&#xA;                2&amp;gt; 写execute方法保存文件到路径，返回成功消息&#xA;        3.Action类的配置文件，include到src/struts.xml文件中&#xA;                        1&amp;gt; &amp;lt;action&amp;gt;标签中配置name=&amp;quot;input&amp;quot;的标签&amp;lt;result&amp;gt;来返回出错消息&#xA;                        2&amp;gt; &amp;lt;action&amp;gt;标签中用param标签注入文件存储路径：uploadPath 底层执行setUploadPath()方法&#xA;                        3&amp;gt; &amp;lt;action&amp;gt;标签中通过&amp;lt;interceptor-ref name=&amp;quot;fileUpload&amp;quot;&amp;gt;标签对上传文件进行参数上的限定&#xA;                                1&amp;gt; &amp;lt;param name=&amp;quot;maximumSize&amp;quot;&amp;gt; 单个文件的最大尺寸(字节)&#xA;                                2&amp;gt; &amp;lt;param name=&amp;quot;allowedExtensions&amp;quot;&amp;gt; 文件扩展名&#xA;                                3&amp;gt; &amp;lt;param name=&amp;quot;allowedTypes&amp;quot;&amp;gt; 文件实际类型，如image/jpeg，可从tomcat配置文件web.xml中查找&#xA;        4.配置返回消息的信息&#xA;                ：src/struts.properties文件中&#xA;                        struts.custom.i18n.resources=struts                # 解锁自/org/apache/struts2/default.properties总配置文件&#xA;                                        # 加载自己，=后面是参照src/目录的相对路径 ，省略掉.properties扩展名&#xA;                        struts.multipart.maxSize=2097152                #  解锁自/org/apache/struts2/default.properties总配置文件&#xA;                                        # 设置上传文件总量的大小&#xA;                        struts.messages.error.file.too.large=\u6587\u4EF6\u592A\u5927\: {0} &amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; {3}&#xA;                        struts.messages.error.content.type.not.allowed=\u6587\u4EF6\u7C7B\u578B\u4E0D\u6B63\u786E\: {0} &amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; {3}&#xA;                        struts.messages.error.file.extension.not.allowed=\u6269\u5C55\u540D\u4E0D\u6B63\u786E\: {0} &amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; {3}&#xA;                                        # 覆盖/org/apache/struts2/default.properties总配置文件的响应消息,=后面是中文的unicode编码的iso8859-1的表示形式，通过视图可以直接配置，也可以用java/bin目录下的native2ascii.exe工具进行转码&#xA;&#xA;    多文件上传&#xA;        出现有多个文件共同上传时，文件拦截器会出现一错全错的情况，这时我们利用struts的一个&#xA;                小bug---文件拦截不成功也调用action类的setXxx方法传入文件，从set函数中对文件进行筛选和转存&#xA;                这时文件拦截器已经形同虚设，一点作用也不起了。&#xA;&#xA;    原理过程&#xA;        1.上传请求经过struts2的过滤器匹配扩展名&#xA;        2.按src/struts.xml文件中声明的配置包映射的名称空间映射到配置包&#xA;        3.根据action标签的name属性匹配名称空间与扩展名之间的“文件名”,映射到该action标签&#xA;                1&amp;gt; 经过多层拦截器&#xA;                2&amp;gt; 用param标签注入文件存储路径&#xA;                3&amp;gt; 通过&amp;lt;interceptor-ref name=&amp;quot;fileUpload&amp;quot;&amp;gt;标签对上传文件进行参数上的限定&#xA;                2&amp;gt; 执行action标签对应类的方法，该方法返回的返回的字符串进行响应&#xA;&#xA;    默认配置&#xA;        1.defaultStack拦截栈中的fileUpload拦截器进行处理&#xA;        2.default.properties配置文件中 对multipart的上传方式进行了配置&#xA;                struts.multipart.parser=jakarta                  # struts使用了第三方的jakerta来给上传文件解码&#xA;                struts.multipart.saveDir=                      # 缓存文件的临时目录，不填默认是&#xA;                                                                                        ## work/catalina/localhost/web工程名/upload_.....00000..tmp&#xA;                struts.multipart.maxSize=2097152      # 默认支持的上传文件的大小 (字节，2m)，是总大小&#xA;        3.多数服务器自己删除缓存文件&#xA;## 下载&#xA;    用传递类型为stream 来返回要下载的文件&#xA;    写法&#xA;        &amp;lt;result name=&amp;quot;success&amp;quot; type=&amp;quot;stream&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- 下载文件的类型 --&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;contentType&amp;quot;&amp;gt;image/pjpeg&amp;lt;/param&amp;gt;&#xA;            &amp;lt;!-- byte[]的大小，单位字节 --&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;bufferSize&amp;quot;&amp;gt;2048&amp;lt;/param&amp;gt;&#xA;            &amp;lt;!-- 设置下载响应头，${uuidFileName}是一个OGNL表达式，不是EL表达式 --&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;contentDisposition&amp;quot;&amp;gt;attachment;filename=${uuidFileName}&amp;lt;/param&amp;gt;&#xA;            &amp;lt;!-- 框架调用getXxx()方法，来获取InputStream流对象 --&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;inputName&amp;quot;&amp;gt;imageStream&amp;lt;/param&amp;gt;&#xA;        &amp;lt;/result&amp;gt;&#xA;            # 与其它同样，要注入的参数从stream类型对应的类中可以进行查看&#xA;    显示与下载的编码问题&#xA;        o-&amp;gt; 设置tomcat/conf/server.xml&#xA;            &amp;lt;Connector port=&amp;quot;8080&amp;quot; .. URIEncoding=&amp;quot;utf-8&amp;quot;/&amp;gt;&#xA;        o-&amp;gt; 提交下载请求用post方式，struts框架自动给post请求编码解码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据&#34;&gt;&#xA;  数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;日志-1&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;scribe&#xA;    facebook出品&#xA;    特点&#xA;        支持nfs存储&#xA;    结构&#xA;        scribe agent&#xA;            向scribe发送数据&#xA;        scribe&#xA;            接收数据，不同topic 的数据发送给不同的store中&#xA;        存储系统(store)&#xA;            file, buffer, network, bucket, null, thriftfile, multi&#xA;chukwa&#xA;    # apache出品，hadoop系列产品&#xA;flume&#xA;    cloudera出品&#xA;    特点&#xA;        可靠性(节点故障时，日志传送到其他节点)&#xA;            三种级别&#xA;                end-to-end 发送前写磁盘，成功时删除&#xA;                store on failure 失败返回时写磁盘&#xA;                best effort 不确认数据是否成功&#xA;        可扩展性&#xA;            agent collector storage三层架构，每层可扩展。&#xA;                agent: 将数据源数据发送给collector&#xA;                collector: 将多个agent数据汇总后, 加载到storage中&#xA;                storge: 存储系统, 可以是file, hdfs, hive, hbase等&#xA;            agent collector 由master统一&#xA;logstash&#xA;    # 分布式日志收集，需结合kafka&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;爬虫&#34;&gt;&#xA;  爬虫&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%88%ac%e8%99%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;cheerio&#xA;    # node解析html，如jquery&#xA;scrapy-redis&#xA;    # python 分布式爬虫框架&#xA;phantomjs&#xA;    # js浏览器模拟框架&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分析&#34;&gt;&#xA;  分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pandas&#xA;    # python数据分析&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;计算&#34;&gt;&#xA;  计算&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;druid&#xA;    # apache&#xA;    特点&#xA;        分布式, 扩展性强&#xA;        高可用，可回滚&#xA;        内存, 时序数据库&#xA;        亚秒级OLAP,  实时分析&#xA;        多租户&#xA;spark&#xA;stream&#xA;hadoop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;搜索&#34;&gt;&#xA;  搜索&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%90%9c%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    垂直搜索引擎&#xA;        针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。&#xA;    通用搜索引擎&#xA;        通过关键字的方式实现的，是语义上的搜索，返回的结果倾向于知识成果，比如文章，论文，新闻等&#xA;        通用搜索引擎的信息量大、查询不准确、深度不够&#xA;        通用搜索引擎的海量信息无序化&#xA;&#xA;部分&#xA;    １.索引&#xA;    ２.分词&#xA;    ３.搜索&#xA;&#xA;compass&#xA;    # 基于lucene&#xA;nutch&#xA;    # 基于lucene&#xA;sunspot&#xA;    # 基于Rsolr，以dsl结构用ruby调solr&#xA;sphinx&#xA;    # 基于sql的全文检索引擎&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;lucene&#34;&gt;&#xA;  lucene&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lucene&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 原理&#xA;    block k-d tree&#xA;    倒排索引&#xA;        词典&#xA;            排序数组&#xA;                # 为了二分查找&#xA;                # 实现简单，性能差&#xA;            哈希表&#xA;                # 性能好，占内存大&#xA;            跳跃表&#xA;                # 内存小且可调节, 模糊查询不好&#xA;            B/B+树&#xA;                # 磁盘索引 ，更新方便，检索慢&#xA;            trie树&#xA;                # 效率与字符串长度有关，只适合做英文词典&#xA;            dat&#xA;                # 可做中文词典，内存占用小&#xA;            fst&#xA;                # 共享前缀，内存占用小，要求输入有序，不易更新&#xA;                内存存前缀索引、磁盘存后缀词块&#xA;        倒排表&#xA;        正向文件&#xA;            # 行式存储，原始文档&#xA;        doc-values&#xA;            # 列式存储，文档号到值的映射&#xA;    文件指纹&#xA;&#xA;# 概念&#xA;    index&#xA;        # 一个倒排表，对应一个目录&#xA;    segment&#xA;        # index的存储单元，包含多个文档&#xA;    document&#xA;        # 创建单位&#xA;    field&#xA;        # 文档里的键值对&#xA;    term&#xA;        # 分词后的字符串&#xA;    analyzer&#xA;        tokenizer&#xA;            # 切分文本到索引单元&#xA;        tokenfilter&#xA;            # 对token预处理&#xA;# 常识&#xA;    特性&#xA;        索引&#xA;        高亮&#xA;        命中率排序&#xA;        分词&#xA;    与数据库的区别：数据库注重存储、全文检索注重查询&#xA;    其它搜索：多媒体搜索&#xA;    索引库(文件夹 或 内存中)：&#xA;        只存储了商品的基本信息&#xA;         索引库与数据库定时同步&#xA;        索引库 -&amp;gt; document -&amp;gt; field                # field是键值对,值只能存数据&#xA;                同步&#xA;        IndexWriter:addDocumnet(),delteDocument(),updateDocument()&#xA;                查询&#xA;                        IndexSearch:search(),get()&#xA;        Field的内部结构&#xA;                    # 不存不索引会报错&#xA;        Store:控制此Field字段是否存储到索引库中&#xA;        Index:是否建立索引（索引不区分大小写,过滤词不创建索引）&#xA;            NO:不建立索引，可以通过field的key查到，但是不能通过关键字查询到&#xA;            NOT_ANALYZED:建立索引，但是不分词&#xA;            ANALYZEd:建立索引又分词&#xA;# 使用到的对象&#xA;    Directory&#xA;    Analyzer&#xA;        TokenStream tokenStream = analyzer.tokenStream(&amp;quot;eldName&amp;quot;,new StringReader(&amp;quot;测试字符串&amp;quot;))&#xA;        while(tokenStream.incrementToken()){&#xA;                TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class);&#xA;                System.out.println(termAttribute.term());&#xA;        }                # 使用分词器测试分词&#xA;    Document&#xA;        add(Field)&#xA;        document = indexSearcher.doc(ScoreDoc)&#xA;        get(String)                # 通过key查找value&#xA;    IndexWriter&#xA;        IndexWriter(directory,analyzer,MaxFieldLength.LIMITED);       # LIMITED限定Field的数量(源码中规定默认值)&#xA;        addDocument(Document)&#xA;        commit()&#xA;        close()                        # 自带commit()&#xA;        rollback()&#xA;    IndexSearcher&#xA;    QueryParser&#xA;        QueryParser(Version.LUCENE_30,&amp;quot;name&amp;quot;,analyzer)&#xA;    Query&#xA;        query = parser.parse(用户传递的字符串);&#xA;        query = parser.parseMultiField(String [], 用户传递的字符串);&#xA;    TopDocs&#xA;        topDocs = indexSearcher.search(query, 10);                # 10是期望的结果数&#xA;                                                                                                        ## 最终查询到的结果数是：期望结果数与实际结果数的最小值&#xA;        totalHits                # 命中的结果数&#xA;    ScoreDoc&#xA;        ScoreDoc [] scoreDocs = topDocs.scoreDocs;&#xA;        scoreDoc.score                # 命中率积分&#xA;        scoreDoc.doc                # 命中文档编号，该编号由lucene自动生成&#xA;    Term                # 索引项&#xA;        Term(&amp;quot;field中的key&amp;quot;,&amp;quot;field中value解析出的关键字&amp;quot;)&#xA;# 索引的结构&#xA;    Term(&amp;quot;key&amp;quot;,&amp;quot;value&amp;quot;)[0,3,4]                        # key 为对应的field中的&amp;quot;key&amp;quot;,value对应的是解析field的&amp;quot;value&amp;quot;出的关键字&#xA;                                                                                ## []中的内容为匹配的文档编号，该编号为系统自动生成的&#xA;# 注意&#xA;    lucene创建索引时field的key都可以重复，没有主键方面的限制。但是实际应用时要求我们为document有唯一的标识“主键”field,便于对每个document进行更新与删除&#xA;# 使用&#xA;    包：IKAnalyzer,lucence-analyzer(英文分词，不需要),memory,core,highlighter&#xA;    工具：lukeAll 用来查看索引库&#xA;    添加、查询、删除、修改&#xA;    抽取配置类（构造方法私有化）&#xA;        Configuration&#xA;            维护了directory与analyzer&#xA;        DocumentUtil&#xA;            goodsToDocument(Goods)&#xA;            documentToGoods(Document)&#xA;        LuceneUtil&#xA;            维护了indexWriter与indexSearcher&#xA;            注意&#xA;                    1.indexWriter在static代码块中初始化&#xA;                    2.getIndexWriter&#xA;        LuceneService&#xA;            用indexWriter与indexSearcher处理业务逻辑&#xA;            添加&#xA;                indexWriter.addDocument(Document)&#xA;                indexWriter.rollback()&#xA;            删除&#xA;                indexWriter.deleteDocument(Term)&#xA;                indexWriter.optimize()                # 删除document的时候同步索引库，没有设置的话只是删除document，但是索引中还是可以查到&#xA;            更新&#xA;                indexWriter.updateDocument(Term,Document)&#xA;                indexWriter.optimize()                # 更新是先删除再添加（所以如果updateDocument(Term,Document)中匹配多个Document时，会出现删除了多个Document,而添加了一个Document的情况）&#xA;            查询&#xA;                QueryParser parser = new QueryParser(Version.LUCENE_30, &amp;quot;field中的key&amp;quot;, analyzer);&#xA;                Query query = IKQueryParser.parseMultiField(new String[]{&amp;quot;name&amp;quot;,&amp;quot;remark&amp;quot;}, &amp;quot;ee&amp;quot;);                # 多字段查询，IKAnalyzer特有&#xA;                    #　多字段查询到的第二个字段的结果，在转换高管时（调用getBestFragment时）只会对该方法指定的一个字段进行匹配，如果该字段不匹配时（但是第二个字段匹配），则会返回空。&#xA;                    ## 针对这一个bug,在getBestFragment处理匹配的结果返回空时，不使用空而直接返回没有高亮的字符串即可。&#xA;                parser.parse(用户传递的字符串);&#xA;                TopDocs topDocs = indexSearcher.search(query, 3);        # 3是期望结果数&#xA;                ScoreDoc [] scoreDocs = topDocs.scoreDocs;&#xA;                Document document = indexSearcher.doc(scoreDoc.doc);                scoreDoc.doc得到文档编号&#xA;                分页查询：&#xA;                    传递当前页码与一页记录数&#xA;                    利用topDocs.totalHits得到总记录数&#xA;                    查询本页与前面所有页的期望数据量，然后只截取本页的文档编号，得到document并返回数据&#xA;&#xA;# 分词器&#xA;    IKAnalyzer&#xA;        配置文件&#xA;            src/IKAnalyzer.cfg.xml中配置&#xA;                &amp;lt;properties&amp;gt;&#xA;                    &amp;lt;entry key=&amp;quot;ext_dict&amp;quot;&amp;gt;/mydict.dic&amp;lt;/entry&amp;gt;                 # 配置自己的字典（不分词）&#xA;                    &amp;lt;entry key=&amp;quot;ext_stopwords&amp;quot;&amp;gt;/ext_stopword.dic&amp;lt;/entry&amp;gt;                 # 配置跳过的字&#xA;                &amp;lt;/properties&amp;gt;&#xA;        Query query = IKQueryParser.parse(&amp;quot;name&amp;quot;,name);                # IKAnalyzer特有&#xA;# 排序&#xA;    Directory directory = FSDirectory.open(new File(&amp;quot;d:/lucene&amp;quot;));&#xA;    IndexSearcher indexSearcher = new IndexSearcher(directory);&#xA;    Query query = IKQueryParser.parse(&amp;quot;name&amp;quot;,&amp;quot;cc&amp;quot;);&#xA;    Sort sort = new Sort(new SortField(&amp;quot;id&amp;quot;, SortField.INT,true));                # 这里可以排序多个字段&#xA;        # 参数1：&amp;quot;id&amp;quot;是排序的field字段,参数2：是字段内容的类型,参数3 true代表降序排列&#xA;        ## 此时命中率不再计算（因为不按命中率排序）&#xA;        ## 排序的field必须建立索引&#xA;    indexSearcher.search(query, null,10,sort);&#xA;高亮&#xA;    导入包:highlight与memory&#xA;    Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(&amp;quot;&amp;lt;font color=&#39;red&#39;&amp;quot;,&amp;quot;&amp;lt;/font&amp;gt;&amp;quot;),new QueryScorer(query));&#xA;    highlighter.setTextFragmenter(new SimpleFragmenter(10));                # 限制字符长度&#xA;    ..&#xA;    String result = highlighter.getBastFragment(analyzer,&amp;quot;name&amp;quot;,doc.get(&amp;quot;name&amp;quot;));&#xA;        # 返回高亮处理字符串&#xA;        ## 参数1：解析用户输入词的分词器,参数2：是要查询的field的key(没有用)，参数3：field的value&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;solr&#34;&gt;&#xA;  solr&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#solr&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基于lucene&#xA;    搜索服务器，http请求提交和返回xml&#xA;功能&#xA;    丰富了查询语言&#xA;    实现可配置、可扩展&#xA;    优化了性能&#xA;    提供了管理界面&#xA;    缓存功能&#xA;    垂直搜索&#xA;    高亮&#xA;    data schema定义字段&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;elasticsearch&#34;&gt;&#xA;  elasticsearch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elasticsearch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基于lucene&#xA;性能&#xA;    第一次查秒级响应(5-10秒)，放到文件系统缓存(filesystem cache)&#xA;    再查命令缓存毫秒级响应                              # 热点数据要预热&#xA;    文件系统缓存(内存中分配)和数据量同样大，才有效率        # 冷热分离&#xA;&#xA;    分页，会查前面所有数据                              # 用scroll api, 快照 + 游标&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;权限&#34;&gt;&#xA;  权限&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;shiro&#34;&gt;&#xA;  shiro&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shiro&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;功能&#xA;    认证&#xA;    授权&#xA;    加密&#xA;    会话管理&#xA;    Web集成&#xA;    缓存&#xA;组件&#xA;    Subject     # 当前用户,绑定到SecurityManager&#xA;    SecurityManager     # 门面模式，管理组件&#xA;    Realms      # 连接认证数据(用户、角色、权限)&#xA;    Authenticator   # 认证principals和credentials&#xA;    Authorizer  # 校验权限&#xA;    SessionManager      # 异构客户端&#xA;控制方式&#xA;    url&#xA;    注解&#xA;    代码&#xA;    页面标签&#xA;模块&#xA;    Authenticator&#xA;        # SecurityManager继承Authenticator&#xA;        public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  throws AuthenticationException;&#xA;    permission&#xA;        概念&#xA;            subject&#xA;            resource&#xA;            permission&#xA;            role&#xA;                隐式角色&#xA;                显示角色&#xA;        配置&#xA;            shiro.ini&#xA;                [users]&#xA;                zhang=123, role1, role2                # 用户名=密码, 角色1, 角色2&#xA;        判断角色&#xA;            o-&amp;gt;&#xA;                subject.hasRole(&amp;quot;admin&amp;quot;);&#xA;            o-&amp;gt;&#xA;                @RequiresRoles(&amp;quot;admin&amp;quot;)&#xA;                @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)&#xA;                    # 表示当前Subject需要角色admin和user。&#xA;            o-&amp;gt;&#xA;                &amp;lt;shiro:hasRole name=&amp;quot;admin&amp;quot;&amp;gt;&amp;lt;/shiro:hasRole&amp;gt;&#xA;        权限注解&#xA;            @RequiresAuthentication&#xA;                # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。&#xA;            @RequiresUser&#xA;                # 表示当前Subject已经身份验证或者通过记住我登录的。&#xA;            @RequiresGuest&#xA;                # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。&#xA;            @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)&#xA;                # 表示当前Subject需要权限user:a或user:b。&#xA;    credential&#xA;        散列&#xA;            String str = &amp;quot;hello&amp;quot;;&#xA;            String salt = &amp;quot;123&amp;quot;;&#xA;            //内部使用MessageDigest&#xA;            String simpleHash&#xA;        密码生成工具&#xA;            //输入明文密码得到密文密码&#xA;            String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;&#xA;            //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）&#xA;            boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);&#xA;    filter&#xA;        NameableFilter                        ＃根据名字找到相应的拦截器实例&#xA;        OncePerRequestFilter                # 控制开启、关闭拦截器实例&#xA;        ShiroFilter                        # 安全控制&#xA;        AdviceFilter                        # aop&#xA;            preHandle                        # 前置增强&#xA;            postHandle                        # 后置增强&#xA;            afterCompletion                # 后置最终增强(异常也执行，相当于finally的概念)&#xA;        PathMatchingFilter                # 匹配请求路径&#xA;        AccessControlFilter                # 允许或拒绝访问，拒绝时如何处理&#xA;    jsp标签&#xA;        &amp;lt;%@taglib prefix=&amp;quot;shiro&amp;quot; uri=&amp;quot;http://shiro.apache.org/tags&amp;quot; %&amp;gt;&#xA;&#xA;        &amp;lt;shiro:guest&amp;gt;&#xA;        欢迎游客访问，&amp;lt;a href=&amp;quot;${pageContext.request.contextPath}/login.jsp&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&#xA;        &amp;lt;/shiro:guest&amp;gt;&#xA;&#xA;        &amp;lt;shiro:user&amp;gt;&#xA;        欢迎[&amp;lt;shiro:principal/&amp;gt;]登录，&amp;lt;a href=&amp;quot;${pageContext.request.contextPath}/logout&amp;quot;&amp;gt;退出&amp;lt;/a&amp;gt;&#xA;        &amp;lt;/shiro:user&amp;gt;&#xA;            # 用户已经身份验证/记住我登录后显示相应的信息。&#xA;&#xA;        &amp;lt;shiro:authenticated&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]已身份验证通过&#xA;        &amp;lt;/shiro:authenticated&amp;gt;&#xA;            # 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。&#xA;&#xA;        &amp;lt;shiro:notAuthenticated&amp;gt;&#xA;            未身份验证（包括记住我）&#xA;        &amp;lt;/shiro:notAuthenticated&amp;gt;&#xA;            # 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证。&#xA;&#xA;        &amp;lt;shiro: principal/&amp;gt;&#xA;            # 显示用户身份信息，默认调用Subject.getPrincipal()获取&#xA;            &amp;lt;shiro:principal type=&amp;quot;java.lang.String&amp;quot;/&amp;gt;&#xA;            &amp;lt;shiro:principal property=&amp;quot;username&amp;quot;/&amp;gt;&#xA;&#xA;        &amp;lt;shiro:hasRole name=&amp;quot;admin&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]拥有角色admin&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:hasRole&amp;gt;&#xA;&#xA;        &amp;lt;shiro:hasAnyRoles name=&amp;quot;admin,user&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]拥有角色admin或user&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:hasAnyRoles&amp;gt;&#xA;&#xA;        &amp;lt;shiro:lacksRole name=&amp;quot;abc&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]没有角色abc&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:lacksRole&amp;gt;&#xA;                        # 如果当前Subject没有角色将显示body体内容。&#xA;&#xA;        &amp;lt;shiro:hasPermission name=&amp;quot;user:create&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]拥有权限user:create&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:hasPermission&amp;gt;&#xA;&#xA;        &amp;lt;shiro:lacksPermission name=&amp;quot;org:create&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]没有权限org:create&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:lacksPermission&amp;gt;&#xA;    session&#xA;        得到会话&#xA;            login(&amp;quot;classpath:shiro.ini&amp;quot;, &amp;quot;zhang&amp;quot;, &amp;quot;123&amp;quot;);&#xA;            Subject subject = SecurityUtils.getSubject();&#xA;            Session session = subject.getSession();&#xA;        api&#xA;            Session&#xA;                getId()&#xA;                getHost()                # 调用HostAuthenticationToken.getHost(), 得到主机地址&#xA;                getTimeout()&#xA;                setTimeout(1000)&#xA;                getStartTimestamp()&#xA;                setLastAccessTime()&#xA;                touch()                        # 更新会话最后访问时间&#xA;                stop()                        # 销毁会话, Subject.logout()与HttpSession.invalidate()会自动调用该api&#xA;                setAttribute(&amp;quot;key&amp;quot;, &amp;quot;123&amp;quot;)&#xA;                getAttribute(&amp;quot;key&amp;quot;)&#xA;                removeAttribute(&amp;quot;key&amp;quot;)&#xA;            SecurityManager&#xA;                Session start(SessionContext context)&#xA;                Session getSession(SessionKey key) throws SessionException&#xA;            WebSessionManager&#xA;                boolean isServletContainerSessions();                # 是否使用Servlet容器的会话&#xA;            ValidatingSessionManager&#xA;                void validateSessions();                                # 验证所有会话是否过期&#xA;    cache&#xA;        接口&#xA;            Cach&amp;lt;K, V&amp;gt;&#xA;            CacheManager&#xA;            CacheManagerAware&#xA;        ini配置&#xA;            userRealm.cachingEnabled                        # 启用缓存，默认false&#xA;            userRealm.authenticationCachingEnabled        # 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false&#xA;            userRealm.authenticationCacheName                # 缓存AuthenticationInfo信息的缓存名称&#xA;            userRealm. authorizationCachingEnabled        # 启用授权缓存，即缓存AuthorizationInfo信息，默认false&#xA;            userRealm. authorizationCacheName                # 缓存AuthorizationInfo信息的缓存名称&#xA;            securityManager.realms=$userRealm&#xA;&#xA;            cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager&#xA;            cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml&#xA;            securityManager.cacheManager=$cacheManager&#xA;&#xA;            sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager&#xA;            securityManager.sessionManager=$sessionManager&#xA;    rememberme&#xA;    ssl&#xA;        o-&amp;gt; keytool -genkey -keystore &amp;quot;D:\localhost.keystore&amp;quot; -alias localhost -keyalg RSA&#xA;            # jdk自带的生成证书工具(包含证书/公钥/私钥）&#xA;        o-&amp;gt; 设置tomcat server.xml&#xA;            &amp;lt;Connector port=&amp;quot;8443&amp;quot; protocol=&amp;quot;HTTP/1.1&amp;quot; SSLEnabled=&amp;quot;true&amp;quot;&#xA;            maxThreads=&amp;quot;150&amp;quot; scheme=&amp;quot;https&amp;quot; secure=&amp;quot;true&amp;quot;&#xA;            clientAuth=&amp;quot;false&amp;quot; sslProtocol=&amp;quot;TLS&amp;quot;&#xA;            keystoreFile=&amp;quot;D:\localhost.keystore&amp;quot; keystorePass=&amp;quot;123456&amp;quot;/&amp;gt;&#xA;        o-&amp;gt;&#xA;    jasig cas&#xA;api&#xA;    Subject: 主体, 如用户&#xA;    SecurityManager: 安全管理器, 管理subject&#xA;    Realm: 权限数据域&#xA;&#xA;    授权&#xA;        对象流程&#xA;            Subject.isPermitted -&amp;gt; SecurityManager -&amp;gt; Authorizer&#xA;        对象&#xA;            ModularRealmAuthorizer        # 多realm授权&#xA;            PermissionResolver                # 解析权限字符串到Permission实例&#xA;            RolePermissionResolver                # 从角色得到权限集合&#xA;配置&#xA;    参数&#xA;        filterChainDefinitions&#xA;            rest：比如/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user：method] ,其中method为post，get，delete等。&#xA;&#xA;            port：比如/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal：//serverName：8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。&#xA;&#xA;            perms：比如/admins/user/**=perms[user：add：*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，比如/admins/user/**=perms[&amp;quot;user：add：*,user：modify：*&amp;quot;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。&#xA;&#xA;            roles：比如/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，比如/admins/user/**=roles[&amp;quot;admin,guest&amp;quot;],每个参数通过才算通过，相当于hasAllRoles()方法。&#xA;&#xA;            anon：比如/admins/**=anon 没有参数，表示可以匿名使用。&#xA;&#xA;            authc：比如/admins/user/**=authc表示需要认证才能使用，没有参数&#xA;&#xA;            authcBasic：比如/admins/user/**=authcBasic没有参数表示httpBasic认证&#xA;&#xA;            ssl：比如/admins/user/**=ssl没有参数，表示安全的url请求，协议为https&#xA;&#xA;            user：比如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查&#xA;                    # remember me可登录&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;分布式&#34;&gt;&#xA;  分布式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;redisson&#34;&gt;&#xA;  redisson&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redisson&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    使用redis外部存储，实现分布式功能&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ukeate.com/docs/middleware/container/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ukeate.com/docs/middleware/container/</guid>
      <description></description>
    </item>
  </channel>
</rss>
