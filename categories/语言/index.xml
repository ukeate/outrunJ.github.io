<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>语言 on ukeate的笔记</title>
    <link>https://ukeate.com/categories/%E8%AF%AD%E8%A8%80/</link>
    <description>Recent content in 语言 on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 01 Jan 2025 08:31:29 -0700</lastBuildDate>
    <atom:link href="https://ukeate.com/categories/%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>程序语言</title>
      <link>https://ukeate.com/docs/pl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ukeate.com/docs/pl/</guid>
      <description>&lt;h1 id=&#34;c&#34;&gt;&#xA;  c&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;库&#xA;    libvirt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;c-1&#34;&gt;&#xA;  c++&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#c-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;问题&#xA;    野指针、迷途指针 Double Free问题&#xA;    智能指针&#xA;    RAII资源获取就是初始化&#xA;    二级指针&#xA;库&#xA;    opencv&#xA;            iplimage&#xA;                    # 图像处理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;php&#34;&gt;&#xA;  php&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#php&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;安装&#xA;        php, php-cgi, php-fpm&#xA;    编译安装&#xA;        yum install libxml2-devel  openssl-devel  bzip2-devel libmcrypt-devel  -y&#xA;        ./configure --prefix=/opt/zly/php --with-mysql=mysqlnd --with-openssl --with-mysqli=mysqlnd --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml  --enable-sockets --enable-fpm --with-mcrypt  --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --with-bz2&#xA;        make&#xA;        make install&#xA;        cp php.ini-production /etc/php.ini&#xA;        cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm&#xA;        chmod +x /etc/rc.d/init.d/php-fpm&#xA;        cp /opt/zly/php/etc/php-fpm.conf.default /opt/zly/php/etc/php-fpm.conf&#xA;        chkconfig --add php-fpm&#xA;        chkconfig php-fpm on&#xA;        /etc/init.d/php-fpm start&#xA;命令&#xA;        php -S localhost:8000 -t dir/&#xA;配置&#xA;        /etc/php/php.ini&#xA;        date.timezone = Europe/Berlin&#xA;            # 时区设置&#xA;        display_errors = On&#xA;&#xA;&#xA;框架&#xA;    zend opcache&#xA;        # php5.5集成，把php执行后的数据缓冲到内存中从而避免重复编译&#xA;工具&#xA;    fpm&#xA;        # php fastCGI 进程管理器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;scheme&#34;&gt;&#xA;  scheme&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#scheme&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 特点&#xA;    词法定界(Lexical Scoping)&#xA;    动态类型(Dynamic Typing)&#xA;    良好的可扩展性&#xA;    尾递归(Tail Recursive)&#xA;    函数作为值返回&#xA;    计算连续&#xA;    传值调用(passing-by-value)&#xA;    算术运算相对独立&#xA;# 标准&#xA;    R5RS (Revised5 Report on the Algorithmic Language Scheme)&#xA;    Guile (GNU&#39;s extension language)&#xA;# guile脚本中(.scm)&#xA;    #! /usr/local/bin/guile -s&#xA;    !#&#xA;&#xA;# 语法&#xA;    注释&#xA;        ;&#xA;                # 注释到行尾&#xA;        #! ... !#&#xA;                # 标准中没有，实现中有的多行注释&#xA;    类型&#xA;        1&#xA;        &#39;symbol&#xA;        &amp;quot;str&amp;quot;&#xA;        true, false&#xA;        struct&#xA;        empty&#xA;            # 表示一个空表&#xA;    块(form)&#xA;        (define x 123)&#xA;        (set! x &amp;quot;abc&amp;quot;)&#xA;        (+ 1 2)&#xA;        (* (+ 2 (* 3 4)) (+ 5 6 7))&#xA;        (display &amp;quot;hello world&amp;quot;)&#xA;        (not #f)&#xA;            # #t&#xA;        (not #t)&#xA;            # #f&#xA;            # not 后不是逻辑型，都返回#f&#xA;&#xA;    非精确数&#xA;        (- #i1.0 #i0.9)&#xA;    函数&#xA;        or&#xA;        and&#xA;        not&#xA;        (sqrt A)&#xA;        (expt A B)&#xA;            # A^B&#xA;        (remainder A B)&#xA;            # A%B&#xA;        (log A)&#xA;            # A的自然对数&#xA;        (sin A)&#xA;        (cond&#xA;            [(&amp;lt; n 10) 5.0]&#xA;            [else .06])&#xA;        (if (&amp;lt; x 0)&#xA;            (- x)&#xA;            x)&#xA;        (symbol=? &#39;Hello x)&#xA;            # 符号，比较。符号还有字符串和图像&#xA;        (string=? &amp;quot;the dog&amp;quot; x)&#xA;            # 字符串，系统看作符号&#xA;        (make-posn 3 4)&#xA;            # 创建posn结构体&#xA;            (poson-x (make-posn 7 0))&#xA;                # 7&#xA;        (define-struct posn (x y))&#xA;            # 定义结构体&#xA;        (number?)&#xA;        (boolean?)&#xA;        (struct?)&#xA;        (zero?)&#xA;        (posn?)&#xA;            # 可以是自定义结构体名&#xA;        (null?)&#xA;            # 检查是否空list&#xA;        (eq? i list)&#xA;            # 元素i是否在list中， 否返回false, 是返回所在的子表&#xA;            # 可以比较符号&#xA;        (memq)&#xA;            # eq?的内部调用&#xA;        (error &#39;&#39;checked-number &amp;quot;number expected&amp;quot;)&#xA;            # 马上出错&#xA;        (cons &#39;Mercury empty)&#xA;            # push&#xA;            (cons? alon)&#xA;                # 是否有元素&#xA;            (define x (cons 1 2))&#xA;                # 序对, 可嵌套&#xA;                (car x)&#xA;                    # 1&#xA;                (cdr x)&#xA;                    # 2&#xA;        (define (dispatch m)&#xA;            # 传0返回x, 传1返回y&#xA;            (cond ((= m 0) x)&#xA;                ((= m 1) y)&#xA;                (else (error &amp;quot;&amp;quot; m))))&#xA;        (first)&#xA;        (rest)&#xA;        (list (list &#39;bob 0 &#39;a) (list &#39;car1 1 &#39;a))&#xA;        (local)&#xA;            # 局部定义使用&#xA;        (lambda)&#xA;            # 匿名函数&#xA;        (append)&#xA;        (set! x 5)&#xA;# 例子&#xA;    复合数据&#xA;        (define-struct student (last first teacher))&#xA;        (define (subst-teacher a-student a-teacher)&#xA;            (cond&#xA;                [(symbol=? (student-teacher a-student) &#39;Fritz)&#xA;                    # 如果教师的名字是&#39;Fritz&#xA;                    (make-student (student-last a-student)&#xA;                        # 创建student结构体，设置新教师名&#xA;                        (student-first a-student)&#xA;                        a-teacher)]&#xA;                [else a-student]))&#xA;    递归列表&#xA;        (define (contains-doll? a-list-of-symbols)&#xA;            (cond&#xA;                [(empty? a-list-of-symbols) false]&#xA;                [else (cond&#xA;                    [(symbol=? (first a-list-of-symbols) &#39;doll) true]&#xA;                    [else (contains-doll? (rest a-list-of-symbols))])]))&#xA;    排序&#xA;        (define (sort alon)&#xA;            (cond&#xA;                [(empty? alon) empty]&#xA;                [(cons? alon) (insert (first alon) (sort (rest alon)))]))&#xA;        (define (insert n alon)&#xA;            (cond&#xA;                [(empty? alon) (cons n empty)]&#xA;                [else (cond&#xA;                    [(&amp;gt;= n (first alon)) (cons n alon)]&#xA;                    [(&amp;lt; n (first alon)) (cons (first alon) (insert n (rest alon)))])]))&#xA;    or函数&#xA;        (define (blue-eyed-ancestor? a-ftree)&#xA;            (cond&#xA;                [(empty? a-ftree) false]&#xA;                [else (or (symbol=? (child-eyes a-ftree) &#39;blue)&#xA;                    (or (blue-eyed-ancestor? (child-father a-ftree))&#xA;                        (blue-eyed-ancestor? (child-mother a-ftree))))]))&#xA;    列表替换&#xA;        (define (replace-eol-with alon1 alon2)&#xA;            (cond&#xA;                ((empty? alon1) alon2)&#xA;                (else (cons (first alon1) (replace-eol-with (rest alon1) alon2)))))&#xA;    列表相等&#xA;        (define (list=? a-list another-list)&#xA;            (cond&#xA;                [(empty? a-list) (empty? another-list)]&#xA;                [(cons? a-list)&#xA;                    (and (cons? another-list)&#xA;                        (and (= (first a-list) (first another-list))&#xA;                            (list=? (rest a-list) (rest another-list))))]))&#xA;    匿名函数&#xA;        (define (find aloir t)&#xA;            (filter1 (local ((define (eq-ir? ir p)&#xA;                (symbol=? (ir-name ir) p)))&#xA;                    eq-ir?)&#xA;                aloir t))&#xA;        (lambda (ir p) (symbol=? (ir-name ir) p))&#xA;    快速排序&#xA;        (define (quick-sort alon)&#xA;            (cond&#xA;                [(empty? alon) empty]&#xA;                [else (append&#xA;                    (quick-sort (smaller-items alon (first alon)))&#xA;                    (list (first alon))&#xA;                    (quick-sort (larger-items alon (first alon))))]))&#xA;        (define (larger-items alon threshold)&#xA;            (cond&#xA;                [(empty? alon) empty]&#xA;                [else (if (&amp;gt; (first alon) threshold)&#xA;                    (cons (first alon) (larger-items (rest alon) threshold))&#xA;                    (larger-items (rest alon) threshold))]))&#xA;        (define (smaller-items alon threshold)&#xA;            (cond&#xA;                [(empty? alon) empty]&#xA;                [else (if (&amp;lt; (first alon) threshold)&#xA;                    (cons (first alon) (smaller-items (rest alon) threshold))&#xA;                    (smaller-items (rest alon) threshold))]))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;erlang&#34;&gt;&#xA;  erlang&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#erlang&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    由爱立信所辖CS-Lab开发，目的是创造一种可以应对大规模并发活动的编程语言。易于编写分布式应用。&#xA;    面向并发(concurrent-oriented)&#xA;            在语言中定义了erlang进程的概念和行为，使它特别经量级(309字节)，创建和结束一个进程时间为1-3ms&#xA;            该进程(绿进程)在rlang虚拟机内管理和高度，是用户态进程&#xA;            进程堆栈占用233字节&#xA;            erlang虚拟机支持几十万甚至更多进程&#xA;    结构化，动态，函数式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;lisp&#34;&gt;&#xA;  lisp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lisp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    为人工智能开发的函数语言&#xA;    目前最主要两大方言为scheme和commonLisp。Emacs扩展语言为Lisp，有一种Emacs Lisp语言&#xA;    拥有理论上最高的运算能力&#xA;&#xA;编译器&#xA;    sbcl&#xA;            # steel bank common lisp&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;lua&#34;&gt;&#xA;  lua&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lua&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    lua语言，来实现逻辑。 c/c++来实现功能&#xA;    eclipse ldt 来开发（cdt 再安装 ldt 使用更方便）&#xA;使用&#xA;    lua Hello.lua                # 执行脚本&#xA;    luac Hello.lua                # 编译字节码&#xA;    #-&amp;gt; lua luac.out&#xA;语法&#xA;    --                # 注释&#xA;    num = 10                # 定义&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;perl&#34;&gt;&#xA;  perl&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#perl&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;标准&#xA;    pcre: Perl Compatible Regular Expressions&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;prolog&#34;&gt;&#xA;  prolog&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#prolog&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    programming in logic缩写， 是一种逻辑编程语言。广泛应用于人工智能&#xA;    不是真正意义上的程序，运行步骤由计算机决定。没有if, when, case, for这样的控制流程语句&#xA;    很难分清哪些是程序，哪些是数据，程序就是数据，是一个智能数据库&#xA;    有强大的递归功能。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;r&#34;&gt;&#xA;  R&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#r&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    本身是GNU的一个开源软件&#xA;    用于统计分析、绘图&#xA;    是S语言的一个分支(实现)&#xA;特点&#xA;    数据存储和处理&#xA;    数组运算(向量、矩阵运算强大)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;d&#34;&gt;&#xA;  D&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 并发&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;ruby&#34;&gt;&#xA;  ruby&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ruby&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;工具&#xA;    gems&#xA;        gem update --system&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;rust&#34;&gt;&#xA;  rust&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rust&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    mozilla开发的,注重安全, 性能, 并发的系统编程语言&#xA;    js之父Brendan Eich设计&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;scala&#34;&gt;&#xA;  scala&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#scala&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    haskell衍生语言&#xA;    集成了面向对象和函数语言的特性&#xA;    可以很简单地与已有的java代码交互，只需要反java相关类导入就可以了&#xA;    面向对象语言同时结合命令式和函数式编程风格&#xA;工具&#xA;    sbt&#xA;        simple build tool&#xA;语法&#xA;    表达式&#xA;        actor1 ! case1          # 异步消息&#xA;        actor1 !? case1         # 同步消息, 需要对方一定返回&#xA;        actor1 !! case1         # 异步消息, 需要对方一定返回&#xA;    Actor&#xA;        o-&amp;gt;&#xA;        import scala.actors.Actor&#xA;&#xA;        class HelloActor extends Actor {&#xA;        def act() {&#xA;            while (true) {&#xA;            receive {&#xA;                case name: String =&amp;gt; println(&amp;quot;Hello, &amp;quot; + name)&#xA;            }&#xA;            }&#xA;        }&#xA;        }&#xA;&#xA;        val helloActor = new HelloActor&#xA;        helloActor.start()&#xA;        helloActor ! &amp;quot;leo&amp;quot;&#xA;    case                        # 模式匹配&#xA;        case class Login(username: String, password: String)&#xA;        class UserManageActor extends Actor {&#xA;        def act() {&#xA;            while (true) {&#xA;            receive {&#xA;                case Login(username, password) =&amp;gt; println(username + password)&#xA;            }&#xA;            }&#xA;        }&#xA;        }&#xA;        val userManageActor = new UserManageActor&#xA;        userManageActor.start()&#xA;        userManageActor ! Login(&amp;quot;leo&amp;quot;, &amp;quot;1234&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;net&#34;&gt;&#xA;  .net&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#net&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;objective-c&#34;&gt;&#xA;  objective-c&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#objective-c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;swift&#34;&gt;&#xA;  swift&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#swift&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;groovy&#34;&gt;&#xA;  groovy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#groovy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 基于jvm，结合python, ruby, smalltalk的特性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;dart&#34;&gt;&#xA;  dart&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dart&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 谷歌发布的基于javascript的编程语言&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hack&#34;&gt;&#xA;  hack&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hack&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # facebook开发的基于HHVM，可与PHP无缝对接&#xA;    特点&#xA;            结合了PHP开发高效性同时，有了静态语言的报错特性&#xA;            支持lambda表达式和强制返回等流行特性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;roy&#34;&gt;&#xA;  roy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#roy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 可编译到js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;elm&#34;&gt;&#xA;  elm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 可编译到js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jujia&#34;&gt;&#xA;  jujia&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jujia&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 动态语言，用于科学和数值计算&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;fortran&#34;&gt;&#xA;  Fortran&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fortran&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 最早出现的高级语言，用于工程计算领域&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;ml&#34;&gt;&#xA;  ML&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ml&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # meta language, 非纯函数式编程,允许副作用和指令式编程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;ocaml&#34;&gt;&#xA;  OCaml&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ocaml&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 在caml上加上oo, 源于ML&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;simula&#34;&gt;&#xA;  simula&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#simula&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 专注于仿真的语言，由类创建的对象会在协调的多线程模式下，像erlang的进程一样并行处理&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Haskell</title>
      <link>https://ukeate.com/docs/pl/haskell/</link>
      <pubDate>Tue, 09 Oct 2018 16:54:16 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/haskell/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;源于ML&#xA;标准化的、纯函数式编程语言&#xA;非限定性语义和强静态类型&#xA;作为其他语言设计新功能时的样板，如Python的lambda标记语句&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;检索函数用http://www.Haskell.org/hoogle&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;单词&#34;&gt;&#xA;  单词&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e8%af%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;polymorphism&#xA;    # 多态&#xA;monomorphic&#xA;    # 单态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;风格&#34;&gt;&#xA;  风格&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a3%8e%e6%a0%bc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;point free style&#xA;    sum&#39; xs = foldl (+) 0 xs&#xA;    sum&#39; = foldl (+) 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;注意&#34;&gt;&#xA;  注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用缩进代替括号，但也可用括号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;文件扩展名&#34;&gt;&#xA;  文件扩展名&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e6%89%a9%e5%b1%95%e5%90%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 文件中不用let定义变量, &#xA;# 变量赋值两次会报错, 这意味着代码顺序不重要&#xA;hs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内置变量&#34;&gt;&#xA;  内置变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;pi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模块&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:m Data.Char Data.Map&#xA;    # 加载模块&#xA;    chr&#xA;        # chr :: Int -&amp;gt; Char&#xA;    ord&#xA;        # ord :: Char -&amp;gt; Int&#xA;    toUpper&#xA;    toLower&#xA;import Data.Char&#xA;    # 导入到全局命名空间&#xA;    import Data.List (nub, sort)&#xA;    import Data.List hiding (nub)&#xA;    import qualified Data.Map as M&#xA;        # 这样其中命名冲突的filter, null函数，只能用Data.Map.filter或M.filter方式调用&#xA;可用模块&#xA;    prelude&#xA;        # 默认载入的模块&#xA;    Data&#xA;        Char&#xA;        List&#xA;        Map&#xA;        Set&#xA;自定义模块&#xA;module Geometry.Sphere&#xA;(sphereVolume&#xA;, sphereArea&#xA;, Shape(..)&#xA;    # 导出类型和其所有构造子&#xA;) where&#xA;sphereVolum :: Float -&amp;gt; Float&#xA;sphereVolum radius = (4.0 / 3.0) * pi * (radius ^ 3)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令函数&#34;&gt;&#xA;  命令函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:load&#xA;    # 加载模块&#xA;    :load a.hs&#xA;:l&#xA;:cd&#xA;    # 切换工作目录&#xA;    :cd c:\a&#xA;:reload&#xA;    # 重载所有模块&#xA;:r&#xA;:type&#xA;    :type &#39;H&#39;&#xA;:t&#xA;:info&#xA;    # 查看一个typeclass有哪些instance和subclass&#xA;    # 类型的信息、函数的类型声明&#xA;:k&#xA;    # 查看kind&#xA;    :k Int&#xA;        # Int :: *&#xA;    :k Maybe&#xA;        # Maybe :: * -&amp;gt; *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;操作符&#34;&gt;&#xA;  操作符&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;%&#xA;    # 分号&#xA;&amp;amp;&amp;amp;&#xA;||&#xA;++    &#xA;    # 字符串拼接&#xA;/=&#xA;    # 不等&#xA;do&#xA;    # 动作的combine, do 是&amp;gt;&amp;gt;=的语法糖, 用来连接一系列动作&#xA;&amp;lt;-&#xA;    # name &amp;lt;- getLine, 存到变量&#xA;    # 除了程序的最后一行用来作返回值，其它语句都可以用 &amp;lt;-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;表达式&#34;&gt;&#xA;  表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 表达式可以随处安放&#xA;if x &amp;lt; 0 then&#xA;    -1&#xA;else if x &amp;gt; 0 then&#xA;    1&#xA;else&#xA;    0&#xA;&#xA;case x of&#xA;    0 -&amp;gt; 1&#xA;    1 -&amp;gt; 5&#xA;    _ -&amp;gt; (-1)&#xA;&#xA;let a = 1&#xA;    # 局部绑定, in可省略则定义到全局&#xA;    twice_a = 2 * a&#xA;in (a + twice_a, a - twice_a)&#xA;    &#xA;let boot x  y z = x * y + z in boot 3 4 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;io-action&#34;&gt;&#xA;  I/O action&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#io-action&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 在main中 I/O action才被执行&#xA;# return () 语句产生I/O action, do接着执行&#xA;# 执行后会打印结果，结果为()时不打印&#xA;main = do&#xA;    _ &amp;lt;- putStrLn &amp;quot;a&amp;quot;&#xA;    name &amp;lt;- getLine&#xA;    putStrLn (name)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;类型表示&#34;&gt;&#xA;  类型表示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b%e8%a1%a8%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Eq a =&amp;gt; a -&amp;gt; a -&amp;gt; Bool&#xA;    # =&amp;gt; 前面是类型约束, 后面表示传入两个同类型参数，返回Bool类型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;变量&#34;&gt;&#xA;  变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;let pi = 3.14&#xA;    # 变量不可变，但可重复定义&#xA;(-1)&#xA;    # 负数一般加小括号&#xA;  let r = 25 :: Double&#xA;    # 默认猜测是Integer&#xA;    # monomorphish restriction(单一同态限定)原理，可以指定polymorphic(多态)&#xA;    ## let r = 25 :: Num a =&amp;gt; a&#xA;True, False&#xA;    # 类型为 Bool&#xA;&amp;quot;abc&amp;quot;&#xA;    # 类型为[char], 与&#39;a&#39;:&#39;b&#39;:&#39;c&#39;:[]&#xA;    a = &amp;quot;aaa&amp;quot; :: String&#xA;        # 得到一个String, 与[char]同样使用&#xA;LT, GT, EQ&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 函数名与参数，参数与参数之间有空格隔开&#xA;# 函数比运算符先结合&#xA;let area r = pi * r ^ 2&#xA;    # 定义函数, &#xA;area 2&#xA;area (-2)&#xA;let area2 r = area r&#xA;let first (x, y) = x&#xA;    # 接收元组&#xA;uppercase, lowercase :: String -&amp;gt; String&#xA;    # 指定函数类型&#xA;分段定义&#xA;    # 编译成case语句&#xA;    f 0 = 1&#xA;    f 1 = 5&#xA;    f _ = -1&#xA;函数合成调用&#xA;    square (f 1)&#xA;    (square . f) 1&#xA;(\xs -&amp;gt; length xs &amp;gt; 15)&#xA;    # lambda表达式&#xA;    # lambda可以用模式匹配，但使用不了多个模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;列表&#34;&gt;&#xA;  列表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%97%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 列表，类型必须相同。&#xA;# 列表都由[]追加得到，逗号是语法糖&#xA;let n = [1, 2]&#xA;[1..20]&#xA;    # range浮点数不精确&#xA;take 20 [1,2..]&#xA;[2,4..20]&#xA;[&#39;a&#39;..&#39;z&#39;]&#xA;0:n&#xA;    # 得到追加列表[0, 1, 2]， 头部追加叫作consing, cons是constructor&#xA;    # -1:0:n&#xA;[[1], [2]]&#xA;n !! 1&#xA;    # 取元素&#xA;l1 &amp;gt; l2&#xA;    # 元素依次比较&#xA;[x*2 | x &amp;lt;- [1..10], x*2 &amp;gt;= 12]&#xA;    # list comprehension&#xA;    boomBangs xs = [if x &amp;lt; 10 then &amp;quot;BOOM!&amp;quot; else &amp;quot;BANG!&amp;quot; | x &amp;lt;-xs, odd x]&#xA;    [x*y | x &amp;lt;-[1,2], y &amp;lt;-[3,4]]&#xA;        # 聚合得[3,4,6,8]&#xA;    length&#39; xs = sum [1 | _ &amp;lt;- xs]&#xA;&#xA;    xxs = [[1,2], [3,4]]&#xA;    [[x | x &amp;lt;- xs, even x] | xs &amp;lt;- xxs]&#xA;&#xA;    [(a,b,c) | c &amp;lt;- [1..10], b &amp;lt;- [1..c], a &amp;lt;- [1..b], a^2 + b^2 = c ^2]&#xA;&#xA;    [a + b | (a,b) &amp;lt;- xs]&#xA;        # list comprehension中的模式匹配&#xA;模式匹配&#xA;    x:xs&#xA;    x:y:z:xs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;元组&#34;&gt;&#xA;  元组&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%83%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 类型可不同，不能单元素。2元组叫pairs, 3元组叫triples, n元组叫n-tuple&#xA;# 元组不可变&#xA;# 元组的类型由长度和其中的类型决定, (&amp;quot;a&amp;quot;, 1)与(1, &amp;quot;a&amp;quot;)是不同的类型，所以[(&amp;quot;a&amp;quot;, 1), (2, &amp;quot;b&amp;quot;)]是错误的&#xA;(True, 1)&#xA;((1,2), True)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;monad&#34;&gt;&#xA;  monad&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#monad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; do&#xA;doGuessing num = do&#xA;    putStrLn &amp;quot;Enter your guess:&amp;quot;&#xA;    guess &amp;lt;- getLine&#xA;    if (read guess) &amp;lt; num&#xA;    then do putStrLn &amp;quot;Too low&amp;quot;&#xA;        doGuessing num&#xA;    else if (read guess) &amp;gt; num&#xA;    then do putStrLn &amp;quot;Too high&amp;quot;&#xA;        doGuessing num&#xA;    else putStrLn &amp;quot;You Win&amp;quot;&#xA;        # 只有一个动作时，可省略do&#xA;&#xA;o-&amp;gt; do&#xA;doGuessing num = do&#xA;    putStrLn &amp;quot;Enter your guess:&amp;quot;&#xA;    guess &amp;lt;- getLine&#xA;    case compare (read guess) num of&#xA;        LT -&amp;gt; do putStrLn &amp;quot;Too low&amp;quot;&#xA;        GT -&amp;gt; do putStrLn &amp;quot;Too high&amp;quot;&#xA;        EQ -&amp;gt; putStrLn &amp;quot;You Win&amp;quot;&#xA;&#xA;o-&amp;gt; functor applicative monad&#xA;class Functor f where&#xA;fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;class Functor f =&amp;gt; Applicative f where&#xA;pure :: a -&amp;gt; f a&#xA;() :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;class Applicative m =&amp;gt; Monad m where&#xA;return :: a -&amp;gt; m a&#xA;(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&#xA;(&amp;gt;&amp;gt;) :: m a -&amp;gt; m b -&amp;gt; m b&#xA;x &amp;gt;&amp;gt; y = x &amp;gt;&amp;gt;= \_ -&amp;gt; y&#xA;fail :: String -&amp;gt; m a&#xA;fail msg = error msg&#xA;instance Functor Maybe where&#xA;fmap func (Just x) = Just (func x)&#xA;fmap func Nothing  = Nothing&#xA;instance Applicative Maybe where&#xA;pure = Just&#xA;Nothing  _ = Nothing&#xA;(Just func)  something = fmap func something&#xA;instance Monad Maybe where&#xA;return = Just&#xA;Nothing &amp;gt;&amp;gt;= func = Nothing&#xA;Just x &amp;gt;&amp;gt;= func  = func x&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内置函数&#34;&gt;&#xA;  内置函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;prelude&#xA;    $&#xA;        # 函数调用符，优先级最低。而空格是最高优先级&#xA;        # $右结合。而空格左结合&#xA;        # 等价于在右而写一对括号&#xA;    .&#xA;        # f . g = \x -&amp;gt; f (g x)&#xA;        # 函数组合&#xA;    main&#xA;        # main :: IO ()&#xA;        main = do&#xA;    signum&#xA;        # 根据数字返回 -1, 0, 1&#xA;    not&#xA;    id&#xA;        # identity&#xA;    unlines&#xA;        unlines [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&#xA;            # 成为 &amp;quot;a\nb\n&amp;quot;&#xA;    unwords&#xA;        unwords [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&#xA;            # 成为 &amp;quot;a b&amp;quot;&#xA;    show&#xA;        # 接受各种类型，转换为String, 再转义打印&#xA;    read&#xA;        read &amp;quot;5&amp;quot; :: Int&#xA;        read &amp;quot;5&amp;quot; - 2&#xA;        read &amp;quot;[1,2,3]&amp;quot; ++ [4]&#xA;    reads&#xA;        # 读取失败返回[]而不报错&#xA;    negate&#xA;        # 取反数字&#xA;    abs&#xA;        # 绝对值&#xA;    length&#xA;        # 列表的长度, [a] -&amp;gt; Int , a在这里是一个type variable, 以小写字母开头(具体类型都大写开头)。&#xA;    map&#xA;    compare&#xA;        # 返回 LT, GT, EQ其中一个&#xA;    min&#xA;    max&#xA;    compare&#xA;        # 返回LT, GT, EQ&#xA;        &amp;quot;Abc&amp;quot; `compare` &amp;quot;Zyx&amp;quot;&#xA;    mod&#xA;        # 取模&#xA;    odd&#xA;        # 奇数&#xA;    even&#xA;        # 偶数&#xA;    succ&#xA;        # 取Enum的后继&#xA;    pred&#xA;        # 取Enum的前置&#xA;    minBound&#xA;        # 取Bound下限&#xA;    maxBound&#xA;    substract&#xA;        # 减&#xA;&#xA;    head&#xA;    tail&#xA;        # 除第一个&#xA;    last&#xA;    init&#xA;        # 除最后一个&#xA;&#xA;    null&#xA;        # 检查list是否空&#xA;    reverse&#xA;        # list反转&#xA;    take&#xA;        take 1 [1,2,3]&#xA;    takeWhile&#xA;        # 取list值，直到某条件&#xA;    drop&#xA;        drop 1 [1,2,3]&#xA;    maximum&#xA;        # list中最大元素&#xA;    minimun&#xA;        # list中最小元素&#xA;    sum&#xA;        # list和&#xA;    product&#xA;        # list积&#xA;    elem&#xA;        # 判断元素是否在list中&#xA;        4 `elem` [3,4,5]&#xA;    cycle&#xA;        take 7 (cycle [1,2,3])&#xA;            # [1,2,3,1,2,3,1]&#xA;    repeat&#xA;        repeat 5&#xA;    replicate&#xA;        replicate 3 10&#xA;            # [10, 10, 10]&#xA;&#xA;    fst (1, 2)&#xA;        # 只适合2元组&#xA;    snd (1, 2)&#xA;        # 只适合2元组&#xA;    zip&#xA;        # zip3, zip4 ... zip7&#xA;        zip [1,2,3] [4,5,6]&#xA;            # [(1,4), (2,5), (3,6)]&#xA;    zipWith&#xA;        # zipWith1 ... zipWith7&#xA;        zipWith (\x y -&amp;gt; x + y) [1,2] [3,4]&#xA;            # [4,6]&#xA;    fromIntegral&#xA;        # 返回更通用的数字类型&#xA;    error &amp;quot;&amp;quot;&#xA;        # 抛错&#xA;    flip&#xA;        # 翻转两个参数调用&#xA;    map&#xA;    filter&#xA;    foldl&#xA;        foldl (\acc x -&amp;gt; acc + x) 0 xs&#xA;    foldr&#xA;        foldr (\x acc -&amp;gt; f x : acc) [] xs&#xA;    foldl1&#xA;        # 以第一个元素为初始值，空list报错&#xA;    foldr1&#xA;    foldl&#39;&#xA;        # foldl的strict版&#xA;    foldr&#39;&#xA;    scanl&#xA;        # 返回累加过程的list&#xA;    scanr&#xA;    scanl1&#xA;    scanr1&#xA;    o-&amp;gt; I/O action&#xA;        # 只有在main中执行&#xA;        # 类型为 IO a&#xA;        putStrLn&#xA;            # 只接受String，不转义打印，加换行符&#xA;            # putStrLn :: String -&amp;gt; IO () , 表示接收String, 是IO动作, 结果类型是()。表示是一个&amp;quot;IO monad&amp;quot;动作&#xA;        putStr&#xA;            # 由putChar递归定义，边界条件是空字符串&#xA;        putChar&#xA;        print&#xA;            # 打印Show typeclass的值&#xA;        getLine&#xA;            # 控制台读一行&#xA;            # getLine :: IO String&#xA;            name &amp;lt;- getLine&#xA;        getChar&#xA;        sequence&#xA;        # 顺序执行I/O action&#xA;        mapM&#xA;            mapM print [1,2,3]&#xA;                # 对list元素执行sequence f&#xA;        mapM_&#xA;            # 同mapM，不打印[(),()]&#xA;        getContents&#xA;            # 读直到 eof (ctrl + d)&#xA;        interact&#xA;            # 用函数处理输入，返回到输出&#xA;Data.List&#xA;    # 每个元素存在thunk中&#xA;    \&#xA;        # 差集&#xA;        [1..3] \\ [2]&#xA;            # [1,3]&#xA;        &amp;quot;Im a big baby&amp;quot; \\ &amp;quot;big&amp;quot;&#xA;            # &amp;quot;Im a baby&amp;quot;&#xA;    union&#xA;    intersection&#xA;    insert&#xA;        # 插入一个元素到可排序list相对位置&#xA;    nub&#xA;        # 去重复元素,常用Set转换取代,提高很多效率&#xA;    map&#xA;        # 导出到了prelude&#xA;    filter&#xA;        # 导出到了prelude&#xA;    intersperse&#xA;        intersperse &#39;.&#39; &amp;quot;abc&amp;quot;&#xA;            # &amp;quot;a.b.c&amp;quot;&#xA;    intercalate&#xA;        # 同intersperse, 但插入list&#xA;    transpose&#xA;        # 二元list列为行&#xA;    foldl&#39;&#xA;        # fold的严格版，直接计算出中间值，而非用惰性&amp;quot;承诺&amp;quot;塞满堆栈&#xA;    foldl1&#39;&#xA;    concat&#xA;        # 移除一级嵌套&#xA;    concatMap&#xA;        # 先map再concat&#xA;        concatMap (replicate 2) [1..3]&#xA;            # [1,1,2,2,3,3]&#xA;    and&#xA;        # list中全true返回true&#xA;        and $ map (&amp;gt;4) [5,6,7,8]&#xA;    or&#xA;    any&#xA;    iterate&#xA;        # 无限迭代值到函数，结果形成list&#xA;        take 10 $ iterate (*2) 1&#xA;    splitAt&#xA;        # 断开list, 返回二元组&#xA;        splitAt 3 &amp;quot;abcdef&amp;quot;&#xA;            # (&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;)&#xA;    takeWhile&#xA;        # 取元素，直到不符合条件&#xA;    dropWhile&#xA;    span&#xA;        # 同takeWhile, 不过返回分割list的二元组&#xA;    break&#xA;        # 同span, 但在条件首次为true时断开&#xA;    sort&#xA;        # list元素要求Ord类型，排序list&#xA;    group&#xA;        # 合并相邻并相等的list元素&#xA;    inits&#xA;        # init递归调用自身&#xA;        inits &amp;quot;abc&amp;quot;&#xA;            # [&amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;ab&amp;quot;, &amp;quot;abc&amp;quot;]&#xA;    tails&#xA;        # tail递归调用自身&#xA;        tails &amp;quot;abc&amp;quot;&#xA;            # [&amp;quot;abc&amp;quot;, &amp;quot;bc&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;&amp;quot;]&#xA;    isInfixOf&#xA;        # list中搜索子list, 有则返回true&#xA;        &amp;quot;cat&amp;quot; `isInfixOf` &amp;quot;im a cat&amp;quot;&#xA;    isPrefixOf&#xA;        # 是否以某list开头&#xA;    isSuffixOf&#xA;        # 是否以某list结尾&#xA;    elem&#xA;        # 是否包含某元素&#xA;    notElem&#xA;    partition&#xA;        # 条件划分list为二元组&#xA;        partition (`elem` [&#39;A&#39;..&#39;Z&#39;]) &amp;quot;AbCD&amp;quot;&#xA;            # (&amp;quot;ACD&amp;quot;, &amp;quot;b&amp;quot;)&#xA;    find&#xA;        # 条件查找list, 返回第一个符合元素的Maybe值&#xA;    elemIndex&#xA;        # 返回elem第一个元素的索引的Maybe值&#xA;    elemIndices&#xA;        # 返回所有匹配索引的list&#xA;    findIndex&#xA;    findIndices&#xA;    lines&#xA;        # 字符串分行到list&#xA;    unlines&#xA;    words&#xA;        # 字符串分词到list&#xA;    unwords&#xA;    delete&#xA;        # 删除list中第一个匹配元素&#xA;        delete &#39;h&#39; &amp;quot;hha&amp;quot;&#xA;            # &amp;quot;ha&amp;quot;&#xA;    replace&#xA;    lookup&#xA;        # 用a查找[(&#39;a&#39;, &#39;b&#39;)]中的b&#xA;    genericLength&#xA;        # 换Int类型为Num类型&#xA;    genericTake&#xA;    genericDrop&#xA;    genericSplitAt&#xA;    genericIndex&#xA;    genericReplicate&#xA;&#xA;    nubBy&#xA;        # 传递函数判断相等性，取代==&#xA;    deleteBy&#xA;    unionBy&#xA;    intersectBy&#xA;    groupBy&#xA;    sortBy&#xA;    insertBy&#xA;    maximumBy&#xA;    minimumBy&#xA;Data.Monoid&#xA;    Monoid&#xA;    Product&#xA;    Sum&#xA;    Any&#xA;    All&#xA;Data.Foldable&#xA;    foldr&#xA;    foldl&#xA;    foldr1&#xA;    foldl1&#xA;Data.Function&#xA;    on&#xA;        ((==) `on` (&amp;gt; 0))&#xA;            # 判断相等性，等价于 (\x y -&amp;gt; (x &amp;gt; 0) == (y &amp;gt; 0))&#xA;        (compare `on` length)&#xA;            # 判断大小&#xA;Data.Char&#xA;    isControl&#xA;        # 是否控制字符&#xA;    isSpace&#xA;        # 包括空格, tab, 换行等&#xA;    isLower&#xA;    isUpper&#xA;    isAlpha&#xA;        # 是否字母&#xA;    isAlphaNum&#xA;        # 字母或数字&#xA;    isPrint&#xA;        # 可打印&#xA;    isDigit&#xA;    isOctDigit&#xA;    isHexDigit&#xA;    isLetter&#xA;        # 同isAlpha&#xA;    isMark&#xA;        # unicode注音字符&#xA;    isNumber&#xA;    isPunctuation&#xA;        # 是否标点符号&#xA;    isSymbol&#xA;        # 货币符号&#xA;    isSeperater&#xA;        # unicode空格或分隔符&#xA;    isAscii&#xA;        # unicode 前128位&#xA;    isLatin1&#xA;        # unicode 前256位&#xA;    isAsciiUpper&#xA;    isAsciiLower&#xA;    GeneralCategory&#xA;        # 得到字符的分类，一共31类, 属于Eq类型&#xA;        generalCategory &#39; &#39;&#xA;            # Space&#xA;    toUpper&#xA;    toLower&#xA;    toTitle&#xA;    digitToInt&#xA;        # 数字，大小写字母list 转成 int list&#xA;    intToDigit&#xA;    ord&#xA;    char&#xA;Data.Map&#xA;    # 用avl树实现&#xA;    fromList&#xA;        # 重复键会忽略，要求key有相等性和排序性&#xA;    fromListWith&#xA;        # 重复键给函数处理&#xA;    toList&#xA;    empty&#xA;        # 返回空map&#xA;    insert&#xA;        insert 3 10 map&#xA;    insertWith&#xA;        # 已包含键时函数处理&#xA;    null&#xA;        # 检查map是否空&#xA;    size&#xA;        # 返回map的大小&#xA;    singleton&#xA;        singleton 3, 9&#xA;            # fromList [(3,9)]&#xA;    lookup&#xA;    member&#xA;        # key 是否在map中&#xA;    map&#xA;    filter&#xA;    keys&#xA;    elems&#xA;Data.Set&#xA;    # 要求元素可排序，自动排序、唯一&#xA;    # 用avl树实现&#xA;    fromList&#xA;    intersection&#xA;    difference&#xA;        # 存在于第一集合而不在第二集合的元素&#xA;    union&#xA;    null&#xA;    size&#xA;    member&#xA;    empty&#xA;    singleton&#xA;    insert&#xA;    delete&#xA;    isSubsetOf    &#xA;        # 子集&#xA;        fromList [1,2] isSubsetOf fromList [1,2]&#xA;    isProperSubsetOf&#xA;        # 真子集&#xA;    filter&#xA;    map&#xA;Data.ByteString&#xA;    # strict bytestring&#xA;    # Empty相当于[], cons相当于:&#xA;Data.ByteString.Lazy&#xA;    # 每个元素存在chunk中，每个chunk 64k，每个chunk相当于一个strict bytestring&#xA;    # cons在chunk不满的时候会新建chunk, cons&#39;是strick版的cons, 会填充chunk&#xA;    pack&#xA;        # pack :: [Word8] -&amp;gt; ByteString&#xA;        pack [80,81]&#xA;    unpack&#xA;    fromChunks&#xA;        # 转换strick bytestring 到lazy&#xA;    toChunks&#xA;        # lazy转strick&#xA;Data.Ratio&#xA;Control.Applicative&#xA;    Applicative&#xA;        class (Functor f) =&amp;gt; Applicative f where&#xA;            pure :: a -&amp;gt; fa&#xA;            (&amp;lt;*&amp;gt;) :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;            f &amp;lt;$&amp;gt; x = fmap f x&#xA;    ZipList&#xA;        ZipList3&#xA;        ZipList7&#xA;    getZipList&#xA;    liftA2&#xA;        liftA2 f x y = f &amp;lt;$&amp;gt; x &amp;lt;*&amp;gt; y &#xA;    sequenceA&#xA;Control.Monad&#xA;    when&#xA;        # Bool true时，返回后面的I/O action, 否则return ()&#xA;    forever&#xA;        # 不断执行后面的I/O action&#xA;        forever $ do&#xA;            putStr &amp;quot;a&amp;quot;&#xA;    forM&#xA;        # 同mapM, 但两个参数顺序相反&#xA;    liftM&#xA;        # monad中的fmap&#xA;    liftM2 liftM3 liftM4 liftM5&#xA;    `ap`&#xA;        # monad中的&amp;lt;*&amp;gt;&#xA;    join&#xA;        join :: (Monad m) =&amp;gt; m (m a) -&amp;gt; m a&#xA;        join mm = do&#xA;            m &amp;lt;- mm&#xA;            m&#xA;    filterM&#xA;    foldM&#xA;Control.Monad.State&#xA;    State&#xA;        newtype State s a = State {runState :: s -&amp;gt; (a, s)}&#xA;    get&#xA;    put&#xA;Control.Monad.Error&#xA;System.IO&#xA;    openFile&#xA;        # openFile :: FilePath -&amp;gt; IOMode -&amp;gt; IO Handle&#xA;        # data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode&#xA;        do&#xA;        handle = openFile &amp;quot;a.txt&amp;quot; ReadMode&#xA;        contents &amp;lt;- hGetContents handle&#xA;        putStr contents&#xA;        hClose handle&#xA;    withFile&#xA;        # withFile :: FilePath -&amp;gt; IOMode -&amp;gt; (Handle -&amp;gt; IO a) -&amp;gt; IO a&#xA;        # 处理完关掉&#xA;        withFile &amp;quot;a.txt&amp;quot; ReadMode (\handle -&amp;gt; do&#xA;            contents &amp;lt;- hGetContents handle&#xA;            putStr contents)&#xA;    readFile&#xA;        # readFile :: FilePath -&amp;gt; IO String&#xA;        do&#xA;        contents &amp;lt;- readFile &amp;quot;a.txt&amp;quot;&#xA;        putStr contents&#xA;    wirteFile&#xA;        # writeFile :: FilePath -&amp;gt; String -&amp;gt; IO ()&#xA;        do&#xA;        writeFile &amp;quot;a.txt&amp;quot; contents&#xA;    appendFile&#xA;    hSetBuffering&#xA;        # 读binary file时的buffer，默认是系统值&#xA;        # data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)&#xA;        hSetBuffering handle $ BlockBuffering (Just 2048)&#xA;    hFlush&#xA;        # 写入时自动Flush&#xA;    openTempFile&#xA;        (tempName, tempHandle) &amp;lt;- openTempFile &amp;quot;.&amp;quot; &amp;quot;temp&amp;quot;&#xA;    hGetContents&#xA;    hClose&#xA;    hGetLine&#xA;    hPusStr&#xA;    hPutStrLn&#xA;    hGetChar&#xA;System.IO.Error&#xA;    catch&#xA;        # catch :: IO a -&amp;gt; (IOError -&amp;gt; IO a) -&amp;gt; IO a&#xA;        toTry `catch` handler&#xA;        handler e&#xA;            | isDoesNotExistError e = &#xA;                case ioeGetFileName e of Just path -&amp;gt; putStrLn $ &amp;quot;a&amp;quot; ++ path&#xA;                    Nothing -&amp;gt; putStrLn &amp;quot;b&amp;quot;&#xA;            | otherwise = ioError e&#xA;    isDoesNotExistError&#xA;    isAlreadyExistsError&#xA;    isFullError&#xA;    isEOFError&#xA;    isIllegalOperation&#xA;    isPermissionError&#xA;    isUserError&#xA;    ioeGetFileName&#xA;        # ioeGetFileName :: IOError -&amp;gt; Maybe FilePath&#xA;    ioError&#xA;        # 丢出接到的error&#xA;System.Directory&#xA;    removeFile&#xA;        removeFile &amp;quot;a.txt&amp;quot;&#xA;    renameFile&#xA;        renameFile tempName &amp;quot;a.txt&amp;quot;&#xA;    copyFile&#xA;    doesFileExist&#xA;System.Environment&#xA;    getArgs&#xA;    getProgName&#xA;System.Random&#xA;    mkStdGen&#xA;        # mkStdGen :: Int -&amp;gt; StdGen&#xA;    getStdGen&#xA;        # IO类型, 得到系统启动时的global generator&#xA;    newStdGen&#xA;        # 把现有的random generator分成两个新的generators, 其中一个指定成新的，返回另一个&#xA;    random&#xA;        # random :: (RandomGen g, Random a) = g -&amp;gt; (a, g)&#xA;        random (mkStdGen 100) :: (Int, StdGen)&#xA;    randoms&#xA;        take 5 $ randoms (mkStdGen 11) :: [Int]&#xA;    randomR&#xA;        # 区间random&#xA;        randomR (1,6) (mkStdGen 2)&#xA;    randomRs&#xA;        take 10 $ randomRs (&#39;a&#39;, &#39;z&#39;) (mkStdGen 3) :: [Char]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数-1&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 模式匹配&#xA;    # case的语法糖&#xA;    # 对构造子匹配，如 8 &#39;a&#39; : []&#xA;factorial :: (Integral a) =&amp;gt; a -&amp;gt; a&#xA;factorial 0 = 1&#xA;factorial n = n * factorial (n - 1)&#xA;&#xA;addVectors :: (Num a) =&amp;gt; (a, a) -&amp;gt; (a, a) -&amp;gt; (a, a)&#xA;addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)&#xA;&#xA;first :: (a, b, c) -&amp;gt; a&#xA;first (x, _, _) = x&#xA;&#xA;tell :: (Show a) =&amp;gt; [a] -&amp;gt; String&#xA;tell [] = &amp;quot;&amp;quot;&#xA;tell [x: []] = &amp;quot;&amp;quot;&#xA;tell [x:y:[]] = &amp;quot;&amp;quot;&#xA;tell [x:y:_] = &amp;quot;too long, the first is &amp;quot; ++ show x ++ &amp;quot; and the second is &amp;quot; ++ show y&#xA;&#xA;length&#39; :: (Num b) =&amp;gt; [a] -&amp;gt; b&#xA;length&#39; [] = 0&#xA;length&#39; (_:xs) = 1 + length&#39; xs&#xA;&#xA;capital :: String -&amp;gt; String&#xA;capital &amp;quot;&amp;quot; = &amp;quot;&amp;quot;&#xA;capital all@(x:xs) = &amp;quot;The first letter of &amp;quot; ++ all ++ &amp;quot; is &amp;quot; ++ [x]&#xA;    # @是as模式&#xA;&#xA;o-&amp;gt; guard&#xA;bmiTell :: (RealFloat a) =&amp;gt; a -&amp;gt; String&#xA;bmiTell weight height&#xA;    | bmi &amp;lt;= skinny = &amp;quot;You&#39;re underweight&amp;quot;&#xA;    | bmi &amp;lt;= normal = &amp;quot;You&#39;re supposedly normal&amp;quot;&#xA;    | bmi &amp;lt;= fat = &amp;quot;You&#39;re fat&amp;quot;&#xA;    | otherwise = &amp;quot;You&#39;re a whale&amp;quot;&#xA;    where bmi = weight / height ^ 2&#xA;    (skinny, normal, fat) = (18.5, 25.0, 30.0)&#xA;        # where是语法结构，不是表达式&#xA;calcBmis :: (RealFloat a) =&amp;gt; [(a, a)] -&amp;gt; [a]&#xA;calcBmis xs = [bmi w h | (w, h) &amp;lt;- xs, let bmi = w / h ^ 2]&#xA;&#xA;myCompare :: (Ord a) =&amp;gt; a -&amp;gt; a -&amp;gt; Ordering&#xA;a `myCompare` b&#xA;    | a &amp;gt; b = GT&#xA;    | a == b = EQ&#xA;    | otherwise = LT&#xA;&#xA;o-&amp;gt; quicksort&#xA;quicksort :: (Ord a) =&amp;gt; [a] -&amp;gt; [a]&#xA;quicksort [] = []&#xA;quicksort (x:xs) = &#xA;    let smallerSorted = quicksort (filter (&amp;lt;=x) xs)&#xA;        biggerSorted = quicksort [a | a &amp;lt;- xs, a &amp;gt; x]&#xA;    in smallerSorted ++ [x] ++ biggerSorted&#xA;&#xA;o-&amp;gt; curry&#xA;compareWithHundred :: (Num a, ord a) =&amp;gt; a -&amp;gt; Ordering&#xA;compareWithHundred = compare 100&#xA;&#xA;divideByTen :: (Floating a) =&amp;gt; a -&amp;gt; a&#xA;divideByTen = (/10)&#xA;    # 中缀函数用括号来不完全调用&#xA;    # 但(-4)表示负4, (substract 4)来表示减4函数&#xA;&#xA;o-&amp;gt; 高阶函数&#xA;applyTwice :: (a -&amp;gt; a) -&amp;gt; a -&amp;gt; a&#xA;applyTwice f x = f (f x)&#xA;&#xA;o-&amp;gt; lambda&#xA;addThree :: (Num a) =&amp;gt; a -&amp;gt; a -&amp;gt; a -&amp;gt; a&#xA;addThree = \x -&amp;gt; \y -&amp;gt; \z -&amp;gt; x + y + z&#xA;&#xA;o-&amp;gt; $ 做数据函数&#xA;map ($ 3) [(4+), (10*), (^2), sqrt]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;类型&#xA;    Int&#xA;        # 有界整数&#xA;    Integer&#xA;        # 无界整数&#xA;    Float&#xA;        # 单精度浮点数&#xA;    Double&#xA;    Bool&#xA;    Char&#xA;    Maybe&#xA;    []&#xA;    ()&#xA;    a&#xA;        # type variables&#xA;类型约束&#xA;    Eq&#xA;    # 可判断相等性的类型，可用 == 或 /= 判断&#xA;        # 只除函数&#xA;    Ord&#xA;        #可比较大小的类型, 必定是Eq&#xA;        # 只除函数&#xA;    Ordering&#xA;        # 只有GT, EQ, LT&#xA;    Show&#xA;        # 可用字符串表示的类型&#xA;        # 只除函数&#xA;    Read&#xA;        # 与Show相反&#xA;    Enum&#xA;        # 连续的类型，有后继子(successer)和前置子(predecesor), 分别通过succ函数和pred函数得到&#xA;        # 可以[1..2]构造list&#xA;        # 包含 (), Bool, Char, Ordering, Int, Integer, Float, Double&#xA;    Bounded&#xA;        # 有上限和下限&#xA;        # 如果Tuple中都属于Bounded, 那么这个Tuple属于Bounded&#xA;    Num&#xA;        # 数字特征&#xA;    Integral&#xA;        # 整数&#xA;    Floating&#xA;        # 浮点，包含Float和Double&#xA;构造类型&#xA;    data Bool = False | True deriving (Ord)&#xA;        # Bool是构造的类型, False为值构造子，值可以用:t查看其类型&#xA;        # 值构造子可以用于模式匹配&#xA;        # 这里值构造子是没有参数的，叫作nullary&#xA;        # False在True前，所以比较时True比False大&#xA;    data Point = Point Float Float deriving (Show)&#xA;        # 值构造子可以与类型同名&#xA;    data Shape = Circle Point Float | Rectangle  Point Point deriving (Show)&#xA;        # 派生自Show, 就可show值成字符串&#xA;    data Person = Person {firstName :: String&#xA;        , lastName :: String&#xA;        } deriving (Show)&#xA;            # Record Syntax, 同 Person String String,  但自动生成同名的取值函数，show显示也改变&#xA;        let p = Person {firstName=&amp;quot;aa&amp;quot;, lastName=&amp;quot;bb&amp;quot;}&#xA;    &#xA;        tellPerson :: Person -&amp;gt; String&#xA;        tellPerson (Person {firstName = a, lastName = b}) = a ++ b&#xA;    newtype CharList = CharList {getCharList :: [Char]} deriving {Eq, Show}&#xA;        # newtype将现有类型包成新类型，只能定义单一值构造子，且其只能有一个字段。并将包裹和解开的成本都去掉&#xA;类型构造子&#xA;    # data声明中不能加类型约束&#xA;    data Maybe a = Nothing | Just a&#xA;    data Car a b = Car { company :: a&#xA;        , year :: b&#xA;        } deriving (Show)&#xA;    tellCar :: (Show a) =&amp;gt; Car String a -&amp;gt; String&#xA;类型别名&#xA;    type String = [Char]&#xA;    type AssocList k v = [(k,v)]&#xA;        # 别名类型构造子&#xA;    type IntMap = Map Int&#xA;        # 不全调用得到不全类型构造子, 同 type intMap v = Map Int v&#xA;infixr&#xA;    infixr 5 :-:&#xA;        # 定义中缀构造子, 5是优先级, :-:是符号&#xA;        # 默认left-associative&#xA;&#xA;    infixr 5 .++&#xA;    (.++) :: List a -&amp;gt; List a -&amp;gt; List a&#xA;    Empty .++ ys = ys&#xA;    (x :-: xs) .++ ys = x :-: (xs .++ ys)&#xA;recursive data structures&#xA;    data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)&#xA;typeclass&#xA;    class Eq a where&#xA;        (==) :: a -&amp;gt; a -&amp;gt; Bool&#xA;        (/=) :: a -&amp;gt; a -&amp;gt; Bool&#xA;        x == y = not (x /= y)&#xA;        x /= y = not (x == y)&#xA;            # 只需要instance一个定义就好，这个定义叫minimal complete definition&#xA;    data TrafficLight = Red | Yellow | Green&#xA;    instance Eq TrafficLight where&#xA;        Red == Red = True&#xA;        Green == Green = True&#xA;        Yellow == Yellow = True&#xA;        _ == _ = False&#xA;    instance Show TrafficLight where&#xA;        show Red = &amp;quot;Red light&amp;quot;&#xA;        show Yellow = &amp;quot;Yellow light&amp;quot;&#xA;        show Green = &amp;quot;Green light&amp;quot;&#xA;&#xA;    class (Eq a) =&amp;gt; Num a where&#xA;        # Num 是 Eq  的 subclass, 要是Num必是Eq&#xA;&#xA;    instance (Eq m) =&amp;gt; Eq (Maybe m) where&#xA;        Just x == Just y = x == y&#xA;        Nothing == Nothing = True&#xA;        _ == _ = False&#xA;            &#xA;o-&amp;gt; Either&#xA;data Either a b = Left a | Right a deriving (Eq, Ord, Read, Show)&#xA;&#xA;o-&amp;gt; Tree&#xA;data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)&#xA;&#xA;o-&amp;gt; YesNo&#xA;class YesNo a where&#xA;    yesno :: a -&amp;gt; Bool&#xA;instance YesNo Int where&#xA;    yesno 0 = False&#xA;    yesno _ = True&#xA;&#xA;o-&amp;gt; Functor&#xA;class Functor f where&#xA;    # map over&#xA;    fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;instance Functor Maybe where&#xA;    # 接收构造子而非类型&#xA;    fmap f (Just x) = Just (f x)&#xA;    fmap f Nothing = Nothing&#xA;instance Functor (Either a) where&#xA;    # parital apply Either, Either a 是个类型构造子&#xA;    fmap f (Right x) = Right (f x)&#xA;    fmap f (Left x) = Left x&#xA;instance Functor ((-&amp;gt;) r) where&#xA;    # 对函数的functor&#xA;    fmap f g = (\x -&amp;gt; f (g x))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ghci&#xA;    set prompt &amp;quot;ghci&amp;gt; &amp;quot;&#xA;        # 设置显示的提示符&#xA;ghc&#xA;    ghc --make a.hs&#xA;runhaskell&#xA;ghc-pkg list&#xA;    # 列出已安装的软件包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;玄学&#34;&gt;&#xA;  玄学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%84%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;&#xA;:{&#xA;data X = X&#xA;a :: Int -&amp;gt; Int&#xA;a x = x + 3&#xA;:}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Html</title>
      <link>https://ukeate.com/docs/pl/markup_language/html/</link>
      <pubDate>Tue, 09 Oct 2018 16:42:05 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/markup_language/html/</guid>
      <description>&lt;h1 id=&#34;事件&#34;&gt;&#xA;  事件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;blur&#xA;change&#xA;click&#xA;dblclick&#xA;focus&#xA;keydown&#xA;keypress&#xA;keyup&#xA;load&#xA;mousedown&#xA;mousemove&#xA;mouseout&#xA;mouseover&#xA;mouseup&#xA;reset&#xA;select&#xA;submit&#xA;unload&#xA;&#xA;Abort&#xA;    # 中断图片下载时激发&#xA;AfterPrint&#xA;    # 打印文档后激发&#xA;AfterUpdate&#xA;    # 传送完数据&#xA;BeforeCopy&#xA;    # 复制到剪贴板前&#xA;BeforeCut&#xA;    # 剪切到剪贴板前&#xA;BeforeEditFocus&#xA;BeforePaste&#xA;BeforePrint&#xA;BeforeUnload&#xA;BeforeUpdate&#xA;Bounce&#xA;CellChange&#xA;CtextMenu&#xA;Copy&#xA;Cut&#xA;DataAvailable&#xA;DatasetChanged&#xA;DatasetComplete&#xA;Drag&#xA;DragDrop&#xA;DragEnd&#xA;DragEnter&#xA;DragLeave&#xA;DragOver&#xA;DragStart&#xA;Drop&#xA;Error&#xA;ErrorUpdate&#xA;FilterChange&#xA;Finish&#xA;Help&#xA;LoseCapture&#xA;Move&#xA;Paste&#xA;&#xA;PropertyChange&#xA;ReadyStateChange&#xA;Resize&#xA;RowEnter&#xA;RowExit&#xA;RowsDelete&#xA;RowsInserted&#xA;Scroll&#xA;SelectStart&#xA;Start&#xA;Stop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;标签&#34;&gt;&#xA;  标签&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%87%e7%ad%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;var&amp;gt;               # 标识常量&#xA;&amp;lt;samp&amp;gt;              # 标识输出内容的样式&#xA;&amp;lt;pre&amp;gt;               # 代码块&#xA;&amp;lt;code&amp;gt;              # 一段代码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;属性&#34;&gt;&#xA;  属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局属性&#xA;    # 配置所有元素共有行为&#xA;    accesskey&#xA;        # 快捷键&#xA;        ## 需要按alt + 指定的键&#xA;    class&#xA;    contenteditable&#xA;        # 内容是否可修改, 如p标签&#xA;    contextmenu&#xA;        # 定义右键菜单，未实现&#xA;    dir&#xA;        # 文字对齐方式&#xA;    draggable&#xA;    dropzone&#xA;    hidden&#xA;    id&#xA;    lang&#xA;    spellcheck&#xA;    style&#xA;    tabindex&#xA;        # tab键切换元素的顺序&#xA;    title&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;浏览器特性&#34;&gt;&#xA;  浏览器特性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8f%e8%a7%88%e5%99%a8%e7%89%b9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;视频播放 &#xA;    支持vaapi, chrome 加上--enable-vaapi参数可以开启硬件加速解码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;标签&#xA;    &amp;lt;input&amp;gt;表单&#xA;        单选框&#xA;        &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; checked value=&amp;quot;1&amp;quot;&amp;gt;&#xA;        &amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;name&amp;quot; value=&amp;quot;1&amp;quot;&amp;gt;&#xA;        下拉框&#xA;        &amp;lt;select id=&amp;quot;mySelect&amp;quot; size=10 multiple&amp;gt;    # 长度等于10 ，多选&#xA;            &amp;lt;option selected=&amp;quot;selected&amp;quot;&amp;gt;Apple&amp;lt;/option&amp;gt;&#xA;            &amp;lt;option&amp;gt;Orange&amp;lt;/option&amp;gt;&#xA;        &amp;lt;/select&amp;gt;&#xA;        勾选框&#xA;        &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;&amp;quot; /&amp;gt;&#xA;        按钮&#xA;        &amp;lt;input type=&amp;quot;button&amp;quot;/&amp;gt;&#xA;        &amp;lt;button&amp;gt;                # &amp;lt;button&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;搜索&amp;lt;/button&amp;gt;        button之间可以加图片&#xA;        &#xA;    &amp;lt;table&amp;gt;表格&#xA;        &amp;lt;caption&amp;gt; # 标题&#xA;        &amp;lt;thead&amp;gt;&#xA;            &amp;lt;th&amp;gt;&#xA;                &amp;lt;td&amp;gt;&amp;lt;td&amp;gt;&#xA;            &amp;lt;/th&amp;gt;&#xA;        &amp;lt;tbody&amp;gt;&#xA;            &amp;lt;tr&amp;gt;&#xA;                &amp;lt;td&amp;gt;&amp;lt;td&amp;gt;&#xA;            &amp;lt;/tr&amp;gt;&#xA;        &amp;lt;tfoot&amp;gt;&#xA;            属性&#xA;                &amp;lt;tr style=&amp;quot;display: none;&amp;quot;&amp;gt;                # 设置属性为隐藏&#xA;&#xA;    &amp;lt;form&amp;gt;表单&#xA;        enctype属性&#xA;            application/x-www-form-urlencoded(默认)                # 在发送编码所有字符（空格转换为 &amp;quot;+&amp;quot; 加号，特殊符号转换为 ASCII HEX 值）&#xA;            multipart/form-data                                                        # 不对字符进行编码，在上传文件时使用&#xA;            text/plain                                                                        # 空格转换为+，但是不对特殊字符进行编码&#xA;            &#xA;    &amp;lt;hr&amp;gt;分割线&#xA;&#xA;    字体&#xA;        &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;  ...  &amp;lt;h6&amp;gt;&amp;lt;h6&amp;gt;标题标签对&#xA;        &#xA;        &amp;lt;b&amp;gt;粗体&amp;lt;/b&amp;gt;&amp;lt;i&amp;gt;斜体&amp;lt;/i&amp;gt;&amp;lt;u&amp;gt;下划线&amp;lt;/u&amp;gt;&amp;lt;tt&amp;gt;打字机风格&amp;lt;/tt&amp;gt;&amp;lt;cite&amp;gt;引用&amp;lt;/cite&amp;gt;&amp;lt;em&amp;gt;强调（斜体粗体）&amp;lt;/em&amp;gt;&amp;lt;strong&amp;gt;重要（黑体加粗体）&amp;lt;/strong&amp;gt;&#xA;        &#xA;        &amp;lt;sub&amp;gt;下标&amp;lt;/sub&amp;gt;&amp;lt;sup&amp;gt;上标&amp;lt;/sup&amp;gt;&#xA;        &#xA;        &amp;lt;font size =-7到+7  coler = 颜色&amp;gt;&amp;lt;/font&amp;gt;&#xA;&#xA;    &amp;lt;img src=&amp;quot;&amp;quot;/&amp;gt;图片&#xA;        属性&#xA;            alt                # 规定图像的替代文本&#xA;            border&#xA;            width&#xA;            height&#xA;&#xA;    &amp;lt;span&amp;gt;与 &amp;lt;div&amp;gt;&#xA;        &amp;lt;span&amp;gt; 在CSS定义中属于一个行内元素,在行内定义一个区域，也就是一行内可以被 &amp;lt;span&amp;gt; 划分成好几个区域&#xA;        ，从而实现某种特定效果。 &amp;lt;span&amp;gt; 本身没有任何属性。&#xA;        &amp;lt;div&amp;gt; 在CSS定义中属于一个块级元素 &amp;lt;div&amp;gt; 可以包含段落、标题、表格甚至其它部分。&#xA;        这使DIV便于建立不同集成的类，如章节、摘要或备注。在页面效果上，使用 &amp;lt;div&amp;gt; 会自动换行，使用 &amp;lt;span&amp;gt; 就会保持同行。&#xA;        &#xA;        &amp;lt;span&amp;gt;没有内边距&#xA;        &#xA;    &amp;lt;label&amp;gt;标签&#xA;        标记通常以下面两种方式中的一种来和表单控件相联系：将表单控件作为标记标签的内容，这样的就是隐式形式&#xA;        ，或者为 &amp;lt;label&amp;gt; 标签下的 for 属性命名一个目标表单 id，这样就是显式形式。&#xA;&#xA;        例如，在 XHTML 中：&#xA;            显式的联系：&#xA;            &amp;lt;label for=&amp;quot;SSN&amp;quot;&amp;gt;Social Security Number:&amp;lt;/label&amp;gt;&#xA;            &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;SocSecNum&amp;quot; id=&amp;quot;SSn&amp;quot; /&amp;gt;&#xA;            &#xA;            隐式的联系：&#xA;            &amp;lt;label&amp;gt;Date of Birth: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;DofB&amp;quot; /&amp;gt;&amp;lt;/label&amp;gt;&#xA;&#xA;    &amp;lt;head&amp;gt;标签&#xA;        &amp;lt;base&amp;gt; 标签为页面上的所有链接规定默认地址或默认目标。&#xA;        &amp;lt;meta http-equiv=&amp;quot;pragma&amp;quot; content=&amp;quot;no-cache&amp;quot;&amp;gt;        定义响应信息头&#xA;        &amp;lt;meta name=&amp;quot;keywrods&amp;quot; content=&amp;quot;keyword1,keyword2&amp;quot;&amp;gt;        关键字&#xA;        ＜meta name=&amp;quot;description&amp;quot; content=&amp;quot;This page is about the meaning of science, education,culture.&amp;quot;＞        网站主要内容&#xA;        ＜meta name=&amp;quot;robots&amp;quot; content=&amp;quot;none&amp;quot;＞        机器人索引 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 &#xA;        ＜meta name=&amp;quot;author&amp;quot; content=&amp;quot;outrun&amp;quot;＞                作者&#xA;        &#xA;    &amp;lt;marquee behavior = &amp;quot;alternate&amp;quot;&amp;gt;  文字行为                # alternate为来回滚动&#xA;        &amp;lt;font size = 30 color = &amp;quot;red&amp;quot;&amp;gt;www.it315.org&amp;lt;/font&amp;gt;&amp;lt;/marquee&amp;gt;&#xA;        &amp;lt;marquee behavior = &amp;quot;slide&amp;quot; &amp;quot;scroll&amp;quot; &amp;quot;alternate&amp;quot; direction=&amp;quot;up&amp;quot;&amp;quot;down&amp;quot;&amp;quot;left&amp;quot;&amp;quot;right&amp;quot;&amp;gt;你好&amp;lt;/marquee&amp;gt;&#xA;        &#xA;    &amp;lt;nobr&amp;gt; 标签之间的文字在浏览器中不换行显示&#xA;        &amp;lt;NOBR&amp;gt;这里是一行不该换行的文本 . . .&#xA;        这是文本行的结尾。&amp;lt;/NOBR&amp;gt;&#xA;&#xA;    &amp;lt;pre&amp;gt;&amp;lt;/pre&amp;gt;        标签之间的文字在浏览器中换行显示&#xA;        &#xA;    &amp;lt;blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;缩进&#xA;&#xA;    条目标签&#xA;        &amp;lt;dl&amp;gt;&#xA;            &amp;lt;dt&amp;gt;&#xA;                &amp;lt;dd&amp;gt;&#xA;                &amp;lt;/dd&amp;gt;&#xA;            &amp;lt;/dt&amp;gt;&#xA;        &amp;lt;/dl&amp;gt;显示条目&#xA;&#xA;        &amp;lt;ol&amp;gt;&#xA;            &amp;lt;li&amp;gt;&#xA;            &amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ol&amp;gt;数字标签列表&#xA;&#xA;        &amp;lt;ul&amp;gt;&#xA;            &amp;lt;li&amp;gt;&#xA;            &amp;lt;/li&amp;gt;&#xA;        &amp;lt;/ul&amp;gt;圆点标签列表&#xA;        &#xA;    &amp;lt;a&amp;gt;标签&#xA;        发送邮件&#xA;        &amp;lt;a href = &amp;quot;mailto:admin@it315.org?subject=咨询&amp;quot;&amp;gt;我要留言&amp;lt;/a&amp;gt;&#xA;                如：mailto:zxx@it315.org?cc=dreamdu@sina.com&amp;amp;subject=Feedback&amp;amp;body=how%20are%20you  # subject body cc 等用url参数拼接的方式拼接&#xA;                        %20代表空格 &#xA;                        subject= 是标题&#xA;                        body= 是邮件内容&#xA;                        CC=是抄送  &#xA;                        BCC=是暗送&#xA;&#xA;        新窗口&#xA;                &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot;/&amp;gt;&amp;lt;/a&amp;gt;打开新窗口&#xA;        属性&#xA;        &amp;lt;a name =&amp;quot;mark1&amp;quot;/&amp;gt;&#xA;        &amp;lt;a href=&amp;quot;text.html#mark1&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;定位&#xA;        &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;打开自己&#xA;        &amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;打开目录&#xA;&#xA;    &amp;lt;map&amp;gt;&amp;lt;/map&amp;gt;定义热点映射4&#xA;        &amp;lt;area&amp;gt;&amp;lt;/area&amp;gt;来说明 属性shape形状，coords坐标，href或nohref，target赖志明浏览器的哪个窗口或帧中显示&#xA;        &amp;lt;img&amp;gt;标签中增加名为usemap的属性来指定图像被用做图像地图，其设置值为图像热点名称 如&amp;lt;img src=&amp;quot;&amp;quot; usemap=&amp;quot;#mymap&amp;quot;&amp;gt;&#xA;        &amp;lt;img src=&amp;quot;logo.gir&amp;quot; border=0 usemap=&amp;quot;#mymap&amp;quot;&amp;gt;&#xA;        &amp;lt;map name=mymap&amp;gt;&#xA;        &amp;lt;area shape=&amp;quot;rect&amp;quot; coords=&amp;quot;0,0,50,50&amp;quot; href=&amp;quot;&amp;quot;&amp;gt;  左上和右下坐标 shape的属性值 rect poly circle&#xA;        &amp;lt;/map&amp;gt;&#xA;&#xA;    &amp;lt;embed&amp;gt;&amp;lt;/embed&amp;gt;标签 添加swf类型flash元素&#xA;        scale=&amp;quot;noscale&amp;quot;                # 没有比例缩放&#xA;        wmode=&amp;quot;transparent&amp;quot;                # 背景透明&#xA;&#xA;样式&#xA;    小图标&#xA;        &amp;lt;link rel=&amp;quot;Shortcut Icon&amp;quot; href=&amp;quot;../imgs/favicon48.ico&amp;quot;&amp;gt;  # 网页小图标&#xA;        &amp;lt;link rel=&amp;quot;Bookmark&amp;quot; href=&amp;quot;../imgs/favicon48.ico&amp;quot;&amp;gt;                        # 收藏夹小图标&#xA;        &#xA;行为&#xA;    url标准&#xA;        基准url + 相对 url = 完整url&#xA;            http://www.it315.org/index.html#section2%E5%AE%9A%E4%BD%8D%E5%88%B0section2&#xA;                &#xA;        url中空格必须转换为+&#xA;        url中用字符的当前字符集编码在内存中的十六进制格式表示，并在每个字节前加上%&#xA;        如果确信特殊字符不会引起冲突，也可以直接传递给服务器，如汉字。也可以一部分编码，一部分不编码，如中&amp;amp;国 就是 中%26国&#xA;&#xA;&#xA;    文件下载&#xA;        超链接post提交&#xA;            &amp;lt;form action=&amp;quot;${pageContext.request.contextPath }/downloadFile&amp;quot;        method=&amp;quot;post&amp;quot; enctype=&amp;quot;application/x-www-form-urlencoded&amp;quot;&amp;gt;&#xA;                &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;uuidFileName&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;&#xA;                &amp;lt;a href=&amp;quot;#&amp;quot; onclick=&amp;quot;download(&#39;${fileName}&#39;)&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&#xA;            &amp;lt;/form&amp;gt;                &#xA;            &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&#xA;                function download(fileName) {&#xA;                    $(&amp;quot;:hidden&amp;quot;).val(fileName);&#xA;                    document.forms[0].submit();&#xA;                }&#xA;            &amp;lt;/script&amp;gt;&#xA;    根目录&#xA;        &amp;lt;head&amp;gt;&#xA;        &amp;lt;base href=&amp;quot;http://www.w3school.com.cn/i/&amp;quot; target=&amp;quot;_blank&amp;quot; /&amp;gt;                # href必选, target可选&#xA;                                                                                        ## js中的相对目录也起作用&#xA;        &amp;lt;/head&amp;gt;&#xA;    frameset&#xA;        frameset的例子&#xA;            &amp;lt;frameset rows=&amp;quot;70,*&amp;quot; cols=&amp;quot;*&amp;quot; frameborder=&amp;quot;no&amp;quot; border=&amp;quot;0&amp;quot; framespacing=&amp;quot;0&amp;quot;&amp;gt;&#xA;            &amp;lt;frame src=&amp;quot;head.html&amp;quot; name=&amp;quot;topFrame&amp;quot; scrolling=&amp;quot;No&amp;quot; noresize=&amp;quot;noresize&amp;quot; id=&amp;quot;topFrame&amp;quot; /&amp;gt;&#xA;            &amp;lt;frameset cols=&amp;quot;193,*&amp;quot; frameborder=&amp;quot;no&amp;quot; border=&amp;quot;0&amp;quot; framespacing=&amp;quot;0&amp;quot;&amp;gt;&#xA;                &amp;lt;frame src=&amp;quot;left.html&amp;quot; scrolling=&amp;quot;No&amp;quot; noresize=&amp;quot;noresize&amp;quot; id=&amp;quot;leftFrame&amp;quot; /&amp;gt;&#xA;                &amp;lt;frame src=&amp;quot;main.html&amp;quot; name=&amp;quot;mainFrame&amp;quot; id=&amp;quot;mainFrame&amp;quot; /&amp;gt;&#xA;            &amp;lt;/frameset&amp;gt;&#xA;            &amp;lt;/frameset&amp;gt;&#xA;            &#xA;            # 在head.html 中的标签中添加链接&#xA;            ## &amp;lt;a href=&amp;quot;/a.html&amp;quot; target=&amp;quot;mainFrame&amp;quot;&amp;gt;Frame main.html&amp;lt;/a&amp;gt;&#xA;            ## 就可以使name 为 mainFrame的&amp;lt;frame&amp;gt;窗体刷新&#xA;            &#xA;            # 在src属性后面添加#name，可以跳转到指定名子的框架&#xA;            ## &amp;lt;frame src=&amp;quot;/example/html/link.html#C10&amp;quot;&amp;gt;跳转到link.html页面的：&amp;lt;a name=&amp;quot;C10&amp;quot;&amp;gt;&amp;lt;h2&amp;gt;Chapter 10&amp;lt;/h2&amp;gt;&amp;lt;/a&amp;gt;位置&#xA;            ## 也可以在a标签中设置跳转&amp;lt;a href=&amp;quot;/example/html/link.html#C10&amp;quot; target=&amp;quot;showframe&amp;quot;&amp;gt;带有锚的链接&amp;lt;/a&amp;gt;&#xA;&#xA;        内联框架：iframe 的例子&#xA;            &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&#xA;            function changeUrl(vPageName){&#xA;            var vIfr=document.getElementById(&amp;quot;ifrObj&amp;quot;);&#xA;            vIfr.src=vPageName+&amp;quot;.asp&amp;quot;;&#xA;            }&#xA;            &amp;lt;/script&amp;gt;&#xA;            &amp;lt;iframe id=&amp;quot;ifrObj&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&#xA;            &amp;lt;a href=&amp;quot;javascript:changeUrl(&#39;2&#39;)&amp;quot;&amp;gt;a&amp;lt;/a&amp;gt;&#xA;            &amp;lt;a href=&amp;quot;javascript:changeUrl(&#39;3&#39;)&amp;quot;&amp;gt;b&amp;lt;/a&amp;gt; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;svg&#34;&gt;&#xA;  svg&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#svg&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    scalable vector graphics, 可缩放矢量图形&#xA;    使用xml格式定义图像&#xA;    由w3c定制&#xA;例子&#xA;    &amp;lt;svg xmlns=&amp;quot;http://www.w3.org/2000/svg&amp;quot; version=&amp;quot;1.1&amp;quot;&amp;gt;&#xA;        &amp;lt;rect width=&amp;quot;300&amp;quot; height=&amp;quot;100&amp;quot; style=&amp;quot;fill:rgb(0, 0, 255); stroke-width:1; stroke:rgb(0, 0, 0)&amp;quot;&amp;gt;&amp;lt;/rect&amp;gt;&#xA;            # 矩形&#xA;    &amp;lt;/svg&amp;gt;&#xA;滤镜&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Css</title>
      <link>https://ukeate.com/docs/pl/markup_language/css/</link>
      <pubDate>Tue, 09 Oct 2018 16:27:24 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/markup_language/css/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# cascading style sheet&#xA;层级匹配&#xA;    不同级&#xA;        1. style属性&#xA;        2. style标签&#xA;        3. link标签&#xA;        4. 浏览器中用户自定义样式表&#xA;        5. 浏览器默认样式             # 浏览器对每个元素定义了默认的样式表&#xA;    !important&#xA;        color: black !important&#xA;    同级                            # 评估得出最特殊的样式, 评分相同时，使用最后的&#xA;        1. id值的数目&#xA;        2. 其它属性和伪类的数目&#xA;        3. 元素名和伪元素的数目&#xA;继承&#xA;    部分元素继承父元素样式&#xA;        外观继承&#xA;        布局不继承&#xA;    inherit                         # 指明使用父元素样式&#xA;        border: inherit    &#xA;三种引入方式&#xA;    内联式&#xA;        &amp;lt;div style=&amp;quot;color:#000;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#xA;    嵌入式&#xA;        &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;&#xA;            div {color:#000;}&#xA;        &amp;lt;/style&amp;gt;&#xA;    引用式&#xA;        &amp;lt;link href=&amp;quot;css.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; /&amp;gt;&#xA;        @&#xA;            @charset &amp;quot;UTF-8&amp;quot;        # 默认UTF-8, 在import前&#xA;            @import &amp;quot;styles.css&amp;quot;    # 静态引用, 效率比&amp;lt;link&amp;gt;标签慢&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;单位&#34;&gt;&#xA;  单位&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e4%bd%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;颜色&#xA;    名称, 如silver, gray&#xA;    0xffffff&#xA;    rgb(112, 128, 144)&#xA;    rgb(112, 128, 114, 0.4)&#xA;    hsl(120, 100%, 22%)         # 色相(hue), 饱和度(saturation), 明度(lightness)&#xA;    hsl(120, 100%, 22%, 0.4)&#xA;长度&#xA;    绝对单位                      # 只有在打印和设计文档时才用绝对单位&#xA;        cm&#xA;        pt                      # 磅&#xA;        in                      # 英寸&#xA;        mm&#xA;        pc                      # pica 等于12磅&#xA;    相对长度&#xA;        em                      # 元素字号&#xA;        ex                      # 元素字体的&#39;x高度&#39;，字体基线到中线的距离，一般与x的高度相当，大致等于0.5em&#xA;        rem                     # 根元素(html元素)字号&#xA;        px                      # css像素，假定了设备的分辨率为96dpi, 是1英寸的1/96(windows系统标准像素密度, 其它平台浏览器自己转换), css在定义中px是相对单位，但浏览器实现中全是绝对单位&#xA;        %                       # 不是所有元素都可以用, 不同属性中%定义不同，如font-size挂钩继承的font-size值, width挂钩元素包含块的宽度&#xA;    算式                        # css3 未得到广泛支持&#xA;        width: calc(80% - 20px);&#xA;角度&#xA;    deg                         # 度, 0 - 360&#xA;    grad                        # 百分度 0 - 400&#xA;    rad                         # 弧度 0 - 6.28&#xA;    turn                        # 圆周 1 turn = 360 deg&#xA;时间&#xA;    s&#xA;    ms&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;选择器&#34;&gt;&#xA;  选择器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%89%e6%8b%a9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;*                               # 所有元素&#xA;&amp;lt;type&amp;gt;                          # 标签&#xA;.&amp;lt;class&amp;gt;                        # 样式&#xA;#&amp;lt;id&amp;gt;                           # id&#xA;[attr]                          # 属性, 如[title] {}&#xA;[attr=&amp;quot;val&amp;quot;]&#xA;[attr^=&amp;quot;val&amp;quot;]                   # 以val开头&#xA;[attr$=&amp;quot;val&amp;quot;]&#xA;[attr*=&amp;quot;val&amp;quot;]                   # 包含val&#xA;[attr~=&amp;quot;val&amp;quot;]                   # 属性多值有val, 空格隔开&#xA;    [class~=&amp;quot;class2&amp;quot;] {}&#xA;[attr|=&amp;quot;val&amp;quot;]                   # 属性多值有val, - 隔开&#xA;    [lang |=&amp;quot;en&amp;quot;] &#xA;&amp;lt;selector&amp;gt;, &amp;lt;selector&amp;gt;          # 同时匹配&#xA;&amp;lt;selector&amp;gt; &amp;lt;selector&amp;gt;           # 后代&#xA;&amp;lt;selector&amp;gt; &amp;gt; &amp;lt;selector&amp;gt;         # 直接后代&#xA;&amp;lt;selector&amp;gt; + &amp;lt;selector&amp;gt;         # p 之后的第一个兄弟a&#xA;&amp;lt;selector&amp;gt; ~ &amp;lt;selector&amp;gt;         # p 之后所有兄弟a&#xA;&#xA;o-&amp;gt; 伪元素                       # 直接使用匹配所有&#xA;::first-line                    # 块级元素文本首行&#xA;::first-letter                  # 块级元素文本首字母&#xA;:before                         # 之前插入内容&#xA;    {content: &#39;a&#39;}&#xA;:after                          # 之后插入内容&#xA;&#xA;o-&amp;gt; 伪类                         # 直接使用匹配所有&#xA;:root                           # 文档根元素, 总是返回html元素&#xA;:first-child                    # 第一子元素&#xA;    p &amp;gt; span: first-child , p 下面第一个span元素&#xA;:last-child&#xA;:only-child                     # 只有一个子元素的该元素&#xA;:only-of-type                   # 同上但指定类型，直接使用时会匹配更多，因为很多某类型的唯一元素&#xA;:nth-child(n)                   # body &amp;gt; :nth-child(2)&#xA;:nth-last-child(n)&#xA;:nth-of-type(n)&#xA;:nth-last-of-type(n)&#xA;&#xA;o-&amp;gt; UI  伪类&#xA;:enabled                        # 已启用的元素&#xA;:disabled                       # 禁用的元素&#xA;:checked                        # 选中的单选或复选按钮&#xA;:default                        # 默认的元素, 如 &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;, 常和outline属性一起使用&#xA;:valid                          # 输入验证有效的元素&#xA;:invalid&#xA;:in-range                       # 范围内的input元素, 未广泛支持&#xA;:out-of-range&#xA;:required                       # 允许使用required属性的input元素&#xA;:optional                       # 非required&#xA;&#xA;o-&amp;gt; 动态伪类&#xA;:link                           # 未访问的a元素&#xA;:visited                        # 已访问过的a元素&#xA;:hover&#xA;:active                         # 当前激活的元素(鼠标按下)&#xA;:focus                          # 获得焦点的元素&#xA;:not(&amp;lt;selector&amp;gt;)                # a:not([href*=&amp;quot;apress&amp;quot;])&#xA;:empty                          # 无子元素的元素&#xA;:lang(&amp;lt;language&amp;gt;)               # lang属性为指定值&#xA;    :lang(en) 匹配 &amp;lt;a lang=&amp;quot;en-us&amp;quot;&amp;gt;&#xA;:target                         # url hash(片段标识符) 定向id所在的元素&#xA;&#xA;例子&#xA;    o-&amp;gt;&#xA;    span.class2 {}&#xA;&#xA;    o-&amp;gt;&#xA;    body &amp;gt; * &amp;gt; span, tr &amp;gt; th {}&#xA;&#xA;    o-&amp;gt; 计数器&#xA;    body {counter-reset: paracount;}&#xA;    p:before {&#xA;        content: counter(paracount) &amp;quot; &amp;quot;;&#xA;        counter-increment: paracount;&#xA;            # counter-increment: paracount 2; 可以增加2&#xA;    }&#xA;&#xA;    o-&amp;gt;&#xA;    :checked + span&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;属性&#34;&gt;&#xA;  属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;布局&#34;&gt;&#xA;  布局&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%83%e5%b1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;position                        # 默认static, top等属性不起作用&#xA;    static&#xA;    absolute&#xA;    fixed                       # fixed滚动固定&#xA;    relative&#xA;left&#xA;right&#xA;top&#xA;bottom&#xA;&#xA;z-index&#xA;columns                         # 列数和列宽的简写属性&#xA;column-count                    # 多列布局的列数&#xA;    column-fill                 # 列间内容分布方式&#xA;    column-gap                  # 列间隔&#xA;    column-rule                 # 列间规则的简写属性&#xA;    column-rule-color&#xA;    column-rule-style&#xA;    column-rule-width&#xA;    column-span                 # 元素跨列数&#xA;    column-width&#xA;flex-align                      # 弹性盒子布局, 未实现&#xA;    flex-direction&#xA;    flex-order&#xA;    flex-pack&#xA;    -webkit-box-align           # 内容高度小于容器高度时&#xA;        # start(顶边放置), end(底边放置), center(中间放置), baseline, stretch(拉伸元素)&#xA;        -webkit-box-flex        # 元素可伸缩性&#xA;        -webkit-box-pack        # 元素伸缩到最大尺寸(max-width)时怎么做&#xA;            # start(左边放置), end(右边放置), center(中间放置), justify(平均分配到各个元素间)&#xA;        -webkit-box-direction   # 内部盒子排列顺序&#xA;例子&#xA;    o-&amp;gt; 多列布局&#xA;    column-count: 3;&#xA;    column-fill: balance;&#xA;    column-rule: medium solid black;&#xA;    column-gap: 1.5em;&#xA;    column-width: 10em;&#xA;&#xA;    o-&amp;gt; 弹性盒&#xA;    #container {&#xA;        display: -webkit-box;&#xA;        -webkit-box-direction: reverse;&#xA;        -webkit-box-align: end;&#xA;        -webkit-box-pack: justify;&#xA;    }&#xA;    #first {-webkit-box-flex: 3;}&#xA;    #second {-webkit-box-flex: 1;}&#xA;&#xA;    o-&amp;gt; css表格&#xA;    #table {display: table;}&#xA;    div.row {display: table-row;}&#xA;    p {display: table-cell;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;盒模型&#34;&gt;&#xA;  盒模型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%92%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;box-sizing                      # 尺寸样式(如width, height)应用到哪部分&#xA;    # content-box, padding-box, border-box, margin-box&#xA;display&#xA;    inline                      # 显示为文本行中的字&#xA;        inline时，忽略width, height, margin属性&#xA;    block                       # 显示为段落, 在垂直方向有所区别&#xA;    inline-block                # 显示为文本行, 整体作为inline, 但内部作为block, 这样认width, height, margin属性&#xA;    list-item                   # 显示为列表项&#xA;    run-in                      # 类型取决于周围元素&#xA;        包含display:block元素，就是block&#xA;        兄弟都是block时，为inline&#xA;        其它都为block&#xA;    compact                     # 为块或标记盒(类list-item), 一般不支持&#xA;    flexbox                     # 弹性盒布局用&#xA;        -webkit-box&#xA;    table                       # 表格布局用&#xA;        inline-table&#xA;        table-caption           # 类似caption&#xA;        table-row-group         # 类似tbody&#xA;        table-header-group      # 类似thead&#xA;        table-footer-group      # 类似tfoot&#xA;        table-row               # 类似tr&#xA;        table-column-group      # 类似colgroup&#xA;        table-column            # 类似col&#xA;        table-cell              # 类似td&#xA;    ruby                        # ruby注释的文本布局用&#xA;        ruby-base&#xA;        ruby-text&#xA;        ruby-base-group&#xA;        ruby-text-group&#xA;    none                        # 元素不可见，不占空间&#xA;float                           # 元素左边界或右边界移动到包含块或另一个浮动盒的边界。其余inline部分流式环绕&#xA;    left, right, none&#xA;clear                           # 左右边界不能挨着另外浮动元素&#xA;    left, right, both, none&#xA;padding&#xA;    padding-bottom&#xA;    padding-left&#xA;    padding-right&#xA;    padding-top&#xA;margin&#xA;    margin-bottom&#xA;    margin-left&#xA;    margin-right&#xA;    margin-top&#xA;height                          # 长度或百分比&#xA;width&#xA;    max-height&#xA;    max-width&#xA;    min-height&#xA;    min-width&#xA;overflow&#xA;    auto                        # 同scroll, 但自动加滚动条&#xA;    hidden                      # 剪掉&#xA;    on-content                  # 移除内容, 已废弃&#xA;    on-display                  # 隐藏内容, 已废弃&#xA;    scroll, visible             # 溢出&#xA;overflow-x&#xA;overflow-y&#xA;&#xA;visibility                      # 元素可见性&#xA;    collapse                    # 不可见，不占据空间, 只能用在表相关内容，如tr, td&#xA;    hidden                      # 不可见，占据空间&#xA;    visible&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;边框&#34;&gt;&#xA;  边框&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%b9%e6%a1%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;border                          # border: 30px dashed #000&#xA;border-width                    # 可以是长度值, 百分比, thin, medium, thick &#xA;    border-width: 15px 5px 15px 5px&#xA;border-style&#xA;    none 默认&#xA;    dashed 破折线&#xA;    dotted 圆点&#xA;    double 双线&#xA;    groove 槽线&#xA;    inset 内嵌效果&#xA;    outset 外凸效果&#xA;    ridge 脊线&#xA;    solid 实线&#xA;&#xA;    border-style: solid dotted dashed double 定义了上、右、下、左的样式&#xA;    border-style: none的时候，边框其它属性无意义&#xA;border-color&#xA;    blue rgb(25%, 35%, 45%) #909090 red;&#xA;border-image                    # 不广泛支持&#xA;    border-image-outset&#xA;    border-image-repeat&#xA;        stretch 拉伸&#xA;        repeat 平铺&#xA;        round 不截断下拉伸&#xA;        space不截断下图片间保留间距平铺&#xA;    border-image-slice&#xA;    border-image-source&#xA;    border-image-width&#xA;&#xA;    o-&amp;gt;&#xA;    -webkit-border-image, -moz-border-image, -o-border-image&#xA;    border-image: url(a.png) 30 / 50px round repeat; 九宫格切分长度都为30, 宽度为50, 横round, 竖repeat&#xA;border-left&#xA;    border-left-style&#xA;    border-left-color&#xA;    border-left-width&#xA;border-right&#xA;    border-right-color&#xA;    border-right-style&#xA;    border-right-width&#xA;border-top&#xA;    border-top-style&#xA;    border-top-color&#xA;border-top-width&#xA;border-top-left-radius&#xA;    border-top-left-radius: 20px 15px; x半径20, y半径15&#xA;border-top-right-radius&#xA;border-bottom&#xA;    border-bottom-style&#xA;    border-bottom-width&#xA;    border-bottom-color&#xA;    border-bottom-left-radius&#xA;    border-bottom-right-radius&#xA;border-radius&#xA;    border-radius: 20px / 15px;&#xA;    border-radius: 50% 20px 25% 5em / 25% 15px 40px 55%&#xA;&#xA;box-shadow&#xA;    box-shadow: hoffset voffset blur spread color inset&#xA;    水平偏移量, 正向右，负向左。垂直偏移量，正向下，负向上。模糊值。阴影延伸半径，正向各方向延伸，负缩小。颜色。内嵌阴影&#xA;    可设置多组阴影，用, 隔开&#xA;outline                         # 轮廓不属于页面，不影响布局, &amp;lt;颜色&amp;gt; &amp;lt;样式&amp;gt; &amp;lt;宽度&amp;gt;&#xA;    outline-color&#xA;    outline-offset              # 距元素边框边缘的偏移量&#xA;    outline-style               # 同border-style&#xA;    outline-width               # 同border-width&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;背景&#34;&gt;&#xA;  背景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%83%8c%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 不继承&#xA;background                      # background: &amp;lt;background-color&amp;gt; &amp;lt;background-position&amp;gt; &amp;lt;background-size&amp;gt; &amp;lt;background-repeat&amp;gt; &amp;lt;background-origin&amp;gt; &amp;lt;background--clip&amp;gt; &amp;lt;background-attachment&amp;gt; &amp;lt;background-image&amp;gt;&#xA;background-attachment           # 背景附着方式&#xA;    fixed 固定到视窗上, 不随文字滚动&#xA;    local 随文字滚动&#xA;    scroll 固定到元素上(使用浏览器的滚动条), 不随文字滚动&#xA;background-color                # 原点在border外边缘&#xA;    函数&#xA;        linear-gradient(transparent, rgba(0, 0, 0, 0.1) 20%, rgba(0, 0, 0, 0.5) 65%, rgba(0, 0, 0, 0.66))&#xA;            # 线性渐变 &#xA;background-image                # 原点在padding外边缘，也就是border内边缘&#xA;    background-image: url(&amp;quot;bg.jpg&amp;quot;)&#xA;background-position             # 起始位置, 可以是长度, top, left, right ,bottom, center, 第一个值控制垂直位置, 第二个值控制水平位置&#xA;    0px 0px                     # 左上偏移0, 0    &#xA;    right ？                    # 位置在右边显示&#xA;    left ？                     # 位置在左连显示(默认)&#xA;    ？ bottom&#xA;    center center               # 位置在中间显示、内容从中间开始显示(默认)&#xA;    ? top                       # 内容从上开始显示&#xA;background-repeat&#xA;    no-repeat&#xA;    repeat 水平和垂直同时平铺&#xA;    repeat-x 水平平铺&#xA;    repeat-y &#xA;    space 水平或垂直平铺, 统一间距,不截断, round 水平或垂直拉伸, 不截断&#xA;background-size                 # 可以长度值或百分比&#xA;    contain 等比缩放, 宽高适应匹配, 不超出容器&#xA;    cover 等比缩放, 宽高最大适应匹配, 可超出容器&#xA;    auto 本身尺寸显示&#xA;background-origin               # 定位显示原点&#xA;    border-box 边框盒子内 &#xA;    padding-box 内边距盒子内&#xA;    content-box 内容盒子内&#xA;background-clip                 # 裁剪, 属性同上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;色彩&#34;&gt;&#xA;  色彩&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%89%b2%e5%bd%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;opacity&#xA;color                           # 前景颜色&#xA;    rgba(255, 255, 255, 0.7)&#xA;user-select                     # 用户不可选择&#xA;filter                          # 滤镜效果, ie8 或之前使用&#xA;    filter:alpha(opacity=50)，同opacity: .5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;文本&#34;&gt;&#xA;  文本&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e6%9c%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;text-decoration                 # node时 a标签没有下划线&#xA;text-indent                     # 首行缩进&#xA;text-align&#xA;    start 语言的起始边界，可能是右&#xA;    end, left, right, center, justify&#xA;text-justify                    # text-align: justify时来指定规则&#xA;    auto&#xA;    none 禁用文本对齐&#xA;    inter-word 空白在单词之间&#xA;    inter-ideograph 中日韩&#xA;    inter-cluster 泰&#xA;    distribute, kashida 草体&#xA;text-transform                  # 转换大小写&#xA;    none, capitalize, uppercase, lowercase&#xA;text-decoration                 # 文本装饰&#xA;    none, underlinenone, overline, line-through, blink&#xA;text-shadow                     # 文本阴影, &amp;lt;h-shadow&amp;gt; &amp;lt;v-shadow&amp;gt; &amp;lt;blur&amp;gt; &amp;lt;color&amp;gt;, 水平偏移, 垂直偏移, 模糊程度, 颜色&#xA;direction                       # 文本对齐&#xA;    ltr, rtl&#xA;word-spacing                    # 词间距&#xA;letter-spacing # 字母间距&#xA;white-space&#xA;    normal 空白被压缩，文本行自动换行&#xA;    nowrap 空白压缩，文本行不换行&#xA;    pre 空白不压缩, 换行符换行&#xA;    pre-line 空白压缩，自动换行或换行符换行&#xA;    pre-wrap 空白不压缩, 自动换行或换行符换行&#xA;line-height                     # 行高, 百分比，长度&#xA;word-wrap                       # 行超距单词截断&#xA;    normal 溢出&#xA;    break-word&#xA;@font-face                      # 指定web字体, woff得到最广泛支持, 在@font-face中定义，font-family中使用&#xA;    @font-face {&#xA;        font-family: &#39;MyFont&#39;;&#xA;        font-style: normal;&#xA;        font-weight: normal;&#xA;        src: url(&#39;http://a/MyFont.woff&#39;)&#xA;    }&#xA;font                            # &amp;lt;font-style&amp;gt; &amp;lt;font-variant&amp;gt; &amp;lt;font-weight&amp;gt; &amp;lt;font-size&amp;gt; &amp;lt;font-family&amp;gt;&#xA;    简写属性&#xA;        font-family             # serif, sans-serif, monospace, cursive, fantasy&#xA;            font-family: MyFont, cursive&#xA;        font-style              # normal, italic, oblique&#xA;font-variant                    # normal, small-caps&#xA;    font-weight                 # bold, bolder, lighter&#xA;    font-size&#xA;        xx-small 浏览器决定的大小&#xA;        x-small, small, medium, large, x-large, xx-large&#xA;        smaller 相对父元素字体的大小&#xA;        larger, &amp;lt;length&amp;gt;, &amp;lt;%&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;列表样式&#34;&gt;&#xA;  列表样式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%97%e8%a1%a8%e6%a0%b7%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;list-style                      # &amp;lt;list-style-type&amp;gt; &amp;lt;list-style-position&amp;gt; &amp;lt;list-style-image&amp;gt;&#xA;    list-style-type             # 列表项前标记&#xA;        none, box, check, circle, diamond, disc, dash, square, decimal, binary, lower-alpha, upper-alpha&#xA;    list-style-image            # 图片作为列表标记&#xA;    list-style-position         # 相对于内容框的位置&#xA;        inside 内容框内部&#xA;        outside 外部&#xA;vertical-align                  # 垂直对齐（文字不行）&#xA;&#xA;cursor&#xA;    auto ：标准光标&#xA;    default ：标准箭头&#xA;    hand ：手形光标&#xA;    wait ：等待光标&#xA;    text ：I形光标&#xA;    vertical-text ：水平I形光标&#xA;    no-drop ：不可拖动光标&#xA;    not-allowed ：无效光标&#xA;    help ：?帮助光标&#xA;    all-scroll ：三角方向标&#xA;    move ：移动标&#xA;    crosshair ：十字标 &#xA;    pointer&#xA;    e-resize n-resize nw-resize w-resize s-resize se-resize sw-resize ne-resize&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;表格样式&#34;&gt;&#xA;  表格样式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e6%a0%bc%e6%a0%b7%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;border-collapse                 # 相邻单元格边框样式&#xA;    separate 默认，重复画框&#xA;    collapse 合并边框&#xA;border-spacing                  # 相邻单元格边框距离&#xA;table-layout                    # 单元格行列的算法规则&#xA;    auto&#xA;    fixed 由表格自身样式和每列width属性决定布局[无则设等间距]，由第一行决定列宽，以下行内容自动换行&#xA;caption-side                    # 表格标题的位置&#xA;    top, bottom&#xA;empty-cells                     # 是否显示表格中空单元格&#xA;    hide&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;计数器&#34;&gt;&#xA;  计数器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e6%95%b0%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;counter-reset                   # 用于有序列表&#xA;counter-increment&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;动画&#34;&gt;&#xA;  动画&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e7%94%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    本质是增强过渡&#xA;@keyframes&#xA;    指定一个以上关键帧&#xA;    只在过程中有效，动画结束后即使仍hover, 也返回初始状态&#xA;animation&#xA;    动画，动画完后回到初始状态。想停留在结束状态用过渡。&#xA;    可以用在初始布局中&#xA;    通过keyframe显式控制， 可重用&#xA;    &amp;lt;animation-name&amp;gt; &amp;lt;animation-duration&amp;gt; &amp;lt;animation-timing-function&amp;gt; &amp;lt;animation-delay&amp;gt; &amp;lt;animation-iteration-count&amp;gt;&#xA;        只是模拟属性值改变来实现动画，动画结束后属性无变化&#xA;        可以应用到页面的初始布局中去，而transform只能应用在动作上&#xA;&#xA;    animation-delay             # 延迟，可以指定多个值，对应transition-property中的多个属性&#xA;    animation-direction         # 重复播放时播放方向&#xA;        normal 每次向前播放&#xA;        alternate 先向前，再反向，相当于animation-iteration-count: 2&#xA;    animation-duration          # 持续时间, 可多值&#xA;    animation-iteration-count   # 循环次数&#xA;        infinite                # 无休止交替播放&#xA;    animation-name              # 关键帧集合名称，可多个&#xA;    animation-play-state        # 动画状态, js中ele.style.webkitAnimationPlayState = &#39;paused&#39;&#xA;        paused                  # 停止&#xA;        playing                 # 开始播放&#xA;    animation-timing-function   # 关键帧时间插值函数&#xA;        normal                  # 每次重复向前播放&#xA;        alternate               # 先向前播放，再反向播放，相当于animation-iteration-count: 2&#xA;transform                       # 变换，动画结束后属性有变化&#xA;    -moz-transform: rotate(-45deg) scaleX(1.2)              # 逆时针旋转45度, 延x轴缩放到1.2倍&#xA;    函数&#xA;        translate               # 水平、垂直或两个方向 平衡。长度，百分比&#xA;        translateX&#xA;        translateY&#xA;        scale                   # 数&#xA;        scaleX&#xA;        scaleY&#xA;        rotate                  # 角度&#xA;        skew                    # 倾斜, 角度&#xA;        skewX&#xA;        skewY&#xA;        matrix                  # 6个参数。自定义变换, 由于z缩放未被实现，后两个参数省略&#xA;    transform-origin            # 变换的起点，默认是元素中心点&#xA;        transform-origin right top;&#xA;        长度，百分比，left center right, top center, bottom&#xA;&#xA;transition                      # &amp;lt;transition-property&amp;gt; &amp;lt;transition-duration&amp;gt; &amp;lt;transition-timing-function&amp;gt; &amp;lt;transition-delay&amp;gt;, 可以作为初始状态，也可以过渡&#xA;    transition-delay            # 开始之间延迟时间, ms&#xA;    transition-duration         # 持续时间, ms&#xA;    transition-property         # 应用过渡的多个属性&#xA;    transition-timing-function              # 时间函数&#xA;        ease 默认&#xA;        linear&#xA;        ease-in&#xA;        ease-out&#xA;        ease-in-out&#xA;        cubic-bezier 指定自定义曲线&#xA;&#xA;    o-&amp;gt;&#xA;    -webkit-&#xA;    transition: .2s background-cololr&#xA;    transition: .2s all&#xA;示例&#xA;    o-&amp;gt; 过渡&#xA;    #banana {&#xA;        font-size: large;&#xA;        border: medium solid black;&#xA;        -webkit-transition-delay: 10ms;&#xA;        -webkit-transition-duration: 250ms;&#xA;            # 反向过渡&#xA;    }&#xA;    #banana:hover {&#xA;        font-size: x-large;&#xA;        border: medium solid white&#xA;        background-color: green;&#xA;        color: white;&#xA;        padding: 4px;&#xA;        -webkit-transition-delay: 100ms;&#xA;        -webkit-transition-property: background-color, color, &#xA;            padding, font-size, border;&#xA;        -webkit-transition-duration: 500ms;&#xA;        -webkit-transition-timing-function: linear;&#xA;    }&#xA;&#xA;    o-&amp;gt; 动画&#xA;    #banana:hover {&#xA;        -webkit-animation-delay: 100ms;&#xA;        -webkit-animation-duration: 500ms;&#xA;        -webkit-animation-iteration-count: infinite;&#xA;        -webkit-animation-timing-function: linear;&#xA;        -webkit-animation-name: &#39;GrowShrink&#39;;&#xA;        -webkit-animation-direction: alternate;&#xA;    }&#xA;    @-webkit-keyframes GrowShrink {&#xA;        from {&#xA;            # 可以用0%替代&#xA;            font-size: xx-small;&#xA;            background-color: red;&#xA;        }&#xA;        50% {&#xA;            # 定义了变化的速率，可以用0%, 100%代替from和to子句&#xA;            background-color: yellow;&#xA;            padding: 1px;&#xA;        }&#xA;        to {&#xA;            # 可以用100%替代&#xA;            font-size: x-large;&#xA;            border: medium solid white;&#xA;            background-color: green;&#xA;            color: white;&#xA;            padding: 4px;&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; 变换&#xA;    #banana {&#xA;        -moz-transform: rotate(-45deg) scale(1.2);&#xA;        -moz-transform-origin: right top;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;典型问题&#34;&gt;&#xA;  典型问题&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b8%e5%9e%8b%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;垂直居中&#xA;    line-height&#xA;        .content {&#xA;            height: 100px;&#xA;            line-height: 100px;&#xA;        }&#xA;    vertical-align&#xA;        .wrapper {display: table;}&#xA;        .cell {&#xA;            display: table-cell;&#xA;            vertical-align: middle;&#xA;        }&#xA;    position&#xA;        .wrapper {position: relative}&#xA;        .content {&#xA;            left: 50%;&#xA;            top: 50%;&#xA;            transform: translate(-50%, -50%)&#xA;        }&#xA;    position&#xA;        .content {&#xA;            position: absolute;&#xA;            top: 0;&#xA;            bottom: 0;&#xA;            left: 0;&#xA;            right: 0;&#xA;            margin: auto;&#xA;        }&#xA;    float填充一半&#xA;        .floater {&#xA;            float: left;&#xA;            height: 50%;&#xA;            margin-bottom: -120px;&#xA;        }&#xA;        .content {&#xA;            clear: both;&#xA;            height: 240px;&#xA;            position: relative;&#xA;        }&#xA;图标切分&#xA;    background-image: url(/base/icons.png);&#xA;    background-repeat: no-repeat;&#xA;    background-position: -910px -74px;&#xA;内部元素自动高度&#xA;    .parent {&#xA;        overflow: hidden;&#xA;    }&#xA;    .parent .children {&#xA;        overflow: hidden;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;stylus&#xA;    # css扩展语言, 创建富有表现力的css, 比less更强大, 类似jquery的css引擎, 支持node.js&#xA;compass&#xA;    # 编译到css，是sass的toolkit, 是用ruby开发的&#xA;blueprint&#xA;    # css框架&#xA;sass&#xA;    # css扩展语言&#xA;caniuse.com&#xA;    # 在线浏览器兼容性测试&#xA;modernizr.com&#xA;    # 测试特性支持是否到位&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;less&#34;&gt;&#xA;  less&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#less&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    less于css如jquery于js&#xA;安装使用&#xA;    npm install -g less&#xA;命令&#xA;    lessc styles.less &amp;gt; styles.css                # 编译&#xA;                                # -x 压缩  --clean-css 更复杂的压缩&#xA;语法&#xA;模板&#xA;    {% %}&#xA;变量&#xA;    @color: #4D926F;&#xA;    #header{&#xA;        color: @color&#xA;    }&#xA;    h2{&#xA;        color: @color&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Elixir</title>
      <link>https://ukeate.com/docs/pl/elixir/</link>
      <pubDate>Tue, 09 Oct 2018 16:24:04 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/elixir/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;跑在erlang虚拟机上&#xA;与erlang相同，actor称作进程, 是比线程更轻量的概念&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 元组&#xA;{:foo, &amp;quot;this&amp;quot;, 42}&#xA;        # 三元组&#xA;&#xA;o-&amp;gt; actor&#xA;defmodule Talker do&#xA;def loop do&#xA;    receive do&#xA;    {:greet, name, age} -&amp;gt; IO.puts(&amp;quot;Hello #{name}&amp;quot;)&#xA;    {:shutdown} -&amp;gt; exit(:normal)&#xA;    end&#xA;    loop&#xA;end&#xA;end&#xA;&#xA;pid = spawn(&amp;amp;Talker.loop/0)&#xA;send(pid, {:greet, &amp;quot;Huey&amp;quot;, 16})&#xA;sleep(1000)&#xA;&#xA;Process.flag(:trap_exit, true)&#xA;pid = spawn_link(&amp;amp;Takler.loop/0)&#xA;send(pid, {:shutdown})&#xA;receive do&#xA;{:EXIT, ^pid, reason} -&amp;gt; IO.puts(&amp;quot;Talker has exited (#{reason})&amp;quot;)&#xA;end&#xA;&#xA;o-&amp;gt; 有状态的actor&#xA;        # 递归&#xA;defmodule Counter do&#xA;def start(count) do&#xA;    spawn(__MODULE__, :loop, [count])&#xA;            # 伪变量__MODULE__, 是当前模块的名字&#xA;end&#xA;def next(counter) do&#xA;    send(counter, {:next})&#xA;end&#xA;def loop(count) do&#xA;    receive do&#xA;    {:next} -&amp;gt;&#xA;        IO.puts(&amp;quot;Current count: #{count}&amp;quot;)&#xA;        loop(count + 1)&#xA;    end&#xA;end&#xA;end&#xA;counter = spawn(Counter, :loop, [1])&#xA;send(counter, {:next})&#xA;&#xA;counter = Countre.start(42)&#xA;Counter.next(counter)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Go</title>
      <link>https://ukeate.com/docs/pl/go/</link>
      <pubDate>Tue, 09 Oct 2018 16:10:44 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/go/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    易工程化&#xA;        简单性而不方便性，避免工程复杂性乘法增长            # 某部分变复杂，增加其他部分的复杂性(功能、选项、配置)&#xA;            没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储&#xA;        类型系统，无类型风格&#xA;        自然方式工作&#xA;            不显式初始化和隐式构造函数&#xA;            集合直接持有元素&#xA;        标准库避免配置和解释     # 自带电池&#xA;        项目结构简单&#xA;        编译检查代码格式&#xA;    csp(communicating sequential process)并发，变长栈运行轻量线程&#xA;    编译为本地机器码        # 像c一样，所以又叫类c语言&#xA;        编译快&#xA;            引用包名在头&#xA;            包依赖有向无环，可独立和并行编译&#xA;            目标文件包含依赖包信息&#xA;    强静态类型&#xA;    有gc&#xA;    变长栈，最小2kb, 最大1GB&#xA;    大厂支持&#xA;历史&#xA;    2007年设计，受影响于Alef(CSP系列), Oberon-2(ALGOL60, Modula-2系列), C&#xA;        # 目的解决google许多复杂性激增的软件系统&#xA;    2009年发布, 作者是Robert Griesemer, Rob Pike, Ken Thompson&#xA;    2012年1.0&#xA;并发编程特点&#xA;    语言层面关键字&#xA;    例程&#xA;        流程控制: csp       # channel为一等公民&#xA;        通信方式: promise-future, channel, event&#xA;    高效调度模型(调度器，资源占用小)&#xA;        O(1)的调度&#xA;        一进程可支撑上百万例程,5kib/goroutine的开销,&#xA;            变长栈存goroutine&#xA;编译&#xA;    CGO_ENABLED=0&#xA;        # 静态链接，不跨平台&#xA;    初始化&#xA;        包级别初始化在main前&#xA;        局部变量在函数执行时&#xA;配置&#xA;    GOROOT                  # go安装目录&#xA;    GOPATH                  # 包目录, 默认要有go的bin目录&#xA;    GOBIN                   # 当前bin目录&#xA;    GO15VENDOREXPERIMENT    # 依赖目录&#xA;    GOOS                    # 指定操作系统, 如android, linux, darwin, windows&#xA;    GOARCH                  # 处理器架构，如amd64, 386, arm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;go&#xA;    help&#xA;        importpath          # 说明 指定代码托管网站版本协议&#xA;        gopath              # vendor怎么使用&#xA;        list                # go list 说明&#xA;    version&#xA;    env                     # 打印go环境信息&#xA;    run                     # 编译并运行&#xA;        -race               # 检查运行中的竞态冲突并报告&#xA;    build                   # 库被舍弃，main包编译成二进制执行文件, 会检测mod&#xA;        go build gopl.io&#xA;        go build x.go&#xA;        -race&#xA;        -i                  # 编译到指定位置&#xA;    install                 # 编译安装, 会检测mod&#xA;    clean                   # 清理build产生的文件&#xA;        -c                  # 清理.test文件&#xA;        -i                  # 清理生成的可执行文件&#xA;        -r                  # 包括依赖包的结果文件&#xA;    doc&#xA;        命令&#xA;            go doc go/build&#xA;        包&#xA;            go doc html/template&#xA;        包成员&#xA;            go doc time.Since&#xA;        方法&#xA;            go doc http.ListenAndServe&#xA;    fmt                     # 代码格式化&#xA;&#xA;    get                     # 下载依赖, 默认目录是GOPATH下的pkg。下载后自动install&#xA;        go get gopl.io/...  # ...通配&#xA;        get gopl.io@2       # 指定mod版本号&#xA;        -u                  # 更新到mod最新版本&#xA;        -v                  # 查看进度&#xA;    list                    # 列出指定代码包的信息&#xA;        go list ...         # ...通配&#xA;        go list ...xml...&#xA;        -json hash          # 输出json格式完整信息&#xA;        -f                  # 使用go模板&#xA;    fix                     # 升级旧代码成新版本代码&#xA;    vet                     # 检查静态错误&#xA;&#xA;    test&#xA;        # go test -cover -args -config config_it.toml -test.run &amp;quot;TestA&amp;quot;&#xA;        # 执行当前目录下所有_test.go结尾的文件&#xA;        -race&#xA;&#xA;        -file               # 可省略，测试单个文件, 如go test test_a.go a.go a.pb.go&#xA;                            ## 测试单个文件需要引入原文件&#xA;        -args               # 运行时参数&#xA;        -run TestFoo        # 正则表达式匹配方法，NONE表示不匹配。如&amp;quot;^TestFoo&amp;quot;, &amp;quot;F|F1&amp;quot;&#xA;        -test.run &amp;quot;TestCreate&amp;quot;                      # 同上&#xA;        -v                  # 每个测试用例的名称和时间&#xA;        -bench=&amp;quot;.*&amp;quot;         # 正则匹配benchmark测试函数&#xA;        -benchmem           # 显示benchmark测试时内存分配&#xA;        --cpuprofile=cpu.prof                       # 生成cpu分析文件，使用多个标记时(如cpu, mem), 一个类别会覆盖另一个。性能剖析启用时, go test不丢弃其临时可执行文件&#xA;        --blockprofile=block.out                    # 生成阻塞分析文件&#xA;        --memprofile=mem.prof                       # 生成内存分析文件&#xA;        -c                  # 生成可执行的二进制文件，名为x.test，它用来生成状态图&#xA;        -cover              # 显示覆盖语句汇总信息&#xA;        -coverprofile=c.out # 生成日志文件c.out，记录语句覆盖信息&#xA;        -covermode=count    # 语句覆盖信息不用bool而用count累加&#xA;&#xA;    tool&#xA;        cover               # 测试覆盖率工具使用方法&#xA;            go tool cover -html=c.out               # html分析c.out&#xA;        pprof               # 交互式访问概要文件&#xA;            go tool pprof module1.test cpu.prof                   # 性能测试状态图, 参数是可执行文件和剖析日志&#xA;            -test           # 文本格式&#xA;            -nodecount=10   # 限制输出10行&#xA;            -web            # 渲染有向图web显示&#xA;        fix                 # 同go fix&#xA;        vet                 # 同go vet&#xA;        cgo                 # 生成能够调用c语言代码的go源码文件&#xA;        compile&#xA;            -help           # 可传给编译器的参数&#xA;    mod&#xA;        init packageName1   # 生成go.mod&#xA;        download            # 下载mod&#xA;        tidy                # 下载缺少，删除多余&#xA;        edit                # 编辑go.mod&#xA;        graph               # 打印依赖图&#xA;        vendor              # 复制依赖到vendor&#xA;        verify              # 验证mod&#xA;        why                 # 打印依赖原因&#xA;godoc                       # 提供html页面&#xA;    -http=:6060             # 运行本地帮助网站&#xA;    -analysis=type          # 提供静态分析结果&#xA;        -analysis=pointer&#xA;gofmt&#xA;golint                          # 检查风格&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;常用&#34;&gt;&#xA;  常用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;go mod 配置&#xA;    环境变量&#xA;        GO111MODULE&#xA;            off                     # 总关闭&#xA;            on                      # 总开启&#xA;            auto                    # 默认，有go.mod开启&#xA;    路径&#xA;        $GOPATH/pkg/mod             # 保存多版本依赖, 被多项目引用&#xA;        go.mod                      # 被go命令维护, 融入了go命令的各个模块&#xA;        go.sum                      # 记录lock&#xA;    依赖加载顺序&#xA;        最新release tag&#xA;        最新commit&#xA;    命令&#xA;        go mod vendor&#xA;代理&#xA;    go env -w GOPROXY=https://goproxy.cn,direct&#xA;包升级&#xA;    go list -m -u all               # 检查可以升级的package&#xA;    go get -u need-upgrade-package  # 升级&#xA;性能测试&#xA;    go test -bench=.  --cpuprofile=cpu.prof --memprofile=mem.prof -config ../conf/config_lc.toml -test.run TestCreateType&#xA;覆盖率&#xA;    go test -cover -args -config config.toml -test.run &amp;quot;TestCreate&amp;quot;&#xA;性能分析&#xA;    go tool pprof service.test cpu.prof&#xA;    go-torch -b cpu.prof&#xA;包管理&#xA;    go list -m -u all&#xA;        # 列可升级包&#xA;    go list -u need-upgrade-package&#xA;        # 升级可升级包&#xA;    go get -u&#xA;        # 升级所有依赖&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;glide&#34;&gt;&#xA;  glide&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#glide&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    包管理&#xA;目录&#xA;    glide.yaml&#xA;    glide.lock&#xA;    main.go&#xA;    subpackages&#xA;    vendor&#xA;命令&#xA;    glide&#xA;        init&#xA;            # 扫描代码目录，创建glide.yaml文件，记录所有依赖&#xA;            删除glide.yaml中自己项目本身&#xA;        get&#xA;            # 安装并更新glide.yaml&#xA;            --all-dependencies -s -v github.com/go-redis/redis#5.0.0&#xA;                # --all-dependencies会更新subpackages&#xA;        update&#xA;            # 下载和更新glide.yaml中的所有依赖，放到vendor下&#xA;            # 递归更新&#xA;        install&#xA;            # 依据glide.lock与glide.yaml文件安装特定版本&#xA;            # glide.lock与glide.yaml不同步时，发出警告&#xA;        up&#xA;            # 更新依赖树，重建glide.lock文件&#xA;        name&#xA;            # 查看glide.yaml中依赖名称&#xA;        list&#xA;            # 依赖列表&#xA;        help&#xA;        --version&#xA;glide.yaml&#xA;    package: .&#xA;    import:&#xA;    - package: github.com/go-redis/redis&#xA;    version: 5.0.0&#xA;    repo:git@github.com:go-redis/redis&#xA;常见问题&#xA;    o-&amp;gt; cannot detect vcs&#xA;        glide.lock或vendor依赖旧版本&#xA;            清理glide.lock和vendor, 检查glide.yaml旧版本&#xA;        glide.yaml子目录处理不完善&#xA;            subpackages:&#xA;            - cloudsql&#xA;        glide mirror找不到包&#xA;            glide mirror set a a --vcs git&#xA;                # 改~/.glide/mirrors.yaml文件&#xA;    o-&amp;gt; does not appear to be a git repository&#xA;        加速服务没有项目&#xA;    o-&amp;gt; glide up依赖不是最新&#xA;        ~/.glide/cache中缓存了旧版本&#xA;    o-&amp;gt; cannot find package &amp;quot;.&amp;quot; in&#xA;        glide对非git协议自有域名处理歧义，子目录分析不准确&#xA;            清理缓存&#xA;                ~/.glide/cache/src/包名&#xA;                ~/.glide/cache/info/包名&#xA;            glide.yaml添加repo重定向及subpackages&#xA;                package: github.com/grpc-ecosystem/grpc-gateway&#xA;                repo: git@github.com:grpc-ecosystem/grpc-gateway.git&#xA;                subpackages:&#xA;                - internal&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;govendor&#34;&gt;&#xA;  govendor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#govendor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    包管理&#xA;使用&#xA;    go get -u -v github.com/kardianos/govendor&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;godev&#34;&gt;&#xA;  godev&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#godev&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gv&#34;&gt;&#xA;  gv&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gv&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gvt&#34;&gt;&#xA;  gvt&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gvt&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gvm&#34;&gt;&#xA;  gvm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 版本管理&#xA;命令&#xA;    gvm&#xA;        install go1.5&#xA;        use go1.5&#xA;        list&#xA;        listall&#xA;        implode&#xA;            # 删除所有go版本和gvm本身&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gore&#34;&gt;&#xA;  gore&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gore&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# repl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;go-torch&#34;&gt;&#xA;  go-torch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-torch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 性能火焰图&#xA;go-torch -b cpu.prof&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gf&#34;&gt;&#xA;  gf&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;-v/version&#xA;-h/help&#xA;init&#xA;build&#xA;gen         # 生成模块&#xA;    gen dao&#xA;run&#xA;swagger&#xA;pack&#xA;get&#xA;docker&#xA;mod&#xA;update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;包                              # 路径引用，命名空间&#xA;    不能循环依赖&#xA;    main包                      # 入口包, 产生可执行文件，也可当库导入&#xA;        main()                  # 入口函数&#xA;    包名最好匹配目录名          # 导入路径的最后一段&#xA;    import&#xA;        逐行import或import(多行)&#xA;        import 别名 包路径&#xA;        import &amp;quot;gopkg.in/yaml.v2&amp;quot; 忽略.v2, 包名为yaml&#xA;        import _ &amp;quot;image/png&amp;quot; 空导入&#xA;        可导入相对目录，以.或..开头&#xA;    var和const&#xA;        逐行或var(多行), const(多行)&#xA;    包文件函数&#xA;        init                    # 文件在编译前排序，按依赖顺序和文件名，也是init的调用顺序。init不能调用和引用&#xA;    包依赖排序依次初始化&#xA;    工作空间&#xA;        src&#xA;        bin                     # 编译后的执行文件&#xA;        pkg                     # 编译后的包, 重复使用加快编译&#xA;    vendor目录放本地依赖&#xA;    文档注释影响编译&#xA;        // +build linux darwin                  # linux和darwin才编译&#xA;        // +build ignore                        # 任何时候都不编译&#xA;    内部包                      # 路径有internal的包, 只能被父目录导入&#xA;        net/http/internal/chunked&#xA;注释&#xA;    //或/**/&#xA;    package前写文档注释，可出现在任何文件中，但一个包约定一个&#xA;    doc.go约定为包的扩展文档注释&#xA;命名&#xA;    字母或下划线开头，区分大小写, 不能用关键字&#xA;    关键字: break, default, func, interface, select, case, defer, go, map, struct, chan, else&#xA;        goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return, var&#xA;    首字母大小写决定可见性，大写表示其是导出的&#xA;    go倾向短名称, 驼峰式命名, 缩写全大写或小写&#xA;操作符&#xA;    优先级:&#xA;        * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^    # 可加=, 如*=&#xA;        + - | ^             # 可加=, 如*=&#xA;        == != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;=     # 基本类型都可比较&#xA;        &amp;amp;&amp;amp;&#xA;        ||&#xA;        + -                 # 一元取正负&#xA;    %                       # 只能整数，符号与被除数一致&#xA;    /                       # 整数除，去小数部分。溢出高位丢弃&#xA;    &amp;amp; | ^ &amp;amp;^                # 按位独立&#xA;        &amp;amp;^                  # and not(位清空)右边1清左边为0&#xA;        &amp;amp;                   # and&#xA;        |                   # or&#xA;        ^                   # xor, 前缀表示取反或按位取补(逐位取反)&#xA;    &amp;lt;&amp;lt; &amp;gt;&amp;gt;                   # 注意，有符号数右移按符号位填补空位&#xA;声明定义&#xA;    不能有无用的声明变量&#xA;    var s string            # 未初始化值默认零值，类型和表达式可省一个&#xA;    var s string = &amp;quot;&amp;quot;       # 不推荐&#xA;    var s = &amp;quot;&amp;quot;              # 不推荐&#xA;    s := &amp;quot;&amp;quot;                 # 短变量声明&#xA;&#xA;    var i,j int             # 自动引申变量类型&#xA;    i, j := 0, 1&#xA;    i, j := true, &amp;quot;a&amp;quot;       # 类型可不一致&#xA;    i, err := 0, e          # err声明过(只检测本词法块，外层不算)，声明i, 赋值err。:=要求至少一个声明&#xA;&#xA;    const                   # 编译时计算&#xA;        枚举&#xA;            type Weekday int&#xA;            const (&#xA;                Sunday Weekday = iota               # 值为0&#xA;                Monday&#xA;                ...&#xA;            )&#xA;            const (&#xA;                i T1 = 1 &amp;lt;&amp;lt; iota                    # 值为1, 下值为 1&amp;lt;&amp;lt;1&#xA;                ...&#xA;            )&#xA;        无类型常量&#xA;            只有常量可以无类型&#xA;            无类型常量存大数精度高于基本类型, 算术精度高于机器精度, 至少256位&#xA;            可用于更多表达式，无需转换类型&#xA;            分类&#xA;                布尔: true&#xA;                整数: 0&#xA;                文字符号: &#39;\u0000&#39;&#xA;                浮点数: 0.0&#xA;                复数: 0i&#xA;                字符串: &amp;quot;&amp;quot;&#xA;            const (&#xA;                _ = 1 &amp;lt;&amp;lt; (10 * iota)             # 下值为 1&amp;lt;&amp;lt;(10*1)&#xA;                ...&#xA;            )&#xA;&#xA;&#xA;    type                    # 类型声明&#xA;        type A int          # 底层共类型, 可赋值性，可比较性。可重写String方法让fmt打印时个性化&#xA;        a = A(i)            # 可赋值就可类型转换&#xA;    func&#xA;    变量生命周期&#xA;        包级别是整个程序执行时间&#xA;        局部变量声明时创建，直到不可访问&#xA;    堆栈&#xA;        逃逸变量(函数外保存地址)在堆，局部变量在栈                   # 与变量创建方式无关(new与否), 逃逸需要一次额外内存分配。&#xA;赋值&#xA;    x = 1&#xA;    *p = 1&#xA;    p.name = &amp;quot;&amp;quot;&#xA;    m[key] = 1&#xA;&#xA;    +=&#xA;    i++和i--                # 只能自成一行, 且不能++i, --i&#xA;    _                       # 忽略变量&#xA;    a, b = b, a             # 多重赋值&#xA;&#xA;    v, err = f()&#xA;    v, ok = m[key]          # map查询&#xA;    v, ok = x.(T)           # 类型断言&#xA;    v, ok = &amp;lt;-ch            # 通道接收&#xA;    可赋值性：类型精准匹配，nil赋值任何接口变量或引用变量, 常量更易隐式转换赋值&#xA;        ==和!= 比较，两边要求是可赋值的&#xA;指针                         # 不能运算&#xA;    &amp;amp;获取地址&#xA;    *获取指针&#xA;语句&#xA;    变长参数&#xA;        f(s...)&#xA;    for&#xA;        for i, j := 0, 1; i &amp;lt; n; i++ {}&#xA;        for i &amp;lt; n {}&#xA;        for {}&#xA;        for index, value := range slice1{}&#xA;        for key, value := range map1 {}&#xA;        for range s{}&#xA;    if&#xA;        if i &amp;lt; n {} else if i &amp;lt; m {} else {}&#xA;        if err := f(); err != nil {}&#xA;    switch&#xA;        switch {                # 无标签(tagless), 相当于switch true,&#xA;        case x &amp;gt; 0:             # fallthrough可贯穿, 可用控制流标签&#xA;        }&#xA;        switch i := 0 {}        # switch true&#xA;        switch i++ { }          # switch true&#xA;        switch f() {}           # switch true&#xA;&#xA;        switch i {&#xA;        case 0:&#xA;        case 1:&#xA;        default:                # default可在任何地方&#xA;        }&#xA;&#xA;        switch t.(type) {                   # 类型匹配, 无匹配类型会panic, 不能用fallthrough&#xA;        case nil:&#xA;        case int, uint;&#xA;        case bool:&#xA;        case string:&#xA;        default:&#xA;        }&#xA;        switch x := x.(type) {}&#xA;    select                                  # channel用select, 值用switch。一直等待直到匹配(default会直接匹配)。多情况匹配随机选择。不能用fallthrough&#xA;        select {&#xA;        case &amp;lt;-ch1:&#xA;        case x := &amp;lt;-ch2:&#xA;        case ch3 &amp;lt;- y:&#xA;        default:&#xA;        }&#xA;&#xA;        o-&amp;gt; 超时&#xA;        select {&#xA;        case &amp;lt;-time.After(10*time.Second):&#xA;        case &amp;lt;-ch:&#xA;        }&#xA;&#xA;        o-&amp;gt; 自发自接&#xA;        for i := 0; i &amp;lt; 10; i++{&#xA;            select {&#xA;            case x := &amp;lt;-ch:&#xA;            case ch &amp;lt;- i:&#xA;            }&#xA;        }&#xA;&#xA;        o-&amp;gt; 标签&#xA;        c := make(chan struct{},2)&#xA;        label1:&#xA;        for {&#xA;            select {&#xA;            case c&amp;lt;- struct{}{}:&#xA;                fmt.Println(1)&#xA;            case &amp;lt;-c:&#xA;                fmt.Println(2)&#xA;                break                       # 无标签break跳出当前select块&#xA;                    # break label&#xA;                    # goto label2&#xA;                    # return&#xA;            default:&#xA;                fmt.Println(3)&#xA;            }&#xA;        }&#xA;        label2:&#xA;        ...&#xA;    控制流标签&#xA;        break, continue, goto   # 可标签化, 如break Label1&#xA;作用域&#xA;    词法块：语法块(block)(大括号), 隐式块(未在大括号中的声明, 如if中)&#xA;        全局块                   # 内置&#xA;        包级别                   # 函数外的声明&#xA;        文件级别                  # 导入的包&#xA;        局部&#xA;    控制流标签作用域是外层函数&#xA;    覆盖&#xA;        x := 1&#xA;        for {&#xA;            x := x+1&#xA;            if .. {&#xA;                x := x+1        # 这里值的x是最外层x&#xA;            }&#xA;        }&#xA;    if声明的变量(隐式词法块)，else中可见&#xA;        if v, err := f(); err != nil {      # else中处理非err逻辑&#xA;            return err&#xA;        } else {&#xA;            v.close()&#xA;        }&#xA;    包中声明作用域无顺序，可递归    # 常量、变量不可以引用自己&#xA; 函数&#xA;    字面量&#xA;        var func()                   # 声明&#xA;        func f(i int) int {}&#xA;        func f(i, j int) (int, error){}&#xA;        func f() (r int){}&#xA;        func f(vals ...int) {}       # 变长函数, 只放最后, vals是slice&#xA;            f(vals...)&#xA;    一等公民&#xA;    函数签名，即函数类型，包括形参列表和返回列表, 命名不影响&#xA;    未定义时为nil, 不可比较&#xA;    值传递, 不能指定默认值&#xA;    函数返回多值, 可return, 可做传入参数&#xA;    返回值有命名，可祼返回(不在return后写参数)&#xA;    错误&#xA;        v, ok := f()                  # 错误只一种情况&#xA;        v, err := f()                 # 错误信息会串联，避免首字母大写和换行&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;    匿名函数用字面量定义，包含外层词法环境(闭包)&#xA;        递归要先声明，再赋值定义&#xA;        重定义变量&#xA;        for _, dir := range dirs() {&#xA;            dir := dir                      # for块作用域变量共享位置，重定义dir每次一个位置&#xA;            dirs = append(dirs, func(){     # 匿名函数引用外层变量，却不一定同步执行&#xA;                os.RemoveAll(dir)&#xA;            })&#xA;        }&#xA;方法&#xA;    字面量&#xA;        func (t T) f(){}                    # t值传递, 方法名唯一, 方法名不能用字段名&#xA;        func (t *T) f(){}                   # t引用传递&#xA;&#xA;        type Path []Point                   # 别名赋方法(不能是指针和接口), 可覆盖原类型方法&#xA;        func (p *Path)f(){}&#xA;    方法可在任何类型(除指针和接口), 如函数&#xA;    变量与变量指针都可直接调方法，编译器隐式取地址或取指针&#xA;        P{1}.f()                            # 编译器不报错但运行出错, f()声明成引用传递, 但P{1}.时, 内存地址还未分配, 即还没有*P, 就无法调f()&#xA;    有引用传递方法时，避免值传递方法，会产生多例&#xA;    值为nil时可调方法&#xA;    方法可赋值&#xA;        f := t.f&#xA;        f(t.f)&#xA;    组合&#xA;        结构体匿名成员方法可如属性般直接调用&#xA;        匿名成员是引用时，多结构体可组合同一成员对象&#xA;        多匿名成员方法冲突时，调用时编译报错&#xA;        可给未命名结构体加方法&#xA;            t = struct{&#xA;                sync.Mutex&#xA;                v int&#xA;            }&#xA;            t.Lock(); t.v++; t.Unlock()&#xA;接口&#xA;    字面量&#xA;        type I interface {&#xA;            f()&#xA;        }&#xA;        type I2 interface {                  # 接口组合&#xA;            I&#xA;        }&#xA;&#xA;        v := t.(T)                           # 断言，失败panic&#xA;        v, ok := t.(T)                       # 失败不panic, ok=false&#xA;    隐式实现，方法匹配即可(接口即约定)           # 鸭子&#xA;    指针方法匹配接口，对接口赋值时要传指针&#xA;    interface{}为空接口类型，可赋值任何类型&#xA;    实现&#xA;        除了接口的定义类型，还包含动态类型(Type) + 动态值(Value)               # 编译时不知道，生成代码在运行时动态分发&#xA;            零值，是动态类型和动态值都是nil&#xA;                动态类型是nil, 指的是它为接口本身类型&#xA;                i = nil会设置接口为零值&#xA;            ==和!=比较&#xA;                动态值都为nil相等&#xA;                动态类型和动态值都相等，才相等&#xA;                    i = new(T); i != nil&#xA;                动态类型一致，动态值不可比较(如slice), 则panic                # 非平凡&#xA;                格式化输出%T拿到动态类型&#xA;    断言&#xA;        变定义类型, 动态类型和动态值不变&#xA;        空接口断言总失败&#xA;        断言成接口，使用公共功能&#xA;            v := t.(I)&#xA;            v.Common()&#xA;    风格&#xA;        强调功能相似性                         # 子类型多态(subtype polymorphism)&#xA;        联合再断言区分                         # 可识别联合(discriminated union), 特设多态(ad hoc polymorhpism)&#xA;            switch t.(type) {}&#xA;关键字&#xA;    defer fn                                 # 后进先出, return或panic后调用&#xA;        defer func(i){...}(1)&#xA;        return、出参赋值、defer顺序            # 先赋值，再defer，再return&#xA;            func f() (i int) {&#xA;                defer func(){&#xA;                    i++&#xA;                }&#xA;                return 0          # 相当于 i=0; i++; return&#xA;            }&#xA;    go fn&#xA;    异常&#xA;        panic()&#xA;            日志包括值(interface{}), 调用栈&#xA;                用interface{}自定义异常类型&#xA;                runtime.Stack()查看栈，利用defer函数在栈清理前调用, 所以栈存在&#xA;            终止当前goroutine, 外层goroutine不捕获&#xA;            按函数调用栈依次中止函数并调defer, 最上层后程序异常退出&#xA;            panic之后定义的defer不执行(声明不提前)&#xA;        recover()&#xA;            中止panic&#xA;            在defer中(panic时只调defer)捕获panic对象，没有时为nil&#xA;            捕获panic对象后, 捕获函数正常返回。要上抛就再手动panic()&#xA;        o-&amp;gt;&#xA;        func Try(fn func(), handler func(interface{})) {&#xA;            defer func() {&#xA;                if err := recover(); err != nil {&#xA;                    handler(err)&#xA;                }&#xA;            }()&#xA;            fn()&#xA;        }&#xA;&#xA;        func main() {／&#xA;            Try(func() {&#xA;                panic(&amp;quot;a&amp;quot;)&#xA;            }, func(e interface{}) {&#xA;                print(e)&#xA;            })&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内置&#34;&gt;&#xA;  内置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;零值                              # 保障变量良好定义，没有未初始化变量&#xA;    数字0, 布尔false, 字符串&amp;quot;&amp;quot;&#xA;    接口和引用类型(slice, 指针, map, channel, 函数)nil&#xA;    复合类型其所有元素或成员零值&#xA;常量&#xA;    true&#xA;    false&#xA;    iota&#xA;    nil&#xA;        比较&#xA;            var s []int         # 未初始化比较, ==nil&#xA;            s = []int(nil)      # 强转, ==nil&#xA;            s = []int{}         # 初始化比较, !=nil&#xA;基本类型&#xA;    字面量&#xA;        06                      # 8进制&#xA;        0x0a                    # 16进制&#xA;        .1或1.                   # 小数点前后可省略&#xA;        2.2e10                  # 科学计数法&#xA;        1 + 2i                  # 复数&#xA;        字符串&#xA;            &amp;quot;\\&amp;quot;                # 转义&#xA;            &amp;quot;\r&amp;quot;                # 光标退到行首&#xA;            &amp;quot;\b&amp;quot;                # 光标退一字符&#xA;            &amp;quot;\x1a&amp;quot;              # 16进制表示位数据, 必2位，无法识别成unicode&#xA;            &amp;quot;\212&amp;quot;              # 8进制表示位数据, 必3位, 无法识别成unicode&#xA;            &amp;quot;\u1234&amp;quot;            # unicode, 16进制数字, 共4x4=16位&#xA;            &amp;quot;\u12345678&amp;quot;        # unicode, 16进制数字, 共4x8=32位&#xA;            ``                  # 原生字符串, 回车被删除(换行符保留)&#xA;    注意&#xA;        会自动截断，如int i=127; i+1=-128; i*i=1&#xA;    int                         # 平台原生整数大小，或该平台运算效率最高值, 多是int32&#xA;    int8                        # -128-127&#xA;    int16&#xA;    int32&#xA;    int64&#xA;    uint                        # 平台决定大小。无符号极少用于表示非负值，往往用于位运算或特定算术运算符，如位集，解析二进制，散列，加密&#xA;    uint8                       # 0-255&#xA;    uint16&#xA;    uint32&#xA;    uint64&#xA;    uintptr                     # 存放指针，大小不明确，底层编程&#xA;    float32                     # 运算会迅速累积误差, 正整数范围有限&#xA;    float64&#xA;    complex64                   # float32构成&#xA;    complex128                  # float64构成&#xA;        var x complex128 = complex(1,2)&#xA;        x := 1 + 2i&#xA;    bool&#xA;    byte                        # uint8别名, 强调是原始数据&#xA;    rune                        # int32别名, unicode码点(UTF-8), 下标取字符(非字节)&#xA;    string                      # 认为是UTF-8编码的unicode, 不合理字节替换成方块(\uFFFD)。不可变(安全截取、共用), 下标取字节，越界宕机异常&#xA;        和数组和slice一样操作&#xA;        []byte和string元素操作一致，只类型不同&#xA;        互换&#xA;            []byte, []rune, string                  # 转换产生副本&#xA;    error&#xA;聚合类型&#xA;    数组&#xA;        字面量&#xA;            var q [3]int&#xA;            q := [3]int{1,2,3}&#xA;            q := [...]int{1,2,3}                        # 长度由元素个数决定&#xA;            q := [...]int{0: 1, 3:2}                    # 指定索引元素值&#xA;        数组是值传递&#xA;        数组元素不可包含自己&#xA;        默认元素为零值&#xA;        不同长度不同类型，不能赋值&#xA;        如果元素可比较，数组就可比较     # 深度比较&#xA;            q1 &amp;lt; q2                   # 字符串比较按字节字典排序&#xA;    slice&#xA;        字面量&#xA;            q := []int{1,2,3}                           # 这里创建了slice, 指向了隐式创建的数组&#xA;            q[0:1]                                      # 左闭右开&#xA;            q[:1]; q[1:]; q[:]&#xA;        轻量级数据结构，用来访问数组的部分&#xA;        零值是nil, 行为和slice一样，不用特殊判断&#xA;        slice后标访问越界时，会自动扩展，越界超过数组长度+1时，会panic&#xA;            append(arr[:i], arr[i+1:]...)删除元素, i为最后元素时, i+1不越界&#xA;        不可比较, 只有写函数实现。只能和nil比较&#xA;            因为slice的元素不是直接的&#xA;                有可能包含它自身&#xA;                同slice不同时间会拥有不同元素&#xA;                    如果slice可比较来做map键, map只对key做浅拷贝, slice需要深度比较, 所以要求slice元素不变&#xA;        三元素                         # 有自己的属性，不是纯引用类型，是聚合类型&#xA;            指针: 指向slice在数组上起始位置&#xA;            长度: slice长度&#xA;            容量: 指针到数组结尾元素个数&#xA;    map                                # key可nil, 取不存在key时, 得到value类型的零值。随机无序遍历&#xA;        字面量&#xA;            m := map[string]int{&#xA;                &amp;quot;a&amp;quot;:1,&#xA;            }&#xA;            a[&amp;quot;b&amp;quot;]=2&#xA;        不能获得地址，如&amp;amp;m[&amp;quot;a&amp;quot;]          # 因为map增长时，已有元素可能重新散列&#xA;        迭代顺序随机                     # key用维护排序, 散列算法健壮&#xA;        零值是nil, 向nil map设置元素会panic&#xA;        map[key1]没有时，获得零值&#xA;            v, ok := m[&amp;quot;a&amp;quot;]             # 判断有无key&#xA;        不可比较，只能和nil比较&#xA;        key要求可比较，可以数组,不可以slice,可以自己映射成可比较类型&#xA;            q := [2]int{}&#xA;            m := map[[2]int]int{}&#xA;            m[q] = 1&#xA;    结构体&#xA;        字面量&#xA;            type T struct {                             # 结构体,&#xA;                Name string `json:&amp;quot;name0,omitempty&amp;quot;`    # 成员标签定义, opmitempty在零值时忽略&#xA;                I1, I2 int&#xA;            }&#xA;&#xA;            t := &amp;amp;T{&amp;quot;a&amp;quot;}                                # 顺序易出错, 用于明显的小结构。未指定成员为零值&#xA;            t := &amp;amp;T{&#xA;                Name: &amp;quot;a&amp;quot;,&#xA;            }&#xA;            (*t).Name = &amp;quot;a&amp;quot;&#xA;            t.Name = &amp;quot;a&amp;quot;                                # .可以用于指针&#xA;&#xA;            struct{}                                    # 空结构体，没有长度，无信息。&#xA;&#xA;            type T1 struct{                             # 匿名成员&#xA;                T&#xA;                T2&#xA;                *T3&#xA;                Name1 string&#xA;            }&#xA;            t1 := T1{&#xA;                T: {&#xA;                    Name: &amp;quot;a&amp;quot;&#xA;                }&#xA;            }&#xA;&#xA;        首字母大写可导出&#xA;        属性类型不可自己，但可自己指针&#xA;        结构体零值由成员零值组成            # 希望结构体方法中处理零值成一个自然的值，如sync.Mutex&#xA;        成员可比较，结构体实例可比较, 可作map key&#xA;        匿名成员(组合)&#xA;            点号访问可跨入(语法糖)，访问匿名成员属性和方法&#xA;                t1.Name; t1.T.Name&#xA;            不能有相同类型的匿名成员&#xA;            不可导出类型的匿名成员，内部成员不影响，但匿名成员本身不可见&#xA;引用类型&#xA;    Type&#xA;    IntegerType&#xA;    FloatType&#xA;    ComplexType&#xA;&#xA;    chan&#xA;        ch := make(chan string)&#xA;&#xA;        var cin chan&amp;lt;- string&#xA;        var cout &amp;lt;-chan string&#xA;&#xA;        ch &amp;lt;- &amp;quot;&amp;quot;&#xA;        &amp;lt;-ch&#xA;接口类型&#xA;    error&#xA;        Error()&#xA;命名类型&#xA;    type&#xA;    结构体&#xA;        type Point struct {&#xA;            X, Y int&#xA;        }&#xA;函数&#xA;    make()&#xA;        make([]int)&#xA;        make(map[string]int)&#xA;        make(chan int)&#xA;    delete()&#xA;        delete(m, &amp;quot;a&amp;quot;)          # 删除map元素, 没key不报错返回零值&#xA;    len()&#xA;        len(ch)                 # 当前缓冲个数&#xA;    cap()&#xA;        cap(ch)                 # 缓冲区容量&#xA;    new()                       # 创建指定类型变量，初始化为零值，返回地址。不带任何信息且是零值(struct{}和[0]int)的类型, new出的地址不同(从前相同)&#xA;        t := new(T)&#xA;    append()                    # 操作slice&#xA;        先检查原容量，容量够修改原数组元素，不够创建新数组(容量扩一倍)复制元素, 返回新slice&#xA;        所以append()最好赋值给原slice&#xA;        s1 := append(s1, s2...)&#xA;    copy()                      # slice或string元素复制&#xA;    close()                     # channel中用&#xA;    complex()                   # 创建复数对象&#xA;    real()                      # 获取复数的实部&#xA;    imag()                      # 获取复数的虚部&#xA;    panic()&#xA;    recover()&#xA;反射&#xA;    谨慎使用&#xA;        脆弱，能导致编译报错的写法，反射中都对应panic，执行时才知道&#xA;        降低自动重构和分析工具的安全性与准确度，反射对类型操作无法静态检查&#xA;        反射慢1-2个数量级(实测20位左右), 适合测试用，不适合关键路径上用&#xA;unsafe&#xA;    值在内存中对齐，计算更高效。结构体用内存间隙来对齐，占空间比元素之和更大&#xA;    结构体成员内存中重新排列可省内存，但目前不是&#xA;cgo&#xA;    o-&amp;gt; c文件&#xA;    #include &amp;lt;bzlib.h&amp;gt;&#xA;    int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen) {...}&#xA;&#xA;    o-&amp;gt; go文件&#xA;    /*&#xA;    #cgo CFLAGS: -I/usr/include&#xA;    #cgo LDFLAGS: -L/usr/lib -lbz2&#xA;    #include &amp;lt;bzlib.h&amp;gt;&#xA;    int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen);&#xA;    */&#xA;    import &amp;quot;C&amp;quot;&#xA;    import (&#xA;        &amp;quot;io&amp;quot;&#xA;        &amp;quot;unsafe&amp;quot;&#xA;    )&#xA;    type writer struct {&#xA;        w io.Writer&#xA;        stream *C.bz_stream&#xA;        outbuf [64*1024]byte&#xA;    }&#xA;    func NewWriter(out io.Writer) io.WriteCloser{&#xA;        const (&#xA;            blockSize = 9&#xA;            verbosity = 0&#xA;            workFactor = 30&#xA;        )&#xA;        w := &amp;amp;writer{w: out, stream: C.bz2alloc()}&#xA;        C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)&#xA;        return w&#xA;    }&#xA;    func (w *writer) Write(data []byte) (int, erro) {&#xA;        if w.stream == nil {&#xA;            panic(&amp;quot;closed&amp;quot;)&#xA;        }&#xA;        var total int&#xA;        for len(data) &amp;gt; 0 {&#xA;            inlen, outlen := C.uint(len(data)), C.uint(cap(w.outbuf))&#xA;            C.bz2compress(w.stream, C.BZ_RUN, (*C.char)(unsafe.Pointer(&amp;amp;data[0])), &amp;amp;inlen, (*C.char)(unsafe.Pointer(&amp;amp;w.outbuf)), &amp;amp;outlen)&#xA;            total += int(inlen)&#xA;            data = data[inlen:]&#xA;            if _, err := w.w.Write(w.outbuf[:outlen]); err != nil {&#xA;                return total, err&#xA;            }&#xA;        }&#xA;        return total, nil&#xA;    }&#xA;&#xA;    注释&#xA;        #cgo 指令指定C工具链选项&#xA;    import &amp;quot;c&amp;quot;&#xA;        编译时促使go build用cgo预处理其上注释&#xA;        产生临时包包含c函数对应声明&#xA;            包含类型，函数，预处理宏对象&#xA;            这里用了C.bz_stream和C.BZ2_bzCompressInit&#xA;    go也可编译成静态库链接进C, 或编译成动态库通过C加载和共享&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内部包&#34;&gt;&#xA;  内部包&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e9%83%a8%e5%8c%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# golang.org/pkg 找到索引&#xA;errors&#xA;    New()&#xA;testing&#xA;    T&#xA;        Error()&#xA;        Errorf()&#xA;        Fatal()&#xA;        Fatalf()&#xA;    B&#xA;syscall                 # 执行其它语言&#xA;syscall/js&#xA;js/wasm                 # 1.11, webAssembly&#xA;go/doc&#xA;go/token&#xA;runtime&#xA;    Stack()                             # 调用栈&#xA;    Gosched()                           # 让出执行权&#xA;    Goexit()                            # 终止当前goroutine, 会执行defer&#xA;    LockOSThread()                      # 绑定协程到当前线程&#xA;    UnlockOSThread()&#xA;    GOMAXPROCS()                        # 并发线程数&#xA;    NumGoroutine()                      # 限制goroutine数&#xA;runtime/debug&#xA;os&#xA;    Stdin                   # 输入流&#xA;    Args                    # 运行参数&#xA;    FileInfo&#xA;&#xA;    Open()                  # 打开文件&#xA;        File&#xA;            Read()&#xA;            Write()&#xA;            Close()&#xA;    Exit(1)                 # 1异常退出&#xA;    RemoveAll()&#xA;    Stat()                  # 文件信息&#xA;os/exec                     # 子进程&#xA;io&#xA;    EOF                     # 文件结束标志, 是一个error&#xA;&#xA;    Copy()&#xA;    WriteString()&#xA;io/ioutil&#xA;    Discard                 # 丢弃&#xA;&#xA;    ReadFile()              # 读整个文件到内存&#xA;    ReadAll()&#xA;    WriteFile()&#xA;    ReadDir()&#xA;bufio                       # 带缓冲io&#xA;    NewScanner()&#xA;        Scanner             # 以行或单词断开&#xA;            Scan()          # 有内容返回true&#xA;            Text()&#xA;    NewReader()&#xA;        ReadRune()&#xA;path                        # 文件路径&#xA;    Base()                  # 获得最后文件名&#xA;path/filepath               # 根据平台处理文件路径&#xA;net&#xA;    Conn&#xA;net/http&#xA;    poolServer(epoll/kqueue/iocp)&#xA;        # 支持多核大量并发连接fd&#xA;    Get()&#xA;        Header&#xA;            Get()&#xA;        Body&#xA;            Close()&#xA;    HandleFunc()&#xA;        ResponseWriter&#xA;        Request&#xA;            RemoteAddr      # 客户ip:端口&#xA;            Host&#xA;            Method&#xA;            Proto           # 网络协议&#xA;            Header&#xA;            Form            # 先ParseForm()&#xA;            URL&#xA;                Path&#xA;&#xA;            ParseForm()&#xA;    ListenAndServe()&#xA;net/http/httputil&#xA;net/url&#xA;    QueryEscape()           # url转义&#xA;context                     # 线程安全, 树形结构&#xA;    Cancel()&#xA;    Deadline(Timeout)&#xA;    Value()&#xA;    TODO()&#xA;&#xA;    o-&amp;gt; ctx.Done()&#xA;    func f(ctx context.Context) (error) {&#xA;        errc := make(chan error, 1)&#xA;&#xA;        go func() {&#xA;            defer close(errc)&#xA;            time.Sleep(2 * time.Second)&#xA;            errc &amp;lt;- nil&#xA;        }()&#xA;&#xA;        select {&#xA;        case &amp;lt;-ctx.Done():&#xA;            &amp;lt;-errc&#xA;            return ctx.Err()&#xA;        case err := &amp;lt;-errc:&#xA;            return err&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; WithTimeout&#xA;    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)     # 调cancel提前结束&#xA;    defer cancel()&#xA;    return f(ctx)&#xA;flag&#xA;    Args                    # 非标识参数&#xA;    Parse()                 # 出错调os.Exit(2)&#xA;&#xA;    o-&amp;gt; 输入&#39;-s / a bc&#39;, 输出&#39;a/bc&#39;&#xA;    sep := flag.Strings(&amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;desc s&amp;quot;)&#xA;    flag.Parse()&#xA;    println(strings.Join(flag.Args(), *sep))&#xA;log&#xA;    SetPrefix()&#xA;    SetFlags()              # 格式标记&#xA;    Fatal()                 # 加日期时间前缀&#xA;    Fatalf()&#xA;time&#xA;    Time&#xA;        Format()&#xA;&#xA;    Now()&#xA;    Since()&#xA;        Seconds()&#xA;    After()&#xA;    AfterFunc()&#xA;    NewTicker()&#xA;        ticker := time.NewTicker(1 * time.Second)&#xA;        &amp;lt;- ticker.C&#xA;        ticker.Stop()&#xA;    Tick()&#xA;        tick := time.Tick(1 * time.Second)          # 无法中止, 用于全局，否则内部goroutine泄漏&#xA;        for {&#xA;            &amp;lt;-tick&#xA;        }&#xA;&#xA;&#xA;fmt                         # string类型会调对象的String()方法&#xA;    Stringer                # 接口，有String()方法可匹配&#xA;&#xA;    Printf()                # 可以用转义序列(\t等)表示不可见字符&#xA;        %d                  # 十进制整数&#xA;        %x, %o, %b          # 十六进制、八进制、二进制整数&#xA;            %X&#xA;            % x             # 十六进制输出，两数一空格&#xA;        %f, %g, %e          # 浮点数6位小数、15位小数并自动精度与表示方式、6位小数e表示&#xA;            &amp;quot;%8.3f&amp;quot;         # 输出8字符宽度，保留3位小数&#xA;        %t                  # 布尔&#xA;        %c                  # unicode字符&#xA;        %s                  # 字符串&#xA;            %*s             # 缩进后面指定数字个空格&#xA;        %q                  # 带引号字符串(&amp;quot;abc&amp;quot;)，或字符(&#39;c&#39;)&#xA;        %v                  # 内置格式的任何值&#xA;            %#v             # 包含结构体成员名字&#xA;        %T                  # 类型&#xA;        %[1]c               # 重复利用第一个参数&#xA;            Printf(&amp;quot;%d %[1]c %[1]q&amp;quot;, &#39;a&#39;)&#xA;        %%                  # %本身&#xA;        特殊数字&#xA;            var z float64&#xA;            fmt.Println(z,-z,1/z,-1/z,z/z)              # &amp;quot;0 -0 +Inf -Inf NaN&amp;quot;&#xA;    Fprintf()&#xA;    Scanf()                 # 格式化输入&#xA;    Errorf()                # 产生一个error&#xA;strconv                     # 类型转换&#xA;    ParseFloat()&#xA;    ParseInt()&#xA;    ParseUint()&#xA;    Itoa()                  # 整数转字符串&#xA;    FormatInt(int64(1a), 2)&#xA;    FormatUint()&#xA;unicode                 # 单符号&#xA;    ToUpper()&#xA;    ToLower()&#xA;    IsDigit()&#xA;    IsLetter()&#xA;unicode/utf8            # 逐个处理&#xA;    RuneCountInString()                 # 字符数&#xA;    DecodeRuneInString()                # 解码, string类型默认调用&#xA;bytes                       # 操作byte数组&#xA;    Buffer&#xA;        WriteByte()&#xA;        WriteRune()&#xA;        WriteString()&#xA;        String()&#xA;&#xA;    Index()&#xA;    Contains()&#xA;    Count()&#xA;    Fields()&#xA;    HasPrefix()&#xA;    Join()&#xA;    Equal()&#xA;strings                     # 处理UTF-8或位序列&#xA;    Index()&#xA;    Split()&#xA;    HasPrefix()&#xA;    HasSuffix()&#xA;    Contains()&#xA;    Count()&#xA;    Fields()&#xA;    Join()&#xA;regexp&#xA;    MustCompile()           # 检查&#xA;    Compile()               # 编译表达式&#xA;text/template&#xA;    Must()                  # 检查，有错panic&#xA;&#xA;&#xA;    o-&amp;gt;&#xA;    {{.Name}}               # .代表当前值&#xA;    {{range .Items}}&#xA;        {{.Title | printf &amp;quot;%.64s&amp;quot;}}&#xA;        {{.CreateAt | daysAgo}}&#xA;    {{end}}&#xA;    template.New(&amp;quot;report&amp;quot;).&#xA;        Funcs(template.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}).&#xA;        Parse(templ)&#xA;text/tabwriter              # 生成表格&#xA;    Flush()&#xA;html/template               # 对html, js, css, url中原字符转义, 避免对输出页面注入控制&#xA;    Html                    # 字符串转成该类型，受信任，不用转义&#xA;&#xA;    Parse()                 # 解析html&#xA;encoding/json               # unicode&#xA;    Marshal()               # 转成json, 不可导出不可见&#xA;    MarshalIndent()         # 格式化转成json&#xA;    Unmarshal()&#xA;    NewDecoder()            # 流式解码&#xA;        Decode()&#xA;encoding/xml&#xA;encoding/gob&#xA;encoding/asn1&#xA;compress/gzip               # DEFLATE算法&#xA;    NewWriter()&#xA;    NewReader()&#xA;compress/bzip2              # Burrows-Wheeler变换, 压缩高，慢&#xA;&#xA;&#xA;sort&#xA;    IntSlice&#xA;        sort.Sort(sort.IntSlice(ints))&#xA;&#xA;    Sort()&#xA;    Reverse()&#xA;        sort.Sort(sort.Reverse(values))&#xA;    IsSorted()&#xA;    Strings()&#xA;    Ints()&#xA;    IntsAreSorted()&#xA;&#xA;    o-&amp;gt;&#xA;    type StringSlice []string&#xA;    func (p StringSlice) Len()int {return len(p)}&#xA;    func (p StringSlice) Less(i, j int)bool {return p[i] &amp;lt; p[j]}&#xA;    func (p StringSlice) Swap(i, j int) {p[i], p[j] = p[j], p[i]}&#xA;    sort.Sort(StringSlice(names))&#xA;math&#xA;    Sin()&#xA;    NaN()               # 返回NaN, NaN值比较总false(除!=), NaN用作信号量&#xA;math/rand&#xA;    Seed(time.Now().UTC().UnixNano())&#xA;    Float64()&#xA;math/cmplx              # 复数运算&#xA;    Sqrt(-1)            # 0 + 1i&#xA;math/bits&#xA;image&#xA;    Rect()&#xA;    NewPaletted()&#xA;        SetColorIndex()&#xA;    Decode()&#xA;    Encode()&#xA;image/color&#xA;    Color&#xA;    White&#xA;    Black&#xA;image/gif&#xA;    GIF&#xA;image/jpeg              # 空导入注册解码器&#xA;image/png               # 空导入注册解码器&#xA;&#xA;&#xA;sync&#xA;    Mutex&#xA;        Lock()&#xA;        Unlock()&#xA;    RWMutex&#xA;        Lock()&#xA;        Unlock()&#xA;        RLock()&#xA;        RUnlock()&#xA;    Once                                # 单例资源初始化，解决了多线程下读检查，防重写的问题&#xA;        Do()&#xA;    WaitGroup&#xA;    Cond&#xA;        Wait()                          # 计数加1, 进入阻塞&#xA;        Signal()                        # 解除一个阻塞，计数减1&#xA;        Broadcast()                     # 解除所有阻塞&#xA;    Map&#xA;    Pool&#xA;&#xA;&#xA;reflect                 # 非导出字段反射可见, 不可更新&#xA;    Type                # 类型&#xA;        String()        # 类型描述, fmt.Printf()中的&amp;quot;%T&amp;quot; 内部调用&#xA;        Field()         # 结构体成员, 返回StructField&#xA;            Name&#xA;        Method()&#xA;    Value               # 值&#xA;        String()        # 值描述，如&amp;quot;&amp;lt;int Value&amp;gt;&amp;quot;&#xA;        Type()&#xA;        Interface()     # 返回接口具体值&#xA;            x := v.Interface()&#xA;            i := x.(int)&#xA;        Kind()          # 得到类型，Bool, String, 各种数字, Array, Struct, Chan, Func, Ptr, Slice, Map, Interface, Invalid(零值), Func&#xA;        Index()         # 数组&#xA;        NumField()      # 结构体成员数&#xA;        FieldByName()&#xA;        MapKeys()       # map&#xA;        MapIndex()      # map&#xA;        IsValid()&#xA;        IsNil()         # 指针&#xA;        Elem()          # 指针指向元素&#xA;        CanAddr()       # 是否可寻址，如指针元素取Elem()的值，数组元素&#xA;        Addr()          # 取地址&#xA;            v.Addr().Interface().(*int)&#xA;        CanSet()        # 检查CanAddr()和是否非导出字段&#xA;        Set()           # 要求可寻址, 类型一致。可Set()interface{}类型&#xA;            SetInt(), SetUint(), SetString(), SetFloat()            # 相对Set()有容错性,不可SetXx()interface{}类型&#xA;            SetMapIndex()&#xA;        NumMethod()     # 方法数&#xA;        Method()        # 取方法&#xA;            Name&#xA;        Call()          # 执行Func类型Value&#xA;    StructField&#xA;        Tag&#xA;    StructTag&#xA;        Get()           # 字段标签中key的值&#xA;    Method&#xA;&#xA;    TypeOf()&#xA;    ValueOf()&#xA;    Zero()              # 零值&#xA;    Append()&#xA;    MakeMap()&#xA;    New()               # 类型新对象地址&#xA;    DeepEqual()         # 深度比较，基本类型用==, 组合类型逐层比较。&#xA;        判断武断，不认为值为nil的map和值不为nil的空map相等。slice同理&#xA;            var c, d map[string]int = nil, make(map[string]int)&#xA;            var a, b []string = nil, []string{}&#xA;&#xA;unsafe                  # 由编译器实现，暴露了内存布局。&#xA;    Pointer             # 任何地址，可比较，可比较nil。无类型向内存写任意值。&#xA;        可转成uintptr对地址计算&#xA;            问题&#xA;                移动垃圾回收器(目前未用)在移变量时地址改变使地址出错。&#xA;                goroutine增长栈时旧栈地址重新分配&#xA;            解决&#xA;                Pointer转uintptr再转回来在一条语句中实现&#xA;            应用&#xA;                深度比较时，防止循环引用，每次比较存两个抽象的指针(即Pointer)和类型(y和y[0]地址一样)&#xA;        var f float64&#xA;        i := *(*uint64)unsafe.Pointer(&amp;amp;f)&#xA;    Sizeof()            # 表达式占字节长度, 不计算表达式，由编译器推断&#xA;    Alignof             # 报告类型对齐方式&#xA;    Offsetof()          # 成员相对起始偏移量, 计算空位&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;外部包&#34;&gt;&#xA;  外部包&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%96%e9%83%a8%e5%8c%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# godoc.org 搜索&#xA;goimports           # 格式化imports顺序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;测试&#34;&gt;&#xA;  测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;规则&#xA;    文件名以_test.go结尾&#xA;    汇报PASS或FAIL, 平均执行时间&#xA;    忽略main函数, 当作库测试&#xA;        main特权函数 log.Fatal()和os.Exit()会阻止跟踪过程&#xA;    包测试循环依赖时，建立外部测试包&#xA;        导出内部成员用于测试的后门成员声明，放在export_test.go内&#xA;机制&#xA;    扫描*_test.go&#xA;    生成临时main包来调用，再编译、运行、汇报, 最后清空临时文件&#xA;Test函数                          # t用于汇报结果和日志&#xA;    func TestF(t *testing.T) {}&#xA;benchmark函数                     # 基准测试，性能&#xA;    b增加了成员N指定执行次数, 增加了性能检测方法&#xA;        开始指定小N, 再推断足够大的N检测稳定运行时间&#xA;    基准测试时初始化代码放循环外面，它的执行时间不加到每次迭代时间中。普通Test做不到&#xA;    用go test -bench=.运行&#xA;        报告中 f-8 1000000 1035 ns/op 分别代表GOMAXPROCS=8, 执行100000次，平均每次1035ns&#xA;&#xA;    o-&amp;gt; 基本使用&#xA;    func BenchmarkF(b *testing.B) {&#xA;        for i := 0; i &amp;lt; b.N; i++{&#xA;            f()&#xA;        }&#xA;    }&#xA;    o-&amp;gt; 相对比较, 如数量级、找最佳缓冲区大小、选算法策略&#xA;    func benchmark(b *testing.B, size int){}&#xA;    func Benchmark10(b *testing.B) {benchmark(b, 10)}&#xA;    func Benchmark100(b *testing.B) {benchmark(b, 100)}&#xA;Example函数                       # 示例，无参无结果。&#xA;    用处&#xA;        可举例子作为文档&#xA;        结尾注释 // output: 验证终端输出&#xA;        实验代码&#xA;    func ExampleF()  {&#xA;        fmt.Print(&amp;quot;a&amp;quot;)&#xA;        // output: aa&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发编程&#34;&gt;&#xA;  并发编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;同步&#xA;    func&#xA;    channel                                 # 和调度器深度关联，控制goroutine的阻塞和唤醒&#xA;        缓冲区&#xA;            作用&#xA;                异步&#xA;                    发送接收解耦&#xA;                    让数据可并行处理(计数信号量)&#xA;                    消除goroutine间速率差异(速率大致相同, 某刻休息)&#xA;                        上下游速率差异大时无作用&#xA;                阻塞时同步&#xA;            c := make(chan struct{})&#xA;            c1 := make(chan struct{}, 1)&#xA;            c ← struct{}{}                  # 阻塞&#xA;            ← c                             # 阻塞&#xA;&#xA;            c1 ← struct{}{}                 # 不阻塞&#xA;            c1 ← struct{}{}                 # 阻塞&#xA;            ← c1                            # 不阻塞&#xA;            ← c1                            # 阻塞&#xA;        方向&#xA;            var c chan struct{}             # in和out&#xA;            var cin &amp;lt;-chan struct{}         # in, 关闭时panic&#xA;                v := &amp;lt;-cin&#xA;            var cout chan&amp;lt;- struct{}        # out&#xA;                cout &amp;lt;- v&#xA;&#xA;            cin = c&#xA;            cout = c&#xA;            c = cin                         # 编译错误&#xA;            c = cout                        # 编译错误&#xA;        nil                                 # 永远阻塞, 用于开启禁用情况&#xA;            var c chan struct{}&#xA;            c &amp;lt;- struct{}{}                 # 阻塞&#xA;        关闭                                 # 关闭不是必须的，不影响回收。只是用来通知和广播&#xA;            c := make(chan struct{})&#xA;            close(c)                        # 再关闭panic&#xA;            c ← struct{}{}                  # panic&#xA;            o, ok := ← c                    # o得到零值, ok是false&#xA;    for range&#xA;        c := make(chan struct{})&#xA;        ...&#xA;        for x := range c {}                 # close(c)时break&#xA;    select&#xA;&#xA;    sync包&#xA;    sync/atomic包&#xA;&#xA;&#xA;    o-&amp;gt; 并发三个业务, 一起结束&#xA;    cond := sync.NewCond(new(sync.Mutex))&#xA;    wg := sync.WaitGroup{}&#xA;    wg.Add(3)&#xA;    wg1 := sync.WaitGroup{}&#xA;    wg1.Add(3)&#xA;    for i := 0; i &amp;lt; 3; i++ {&#xA;        go func(i int) {&#xA;            defer wg1.Done()&#xA;            cond.L.Lock()&#xA;            fmt.Println(&amp;quot;wait&amp;quot;, i)          # 业务预处理&#xA;            wg.Done()&#xA;            cond.Wait()                     # 阻塞&#xA;            fmt.Println(&amp;quot;done&amp;quot;, i)          # 业务后续处理(要求所有业务预处理过)&#xA;            cond.L.Unlock()&#xA;        }(i)&#xA;    }&#xA;    wg.Wait()                               # 业务预处理完成&#xA;&#xA;    cond.L.Lock()&#xA;    cond.Broadcast()                        # 处理业务后续&#xA;    cond.L.Unlock()&#xA;    wg1.Wait()                              # goroutine完成&#xA;异步&#xA;    语句&#xA;        语句是串行一致的(sequentially consistent)&#xA;        串行一致基础上，语句会重排, 重排中可能穿插执行其它goroutine语句&#xA;            t := map[string]int{&#xA;                &amp;quot;a&amp;quot;: 1&#xA;                &amp;quot;b&amp;quot;: 2&#xA;            }&#xA;            重排为&#xA;            t := make(map[string]int)&#xA;            t[&amp;quot;a&amp;quot;]=1&#xA;            t[&amp;quot;b&amp;quot;]=2&#xA;    goroutine&#xA;        语句&#xA;            go f()&#xA;        泄漏&#xA;            阻塞不能自动结束                  # 如操作channel时&#xA;            main中最后调panic(), 从崩溃转储信息判断资源释放情况&#xA;        死锁(deadlock)                      # 指没有可调度的goroutine&#xA;            所有goroutine阻塞或没有goroutine&#xA;        运行main的是主goroutine, main返回所有goroutine暴力终结&#xA;        无id(标识)&#xA;        不能中断&#xA;        无返回值&#xA;    runtime&#xA;    context&#xA;    time&#xA;并发模式                                    # 避免goroutine泄漏，保证通信顺序&#xA;    done/quit&#xA;        o-&amp;gt; done控制goroutine退出。         # 更快的响应要写更多的逻辑入侵，找到响应慢点写done逻辑&#xA;        func f(done &amp;lt;-chan struct{}) {&#xA;            select {&#xA;            case &amp;lt;-done:&#xA;                for range ch{              # 耗尽通道, 其它goroutine不会卡在ch&amp;lt;-上而退出&#xA;                }&#xA;                return&#xA;            }&#xA;        }&#xA;        func cancelled()bool{&#xA;            select {&#xA;            case &amp;lt;-done:&#xA;                return true&#xA;            default:&#xA;                return false&#xA;            }&#xA;        }&#xA;        func f2(){                          # 轮循函数中入口检查, 避免创建新goroutine&#xA;            if cancelled() {&#xA;                return&#xA;            }&#xA;        }&#xA;&#xA;        done := make(chan struct{})&#xA;        defer close(done)&#xA;        f(done)&#xA;    channels of channels&#xA;        o-&amp;gt; 循环处理请求&#xA;        func handle(reqs chan chan interface{}) {&#xA;            for req := range reqs {&#xA;                req &amp;lt;- 0&#xA;            }&#xA;        }&#xA;        func server(req chan interface{}) {&#xA;            reqs := make(chan chan interface{})&#xA;            defer close(reqs)&#xA;            go handle(reqs)&#xA;            reqs &amp;lt;- req&#xA;        }&#xA;        func client() interface{} {&#xA;            req := make(chan interface{})&#xA;            defer close(req)&#xA;            go server(req)&#xA;            return &amp;lt;-req&#xA;        }&#xA;        fmt.Println(client())&#xA;&#xA;        o-&amp;gt; 循环异常退出&#xA;        type S struct {&#xA;            closing chan chan error&#xA;        }&#xA;        func (s *S) close() error {&#xA;            errc := make(chan error)&#xA;            s.closing &amp;lt;- errc&#xA;            return &amp;lt;-errc&#xA;        }&#xA;        func (s *S) loop() {&#xA;            for {&#xA;                select {&#xA;                case errc := &amp;lt;-s.closing:&#xA;                    errc &amp;lt;- nil&#xA;                    return&#xA;                }&#xA;            }&#xA;        }&#xA;    pipeline(fan-in, fan-out)           # 传入传出channel来处理&#xA;        o-&amp;gt;&#xA;        func gen(done &amp;lt;-chan struct{}, nums ...int) &amp;lt;-chan int {&#xA;            out := make(chan int)&#xA;            go func() {&#xA;                defer close(out)&#xA;                for _, n := range nums {&#xA;                    select {&#xA;                    case out &amp;lt;- n:&#xA;                    case &amp;lt;-done:&#xA;                        return&#xA;                    }&#xA;                }&#xA;            }()&#xA;            return out&#xA;        }&#xA;        func sq(done &amp;lt;-chan struct{}, in &amp;lt;-chan int) &amp;lt;-chan int {&#xA;            out := make(chan int)&#xA;            go func() {&#xA;                defer close(out)&#xA;                for n := range in {&#xA;                    select {&#xA;                    case out &amp;lt;- n * n:&#xA;                    case &amp;lt;-done:&#xA;                        return&#xA;                    }&#xA;                }&#xA;            }()&#xA;            return out&#xA;        }&#xA;        func merge(done &amp;lt;-chan struct{}, cs ...&amp;lt;-chan int) &amp;lt;-chan int {&#xA;            # wg等cs数目个协程合并数据到out后，关闭out&#xA;            var wg sync.WaitGroup&#xA;            out := make(chan int)&#xA;&#xA;            output := func(c &amp;lt;-chan int) {&#xA;                for n := range c {&#xA;                    select {&#xA;                    case out &amp;lt;- n:&#xA;                    case &amp;lt;-done:&#xA;                    }&#xA;                }&#xA;                wg.Done()&#xA;            }&#xA;&#xA;            wg.Add(len(cs))&#xA;            for _, c := range cs {&#xA;                go output(c)&#xA;            }&#xA;&#xA;            go func() {&#xA;                wg.Wait()&#xA;                close(out)&#xA;            }()&#xA;            return out&#xA;        }&#xA;&#xA;        func main() {&#xA;            done := make(chan struct{})&#xA;            defer close(done)&#xA;&#xA;            for n := range sq(done, sq(done, gen(done, 2, 3))) {&#xA;                # gen产生维护数字chan, sq产生维护平方chan。三个chan&#xA;                # 三个goroutine done()时return, chan return时close()&#xA;                fmt.Println(n)&#xA;            }&#xA;&#xA;            // 扇出&#xA;            in := gen(done, 2, 3)&#xA;            c1 := sq(done, in)&#xA;            c2 := sq(done, in)&#xA;            // 扇进&#xA;            for n := range merge(done, c1, c2) {&#xA;                fmt.Println(n)&#xA;            }&#xA;        }&#xA;    timeout&#xA;        select {&#xA;        case &amp;lt;-ch:&#xA;            ...&#xA;        case &amp;lt;-time.After(time.Second)&#xA;            return&#xA;        }&#xA;    控制并发数&#xA;        并发写缓冲区channel&#xA;        for循环产生并发数goroutine&#xA;常用&#xA;    中断&#xA;        # os.Exit()程序返回错误码&#xA;&#xA;        done := make(chan struct{})&#xA;        go func() {&#xA;            defer close(done)&#xA;            c := make(chan os.Signal, 1)&#xA;            defer close(c)&#xA;            signal.Notify(c, os.Interrupt, os.Kill)&#xA;            defer signal.Stop(c)&#xA;            &amp;lt;-c&#xA;        }()&#xA;    并发压测&#xA;        func concurrent(done chan struct{}, fn func(), num int, ccu int, qps int) {     # num总数，ccu并行数，qps并发数&#xA;            interval := time.Duration(1e9/qps) * time.Nanosecond&#xA;            don := make(chan struct{}, 2)&#xA;            go func() {&#xA;                &amp;lt;-done&#xA;                for i := 0; i &amp;lt; ccu; i++ {&#xA;                    don &amp;lt;- struct{}{}&#xA;                }&#xA;            }()&#xA;&#xA;            //&#xA;            tasks := make(chan struct{})&#xA;            go func() {&#xA;                var wg sync.WaitGroup&#xA;                wg.Add(num)&#xA;                for i := 0; i &amp;lt; num; i++ {&#xA;                    tasks &amp;lt;- struct{}{}&#xA;                    wg.Done()&#xA;                    time.Sleep(interval)&#xA;                }&#xA;                wg.Wait()&#xA;                close(tasks)&#xA;            }()&#xA;&#xA;            //&#xA;            var wg sync.WaitGroup&#xA;            wg.Add(ccu)&#xA;            for i := 0; i &amp;lt; ccu; i++ {&#xA;                go func() {&#xA;                    defer wg.Done()&#xA;                    for range tasks {&#xA;                        select {&#xA;                        case &amp;lt;-don:&#xA;                            return&#xA;                        default:&#xA;                            fn()&#xA;                        }&#xA;                    }&#xA;                }()&#xA;            }&#xA;            wg.Wait()&#xA;        }&#xA;        m := sync.Mutex{}&#xA;        count := 0&#xA;        do := func(){&#xA;            m.Lock()&#xA;            count++&#xA;            m.Unlock()&#xA;        }&#xA;        concurrent(done, do, 999, 100, 1e3)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Python</title>
      <link>https://ukeate.com/docs/pl/python/</link>
      <pubDate>Tue, 09 Oct 2018 16:05:05 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/python/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;虚拟机语言&#xA;虽然是脚本语言，可以预编译成pyc文件来执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;shell&#34;&gt;&#xA;  shell&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shell&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;#! /usr/bin/python&#xA;# -*- coding: utf8 -*-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;规范&#xA;    pep8&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内置函数&#34;&gt;&#xA;  内置函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;&#xA;    input(&amp;quot;&amp;quot;)&#xA;        # x = int(input(&amp;quot;Please enter an integer:&amp;quot;))&#xA;    print(&amp;quot;%s&amp;quot;, % s1)&#xA;        ## %.3s % (&amp;quot;abcdef&amp;quot;)取3字符&#xA;        ## %.* s % (2, &amp;quot;abcd&amp;quot;)取2字符)&#xA;    # %r repr()显示字符串&#xA;        # %c 单个字符&#xA;        # %b 二进制整数&#xA;        # %x 十六进制整数&#xA;        # %d 十进制整数&#xA;        # %i 十进制整数&#xA;        # %o 八进制整数&#xA;        # %e %E 指数(基底分别为e E)&#xA;        # %-10.3f %-10.3F 浮点数&#xA;        ## 10位宽, 小数精确3位, 右对齐&#xA;        # %g %G 指数(e E)或浮点数(根据显示长度决定)&#xA;        # %% 字符%&#xA;        print(&amp;quot;c is %s, e is %i&amp;quot; % (c, e)&#xA;    str(1)&#xA;    int(&amp;quot;1&amp;quot;)&#xA;    range(1, 10)&#xA;        # range(-2, -11, -3)&#xA;    exec(&#39;&#39;)&#xA;        # 执行字符串中的代码&#xA;    execfile(r&#39;a.py&#39;)&#xA;    eval(&#39;2 * 3&#39;, globals, locals)&#xA;        # 执行字符串中的表达式&#xA;        # ast.literal_eval&#xA;    compile(str, filename, kind)&#xA;        # 编译字符串为模块&#xA;        # kind取值: single单语句, exec多语句, eval一个表达式&#xA;    assert 1 != 1&#xA;    repr(list)&#xA;        # 对象转换成代码字符串　&#xA;    map(str, range(100))&#xA;    filter()&#xA;    reduce()&#xA;    locals()&#xA;        # 当前作用域的变量字典&#xA;    isinstance(value, list)&#xA;    hasattr(obj, &#39;__call__&#39;)&#xA;        # 判断是否函数&#xA;    type(l)&#xA;        # 返回对象类型，或创建metaclass&#xA;    chr(48)&#xA;        # 返回字符&#xA;    unichr&#xA;    ord(&#39;0&#39;)&#xA;        # 返回ascii码&#xA;    bool()&#xA;    iter()&#xA;    next()&#xA;    zip(&#39;abc&#39;, &#39;123&#39;)&#xA;        list(zip())&#xA;o-&amp;gt; 文件&#xA;    spath = &amp;quot;D:/a.txt&amp;quot;&#xA;    f = open(spath, &amp;quot;w&amp;quot;)&#xA;        # 没有时创建&#xA;    f.write(&amp;quot;a\n&amp;quot;)&#xA;    f.writelines(&amp;quot;b&amp;quot;)&#xA;    f.close()&#xA;&#xA;    f = open(spath, &amp;quot;r&amp;quot;)&#xA;    for line in f:&#xA;        print(&amp;quot;%s&amp;quot; % line)&#xA;    f.readline()&#xA;    f.close()&#xA;o-&amp;gt; 文档&#xA;    dir(list)&#xA;    help(s.replace)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 基本类型&#xA;    数字&#xA;        1.2, 3+4j, Decimal, Fraction&#xA;    字符串&#xA;&#xA;&#xA;    列表&#xA;        [1, 2]&#xA;    字典&#xA;        {&#39;a&#39;:1}&#xA;    元组&#xA;        (1)&#xA;    文件&#xA;        open(&#39;eggs&#39;, &#39;r&#39;)&#xA;    集合&#xA;        {&#39;a&#39;}&#xA;    其他类型&#xA;        类型, None, False, True&#xA;    编程单元&#xA;        函数, 模块, 类&#xA;    实现相关类型&#xA;        编译代码堆栈跟踪&#xA;                &#xA;o-&amp;gt; 扩展属性&#xA;    dict = type(&#39;dict&#39;, (dict,), {})&#xA;    d = dict()&#xA;    d.a = 1&#xA;&#xA;o-&amp;gt; 序列&#xA;    [1,&#xA;    2]&#xA;    [1, [2]]&#xA;&#xA;    len(l)&#xA;    l[0]&#xA;    l[-1]&#xA;    l[1:3]&#xA;    l[1:]&#xA;    l[:3]&#xA;    l[:-1]&#xA;    l[:]&#xA;&#xA;    l + l&#xA;    l * 2&#xA;    del l[1:3]&#xA;    o-&amp;gt; 字符串&#xA;        # 不可变&#xA;        r&#39;a&#39; R&#39;a&#39; u&#39;a&#39; U&#39;a&#39; b&#39;a&#39; B&#39;a&#39;&#xA;        &#39;abc\&#xA;        def&#39;&#xA;        &#39;a&#39; &#39;b&#39;&#xA;        &#39;a&#39; &amp;quot;a&amp;quot; &#39;&#39;&#39;a&#39;&#39;&#39; &amp;quot;&amp;quot;&amp;quot;a&amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;        s.startswith(&#39;a&#39;)&#xA;        s.find(&#39;a&#39;)&#xA;        s.replace(&#39;a&#39;, &#39;A&#39;)&#xA;        s.split(&#39;,&#39;)&#xA;        s.join(list)&#xA;        s.upper()&#xA;        s.isalpha()&#xA;        s.isdigit()&#xA;        s.rstrip()&#xA;                # 去右侧空白&#xA;        &#39;%s, %s&#39; % (&#39;a&#39;, &#39;b&#39;)&#xA;        &#39;{0},{1}&#39;.format(&#39;a&#39;, &#39;b&#39;)&#xA;&#xA;        if &#39;a&#39; in name:&#xA;    o-&amp;gt; 列表&#xA;        l.append(&#39;h&#39;)&#xA;        l.pop(2)&#xA;            # 弹出特定位置&#xA;        l.sort()&#xA;        l.reverse()&#xA;&#xA;        print(l)&#xA;&#xA;        for x in word:&#xA;&#xA;        [2 * i for i in [2,3,4] if i &amp;gt; 2]&#xA;            # 列表解析&#xA;            [row[1] + 1 for row in M]&#xA;            [M[i][i] for i in [0, 1, 2]]&#xA;            {ord(x) for x in &#39;spaam&#39;}&#xA;                # 创建集合&#xA;            {x: ord(x) for x in &#39;spaam&#39;}&#xA;                # 创建字典&#xA;    o-&amp;gt; 元组&#xA;        # 不可变&#xA;        (&#39;a&#39;, &#39;b&#39;)&#xA;        (1,) + (2,)&#xA;            # (1, 2)&#xA;        t.index(&#39;c&#39;)&#xA;        t.count(&#39;c&#39;)&#xA;    o-&amp;gt; set&#xA;        s = set(&#39;a&#39;)&#xA;        set([1])&#xA;        s.add(2)&#xA;&#xA;        s1, s2&#xA;        s1 &amp;amp; s2&#xA;        s1 | s2&#xA;        s1 - s2&#xA;        {x ** 2 for x in [1,2,3,4]}&#xA;            # 返回set&#xA;&#xA;o-&amp;gt; 字典&#xA;    d = {&#39;a&#39;: &#39;aaa&#39;, &#39;b&#39;: &#39;bbb&#39;, &#39;c&#39;: 12}&#xA;    d[&#39;d&#39;] = 3&#xA;&#xA;    d.items()&#xA;        # key value&#xA;    d.keys()&#xA;        list(d.keys())&#xA;&#xA;    len(d)&#xA;    del d[&#39;a&#39;]&#xA;    d.get(&#39;a&#39;, 0)&#xA;    d[&#39;a&#39;]&#xA;&#xA;    for key in d:&#xA;    if &#39;a&#39; in d:&#xA;    d[&#39;a&#39;] if &#39;a&#39; in d else 0&#xA;o-&amp;gt; 文件&#xA;    f = open(&#39;data.txt&#39;, &#39;w&#39;)&#xA;    f.write(&#39;a&#39;)&#xA;    f.close()&#xA;&#xA;    text = f.read()&#xA;        text.split()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;语句&#34;&gt;&#xA;  语句&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 语句&#xA;    在物理行中用分号划分逻辑行&#xA;    pass&#xA;o-&amp;gt; 运算符&#xA;    + - * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= == !=&#xA;    &amp;amp; | ^ ~&#xA;        # 按位与 或 异或 翻转(x 变为 -(x + 1))&#xA;    not and or&#xA;    **&#xA;        # 幂&#xA;    //&#xA;        # 取整除&#xA;    code if None else 0&#xA;    True and 1 or 0&#xA;o-&amp;gt; 条件&#xA;    if x &amp;lt; 0:&#xA;            x = 0&#xA;    elif x == 0:&#xA;    else:&#xA;o-&amp;gt; 循环&#xA;    for x in a:&#xA;    else:&#xA;&#xA;    while running:&#xA;    else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;函数&#xA;    def sum(a, b=2, *args, **kwargs):&#xA;            # *args得到元组, kwargs得到字典&#xA;            &#39;&#39;&#39; doc&#xA;        string&#39;&#39;&#39;&#xA;&#xA;        global x&#xA;        nonlocal y&#xA;        return a + b&#xA;    sum(a=1)&#xA;    sum.__doc__&#xA;&#xA;    def make_repeater(n):&#xA;        return lambda s: s * n&#xA;            # lambda只能跟表达式，返回一个函数&#xA;生成器&#xA;    def gn2():&#xA;        yield&#xA;    def gn(N):&#xA;        for i in range(N):&#xA;            yield i ** 2&#xA;        yield from gn2()&#xA;            # 相当于静态引入gn2&#xA;    g = gn()&#xA;    next(g)&#xA;    g.send(1)&#xA;asyncio模块&#xA;    @asyncio.coroutine&#xA;    def f():&#xA;        yield from asyncio.sleep(1)&#xA;    loop = asyncio.get_event_loop()&#xA;    tasks = [asyncio.async(f())]&#xA;    loop.run_until_complete(asyncio.wait(tasks))&#xA;    loop.close()&#xA;协程&#xA;    @types.coroutine&#xA;    def f2():&#xA;        yield&#xA;&#xA;    async def f():&#xA;        print(1)&#xA;        await f2()&#xA;                # 协程显式交替，线程不用写，会隐式交替&#xA;&#xA;    try:&#xA;        f().send(None)&#xA;    except StopIteration:&#xA;        pass&#xA;协程asyncio&#xA;    async f():&#xA;        await asyncio.sleep(1)&#xA;    loop = asyncio.get_event_loop()&#xA;    tasks = [asyncio.ensure_future(f())]&#xA;    loop.run_until_complete(asyncio.wait(tasks))&#xA;    loop.close()&#xA;协程属性&#xA;    gi_frame&#xA;        f_code&#xA;            co_filename&#xA;        f_lineno&#xA;属性&#xA;    __name__&#xA;    __code__&#xA;    __annotations__&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;oop&#34;&gt;&#xA;  oop&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#oop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Base:&#xA;    __metaclass__ = models.SubfieldBase&#xA;        # __metaclass__实例化结果是类，用于继承&#xA;    description = &#39;&#39;&#xA;    def __init__(self, name):&#xA;        # self就是this&#xA;        #  __del__(self)&#xA;        # __str__(self)&#xA;        # __lt__(self)&#xA;        # __getitem__(self, key)&#xA;        ## x[key]索引时调用&#xA;        # __len__(self)&#xA;        super(Base, self).__init__(*args, **kwargs)&#xA;        self.data = []&#xA;&#xA;    def add(self, x)&#xA;        self.data.append(x)&#xA;    @classmethod&#xA;    def t1(cls):&#xA;    @staticmethod&#xA;    def t2():&#xA;class Child(Base):&#xA;    # 继承&#xA;    def plus(self, a, b):&#xA;        return a + b&#xA;oChild = Child()&#xA;oChild.add(&amp;quot;str1&amp;quot;)&#xA;oChild.data&#xA;oChild.plus(2, 3)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模块&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# .pyc是字节编译文件&#xA;# __name__ 等于&#39;__main__&#39;时程序本身使用运行, 否则是引用&#xA;&#xA;# a.py&#xA;def add_func(a, b):&#xA;        return a + b&#xA;# b.py&#xA;from a import add_func&#xA;    # import add_func as f&#xA;    # from a import *&#xA;&#xA;# __init__.py&#xA;    # 表示文件夹为包, 可空&#xA;&#xA;包路径&#xA;    # 环境变量PYTHONPATH中的值&#xA;    import sys&#xA;    import os&#xA;&#xA;    sys.path&#xA;    sys.path.append(os.getcwd() + &amp;quot;\\parent\\child&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;异常&#34;&gt;&#xA;  异常&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e5%b8%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;if s == &amp;quot;&amp;quot;:&#xA;    raise Exception(&amp;quot;must not be empty.&amp;quot;)&#xA;try:&#xA;    i = int(s)&#xA;except Exception as err:&#xA;    # except Exception, err&#xA;    print(&#39;Error %d: %s&#39; % (e.args[0], e.args[1]))&#xA;except:&#xA;finally:&#xA;    print(&amp;quot;Goodbye.&amp;quot;)&#xA;else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模块-1&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;os&#xA;sys&#xA;    argv&#xA;        # 参数列表, 多维列表&#xA;    exit()&#xA;        # 退出线程&#xA;imp&#xA;    reload&#xA;        # 重载模块&#xA;time&#xA;timeit&#xA;profile&#xA;decimal&#xA;fractions&#xA;urllib&#xA;http&#xA;    http.server&#xA;        # python3中的SimpleHTTPServer&#xA;re&#xA;functools&#xA;itertools&#xA;SimpleHTTPServer&#xA;    # python2自带ftp服务器。&#xA;    pythom -m SimpleHTTPServer 8080&#xA;&#xA;&#xA;PyQt&#xA;    # gui&#xA;PyGTK&#xA;    # gui&#xA;wxPython&#xA;    # gui&#xA;TkInter&#xA;    # gui&#xA;matplotlib&#xA;    # 图形&#xA;pillow&#xA;    # ocr, 文字识别&#xA;pytesseract&#xA;    # ocr, 精确&#xA;&#xA;&#xA;numpy&#xA;math&#xA;random&#xA;scipy&#xA;    # 科学计算&#xA;&#xA;beautifulsoup&#xA;    # 网页结构化&#xA;scrapy&#xA;    # 网页结构化&#xA;requests&#xA;phantomJS&#xA;    # 运行网页js&#xA;selenium&#xA;    # 运行网页js&#xA;&#xA;&#xA;pandas&#xA;    # 数据分析，产生数据结构、操作、统计、绘图&#xA;seaborn&#xA;    # 数据可视化&#xA;scikit-learn&#xA;    # 机器学习&#xA;nltk&#xA;    # 自然语言分析&#xA;&#xA;&#xA;mysql-connector&#xA;mysqlclient&#xA;PyMySQL&#xA;MySQLdb&#xA;redis.py&#xA;south&#xA;    # 表结构迁移, django自带&#xA;&#xA;pickle&#xA;    # 持久化&#xA;qrcode&#xA;    # 二维码&#xA;&#xA;&#xA;ast&#xA;    # 运算前检查的eval()&#xA;datetime&#xA;shutil&#xA;    # shell&#xA;&#xA;&#xA;fabric&#xA;    # 运程自动部署&#xA;celery&#xA;    # 定时调度&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ipython notebook&#xA;    # 在线运行python&#xA;bpython&#xA;    # 更好的repl&#xA;pdb&#xA;    # 调试&#xA;cprofile&#xA;    # 性能测试&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;steuptools&#34;&gt;&#xA;  steuptools&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#steuptools&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;easy_install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pip&#34;&gt;&#xA;  pip&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pip&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pip install -i http://pypi.douban.com/simple/ torndb&#xA;    # 用豆辨的pypi索引&#xA;pip install ipython==4.2.0&#xA;    # 安装指定版本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pyenv&#34;&gt;&#xA;  pyenv&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pyenv&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pyenv versions&#xA;pyenv install 3.7.6&#xA;    --list&#xA;pyenv virtualenv 3.7.6 37&#xA;eval &amp;quot;$(pyenv init -)&amp;quot;&#xA;eval &amp;quot;$(pyenv virtualenv-init -)&amp;quot;&#xA;pyenv activate 37&#xA;pyenv deactivate&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;conda&#34;&gt;&#xA;  conda&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#conda&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;环境相关&#xA;    conda env&#xA;        create -f e.yml     # 创建环境&#xA;            -n name1    &#xA;        list                # 列出所有环境&#xA;        remove -n name1     # 删除环境&#xA;    conda activate e1&#xA;    conda init bash&#xA;包相关&#xA;    conda list              # 当前环境所有软件包&#xA;    conda search pillow     # 列出包所有版本&#xA;    conda install pillow=7.0.0&#xA;        -c                  # 指定channel，相当于命名空间&#xA;    conda uninstall pillow&#xA;    conda upgrade numpy&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;容器&#34;&gt;&#xA;  容器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;gunicorn&#xA;    # python实现&#xA;    sudo pip install gunicorn&#xA;    gunicorn -w4 -b0.0.0.0:8001 app.wsgi&#xA;uwsgi&#xA;    # c语言实现&#xA;    sudo pip install uwsgi&#xA;    uwsgi --http :8001 --chdir /path/to/project --home=/path/to/env --module project.wsgi&#xA;            # --home指定virtualenv的路径&#xA;nginx&#xA;shell&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Clojure</title>
      <link>https://ukeate.com/docs/pl/clojure/</link>
      <pubDate>Tue, 09 Oct 2018 16:00:21 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/clojure/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程&#xA;    操作符知道自己的特征值(identity value), 如+是0, *是1&#xA;    数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃&#xA;    集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能&#xA;            # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的&#xA;    没有尾递归优化，不常用递归，要用loop.recur&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    s-expressions&#xA;            (max 3 5)&#xA;            (+ 1 (* 2 3))&#xA;            (def meaning-of-life 42)&#xA;            (if (&amp;lt; meaning-of-life 0) &amp;quot;negative&amp;quot; &amp;quot;non-negative&amp;quot;)&#xA;    (def droids [&amp;quot;Huey&amp;quot; &amp;quot;Dewey&amp;quot; &amp;quot;Louie&amp;quot;])&#xA;            (count droids)&#xA;            (droids 0)&#xA;    (def me {:name &amp;quot;Paul&amp;quot; :age 45 :sex :male})&#xA;            (:age me)&#xA;    (defn percentage [x p] (* x (/ p 100.0)))&#xA;            (percentage 200 10)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发&#34;&gt;&#xA;  并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 原子变量&#xA;        # 对一个值进行同步更新&#xA;(def my-atom (atom 42))&#xA;(deref my-atom)&#xA;@my-atom&#xA;(swap! my-atom inc)&#xA;(swap! my-atom + 2)&#xA;(reset! my-atom 0)&#xA;&#xA;(def session (atom {}))&#xA;(swap! session assoc :username &amp;quot;paul&amp;quot;)&#xA;&#xA;(if (compare-and-set! a old new)&#xA;        # 判断原子变量a的值是否是old, 是时赋成new并返回true&#xA;new&#xA;(recur))&#xA;&#xA;o-&amp;gt; conj 添加新成员&#xA;(def players (atom ()))&#xA;(defn list-players []&#xA;(response (json/encode @players)))&#xA;(defn create-player [player-name]&#xA;(swap! players conj player-name)&#xA;(status (response &amp;quot;&amp;quot;) 201))&#xA;(defroutes app-routes&#xA;(GET &amp;quot;/players&amp;quot; [] (list-players))&#xA;(PUT &amp;quot;/players/:player-name&amp;quot; [player-name] (create-player player-name)))&#xA;(defn -main [&amp;amp; args]&#xA;(run-jetty (site app-routes) {:port 3000}))&#xA;&#xA;o-&amp;gt; cons列表首添加元素&#xA;(def listv2 (cons 4 listv1))&#xA;&#xA;o-&amp;gt; validator&#xA;        # 值改变之前调用&#xA;(def non-negative (atom 0 :validator #(&amp;gt;= % 0)))&#xA;(reset! non-negative -1)&#xA;&#xA;o-&amp;gt; 监视器&#xA;        # 值改变之后调用　&#xA;(def a (atom 0))&#xA;(add-watch a :print #(println &amp;quot;Changed from &amp;quot; %3 &amp;quot; to &amp;quot; %4))&#xA;(swap! a + 2)&#xA;        # !的命名表示函数是事务不安全的&#xA;&#xA;o-&amp;gt; 代理&#xA;        # 对一个值进行异步更新。&#xA;        # 代理维护的数据与事务数据相同。代理具有事务性，send会在事务成功后生效&#xA;        # 方便做内存并发日志系统&#xA;(def my-agent (agent 0))&#xA;@my-agent&#xA;(send my-agent inc)&#xA;        # send在值更新之前立即返回，不进行重试。多线程同时调用send, 调用被串行。具有副作用&#xA;        # send使用公用线程池，send-off使用一个新线程，send-via使用由参数指定的executor&#xA;(send my-agent #((Thread/sleep 2000) (inc %)))&#xA;        # 设置延迟时间&#xA;(await my-agent)&#xA;        # 等待代理执行完成后再继续。await-for函数可以设置超时时间&#xA;&#xA;(def non-negative (agent 1 :validator (fn [new-val] (&amp;gt;= new-val 0))))&#xA;        # 代理可以使用校验器和监视器&#xA;        # 校验器失败时抛出异常，代理进入失效状态&#xA;        # 错误处理模式默认为 :fail, 可以置为:continue&#xA;        # 可以设置错误处理函数&#xA;(agent-error non-negative)&#xA;        # 查看代理是否在失效状态&#xA;(restart-agent non-negative 0)&#xA;        # 重置失效状态&#xA;&#xA;o-&amp;gt; 引用&#xA;        # 只有在事务中才能修改引用的值，对多个值进行同步更新&#xA;(def my-ref (ref 0))&#xA;@my-ref&#xA;&#xA;(dosync (ref-set my-ref 42))&#xA;        # dosync创建一个事务，事务同swap!一样，用重试机制实现&#xA;        # clojure的事务有原子性，一致性，隔离性，没有持久性&#xA;(dosync (alter my-ref inc))&#xA;        # commute替换alter，可以得到不很强的隔离性，用于做优化&#xA;(defn transfer [from to amount]&#xA;(dosync &#xA;    (alter from - amount)&#xA;    (alter to + amount)))&#xA;&#xA;o-&amp;gt; threed&#xA;(defn stress-thread [from to iterations amount]&#xA;(Thread. #(dotimes [_ iterations] (transfer from to amount))))&#xA;(let [t1 (stress-thread checking savings 100 100)&#xA;    t2 (stress-thread savings checking 200 100)]&#xA;(.start t1)&#xA;(.start t2)&#xA;(.join t1)&#xA;(.join t2))&#xA;&#xA;o-&amp;gt; ensure确保当前返回的值不被其它事务修改&#xA;(when (and (= (ensure left) :thinking) (= (ensure right) :thinking))&#xA;(ref-set philosopher :eating))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;csp&#34;&gt;&#xA;  csp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#csp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        core.async提供了channel和go块&#xA;        引入的core.async中部分函数名与clojure核心库函数名冲突&#xA;&#xA;o-&amp;gt; channel&#xA;(def c (chan))&#xA;(thread (println &amp;quot;Read:&amp;quot; (&amp;lt;!! c) &amp;quot;from c&amp;quot;))&#xA;        # thread是core.async提供的辅助宏，将其中代码运行在一个单独的线程上&#xA;(&amp;gt;!! c &amp;quot;Hello thread&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;用例&#34;&gt;&#xA;  用例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%a8%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;求和&#xA;(defn recursive-sum &#xA;&amp;quot;&amp;quot;&#xA;        # 文档字符串&#xA;        ## (require &#39;[philosophers.util :refer :all])&#xA;        ## (clojure.repl/doc swap-when!) 来查看文档字符串&#xA;[numbers &amp;amp; args])&#xA;        # &amp;amp;表示可变参数&#xA;        ## (apply f old args) 将args展开，作为附加参数传递给f&#xA;(if (empty? numbers)&#xA;    0&#xA;    (+ (first numbers) (recursive-sum (rest numbers))))&#xA;&#xA;(defn reduce-sum [numbers]&#xA;(reduce (fn [acc x] (+ acc x)) 0 numbers))&#xA;&#xA;(defn sum [numbers]&#xA;(reduce + numbers))&#xA;&#xA;o-&amp;gt;并行&#xA;(ns sum.core&#xA;(:require [clojure.core.reducers :as r]))&#xA;&#xA;(defn parallel-sum [numbers]&#xA;(r/fold + numbers))&#xA;&#xA;(def numbers (into [] (range 0 10000)))&#xA;(time (sum numbers))&#xA;(time (sum numbers))&#xA;        # 预热jim编译器&#xA;(time (parallel-sum numbers))&#xA;&#xA;o-&amp;gt; map&#xA;(def counts {&amp;quot;apple&amp;quot; 2 &amp;quot;orange&amp;quot; 1})&#xA;        (get counts &amp;quot;apple&amp;quot; 0)&#xA;        (get counts &amp;quot;banana&amp;quot; 0)&#xA;                # 没有时返回设定的默认值0&#xA;        (assoc counts &amp;quot;banana&amp;quot; 1)&#xA;        (assoc counts &amp;quot;apple&amp;quot; 3)&#xA;&#xA;o-&amp;gt; frequencies&#xA;(defn word-frequencies [words]&#xA;(reduce&#xA;(fn [counts word] (assoc counts word (inc (get counts word 0))))&#xA;{} words))&#xA;&#xA;(frequencies [&amp;quot;one&amp;quot; &amp;quot;potato&amp;quot;])&#xA;        # 标准库中已提供&#xA;&#xA;o-&amp;gt; partial函数&#xA;        # 返回一个被局部代入的函数&#xA;(def multiply-by-2 (partial * 2))&#xA;(multiply-by-2 3)&#xA;&#xA;o-&amp;gt; 序列&#xA;(defn get-words [text] (re-seq #&amp;quot;\w+&amp;quot; text))&#xA;(get-words &amp;quot;one tow three four&amp;quot;)&#xA;(map get-words [&amp;quot;one two three&amp;quot; &amp;quot;four five six&amp;quot;])&#xA;(mapcat get-words [&amp;quot;one two three&amp;quot; &amp;quot;four five six&amp;quot;])&#xA;        # 平辅数组&#xA;&#xA;o-&amp;gt; iterate&#xA;        # 不断将函数应用到初始值，第一次返回值，第二次返回值&#xA;(take 10 (iterate inc 0))&#xA;(take 10 (iterate (partial + 2) 0))&#xA;(take-last 5 (range 0 10000))&#xA;        # 头元素使用后舍弃，耗相同的内存&#xA;&#xA;o-&amp;gt; pmap&#xA;(pmap #(frequencies (get-words %)) pages)&#xA;        # pmap在需要结果时并行计算，仅生成需要的结果，称为半懒惰(semi-lazy)&#xA;        # #(...)是读取器宏，来快速创建匿名函数，参数通过%1, %2标识, 只有一个参数时可以是%&#xA;        ## (fn [page] (frequencies (get-words page)))与其等价&#xA;&#xA;o-&amp;gt; merge-with&#xA;        # 标准库函数&#xA;(merge-with f &amp;amp; maps)&#xA;        # 将maps中其余map合并到第一个map中，返回合并后的map&#xA;        ## 同键名时，多个值从左向右地合并，调用传递的f(val-in-result val-in-latter)&#xA;(def merge-counts (partial merge-with +))&#xA;(merge-counts {:x 1 :y 2} {:y 1 :z 1})&#xA;&#xA;o-&amp;gt; partition-all&#xA;        # 序列分批&#xA;(partition-all 4 [1 2 3 4 5 6 7 8 9 10])&#xA;        # ((1 2 3 4) (5 6 7 8) (9 10))&#xA;&#xA;o-&amp;gt; reducers包&#xA;        # 化简器，不代表函数的结果，代表如何产生结果的描述&#xA;        ## 嵌套的函数返回化简器，比返回懒惰序列效率更高&#xA;        ## 可以对整个嵌套链的集合操作，可以用fold进行并行化&#xA;        # clojure.core中大部分函数都有其对应的化简器版本&#xA;(require &#39;[clojure.core.reducers :as r]&#39;)&#xA;(r/map (partial * 2) [1 2 3 4])&#xA;        # 返回一个化简器(reducible)&#xA;(reduce conj [] reducible)&#xA;        # conj函数第一个参数为一个集合(初始值为[]), 将第二个参数合并到第一个参数中&#xA;(into [] reducible)&#xA;        # into函数为内置函数，同上&#xA;&#xA;o-&amp;gt;协议(类似java中的接口)来定义&#xA;(defprotocol CollReduce&#xA;        # 化简&#xA;(coll-reduce [coll f] [coll f init]))&#xA;        # coll相当于this, 支持多态性分派(polymorphic dispatch)&#xA;(coll-reduce coll f)&#xA;&#xA;(defn my-reduce&#xA;([f coll] (coll-reduce coll f))&#xA;([f init coll] (coll-reduce coll f init)))&#xA;(my-reduce + [1 2 3 4])&#xA;(my-reduce + 10 [1 2 3 4])&#xA;&#xA;(defn make-reducer [reducible transforms]&#xA;(reify&#xA;    CollReduce&#xA;    (coll-reduce [_ f1]&#xA;    (coll-reduce reducible (transformf f1) (f1)))&#xA;    (coll-reduce [_ f1 init]&#xA;    (coll-reduce reducible (transformf f1) init))))&#xA;        # 用reify实现一个协议&#xA;        # 调用reducible的coll-reduce方法。用transformf对f1进行转换，转换出的函数作为传给coll-reduce方法的一个参数&#xA;        # _表示未被使用的函数参数名，可以写成(coll-reduce [this f1])&#xA;&#xA;(defn my-map [mapf reducible]&#xA;(make-reducer reducible&#xA;    (fn [reducef]&#xA;    (fn [acc v]&#xA;        (reducef acc (mapf v))))))&#xA;        # acc是之前化简结果, v是集合元素。mapf对v进行转换&#xA;&#xA;o-&amp;gt; fold折叠&#xA;        # 不能适用于懒惰序列&#xA;(defprotocol CollFold&#xA;(coll-fold [coll n combinef reducef]))&#xA;&#xA;(defn my-fold&#xA;([reducef coll]&#xA;    (my-fold reducef reducef coll))&#xA;([combinef reducef coll]&#xA;    (my-fold 512 combinef reducef coll))&#xA;([n combinef reducef coll]&#xA;    (coll-fold coll n combinef reducef)))&#xA;&#xA;(defn make-reducer [reducible transformf]&#xA;(reify&#xA;    CollFold&#xA;    (coll-fold [_ n combinef reducef]&#xA;    (coll-fold reducible n combinef (transformf reducef)))&#xA;&#xA;    (CollReduce&#xA;    (coll-reduce [_ f1]&#xA;        (coll-reduce reducible (transformf f1) (f1)))&#xA;    (coll-reduce [_ f1 init]&#xA;        (coll-reduce reducible (transformf f1) init))))&#xA;&#xA;(def numbers (into [] (take 10000000 (repeatedly #(rand-int 10)))))&#xA;(require [&#39;reducers.parallel-frequencies :refer :all&#39;])&#xA;(time (frequencies numbers))&#xA;(time (parallel-frequencies numbers))&#xA;&#xA;o-&amp;gt; doall强迫懒惰序列对全部元素求值&#xA;(reduce + (doall (map (partial * 2) (range 10000))))&#xA;&#xA;o-&amp;gt; future&#xA;        # 单独线程中执行一段代码&#xA;        # 典型场景是异步通信&#xA;(def sum (future (+ 1 2 3 4 5)))&#xA;sum&#xA;        # 返回一个future对象&#xA;(deref sum)&#xA;@sum&#xA;        # 运行&#xA;(let [a (future (+ 1 2))&#xA;    b (future (+ 3 4))]&#xA;(+ @a @b))&#xA;        # let给a赋值，阻塞当前线程直到被求值&#xA;        # 外层加法将一直阻塞，直到所有代表的值被求值&#xA;&#xA;o-&amp;gt; promise&#xA;        # 创建promise对象后，代码并不会像future一样立即执行，等待deliver赋值后执行&#xA;(def meaning-of-life (promise))&#xA;(future (println &amp;quot;The meaning of life is:&amp;quot; @meaning-of-life))&#xA;(deliver meaning-of-life 42)&#xA;&#xA;o-&amp;gt; Compojure库的服务器&#xA;(def snippets (repeatedly promise))&#xA;(defn accept-snippet [n test]&#xA;(deliver (nth snippets n) test))&#xA;(future&#xA;(doseq [snippet (map deref snippets)]&#xA;    (println snippet)))&#xA;&#xA;(defroutes app-routes&#xA;(PUT &amp;quot;/snippet/:n&amp;quot; [n :as {:keys [body]}]&#xA;    (accept-snippet (edn/read-string n) (slurp body))&#xA;    (response &amp;quot;OK&amp;quot;)))&#xA;(defn -main [&amp;amp; args]&#xA;(run-jetty (site app-routes) {:port 3000}))&#xA;&#xA;o-&amp;gt; re-seq正则&#xA;(defn sentence-split [text]&#xA;(map trim (re-seq #&amp;quot;[^\.!\?:;]+[\.!\?:;]*&amp;quot; text)))&#xA;        # trim是内置函数&#xA;(defn is-sentence? [text]&#xA;(re-matches #&amp;quot;^.*[\.!\?:;]$&amp;quot; text))&#xA;&#xA;o-&amp;gt; reductions&#xA;        # 同reduce, 返回中间值构成的序列&#xA;(reductions + [1 2 3 4])&#xA;        # (1 3 6 10)&#xA;&#xA;o-&amp;gt; clj-http库&#xA;(def translator &amp;quot;http://localhost:3001/translate&amp;quot;)&#xA;(defn translate [text]&#xA;(future&#xA;    (:body (client/post translator {:body text}))))&#xA;&#xA;o-&amp;gt; delay在解引用前不求值&#xA;(def translations&#xA;(delay&#xA;    (map translate (strings-&amp;gt;sentences (map deref snippets)))))&#xA;&#xA;o-&amp;gt; 系统时间&#xA;(defn now []&#xA;(System/currentTimeMillis))&#xA;&#xA;o-&amp;gt; Schejulure库&#xA;(def session-sweeper&#xA;(schedule {:min (range 0 60 5)} sweep-sessions))&#xA;        # 定期调用&#xA;&#xA;o-&amp;gt; Useful库&#xA;(defn expired? [session]&#xA;(&amp;lt; @(:last-referenced session) (session-expiry-time)))&#xA;(defn sweep-sessions []&#xA;(swap! sessions #(remove-vals % expired?)))&#xA;        # 删除元素&#xA;&#xA;o-&amp;gt; Loop/Recur&#xA;(defn swap-when! [a pred f &amp;amp; args]&#xA;(loop []&#xA;    (let [old @a]&#xA;    (if (pred old)&#xA;        (let [new (apply f old args)]&#xA;        (if (compare-and-set! a old new)&#xA;            new&#xA;            (recur)))&#xA;        nil))))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;clojureScript&#xA;        # 编译到js&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>JS</title>
      <link>https://ukeate.com/docs/pl/js/</link>
      <pubDate>Tue, 09 Oct 2018 10:31:30 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/js/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特性&#xA;    原型链, 面向对象, 动态语言(已超出脚本语言的范畴)&#xA;    弱类型，变量都是var&#xA;    解释器有自己的内存管理机制(garbage collection)&#xA;    自由数据类型转换                        # 产生了==, ===的判断相等的不同定义&#xA;v8引擎&#xA;    直接生成机器码&#xA;    分代式GC&#xA;    java jvm工程师参数了优化&#xA;历史&#xA;    Netscape(现Mozilla)创建JavaScript, 但JavaScript是Sun(现Oracle)的注册商标&#xA;    作为标准提交给ECMA(欧洲计算机制造协会), 改名为ECMAScript&#xA;        ECMAScript 3(ES3) 作为标准广泛使用&#xA;        ECMAScript 5(ES5) 定义了新的语言标准&#xA;        JavaScript1.5是Mozilla的版本号, 相当于ES3,包含一些非标准语言扩展&#xA;            JavaScript1.8 在实现es7&#xA;        JavaScript解释器或引擎(engine)也有版本号&#xA;            Google的叫做V8(现在是4.0)&#xA;    微软改动并取名Jscript&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;标准&#34;&gt;&#xA;  标准&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%87%e5%87%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;ecmascript-6&#34;&gt;&#xA;  ECMAScript 6&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ecmascript-6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    目标是js可写&#xA;        复杂的应用程序&#xA;        函数库&#xA;        代码自动自成器(code generator)&#xA;    mozilla基于ECMAScript6 发布 JavaScript2.0&#xA;    V8, node.js使用&#xA;&#xA;let                                 # 块级作用域中声明变量&#xA;const                               # 声明常量&#xA;Set对象                              # 同java Set, 是一个数组&#xA;    属性&#xA;        size&#xA;    方法&#xA;        add(value)&#xA;        delete(value)&#xA;        has(value)&#xA;        clear()&#xA;Map对象                              # 键值对，键可以是对象&#xA;    使用&#xA;        var m = new Map();&#xA;        o = {p: &amp;quot;Helllo&amp;quot;};&#xA;        m.set(o, &amp;quot;content&amp;quot;);&#xA;        m.get(o);&#xA;    属性&#xA;        size&#xA;    方法&#xA;        set(key, value)&#xA;        get(key)&#xA;        has(key)&#xA;        delete(key)&#xA;        clear()&#xA;... (rest运算符)&#xA;yield关键字&#xA;class关键字&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;commonjs&#34;&gt;&#xA;  commonJS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#commonjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    模块化标准&#xA;    require同步加载, 再执行代码，会阻塞。对服务器不是问题，对浏览器是大问题&#xA;    输出的是值的拷贝&#xA;    require后的模块运行后缓存, 可手动清除缓存&#xA;commonJs规范下的javascript&#xA;    node.js&#xA;    mongoDB&#xA;    ringojs&#xA;使用&#xA;    var math = require(&#39;math&#39;);&#xA;    math.add(2, 3);&#xA;    let {stat, exists, readFile} = require(&#39;fs&#39;)&#xA;        # 加载fs所有方法生成_fs, 再取其中3个方法。没法做静态优化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;amd&#34;&gt;&#xA;  AMD&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#amd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    模块化标准&#xA;    异步加载, 预执行&#xA;使用&#xA;    require([&#39;math&#39;], functioni (math){&#xA;        math.add(2, 3);&#xA;    });&#xA;        # 加载成功后进行回调&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cmd&#34;&gt;&#xA;  CMD&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cmd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    sea.js提出&#xA;    懒执行&#xA;使用&#xA;    define(function(require, exports, module){ ... })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;词法&#34;&gt;&#xA;  词法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%8d%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;unicode编写的&#xA;    转义&#xA;        &#39;café&#39;表示为&#39;caf\u00e9&#39;&#xA;        &#39;é&#39; 也可以表示为&#39;e\u0301&#39;, e后面跟一个语调符&#xA;区分大小写                                   # html中不区分大小写&#xA;注释&#xA;    //, /**/&#xA;标识符和保留字&#xA;    要求&#xA;        开头以字母、下划线、dollar符。&#xA;        后续可以加数字&#xA;        可以出现unicode字符集中的Mn类、Mc类、Pc类，如           # Mn表示非间距字符，Mc表示影响基字符标志位的间距字符, Pc是连接两个字符的连接符或标点符号。&#xA;            é, π,&#xA;    保留字&#xA;        break, delete, function, return, typeof, case, do, if, switch, var, catch, else, in, this, void, continue, false, instanceof, throw, while, debugger, finally, new, true, with, default, for, null, try&#xA;    未被使用的名保留字&#xA;        class, const, enum, export, extends, import, super&#xA;    严格模式下的保留字&#xA;        implements, let, private, public, yield, interface, package, protected, static&#xA;    严格模式下不能用做变量名&#xA;        arguments, eval&#xA;    es6新增保留字&#xA;        await&#xA;    ECMAScript3将所有java关键字列为保留字&#xA;    全局属性和对象和函数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;直接量&#34;&gt;&#xA;  直接量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b4%e6%8e%a5%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;直接量(numeric literal)&#xA;    1&#xA;    1.2&#xA;    &amp;quot;hi&amp;quot;&#xA;    &#39;hi&#39;&#xA;    true&#xA;    false&#xA;    /javascript/gi&#xA;        # 用于模式匹配&#xA;        ## 实际是一个RegExp对象&#xA;        ## gi是用来修饰匹配模式的含义&#xA;    null&#xA;    {x:1, y:2}&#xA;        {foo}                                   # 等同 {foo: foo}, 简化写法常用于函数返回值&#xA;        {method () {}}                          # 等同 {method: function () {}}&#xA;        {*m () {}}                              # generator&#xA;        {[&#39;a&#39; + &#39;b&#39;]: 1}                        # object&#xA;        {[&#39;hello&#39;](){reutrn 0;}}                # 对象属性是Symbol值时, name属性返回这个Symbol值的描述&#xA;        {get a () {}, set a (val) {}}           # 属性getter, setter。get, set函数的函数名name是 &#39;get xxx&#39;, &#39;set xxx&#39;&#xA;    [1,2,3,4]&#xA;整型直接量&#xA;    0&#xA;    10&#xA;    0xff/0Xff                                   # 16进制&#xA;    0o377                                       # 8进制&#xA;        0377                                    # ECMAScript标准不支持八进制直接量，某些实现可以采用八进制表示&#xA;                                                # ECMAScript6严格模式下, 八进制直接量是明令禁止的&#xA;    0b11/0B11                                   # 2进制&#xA;浮点型直接量&#xA;    3.14&#xA;    .333&#xA;    6.02e23                                     # 6.02 x 10^23&#xA;    1.4E-32&#xA;字符串直接量&#xA;    ECMAScript5可多行                             # ECMAScript3规定必须一行&#xA;        &amp;quot;one\&#xA;        long line&amp;quot;&#xA;    模板字符串                                   # 保留换行，空格，缩进&#xA;        var name = &#39;Bob&#39;;&#xA;        `hello ${name}                          # ${}中可用任意表达式，包括函数&#xA;        how are you`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;可省略的分号&#xA;    通用规则: 独占一行，并与下一行不能整体解析时&#xA;        var a = f&#xA;        反例                                      # 以 (, [, /, +, - 开始的语句极可能和前一条语句一起解析，可写成 ;(a+b)&#xA;            (a+b).toString(); 就不可以&#xA;    例外规则&#xA;        return, break, continue占一行时，总加分号&#xA;        ++, -- 永远解析为前缀, 所以作后缀时要加分号   # 如　x [换行] ++ [换行] y, 解析为 x; ++y&#xA;    &#39;}&#39;之前的分号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;严格模式&#34;&gt;&#xA;  严格模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a5%e6%a0%bc%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;区别&#xA;    所有变量都要先声明&#xA;    增加了保留字(如await, protected, static, interface)&#xA;    eval, arguments当作关键字&#xA;    不允许八进制整数直接量(0前缀)&#xA;    不能给只读属性赋值，不能给不可扩展对象创建新成员&#xA;    arguments对象拥有参数的静态副本。               # 非严格模式中，都是引用，可以改变原值&#xA;    限制调用栈检测能力                              # 具有caller和arguments属性，但访问时会抛出异常&#xA;        arguments.caller, arguments.callee都会抛出类型错误异常&#xA;        fn.caller, fn.arguments禁止使用&#xA;    对象定义同名属性产生语法错误, 函数声明同名参数产生语法错误&#xA;&#xA;    禁止使用with语句&#xA;    this值在调用的函数中是undefined,                # this禁止指向全局变量&#xA;        指非属性调用，如eval()，非a.test()&#xA;    eval()代码不能创建局部变量或函数&#xA;        而是定义在eval创建的新作用域(在eval返回时弃用)中&#xA;        eval不包含外层作用域&#xA;    delete后非法标识符抛出异常&#xA;        如delete prop, 只能delete global[prop]&#xA;        delete不可配置属性抛出异常&#xA;    es5, es6中尾调用优化只在严格模式下开启             # 因为arguments.caller会跟踪函数调用栈, 无法开启&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模块化&#34;&gt;&#xA;  模块化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    es6中模块化思想是尽量静态化，编译时确定模块依赖关系与输入输出&#xA;    CommonJS(CMD)与AMD都只能在运行时确定&#xA;    UMD模式只是加了CMD和AMD的切换&#xA;es6&#xA;    特点&#xA;        import, export可以出现在顶层的任何位置&#xA;        import&#xA;            会变量提升, 会执行import的模块&#xA;            引入的变量是只读的，修改会报错。但可以修改引入变量的内部属性&#xA;            只加载3个方法，编译时加载，可能静态分析。但不能引用fs模块本身&#xA;            使引入宏(macro)和类型检查(type system)成为可能&#xA;        模块自动采用严格模式&#xA;        输出/引入的是值的只读引用, 值在运行时计算&#xA;    import&#xA;        import {stat, exists, readFile} from &#39;fs&#39;                   # 多引用&#xA;        import {a as b} from &#39;./profile&#39;                            # b 作为 a 的别名&#xA;        import &#39;lodash&#39;                                             # 只运行模块&#xA;        import * as circle from &#39;./circle&#39;                          # 引入模块到对象&#xA;            circle.area&#xA;        import a from &#39;./export-default&#39;                            # 引入模块中默认的导出, a可以起任意名，不用大括号&#xA;            import {default as xxx} from &#39;./&#39;                       # 本质是输出名字为default变量&#xA;        import def, {a} from &#39;./module&#39;                             # 同时引入default和其它变量&#xA;    export&#xA;        export var a = 1;&#xA;        export function f () {}&#xA;&#xA;        var b = 1, c = 1;&#xA;        export {b, c}                                               # 用于统一输出&#xA;&#xA;        export {v1 as sv1}&#xA;        export {a as b} from &#39;./someModule&#39;                         # 导入同时导出&#xA;        export v from &#39;mod&#39;                                         # 导入同时导出, es7提案可省略大括号&#xA;        export default function() {}                                # export default命令来配置默认导出, 本质是输出名字为default的变量，系统允许它取任意名&#xA;                                                                    # export default foo 导出的foo名在模块外部是无效&#xA;    继承&#xA;        export * from &#39;circle&#39;&#xA;        export var e = 2.7&#xA;        export default function() {}                                # 输出了circle模块的所有方法(忽略default), 又输出了自定义属性&#xA;循环引用&#xA;    CommonJS会输出已执行的部分&#xA;        写法问题&#xA;            var foo = require(&#39;a&#39;).foo&#xA;                a在别处循环引用时, 得到的foo可能是执行到一半的值&#xA;                而var a = require(&#39;a&#39;), a.foo就会得到执行完后的值&#xA;        o-&amp;gt; 例子&#xA;        a.js&#xA;            exports.done = false;&#xA;            var b = require(&#39;./b.js&#39;);&#xA;            console.log(&#39;a.js =&amp;gt; b.done : &#39;, b.done)&#xA;            exports.done = true;&#xA;            console.log(&#39;a.js done&#39;)&#xA;        b.js&#xA;            exports.doen = false;&#xA;            var a = require(&#39;./a.js&#39;)&#xA;            console.log(&#39;b.js =&amp;gt; a.done : &#39;, a.done);&#xA;            exports.done = true;&#xA;            console.log(&#39;a.js done&#39;)&#xA;            main.js&#xA;            var a = require(&#39;./a.js&#39;), b = require(&#39;./b.js&#39;)&#xA;            console.log(&#39;main.js =&amp;gt; a.done: &#39;, a.done, &#39; b.done: &#39;, b.done)&#xA;        执行&#xA;            b.js =&amp;gt; a.done: false&#xA;            b.js done&#xA;            a.js =&amp;gt; b.done: true&#xA;            a.js done&#xA;            main.js =&amp;gt; a.done: true b.done: true&#xA;&#xA;            a.js中require(&#39;./b.js&#39;)阻塞, 执行b.js&#xA;            b.js中require(&#39;./a.js&#39;), 加载已执行的a.js&#xA;            执行完b.js回到a.js, 执行完a.js&#xA;            main.js加载已执行的a.js b.js&#xA;    es6 import时不执行代码，而是引用&#xA;        o-&amp;gt; 例子                                  # CommonJS中不能执行, a加载b, b加载a, a没有输出, foo不存在, es6中可以执行&#xA;        a.js&#xA;            import {bar} from &#39;./b.js&#39;;&#xA;            export function foo() {&#xA;                bar();&#xA;                console.log(&#39;a.js done&#39;)&#xA;            }&#xA;        b.js&#xA;            import {foo} from &#39;./a.js&#39;;&#xA;            export function bar() {&#xA;                if(Math.random() &amp;gt; 0.5) {foo()}&#xA;            }&#xA;        babel-node a.js&#xA;&#xA;        o-&amp;gt; 例子&#xA;        even.js&#xA;            import {odd} from &#39;./odd&#39;&#xA;            export var counter = 0;&#xA;            export function even(n) {&#xA;                counter++;&#xA;                return n == 0 || odd(n - 1);&#xA;            }&#xA;        odd.js&#xA;            import {even} from &#39;./even&#39;;&#xA;            export function odd(n) {&#xA;                return n != 0 &amp;amp;&amp;amp; even(n - 1);&#xA;            }&#xA;        main.js&#xA;            import * as m from &#39;./even.js&#39;&#xA;            m.even(10)  // true&#xA;            m.counter    // 6                       # 10 变到 0 even执行了6次&#xA;            m.even(20)    // true                   # 20 变到 0 even执行了11次&#xA;            m.counter    // 17                      ＃es6中引用加载机制保证even, odd函数能加载，所以可执行。而CommonJS中循环引用，even和odd函数都不会加载&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类型与变量&#34;&gt;&#xA;  类型与变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b%e4%b8%8e%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;声明&#xA;    特点&#xA;        存值之前是undefined&#xA;        声明提前&#xA;        非声明变量赋值创建全局变量                     # ECMAScript 5 严格模式下未声明赋值会报错&#xA;            非声明的全局变量与声明全局变量的区别: 非声明的全局变量是可配置的(可delete)，而var声明的全局变量不可配置&#xA;        let&#xA;            支持了直接用{}的块级作用域&#xA;            只在块级作用域有效&#xA;                for(let i = 0; ...; ...)&#xA;            无变量提升&#xA;            声明前存在暂时性死区&#xA;                死区中使用该变量会直接报错&#xA;            重复声明报错&#xA;            声明的全局变量不再是全局对象的属性&#xA;                同样机制的还有const, class&#xA;        const&#xA;            只能在声明时赋值一次, 其他同let&#xA;    var x;&#xA;    x = 1;&#xA;    let a = 10&#xA;    const PI = 3.1415&#xA;        export const A = 1;&#xA;            import * as constants from &#39;./constants&#39;&#xA;            constants.A&#xA;类型&#xA;    特点&#xA;        可以拥有方法的类型, 不能拥有方法的类型&#xA;        可变(mutable)类型                           # 值可以改变, 比较(==, ===)是地址的比较&#xA;            对象&#xA;        不可变(immutable)类型                       # 比较(==, ===)是值的比较&#xA;            数字、布尔值、null、undefined、字符串     # 字符串不像c语言可以看作字符数组，js的字符串不可变&#xA;    原始值&#xA;        # 不可以拥有自己的方法&#xA;        null&#xA;        undefined&#xA;    原始类型(primitive type)                        # 可以拥有自己的方法, 原始类型都包含内置构造函数&#xA;        数字&#xA;        字符串&#xA;        布尔值&#xA;        Symbol&#xA;    对象类型(object type)或引用类型，如&#xA;        对象(object)是属性(property)的集合&#xA;            property由key/value组成&#xA;        全局对象(global object)&#xA;        数组类: Array&#xA;            内存连续保住的带编号的值的有序集合&#xA;        函数类: Function&#xA;            具有相关联的可执行代码的特殊对象&#xA;类型转换                                            # Symbol不可转换&#xA;    转换为数字                                      # 字符串允许在开始和结尾处带有空格&#xA;        false为 0&#xA;        true为 1&#xA;        &amp;quot;&amp;quot;为 0&#xA;        失败为 NaN&#xA;    转换为字符串&#xA;        -0 为&amp;quot;0&amp;quot;&#xA;        -Infinity 为&amp;quot;-Infinity&amp;quot;&#xA;        [9]为 &amp;quot;9&amp;quot;&#xA;        [&#39;a&#39;]其他数组，调用join()方法&#xA;    对象转换字符串                                    # 运算符+ == != 的处理运用这里的原理&#xA;                                                    # 日期对象有自己的重定义,valueOf与toString返回的原始值将直接使用&#xA;        toString()&#xA;        valueOf()                                   # 没有toString()方法时调用, 如果返回原始值，自动将它转换为字符串&#xA;            数组、函数、正则表达式返回对象本身&#xA;            日期类返回毫秒数&#xA;        无法得到原始值则抛出异常&#xA;    对象转换数字                                      # 运算符 - &amp;lt; 用了这里的原理&#xA;        首先尝试valueOf()                            # 如果返回原始值，自动转换为数字&#xA;        再尝试toString()                             # 自动转换为数字&#xA;        无法得到原始值则抛出异常&#xA;        例子&#xA;            数字&#xA;                []为0                                # valueOf -&amp;gt; toString -&amp;gt; &amp;quot;&amp;quot; -&amp;gt; 0&#xA;                [9]为9                               # valueOf -&amp;gt; toString -&amp;gt; &amp;quot;9&amp;quot; -&amp;gt; 9&#xA;相等性&#xA;    null == undefined&#xA;    &amp;quot;0&amp;quot; == 0&#xA;    0 == false&#xA;    &amp;quot;0&amp;quot; == false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;数字&#xA;    基础&#xA;        所有数字用二进制浮点数表示(64位, 如java中的double)&#xA;            # IEEE-754标准&#xA;            ## 整数范围 -2^53 ~ 2^53(大约900亿亿)&#xA;        实际的操作(数组索引, 位操作符)基于32位整数&#xA;        负号是一元运算符，并不是数字直接量语法的组成部分&#xA;        0与-0唯一差别&#xA;            1/zero !== 1/-0    # 正无穷大和负无穷大不等&#xA;    实数近似表示(几乎所有现代编程语言都存在, 因为都是IEEE-754标准)&#xA;        浮点数表示褛的个数为18 437 736 874 454 810 627个&#xA;        IEEE-754标准精确表示1/2, 1/8, 1/1024，但不精确表示1/10, 1/00。&#xA;            # 建议用大整数进行重要计算(如元, 角, 分各用整数表示)&#xA;            所以js只能近似表示0.1&#xA;            var x = .3 - .2&#xA;            var y = .2 - .1&#xA;            x == y        // =&amp;gt; false&#xA;            x == .1    // =&amp;gt; false&#xA;            y == .1    // =&amp;gt; true&#xA;字符串&#xA;    基础&#xA;        从0开始&#xA;        没有如c语言中的字符型&#xA;        采用UTF-16编码的Unicode字符集。&#xA;            是一组无符号16位值组成的序列。&#xA;                # 用16位内码表示, 表示一个单个字符&#xA;                ## 不能16位Unicode表示的遵循UTF-16编码规则，两个16位值来表示一个(代理项对)&#xA;                ### 长度为2的字符串可能表示一个Unicode字符,如var e =&amp;quot;\ud835\udc52&amp;quot;; e.length // =&amp;gt; 2&#xA;            字符串的操作不对代理项对单独处理&#xA;            不对字符串做标准代加工&#xA;                所以不能保证字符串是剑的UTF-16格式&#xA;    运算&#xA;        +            # 字符串连接&#xA;    unicode&#xA;        允许采用\uxxxx表示\u0000 到 \uFFFF之间的字符&#xA;        超出范围时用4字节表示, 如 \uD842\uDFB7&#xA;        &#39;\u20BB7&#39; 会被解释成 &#39;\u20BB&#39; + &#39;7&#39;&#xA;        &#39;\u{20BB7}&#39; 会正确解释&#xA;        多种表示法&#xA;            &#39;\z&#39;&#xA;            &#39;\172&#39;&#xA;            &#39;\x7A&#39;&#xA;            &#39;\u007A&#39;&#xA;            &#39;\u{7A}&#39;&#xA;    转义&#xA;        十六进制数表示Latin-1或Unicode中的任意字码, 由两位十六进制数指定&#xA;            &#39;\xA9&#39;        // =&amp;gt; ©&#xA;        \u表示4个十六进制数指定的Unicode字符&#xA;            &#39;\u03c0&#39;    // =&amp;gt;&#xA;        \n&#xA;        \&#39;&#xA;        \0            # 同\u0000, 表示空字符串&#xA;        \b            # 同\u0008, 表示退格符&#xA;        \t            # 同\u0009, 表示tab&#xA;        \v            # \u000B, 垂直制表符&#xA;        \f            # \u000C, 换页符&#xA;        \r            # \u000D, 回车&#xA;布尔&#xA;    转换&#xA;        # 所有值都可以转换为布尔值&#xA;        false&#xA;            undefined&#xA;            null&#xA;            0&#xA;            -0&#xA;            NaN&#xA;            &amp;quot;&amp;quot;&#xA;        true&#xA;            除以上，全部为true&#xA;    api&#xA;        toString()                              # 转换成&amp;quot;true&amp;quot;或&amp;quot;false&amp;quot;&#xA;null undefined&#xA;    类型&#xA;        null为object                            # 但可以表示数字类型、字符串类型&#xA;        undefined为&amp;quot;undefined&amp;quot;, 是一个单独类型&#xA;    比较&#xA;        null == undefined        // =&amp;gt; true&#xA;        null === undefined        // =&amp;gt; false&#xA;    无api                                       # .和[]取成员会产生类型错误&#xA;    bug&#xA;        undefined在ECMAScript可读/写，可赋任意值&#xA;    结论&#xA;        undefined表示系统级类似错误的空缺&#xA;        null表示程序级的，正常出现的空缺&#xA;&#xA;Symbol&#xA;    介绍&#xA;        原始数据类型，因为不是对象，所以不能new, 不能添加属性&#xA;        不参与类型转换, 但可以toString            # 可以String(s)得到 &#39;Symbol(a)&#39;, Boolean(s)得到true, !s 得到false。Number(s)会报错&#xA;        可以做属性名a[sym1] = 1, 不能用点运算符赋值或取值&#xA;        常用于设置常量结构体来switch，以消除魔术字符串&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;作用域&#34;&gt;&#xA;  作用域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%9c%e7%94%a8%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局变量&#xA;    就是定义顶级对象的属性                         # 这点在ECMAScript规范中强制规定&#xA;    在js代码任何地方都有定义&#xA;局部变量&#xA;    在函数内有定义，优先于全局变量&#xA;与c语言区别(嵌套作用域)&#xA;    c中{}内产生块级作用域(block scope), 其中变量其外不可见&#xA;    js中没有块级作用域，是函数作用域(function scope), 变量在内部嵌套函数中有定义。&#xA;声明提前&#xA;    内部嵌套函数而言, 变量声明之前就可用, 称为声明提前(hoisting)         # hoisting js函数里声明的所有变量(不赋值), 被&amp;quot;提前&amp;quot;到函数体顶部，在js引擎预编译时进行。&#xA;    例子&#xA;        var scope = &amp;quot;global&amp;quot;&#xA;        function f(){&#xA;            console.log(scope)                  # undefined, 因为局部scope声明提前，覆盖了全局scope, 而声明提前不定义, 定义在执行代码时进行&#xA;            var scope = &amp;quot;local&amp;quot;                 # 等价于开头var scope;&#xA;            console.log(scope)&#xA;        }&#xA;特点&#xA;    js本身设计中没有构造函数，普通函数，对象方法，闭包。这些都是莫须有的叫法&#xA;    内部函数可以访问外部函数上下文&#xA;    非严格格式直接声明变量，挂到global上&#xA;    作用域在函数中定义, 非块定义, 所以&#xA;        for(var i = 0; i &amp;lt; 10; i++){            # 中定义的i与value，在for之外可以被访问, 且声明提前&#xA;            var value = &#39;hello&#39;;&#xA;        }&#xA;this&#xA;    有调用对象就指向调用对象&#xA;    没调用对象指向全局对象&#xA;        O.a = function(){&#xA;            var b = function(){                 # b中的this永远是全局对象&#xA;                console.log(this);&#xA;            };&#xA;            b();&#xA;        };&#xA;        O.a()&#xA;    new 构造时this指向新对象&#xA;        var O = function(){this.val = 100;}&#xA;        var o = new O();&#xA;        console.log(o.val);                     # 这里输出o.val而不是O.val&#xA;    用apply或call或bind方法改变this指向&#xA;        function tt(){&#xA;            console.log(arguments.callee);      # 永远是tt本身&#xA;            console.log(this);                  # 都是下面定义的a&#xA;        }&#xA;        var a = &#39;1&#39;;&#xA;        tt.call(a, 1, 2);&#xA;        tt.apply(a, [1, 2]);&#xA;        var att = tt.bind(a);&#xA;        att();&#xA;参数调用时，会扩展作用域，如&#xA;    f(a.b)()                                    # a挂到f的作用域&#xA;    var f = function(c){}&#xA;作用域链(scope chain)&#xA;    特点&#xA;        每一段js代码有关联的作用域链&#xA;        一个对象链表，定义这段代码的作用域&#xA;        变量解析(variable resolution)时，从链第一个开始查找到最后一个   # 查找不存在时抛出引用错误(ReferenceError)&#xA;    原理&#xA;        定义一个函数时，实际上保存一个作用域链&#xA;        调用该函数时，创建新对象放局部变量，添加到保存的作用域链&#xA;        同时，创建一个新的、更长的&amp;quot;函数调用作用域链&amp;quot;&#xA;        该函数每次调用外部函数时，嵌套函数重定义&#xA;    代码作用域链分类&#xA;        顶层代码&#xA;            顶级对象属性&#xA;        无嵌套函数体&#xA;            var定义的局部变量&#xA;            顶级对象属性&#xA;        嵌套函数体&#xA;            var定义的局部变量&#xA;            顶级对象属性&#xA;            函数调用作用域&amp;quot;链&amp;quot;&#xA;    注意&#xA;        函数创建时，它的作用域链中会填入全局对象&#xA;        执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象&#xA;            运行期上下文定义了函数执行时的环境&#xA;            每个运行期上下文都有自己的作用域链&#xA;            其作用域链初始化为当前运行函数的Scope所包含的对象。&#xA;        函数中的值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中&#xA;            它们共同组成了一个新的对象，叫“活动对象(activation object)”&#xA;            该对象包含了函数的所有局部变量、命名参数、参数集合以及this&#xA;            此对象会被推入作用域链的前端&#xA;            运行期上下文被销毁，活动对象也随之销毁&#xA;        在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。&#xA;            该过程从作用域链头部，也就是从活动对象开始搜索&#xA;            如果没找到继续搜索作用域链中的下一个对象&#xA;            如果搜索完所有对象都未找到，则认为该标识符未定义&#xA;        作用域链只会被 with 语句和 catch 语句影响。&#xA;    优化代码：&#xA;        因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。&#xA;            所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量&#xA;            一个好的经验法则是, 如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用&#xA;        优化with&#xA;            with(o){&#xA;            }&#xA;            使用with语句来避免多次书写document，看上去更高效，实际上产生了性能问题。&#xA;                代码运行到with语句时，运行期上下文的作用域链临时被改变了&#xA;                一个新的可变对象被创建，它包含了参数指定的对象的所有属性, 这个对象将被推入作用域链的头部&#xA;                这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。&#xA;        优化try-catch&#xA;            try{&#xA;                doSomething();&#xA;            }catch(ex){&#xA;                alert(ex.message);              # 作用域链在此处改变。同理，catch语句使效率下降&#xA;&#xA;            try{&#xA;                doSomething();&#xA;            }catch(ex){&#xA;                handleError(ex);                # 委托给处理器方法, 没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。&#xA;            }                                   # 优化后的代码，handleError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;表达式&#34;&gt;&#xA;  表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    表达式(expression), 由解释器计算(evaluate)&#xA;原始表达式(primary expression)&#xA;    常量&#xA;    直接量&#xA;    关键字&#xA;        true, false, null, this&#xA;    变量名&#xA;对象和数组初始化表达式                             # 对象直接量、数组直接量&#xA;    {}&#xA;    []&#xA;函数定义表达式                                    # 函数直接量&#xA;    var square = function(x){reutrn x*x}&#xA;属性访问表达式                                    # 其前面的表达式首先计算, null, undefined会抛出类型错误异常，因为它们不能包含属性&#xA;    .&#xA;    [1]&#xA;    [&amp;quot;a&amp;quot;]&#xA;调用表达式(invocation expression)&#xA;    顺序&#xA;        首先计算函数表达式，再计算参数表达式&#xA;        传入实参的值赋值给形参&#xA;        执行函数体&#xA;        return返回值给变量名，无return 函数名赋为undefined&#xA;    左边是属性访问表达式时，称作方法调用(method invocation)&#xA;        函数体的this是宿主对象(执行者)&#xA;        非方法调用时，this是顶级对象&#xA;            ECMAScript 5中非方法调用时, this是undefined&#xA;    f(0)                                        # 非方法调用&#xA;    Math.max(x, y, z)                           # 静态方法调用, this为Math类&#xA;    a.sort()                                    # 动态方法调用, this为a实例&#xA;对象创建表达式(object creation expression)&#xA;    特点&#xA;        创建一个对象并调用构造函数&#xA;        与调用表达式相似&#xA;    过程&#xA;        创建空对象，该对象作为构造函数的this，可用来初始化动态属性&#xA;        传入指定参数，执行构造函数。&#xA;        返回值以构造函数返回值优先(本次对象废弃)，没有时则返回本次创建的对象&#xA;    new Point(2, 3)&#xA;    new Object()&#xA;    new Object                                  # 不传参时, ()可以省略&#xA;关系表达式&#xA;    ==&#xA;    &amp;lt;&#xA;    in&#xA;    instanceof&#xA;逻辑表达式&#xA;    !&#xA;    &amp;amp;&amp;amp;&#xA;    ||&#xA;赋值表达式&#xA;    (a=b) == 0&#xA;    i = j = k = 0;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;运算符&#34;&gt;&#xA;  运算符&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e7%ae%97%e7%ac%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    可符号，可关键字&#xA;    一元、二元、三元运算符                         # - +(正负号)是一元，*是二元, ?!是三元&#xA;    期望与转型&#xA;        &amp;quot;3&amp;quot; * &amp;quot;5&amp;quot;                               # 期望数字, 自动转型&#xA;        对类型依赖&#xA;            +                                   # 数字则运算，字符串则拼接&#xA;            &amp;lt;                                   # 数字则比较, 字符则比较字符表次序&#xA;    左值(lvalue)&#xA;        表达式只能出现在赋值运算(=)的左侧&#xA;            &amp;amp;, ++等操作符的操作数&#xA;            内存栈中的变量名&#xA;                变量、对象属性、数组元素&#xA;        内置函数可返回左值，自定义函数不可以&#xA;    优先级&#xA;    左右结合性&#xA;    运算顺序&#xA;        总是严格从左到右计算表达式&#xA;        表达式会影响变量值(如++, --, delete)时，先执行&#xA;            b = (a++)+a                         # 计算b, 计算a++(返回的结果是1), 计算右边的a(结果是2), 计算等号右边(1 + 2), 赋值&#xA;关键字运算符&#xA;    delete, typeof, instanceof, in, void&#xA;    in运算符                                     # 判断是否存在属性, 左是字符串, 右是对象&#xA;        &#39;toString&#39; in obj&#xA;        for( var i in ojb)&#xA;    instanceof运算符                             # 判断是否实例, 会判断父类, (prototype chain)&#xA;        o instanceof f                          # 遍历原型链, 计算f.prototype, 然后在o原型链中查找f, 找到则返回true&#xA;    typeof 运算符                                # 返回一个对象的类型描述字符串&#xA;        typeof value == &amp;quot;string&amp;quot; ? &amp;quot;&#39;&amp;quot; + value + &amp;quot;&#39;&amp;quot; : value&#xA;        typeof(value)                           # 可以写作函数的形式&#xA;        返回值&#xA;            &amp;quot;undefined&amp;quot;, &amp;quot;object&amp;quot;, &amp;quot;boolean&amp;quot;, &amp;quot;number&amp;quot;, &amp;quot;string&amp;quot;, &amp;quot;function&amp;quot;&#xA;            null, 对象和数组 返回&amp;quot;object&amp;quot;         # 函数是对象的一种，但typeof特殊对待。&#xA;                                                # instanceof, class特性, constructor属性&#xA;    delete运算符                                 # 严格模式下删除失败会报错&#xA;        删除属性, 成功则返回true&#xA;        内置核心客户端属性不能删除&#xA;        var语句声明的变量不能删除&#xA;        function定义的函数和其参数不能删除&#xA;    void运算符&#xA;        写在操作数前，操作数照常计算, 但返回undefined&#xA;            &amp;lt;a href=&amp;quot;javascript:void window.open();&amp;quot;&amp;gt;               # 使浏览器不必显示计算结果&#xA;普通一元(目)运算符&#xA;    +                                           # 这里+, -表示正负号, +, -会把变量自动转型为数字&#xA;    -&#xA;    ++                                          # ++, -- 作为前增量时, 返回计算后的值，后增量时，返回计算前的值。与c语言不一样，c语言的前后增量作用于整个表达式s&#xA;    --&#xA;普通二元(目)运算符&#xA;    特点&#xA;        必要时转换数字&#xA;        js中数字都是浮点数, 所以5/2 = 2.5&#xA;        左结合&#xA;        根据类型进行数字相加或字符串连接&#xA;        对象先尝试转换数字(Date除外，先转换字符串)&#xA;            如果存在字符串，则拼接(不论字符串值是否数字)&#xA;            都为非字符串，则转换数字计算，失败返回NaN&#xA;    -&#xA;    *&#xA;    /&#xA;    %&#xA;    **                                          # **是指数运算符&#xA;    +&#xA;三元(目)运算符&#xA;    ?:                                          # 条件运算符, 唯一三元运算符&#xA;位运算符(对操作数每位布尔运算)&#xA;    特点&#xA;        要求操作数是整数(32位整形而非64位浮点型)&#xA;        会自动强制转换&#xA;        NaN, Infinity, -Infinity转换为0&#xA;    &amp;amp;                                           # 按位与&#xA;        0x1234 &amp;amp; 0x00FF = 0x0034&#xA;    |                                           # 按位或&#xA;        0x1234 | 0x00FF = 0x12FF&#xA;    ^                                           # 按位异或&#xA;        0xFF00 ^ oxF0F0 = 0x0FF0&#xA;    ~                                           # 按位非&#xA;        ~0x0f = 0xFFFFFFF0或 -16&#xA;    &amp;lt;&amp;lt;                                          # 左移&#xA;        7&amp;lt;&amp;lt;2 = 28&#xA;                                                # 移动倍数是0~31的整数，用0补&#xA;    &amp;gt;&amp;gt;                                          # 左边高位 正数填0, 负数填1&#xA;        7&amp;gt;&amp;gt;1 = 3&#xA;        -7&amp;gt;&amp;gt;1 = -4&#xA;    &amp;gt;&amp;gt;&amp;gt;                                         # 无符号右移，左边高位总填0&#xA;相等不等运算符&#xA;    ==(equality operator), ===(严格相等(strict equality)或恒等(identity operator))&#xA;        ==                                      # 数字和字符串原始类型也是地址的相等(恒等)&#xA;            null == undefined&#xA;            数字==字符串, 字符串转换为数字比较, true转换成1比较&#xA;            &amp;quot;1&amp;quot;==true    # 同时转换为数字比较&#xA;            对象根据另一个值的类型转换&#xA;        === 与 ==&#xA;            不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等&#xA;    !=, !==是==, ===的求反&#xA;比较运算符&#xA;    &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=                                # 存在NaN则返回false, &amp;lt;=只是简单的不大于，&amp;gt;=相反。不进行==比较&#xA;        0 == -0&#xA;        Infinity最大(除了本身)&#xA;        -Infinity最小(除了本身)&#xA;    转换&#xA;        对象转换为数字&#xA;        同为字符串，字母表顺序比较(16位unicode字符索引顺序)&#xA;        存在不为字符串，转换数字&#xA;逻辑运算符&#xA;    ! &amp;amp;&amp;amp; ||                                     # !会隐式转换为布尔类型, &amp;amp;&amp;amp;比||优先级要高, !优先级最高&#xA;    隔断性&#xA;        (a == b) &amp;amp;&amp;amp; stop()                      # 同if(a == b) stop();&#xA;        var max = a || b || 0;                  # 常用。层层按优先级判断，给max赋值, 用来给可能未传入的参数赋默认值&#xA;赋值运算符&#xA;    =&#xA;    带操作的赋值运算符&#xA;        +=, -=, *=, /=, %/, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;gt;&amp;gt;&amp;gt;=, &amp;amp;=, |=, ^=, **=&#xA;    注意&#xA;        data[i++] *=2&#xA;        data[i++] = data[i++] * 2               # 以上不相同&#xA;逗号运算符                                       # 计算左边表达式并忽略结果, 连接多上表达式成为一个表达式&#xA;    i=0, j=1, k=2                               # 计算结果是2&#xA;    for(var i=0, j=10; i &amp;lt; j;j--)&#xA;扩展(spread)运算符                               # 展开具有[Symbol.iterator]接口的可遍历对象，所以可以展开字符串, Map, Set, Generator&#xA;                                                # 内部使用for of, 支持4字节字符&#xA;    [1, 2, ...arguments]                        # 展开成新数组, 等于[1, 2].concat(arguments)&#xA;    [a, ...rest] = [1, 2, 3]                    # 模式匹配给rest赋值, 只能放在最后&#xA;    array.push(1, ...items, 2)                  # 函数调用&#xA;函数绑定运算符                                    # 返回原对象, 可以链式调用a::b::c, 把b, c都绑定到a&#xA;    foo::bar                                    # bar.bind(foo)&#xA;    ::obj.foo                                   # obj.foo.bind(obj)&#xA;优先级&#xA;    优先级(js权威指南六版66页)&#xA;算术运算&#xA;    不报错&#xA;        溢出(overflow), 下溢(underflow), 被零整除&#xA;        overflow&#xA;            超过表示的数字上限, 得到Infinity或-Infinity&#xA;        underflow&#xA;            比最小值还小, 返回0或负0, 负0几乎和0一样, 很少用到&#xA;        除零&#xA;            返回无穷大或负无穷大&#xA;    返回NaN&#xA;        零除以零&#xA;        无穷除以无穷&#xA;        负数开方&#xA;        无法转换为数字&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;eval&#34;&gt;&#xA;  eval&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eval&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    计算由源代码组成的字符串, 用eval(&amp;quot;&amp;quot;)来运行&#xA;    eval()是一个函数，但设计上更像运算符。&#xA;        限制eval()函数使它更像运算符&#xA;eval()&#xA;    一个参数，如果不传入字符串，则直接返回传入的参数。&#xA;        传入字符串, 则编译该字符串&#xA;            失败则抛出语法错误异常(SyntaxError)，成功则开始执行这段代码&#xA;            执行成功，返回字符串中最后一个语句的值。最后语句没有值，返回undefined&#xA;            执行中抛出异常, 该异常将调用传递给eval()[?]&#xA;    eval的作用域是当前作用域, 如eval(&amp;quot;var y = 3;&amp;quot;)&#xA;    用eval向函数中粘贴代码片段是无意义的，如&#xA;        var foo = function(a){eval(a)};&#xA;        foo(&amp;quot;return;&amp;quot;);                                             # 执行eval(a)的上下文是全局的, 会抛出return not in function错误&#xA;    eval作为单独脚本，如eval(&amp;quot; y = 1;&amp;quot;)是有意义的&#xA;问题&#xA;    eval()中的代码，解释器不能分析和优化&#xA;        eval()可以改变局部变量，对优化是很大的问题&#xA;    eval()的函数名可以被赋予其他名字(与运算符的区别)&#xA;        var f = eval;&#xA;        var g = f;&#xA;        这样解释器无法优化任何调用g()的函数&#xA;            所以ECMAScript规定不可以对eval()赋予别名，会抛出EvalError异常&#xA;            实际上，大多数实现并不这么做。别名调用时, 会当作顶层全局代码来执行&#xA;            这样不会修改局部变量的值，不影响优化&#xA;    ECMAScript 5规定&#xA;        直接eval(direct eval), 总是在调用它的上下文作用域执行&#xA;        间接调用(指别名调用)则作为顶层代码执行，不能读、写、定义局部变量   # 间接eval是有用的特性，允许在局部作用域执行上下文无依赖的脚本&#xA;    ie9之前的不同&#xA;        别名调用eval()是局部调用&#xA;        用execScript()来全局eval调用                                  # 与eval不同在于总是返回null&#xA;    ECMAScript 5 严格模式&#xA;        eval作为保留字, 不能用别名覆盖(更像运算符)&#xA;        eval中的字符串以&amp;quot;use strict&amp;quot;指令开始&#xA;        可以使用和更改局部变量，不可以定义新的变量&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;语句&#34;&gt;&#xA;  语句&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    语句以分号结束&#xA;    表达式计算出值，语句来执行。&#xA;        有副作用的表达式也会执行，叫作表达式语句(expression statement)&#xA;        声明语句(declaration statement), 来声明新变量或定义新函数&#xA;    js解释器依照语句编写顺序执行&#xA;        控制结构(control structure)改变顺序&#xA;            条件conditional&#xA;                switch&#xA;            循环loop&#xA;                while, for&#xA;            跳转jump&#xA;                break, return, throw&#xA;表达式语句&#xA;    赋值语句，如 greeting = &amp;quot;Hello&amp;quot; + name;&#xA;    ++, --&#xA;    delete&#xA;    函数调用，如 alert(greeting);                 # Math.cos(x)不是表达式语句，它没有对浏览器造成影响&#xA;复合语句和空语句&#xA;    {}括起来当作单独语句&#xA;        内部语句必须分号&#xA;        内部声明的变量作用域在外部(es6之前)&#xA;        如&#xA;            {&#xA;                x = Math.PI;&#xA;                cx = Math.cos(x);&#xA;            }&#xA;    空语句&#xA;        ;&#xA;        如&#xA;            if(){....}&#xA;            if();&#xA;块作用域(es6之后)                                 # 内部使用严格模式&#xA;    {&#xA;    }&#xA;声明语句&#xA;    特点&#xA;        声明语句创建的变量无法删除，但不是只读的，可以重写&#xA;        函数声明常出现在代码最顶层&#xA;        函数声明并没有归类为真正的语句&#xA;        函数声明不能出现在if, while等语句中&#xA;    var, function&#xA;    如&#xA;        var f = function(){}                    # 变量名指向函数对象，声明提前。初始化要在执行到时进行, 不可以在代码之前调用&#xA;        function f(){}                          # 函数声明和定义均提前，可以在代码之前调用&#xA;条件语句&#xA;    if(expression1) statement1&#xA;        else if(expression2) statement2&#xA;        else statement3&#xA;    switch(expression){ statements}&#xA;        特点&#xA;            不重复计算表达式&#xA;            无break向下执行，如c语言&#xA;            ECMAScript规定case可跟随任意表达式&#xA;                case是恒等比较, 所以不会作类型转换&#xA;                case是运行时(run-time)计算的, 灵活但效率低。&#xA;                c, c++, java中case是编译时(compile-time)常量&#xA;            编译时常量形成跳转表(jump table), 执行非常高效&#xA;            避免使用函数表达式和赋值表达式，建议常量表达式&#xA;            default标签可以在switch语句内的任何地方&#xA;        switch(typeof x){&#xA;            case &#39;number&#39;: break;&#xA;            default: break;&#xA;        }&#xA;    while(expression) statement&#xA;    do statement while(expression);             # 代码至少执行一次&#xA;    for(initialize; test; increment) statement                      # for(;;)比while(true)高效&#xA;    for(variable in object)                     # 遍历对象属性成员, 遍历出的数组key(如0, 1, 2)是字符串&#xA;        for(a[i++] in o)&#xA;        for(i in [1,2,3])&#xA;        原理&#xA;            计算object表达式&#xA;                为null或undefined 则跳过         # ECMAScript3的实现可能会抛出一个类型错误异常&#xA;                为原始值, 则包装对象&#xA;                否则就一定是对象，枚举对象属性(或数组索引)&#xA;                    只有可枚举(enumerable)属性才会遍历到&#xA;                        代码中所有属性和方法可枚举&#xA;                        ECMAScript 5可以特殊手段变为不可枚举&#xA;                        js语言核心定义的内置方法不可枚举(nonenumerable)，如toString()&#xA;                        很多内置属性不可枚举&#xA;                        继承的自定义属性也可以枚举出来&#xA;                    prototype上有多个原型(原型链上多个对象), 每个都遍历&#xA;                    for/in中提前删除的未枚举属性不会枚举到&#xA;                        定义的新属性不会枚举到(有些实现是可以枚举到的)&#xA;                    每次循环计算variable表达式的值，以它为左值赋值&#xA;        顺序&#xA;            通常实现按照定义先后顺序&#xA;            原型链多继承对象有特定顺序&#xA;            数组依照数字顺序                    # 不是全部实现, 索引非数字或不连续时，按照特定顺序&#xA;    for(let c of s)                           # 会正确识别4字节字符&#xA;跳转语句(jump statement)&#xA;    break, continue, return, throw            # throw是复杂的跳转语句，跳转到最近闭合异常处理程序, 处理程序可以在同函数中或高层调用栈中&#xA;标签语句&#xA;    identifier: statement&#xA;        identifier不能是保留字。与变量或函数命名空间不同，可以使用同一个标识符作标签和函数名&#xA;        外层语句标签不能和它内部的重名。不嵌套下是可重名的&#xA;        break, continue是唯一可以使用语句标签的语句&#xA;    mainloop: while(token != null){&#xA;        continue mainloop;&#xA;        // break mainloop;&#xA;    }&#xA;break语句&#xA;    特点&#xA;        break后面无内容自动补分号&#xA;        不可以跳出函数边界，只在一个函数中起作用&#xA;        for中不会计算自增表达式, 直接退出&#xA;    break;&#xA;    break labelname;&#xA;continue语句&#xA;    特点&#xA;        continue后面无内容自动补分号&#xA;        while中跳到开头检测expression, do/while跳到结尾&#xA;        for中先计算自增表达式，再检测expression, for/in中遍历下一个属性名，赋给变量&#xA;    continue;&#xA;    continue labelname;&#xA;return语句&#xA;    特点&#xA;        return后面无内容自动补分号&#xA;        函数调用是表达式，return返回函数表达式的值并跳过后续结果。无return时, 函数表达式结果为undefined&#xA;        只在函数中出现&#xA;throw语句&#xA;    特点&#xA;        js解释器立即停止当前执行的逻辑，并跳转到就近异常处理程序&#xA;        try/catch/finally语句的catch编写异常处理程序&#xA;        没有异常处理程序, js把异常当作程序错误处理，报告给用户&#xA;    throw expression;&#xA;    throw new Error(&#39;x不能是负数&#39;);              # Error对象, name属性表示错误类型, message属性存放传递给构造函数的错误信息&#xA;try/catch/finally语句                           # catch可选, finally可选, try finally一起, finally用于清理代码&#xA;    finally中常写的逻辑                          # finally中return, continue, break, throw跳转，忽略已有返回值或异常，以finally中的为准&#xA;        o-&amp;gt; 正常终止, 收尾语句&#xA;        o-&amp;gt; break, continue或return终止&#xA;        o-&amp;gt; 抛出异常，被catch捕获。抛出异常未被捕获, 继续向上传播&#xA;    模拟for(initialize; test; increment)body;&#xA;    initialize;&#xA;    while(test){&#xA;        try{body;}                              # body中有break时, 这里相比for循环有一次额外的自增运算, 所以while不能完全模拟for&#xA;        finally{increment;}&#xA;    }&#xA;with语句&#xA;    with(object) statement&#xA;    with语句用于临时扩展作用域链, 将对象添加到作用域链的头部&#xA;    with下创建未声明变量不会添加到with对应对象作属性，而是和平时一样&#xA;        with执行完后把作用域链恢复到原始状态&#xA;        作用域链(scope chain)&#xA;            按序检索的对象列表, 通过它进行变量名解析&#xA;        严格模式下禁止使用with语句。非严格模式不擒获with, 因为运行慢且非常难于优化&#xA;            对象嵌套层很深时使用with来简化代码编写&#xA;debugger语句&#xA;    debugger;                                   # 产生一个断点(breakpoint)，在解释器调试模式运行时使用&#xA;                                                # ECMAScript 5中加入的debugger语句。但从前主流浏览器已经实现了&#xA;&amp;quot;use strict&amp;quot;指令&#xA;    只出现在代码或函数体的开始或eval()中。其前可以有其字符串直接量表达式语句&#xA;        解释器可能将&amp;quot;use strict&amp;quot;之前的字符串和它都解释成解释器自有的指令&#xA;        直到第一条常规语句出现之后, 字符串直接量就只当作普通表达式语句对待&#xA;    表示其后的代码将会解析为严格代码&#xA;        函数和eval()只作用到自身&#xA;    ECMAScript 5引入的指令。可以使用单引号。对于没有实现ECMAScript 5的解释器来说，它什么也不做(没有副作用)&#xA;        将来ECMAScript希望用use做关键字&#xA;tag函数                                         # 用于过滤html字符串, 嵌入其他语言执行或filter出特定的值&#xA;    tag`hello ${1} world ${2}`&#xA;    function tag(strArr, ...values){}           # [&#39;hello &#39;, &#39; world &#39;, &#39;&#39;] , 1, 2&#xA;数组推导                                        # 支持iterator接口, 即也支持字符串。惰性求值, 可以替代filter方法&#xA;    var a1 = [1, 2, 3]&#xA;    var a2 = [for (i of a1) i * 2]&#xA;    var a3 = [for (i of a1) if(i &amp;lt; 3) i]&#xA;    var b1 = [1, 2]&#xA;    var b2 = [&#39;a&#39;, &#39;b&#39;]&#xA;    [for (s of b1) for (w of b2) s+w]    // [&#39;1a&#39;, &#39;1b&#39;, &#39;2a&#39;, &#39;2b&#39;]&#xA;    let c = (for (n of generator()) n * n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;模式匹配&#34;&gt;&#xA;  模式匹配&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    模式匹配只对自身属性起作用&#xA;&#xA;数组&#xA;    let [foo, [[bar], baz]] = [1, [[2], 3]]     # var, const同样适用&#xA;    let [,, third] = [1, 2, 3]&#xA;    let [head, ...tail] = [1, 2, 3]&#xA;    let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])    # 只要有Iterator接口，都可以匹配&#xA;&#xA;    var [foo = true] = []                       # 设置默认值，在值严格等于undefined时生效&#xA;        var [x = 1] = [undefined]&#xA;            x = 1&#xA;        var [x = 1] = [null]&#xA;            x = null&#xA;        let [x = f()] = [1]                     # 惰性求值&#xA;        let [x = y, y = 1]                      # 报错, y 未声明&#xA;&#xA;对象&#xA;    var {bar, foo} = {foo: &#39;a&#39;, bar: &#39;b&#39;};&#xA;    var {foo: baz} = {foo: &#39;a&#39;};                # baz = &#39;a&#39;&#xA;    var {p: [x, {y}]} = {p: [&#39;a&#39;, {&#39;b&#39;}]}       # 这里p是模式，不是变量，所以不声明或赋值&#xA;    let obj = {}, arr = [];&#xA;    ({foo: obj.prop, bar: arr[0]} = {foo: 1, bar: 0});              # 嵌套值, 不加()时{}会被解释成代码块&#xA;    var {x = 3} = {};&#xA;    let {log, sin, cos} = Math                  # 将对象的方法赋值到变量&#xA;    let n = {...{a: 3, b: 4}}                   # {a: 3, b: 4}, 扩展null, undefined会被忽略, 被扩展对象中的getter会执行&#xA;        let n = {x: 1, ...a}                    # a中的x属性会被覆盖掉, 原理同Object.assign&#xA;        let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4}                 # x // 1, y // 2, z // {a: 3, b: 4}, z 是引用&#xA;基本类型&#xA;    const [a, b] = &#39;hello&#39;&#xA;    let {toString: s} = 123                     # 如果右边不是对象，先包装, null 和 undefined不能匹配&#xA;        # let {toString: s} = true&#xA;&#xA;函数&#xA;    function add([x, y]){}&#xA;    add([1, 2])&#xA;    function move({x = 0, y = 0} = {})          # function move({x, y} = {x: 0, y: 0}) 是错误的&#xA;&#xA;圆括号&#xA;    [(b)] = [3]&#xA;    ({p: (d)} = {})&#xA;    [(parseInt.prop)] = [3]                     # 只有非声明语句的非模式部分可以用圆括号&#xA;&#xA;用途&#xA;    [x, y] = [y, x]                             # 交换值&#xA;    function f(){return [1, 2]}&#xA;    var [a, b] = f();&#xA;    function f(){return {foo: 1, bar: 2}}&#xA;    var {foo, bar} = f();                       # 函数返回多个值&#xA;    function f([x, y]){}&#xA;    f([1, 2])&#xA;    function f({x, y, z = 3}){}&#xA;    f({y: 2, x: 1})                             # 参数定义&#xA;    let {id} = {id: 42, status: &#39;ok&#39;}           # json匹配&#xA;    var map = new Map(); map.set(&#39;a&#39;, 1)&#xA;    for(let [, val] of map){}                   # 遍历map&#xA;    const {SourceMapConsumer, SourceNode} = require(&#39;source-map&#39;)   # 输入模块方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    js的函数是参数化的&#xA;        在js中，函数即对象，可以随意传递，可以设置属性和调用该函数的函数&#xA;        在js中，函数可以嵌套定义, 嵌套的函数可以访问被定义所处作域中的变量，这个作用域就是闭包(closure)&#xA;        函数是对象，但typeof经过处理，所以返回&amp;quot;function&amp;quot;, 可以拥有静态属性和方法，可以用内部构造函数Function()创建&#xA;    形参 标识符列表(函数中定义的变量)，调用时为其提供实参值。&#xA;    初始化对象的函数是构造函数&#xA;    return停止函数执行并返回它的表达式。没有表达式时返回undefined。没有return语句时返回undefined&#xA;    this是关键字，不是变量或属性名，所以不允许赋值。&#xA;        this没有作用域限制&#xA;    将函数绑定到Function.prototype上，以便所有函数对象都继承它&#xA;关键字&#xA;    this&#xA;        除实参外，每次调用拥有一个调用上下文 this&#xA;        对象调用函数时, 此次调用上下文是该对象。&#xA;    super&#xA;        super()调用父类的构造方法, super相当与父类的实例，super同时部署了父类的静态属性&#xA;        对象总是继承其他对象，所以在任意对象中，都可以使用super, 如&#xA;            var obj = {toString() {return &#39;a &#39; + super.toString() }}&#xA;    new.target&#xA;        构造函数中使用, 返回调用该构造函数时new 命令作用的对象&#xA;        如果直接调用等, 则值为undefined&#xA;        function Person() {new.target === Person}&#xA;        class {constructor() {new.target}}                          # 子类继承父类调用super()时, 父类构造方法中new.target指向子类, 可以利用写出不能继承的类&#xA;定义                                              # 函数名通常是动词或以动词为前缀的词组，常用的写短&#xA;    function a(){}&#xA;        声明和定义均提前&#xA;        ECMA只允许它作为顶级语句，不能出现在循环、条件判断或者try/cache/finally及with语句中&#xA;            一些js实现并未严格遵守规则，比如firefox就可以在if中出现函数声明&#xA;    var a = function(){}&#xA;        只声明提前。可作匿名函数&#xA;        此为函数定义表达式, 可以出现在js代码的任何地方&#xA;    o.m = f&#xA;        给已有对象的属性引用方法&#xA;创建函数&#xA;    function fun(){}&#xA;    var fun = function {}&#xA;    var fun = new Function(&amp;quot;输入变量1&amp;quot;,&amp;quot;输入变量2&amp;quot;,&amp;quot;执行内容&amp;quot;);        # 动态创建函数&#xA;&#xA;    var f = (a, b) =&amp;gt; a + b&#xA;    var f = n =&amp;gt; n&#xA;    var f = () =&amp;gt; {return 1}&#xA;    var f = () =&amp;gt; ({a: 1})&#xA;    箭头函数特性:&#xA;        没有自己的this, this是外部的this, 所以不能用call, apply, bind改变this&#xA;        不能当作构造函数, 没有super, new.target&#xA;        没有arguments, arguments是外部的&#xA;        不能成为Generator&#xA;        大括号解释为代码块, 要返回对象时用圆括号括起来&#xA;        const pipeline = (...funcs) =&amp;gt; val =&amp;gt; funcs.reduce((a, b) =&amp;gt; b(a), val)&#xA;        const plus1 = a =&amp;gt; a + 1, mult2 = a =&amp;gt; a * 2, addThenMult = pipeline(plus1, mult2);&#xA;        addThenMult(5)    // 12&#xA;        let insert = val =&amp;gt; ({into: (arr) =&amp;gt; ({after: (afterVal) =&amp;gt; {&#xA;            arr.splice(arr.indexOf(afterVal) + 1, 0, val); return arr;&#xA;        }})})&#xA;        insert(2).into([1, 3]).after(1)    // [1, 2, 3]&#xA;参数&#xA;    function f(x, y = 5)&#xA;        f({x: 1, y: 2})可以模式匹配&#xA;        默认值可以是变量，作用域是函数内作用域。函数a默认值是函数b时, 函数b的作用域链不包含函数a&#xA;        默认值一般在最后, 可以一眼看出哪些参数可以省略，调用时也好看&#xA;    function f(url, {method = &#39;GET&#39;} = {})&#xA;    function f({a, b}) {a, b}&#xA;        f({a: 1, b: 2}) 对象匹配&#xA;    function f(a = throwErr())&#xA;        设置不可省略的参数, 默认值是延迟计算的&#xA;    function f(...rest)&#xA;        一定在末尾&#xA;嵌套函数&#xA;    特性    &#xA;        内部嵌套函数可以读写外部参数&#xA;        this不会在嵌套函数中继承，函数调用和方法调用中this的规则不变。&#xA;            如果要在内部访问外部this, 需要将外部this保存到变量中(通常用self, [that 是传递this时使用的变量名])&#xA;调用&#xA;    方式&#xA;        作为函数&#xA;        作为方法&#xA;        作为构造函数&#xA;        通过它们的call()和apply()方法间接调用&#xA;    原理&#xA;        调用由函数对象，左圆括号，参数列表(逗号分隔)，右圆括号组成&#xA;        每个参数表达式都会计算出一个值作为实参传递给声明时定义的形参&#xA;            在函数体中存在一个形参的引用指向当前传入的实参列表&#xA;        函数表达式的值成为调用表达式的值&#xA;        ECMAScritp 3和非严格ECMAScript 5中，函数调用上下文(this)是全局对象。严格模式下是undefined&#xA;            常用this判断是否严格模式&#xA;    调用表达式&#xA;        f()                                     # 作为普通函数调用&#xA;        o.m(x, y)                               # 函数表达式本身就是属性访问表达式, 此时函数作为一个方法调用, 方法调用的上下文是该调用对象o&#xA;        o[&amp;quot;m&amp;quot;](x, y)&#xA;        a[0](z)                                 # 可以用方括号来方法调用&#xA;        a.b.c()&#xA;        f().m()                                 # 方法链, 链式调用, 返回this或构造对象&#xA;构造函数调用&#xA;    方法名前带有new, 就是构造函数的调用&#xA;    与普通的函数调用及方法调用在实参处理、调用上下文、返回值方面都不同&#xA;    定义一类(class)对象，创建对象继承构造函数的prototype属性&#xA;        class看作是对象类型的子类型&#xA;    使用新对象作为调用上下文, 如new o.m()中，this不是o&#xA;    如果return一个对象，则构造的就是这个对象，如果返回原始值或没有值，则忽略返回值&#xA;    原理&#xA;        计算实参表达式，传入函数内。没有形参，允许省略实参列表和圆括号，如&#xA;            var o = new Object()                # 无参时圆括号可以省略&#xA;        创建空对象，继承构造函数的prototype, 试图初始化该对象，并将该对象作为调用上下文&#xA;            尽管构造函数看起来像方法调用，但它用新对象作为调用上下文&#xA;            所以 new o.m()看起来是方法调用，但它的调用上下文并不是o&#xA;        通常不使用return关键字，显式返回构造的新对象&#xA;            显式使用return时，如果没有值或是原始值，就忽略return。如果是对象，就返回return的对象&#xA;间接调用&#xA;    call和apply&#xA;        可以显式指定调用上下文，这样任何函数都可以作为任何对象的方法来调用&#xA;        call使用自有的实参列表作为函数实参，apply以数组形式传入参数&#xA;实参和形参&#xA;    不检查传入的参数类型和参数个数，所以要手动做参数检查&#xA;        传入参数少时，剩下的形参都设置为undefined&#xA;            所以在参数检查时，要给省略的参数赋默认值。如 a = a || []&#xA;            a = a || [] 是习惯用法，用来代替if语句，前提是a必须预先声明&#xA;        前面的参数可选且不传时，传入占位符null(也可以传undefined)&#xA;        函数定义中使用/*optional*/来强调形参可选, 如&#xA;            function f(o, /*optional*/ a)&#xA;    可变长实参列表(实参对象)&#xA;        arguments&#xA;            是类数组对象，可以通过数字下标访问传入的实参值&#xA;            这种可以接收任意个数实参的函数    称为 不定实参函数(varargs function)&#xA;            非严格模式下, 实参对象的数组元素是函数形参对应实参的别名，改变实参值时，实参对象中的值也改变&#xA;                ECMAScript 5中移除了别名这个特性(实测没有移除)&#xA;            非严格模式中, arguments是一个标识符，严格模式中，它是一个保留字&#xA;            arguments的callee和caller属性&#xA;                ECMAScript 5 严格模式中，对这两个属性的读写操作都会产生类型错误&#xA;            非严格模式中, callee指代当前正在执行的函数，caller是非标准的，但大多数浏览器都实现了这个属性，指代调用callee的函数。&#xA;                通过caller属性可以访问调用栈&#xA;            可通过callee递归调用自身&#xA;                var factorial = function(x){&#xA;                    if( x &amp;lt;= 1) return 1;&#xA;                    return x * arguments.callee(x-1)&#xA;                }&#xA;    对象属性作实参，如&#xA;        easycopy({from: a, to: b, length: 4})&#xA;        function easycopy(args){&#xA;            args.from;&#xA;            args.from_start || 0;&#xA;        }&#xA;    类型注释&#xA;        function max(/*number*/a, /*optional*/b, /*array*/c, /*integer*/d, /*index*/e){&#xA;            if(isArrayLike(c)){&#xA;                if(isFinite(a));&#xA;            }&#xA;        }&#xA;函数作为值&#xA;    function a(){}                              # 定义创建函数对象，赋值给a。函数对象的名字是看不见&#xA;    o.f = f                                     # 将函数赋值给对象的属性，就称为方法&#xA;    var a = [function() {}, 20]                 # 没有名字的函数，放在数组直接量中&#xA;函数的自定义属性&#xA;    如当函数需要专属常量时，可在上面定义静态属性&#xA;    如要求函数返回唯一整数，可以定义静态属性做个计数器，&#xA;    如果要做缓存，也可以定义多个静态属性来缓存返回过的结果，属性名就是传入过的值&#xA;作命名空间&#xA;    无法声明只在一个代码块中可见的变量。所以定义一个函数做临时命名空间&#xA;    有些js扩展中(如mozilla的java script 1.7)可以使用let声明语句块内的变量, 如&#xA;        let(x = 1){ print(x)}&#xA;    (function(){&#xA;    }());&#xA;        匿名函数不会定义全局函数变量并运行, 定义了内部的局部变量&#xA;        最外层圆括号是习惯写法，尽管有些时候没必要也不应当省略&#xA;闭包&#xA;    js采用词法作用域(lexical scoping), 函数的执行依赖变量作用域。作用域在函数定义时决定，而非调用时&#xA;        当前函数的变量保存在函数作用域内(闭包)&#xA;        闭包指函数变量可以被隐藏于作用域链之内，象是函数将变量&amp;quot;包裹&amp;quot;了起来&#xA;    每函数中引入当前作用域链&#xA;    定义时与运行时&#xA;        大多定义函数时的作用域链在调用函数时依然有效&#xA;        调用函数时与定义函数时作用域链不是同一个时&#xA;            如返回内部嵌套的函数a时，外部运行a，其作用域链仍然是a的作用域链而非外部作用域链&#xA;    作用&#xA;        捕捉局部变量并一直保存&#xA;    原理&#xA;        如果一个函数的局部变量定义在cpu栈中, 函数返回时它们的确不存在了&#xA;        js中作用域链是一个对象列表，不是绑定的栈。&#xA;            运行js函数a时, 都创建新的对象保存局部变量。该新对象添加到作用域链中&#xA;                函数a返回时，从作用域链中删除该局部变量对象，等待垃圾回收&#xA;                如果a有嵌套函数，每个嵌套函数各自对应一个作用域链         # 该嵌套函数的作用域链，保留a的局部变量对象&#xA;                    嵌套函数在a中局部变量对象中保存时，会随其一起从作用域链删除&#xA;                    嵌套函数被返回或被外部引用时, 该嵌套函数不被回收，且其自身作用域链中的自身局部变量对象、a的局部变量对象也不删除。&#xA;        闭包的this值会随外部调用者而变动，所以要先将this转存。var self = this;&#xA;            闭包中使用的arguments也会变动，也要转存。var outerArguments = arguments;&#xA;可调用对象&#xA;    如&amp;quot;类数组对象&amp;quot;不是真正的数组，&amp;quot;可调用对象&amp;quot;不是函数，但所有函数都是可调用的&#xA;    可调用对象使用越来越少&#xA;    例如&#xA;        ie8及之前的版本window.alert()和document.getElementById()使用了可调用的宿主对象&#xA;        RegExp对象可以直接调用(如RegExp()), 是非标准特性, Netscape提出后被后续浏览器兼容&#xA;            typeof RegExp可能是&amp;quot;function&amp;quot;也可以是&amp;quot;object&amp;quot;&#xA;            最好不要对可调用RegExp对象有太多依赖，其可调用特性将来可能被删除&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;generator&#34;&gt;&#xA;  generator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#generator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;基本&#xA;    generator生成的遍历器g, g[Symbol.iterator]()得到自己。继承它prototype上的方法&#xA;        generator中this添加的属性, 生成的遍历器实例中没有, generator new相当于执行得到遍历器&#xA;        g.bind(obj) 可以改变generator中的this&#xA;    作为对象属性时写做 {* g() {}}, {g: function* () {}}&#xA;应用&#xA;    状态机&#xA;    协程(coroutine)&#xA;        generator是半协程(semi-coroutine), 只有generator函数的调用者，才能改变程序运行状态&#xA;        将多个协作的任务写成generator, 用yield语句交换控制权&#xA;    异步程序同步写法&#xA;    部署iterator接口&#xA;    可看作数组结构&#xA;yield&#xA;    特点&#xA;        惰性求值&#xA;        在表达式中时加圆括号, 如&#39;hello&#39; + (yield 1)，字符串模板中`${yield}`&#xA;        var n = yield i; g.next(1) 来返回值给n, g.next()返回undefined&#xA;        第一次调用g.next()不能传值，因为执行第一个yield之前的代码, 还没有yield来接收&#xA;    var a = yield* g()&#xA;        展开g()得到的generator(可展开所有iterator), 是for ... of的一种简写形式&#xA;        g()中有return 时, a 得到return 的值&#xA;    yield [a(), b()]&#xA;        非展开，而是并列执行, 全部执行返回时返回&#xA;throw&#xA;    特点&#xA;        外部的throw语句只被外部捕获&#xA;        generator中throw的错误先内部捕获，再抛出, g.throw(1)相当于从内部yield处抛出一个错误&#xA;        generator抛出错误后不再能继续执行，再执行返回done=true&#xA;    var g = function* () {try {yield;} catch (e) {}}                # 可以多个yield一个try catch ,  而回调函数只能一个回调一个try catch&#xA;    var i = g(); i.next()&#xA;    try{i.throw(&#39;a&#39;); i.throw(&#39;b&#39;) } catch(e){}                     # 内部捕获a, 外部捕获b&#xA;return&#xA;    特点&#xA;        相当于强制内部return&#xA;        generator中有finally时, g.return()延迟到所有finally执行后执行，再结束&#xA;    g.return(0)    // {value: 0, done: true}&#xA;使用&#xA;    function* f () {&#xA;        yield 1; yield 2; return 3;&#xA;    }&#xA;    var ff = f(), ff.next()&#xA;        # {value: 1, done: false}, {value: 2, done: false}, {value: 3, done: true}, {value: undefined, done: true}&#xA;        ## 没有return语句时, 去掉第三个结果，其它不变&#xA;自动执行                                    # 写执行器处理thunk和promise&#xA;    非promise&#xA;        thunk函数, 把回调函数抽离出来&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;promise&#34;&gt;&#xA;  promise&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#promise&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;三种状态&#xA;    进行中(pending)&#xA;    完成(fulfilled)&#xA;    失败(rejected)&#xA;状态转换&#xA;    状态可以由pending转换成fulfilled，或pending转换成rejected&#xA;    promise的状态转换只发生一次，之后代码会执行，但抛出的错误不捕获&#xA;    p2中return p1, 则p1的状态决定了p2的状态, 如果p1是resolved或reject, p2的回调立即执行&#xA;    所以返回promise对象时, then的回调相当于返回promise的then的回调&#xA;    新建即执行，不能取消。内部错误不抛出。无法得到具体pending状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;async&#34;&gt;&#xA;  async&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#async&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    generator的语法糖, 自动执行generator, 处理promise&#xA;    内置执行器，返回promise对象&#xA;使用&#xA;    var asyncReadFile = async function () {&#xA;        try {&#xA;            var f1 = await readFile(&#39;/etc/fstab&#39;);&#xA;        } catch (e) {}&#xA;        await p2.catch(function (e) {})&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;class&#34;&gt;&#xA;  class&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#class&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    所有方法在prototype上(constructor, static外)，不可枚举&#xA;    无变量提升&#xA;    类内部即严格模式&#xA;    class A的A.name = &#39;A&#39;, 意义同函数名&#xA;&#xA;语法&#xA;    class Point {&#xA;        constructor(x, y) {                         # 不定义时，生成空constructor方法, this代表新生的实例&#xA;            this.x = x, this.y = y;&#xA;        }&#xA;        toString() {return &#39;a&#39;}&#xA;        [methodName]() {}&#xA;        get prop() {...}&#xA;        set prop(val) {}&#xA;        * [Symbol.iterator]() {}&#xA;        static sMethod() {}                         # 相当于直接在Point上定义, es6 内只有方法，没有属性&#xA;        prop: 1                                     # es6中忽略, es7提案&#xA;        static prop2: 2                             # es6中忽略 es7提案&#xA;    }&#xA;    Point.a = 1;                                    # es6 静态属性只能在class外部定义&#xA;    var point = new Point(2, 3);&#xA;&#xA;    o-&amp;gt;&#xA;    var A = class B{};                              # 这时类的名字是A, 而B只能在类内中指代自己&#xA;    var A = class {};&#xA;    var a = new class {}();&#xA;&#xA;继承&#xA;    两条原型链&#xA;        Object.setPrototypeOf(B.prototype, A.prototype)&#xA;        B.prototype.__proto__ = A.prototype         # 作为构造函数, 子类B的prototype是A的实例&#xA;        Object.setPrototypeOf(B, A)&#xA;        B.__proto__ = A                             # 作为一个对象, 子类B的原型是A(强行成为继承关系来得到A的静态属性)&#xA;        B.__proto__.__proto__ = A.__proto__,        # 子类原型的原型是父类的原型&#xA;    继承的特殊种类&#xA;        class A {}, A.__proto__ = Function.prototype, A.prototype.__proto__ = Object.prototype&#xA;        class A extends null {}, A.__proto__ = Function.prototype, A.prototype.__proto__ = undefined&#xA;&#xA;    o-&amp;gt;&#xA;    class A extends B {&#xA;        constructor(x, y, color) {                  # 默认construcotr为constructor(...args) {super(...args)};&#xA;            super(x, y);                            # 调用B的constructor, 必须调用super来创建父类对象作用自己的prototype, 否则整个继承失败，报错&#xA;            this.color = color                      # this必须在super调用之后才能使用, 否则没有prototype生成this, 报错&#xA;        }&#xA;    }&#xA;    let cp = new A(1, 2, &#39;a&#39;)&#xA;    cp instanceof A    // true&#xA;    cp instanceof B    // true&#xA;&#xA;    o-&amp;gt; 继承原生构造函数(es5不可以)&#xA;        es5机制决定先新建子类实例this, 再将父类属性添加到子类上。父类的内部属性无法获取(如Array的[[DefineOwnProperty]])。&#xA;        es6允许继承原生父类构造函数定义子类, 即先新建父类this, 再用子类修饰, 父类的所有行为都可继承&#xA;    function MyArray() {Array.apply(this, arguments)}&#xA;    MyArray.prototype = Object.create(Array.prototype, {constructor: {&#xA;        value: MyArray,&#xA;        writable: true,&#xA;        configurable: true,&#xA;        enumerable: true,&#xA;    }})&#xA;    class MyArray extends Array {&#xA;        constructor(... args) {&#xA;        super(... args);&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; 用mixin来混合继承&#xA;    class A extends mix(B, C)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;decorator&#34;&gt;&#xA;  decorator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#decorator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    编译时执行&#xA;    相当于 class A {}, A = decorator(A) || A;&#xA;    不能用于函数，因为函数提升?&#xA;&#xA;o-&amp;gt; 修饰类&#xA;function testable(target) {                         # target是被修饰的类, 参数2为属性名, 参数3为属性描述对象&#xA;    target.isTestable = true;&#xA;}&#xA;function testable(val) {&#xA;    return function(target) {&#xA;        target.isTestable = val;&#xA;    }&#xA;}&#xA;@testable&#xA;class A {}&#xA;A.isTestable    // true&#xA;&#xA;o-&amp;gt; 修饰类属性&#xA;function readonly(target, name, descriptor) {&#xA;    descriptor.writable = false;&#xA;    return descriptor;&#xA;}&#xA;class Person {&#xA;    @readonly&#xA;    name() {return 0}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基础&#xA;    一种复合值。属性的无序集合，属性由名/值对组成，看作字符串到值的映射。&#xA;        这种数据结构叫做散列(hash), 散列表(hashtable), 字典(dictionary), 关联数组(associative array)&#xA;        常用来模拟静态对象或静态语言的结构体。也可以模拟json字符串&#xA;    可以基于原型(prototype)继承属性，称作原型式继承(prototypal inheritance)&#xA;    除了字符串、数字、true、false、null、undefined外，js中的值都是对象&#xA;        字符串、数字、布尔值可以自动包装为对象(构造函数的实例)&#xA;    对象操作通过引用(而非值)。&#xA;    常见属性操作&#xA;        创建(create)&#xA;        设置(set)&#xA;        查找(query)&#xA;        删除(delete)&#xA;        检测(test)&#xA;        枚举(enumerate)&#xA;组成&#xA;    属性的名/值对 + 属性特性(property attribute) + 对象特性(object attribute)&#xA;            属性名可以是空字符串，不能重名&#xA;        属性特性包括: 可写(writable attribute), 可枚举(enumerable attribute), 可配置(configurable attribute)&#xA;            可配置表明是否可以删除或修改该属性&#xA;            通过代码给对象创建的所有属性都是可写、可枚举、可配置的, ECMAScript 5 中可以改变&#xA;        对象特性包括&#xA;            对象原型(prototype)                     # 指向另外一个对象, 本对象继承它的原型&#xA;            对象的类(class)                         # 一个标识对象类型的字符串&#xA;            对象的扩展标记(extensible flag)          # ECMAScript 5中指明是否可以向该对象添加新属性&#xA;分类&#xA;    内置对象(native object)                         # 由ECMAScript定义的对象或类。如数组、函数、日期、正则表达式&#xA;    宿主对象(host object)                           # js解释器( 如web浏览器)嵌入的宿主环境,如 HTMLElement对象&#xA;                                                   # 宿主环境定义的方法可当作普通js函数对象, 宿主对象可当作内置对象&#xA;    自定义对象(user-defined object)                  # 运行中的js代码创建的对象&#xA;    自有属性(own property)                          # 直接在对象中定义的属性&#xA;    继承属性(inherited property)                    # 对象的原型对象中定义的属性&#xA;原型&#xA;    每一个js对象(null除外)都与另一个对象(原型)关联，从原型继承属性。&#xA;    内容&#xA;        对象直接量创建的对象有同一个原型对象Object.prototype&#xA;        new的对象原型是构造函数prototype的属性的值     # 于是new Object()创建的对象继承自Object.prototype&#xA;        Object.prototype这个对象没有原型&#xA;        具体&#xA;            除Object.prototype的对象是普通对象，都有原型。&#xA;            所有内置构造函数都继承Object.prototype&#xA;                如, new Date()创建的对象同时继承Date.prototype和Object.prototype&#xA;                这一系列的链接的原型对象就是&amp;quot;原型链&amp;quot;(prototype chain)&#xA;创建对象&#xA;    {}&#xA;        ECMAScript 5中(ECMAScript3的部分实现), 保留字用作属性名可以不带引号&#xA;            ECMAScript 3中保留字作属性名必须用引号&#xA;        ECMAScript 3的IE中, 最后一个逗号不可以忽略&#xA;        每次计算对象直接量，都会计算它的每个属性的值&#xA;    new            # 关键字创建&#xA;        new后的函数是构造函数(constructor)。&#xA;    Object.create()&#xA;        ECMAScript 5中出现的静态函数&#xA;        参数1是原型对象, 参数2可选，对对象属性进一步描述&#xA;&#xA;        Object.create({x:2})&#xA;        Object.create(null)&#xA;            传入参数null来创建没有原型的新对象。&#xA;            没有原型的对象没有toString等方法, 所有不能+运算&#xA;        Object.create(Object.prototype)&#xA;            创建普通对象&#xA;对象序列化(serialization)                            # json(JavaScript Object Notation)&#xA;    ECMAScript 5 api                                # stringify, parse的第二个参数可选，传入属性列表来定制序列化或还原操作&#xA;        JSON.stringify()&#xA;            支持对象, 数组, 字符串, 无穷大数字, true, false, null。NaN, Infinity, -Infinity序列化结果是null&#xA;                日期stringify为日期字符串，parse不能还原成对象&#xA;                只序列化对象的可枚举自有属性。不能序列化的属性自动省略掉&#xA;            函数, RegExp, Error对象和undefined不能序列化和还原&#xA;        JSON.parse()&#xA;创建对象                                            # 函数即对象，本身为构造方法&#xA;    var obj = {};                                  # var obj = []是数组, 数组中Obj[&#39;aa&#39;]添加的是属性而非成员, 静态对象&#xA;    function Obj(a, b){};&#xA;        new Obj(a, b);&#xA;    function Obj(a, b){&#xA;        thisf = new Array();&#xA;        return new Object(a, b)&#xA;    };            &#xA;        Obj(a, b);&#xA;            只能返回Obj里定义的新对象的实例(不能返回本身的实例)&#xA;            内的变量函数静态。指向外部函数可动态&#xA;            内对象为动态&#xA;        new Obj(a, b);                              # 内变量函数动态(内存浪费)&#xA;        Obj.prototype.c = &#39;c&#39;&#xA;        Obj.prototype.d = function(){};&#xA;        Obj.prototype.e = new Array();              # prototype函数为静态函数, prototype对象为静态&#xA;    function Obj(a, b){ }                           # 内部prototype, 与外部完全相同&#xA;        if(typeof Obj._initialized == &#39;undefined&#39;){&#xA;            Obj.prototype.c = function(){};&#xA;            Obj._initialized = true;&#xA;        }&#xA;    最好方式:&#xA;        内部定义变量和对象, prototype定义函数(防止new对象的函数动态)。&#xA;        prototype定义函数可以在内部，也可以在外部。&#xA;    扩展对象&#xA;        Obj.prototype.extend                        # 添加或重写当前对象的属性&#xA;        Object.prototype.extend                     # 所有对象上添加属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;属性&#34;&gt;&#xA;  属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;查询和设置&#xA;    . []&#xA;        ECMAScript 3中, 点运算符后的标识符不能是保留字。ECMAScript5(包括ECMAScript3的某些实现)中可以&#xA;        []中必须返回可以转换为字符串的值&#xA;        []的写法用了字符串索引，叫做关系数组(associative array), 散列或字典&#xA;    属性不存在时自动创建&#xA;描述对象&#xA;    value&#xA;    writable                                        # 可修改&#xA;    enumerable                                      # 可枚举性&#xA;        for...in, Object.keys(), JSON.stringify(), Object.assign(), Reflect.enumerate()会忽略不可枚举属性&#xA;        for...in等价Reflect.enumerate(), 会返回继承的属性&#xA;    configurable                                    # 可配置&#xA;遍历属性                                             # 先遍历属性名是数值的属性，再遍历字符串，再遍历Symbol&#xA;    for ... in                                      # 自身和继承的可枚举属性&#xA;    Object.keys                                     # 自身的可枚举属性(不含Symbol)&#xA;    Object.getOwnPropertyNames                      # 自身所有属性(不含Symbol)&#xA;    Object.getOwnPropertySymbols                    # 自身所有Symbol属性&#xA;    Reflect.ownKeys                                 # 自身所有属性&#xA;    Reflect.enumerate                               # 同for ... in&#xA;访问错误&#xA;    查询不存在的属性不报错, 返回undefined&#xA;    对象不存在，会查询null和undefined的属性，会报错&#xA;        建议写法: var len = book &amp;amp;&amp;amp; book.subtitle &amp;amp;&amp;amp; book.subtitle.length&#xA;    只读的设置不报错，如                              # ECMAScript 5的严格模式中会报错&#xA;        Object.prototype = 0;        &#xA;设置属性失败的情况&#xA;    o中属性p是只读的                                  # defineProperty()可以&#xA;    o中属性p是继承属性，且它是只读的&#xA;    o没有属性p, o没有使用p的setter方法, o可扩展性为false&#xA;删除属性&#xA;    delete&#xA;        删除成功，属性不存在，不是属性访问表达式时，返回true&#xA;        属性可配置性为false，非严格模式下返回false, 严格模式下抛出异常&#xA;        全局对象可以不用属性访问表达式, 如 delete x;&#xA;            严格模式下, delete x; 会报语法错误, 必须delete this.x&#xA;        只是断开联系&#xA;        只删除自有属性，不能删除继承属性&#xA;            继承属性可以从原型对象上删除它&#xA;            a = {p:{x:1}}; b= a.p; delete a.p; 执行后p.x还是1。因为属性的引用依然存在&#xA;                会内存泄漏，所以在销毁对象时，要遍历属性中的属性，依次删除&#xA;检测属性&#xA;    in                                              # 检测自有属性和继承属性&#xA;        &amp;quot;x&amp;quot; in o;&#xA;    o.x !== undefined                               # 同in，但没法区分属性的值为undefined时的属性，in可以&#xA;                                                    # !==可以区分null和undefined, 所以用!==&#xA;    hasOwnProperty()                                # 只检测自有属性&#xA;        o.hasOwnProperty(&amp;quot;x&amp;quot;);&#xA;    propertyIsEnumerable()                          # 自有属性且可枚举&#xA;        o.propertyIsEnumerable(&amp;quot;x&amp;quot;)&#xA;枚举属性                                             # ECMAScript 3 的不可枚举属性不能得到&#xA;    for/in&#xA;        ECMAScript 5之前, 工具库给Object.prototype添加的属性必须可枚举&#xA;        所以for/in会枚举出来，要用hasOwnProperty(p)来过滤&#xA;    Object.keys()                                   # ECMAScript 5中定义，返回可枚举的自有属性名数组&#xA;    Object.getOwnPropertyNames()                    # ECMAScript 5中定义，返回自有属性名数组&#xA;getter和setter&#xA;    通常用来表示同一组数据的两种方法(如笛卡尔坐标系表示法和极坐标系表示法)&#xA;        也用于检测属性的写入和读取值&#xA;    ECMAScript 5中属性值可以用方法替代，就是getter和setter, 叫做存取器属性(accessor property)&#xA;        是访问描述符，相对数据描述符(如writable)&#xA;        普通的属性叫做数据属性(data property), 只有一个简单的值&#xA;        存取器属性不具有可写性(writable attribute)&#xA;        作为替代, 只有getter, 则只读。只有setter, 则只写。同时拥有, 则可读写&#xA;            读取只写属性总是返回undefined&#xA;        存取器属性是可以继承的&#xA;    定义&#xA;        var o = {&#xA;            data_prop: 1,&#xA;            get accessor_prop(){},                  # 函数中的this表示当前对象o&#xA;            set accessor_prop(value){}&#xA;        };&#xA;        var descriptor = Object.getOwnPropertyDescriptor(o, &#39;accessor_prop&#39;);&#xA;        &#39;get&#39; in descriptor    // true&#xA;        &#39;set&#39; in descriptor    // true&#xA;    例子&#xA;        var p = {&#xA;            $x: 1.0, &#xA;            $y: 1.0,&#xA;            get r () {return Math.sqrt(this.x * this.x + this.y * this.y);},&#xA;            set r (newvalue) {&#xA;                var oldvalue = Math.sqrt(this.x * this.x + this.y * this.y);&#xA;                var ratio = newvalue/oldvalue;&#xA;                this.x *= ratio;&#xA;                this.y *= ratio;&#xA;            },&#xA;            get theta () {return Math.atan2(this.y, this.x); }&#xA;        }&#xA;    例子&#xA;        var serialnum = {                           # 序列&#xA;            $n: 0,                                  # $暗示私有属性&#xA;            get next(){return this.$n++;},&#xA;            set next(n){&#xA;                if(n &amp;gt;= this.$n) this.$n = n;&#xA;                else throw &amp;quot;序列号的值不能比当前值小&amp;quot;;&#xA;            }&#xA;        }&#xA;    例子2&#xA;        var random = {                              # 返回不同数量范围的随机数&#xA;            get octet(){ return Math.floor(Math.random() * 256)},&#xA;            get uint16(){ return Math.floor(Math.random() * 65536)},&#xA;            get int16(){ return Math.floor(Math.random() * 65536) - 32768}&#xA;        };&#xA;属性的特性                                           # ECMAScrit 3这些特性不可以配置, ECMAScript 5中提供查询和设置的api&#xA;    作用&#xA;        给原型对象添加方法，设置该方法为不可枚举，看起来像内置方法&#xA;        给普通对象定义不能修改或删除的属性，实现&amp;quot;锁定&amp;quot;&#xA;    组成&#xA;        值(value), 可写性(writable)、可枚举性(enumerable)、可配置性(configurable)&#xA;            存取器特性是读取(get)、写入(set)、可枚举性、可配置性&#xA;    原理&#xA;        ECMAScript 5定义了 属性描述符(property descriptor)对象, 代表4个特性&#xA;            该对象的属性有value, writable, enumerable, configurable, 代表4个特性&#xA;            存取器属性描述符用get和set代替value和writable&#xA;                writable, enumerable, configurable是布尔值&#xA;                get和set是函数值, value什么都可以&#xA;    调用                                             # 新建属性的默认特性对象为false或undefined&#xA;        Object.getOwnPropertyDescriptor(o, p)&#xA;            获得对象o的p自有属性的 属性描述符对象&#xA;            要得到继承属性的特性, 要遍历原型链&#xA;        Object.defineProperty(o, &amp;quot;x&amp;quot;, {             # 新建或修改自有属性的特性, 传入对象和属性名与属性描述符对象&#xA;            value: 1,&#xA;            writable: true,&#xA;            enumerable: false,&#xA;            configurable: true&#xA;        });&#xA;        Object.defineProperty(o, &amp;quot;x&amp;quot;, {get: function(){ return 0; }});&#xA;            修改x为存取器属性&#xA;                返回修改后的对象&#xA;            不允许创建或修改的属性，抛出类型错误异常&#xA;                规则(违反则抛异常)&#xA;                    对象不可扩展，可以编辑已有属性, 不能添加&#xA;                    属性不可配置, 不能修改可配置性和可枚举性&#xA;                    存取器属性不可配置, 不能修改getter, setter方法, 不能转换为数据属性&#xA;                    数据属性不可配置，不能转换在存取器属性&#xA;                    数据属性不可配置，不能可写性从false修改为true&#xA;                    数据属性不可配置且不可写, 不能修改值。可配置但不可写时可以修改值&#xA;                        实际上自动标记为可写，再改值，再转换为可写&#xA;        Object.defineProperties({}, {&#xA;            x: {value: 1, writable: true, enumerable: true, configurable: true},&#xA;            y: {value: 1, writable: true, enumerable:true, configurable:true},&#xA;            r: {&#xA;                get: function(){return Math.sqrt(this.x * this.x + this.y * this.y)},&#xA;                enumerable: true,&#xA;                configurable: true&#xA;            }&#xA;        })&#xA;            新建或修改多个属性及特性。第一个参数是修改对象，第二个参数是映射表&#xA;                返回修改后的对象&#xA;            不允许创建或修改的属性，抛出类型错误异常&#xA;    老式api(ECMAScript 5之前，非IE浏览器)&#xA;        __lookupGetter__()&#xA;        __lookupSetter__()                              # 返回一个属性的getter和setter&#xA;        __defineGetter__()&#xA;        __defineSetter__()                              # 定义getter和setter, 第一个参数是属性名, 第二个参数是getter或setter方法&#xA;对象三个属性&#xA;    包括&#xA;        原型(prototype)&#xA;        类(class)&#xA;        可扩展性(extensible attribute)&#xA;    原型&#xA;        api&#xA;            Object.getPrototypeOf()                     # ECMAScript 5出现, 传入对象返回原型&#xA;            o.constructor.prototype                     # 得到对的原型，对于Object.create()创建的对象常不是这样&#xA;            p.isPrototypeof(o)                          # 检测p是否是o的原型(或牌原型链中)，与instanceof运算符类似&#xA;            __proto__                                   # Mozilla实现的js有的属性, safari和chrome也支持&#xA;    类属性&#xA;        表示对象类型信息的字符串, 用toString()方法可以得到&#xA;        ECMAScript 3和5 都不能设置这个属性，只能间接查询&#xA;        js内置构造函数创建的对象类属性与函数名称相匹配&#xA;            对象直接量、Object.create、自定义构造函数 创建的对象类属性是&amp;quot;Object&amp;quot;&#xA;            对于自定义类来说，没办法通过类属性来区分对象的类&#xA;        api&#xA;            toString()                                  # 返回如 [object class], 提取class, 很多对象的toString方法重写了, 要间接调用Function.call()方法&#xA;            function classof(o){&#xA;                if(o === null) return &amp;quot;Null&amp;quot;;&#xA;                if(o === undefined) return &amp;quot;Undefined&amp;quot;; # ECMAScript 5中不需要对null和undefined作处理&#xA;                return Object.prototype.toString.call(o).slice(8, -1);&#xA;            }&#xA;    可扩展性&#xA;        表示是否可以给对象添加新属性。ECMAScript 5中 内置对象和自定义对象都显式可扩展&#xA;        宿主对象可扩展性由js引擎定义&#xA;        api&#xA;            # preventExtensions, seal, freeze 都返回传入的对象&#xA;            Object.esExtensible()                       # 判断对象是否可扩展&#xA;            Object.preventExtensions()                  # 转换对象为不可扩展, 参数为待转换对象, 对象转换不可扩展后，无法再转换回来, 给不可扩展对象原型添加属性, 对象同样会继承新属性&#xA;            Object.seal()                               # 对象设置不可扩展, 同时对象自有属性不可配置, 已有属性标记为可写的依然可配置, seal后的对象不能解封&#xA;            Object.isSealed()                           # 检测对象是否封闭&#xA;            Object.freeze()                             # 除了seal外，将自有数据属性设置为只读, setter方法不受影响&#xA;            Object.isFrozen()                           # 检测是否冻结&#xA;继承&#xA;    介绍&#xA;        js对象有自有属性(own property)，有从原型继承来的属性&#xA;    原型链(prototype chain)                              # 原型，原型的原型 ...&#xA;        属性的查询先找自有属性，再找原型链&#xA;        属性修改时, 先检查属性是否允许赋值。&#xA;            总在自有属性修改或创建，不修改原型链上的对象。这就是属性的覆盖(override)&#xA;                继承的对象有setter方法且是accessor属性时，修改属性时会由当前对象(非原型对象)调用setter方法。&#xA;                由当前对象调用，所以还是不会修改原型链&#xA;                setter方法如setTitle()&#xA;    inherit(p)函数&#xA;        function inherit(p){&#xA;            if(p == null) throw TypeError();&#xA;            if(Object.create) return Object.create(p);&#xA;            var t = typeof p;&#xA;            if(t !== &amp;quot;object&amp;quot; &amp;amp;&amp;amp; t !== &amp;quot;function&amp;quot;) throw TypeError();&#xA;            function f(){};&#xA;            f.prototype = p;&#xA;            return new f();&#xA;        }&#xA;        var o = {x: &amp;quot;don&#39;t change this value&amp;quot;};&#xA;        library_function(inherit(o));                   # 可以防止对o的意外修改&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数组&#34;&gt;&#xA;  数组&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    数字索引                                             # 最大索引 2^32 - 2, 实现经过优化, 数字索引访问比访问常规属性快很多&#xA;    元素无类型&#xA;    数组是动态, 根据需要它们会增长或缩减&#xA;    数组可能是稀疏的, 索引不一定连续, length对于稀疏数组取最大索引+1&#xA;原理&#xA;    数组对象使用小于0 ~ 2^32 - 2 非负整数属性名时, 自动维护其length属性值&#xA;    [] 索引内的数字作为索引创建和访问, 其它作为属性&#xA;    a[&#39;1&#39;] 同 a[1] 同 a[1.000]&#xA;    数组可以原型继承, 可以定义getter, setter方法&#xA;    数组元素可以delete, in, for/in                        # delete a[0], 0 in a&#xA;稀疏数组&#xA;    稀疏数组比稠密数组更慢, 内存利用率更高, 查找元素与常规对象属性查找时间一样长&#xA;    for/in时会跳过未有元素&#xA;&#xA;    a = new Array(5)&#xA;    a = [, , ,]&#xA;    a = [1, , 3]                                        # 旧版本实现中, [1,,3]与[1,undefined, 3]是一样的，不是稀疏数组&#xA;    a[1000] = 0&#xA;创建与调用&#xA;    var misc = [1.1, , true]                            # 第二个是undefined&#xA;    new Array()&#xA;    new Array(10)                                       # 预分配数组空间&#xA;    new Array(5, 4, &amp;quot;testing&amp;quot;)&#xA;    a[0]        &#xA;    a.length    &#xA;        length大于每一个索引&#xA;        对lenght赋值, 小于length索引的元素将删除, 如length=0清空数组&#xA;            Object.defineProperty()让数组的length变成只读&#xA;            Object.defineProperty(a, &amp;quot;length&amp;quot;, {writable: false})来避免删除元素&#xA;            让数组无线不能配置也可以，如Object.seal, Object.freeze方法&#xA;添加删除&#xA;    a[1] = &amp;quot;a&amp;quot;;&#xA;    a.push(&amp;quot;zero&amp;quot;, &amp;quot;one&amp;quot;)&#xA;    delete a[1]&#xA;    a.pop()                                             # 反push&#xA;    a.shift()                                           # 头部删除, 重改所有元素索引&#xA;    a.unshift()                                         # 反shift, 头部插入元素&#xA;    splice()                                            # 通用方法插入, 删除, 替换数组元素, 根据需要修改length属性&#xA;遍历&#xA;    for(var i = 0; i &amp;lt; a.length; i++)                   # 判断undefined&#xA;    for(var index in a){                                # 会遍历出Array.prototype中的方法, 要进行过滤, ECMAScript 允许for/in遍历顺序不同, 一般是升序的, 如果同时有属性和元素，很可能是创建顺序&#xA;        if(!a.hasOwnProperty(i)) continue;&#xA;        // if(String(Math.floor(Math.abs(Nuber(i)))) !== i) continue;        # 跳过不是正整数的i&#xA;    }&#xA;    a.forEach(function(x){})                            # ECMAScript 5定义的新方法&#xA;多维数组                                                 # js不支持真正的多维数组，可以用数组模拟&#xA;    var a = new Array(10)&#xA;    a[0] = new Array(10)&#xA;    a[0][0]&#xA;空位问题&#xA;    Array(3)    // [, , , ]                             # 没有0位置, 但length = 3, 不同于有0位置但值为undefined, es5中对空位处理很不一致, 一般是跳过, es6会将空位值转为undefined&#xA;类数组对象                                               # 与数组相似的对象, 字符串虽然与数组类似，但length没有限制, 最好不看作类数组对象&#xA;    特性&#xA;        自动更新length属性, length设置后自动截断数组&#xA;        从Array.prototype中继承了一些有用的方法&#xA;        类属性(class)为&amp;quot;Array&amp;quot;(Date等类也是&amp;quot;Date&amp;quot;)&#xA;    创建                                                 # 数组的方法对于自定义的类数组对象是通用的, 虽然不能继承Array.prototype, 但可以间接调用Function.call&#xA;        要求&#xA;            自动维护length属性&#xA;            下标是数字字符串并在数组下标范围内&#xA;        var a = {&amp;quot;0&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;1&amp;quot;: &amp;quot;b&amp;quot;}&#xA;作为数组的字符串&#xA;    介绍&#xA;        ECMAScript 5中，字符串类似只读数组。访问如下&#xA;            s.charAt(0)&#xA;            s[0]&#xA;        Array.isArray(s)是false&#xA;        通用字符串方法可以乃至字符串中，如                   # 但字符串是不可变值的，所以中push, sort, reverse, splice在字符串上是无效的, 出错时没有提示&#xA;            Array.prototype.join.call(&#39;abc&#39;, &amp;quot; &amp;quot;)        # &amp;quot;a b c&amp;quot;&#xA;二进制数组&#xA;    介绍&#xA;        ArrayBuffer, TypedArray, DataView&#xA;        TypedArray按小端字节序来处理ArrayBuffer, 大端字节序可以自定义DataView&#xA;    TypedArray&#xA;        溢出&#xA;            正向溢出(overflow)&#xA;                uint8[0] = 256    // 0                  # 值为 数据类型最小值 + 余值 - 1, 这里为 0 + 1 - 1&#xA;                int8[0] = 128    // -128                # -128 + 1 - 1&#xA;            负向溢出(underflow)&#xA;                uint8[0] = -1    // 255                 # 值为 数据类型最大值 - 余值 + 1, 这里为 255 - 1 + 1&#xA;                int8[0] = -129    // 127                # 127 - 1 + 1&#xA;            Uint8ClampedArray负向溢出都为0, 正向溢出都为255&#xA;    场景&#xA;        o-&amp;gt;ajax中&#xA;        xhr.responseType设置为 &#39;arraybuffer&#39;来接收二进制数据(也可以设blob)&#xA;&#xA;        o-&amp;gt; canvas中&#xA;        ctx.getImageData(0, 0, canvas.width, canvas.height)&#xA;        uint8ClampedArray = imageData.data;&#xA;&#xA;        o-&amp;gt;　websocket中&#xA;        socket.binaryType = &#39;arraybuffer&#39;&#xA;        var arrayBuffer = event.data;&#xA;        socket.send(new Uint8Array(4).buffer);&#xA;&#xA;        o-&amp;gt; fetch api中&#xA;        返回request.arrayBuffer()得到arrayBuffer数据&#xA;&#xA;        o-&amp;gt; file api中&#xA;        reader.readAsArrayBuffer(file);&#xA;        reader.onload = function() { var arrayBuffer = reader.result; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;集合&#34;&gt;&#xA;  集合&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e5%90%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Set&#xA;    数据唯一&#xA;    Nan等于自身&#xA;WeakSet&#xA;    成员只能是对象&#xA;    成员弱引用，垃圾回收不考虑其引用，所以不能引用其成员，所以WeakSet不可遍历，因为刚遍历出的成员可能已删除&#xA;    可用于储存dom节点，实时判断是否存在，且防止内存泄漏&#xA;Map&#xA;    各种类型都可作为键, 键唯一覆盖, NaN等于自身, +0 等于 -0&#xA;WeakMap&#xA;    只接受对象作key&#xA;    元素被回收后, 自动移除对应的键值对&#xA;    适用于dom节点作键名，部署关联外部的私有属性(外部对象删除后，私有属性同步删除)，不会内存泄漏&#xA;遍历器&#xA;    介绍&#xA;        默认三种结构支持, Array, Set, Map。Object不支持，因为不确定遍历顺序&#xA;        字符串是类数组，有原生的iterator接口&#xA;    内部调用方式&#xA;        解构&#xA;            let [x, y] = new Set().add(1).add(2);&#xA;        扩展运算符&#xA;            [...iterable]&#xA;        yield* iterable&#xA;        参数&#xA;            for ... of&#xA;            Array.from()&#xA;            Map(), Set(), WeakMap(), WeakSet()&#xA;            Promise.all()&#xA;            Promise.race()&#xA;    实现&#xA;        iterable[Symbol.iterator] = function* () {&#xA;            yield 1;&#xA;            yield 2;&#xA;        }&#xA;        iterable[Symbol.iterator] = function () {&#xA;            return {&#xA;                next(){},&#xA;                return () { return {done: true}}        # return 在for ... of 提前退出(出错, break, continue), 可以用于释放资源, return 方法必须返回一个对象，这是Generator规格规定的&#xA;                throw() {}                              # 配合Generator使用&#xA;            };&#xA;&#xA;        }&#xA;    使用&#xA;        var result = iterator.next()&#xA;        while(!result.done) {&#xA;            var x = result.value;&#xA;            result = iterator.next();&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;proxy&#34;&gt;&#xA;  proxy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#proxy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    元编程(meta programming), 在对象外层进行代理&#xA;    在obj.proxy上设置Proxy对象，该对象的操作会变成对Proxy对象的操作&#xA;&#xA;var obj = new Proxy({}, {&#xA;    get: function (target, key, receiver) {&#xA;        return Reflect.get(target, key, receiver);&#xA;    },&#xA;    set: function (target, key, value, receiver) {&#xA;        return Reflect.set(target, key, value, receiver);&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reflect&#34;&gt;&#xA;  reflect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reflect&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    将Object上一些明显属于语言内部的方法(如Object.defineProperty)放到Reflect上&#xA;    修改Object上原有方法，变得更合理, 如Object.defineProperty在无法定义属性时抛出异常, 而Reflect.definePropert则返回false&#xA;    让Object操作变成函数作为, 如name in obj, delete obj[name]变成Reflect.has, Reflect.deleteProperty&#xA;    让Proxy上方法与Reflect方法对应，让Proxy的对象操作默认行为在Reflect上执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;正则&#34;&gt;&#xA;  正则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a3%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基本字符&#xA;    会精确匹配一段字符，如hi。这段字符可以出现多次&#xA;字面量&#xA;    /^[a-z]+$/.text(str);                   # ^代表开头, $是结尾&#xA;转义&#xA;    \&#xA;元字符                                       # metacharacter&#xA;    .                                       # 匹配除换行符以外任意字符&#xA;    \b&#xA;                                            # 表示单词的开头或结尾，也就是单词的分界。只匹配一个位置\s\S&#xA;        \bhi\b                              # hi单词&#xA;    \d                                      # 表示数字&#xA;    \s                                      # 匹配任意空白符，包括空格、tab、换行、中文全角空格等&#xA;        \s\S                                # 匹配包括\n在内的所有字符&#xA;    \w                                      # 匹配非特殊字符，包括字母、数字、下划线或汉字&#xA;    ^                                       # 匹配开头&#xA;    $                                       # 匹配结尾&#xA;    反义&#xA;        \W                                  # 非字符&#xA;        \S                                  # 非空白&#xA;        \D                                  # 非数字c&#xA;        \B                                  # 非单词位置&#xA;非&#xA;    [^x]                                    # 非x, [^aeiou] 除了aeiou以外的任意字符&#xA;限定字符&#xA;    {2}                                     # 表示前面的内容出现2次, {5, 12}内容出现5到12次, {5, }内容出现5或更多次&#xA;    ?                                       # 零次或一次&#xA;    *                                       # 零个或多个&#xA;    +                                       # 表示一个或多个&#xA;字符类&#xA;    [aeiou]                                 # 匹配其中的一个, [.?!] 匹配.或?或!&#xA;    [0-9]                                   # 同\d, [a-z0-9A-Z] 同\w&#xA;分枝条件&#xA;    |                                       # jpg|png,&#xA;        每个分支都从第一个分支开始匹配, 如\d{5}|\d{5}-d{4}只能匹配11111或11111-2222中的11111&#xA;分组                                         # 零宽断言只占用不消费&#xA;    ()&#xA;    语法&#xA;        (exp)&#xA;        (?&amp;lt;name1&amp;gt;exp)                       # 组命名&#xA;        (?:exp)                             # 消费exp, 不捕获匹配的文本，也不分配组号&#xA;        (?=exp)                             # 零宽断言，正向前瞻，后面能匹配表达式exp&#xA;            \b\w+(?=ing\b)                  # 匹配以ing结尾单词的前面部分，如dancing中的danc&#xA;            /(\w)\1{2}(?=(\w)\2{2})/g       # 匹配所有在3个连续相同字符前的相邻3个连续相同字符, aaalllsss0tAAAnnn999结果是aaa, lll, AAA, nnn&#xA;        (?&amp;lt;=exp)                            # 零宽断言，正向后瞻，前面能匹配表达式exp&#xA;            (?&amp;lt;=\bre)\w+\b                  # 匹配以re开头单词的后半部分，如reading中的ading&#xA;        (?!exp)                             # 零宽断言，负向前瞻，后面不匹配exp的位置, js不支持&#xA;            \b\w*q(?!u)\w*\b                # 匹配一个单词，该单词包含后面不是字母u的字母q&#xA;                &#xA;            \d{3}(?!\d)                     # 匹配三位数字，且它们后面不能有数字&#xA;            \b((?!abc)\w)+\b                # 匹配不包含连续字符串abc的单词&#xA;        (?&amp;lt;!exp)                            # 零宽断言，负向后瞻，前面不匹配exp的位置, js不支持&#xA;            (?&amp;lt;![a-z])\d{7}                 # 匹配前面不是小写字母的七位数字&#xA;        (?#comment)                         # 注释&#xA;后向引用                                     # 分组捕获后会自动编号，从左到右，1234。后向引用用于引用前面匹配到的文本，如 \1 代表分组1匹配的文本&#xA;    \b(\w+)\b\s+\1\b                        # 匹配重复的单词, 如go go&#xA;    (?&amp;lt;Word&amp;gt;\w+) 或 (?&#39;Word&#39;\w+)             # 把\w+的组名指定为Word, 用\k&amp;lt;Word&amp;gt;引用&#xA;贪婪与懒惰&#xA;    o-&amp;gt; 包含能接受重复限定符时，会匹配尽可能多的字符。如a.*b&#xA;    o-&amp;gt; a.*?b会懒惰匹配&#xA;        懒惰限定符&#xA;            *? 重复懒惰匹配任意次&#xA;            +? 重复懒惰匹配1次或多次&#xA;            ?? 重复懒惰匹配0次或1次&#xA;            {n, m}? 重复懒惰匹配n到m次&#xA;            {n,}? 重复懒惰匹配n次以上&#xA;平衡组/递归匹配&#xA;    (?&#39;group&#39;) 把捕获的内容命名为group，并压入栈(Stack)&#xA;    (?&#39;-group&#39;) 从栈中弹出最后压入的名为group的捕获内容。如果栈为空，则匹配失效&#xA;    (?(group)yes|no) 如果栈中存在名为group的捕获内容，继续匹配yes部分的表达式，否则则继续匹配no部分的表达式&#xA;    示例                                      # 平衡组最常见的应用是匹配HTML&#xA;        匹配xx&amp;lt;aa&amp;lt;bbb&amp;gt;&amp;lt;bbb&amp;gt;aa&amp;gt;yy&#xA;            思路&#xA;                每碰到左括号，就压入一个Open, 每碰到右括号，弹出一个&#xA;                最后看栈是否空，如果否则表示不配对，应该失败&#xA;                正则表达式引擎会进行回溯(放弃最前面或最后面一些字符), 尽量使整个表达式得到匹配&#xA;        &amp;lt;                                     # 最外层的左括号&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号的内容&#xA;        (&#xA;        (&#xA;        (?&#39;Open&#39;&amp;lt;)                            # 又碰到了左括号, 压入一个Open&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号内容&#xA;        )+&#xA;        (&#xA;        (?&#39;-Open&#39;&amp;gt;)                           # 碰到了右括号, 擦掉一个Open&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号内容&#xA;        )+&#xA;        )*&#xA;        (?(Open)(?!))                         # 负向前瞻，判断栈中还有没有Open, 有则匹配失败&#xA;        &amp;gt;                                     # 最外层右括号&#xA;        )&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; js中不支持 回顾后发断言&#xA;o-&amp;gt; 可以跟三个flag，比如/something/igm&#xA;    i表示不区分大小写&#xA;    g表示匹配多个&#xA;        g会影响String.prototype.match()和RegExp.prototype.exec()的行为&#xA;        match中加g会返回数组，不加g返回比较详细的信息&#xA;        exec中加g，且正则存在变量中时,该正则变量执行exec后会存储信息, 如&#xA;        var re = /h(.*?)\b/g;&#xA;        re.exec(&#39;hello helloo&#39;) 执行三次，匹配内容有变化&#xA;    m表示，^$可以匹配每一个的开头和结尾&#xA;o-&amp;gt; api&#xA;    RegExp&#xA;        exec                                    # 执行第一个, exp本身保留执行状态&#xA;            exp = /#/&#xA;            exp.exec(&#39;##&#39;)&#xA;        test&#xA;    String&#xA;        replace                                 # 替换第一个, &#39;abc - 123 - #$*&#39;&#xA;            &#39;John Smith&#39;.replace(/(\w+)\s(\w+)/, &#39;$2, $1&#39;)&#xA;            &#39;abc123#$*&#39;.replace(/([^\d]*)(\d*)([^\w]*)/, function replacer(match, p1, p2, p3, offset, string) {&#xA;            return [p1, p2, p3].join(&#39; - &#39;);&#xA;            });&#xA;        replaceAll&#xA;        match                                   # 不能有g选项，只得到第一个匹配&#xA;&#xA;.net中处理选项&#xA;    IgnoreCase                                  # 忽略大小写&#xA;    Multiline                                   # 多行模式, 更改^$的含义为一行首和行尾, $表示\n之前的位置以及字符串结束前的位置&#xA;    Singleline                                  # 单行模式(可以与Multiline通用)，更改.的含义，便它与每一个字符匹配(包括\n)&#xA;    IgnorePatternWhitespace                     # 忽略空白，会忽略表达式中非转义空白并启用#作为标记注释&#xA;    ExplicitCapture                             # 显式捕获，仅捕获已被显式命名的组&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;常用&#34;&gt;&#xA;  常用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;a[^&amp;gt;]+&amp;gt;&#xA;    # 用尖括号括起来的以a开头的字符串&#xA;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$&#xA;    # 密码的强度必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间&#xA;^[\\u4e00-\\u9fa5]{0,}$&#xA;    # 字符串只能是中文&#xA;^\\w+$&#xA;    # 由数字，26个英文字母或下划线组成的字符串&#xA;[\\w!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?&#xA;    # 校验E-Mail 地址&#xA;^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$&#xA;    # 校验身份证号码 15位&#xA;^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$&#xA;    # 校验身份证号码 18位&#xA;^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$&#xA;    # “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年&#xA;^[0-9]+(.[0-9]{2})?$&#xA;    # 金额校验，精确到2位小数&#xA;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$&#xA;    # 国内 13、15、18开头的手机号正则表达式&#xA;^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$&#xA;    # 判断IE的版本&#xA;\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&#xA;    # 校验IP-v4地址&#xA;(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))&#xA;    # 校验IP-v6地址&#xA;/^[a-zA-Z]+:\\/\\//&#xA;    # 检查URL的前缀&#xA;^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;amp;=]*)?&#xA;    # 提取URL链接&#xA;^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&amp;quot;&amp;lt;&amp;gt;|]+\\.txt(l)?$&#xA;    # 文件路径及扩展名校验&#xA;^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$&#xA;    # 提取Color Hex Codes&#xA;\\&amp;lt; *[img][^\\\\&amp;gt;]*[src] *= *[\\&amp;quot;\\&#39;]{0,1}([^\\&amp;quot;\\&#39;\\ &amp;gt;]*)&#xA;    # 提取网页图片&#xA;(&amp;lt;a\\s*(?!.*\\brel=)[^&amp;gt;]*)(href=&amp;quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&amp;quot;]+)&amp;quot;((?!.*\\brel=)[^&amp;gt;]*)(?:[^&amp;gt;]*)&amp;gt;&#xA;    # 提取页面超链接&#xA;^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}&#xA;    # 查找CSS属性&#xA;&amp;lt;!--(.*?)--&amp;gt;&#xA;    # 抽取注释&#xA;&amp;lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&amp;quot;.*?&amp;quot;|&#39;.*?&#39;|[\\^&#39;&amp;quot;&amp;gt;\\s]+))?)+\\s*|\\s*)\\/?&amp;gt;&#xA;    # 匹配HTML标签&#xA;&#39;12345678901&#39;.replace(/(\d{3})\d{4}(\d{4})/, &#39;$1****$2&#39;)&#xA;    # 替换中四位到*&#xA;&#39;1111111&#39;.replace(/([\d]{3})(?=[\d]+)/g, &#39;$1-&#39;)&#xA;    # 替换为 &#39;111-111-1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;元字符扩展&#34;&gt;&#xA;  元字符扩展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%83%e5%ad%97%e7%ac%a6%e6%89%a9%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;\a              # 报警字符&#xA;\t              # 制表符&#xA;\v              # 竖向制表符&#xA;\r              # 回车&#xA;\f              # 换页符&#xA;\n              # 换行符&#xA;\e              # Escape&#xA;\0nn            # ASCII码中八进制代码为nn的字符&#xA;\xnn            # ASCII码中十六进制代码为nn的字符&#xA;\unnnn          # Unicode码中十六进制代码为nnnn的字符&#xA;\cN             # ASCII控制字符，如\cC 代表ctrl + c&#xA;\A              # 字符串开头，同^但不受多行选项影响&#xA;\Z              # 字符串结尾或行尾，不受多行选项影响&#xA;\z              # 字符串结尾，同$但不受多行选项影响&#xA;\G              # 当前搜索的开头&#xA;\p{name}        # Unicode中命名为name的字符类，如\p{IsGreek}&#xA;(?&amp;gt;exp)         # 贪婪子表达式&#xA;(?&amp;lt;x&amp;gt;-&amp;lt;y&amp;gt;exp)   # 平衡组&#xA;(?im-nsx:exp)   # 在子表达式exp中改变处理选项&#xA;(?im-nsx)       # 为表达式后面的部分改变处理选项&#xA;(?(exp)yes|no)  # 把exp当作零宽正向先行断言，如果能匹配，使用yes作为此组表达式，否则使用no&#xA;    (?(exp)yes) 只使用空表达式为no&#xA;    (?(name)yes|no) 命名为name的组捕获到内容，使用yes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;风格&#34;&gt;&#xA;  风格&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a3%8e%e6%a0%bc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 最好js和html用独立的引号风格，如&#xA;        html双引号, js单引号&#xA;o-&amp;gt; 始终用var之类来声明变量，不用未声明变量&#xA;&#xA;o-&amp;gt; let和const取代var, 全局常量使用const&#xA;&#xA;o-&amp;gt; 特意将变量声明放在函数体顶部, 而不是使用变量之外, 来反映真实的作用域声明提前&#xA;&#xA;o-&amp;gt; 多用解构&#xA;    const [first, second] = arr                 # 数组取元素&#xA;    function f({a, b}) {}                       # 对象解构给函数赋值&#xA;    function f() {return {a, b}}, const {a, b} = f()                # 函数返回值解构&#xA;    var arr2 = [...arr]                         # 扩展运算符拷贝数组&#xA;&#xA;o-&amp;gt; 单行定义对象不逗号结尾(以后不扩展), 多行时逗号结尾(以后可能会扩展), 尽量用简洁的写法&#xA;    {a: 1, b}&#xA;    {&#xA;        [getKey(&#39;a&#39;)],&#xA;    }&#xA;&#xA;o-&amp;gt; Array.from转换类数组到数组&#xA;&#xA;o-&amp;gt; 匿名函数 (() =&amp;gt; {})(), 同时绑定了this为当前作用域&#xA;&#xA;o-&amp;gt; 不使用arguments, 使用rest运算符&#xA;&#xA;o-&amp;gt; 函数使用默认值 function f (opts = {})  {}&#xA;&#xA;o-&amp;gt; 用Map取代Object, 因为Map内建遍历机制, key可为对象。只能要数据转换时用Object&#xA;&#xA;o-&amp;gt; 总是用class取代需要的prototype操作, 因为class写法更简洁。extends也更简单, 不会有破坏instanceof运算的危险&#xA;&#xA;o-&amp;gt; 模块使用es6的机制, 模块只能一个输出时用export default, 多输出时用export, 不要export 和export default混合使用&#xA;&#xA;o-&amp;gt; 运算符&#xA;var t = o &amp;amp;&amp;amp; o.a || &#39;&#39;                          # 有o时取o.a, 无o时取&#39;&#39;, 因为&amp;amp;&amp;amp;的优先级比||高&#xA;var ifExist = !!o.a                             # 转换成布尔类型, 当然o.a = 0 什么的值时， 会判断失误，所以用来判断对象&#xA;&#xA;o-&amp;gt; 判断类型&#xA;typeof a === &amp;quot;string&amp;quot;                           # 数组等其他Object类型通通是Object&#xA;a instanceof Array                              # 判断Object类型的具体类型&#xA;a.constructor == Array                          # 判断构造函数&#xA;Object.prototype.toString.call(o) === &#39;[object Array]&#39;              # 用toString判断&#xA;&#xA;o-&amp;gt; 柯里化&#xA;function currying (fn, n) {&#xA;    return function (m) {&#xA;        return fn.call(this, m, n);&#xA;    }&#xA;}&#xA;function tailFactorial(n, total) {              # 尾递归调用优化&#xA;    if(n === 1) return total;&#xA;    return tailFactorial (n - 1, n * total);&#xA;}&#xA;const factorial = currying(tailFactorial, 1);&#xA;factorial(5)&#xA;&#xA;o-&amp;gt; 尾递归&#xA;function factorial (n, total = 1) {&#xA;    if(n === 1) return total;&#xA;    return factorial(n - 1, n * total);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;浏览器&#34;&gt;&#xA;  浏览器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8f%e8%a7%88%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;js执行顺序&#xA;    当页面载入时，会执行位于 body 部分的 JavaScript。&#xA;    当被调用时，位于 head 部分的 JavaScript 才会被执行。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;常用函数&#34;&gt;&#xA;  常用函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础扩展&#34;&gt;&#xA;  基础扩展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e6%89%a9%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;循环变量作用域&#xA;    function constfunc(v){&#xA;        return function(){return v}&#xA;    }&#xA;    var funcs = []&#xA;    for(var i = 0; i &amp;lt; 10; i++){&#xA;        funcs[i] = constfunc(i)&#xA;    }&#xA;闭包序列&#xA;    var uniqueInteger = (function(){&#xA;        var counter = 0;&#xA;        return function(){return counter++;}&#xA;    }());&#xA;    seq  = uniqueInteger()&#xA;    id = seq()&#xA;闭包计数器&#xA;    function counter(){&#xA;        var n = 0;&#xA;        return {&#xA;            count: function(){return n++;},&#xA;            reset: function(){n = 0;}&#xA;        };&#xA;    }&#xA;属性存取器&#xA;    function counter(n){&#xA;        return{&#xA;            get count() {return n++},&#xA;            set count(m){&#xA;                if(m &amp;gt;= n) {n = m }&#xA;                else {throw Error(&amp;quot;count can only be et to a larger value&amp;quot;)}&#xA;            }&#xA;        }&#xA;    }&#xA;    var c = counter(1000);&#xA;    c.count;&#xA;属性define&#xA;    Object.defineProperty(Object.prototype, &amp;quot;extend&amp;quot;, {&#xA;        writable: true,&#xA;        enumerable: false,&#xA;        configurable: true,&#xA;        value: function(o){&#xA;            var names = Object.getOwnPropertyNames(o);&#xA;            for(var i = 0; i &amp;lt; names.length; i++){&#xA;                if(names[i] in this) continue;&#xA;                var desc = Object.getOwnPropertyDescriptor(o, names[i]);&#xA;                Object.defineProperty(this, names[i], desc);&#xA;            }&#xA;        }&#xA;    });&#xA;私有属性&#xA;    function addPrivateProperty(o, name, predicate){&#xA;        var value;&#xA;        o[&amp;quot;get&amp;quot; + name] = function(){return value;}&#xA;        o[&amp;quot;set&amp;quot; + name] = function(v){&#xA;            if(predicate &amp;amp;&amp;amp; ! predicate(v)) {throw Error(&amp;quot;set&amp;quot; + name + &amp;quot;: invalid value &amp;quot; + v)}&#xA;            else {value = v}&#xA;        };&#xA;    }&#xA;    var o = {}&#xA;    addPrivateProperty(o, &amp;quot;Name&amp;quot;, function(x){ return typeof x == &amp;quot;string&amp;quot;;});&#xA;    o.setName(&amp;quot;A&amp;quot;);&#xA;    o.setName(o);&#xA;嵌套属性名&#xA;    function getAllPropertyNames = function(obj){&#xA;        var props = [];&#xA;        do {&#xA;            props = props.concat(Object.getOwnPropertyNames(obj));&#xA;        } while (obj = Object.getPrototypeOf(obj));&#xA;        return props;&#xA;    }&#xA;嵌套属性名2&#xA;    function keys(o){&#xA;        if(typeof o !== &amp;quot;object&amp;quot;) throw TypeError();&#xA;        var result = [];&#xA;        for(var prop in o){&#xA;            if(o.hasOwnProperty(prop))&#xA;            result.push(prop);&#xA;        }&#xA;        return result;&#xA;    }&#xA;嵌套累加&#xA;    function flexisum(a){&#xA;        var total = 0;&#xA;        for(var i = 0; i &amp;lt; arguments.length; i++) {&#xA;            var element = arguments[i], n;&#xA;            if(element == null){&#xA;                continue;&#xA;            } else if(isArray(element)){&#xA;                n = flexisum.apply(this, element);&#xA;            } else if(typeof element === &amp;quot;function&amp;quot;){&#xA;                n = Number(element());&#xA;            } else{&#xA;                n = Number(element);&#xA;            }&#xA;            if(isNaN(n)){&#xA;                throw Error(&amp;quot;flexisum(): can&#39;t convert &amp;quot; + element + &amp;quot; to number&amp;quot;);&#xA;            }&#xA;            total +=n;&#xA;        }&#xA;        return total;&#xA;    }&#xA;泛函代理, monkey-patching &#39;this&#39;&#xA;    function trace(o, m){&#xA;        var original = o[m];&#xA;        o[m] = function(){&#xA;            return original.apply(this, arguments);&#xA;        }&#xA;    }&#xA;兼容ECMAScript 3实现bind&#xA;    function bind(f, o){&#xA;        if(f.bind) {return f.bind(o)}&#xA;        else {&#xA;            return function(){&#xA;                return f.apply(o, arguments);&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数式&#34;&gt;&#xA;  函数式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;thunk&#xA;    function thunk (fileName) {&#xA;        return function (callback) {&#xA;            return fs.readFile(fileName, callback)&#xA;        }&#xA;    }&#xA;extend, 同名覆盖&#xA;    function extend(o, p){&#xA;        for(prop in p){&#xA;            o[prop] = p[prop];&#xA;        }&#xA;        return o&#xA;    }&#xA;merge, 同名不覆盖&#xA;    function merge(o, p){&#xA;        for(prop in p){&#xA;            if(o.hasOwnProperty[prop]) {continue}&#xA;            o[prop] = p[prop];s&#xA;        }&#xA;        return o;&#xA;    }&#xA;restrict, 删除非公共属性&#xA;    function restrict(o, p){&#xA;        for(prop in o){&#xA;            if(!(prop in p)) delete o[prop];&#xA;        }&#xA;        return o;&#xA;    }&#xA;substract, 删除公共属性&#xA;    function subtract(o, p){&#xA;        for(prop in p){&#xA;            delete o[prop];&#xA;        }&#xA;        return o;&#xA;    }&#xA;union, extend产生新对象&#xA;    function union(o, p) { return extend(extend({}, o), p);}&#xA;intersection, restrict产生新对象&#xA;    function intersection(o, p){ return restrict(extend({}, o), p);}&#xA;mixin&#xA;    function mix (...mixins) {&#xA;        class Mix {}&#xA;        for (let mixin of mixins) {&#xA;            copyProperties(Mix, mixin);&#xA;            copyProperties(Mix.prototype, mixin.prototype);&#xA;        }&#xA;        return Mix;&#xA;    }&#xA;    function copyProperties(target, source) {&#xA;        for(let key of Reflect.ownKeys(source)) {&#xA;            if(key !== &#39;constructor&#39;&#xA;                &amp;amp;&amp;amp; key !== &#39;prototype&#39;&#xA;                &amp;amp;&amp;amp; key !== &#39;name&#39;) {&#xA;                let desc = Object.getOwnPropertyDescriptor(source, key);&#xA;                Object.defineProperty(target, key, desc);&#xA;            }&#xA;        }&#xA;    }&#xA;混合继承&#xA;    class A extends mix(B, C) {}&#xA;mixins方法不被覆盖&#xA;    let Mixin1 = (superclass) =&amp;gt; class extends superclass {&#xA;        foo () {if(super.foo) super.foo()}&#xA;    }&#xA;    let Mixin2 = (superclass) =&amp;gt; class extends superclass {&#xA;        foo () {if(super.foo) super.foo()}&#xA;    }&#xA;    class S {&#xA;        foo() {}&#xA;    }&#xA;    class C extends Mixin1(Mixin2(s)) {&#xA;        foo() {super.foo()}&#xA;    }&#xA;    new c().foo()        // C, Mixin1, Mixin2, S&#xA;trait&#xA;    # 同mixins 额外功能: 防止同名方法冲突, 排除混入某些方法，为混入方法起别名等&#xA;    @traits(A, B)&#xA;    class C()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;generator-1&#34;&gt;&#xA;  generator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#generator-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;状态机 generator clock&#xA;    var clock = function* (_) {&#xA;        while(true) {&#xA;            yield _;&#xA;            console.log(&#39;Tick&#39;);&#xA;            yield _;&#xA;            console.log(&#39;Tock&#39;);&#xA;        }&#xA;    }&#xA;    非generator实现&#xA;        var ticking = true;&#xA;        var clock = function() {&#xA;            if (ticking) {console.log(&#39;Tick&#39;);}&#xA;            else {console.log(&#39;Tock&#39;);}&#xA;            ticking = !ticking&#xA;        }&#xA;递归next&#xA;    function run(fn) {&#xA;        var gen = fn();&#xA;        function next (err, data) {&#xA;            var result = gen.next(data);&#xA;            if (result.done) {return result.value;}&#xA;            result.value(next);&#xA;        }&#xA;        next();&#xA;    }&#xA;    run(gen);&#xA;generator, promise, 递归next2&#xA;    var readFile = function(fileName) {&#xA;        return new Promise(function (resolve, reject) {&#xA;            fs.readFile(fileName, function(err, data) {&#xA;                if(err) {reject(err);}&#xA;                resolve(data);&#xA;            })&#xA;        })&#xA;    }&#xA;    var gen = function* () {&#xA;        var f1 = yield readFile(&#39;/etc/fstab&#39;);&#xA;    }&#xA;    function run(gen) {&#xA;        var g = gen();&#xA;        function next(data) {&#xA;            var result = g.next(data);&#xA;            if (result.done) {return result.value;}&#xA;            result.value.then(function(data) {&#xA;                next(data);&#xA;            })&#xA;        }&#xA;        next()&#xA;    }&#xA;    run(gen);&#xA;co, thunkify&#xA;    var readFile = thunkify(fs.readFile);&#xA;    var gen = function* () {&#xA;        var r1 = yield readFile(&#39;/etc/fstab&#39;);&#xA;        var r2 = yiled readFile(&#39;/etc/shells&#39;)&#xA;    }&#xA;    co(gen)&#xA;mixins注解&#xA;    function mixins (...list) {&#xA;        return function (target) {&#xA;            Object.assign(target.prototype, ...list)&#xA;        }&#xA;    }&#xA;    const Foo = {&#xA;        foo() {}&#xA;    }&#xA;    @mixins(Foo)&#xA;    class MyClass()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;全局&#34;&gt;&#xA;  全局&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a8%e5%b1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    Infinity                                # 表示正无穷大&#xA;    NaN                                     # 指示是不是数字, Infinity与NaNECMAScript中可读写， ECMAScript修正为只读, Infinity与NaN与任何值不相等(包括自身), 建议用非来判断&#xA;    undefined&#xA;    console&#xA;        log(&#39;abc %s&#39;, &#39;d&#39;)                  # &#39;abc d&#39;, 格式化输出&#xA;&#xA;方法&#xA;    parseFloat                              # 可以解析整数和浮点数, 跳过前导空格, 忽略后面非数字内容。第一个非空格字符是非法数字直接量时，返回NaN&#xA;    parseInt                                # 只解析整数, 可接收第二个可选参数，指定数字转换基数&#xA;        &amp;quot;0x&amp;quot;, &amp;quot;0X&amp;quot;前缀, 解析为16进制数&#xA;    isNaN&#xA;    isFinite                                # NaN, Infinity 不通过, 非数字报错&#xA;    escape                                  # deprecated since ECMAScript v3&#xA;    decodeURI                               # 不处理 =, &amp;amp; 等&#xA;    decodeURIComponent                      # 会处理 =, &amp;amp; 等&#xA;    encodeURI&#xA;    encodeURIComponent&#xA;    eval                                    # 可以访问调用时的整个作用域，所以编译器不能裁剪作用域, 要间接调用, 如 (0, eval)(src)&#xA;    requestAnimationFrame&#xA;    fetch&#xA;        fetch(url).then(function (request) { return request.arrayBuffer })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;构造函数&#34;&gt;&#xA;  构造函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;包装对象函数&#34;&gt;&#xA;  包装对象函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8c%85%e8%a3%85%e5%af%b9%e8%b1%a1%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基本类型(数字，布尔，字符串)在构建时，会通过new String(s)的方式转换成对象，有了对象的方法，这个过程就是包装对象&#xA;undefined没有包装对象，所以访问属性会造成类型错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    是Object类型, 是基本类型string的包装类型&#xA;        引用字符串类型的属性时,js会调用new String(s)来转换成对象&#xA;            属性引用结束, 该新对象销毁&#xA;            实际上有优化&#xA;包装测试&#xA;    自动包装测试&#xA;        1.toString                          # 异常&#xA;        (1).toString                        # =&amp;gt; &amp;quot;1&amp;quot;&#xA;    原始类型属性只读&#xA;        var s = &amp;quot;test&amp;quot;;&#xA;        s.len = 4;                          # 相当于new String(&amp;quot;test&amp;quot;).len = 4&#xA;        s.len   // undefined                # 相当于new String(&amp;quot;test&amp;quot;).len&#xA;    运算&#xA;        ==                                  # 原始类型与包装类型相等&#xA;        ===                                 # 原始类型与包装类型不相等&#xA;语法&#xA;    ECMAScript 5中，可以用数组方式访问16位值, 如&#xA;        s[0]&#xA;属性&#xA;    length                                  # 4字节的字符会误判为2&#xA;&#xA;静态方法&#xA;    localCompare()                          # 参照本地语言字母表字符次序&#xA;    fromCodePoint()                         # 支持4字节字符值转换, 多参数时合并成字符串&#xA;    raw                                     # 一个tag函数, 转义模板字符串到字符串&#xA;        String.raw`\n${2 + 3}`              # &#39;\\n5&#39;&#xA;        String.raw({raw: &#39;test&#39;}, 0, 1, 2)  # 正常调用时, 第一个参数对象中必要有raw属性，其值为tag函数的第一个字符串数组的参数。其余参数与tag函数其余参数对应&#xA;                &#xA;方法&#xA;    substring(1, 4) // =&amp;gt; 返回第2~4个字符     # 与java不同，java是第1~3个&#xA;    slice(1, 4)&#xA;    indexOf(&amp;quot;&amp;quot;)&#xA;    lastIndexOf(&amp;quot;&amp;quot;)&#xA;    toUpperCase()&#xA;    charAt(0)                               # 取2个字节的字符&#xA;    charCodeAt()                            # 取2个字节字符的十进制值&#xA;    codePointAt()                           # index位的4字节字符当作一个字符，正确处理，得到十进制值, index+1位会取该4字节字符的后2字节, 为了匹配length属性&#xA;    at()                                    # 支持4字节字符, 匹配正确长度的方法&#xA;    fromCharCode()                          # 2字节字符值转换到字符&#xA;    normalize()&#xA;        &#39;\u01D1&#39;.normalize() === &#39;\u004F\u030C&#39;.normalize()&#xA;            原重音符号与 (字符 + 重音)合成符等价&#xA;        不支持3个及以上字符合成&#xA;    includes                                # s.includes(&#39;o&#39;, 6) 从6位置开始搜索o是否出现&#xA;    startsWith&#xA;    endsWith                                # s.endsWith(&#39;o&#39;, 6) 前6个字符是否以o结尾&#xA;    repeat(3)                               # 字符串重复3次返回&#xA;    padStart                                # &#39;x&#39;.padStart(5, &#39;ab&#39;) 返回 &#39;ababx&#39;, padStart(5)会填充空格&#xA;    padEnd&#xA;    正则                                    # es6中内部调用RegExp.prototype[Symbol.match]等方法&#xA;        search(pattern)                     # 返回首次匹配成功的位置&#xA;        match(pattern)                      # 所有匹配位置的数组&#xA;        replace(pattern, &amp;quot;&amp;quot;)                # 所有匹配替换&#xA;        split(pattern)                      # 匹配分割&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;number&#34;&gt;&#xA;  Number&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#number&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    NaN&#xA;    POSITIVE_INFINITY&#xA;    NEGATIVE_INFINITY&#xA;    MAX_VALUE&#xA;    MIN_VALUE&#xA;    EPSILON                                 # 极小的常量 2.22....e-16, 用来设置浮点计算的一个合理误差范围&#xA;    MAX_SAFE_INTEGER                        # 越界最大值&#xA;    MIN_SAFE_INTEGER                        # 越界最小值&#xA;静态方法&#xA;    isFinite&#xA;    isNaN&#xA;    isInteger&#xA;    isSafeInteger                           # 判断是否越界&#xA;    parseInt&#xA;    parseFloat&#xA;        &#xA;方法&#xA;    字符串解析&#xA;        构造方法                            # 只基于十进制转换&#xA;        调用全局函数parseInt(), parseFloat()&#xA;    转换为字符串&#xA;        toString()                          # Number类的toString()可接收转换基数, 来转换进制&#xA;            如 n.toString(2); n.toStrng(8); n.toString(16)&#xA;        toFixed(0)                          # 保留几位小数, 从不使用指数计数法&#xA;        toExponential(1)                    # 转换为指数, 参数为指数前保留几位小数&#xA;        toPrecision(4)                      # 保留有效数字，多出位数转换成指数, 以上三个方法自动补0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;boolean&#34;&gt;&#xA;  Boolean&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#boolean&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;object&#34;&gt;&#xA;  Object&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#object&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    __proto__&#xA;        用来读取或设置当前对象的prototype对象，只有浏览器必须部署这个属性&#xA;        语义上是内部属性，被支持仅因为被广泛使用&#xA;动态方法&#xA;    hasOwnProperty&#xA;         是否有某属性，可判断属性值为undefined的情况&#xA;         没prototype的对象, 该方法直接调用失败，需要Object.prototype.hasOwnProperty.call来调用&#xA;    propertyIsEnumerable&#xA;    isPrototypeOf&#xA;        b.isPrototypeOf(c)                  # b是否出现在c的prototype链中&#xA;    toString&#xA;    toLocaleString&#xA;        返回对象的本地化字符，默认时仅调用toString方法&#xA;        Date和Number对toLocaleString做了定制&#xA;        Array的toLocalString对每个数组元素调用toLocaleString方法&#xA;            toString会对每个数组元素调用toString方法&#xA;    *toJSON&#xA;        Object.prototype没有定义这个方法, JSON.stringigy会调用要序列化对象的toJSON方法,如Date.toJSON()&#xA;    valueOf&#xA;        要将对象转换为原始值时调用&#xA;        如果需要使用原始值的上下文中使用了对象，会自动调用这个方法&#xA;静态方法&#xA;    create                                  # new会执行构造方法，有副作用&#xA;        Object.create(null)                 # 创建的对象没有prototype，不同于{}&#xA;    getPrototypeOf                          # 用于判断继承&#xA;            Object.getPrototypeOf(B) === A&#xA;    getOwnPropertyNames                     # 所有自身属性&#xA;    getOwnPropertyDescriptor(obj, &#39;foo&#39;)    # 获得属性的描述对象&#xA;    getEnumPropertyNames                    # 可枚举自身属性和继承属性&#xA;    setPrototypeOf                          # 标准可靠的方法修改对象prototype的关联&#xA;            Object.setPrototypeOf(Bar.prototype, Foo.prototype)     # 同Bar.prototype = Object.create(Foo.prototype)&#xA;    keys                                    # 可枚举自身属性&#xA;    defineProperty                          # 数据描述符，getter、setter是访问描述符&#xA;        # 修改属性，在原型链上层属性为writable: false或有对应属性的setter时，不会发生屏蔽。使用defineProperty可发生屏蔽&#xA;        Object.defineProperty(Object, &#39;is&#39;, {&#xA;                value: function (x, y) {...},&#xA;                configurable: true,         # false时，delete该属性会静默失败&#xA;                enumerable: false,&#xA;                writable: true,&#xA;                get: function(){return 1}&#xA;        })&#xA;    toLocaleString&#xA;    toString                                # toString(16) 转换为16进制&#xA;    is(&#39;foo&#39;, &#39;foo&#39;)                        # 比较两个值是否相等, 基本是===，不同在于, +0 等于 -0, NaN 等于 NaN&#xA;    assign(target, source1, source2)&#xA;        复制源对象自身可枚举属性到目标对象, source2覆盖source2覆盖target&#xA;        Symbol值的属性也会被拷贝&#xA;        _.defaultsDeep方法可以深拷贝&#xA;        常用于给对象添加静态方法或方法，合并对象，为属性指定默认值&#xA;            Object.assign({}, DEFAULTS, options);&#xA;    preventExtensions                       # 使对象不可设置属性&#xA;    isExtensible&#xA;    seal                                    # 创建“密封”对象, 在现有对象上调用preventExtensions并把现在属性标记为configurable: false&#xA;    freeze                                  # 调用seal并标记现有属性为writable: false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;array&#34;&gt;&#xA;  Array&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#array&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;静态方法&#xA;    isArray(a)                              # ECMAScript 5 判断是否数组&#xA;            [] instanceof Array的问题&#xA;                多frame中有多个js环境, 都有自己的全局对象与构造函数。一个窗体中的对象是当前窗体构造函数创建，而另外窗体构造函数判断该对象则不成立。&#xA;                    # 但窗体间的混淆不常发生&#xA;            ECMAScript 3 可以检查对象类属性来判断。&#xA;                # 实际上就是ECMAScript 5中Array.isArray的代码&#xA;                var isArray = Array.isArray || function(o){&#xA;                    return typeof o === &amp;quot;ojbect&amp;quot; &amp;amp;&amp;amp; Object.prototype.toString.call(o) == &amp;quot;[object Array]&amp;quot;&#xA;                };&#xA;    from&#xA;        # 类数组对象或可遍历对象(如Set, Map)转为数组，转换后的数组具有了iterator接口&#xA;        # 类数组对象同[].slice.call(arraylike), 可遍历对象同[...traversable]&#xA;        Array.from(arraylike)&#xA;        Array.from([1, , 2, , 3], (n) =&amp;gt; n || 0)&#xA;        Array.from(&#39;abc&#39;)&#xA;            # 字符串转数组&#xA;        Array.from(new Set(array))&#xA;            # 去除重复元素&#xA;    of&#xA;        # 一组值转换为数组, 用于替代Array(), new Array()&#xA;        # 弥补Array()的返回不一致问题, 如Array(3) // [, , ,]&#xA;        Array.of(1, 2, 3)        // [1, 2, 3]&#xA;动态方法&#xA;    join, ...                               # firefox1.5 后 动态方法也写入到了静态方法中。但不是标准, 是String.split()的逆向操作&#xA;        a.join()                                // =&amp;gt; &amp;quot;1,2,3&amp;quot;&#xA;        a.join(&amp;quot;&amp;quot;)                        // =&amp;gt; &amp;quot;123&amp;quot;&#xA;        new Array(2).join(&#39;-&#39;)                // =&amp;gt; &amp;quot;--&amp;quot;&#xA;    reverse                                 # 倒序&#xA;        a.reverse()&#xA;    sort                                    # 排序&#xA;        a.sort()                            # 默认以字母表排序, 自动转字符串 undefined排到最后&#xA;        a.sort(function(a, b){&#xA;            return a-b;                     # a在前, 返回负数。b在前返回正数。0表示相等，顺序无关紧要, 此处是升序排列&#xA;        })&#xA;    concat                                  # 连接数组, 创建返回一个新数组, 传入数组, 连接数组元素而非本身, 但不扁平化数组的数组&#xA;        a.concat(4, [5, [6, 7]])&#xA;    slice                                   # 截取新数组&#xA;        var a = [1,2,3,4,5]&#xA;        a.slice(0,3)    // 返回 [1,2,3]&#xA;        a.slice(3)      // 返回 [4,5]&#xA;        a.slice(1, -1)  // 返回 [2,3,4]&#xA;        a.slice(-3, -2) // 返回 [3]&#xA;    splice                                  # 修改数组&#xA;        第一个参数起始位置(包含), 第二个参数删除个数(省略则从起始到结束都删除)&#xA;        后面任意个参数指定插入到数组中的元素&#xA;        返回由删除元素组成的数组&#xA;    push 和 pop                              # 数组作为栈(先进后出)来用, push在结尾添加, pop在结尾删除, 插入元素时不解封数组&#xA;    unshift 和 shift                         # unshift在头部添加元素, shift在头部删除。都改变索引, 插入元素时不解封数组&#xA;    toString                                # 调用每个元素的toString()方法, 输出有逗号分隔的字符串列表(没有方括号), 与不使用任何参数的join()是一样的&#xA;    toLocaleString                          # 调用元素的toLocaleString&#xA;    copyWithin                              # 当前数组中复制一段到另一位置&#xA;        [1, 2, 3, 4, 5].copyWithin(0, 3)        // [4, 5, 3, 4, 5]&#xA;            # 第三个参数是结束位置(不包含), 默认是结尾。把4, 5 复制替换到1, 2&#xA;        [1, 2, 3, 4, 5].copyWithin(0, -2, -1)        // [4, 2, 3, 4, 5]&#xA;            # 4到5(不包含)复制到1&#xA;    find                                    # 返回第一个符合条件的元素, 没有时返回undefined, 可处理NaN, 第二个参数绑定回调函数的this对象&#xA;        [1, 4, -5, 10].find((n) =&amp;gt; n &amp;lt; 0)&#xA;    findIndex                               # 返回第一个符合条件的index, 没有时返回-1&#xA;    fill                                    # 用某元素填充数组, 可标识起始位置&#xA;        [1, 2, 3].fill(0)        // [0, 0, 0]&#xA;        [1, 2, 3].fill(0, 1, 2)        // [1, 0, 3]&#xA;    includes                                # 是否包含元素，可识别NaN, 返回布尔值, 第二个参数表示起始位置, indexOf 使用===判断, 会对NaN误判&#xA;            [1, 2, 3].includes(2, 0)&#xA;&#xA;    遍历类方法&#xA;        对稀疏数组，不存在的元素不调用传递的回调函数&#xA;        方法第一个参数是回调函数, 第二个参数是回调函数的this&#xA;        多数情况下, 传入的回调函数传递三个参数: 数组元素, 元素的索引, 数组本身&#xA;        forEach                             # 没有break语句，用抛出异常替代&#xA;            a.forEach(function(value){})&#xA;                function foreach(a, f, t){&#xA;                try{a.forEach(f, t);}&#xA;                catch(e){&#xA;                    if(e === foreach.break) return;&#xA;                    else throw e;&#xA;                }&#xA;            }&#xA;            foreach.break = new Error(&amp;quot;StopIteration&amp;quot;);&#xA;        map                                 # 映射数组元素, 稀疏数组也返回相同的缺失元素&#xA;            [1,2,3].map(function(x){return x * x})  // 返回 [1, 4, 9]&#xA;        filter                              #  回调返回true的元素保留，返回新数组, 返回的数组总是稠密的，可用于压缩空缺并删除undefined 和 null元素&#xA;            [5, 4, 3, 2, 1].filter(function(x){ return x &amp;lt; 3}) // 返回 [2, 1]&#xA;        every和some&#xA;            every表示所有, 在都返回true时返回true&#xA;            some表示存在, 都返回false时返回false&#xA;                在确定返回值时停止遍历&#xA;            a.some(func)&#xA;        reduce和reduceRight                  # 使用指定函数将数组元素进行组合，称为&amp;quot;注入&amp;quot;和&amp;quot;折叠&amp;quot;&#xA;            a.reduce(function(x, y){ return x + y}, 0)&#xA;                第一个是回调函数。第二个可选，是初始值，无初始值时一开始直接传入第一第二个元素&#xA;                    回调函数中第一个是累积的结果, 第二个是当前元素&#xA;                空数组无初始值调用会导致类型错误异常。&#xA;                只有一个值并没有初始值时, reduce只简单抬这个值&#xA;            reduceRight同reduce，但索引从高到低处理数组&#xA;        indexOf和lastIndexOf&#xA;            搜索数组元素, 返回第一个匹配元素的索引, 失败则返回 -1&#xA;                indexOf从前往后, lastIndexOf从后往前&#xA;            第二个参数可选，指定起始索引。负索引代表相对末尾的偏移量&#xA;            字符串也有indexOf和lastIndexOf, 针对每个字符&#xA;    返回遍历器&#xA;            entries&#xA;                for(let [ind, ele] of [&#39;a&#39;, &#39;b&#39;].entries()) {}&#xA;                    # 得到 0 &#39;a&#39;, 1 &#39;b&#39;&#xA;                    # 不用for of , entriesIterator.next().value        // [0, &#39;a&#39;]&#xA;            keys&#xA;            values&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;function&#34;&gt;&#xA;  Function&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#function&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    var f = new Function(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;return x*y;&amp;quot;);&#xA;        # 任意数量实参。最后一个实参是函数体，语句间用分号隔开&#xA;        # 创建一个匿名函数&#xA;特点&#xA;    允许js在运行时动态创建并编译函数&#xA;    每次调用，都解析函数体并创建新函数对象，效率低&#xA;        # 循环中嵌套函数和函数定义表达式不会每次都重新编译&#xA;    总在全局作用域创建，可以认为其构造函数是全局作用域中执行eval()&#xA;函数体代码内&#xA;    arguments&#xA;        callee&#xA;        caller                              # 调用栈的上层函数, 出于安全考虑，大部分编译器已不支持caller, 用非标准的 fn.caller来取代, fn为当前函数名&#xA;属性&#xA;    length&#xA;        只读属性，代表函数形参数量。不包含设置了默认值的形参，也不包含...rest参数&#xA;        arguments.length是实际实参个数, arguments.callee.length是期望实参个数, 同本length&#xA;    name&#xA;        函数名, es5中只支持具名函数如function a(){}, es6支持var a = function(){}&#xA;        (new Function).name        // &#39;anonymous&#39;&#xA;        foo.bind({}).name        // &#39;bound foo&#39;&#xA;    prototype                               # 指向原型对象(prototype object)，从该函数创建对象时，从原型对象上继承属性&#xA;&#xA;方法&#xA;    call(o, 1, 2)                           # 传入可变调用时参数&#xA;    apply(o, [1, 2])                        # 传入调用时参数数组或类数组对象, 这样可以将arguments数组直接传入另一个函数来调用&#xA;        ECMAScript 严格模式中，o传入什么,this就是什么。其它情况下，o为null或undefined时替换为顶级对象，原始值会被包装。&#xA;    bind(o, ...)&#xA;        ECMAScript 5新增方法。在函数a上调用bind, 传入对象o，反回以o调用a的新函数b&#xA;            bind返回的是一个闭包, 返回的函数不包含prototype属性&#xA;            普通函数固有的prototype属性是不能删除的&#xA;            除第一个实参外，其它实参按顺序绑定到调用bind函数f的实参上，称为柯里化(currying), 如&#xA;            f = function(x, y); ff = f.bind(o, 1); ff(2);        // 此时x绑定为1, y传入为2&#xA;            ECMAScript 5中的bind, 返回的函数对象的length属性，值是返回函数的形参个数减其实参个数&#xA;            返回的函数可以用作构造函数，此时以原始函数的形式调用作为构造函数(实参也会原封不动地传入)&#xA;                用作构造函数时, 使用原始函数的prototype&#xA;    toString()&#xA;        ECMAScript规定返回和函数声明语法相关的字符串&#xA;        大多数toString()方法返回函数的完整源码，内置函数往往返回类似&amp;quot;[native code]&amp;quot;的字符串作函数体&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;date&#34;&gt;&#xA;  Date&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#date&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;var now = new Date()&#xA;var then = new Date(2011, 0, 1)&#xA;var later = new Date(2011, 0, 1, 17, 10, 30)&#xA;var elapsed = now - then;&#xA;&#xA;now.setMonth(now.getMonth - 1);&#xA;方法&#xA;    getFullYear()&#xA;    getMonth()&#xA;    getDate()&#xA;    getDay()&#xA;    getHours()&#xA;    getUTCHours()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;error&#34;&gt;&#xA;  Error&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#error&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;regexp&#34;&gt;&#xA;  RegExp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#regexp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new RegExp(&#39;xyz&#39;, &#39;i&#39;); // /xyz/i&#xA;    new RegExp(/abc/ig, &#39;i&#39;) // /abc/i&#xA;修饰符&#xA;    i&#xA;    g                                       # 全局多次匹配, 下次匹配从剩余中重新开始&#xA;    u                                       # 正确处理4字节字符, 存在u修饰符时, /\u{61}/可以表示unicode字符, 否则会匹配61个连续的u&#xA;    y                                       # 粘连，基本同g，不同在于剩余第一个字符开始必须匹配上, 确保匹配之间不会有漏掉的字符&#xA;        var s = &#39;aaa_aa_a&#39;, r1 = /a+/g, r2 = /a+/y;&#xA;        r1.exec(s), r2.exec(s)              # [&#39;aaa&#39;] [&#39;aaa&#39;]&#xA;        r1.exec(s), r2.exec(s)              # [&#39;aa&#39;] null&#xA;属性&#xA;    flags                                   # 修饰符&#xA;    lastIndex                               # 从这个index开始匹配&#xA;    sticky                                  # 是否设置了y字符&#xA;静态方法&#xA;        &#xA;方法&#xA;    test&#xA;        /\d+/g.test(&amp;quot;testing: 1, 2, 3&amp;quot;)&#xA;    exec                                    # 返回带有特殊属性的Array match&#xA;        match&#xA;            属性&#xA;                index&#xA;                    # 在index上匹配成功&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;set&#34;&gt;&#xA;  Set&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#set&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new Set()&#xA;    new Set([1, 2, 3])&#xA;属性&#xA;    size                                    # Set实例成员数&#xA;方法&#xA;    add(x)&#xA;    delete(x)&#xA;    has(x)                                  # 是否有x&#xA;    clear()                                 # 清除所有成员&#xA;    keys()&#xA;    values()                                # values同keys完全一致, 返回遍历器&#xA;    entries()                               # 返回[key, key]的遍历器&#xA;    forEach(function (value, key, obj) {}, boundThis)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;weakset&#34;&gt;&#xA;  WeakSet&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#weakset&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new WeakSet()&#xA;    new WeakSet([1, 2, 3])                  # 任何可遍历对象&#xA;属性                                         # 没有size&#xA;方法&#xA;    add(x)&#xA;    delete(x)&#xA;    has(x)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;map&#34;&gt;&#xA;  Map&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#map&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new Map()&#xA;    new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2]])&#xA;属性&#xA;    size&#xA;方法&#xA;    set(key, value)&#xA;    get(key)&#xA;    delete(key)&#xA;    has(key)&#xA;    clear()&#xA;    keys()&#xA;    values()&#xA;    entries()                               # map[Symbol.iterator] === map.entries&#xA;    forEach(function(value, key, map) {}, boundThis)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;weakmap&#34;&gt;&#xA;  WeakMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#weakmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    get&#xA;    set&#xA;    delete&#xA;    has&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;proxy-1&#34;&gt;&#xA;  Proxy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#proxy-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;new Proxy(target, handlers)                 # target表示要拦截的对象, handler是回调方法&#xA;拦截器&#xA;    get(target, propKey, receiver)          # 属性读取。propKey是属性名, receiver是继承该proxy的对象&#xA;    set(target, propKey, value, receiver)   # 属性设置&#xA;    has(target, propKey)                    # in操作，返回布尔值&#xA;    deleteProperty(target, propKey)         # delete操作，返回布尔值&#xA;    enumerate(target)                       # for in , 返回遍历器&#xA;    ownKeys(target)                         # Object.getOwnPropertyNames, Object.getOwnPropertySymbols, Object.keys, 返回数组&#xA;    getOwnPropertyDescriptor(target, propKey)                       # Object.getOwnPropertyDescriptor, 返回描述对象&#xA;    defineProperty(target, propKey, propDesc)                       # Object.defineProperty, Object.defineProperties, 返回布尔值&#xA;    preventExtensions(target)               # Object.preventExtensions, 返回布尔值&#xA;    getPrototypeOf(target)                  # Object.getPrototypeOf, 返回对象&#xA;    isExtensible(target)                    # Object.isExtensible, 返回布尔值&#xA;    setPrototypeOf(target, proto)           # Object.setPrototypeOf, 返回布尔值&#xA;    apply(target, object, args)             # 拦截proxy作为函数调用的操作, 如proxy(), proxy.call, proxy.apply&#xA;    construct(target, args, proxy)          # 拦截proxy作用构造函数的操作, 如new proxy&#xA;静态方法&#xA;    revocable(target, handler)              # 返回有proxy, revoke属性的对象实例, proxy是Proxy实例, 调用revoke()函数可以取消Proxy&#xA;        et {proxy, revoke} = Proxy.revocable({}, {})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;arraybuffer&#34;&gt;&#xA;  ArrayBuffer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#arraybuffer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var buf = new ArrayBuffer(32)           # 生成32字节的内存区域，每个字节默认值为0&#xA;    if(buf.byteLength === 32)               # 由于内存可能不够大，要检查是否分配成功&#xA;属性&#xA;    byteLength                              # 内存区字节长度&#xA;方法&#xA;    slice(0, 3)                             # 拷贝前3个字节，生成新的ArrayBuffer&#xA;    isView(v)                               # 检查某视图是否为该buf的视图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;typedarray&#34;&gt;&#xA;  (TypedArray)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#typedarray&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;9种类型数组&#xA;    Int8Array&#xA;    Uint8Array&#xA;    Uint8ClampedArray                       # 自动过滤溢出。用于处理图像颜色, 只取值0 - 255, 过滤掉高位, ie10不支持该类型&#xA;    Int16Array&#xA;    Uint16Array&#xA;    int32Array&#xA;    Uint32Array&#xA;    Float32Array&#xA;    Float64Array&#xA;构造&#xA;    var x1 = new Int32Array(buf)&#xA;        带符号整形方式读buf&#xA;        new Int32Array(buf, 2, 2) 开始于字节2, 长度为2(2 * 32bit)。第3个参数不填则到末尾&#xA;            开始字节数要符合视图类型, 如16位类型视图单位是2个字节, 不能从1字节开始, 否则将报错&#xA;            用于构建复合视图&#xA;    x1[0] = 1;                              # 第0位4个字节赋值&#xA;    var x2 = new Uint8Array([0, 1, 2])      # 数组会直接分配内存生成ArrayBuffer&#xA;    new Float64Array(8)                     # 直接分配8字节生成ArrayBuffer来创建视图&#xA;    new Int8Array(new Uint8Array(4))        # 会开辟新的ArrayBuffer，复制原有数据来建立视图&#xA;        new Int8Array(new Uint8Array(4).buffer)可以用同一个buffer&#xA;属性&#xA;    length&#xA;    BYTES_PRE_ELEMENT                       # 表示当前数据类型占用的字节数&#xA;    buffer                                  # 该视图的ArrayBuffer对象&#xA;    byteLength                              # 该视图中buffer占内存的长度，是只读属性&#xA;    byteOffset                              # 该视图从哪个字节开始, 只读属性&#xA;静态方法&#xA;    of                                      # 将参数转为TypedArray实例&#xA;    from                                    # 可遍历数据转TypedArray, 可将TypedArray转为另一种TypedArray。可以接map函数&#xA;        Int16Array.from(Int8Array.of(1, 2, 3), x =&amp;gt; 2 * x)&#xA;方法                                        # 没有concat方法&#xA;    set                                     # 复制数组，整段内存覆盖&#xA;        b.set(a, 2)                         # 从b的index2开始复制a&#xA;    subarray                                # 建立新视图&#xA;        a.subarray(2, 3)                    # 从index2复制到index3(不包含), 参数2不填默认复制到结尾&#xA;    slice&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dataview&#34;&gt;&#xA;  DataView&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dataview&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new DataView(buf)                       # DataView(ArrayBuffer buffer [, startIndex [, length]])&#xA;属性&#xA;    buffer&#xA;    byteLength&#xA;    byteOffset&#xA;方法&#xA;    getInt8(0, true)                        # 以带符号整形格式读第0个字节, 第二个参数默认false, 使用大端字节序解读(两个或以上字节的数据需要), 设置true则为小端字节序&#xA;    getUint8&#xA;    getInt16&#xA;    getUint16&#xA;    getInt32&#xA;    getUint32&#xA;    getFloat32&#xA;    getFloat64&#xA;    setUint8(0, 1, true)                    # 开始序号, 数据, 小端字节序&#xA;    setInt16&#xA;    setUint16&#xA;    setInt32&#xA;    setUint32&#xA;    setFloat32&#xA;    setFloat64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;websocket&#34;&gt;&#xA;  WebSocket&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#websocket&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new WebSocket(&#39;ws://127.0.0.1:8081&#39;)&#xA;属性&#xA;    binaryType                              # 设置成&#39;arraybuffer&#39;来接收和发送arraybuffer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;filereader&#34;&gt;&#xA;  FileReader&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#filereader&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var fileInput = document.getElementById(&#39;fileInput&#39;);&#xA;    var file = fileInput.files[0];&#xA;    var reader = new FileReader();&#xA;    reader.readAsArrayBuffer(file);&#xA;    reader.onload = function () { var arrayBuffer = reader.result; }&#xA;    或&#xA;    reader.addEventListener(&#39;load&#39;, processimage, false);&#xA;    function processimage(e) { var buffer = e.target.result; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;promise-1&#34;&gt;&#xA;  Promise&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#promise-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var promise = new Promise(function (resolve, reject) {resolve(0); /* reject(err)*/})&#xA;方法&#xA;    then(func1, func2, func3)               # func1对就fulfilled回调, func2对应rejected回调, func3用于处理进度信息&#xA;    catch                                   # 是then(null, rejection)的别名，尽量使用catch而非then(null, rejection), 这样看起来更接近同步写法&#xA;静态方法&#xA;    all([p1, p2, p3])                       # 成员不是promise对象时，先promise.resolve(data), 全部完成, fullfilled。一个rejected, rejected, 返回第一个reject的错误&#xA;    race([p1, p2, p3])                      # 一个完成, fullfiled, 返回该promise&#xA;        Promise.race([p1, new Promise((resolve, reject) =&amp;gt; {&#xA;            setTimeout(() =&amp;gt; reject(new Error(&#39;time out.&#39;)), 5000)&#xA;        })])&#xA;    resolve&#xA;    reject&#xA;    done                                    # 不在规范内, 总是在回调链尾端, 保证抛出任何可能出现的错误&#xA;    finally                                 # 不在规范内, 接受一个回调函数，永远执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;全局对象&#34;&gt;&#xA;  全局对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a8%e5%b1%80%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;顶级全局对象&#34;&gt;&#xA;  顶级全局对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a1%b6%e7%ba%a7%e5%85%a8%e5%b1%80%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    js代码最外层的this&#xA;    初始化时, 定义所有预定义全局值&#xA;    代码中定义的全局变量，实际是该对象的属性&#xA;Global&#xA;Window&#xA;    介绍&#xA;        初始化时定义了一部分其他全局属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;math&#34;&gt;&#xA;  Math&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#math&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    PI&#xA;    E                                       # 自然对数底数&#xA;    LN10                                    # 同Math.log(10), 表示以e为低10的对数, Math.log(100)/Math.LN10 消底后表示以10为底100的对数&#xA;    LN2&#xA;静态方法&#xA;    trunc                                   # 去除小数部分&#xA;    sign                                    # 判断正负或零&#xA;    exp                                     # e的x次方&#xA;    log                                     # x的自然对数&#xA;    cbrt                                    # 立方根, 同Math.pow(Math.abs(x), 1/3)&#xA;    clz32&#xA;        二进制下32位无符号整数有多少个前导0。小数会取floor&#xA;            count leading zero bits in 32-bit binary representations of a number&#xA;        Math.clz32(1000)        // 22&#xA;        Math.clz32(1000 &amp;lt;&amp;lt; 1)        // 21&#xA;    imul                                    # 32位带符号整数的乘积, 在乘积越界时会返回正确的低位数值&#xA;    fround                                  # 返回一个数的单精度浮点数表示, 4位无法精确表示的小数，会返回最接近的数, 同new Float32Array([x])[0]&#xA;        Math.fround(1.337);        // 1.337000012...&#xA;    hypot                                   # 所有参数平方和的平方根&#xA;    expm1                                   # 返回Math.exp(x) - 1&#xA;    log1p                                   # 返回Math.log(1 + x)&#xA;    log10                                   # 返回以10为低x的对数, 同 Math.log(x) / Math.LN10&#xA;    log2&#xA;    sinh                                    # 双曲正弦 hyperbolic sine&#xA;    cosh                                    # 双曲余弦 hyperbolic cosine&#xA;    tanh                                    # 双曲正切 hyperbolic tangent&#xA;    asinh                                   # inverse hyperbolic sine&#xA;    acosh&#xA;    atanh&#xA;方法&#xA;    pow(x, y)                               # x的y次方, pow(x, 1/3) 表示立方根&#xA;    round(.6)                               # 四舍五入&#xA;    ceil(.6)                                # 向上求整&#xA;    floor(.6)                               # 向下求整&#xA;    abs(-5)                                 # 绝对值&#xA;    max(x, y)                               # 最大值&#xA;    min(x, y)                               # 最小值&#xA;    random()                                # &amp;gt;=0, &amp;lt; 1.0的伪随机数&#xA;    sqrt(3)                                 # 平方根&#xA;    sin(0)&#xA;    log(10)                                 # 自然对数&#xA;    exp(3)                                  # e的3次幂&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;json&#34;&gt;&#xA;  JSON&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#json&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    parse(str)&#xA;    stringify(obj)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reflect-1&#34;&gt;&#xA;  Reflect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reflect-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;静态方法&#xA;    ownKeys(target)                         # 返回对象自身所有属性&#xA;    enumerate(target)                       # 返回Iterator，遍历对象自身和继承的所有可枚举属性, 同for ... in&#xA;    apply(target, thisArg, args)&#xA;    construct(target, args)&#xA;    get(target, name, receiver)&#xA;    set(target, name, value, receiver)&#xA;    defineProperty(target, name, desc)&#xA;    deleteProperty(target, name)&#xA;    has(target, name)&#xA;    isExtensible(target)&#xA;    preventExtensions(target)&#xA;    getOwnPropertyDescriptor(target, name)&#xA;    getPrototypeOf(target)&#xA;    setPrototypeOf(target, prototype)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;symbol&#34;&gt;&#xA;  Symbol&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#symbol&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    hasInstance                             # Obj[Symbol.hasInstance]方法在instanceof运算时调用，如Foo[Symbol.hasInstance](foo)&#xA;    isConcatSpreadable                      # arr.concat时是否要展开&#xA;        let arr = [1, 2], arr[Symbol.isConcatSpreadable] = false,&#xA;        [&#39;a&#39;, &#39;b&#39;].concat(arr, &#39;c&#39;)        // [&#39;a&#39;, &#39;b&#39;, [1, 2], &#39;c&#39;]&#xA;    species                                 # 如果this.constructor[Symbol.species]存在, 用它来做构造函数&#xA;    match                                   # str.match(obj)时, 调用obj[Symbol.match](str)&#xA;    replace                                 # str.replace(s, r)时, 调用s[Symbol.replace](s, r)&#xA;    search                                  # str.search(obj)时，调用obj[Symbol.search](str)&#xA;    split                                   # str.split(separator, limit)时, 调用separator[Symbol.split](str, limit)&#xA;    iterator&#xA;        for ... of指向调用的默认遍历器&#xA;        function A {*[Symbol.iterator] () {&#xA;            let i = 0; while(this[i] != undefined) {yield this[i]; i++;}&#xA;        }}&#xA;    toPrimitive                             # 对象转原始类型值时调用&#xA;        {[Symbol.toPrimitive] (hint) {}}        // hint值有 &#39;number&#39;, &#39;string&#39;, &#39;default&#39;&#xA;    toStringTag&#xA;        toString时拼在后面, 如 &#39;[object xxx]&#39;&#xA;    unscopables&#xA;        排除with时的属性, Array.prototype[Symbol.unscopables]        // {copyWithin: true, ...}&#xA;&#xA;方法&#xA;    s.toString()        // &#39;Symbol(foo)&#39;    # 可以String(s) 得到字符串&#39;Symbol(foo)&#39;&#xA;静态方法&#xA;    for(&#39;foo&#39;)                              # 搜索以&#39;foo&#39;作参数登记的Symbol值, 没有时会新建、登记并返回, 这种登记是全局的&#xA;    keyFor(s)                               # 返回s登录的字符串，没有时返回undefined&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;dom&#34;&gt;&#xA;  dom&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dom&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;window对象&#34;&gt;&#xA;  window对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#window%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;document&#34;&gt;&#xA;  document&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#document&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    id&#xA;    innerHTML                               # 非标准但通用&#xA;    body&#xA;        方法&#xA;            appendChild(domElement)&#xA;方法&#xA;    getElementById(&amp;quot;&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;element&#34;&gt;&#xA;  element&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#element&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    innerHTML&#xA;    style&#xA;        display = &amp;quot;none&amp;quot;&#xA;        visibility = &amp;quot;hidden&amp;quot;&#xA;    className&#xA;方法&#xA;    createElement(&amp;quot;div&amp;quot;)&#xA;    createTextNode(msg)&#xA;    appendChild(ele)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;xmlhttprequest&#34;&gt;&#xA;  XMLHttpRequest&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xmlhttprequest&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;var req = new XMLHttpRequest()&#xA;方法&#xA;    open(&amp;quot;GET&amp;quot;, url)&#xA;    send(null)                              # null表示不带正文地发送这个请求&#xA;    onreadystatechange = function(){        # 重写回调函数&#xA;        if(req.readyState == 4 &amp;amp;&amp;amp; req.status == 200){&#xA;            var text = req.responseText;    # 响应的字符串&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;localstorage&#34;&gt;&#xA;  localStorage&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#localstorage&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;worker&#34;&gt;&#xA;  Worker&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#worker&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    it is a javascript running in the background, without affecting the performance of the page.&#xA;    dom中的js线程在执行时会阻塞&#xA;使用&#xA;    var w;&#xA;    // start worker&#xA;    function startWorker(){&#xA;        if(typeof(Worker) !== &#39;undefined&#39;){&#xA;            if(typeof(w) == &#39;undefined&#39;){&#xA;                w = new Worker(&#39;demo_workers.js&#39;);&#xA;            }&#xA;            w.onmessage = function(event){&#xA;                ＃ worker &#39;s api, will call postMessage()&#xA;                document.getElementById(&#39;result&#39;).innerHTML = event.data;&#xA;            };&#xA;        }else {&#xA;            document.getElementById(&#39;result&#39;).innerHTML = &#39;sorry, your browser does not support Web Workers...&#39;;&#xA;        }&#xA;    }&#xA;    // stop worker&#xA;    w.terminate();                                                        ＃ worker &#39;s api, will trigger w.onmessage();&#xA;    w = undefined;&#xA;&#xA;    /* demo_workers.js */                                            # 外部的js文件不能访问window, document, parent对象&#xA;    var i = 0;&#xA;    function timeCount(){&#xA;        i = i + 1;&#xA;        postMessage(i);                                            # worker &#39;s api, when onmessage() was triggered.&#xA;        setTimeout(&#39;timeCount()&#39;, 500);&#xA;    }&#xA;    timedCount();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;eventsource&#34;&gt;&#xA;  EventSource&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eventsource&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    浏览器推送&#xA;事件&#xA;    onopen&#xA;    onmessage&#xA;    onerror&#xA;使用&#xA;    var source = new EventSource(&amp;quot;demo_sse.php&amp;quot;);&#xA;    source.onmessage = function(event){&#xA;        document.getElementById(&#39;result&#39;).innerHTML += event.data + &#39;&amp;lt;br/&amp;gt;&#39;;&#xA;    };&#xA;    // demo_sse.php&#xA;    &amp;lt;?php&#xA;    header(&#39;Content-Type: text/event-stream&#39;);&#xA;    header(&#39;Cache-Control: no-cache&#39;);&#xA;&#xA;    $time = date(&#39;r&#39;);&#xA;    echo &amp;quot;data: The server time is: {$time}\n\n&amp;quot;;&#xA;        # data在上面event.data中引用&#xA;    flush();&#xA;    ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;控件&#34;&gt;&#xA;  控件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;activexobject&#34;&gt;&#xA;  ActiveXObject&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#activexobject&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;new ActiveXObject(&amp;quot;Excel.Application&amp;quot;);         # Microsoft.XMLHTTP, ie中适用&#xA;Server.CreateObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;)        # 在chrome中不起作用, 可以用 new XMLHttpRequest()创建&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;canvas&#34;&gt;&#xA;  canvas&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#canvas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    原点: canvas左上角&#xA;    默认Style为black&#xA;    颜色设定&#xA;        &amp;quot;red&amp;quot; &amp;quot;blue&amp;quot;&#xA;        &amp;quot;#EEEEFF&amp;quot;&#xA;        &amp;quot;rgb(1-255, 1-255, 1-255)&amp;quot;&#xA;        &amp;quot;rgba(1-255, 1-255, 1-255, 0-1)&amp;quot;&#xA;    路径&#xA;        可以被填充多个轮廓或图形的操作。&#xA;基本使用&#xA;    var context =canvas.getContext(&amp;quot;2d&amp;quot;);&#xA;&#xA;    context.fill()//填充&#xA;    context.stroke()//绘制边框&#xA;    context.lineWidth//图形边框宽度&#xA;&#xA;    context.fillStyle//填充的样式&#xA;    context.strokeStyle//边框样式&#xA;绘制&#xA;    矩形&#xA;        content.fillRect(x, y, width, height)&#xA;        strokeRect(x, y, width, height)         # x, y是起点坐标, width, height为宽和高&#xA;    清除矩形区域&#xA;        context.clearRect(x,y,width,height)&#xA;    圆弧&#xA;        context.arc(x, y, radius, startAngle,endAngle, anticlockwise)&#xA;            x, y是圆心坐标, radius是半径, startAngle, endAngle是开始、结束弧度, anticlockwise=false时顺时针画圆&#xA;            一刻钟是零度, 弧度可以用Math.PI来表示&#xA;例子&#xA;    矩形&#xA;        context.fillRect(0, 120, 100, 100);&#xA;        context.strokeRect(120, 120, 100, 100);&#xA;        context.clearRect(50, 50, 240, 120);&#xA;    圆弧&#xA;        context.beginPath();&#xA;        ctx.arc(100,75,50,0,1.3 * Math.PI, false);&#xA;        context.closePath();&#xA;        context.fill();                         # 或ctx.stroke()画线, fill()填充开始点与结束点的连线&#xA;image&#xA;    var image = ctx.getImageData(0, 0, 256, 256);                   # 取画布矩形区域的图像&#xA;    ctx.putImageData(image, 10, 70)             # 把图像复制到画布的一个起点&#xA;    例子&#xA;        var c=document.getElementById(&amp;quot;myCanvas&amp;quot;);&#xA;        var ctx=c.getContext(&amp;quot;2d&amp;quot;);&#xA;        var imgData=ctx.createImageData(100,100);&#xA;        for (var i=0;i&amp;lt;imgData.data.length;i+=4)                    # 一个像素有4个值RGB + alpha, alpha=255表示不透明&#xA;        {&#xA;            imgData.data[i+0]=255;&#xA;            imgData.data[i+1]=0;&#xA;&#xA;            imgData.data[i+2]=0;&#xA;            imgData.data[i+3]=255;&#xA;        }&#xA;        ctx.putImageData(imgData,10,10);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;优化&#34;&gt;&#xA;  优化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;canvas.width = canvas.width                     # 一种巧妙的方法清除并重置画布&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;webgl&#34;&gt;&#xA;  webgl&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#webgl&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    由Khronos Group维护                          # 还维护了OpenGL和COLLADA&#xA;    使用OpenGL渲染语言GLSL ES&#xA;    WebGL是在浏览器中实现三维效果的一套规范&#xA;    webgl通过增加openGL es 2.0的一个js绑定, 把它们结合在一起&#xA;    webgl可以为html5 canvas提供硬件3d加速渲染&#xA;        更流畅地展示3d场景和模型&#xA;        创建复杂的导航和数据视觉化&#xA;名词&#xA;    科纳斯组织       Khronos Group&#xA;    GLSL ES         OpenGL Shading Language Embedded System&#xA;    网格          Mesh&#xA;    模型          model&#xA;    纹理映射        texture map&#xA;    材质          material&#xA;    光源          light&#xA;    变换          transform&#xA;    相机          camera&#xA;    视口          viewport&#xA;    投影矩阵       projection matrix&#xA;    视锥体         view volume&#xA;    视平截头体      view frustum&#xA;    着色器         shader&#xA;    图元          primitive&#xA;    三角形带        triangle strip&#xA;    类型化数组       typed array&#xA;    模型视图矩阵      modelview matrix&#xA;    投影矩阵        projection matrix&#xA;    顶点着色器        vertex shader&#xA;    片元着色器        fragment shader&#xA;    像素着色器        pixel shader, 同fragment shader&#xA;    自发光         unlit&#xA;    预置光照        prelit&#xA;    镜面高光        specular highlights&#xA;    镜面反射        specular reflection&#xA;    alpha混合        alpha blending&#xA;    变换层级        transform hierarchy&#xA;    帧动画         frame-based animation&#xA;    补间动画        tweening&#xA;    关键帧         keyframe&#xA;    关键帧动画       keyframe animation&#xA;    插值          interpolation&#xA;    线性插值        linear interpolation&#xA;    关节动画        articulated animation&#xA;    蒙皮动画        skinned animation&#xA;    骨骼          skeleton&#xA;    目标变形动画      morph target animation&#xA;    程序贴图        procedural texture&#xA;    纹理变换        texture transform&#xA;    拾取          picking&#xA;    面法线        face normal&#xA;    程序贴图        procedural texture&#xA;    多级渐进纹理过滤        mipmapping / mipmapping filtering&#xA;    数码内容创作软件        DCC        digital content creation&#xA;    包围盒        bounding box&#xA;框架&#xA;    three.js&#xA;    physi.js&#xA;    glMatrix&#xA;    GLGE&#xA;    philoGL&#xA;    sceneJS&#xA;    spiderGL&#xA;着色器&#xA;工具&#xA;    webgl inspector&#xA;        # chrome的扩展, webgl调试&#xA;网站&#xA;    www.khronos.org/webgl/&#xA;        # Khronos提供的主页&#xA;    learningwebgl.com/blog&#xA;    blog.tojicode.com&#xA;    https://developer.mozilla.org/en/WebGL&#xA;        # mozilla的webgl教程&#xA;    www.chromeexperiments.com&#xA;        # chrome体验&#xA;    www.html5rocks.com&#xA;        # 提供html5资源&#xA;    www.lao3d.com&#xA;        # 国内首个webgl网站&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Java</title>
      <link>https://ukeate.com/docs/pl/java/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/java/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;历史&#xA;    1991.4 Oak&#xA;    1995.5 Java1.0 &amp;quot;Write Once, Run Anywhere&amp;quot;&#xA;    1996.1 JDK1.0, 纯解释型JVM(Sun Classic VM), Applet, AWT&#xA;    1996.5 JavaOne大会&#xA;    1997.2 JDK1.1, JDBC, JAR文件格式, JavaBeans, RMI, 内部类(Inner Class), 反射(Reflection)&#xA;    1998.12 JDK1.2, 分出J2SE、J2EE、J2ME。JVM内置JIT, EJB, Java Plug-in, Java IDL, Swing, Collections, strictfp关键字&#xA;    1999.4 JVM HotSpot&#xA;    2000.5 JDK1.3, 数学运算, Timer, JNDI成为平台服务, CORBA IIOP实现RMI, 2D API, JavaSound&#xA;    2002.2 JDK1.4, 成熟版本，多公司参与。正则, 异常链, NIO, 日志类, XML, XSLT&#xA;        # .NET发布&#xA;    2004.9 JDK1.5, 自动装箱, 泛型, 动态注解, 枚举, 变长参数, foreach, 改进内存模型JMM(Java Memory Model), concurrent包&#xA;    2006.12 JDK1.6, 改名为Java SE 6, Java EE 6, Java ME 6。动态语言支持(内置Mozilla JavaScript Rhino), 编译API, HTTP服务器API。JVM改进(锁、gc、类加载)&#xA;    2006.11 JavaOne Java开源。建立OpenJDK&#xA;    2009.2 JDK1.7, OpenJDK1.7和Sun JDK1.7几乎一样。Lambda项目, Jigswa项目(虚拟机模块化), 动态语言支持, GarbageFirst收集器, Coin项目(语言细节进化)。Oracle收购Sun后延迟部分项目。支持Mac OS X和ARM&#xA;    2009.4 Oracle收购Sun&#xA;&#xA;    o-&amp;gt; JVM历史&#xA;    Sun Classic                 # 1.0到1.3&#xA;        解释器&#xA;        sunwjit                 # 外挂编译器, 还有SymantecJITt shuJIT等&#xA;            编译器和解释器不能同时工作，编译器接管后，要对所有代码编译，不能用耗时稍高的优化，效率低&#xA;    Exact VM                    # 1.2到1.3&#xA;        使用准确内存管理EMM(Exact Memory Management)而得名&#xA;            虚拟机知道内存数据类型, gc时好判断数据是否被使用&#xA;            抛弃Classic VM基于handler(句柄关联对象移动地址)的对象查找方式, 每次定位对象少一次间接查找&#xA;        两级即时编译器&#xA;        与解释器混合工作&#xA;    Sun HotSpot VM              # 1.2, Sun JDK和OpenJDK, 来源Strongtalk VM&#xA;        EMM&#xA;        热点代码探测              # 与解释器协同，平衡最优响应时间和最佳执行性能&#xA;            执行计数器找出最有编译价值的代码，通知JIT以方法为单位编译&#xA;            方法频繁调用或有效循环多，触发标准编译和OSR(栈上替换)&#xA;            不用等待本地代码输出就执行，编译时间压力小，可引入更多优化技术，输出更高效本地代码&#xA;    KVM                         # 强调简单、轻量、可移植，但运行慢。Android, iOS前手机平台广泛使用&#xA;    CDC-HI VM/CLDC-HI VM        # CDC/CLDC(Connected Limited Device Configuration)希望在移动端建立统一java编译接口, 这是它们的参考实现， Java ME的支柱&#xA;    Squawk VM                   # 运行于Sun SPOT(small programmable object technology, 一种手持wifi设备)。java本身实现大部分&#xA;    JavaInJava                  # 实验，java实现自身元循环(meta-circular), 需要运行在宿主虚拟机上，没有JIT, 解释运行&#xA;    Maxine VM                   # 几乎java实现, 有JIT和gc, 没有解释器，宿主或独立运行，效率接近HotSpot Client VM&#xA;&#xA;    BEA JRockit                 # 专注服务器端，不太关心响应时间，没有解释器&#xA;        gc和MissionControl领先&#xA;    IBM J9 VM                   # IT4J(IBM Technology for Java Virtual Machine), SmallTalk虚拟机扩展而来, 面向各平台，主要应用于IBM产品&#xA;&#xA;    Azul VM                     # HotSpot改进，Azul Systems公司运行于专有硬件Vega&#xA;        每个实例管理数十cpu, 数百GB内存，可控gc时间，对硬件优化线程调度&#xA;    Zing JVM                    # Azul VM运行于x86平台&#xA;    BEA Liquid VM               # 现在的JRockit VE(virtual edition), BEA运行在自己Hypervisor系统上&#xA;        实现专用操作系统的必要功能，如文件系统、网络支持&#xA;        虚拟机直接控制硬件, 好处如 线程调度不用切换内核态、用户态等&#xA;    Apache Harmony              # 虚拟机，兼容Java1.5、1.6, 没得到TCK认证(Technology Compatibility Kit)兼容性测试的授权&#xA;        许多代码吸纳进IBM的JDK1.7和Google Android SDK&#xA;    Google Android Dalvik VM    # Android平台核心组成部分之一&#xA;        不能直接执行class, 执行dex文件可由class文件转化, 可直接使用大部分Java API&#xA;        寄存器架构，非栈架构&#xA;        Android2.2提供JIT&#xA;    Microsoft JVM               # 微软想垄断Java，Sun打官司令开发停止&#xA;    其它&#xA;        JamVM, cacaovm, SableVM, Kaffe, Jelatine JVM, NanoVM, MRP, Moxie JVM, Jikes RVM&#xA;&#xA;    o-&amp;gt;JDK发行版 &#xA;    Open JDK&#xA;    Oracle JDK&#xA;    IBM JDK&#xA;概念&#xA;    JDK(java development kit)       # java开发的最小环境&#xA;        Java语言&#xA;        JVM&#xA;        Java API类库&#xA;    JRE(java runtime environment)&#xA;        JVM&#xA;        Java SE API&#xA;    平台&#xA;        Java Card                        # Applets, 运行在小内存设备&#xA;        Java ME(Micro Edition)           # 以前叫J2ME。手机, PDA, 精简API&#xA;        Java SE(Standard Edition)        # 以前叫J2SE, 桌面应用, 完整API&#xA;        Java EE(Enterprise Edition)      # 企业应用(ERP, CRM), 扩充API(javax包, 有些合入了JavaSE), 部署支持&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jdk&#34;&gt;&#xA;  JDK&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;5&#xA;    自动装箱拆箱&#xA;    枚举类型&#xA;    import static&#xA;    可变参数&#xA;    内省&#xA;    泛型&#xA;    for增强&#xA;    注解&#xA;6&#xA;    AWT新类Desktop、SystemTray&#xA;    JAXB2，把Bean变为XML&#xA;    StAX XML处理&#xA;    Compiler API动态生成class&#xA;    Http Server API, 轻量http容器&#xA;    Common Annotations补充, Annotations API&#xA;    Console类&#xA;    脚本语言引擎: js, groovy, ruby&#xA;7&#xA;    switch支持String&#xA;    泛型推断&#xA;        new ArrayList&amp;lt;&amp;gt;()&#xA;    AutoCloseable interface，对象销毁时自动调用close()&#xA;    FileSystem新方法, 取环境变量&#xA;        getJavaIoTempDir()      # IO临时文件夹&#xA;        getJavaHomeDir()        # JRE目录&#xA;        getUserHomeDir()        # 用户目录&#xA;        getUserDir()            # 运行目录&#xA;    Boolean加方法&#xA;        negate()&#xA;        and()&#xA;        or()&#xA;        xor()&#xA;    Character加方法&#xA;        equalsIgnoreCase()&#xA;    Math加方法，安全计算&#xA;        safeToInt()&#xA;        safeNegate()&#xA;        safeSubtract()&#xA;        safeMultiply()&#xA;        safeAdd()&#xA;    switch case可以匹配String&#xA;    数值可下划线, 二进制&#xA;        int i = 1_000_000&#xA;        int i = 0b1001_1001&#xA;    多异常类型&#xA;        catch(A|B e){}&#xA;    try with resource自动关闭资源&#xA;        try (FileInputStream s1 = new FileInputStream(&amp;quot;&amp;quot;); FileOutputStream o1 = new FileOutputStream(&amp;quot;&amp;quot;)) {}&#xA;8&#xA;    interface default方法&#xA;    lambda表达式&#xA;    lambda作用域可访问实际final变量, 可访问对象字段和静态变量 &#xA;    函数式接口&#xA;        @FunctionalInterface&#xA;    函数引用&#xA;        Converter&amp;lt;String, Integer&amp;gt; f = Integer::valueOf&#xA;        User::new&#xA;    Predicate类, Function接口, Supplier接口, Consumer接口, Comparator接口, Optional接口&#xA;    Stream接口&#xA;        filter()...&#xA;        Collection&#xA;            stream()&#xA;            parallelStream()&#xA;    Date API&#xA;        Clock&#xA;            static systemDefaultZone()&#xA;            millis()&#xA;            instant()&#xA;        Date.from(instant)&#xA;        ZoneId&#xA;            static getAvailableZoneIds()&#xA;            static of()&#xA;            getRules()&#xA;        LocalTime&#xA;            static now()&#xA;            static of()&#xA;            static parse&#xA;            plust()...&#xA;        LocalDate&#xA;            static parse()&#xA;        LocalDateTime&#xA;            static of()&#xA;            toInstant()...&#xA;        ChronoUnit.HOURS.between()&#xA;        DateTimeFormatter&#xA;            static ofLocalizedTime(FormatStyle.SHORT)&#xA;            static ofPattern()&#xA;            withLocale(Locale.GERMAN)&#xA;    多重注解, 同一注解使用多次&#xA;        @Repeatable&#xA;9&#xA;    JDK模块化加载，瘦身&#xA;    AOT(Ahead of Time Compilation)&#xA;    接口私有方法&#xA;    jshell&#xA;    try with resource改进&#xA;        FileInputStream s1 = new FileInputStream(&amp;quot;&amp;quot;);&#xA;        FileOutputStream o1 = new FileOutputStream(&amp;quot;&amp;quot;);&#xA;        try (s1;o1){}&#xA;    下划线不能单独成为变量名，后续会成为关键字&#xA;    String从char[]改为byte[]&#xA;    stream加强，集合加强&#xA;        list.of()&#xA;        map.of()&#xA;        copyof()&#xA;10&#xA;    引入var, 只能声明局部变量&#xA;        var a = &amp;quot;a&amp;quot;;&#xA;11&#xA;    直接运行源码&#xA;        java a.java&#xA;    String&#xA;        strip()             # 可去除unicode空白字符&#xA;        isBlank()           # 长度为0或空格&#xA;        repeat(4)           # 重复4次生成新串&#xA;    lambda var类型推断&#xA;        (var a) -&amp;gt; a&#xA;    Optional加强&#xA;    InputStream&#xA;        transferTo()&#xA;    HTTP Client API&#xA;12&#xA;    switch多值（preview）&#xA;        switch(a) {&#xA;            case 1,2,3 -&amp;gt; a;&#xA;        }&#xA;13&#xA;    switch返回值(preview)&#xA;        String s = switch(a) {&#xA;            case 1 -&amp;gt; &amp;quot;a&amp;quot;;&#xA;        }&#xA;    文本块(preview)&#xA;        String s = &amp;quot;&amp;quot;&amp;quot;&#xA;            abc&#xA;            &amp;quot;&amp;quot;&amp;quot;;&#xA;14&#xA;    instanceof模式匹配(preview)&#xA;        if (o instanceof Integer i){&#xA;            i++;&#xA;        }&#xA;    空指针定位到对象        # a().b().c的情况&#xA;        -XX:+ShowCodeDetailsInExceptionMessages&#xA;    record类型(preview)&#xA;        public record User(String name, Integer age){}&#xA;    jpackage&#xA;15&#xA;    sealed类(preview), 限制子类继承&#xA;        public sealed class Animal permits Cat, Dog {}&#xA;        public final class Cat extends Animal {}&#xA;        public sealed class Dog extends Animal permits Husky {}&#xA;        public final class Husky extends Dog {}&#xA;    CharSequence interface添加default isEmpty()&#xA;    TreeMap添加方法&#xA;        putIfAbsent()&#xA;        computeIfAbsent()&#xA;        computeIfPresent()&#xA;        compute()&#xA;        merge()&#xA;    正式版: 文本块&#xA;16&#xA;    包装类编译时警告&#xA;        Integer i = new Integer(1)&#xA;        synchronized(i){}&#xA;    获取AM或PM&#xA;        DateTimeFormatter.ofPattern(&amp;quot;B&amp;quot;).format(LocalDateTime.now())&#xA;    InvocationHandler添加方法&#xA;        invokeDefault()     # 调interface default方法&#xA;    JVM优化: ZGC并发栈处理，弹性metaspace&#xA;    Stream&#xA;        toList()&#xA;    正式版: record类型、instanceof模式匹配、jpackage&#xA;17, LTS版&#xA;    去掉AOT、GraalVM的JIT&#xA;    switch模式匹配(preview)&#xA;        switch(a) {&#xA;            case B b -&amp;gt; b.b();&#xA;            case null -&amp;gt; ;&#xA;        }&#xA;    伪随机数增加interface, 用于使用stream&#xA;        RandomGeneratorFactory&#xA;        RandomGenerator, 由Random和ThreadLocalRandom继承&#xA;&#xA;    正式版: sealed类&#xA;21, LTS版&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令与工具&#34;&gt;&#xA;  命令与工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4%e4%b8%8e%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;bin&#xA;    javac           #  编译器&#xA;    java            #  解释器&#xA;        -jar a.jar&#xA;            --spring.config.location=/application.yml &#xA;            --spring.profiles.active=prod &#xA;                # 指定spring config&#xA;            -Xmx2g&#xA;            -Dserver.port&#xA;                # 覆盖properties&#xA;    javadoc         #  生成HTML格式的帮助文档&#xA;        javadoc -d docs -sourcepath src/ -subpackages com.ryx -author&#xA;    jdb             #  java调试器&#xA;    javah           #  反编译成c头文件&#xA;    javap           #  反编译成java文件&#xA;    jar             #  打包工具&#xA;        打包标签&#xA;            把包目录和class类放到jnb目录&#xA;            jnb/META-INF/tld文件添加&amp;lt;uri&amp;gt;http:# www.xxx.com&amp;lt;/uri&amp;gt;&#xA;            jar cvf jnb.jar *&#xA;        jar cvfm ul.jar manifest.mf com&#xA;    native2ascii    #  转换为unicode编码&#xA;    serialver       #  返回指定类的序列化号serialverUID&#xA;    appletviewer    #  小程序浏览器，执行HTML文件上java小程序类&#xA;    htmlconverter   #  转换applet tags成java plug-in&#xA;    javap           # 反编译&#xA;    jad             # 反编译&#xA;        jad -o -a d.java Xxx.class&#xA;    jps                                 # 查java进程&#xA;    jinfo                               # 输出、修改opts&#xA;    jstat                               # 性能分析&#xA;        -option                         # 查看分析项&#xA;        -class                          # 加载class的数量&#xA;        -compiler                       # 实时编译数量&#xA;        -gc                             # gc次数，时间&#xA;        -gccapacity                     # gc占量: young、old、perm&#xA;        -gcnew                          # new对象数量&#xA;        -gcnewcapacity                  # new对象占量&#xA;        -gcutil                         # gc统计&#xA;    jmap                                # 内存分配&#xA;    jconsole                            # 图形统计：heap, threads, classes, cpu, VM summary&#xA;    jstack                              # 查看线程(如死锁),得到java stack和native stack&#xA;工具&#xA;    MAT (Memory Analyzer)&#xA;        # eclipse MAT插件分析dump文件&#xA;    JProfiler&#xA;        # 图形化全面性能分析&#xA;常见场景&#xA;    分析GC效果，内存泄漏&#xA;        jstat -gcutil -t -h8 [pid] 1000&#xA;    dump内存&#xA;        jmap -dump:live,format=b,file=heap.bin [pid]&#xA;    查死锁&#xA;        jstack |grep deadlock            # deadlock会列在最后&#xA;    CPU占用&#xA;        top&#xA;        top -Hp [pid]&#xA;        printf &#39;%x&#39; [tid]&#xA;        jstack [pid] | grep [16进制tid] -A 10&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础-1&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;类型&#xA;    基本类型&#xA;        # 作为面向对象语言，为了方便引入了基本类型&#xA;        boolean 1或4字节&#xA;            # 没有定义类型的字节码，跟据jvm实现有时用int代替&#xA;            # 据说[]boolean是1个，boolean直接用int类型是4个&#xA;        byte  1个字节&#xA;        short 2个字节&#xA;        char  2个字节&#xA;            # gbk, gb2312这种2字节编码，一个汉字存一个char。utf-8一个字用3字节&#xA;        int   4个字节&#xA;        long  8个字节&#xA;        float 4个字节&#xA;        double 8个字节&#xA;    包装类型&#xA;        # 不可变(immutable)类&#xA;        Boolean, Byte, Short, Character, Integer, Long, Float, Double&#xA;        享元&#xA;            Integer i1 = 120, i2 = 120, i3 = 130, i4 = 130;&#xA;            i1 == i2; i3 != i4&#xA;                # 数字小于1字节(-128 -- 127)后 , 内部存在IntegerCache中,这是一种享元模式&#xA;        自动折装箱(java5)&#xA;            Integer iObj = 3;        # 装箱&#xA;            iObj + 12;            # 折箱&#xA;    字符串&#xA;        # 不可变(immutable)类, 用cahr数组实现&#xA;        字面量处理 String str = &amp;quot;abc&amp;quot;&#xA;            # String s = new String(&amp;quot;abc&amp;quot;) 放堆里&#xA;            定义引用变量str&#xA;            栈中查找&amp;quot;abc&amp;quot;, 有则返回地址，没有则开辟地址，再创建String对象，对象指向该地址, 该地址标记对象引用&#xA;                # 放在栈的静态区(static segement)里&#xA;            str指向地址, 所以str保存了一个指向栈中数据的引用&#xA;        &amp;quot;a&amp;quot;+&amp;quot;b&amp;quot; 会编译成使用StringBuilder&#xA;            # 循环中会重复创建&#xA;    泛型&#xA;        字面量&#xA;            Map&amp;lt;String, Integer&amp;gt; a = new HashMap&amp;lt;&amp;gt;();               # 后面的菱形操作符做了类型推断&#xA;            f(new HashMap&amp;lt;&amp;gt;)                                        # 传值使用菱形操作符&#xA;&#xA;引用&#xA;    强引用(strong reference)&#xA;        String s = new String(&amp;quot;&amp;quot;)&#xA;    软引用(soft reference)     # 内存不足时回收&#xA;        # 用来实现内存敏感的高速缓存, 如object-cache，为了能cache又不会内存不足&#xA;        SoftReference&amp;lt;String&amp;gt; softRef = new SoftReference&amp;lt;String&amp;gt;(s)&#xA;        回收&#xA;            将softRef引用referent(s)设为null，不再引用new String(&amp;quot;&amp;quot;)&#xA;            new String(&amp;quot;&amp;quot;)设置为可结束(finalizable)&#xA;            new String(&amp;quot;&amp;quot;)运行finalize(),空间释放。softRef添加到它的ReferenceQueue(如果有)&#xA;    弱引用(weak reference)     # 表示可有可无, gc扫描到随时回收&#xA;        WeakReference&amp;lt;String&amp;gt; weakRef = new WeakReference&amp;lt;String&amp;gt;(s)&#xA;    虚引用(PhantomReference)   # 形同虚设，像没引用，用来跟踪垃圾回收活动&#xA;        ReferenceQueue&amp;lt;String&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;()&#xA;        PhantomReference&amp;lt;String&amp;gt; phantomRef = new PhantomReference&amp;lt;String&amp;gt;(s, queue)&#xA;        # 必须和ReferenceQueue联合使用&#xA;        # 可以通过判断ReferenceQueue是否有虚引用，来了解被引用对象是否将要被回收&#xA;修饰&#xA;    volatile    # 类型修饰符，告诉jvm该变量在寄存器/工作内存中值是不确定的&#xA;        # 没有原子性&#xA;        # 不会造成线程阻塞&#xA;        # 读性能几乎不变，写稍慢，因为插入内存屏障来保证不乱序执行&#xA;        对所有线程可见(可见性，线程的修改对其它线程可见)&#xA;            # 跳过cpu cache，新值立即同步到内存, 使用前从内存刷新&#xA;        禁止编译器指令重排序优化&#xA;    synchronized    # 锁当前变量、方法、类，只有当前线程可用&#xA;        # 保证可见性和原子性&#xA;语句&#xA;    ==&#xA;        # 基础类型比较数值，引用类型比较地址&#xA;    +1 与 += 1&#xA;        short s1 = 1; s1 = s1 + 1   # 出错，类型变为int&#xA;        s1 += 1     # 相当于 s1 = (short)(s1 + 1)&#xA;    + &amp;quot;&amp;quot;    # 编译成StringBuilder实现&#xA;    goto和const是保留字但没有使用&#xA;    标签&#xA;        label1:&#xA;        for(; true; ) {&#xA;            break lable1;&#xA;            // continue lable1;&#xA;        }&#xA;    增强for循环(1.5)&#xA;        for(int i : args){&#xA;            sum += i;&#xA;        }&#xA;    同步&#xA;        public synchronized void synMethod(){}&#xA;        synchronized(a1){}&#xA;    switch&#xA;        expr类型&#xA;            1.5前只能byte, short, char, int&#xA;            1.5可以枚举&#xA;            1.7可以String&#xA;            long目前不可以&#xA;表达式&#xA;    java赋值语句返回被赋值的对象&#xA;    &amp;amp; 与 &amp;amp;&amp;amp;&#xA;        &amp;amp;是 按位与，逻辑与(后面会计算)&#xA;        &amp;amp;&amp;amp;是 短路与&#xA;    | 与 ||&#xA;        # 同上&#xA;    lambda表达式                                                     # 为了便于并行编程, 提高语法的抽象级别&#xA;        字面量&#xA;            () -&amp;gt; o.f()&#xA;            () -&amp;gt; {&#xA;                o.f()&#xA;            }&#xA;            event -&amp;gt; o.f()&#xA;            (x, y) -&amp;gt; x + y&#xA;            (Long x, Long y) -&amp;gt; x + y&#xA;&#xA;            f(O::f1)                                                # 简化 f((o) -&amp;gt; o.f1())&#xA;        类型&#xA;            Predicate&amp;lt;T&amp;gt;&#xA;                Predicate&amp;lt;String&amp;gt; condition = (s) -&amp;gt; s.length() &amp;gt; 4);&#xA;                if (condition.test(s)) {}&#xA;&#xA;                Predicate&amp;lt;String&amp;gt; a = (s) -&amp;gt; s.length() &amp;gt; 1; b = (s) -&amp;gt; s.length() &amp;gt; 2;&#xA;                Predicate&amp;lt;String&amp;gt; c = a.and(b)&#xA;            Consumer&amp;lt;T&amp;gt;&#xA;            Function&amp;lt;T, R&amp;gt;&#xA;            Supplier&amp;lt;T&amp;gt;&#xA;            UnaryOperator&amp;lt;T&amp;gt;&#xA;            BinaryOperator&amp;lt;T&amp;gt;&#xA;        特点&#xA;            参数类型推断&#xA;            作为匿名内部类&#xA;                button.addListener(event -&amp;gt; o.f())&#xA;            引用外部变量时，不一定声明final, 但要是即成事实(effectively)的final变量(不能重复赋值)&#xA;            重载解析参数类型时，找最具体类型。&#xA;                无法推断时报错, 如                                    # 重定义方法名或传入时做强转&#xA;                    f(Predicate&amp;lt;Integer&amp;gt; p)&#xA;                    f(IntPredicate p)&#xA;声明&#xA;    静态导入(1.5)&#xA;        import static java.lang.Math.max&#xA;        import static java.lang.Math.*&#xA;            # 导入的是方法，该方法就可以直接使用&#xA;方法&#xA;    修饰&#xA;        开放性&#xA;            修饰符     当前类     同包      子类      其他包&#xA;            public       √        √        √          √&#xA;            protected    √        √        √&#xA;            无           √        √&#xA;            private      √&#xA;        default修饰接口默认方法(虚方法)&#xA;    方法参数都是值传递，无法改变外部的参数本身&#xA;    可变参数(1.5)&#xA;        public void sum(int x, int... args)&#xA;    static方法初始化先于构造方法&#xA;    overload与override&#xA;        重载&#xA;            父类、同类、子类中比较&#xA;            方法名一致，入参有变化&#xA;            返回值不影响&#xA;                # 为副作用调用时(忽略返回值)考虑&#xA;            修饰符、异常声明不影响&#xA;        重写&#xA;            入参，出参一致&#xA;            构造方法、final方法不能被重写&#xA;            static方法不能被重写，可再次声明&#xA;            访问权限不能缩小&#xA;            异常声明不扩大，可加非强制异常&#xA;    finally&#xA;        # return前走finally, catch块中也一样&#xA;类&#xA;    字面量&#xA;        public class A {{&#xA;            ...&#xA;        }}&#xA;            这是匿名构造函数，相当于:&#xA;                public class A {&#xA;                    public A() {&#xA;                        ...&#xA;                    }&#xA;                }&#xA;    接口&#xA;        不能定义构造函数&#xA;        只定义抽象方法&#xA;        类成员全部public&#xA;        定义的实际上都是常量&#xA;        不能定义静态方法&#xA;        类可实现多接口&#xA;        函数接口，接口声明默认方法&#xA;        default方法&#xA;            Collection中添加stream()会打破前版本二进制兼容性(原版本找不到stream而报错)，默认方法指定找不到时使用的方法, 维护兼容性&#xA;            可被其它接口继承重写&#xA;            多重继承&#xA;                继承代码块，不继承类状态(属性)                         # 有些人认为多重继承的问题在于状态的继承&#xA;                冲突报错, 可子类重写解决&#xA;            优先级: 子类 &amp;gt; 类 &amp;gt; 接口&#xA;    抽象类&#xA;        # 有抽象方法的类&#xA;        可定义构造函数&#xA;        可定义抽象方法和具体方法&#xA;        成员可以是private, default, protected, public&#xA;        可定义成员变量&#xA;        可定义静态方法&#xA;        类只继承一个抽象类&#xA;    接口与抽象类&#xA;        不能实例化&#xA;        可作为引用类型&#xA;        继承的类要实现所有抽象方法，否则还是抽象类&#xA;    抽象方法&#xA;        不能static，static方法不能被重写&#xA;        不能native，native需要实现&#xA;        不能synchronized，synchronized表示一种实现方式&#xA;    静态变量&#xA;        # 实例变量属于对象实例，有多个&#xA;        属于类，只有一个，实现共享内存&#xA;    内部类&#xA;        静态嵌套类(static nested class), 可不依赖外部类实例被实例化&#xA;        内部类，外部类实例化后才能实例化&#xA;            new Outer().new Inner()     # 在Outer类中也不能new Innter()&#xA;注解&#xA;    @FunctionalInterface                        # 检查是否符合函数接口标准&#xA;安全性&#xA;    安全沙箱机制&#xA;        类加载体系&#xA;        .class文件检验器&#xA;        JVM及语言的安全特性&#xA;        安全管理器与java api&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;异常&#34;&gt;&#xA;  异常&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e5%b8%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;异常机制&#xA;    运行时出现错误，控制权交给异常处理器&#xA;    方法立即结束，抛出一个异常对象。调用该方法的程序停止，搜索处理代码&#xA;&#xA;Throwable&#xA;    Error&#xA;        # JVM相关问题，如系统崩溃、虚拟机错误、内存不足、方法调用栈溢出&#xA;    Exception&#xA;        # 指可处理的异常&#xA;        RuntimeException&#xA;            # 非强制(unchecked)。除RuntimeException都是强制异常(checked)&#xA;Error&#xA;    java.lang.OutOfMemoryError      # 内存溢出&#xA;    java.lang.StackOverflowError        # 堆溢出&#xA;&#xA;运行时异常&#xA;    ArithmeticExecption     # 算术异常类&#xA;    IllegalArgumentException    # 方法传递参数错误&#xA;    NullPointerException        # 空指针异常类&#xA;    ClassNotFoundException  # 类找不到，加载路径错误&#xA;    ClassCastException      # 类型强制转换异常&#xA;    NoClassDefFoundException    # 未找到类定义&#xA;    ArrayIndexOutOfBoundsException      # 数组越界异常&#xA;    ArrayStoreException      # 数组存储异常，操作数组时类型不一致&#xA;    BufferOverflowException     # 缓冲溢出异常&#xA;    NegativeArrayException      # 数组负下标异常&#xA;    NoSuchMethodException       # 方法未找到异常&#xA;    IllegalStateException     # servlet过滤器中 chain.doFilter中request,response类型为ServletRequest，ServletResponse时出错&#xA;    NumberFormatException   # 字符串转换为数字异常&#xA;    SQLException        # sql语句出错&#xA;    InstantiationException      # 实例化异常&#xA;    DateTimeException   # 无效时间&#xA;&#xA;强制异常&#xA;    FileNotFoundException       # 文件未找到异常&#xA;    ParseException      # 解析时间字符串到时间类型出错&#xA;    ServletException        # servlet转发时出现过该异常&#xA;    IOException     # io异常&#xA;    java.sql.BatchUpdateException       # sql批处理&#xA;    com.mysql.jdbc.MysqlDataTruncation      # mysql 插入数据被截断,插入数据过长时遇到&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;注解&#34;&gt;&#xA;  注解&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e8%a7%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# annotation (1.5特性)&#xA;jdk的注解&#xA;    @SuppressWarnings(&amp;quot;deprecation&amp;quot;)        # 压制警告&#xA;        # SuppressWarning不是一个标记注解。它有一个类型为String[]的成员，&#xA;        # 参数如下&#xA;        all to suppress all warnings&#xA;        boxing to suppress warnings relative to boxing/unboxing operations&#xA;        cast to suppress warnings relative to cast operations&#xA;        dep-ann to suppress warnings relative to deprecated annotation&#xA;        deprecation to suppress warnings relative to deprecation&#xA;        fallthrough to suppress warnings relative to missing breaks in switch statements&#xA;        finally to suppress warnings relative to finally block that don’t return&#xA;        hiding to suppress warnings relative to locals that hide variable&#xA;        incomplete-switch to suppress warnings relative to missing entries in a switch statement (enum case)&#xA;        nls to suppress warnings relative to non-nls string literals&#xA;        null to suppress warnings relative to null analysis&#xA;        rawtypes to suppress warnings relative to un-specific types when using generics on class params&#xA;        restriction to suppress warnings relative to usage of discouraged or forbidden references&#xA;        serial to suppress warnings relative to missing serialVersionUID field for a serializable class&#xA;        static-access to suppress warnings relative to incorrect static access&#xA;        synthetic-access to suppress warnings relative to unoptimized access from inner classes&#xA;        unchecked to suppress warnings relative to unchecked operations&#xA;        unqualified-field-access to suppress warnings relative to field access unqualified&#xA;        unused to suppress warnings relative to unused code&#xA;&#xA;    @Deprecated                             # 标记过时&#xA;    @Override&#xA;元注解(metadata)&#xA;    @Retention(RetentionPolicy.RUNTIME)&#xA;        # 保留策略 CLASS、RUNTIME和SOURCE这三种，分别表示注解保存在类文件、JVM运行时刻和源代码阶段&#xA;        # 只有当声明为RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息。&#xA;    @Target用来声明注解作用目标，如类型、方法和域等。如&#xA;        @Target(ElementType.TYPE)  //接口、类、枚举、注解&#xA;        @Target(ElementType.FIELD) //字段、枚举的常量&#xA;        @Target(ElementType.METHOD) //方法&#xA;        @Target(ElementType.PARAMETER) //方法参数&#xA;        @Target(ElementType.CONSTRUCTOR)  //构造函数&#xA;        @Target(ElementType.LOCAL_VARIABLE)//局部变量&#xA;        @Target(ElementType.ANNOTATION_TYPE)//注解&#xA;        @Target(ElementType.PACKAGE) ///包&#xA;    @Document：说明该注解将被包含在javadoc中&#xA;    @Inherited：说明子类可以继承父类中的该注解&#xA;自定义注解&#xA;    # @interface用来声明一个注解&#xA;    ## 其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型。可以通过default来声明参数的默认值。&#xA;    @Retention(RetentionPolicy.RUNTIME)&#xA;    @Target(ElementType.TYPE)&#xA;    public @interface Assignment {&#xA;        String assignee();&#xA;        int effort();&#xA;        double finished() default 0;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;版本特性&#34;&gt;&#xA;  版本特性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%88%e6%9c%ac%e7%89%b9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;java8&#xA;    接口中可以定义静态方法与默认方法&#xA;        不能重写equals，hashCode或toString的默认实现。&#xA;    Lambdas&#xA;        # Lambda更好地利用多核处理器&#xA;        与匿名内部类&#xA;            匿名内部类编译成.class文件，lambda表达式编译成私有方法, 使用invokedynamic(java7)字节码指令动态绑定&#xA;                private static java.lang.Object lambda$0(java.lang.String)&#xA;            匿名内部类this指向该匿名内部类, lambda的this总指向所有的外部类&#xA;        内部变量&#xA;            可以使用静态、非静态局部变量&#xA;            只能引用final和局部变量，不能修改外部变量     # 不可变闭包&#xA;        注解&#xA;            @Functionalnterface     # 函数式接口&#xA;                有且公有一个抽象方法      # SAM(single abstract method)&#xA;                允许定义静态方法、默认方法、Object中的public方法&#xA;                不是必须的，接口符合以上定义就算函数式接口&#xA;        函数&#xA;            (int x, int y) -&amp;gt; { return x + y; }&#xA;            Runnable r = () -&amp;gt; { System.out.println(&amp;quot;Running!&amp;quot;); }&#xA;        SAM&#xA;            new Thread(() -&amp;gt; System.out.println(&amp;quot;&amp;quot;))&#xA;                # Thread有单个抽象方法run()&#xA;        列表&#xA;            list1.forEach(System::out::println)&#xA;    java.util.function包&#xA;        # 声明于function包内的接口可接收lambda表达式&#xA;        Predicate&#xA;        Stream&#xA;    Optional&#xA;    Jigsaw&#xA;        # jdk上的模块系统，使大块的代码更易于管理&#xA;&#xA;java7&#xA;    switch中可以使用字符串了&#xA;    运用List&amp;lt;String&amp;gt; tempList = new ArrayList&amp;lt;&amp;gt;(); 即泛型实例化类型自动推断&#xA;    语法上支持集合，而不一定是数组&#xA;        final List&amp;lt;Integer&amp;gt; piDigits = [ 1,2,3,4,5,8 ];&#xA;    map集合支持并发请求，且可以写成&#xA;        Map map = {name:&amp;quot;xxx&amp;quot;,age:18};&#xA;java6&#xA;    ui增强&#xA;        Java应用程序可以和本地平台更好的集成&#xA;    web service支持增强：jax-ws2.0与jaxb2.0&#xA;        优先支持编写 XML web service 客户端程序。&#xA;        用过简单的annotaion将你的API发布成.NET交互的web services.&#xA;    jdbc4.0&#xA;    Scripting可以在Java源代码中混入JavaScript&#xA;&#xA;java5&#xA;    泛型，允许指定集合里元素的类型&#xA;    枚举类型&#xA;    自动类型包装和拆包&#xA;    可变参数&#xA;    注解&#xA;    增强for循环&#xA;    静态引入&#xA;    新的线程模型与并发库&#xA;        HashMap的替代者ConcurrentHashMap&#xA;        ArrayList的替代者CopyOnWriteArrayList&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;object&#34;&gt;&#xA;  Object&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#object&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;clone()&#xA;    # 开始与new相同分配内存, 然后填充对象的域。是浅拷贝&#xA;    深拷贝&#xA;        class Body implements Cloneable {&#xA;            @Override&#xA;            protected Object clone() throws CloneNotSupportedException {&#xA;                body = (Body) super.clone()&#xA;                body.head = (Head)head.clone()&#xA;                return body&#xA;            }&#xA;        }&#xA;equals()&#xA;    # 具有自反性、对称性、传递性、一致性&#xA;    # 先确定hashCode一致，equals相等的对象hashCode一定相等&#xA;    # 没重写时比较地址&#xA;    重写equals&#xA;        1 == 检查是否引用&#xA;        2 instanceof 检查类型&#xA;        3 属性是否匹配&#xA;        4 是否满足对称性、传递性、一致性&#xA;        5 总要重写hashCode&#xA;finalize()&#xA;    # 垃圾收集时调用&#xA;valueOf()   # 转换成自己类型&#xA;wait()&#xA;notify()&#xA;notifyAll()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;系统&#34;&gt;&#xA;  系统&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;System&#xA;    currentTimeMillis();&#xA;        # Clock.systemDefaultZone().millis()  # java8&#xA;    arraycopy()&#xA;File&#xA;    String[] list()            # 列出目录下的所有文件名&#xA;    String[] list(FilenameFilter filter)            # 列出目录下符合filter规范的文件名（filter用匿名内部类定义）&#xA;Scanner&#xA;    next()&#xA;        例如：&#xA;        Scanner input = new Scanner(System.in);&#xA;        int data = input.nextInt();&#xA;        System.out.println(data);&#xA;    得到继承结构&#xA;        StackTraceElement [] stackTraces = new Throwable().getStackTrace();&#xA;        for(StackTraceElement temp : stackTraces){&#xA;        temp.getClassName()&#xA;        temp.getFieldName();&#xA;        temp.getMethodName();&#xA;        }&#xA;Cloneable接口&#xA;    clone()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;包装类型&#34;&gt;&#xA;  包装类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;parseXxx(String)    # 从字符串转换&#xA;valueOf(String)     # 从字符串转换&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# final类，不可继承&#xA;length()&#xA;    # String length是方法, 数组length是属性&#xA;isEmpty()&#xA;indexOf()&#xA;lastIndexOf()&#xA;chatAt()&#xA;substring()&#xA;trim()&#xA;toLowerCase()&#xA;toUpperCase()&#xA;split()&#xA;getBytes()&#xA;replaceAll()&#xA;    String p = &amp;quot;A0A1A2&amp;quot;.replaceAll(&amp;quot;([A-Z]{1,1})([A-Z0-9]{1,1})?&amp;quot;, &amp;quot;$1=$2 &amp;quot;);&#xA;    # A=0 A=1 A=2&#xA;    ## $符是组的概念，与&amp;quot;([A-Z]{1,1})([A-Z0-9]{1,1})?&amp;quot;中的两对括号代表两组&#xA;    ## {1,1}代表匹配1次, (从1次到1次)&#xA;    replaceAll(&amp;quot;[A_Z]&amp;quot;, &amp;quot;_$0&amp;quot;)            # 分组匹配被替换的值到替换字符串中&#xA;&#xA;类&#xA;    StringBuffer&#xA;        # 线程安全&#xA;        append()&#xA;        insert()&#xA;    StringBuilder&#xA;        # 1.5引入&#xA;    intern()&#xA;        # 返回常量池中的引用(String对象equals池中某对象为true)，没有时添加&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;正则&#34;&gt;&#xA;  正则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a3%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Pattern&#xA;[abc]&#xA;[^abc]&#xA;[a-zA-Z]&#xA;[a-z&amp;amp;&amp;amp;[def]]&#xA;[a-z&amp;amp;&amp;amp;[^bc]]    =    [ad-z]&#xA;[a-z&amp;amp;&amp;amp;[^m-p]]    =    [a-lq-z]&#xA;.除了换行符之外的任意字符&#xA;\d    [0-9]&#xA;\D    [^0-9]&#xA;\s    [ \t\n\x0B\f\r]&#xA;\S    [^\s]&#xA;\w    [a-zA-Z_0-9]&#xA;\W    [^\w]&#xA;&#xA;posix的字符&#xA;\p{Lower}        [a-z]&#xA;\p{Upper}        [A-Z]&#xA;\p{ASCII}        [\x00-\x7F]&#xA;\p{Alpha}        [\p{Lower}\p{Upper}]&#xA;\p{Digit}        [0-9]&#xA;\p{Alnum}        [\p{Alpha}\p{Digit}]&#xA;\p{Punct}        !&amp;quot;#$%&amp;amp;&#39;()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~    之一&#xA;\p{Graph}        [\p{Alnum}\p{Punct}]所有可见字符&#xA;\p{Print}        [\p{Graph}\x20]    \x20为空格&#xA;\p{Blank}        [ \t]    一个空格或tab&#xA;\p{Cntrl}        [\x00-\x1f\x7f]    控制字符&#xA;\p{XDigit}        [0-9a-fA-F]    十六进制符号&#xA;\p{Space}        [ \t\n\x0B\f\r]&#xA;&#xA;代表边界的字符&#xA;^        行首&#xA;$        行尾&#xA;\b        A word boundary&#xA;\B        A non-word boundary&#xA;\A        input的开始&#xA;\G        The end of the previous match&#xA;\Z        The end of the input but for the final terminator,if any&#xA;\z        The end of the input&#xA;&#xA;Greedy 定量&#xA;X?        0或1个&#xA;X*        0或多个&#xA;X+        1或多个&#xA;X{n}        n个&#xA;X{n,}    最少n个&#xA;X{n,m}    n到m，包含n,m&#xA;&#xA;Logical operators&#xA;XY        XY&#xA;X|Y        X或Y&#xA;(X)        捕获的匹配&#xA;\n        得到第n个捕获&#xA;&#xA;Quotation&#xA;\        Nothing, but quotes the following character&#xA;\Q        Nothing, but quotes all characters until \E&#xA;\E        Nothing, but ends quoting started by \Q&#xA;&#xA;Special constructs (non-capturing)&#xA;(?某某)&#xA;&#xA;* 方案&#xA;* 任意字符&#xA;&#xA;    [\S\s]        # 匹配空格或非空格，就是任意一个字符&#xA;        ## [\W\w] 相同&#xA;&#xA;* 匹配多个&#xA;    Pattern p1 = Pattern.compile(&amp;quot;\\(.*?\\)&amp;quot;);&#xA;        Matcher m1 = p1.matcher(&amp;quot;kjdjdjj(738383)ddk(9999)ppp&amp;quot;);&#xA;        while (m1.find()) {&#xA;            System.out.println(m1.group().replaceAll(&amp;quot;[()]&amp;quot;, &amp;quot;&amp;quot;));&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;math&#34;&gt;&#xA;  Math&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#math&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;round&#xA;    # 四舍五入, -11.5得到11&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;时间&#34;&gt;&#xA;  时间&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%b6%e9%97%b4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;java8的新时间类实现JSR-310&#xA;    特点&#xA;        不变性, 内部状态不变、线程安全&#xA;        关注点分离，定义了不同的类：Date, Time, DateTime, timestamp, 时区&#xA;        策略模式，所有类定义format()和parse()方法&#xA;        实用方法，所有类定义了方便操作的方法&#xA;        扩展性，使用ISO-8601日历系统，也可扩展在其它系统&#xA;    包&#xA;        java.time       # 基础包&#xA;        java.time.chrono     # 非ISO日历系统的泛化api&#xA;        java.time.format    # 格式化和解析，基本不用(基础包有封装)&#xA;        java.time.temporal  # 时态对象，用来改变时间&#xA;        java.time.zone      # 时区相关类&#xA;    JSR-310&#xA;        精确到纳秒&#xA;        对应人类观念，也不是像Date一样用零点时间表示日期&#xA;        大部分基于Joda-Time，区别：&#xA;            包名从org.joda.time到java.time&#xA;            不接受null值，Joda-Time视null为0&#xA;            机器用Instant和人用DateIme接口差别更明显&#xA;            所有异常继承DateTimeException&#xA;    方法&#xA;        Of  # 静态工厂&#xA;        parse   # 静态解析&#xA;        get&#xA;        is&#xA;        with    # 设置时间，不可变&#xA;        plus&#xA;        minus&#xA;        to      # 转换类型&#xA;        at      # 组合对象&#xA;Calendar&#xA;    getInstance()&#xA;    get(Calendar.YEAR)   # YEAR, MONTH, DATE, HOUR_OF_DAY, MINUTE, SECOND&#xA;    getTimeInMillis()   # 时间戳，毫秒&#xA;    getTime()&#xA;    set()   # 设置到时间&#xA;    使用&#xA;        Calendar c = Calendar.getInstance()&#xA;        c.set(Calendar.DAY_OF_MONTH, 1)     // 月第一天&#xA;        c.set(Calendar.DAY_OF_MONTH, c.getActualMaximum(Calendar.DAY_OF_MONTH))     // 月最后一天&#xA;        System.out.println(format.format(c.getTime(0))&#xA;        c.add(Calendar.DATE, -1)    // 昨天&#xA;SimpleDateFormat&#xA;    format(Date)&#xA;    使用&#xA;        SimpleDateFormat formatter = new SimpleDateFormat(&amp;quot;yyyy/MM/dd&amp;quot;)&#xA;        System.out.println(formatter.format(new Date()))&#xA;LocalDate     # java8, 默认格式(yyyy-MM-dd)&#xA;    now()&#xA;        LocalDate.now()&#xA;        LocalDate.now(ZoneId.of(&amp;quot;Asia/Kolkata&amp;quot;))   // 时区时间&#xA;    of()    # 指定时间&#xA;    ofEpochDay()  # 纪元日(1970.1.1)后多少天&#xA;    ofYearDay()   # 年后多少天&#xA;&#xA;    minusDays()&#xA;        today.minusDays(1)  # 昨天&#xA;    isLeapYear()    # 闰年&#xA;    isBefore()  # 比较大小&#xA;    atTime()    # 返回LocalDateTime&#xA;    plusDays()&#xA;    plusWeeks()&#xA;    plusMonths()&#xA;    minusDays()&#xA;    minusWeeks()&#xA;    minusMonths()&#xA;    with()      # 定位时间&#xA;        today.with(TemporalAdjusters.irstDayOfMonth())&#xA;        today.with(TemporalAdujsters.lastDayOfYear())&#xA;    until()     # 返回Period&#xA;    使用&#xA;        LocalDate today = LocalDate.now()&#xA;        LocalDate firstday = LocalDate.of(today.getYear(), today.getMonth(), 1)     // 月第一天&#xA;        LocalDate lastDay = today.with(TemporaAdjusters.lastDayOfMonth())       // 月最后一天&#xA;        System.out.println(lastDay)&#xA;LocalTime     # java8, 默认格式(hh:mm:ss.zzz)&#xA;    now()&#xA;    of()&#xA;    ofSecondOfDay()     # 从0开始多少秒后&#xA;LocalDateTime   # java8，默认格式(yyyy-MM-dd-HH-mm-ss.zzz)&#xA;    now()&#xA;    of()&#xA;        LocalDaeTime.of(LocalDate.now(), LocalTime.now())&#xA;        LocalDateTime.of(2014, Month.JANUARY, 1, 10, 10, 30)&#xA;    ofEpochSecond()&#xA;    ofInstant()&#xA;    parse()     # 按格式parse字符串&#xA;        LocalDateTime.parse(&amp;quot;27::Apr::2014 21::39::48&amp;quot;, DateTimeFormatter.ofPattern(&amp;quot;d::MMM::uuuu HH::mm::ss&amp;quot;))&#xA;&#xA;    getYear()&#xA;    getMonthValue()&#xA;    getDayOfMonth()&#xA;    getHour()&#xA;    getMinute()&#xA;    getSecond()&#xA;    minusDays()&#xA;    plush()&#xA;ZonedDateTime&#xA;    now()&#xA;    parse()&#xA;        ZonedDateTime.parse(&amp;quot;2013-12-31T23:59:59Z[Europe/Paris]&amp;quot;)&#xA;Clock     # java8&#xA;    systemDefaultZone()&#xA;    systemUTC()&#xA;    system(ZoneId.of(&amp;quot;Europe/Paris&amp;quot;))&#xA;    fixed(Instant.now(), ZoneId.of(&amp;quot;Asia/Shanghai&amp;quot;))    # 固定时区&#xA;    offset(c1, Duration.ofSeconds(2))   # 偏移&#xA;&#xA;    millis()        # 时间戳&#xA;Instant     # java8, 机器可读格式，精确到纳秒&#xA;    now()&#xA;        now(clock1)     # 得到瞬间时间&#xA;    ofEpochMilli&#xA;&#xA;    toEpochMilli()&#xA;    getEpochSecond()&#xA;Duration        # java8, 时间段&#xA;    between()&#xA;    ofDays()&#xA;&#xA;    toDays()&#xA;    toHourse()&#xA;Period      # java8&#xA;    getMonths()     # 算成月数&#xA;DateTimeFormatter   # java8&#xA;    BASIC_ISO_DATE&#xA;    ofPatter()&#xA;    使用&#xA;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&amp;quot;yyyy/MM/dd&amp;quot;)&#xA;        System.out.println(LocalDate.now().format(formatter))&#xA;Chronology  # java8 年表&#xA;    localDateTime(LocalDateTime.now())&#xA;&#xA;    类&#xA;        HijrahChronology&#xA;            INSTANCE&#xA;新旧转换&#xA;    // Date, Instant, LocalDateTime&#xA;    Instant timestamp = new Date().toInstant()&#xA;    LocalDateTime date = LocalDateTime.ofInstant(timestamp, ZoneId.of(ZoneId.SHORT_IDS.get(&amp;quot;PST&amp;quot;)))&#xA;    Date date = Date.from(Instant.now())&#xA;&#xA;    // Calendar, Instant&#xA;    Instant time = Calendar.getInstance().toInstant()&#xA;&#xA;    // TimeZone, ZoneId&#xA;    ZoneId defaultZone = TimeZone.getDefault().toZoneId()&#xA;    TimeZone timeZone = TimeZone.getTimeZone(defaultZone)&#xA;&#xA;    // GregorianCalendar, ZonedDateTime&#xA;    ZonedDateTime gCalendarDateTime = new GregorianCalendar().toZonedDateTime()&#xA;    GregorianCalendar gCalendar = GregorianCalendar.from(gCalendarDateTime)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数组&#34;&gt;&#xA;  数组&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;length&#xA;    属性&#xA;newInstance()&#xA;    泛型数组实例化&#xA;        T[] = (T[]) new Object[0];&#xA;        (T[]) Array.newInstance(type, size);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;枚举&#34;&gt;&#xA;  枚举&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%9a%e4%b8%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 枚举类型的比较取决于声明顺序&#xA;举类的实现类&#xA;    java.lang.Enum&amp;lt;E&amp;gt; extends Object&#xA;        static &amp;lt;T extends Enum&amp;lt;T&amp;gt;&amp;gt; T valueOf(Class&amp;lt;T&amp;gt; enumType, String name)&#xA;&#xA;    javax.lang.model.element.ElementKind extends java.lang.Enum&amp;lt;ElementKind&amp;gt;&#xA;        # 实际创建枚举类型时继承的类&#xA;        # 此类的静态方法不是Enum本身的方法，所以它们在java.lang.Enum的javadoc中没有出现。&#xA;        static ElementKind valueOf(String name)&#xA;            # 为提供的字符串返回一个枚举类型，该枚举类型必须精确地匹配源代码声明。&#xA;        static ElementKind[] values()&#xA;            # 返回一个枚举类型所有可能值的数组。&#xA;&#xA;定义1&#xA;    public enum Color {&#xA;    RED, GREEN, BLANK, YELLOW&#xA;        # 元素列表必须在最前, 如果元素列表后面没有东西的话，可以省略分号&#xA;        // 枚举的构造方法必须是私有的&#xA;        // private WeekDay() {&#xA;        //}&#xA;    }&#xA;&#xA;定义2&#xA;    enum Signal {&#xA;    GREEN, YELLOW, RED&#xA;    }&#xA;&#xA;定义3&#xA;    自定义构造（要注意必须在enum的实例序列最后添加一个分号）&#xA;    public enum Color {&#xA;        RED(&amp;quot;红色&amp;quot;, 1), GREEN(&amp;quot;绿色&amp;quot;, 2), BLANK(&amp;quot;白色&amp;quot;, 3), YELLO(&amp;quot;黄色&amp;quot;, 4);&#xA;        // 成员变量&#xA;        private String name;&#xA;        private int index;&#xA;        // 构造方法&#xA;        private Color(String name, int index) {&#xA;            this.name = name;&#xA;            this.index = index;&#xA;        }&#xA;        // 普通方法&#xA;        public static String getName(int index) {&#xA;            for (Color c : Color.values()) {&#xA;            if (c.getIndex() == index) {&#xA;                return c.name;&#xA;            }&#xA;            }&#xA;            return null;&#xA;        }&#xA;        // get set 方法&#xA;        public String getName() {&#xA;            return name;&#xA;        }&#xA;        public void setName(String name) {&#xA;            this.name = name;&#xA;        }&#xA;        public int getIndex() {&#xA;            return index;&#xA;        }&#xA;        public void setIndex(int index) {&#xA;            this.index = index;&#xA;        }&#xA;    }&#xA;使用&#xA;    public enum TrafficLamp {&#xA;        RED(30) {&#xA;&#xA;            @Override&#xA;            public TrafficLamp nextLamp() {&#xA;                return GREEN;&#xA;            }&#xA;        },&#xA;        GREEN(45) {&#xA;            @Override&#xA;            public TrafficLamp nextLamp() {&#xA;                return YELLOW;&#xA;            }&#xA;        },&#xA;        YELLOW(5) {&#xA;            @Override&#xA;            public TrafficLamp nextLamp() {&#xA;                return RED;&#xA;            }&#xA;        };&#xA;        public abstract TrafficLamp nextLamp();&#xA;&#xA;        private int time;&#xA;&#xA;        private TrafficLamp(int time) {&#xA;            this.time = time;&#xA;        }&#xA;    }&#xA;    @Test&#xA;    public void testHere() {&#xA;        WeekDay weekDay = WeekDay.MON;&#xA;        weekDay.toString();&#xA;        weekDay.name();&#xA;        // 排行&#xA;        weekDay.ordinal();&#xA;        WeekDay.valueOf(&amp;quot;SUN&amp;quot;);&#xA;        WeekDay.values();&#xA;    }&#xA;自己实现&#xA;    public abstract class WeekDay {&#xA;        private WeekDay() {&#xA;        };&#xA;&#xA;        /*&#xA;        * public WeekDay nextDay(){ if(this == SUN){ return MON; }else { return&#xA;        * SUN; } }&#xA;        */&#xA;&#xA;        public abstract WeekDay nextDay();&#xA;&#xA;        public final static WeekDay SUN = new WeekDay() {&#xA;&#xA;            @Override&#xA;            public WeekDay nextDay() {&#xA;                return MON;&#xA;            }&#xA;        };&#xA;        public final static WeekDay MON = new WeekDay() {&#xA;&#xA;            @Override&#xA;            public WeekDay nextDay() {&#xA;                return SUN;&#xA;            }&#xA;        };&#xA;&#xA;        @Override&#xA;        public String toString() {&#xA;            return this == SUN ? &amp;quot;SUN&amp;quot; : &amp;quot;MON&amp;quot;;&#xA;        }&#xA;    }&#xA;使用接口组织枚举&#xA;    public interface Food {&#xA;    enum Coffee implements Food{&#xA;        BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO&#xA;    }&#xA;    enum Dessert implements Food{&#xA;        FRUIT, CAKE, GELATO&#xA;    }&#xA;    }&#xA;用switch判断&#xA;    # JDK1.6之前的switch语句只支持int,char,enum类型&#xA;    enum Signal {&#xA;    GREEN, YELLOW, RED&#xA;    }&#xA;    public class TrafficLight {&#xA;    Signal color = Signal.RED;&#xA;    public void change() {&#xA;        switch (color) {&#xA;        case RED:&#xA;        color = Signal.GREEN;&#xA;        break;&#xA;        case YELLOW:&#xA;        color = Signal.RED;&#xA;        break;&#xA;        case GREEN:&#xA;        color = Signal.YELLOW;&#xA;        break;&#xA;        }&#xA;    }&#xA;    }&#xA;枚举的集合&#xA;    java.util.EnumSet    # 集合中的元素不重复&#xA;    java.util.EnumMap    # key是enum类型，而value则可以是任意类型。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;collection&#34;&gt;&#xA;  Collection&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#collection&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;继承结构&#xA;    &amp;lt;&amp;lt;Collection&amp;gt;&amp;gt;&#xA;        &amp;lt;&amp;lt;Queue&amp;gt;&amp;gt;&#xA;            PriorityQueue&#xA;            &amp;lt;&amp;lt;Deque&amp;gt;&amp;gt;&#xA;                ArrayDeque&#xA;        &amp;lt;&amp;lt;List&amp;gt;&amp;gt;&#xA;            ArrayList&#xA;            LinkedList  # 实现&amp;lt;&amp;lt;Deque&amp;gt;&amp;gt;&#xA;            Vector&#xA;                Stack&#xA;        Set&#xA;            HashSet&#xA;            EnumSet&#xA;            &amp;lt;&amp;lt;SortedSet&amp;gt;&amp;gt;&#xA;                TreeSet&#xA;    &amp;lt;&amp;lt;Map&amp;gt;&amp;gt;&#xA;        HashMap&#xA;        LinkedHashMap&#xA;        &amp;lt;&amp;lt;SortedMap&amp;gt;&amp;gt;&#xA;            TreeMap&#xA;Arrays&#xA;    fill()                      # 赋初值&#xA;    asList()                    # 数组转List&#xA;    sort()&#xA;    binarySearch()&#xA;    equals()                    # 数组比较&#xA;    parallelPrefix()            # 前值和，如0, 1, 2, 3 处理后为 0, 1, 3, 6。&#xA;    parallelSetAll()            # 修改值&#xA;    parallelSort()&#xA;ArrayList&#xA;    # 用数组实现，查询快，增删慢&#xA;    toArray() # 返回list中的所有元素作为一个Object []&#xA;    toArray(T[] a)  # 返回泛型类型的list中的所有元素&#xA;&#xA;    trimToSize()    # 优化掉删除出现的空位&#xA;&#xA;    stream()&#xA;    parallelStream()  # 并行流&#xA;    实现&#xA;        public ArrayList() {&#xA;            array = EmptyArray.OBJECT;&#xA;        }&#xA;        public ArrayList(int capacity) {&#xA;            if (capacity &amp;lt; 0) {&#xA;                throw new IllegalArgumentException(&amp;quot;capacity &amp;lt; 0:&amp;quot; + capacity);&#xA;            }&#xA;            array = (capacity == 0 ? EmptyArray.OBJECT : new Object[capacity]);&#xA;        }&#xA;        public ArrayList(Collection&amp;lt;? extends E&amp;gt; collection) {&#xA;            if (collection == null) {&#xA;                throw new NullPointerException(&amp;quot;collection == null&amp;quot;);&#xA;            }&#xA;&#xA;            Object[] a = collection.toArray();&#xA;            if (a.getClass() != Object[].class) {&#xA;                Object[] newArray = new Object[a.length];&#xA;                System.arraycopy(a, 0, newArray, 0, a.length);&#xA;                a = newArray;&#xA;            }&#xA;            array = a;&#xA;            size = a.length;&#xA;        }&#xA;        @Override&#xA;        public boolean add(E object) {&#xA;            Object[] a = array;&#xA;            int s = size;&#xA;            if (s == a.length) {&#xA;                Object[] newArray = new Object[s +&#xA;                (s &amp;lt; (MIN_CAPACITY_INCREMENT / 2) ?&#xA;                MIN_CAPACITY_INCREMENT : s &amp;gt;&amp;gt; 1)];&#xA;            System.arraycopy(a, 0, newArray, 0, s)&#xA;            array = a = newArray;&#xA;            }&#xA;            a[s] = object;&#xA;            size = s + 1;&#xA;            modCount++;     // 修改次数&#xA;            return true;&#xA;        }&#xA;        @Override&#xA;        public E remove(int index){&#xA;            Object[] a = array;&#xA;            int s = size;&#xA;            if (index &amp;gt;= s) {&#xA;                throwIndexOutOfBoundsException(index, s);&#xA;            }&#xA;            @SuppressWarnings(&amp;quot;unchecked&amp;quot;)&#xA;            E result = (E) a[index];&#xA;            System.arraycopy(a, index + 1, a, index, --s - index);&#xA;            a[s] = null;&#xA;            size = s;&#xA;            modCount++;&#xA;            return result;&#xA;        }&#xA;        @Override&#xA;        public void clear() {&#xA;            if (size != 0) {&#xA;                Arrays.fill(array, 0, size, null);&#xA;                size = 0;&#xA;                modCount++;&#xA;            }&#xA;        }&#xA;LinkedList&#xA;    # 循环双向链表实现，增删快，查询慢&#xA;&#xA;    类&#xA;        Entry&#xA;Vector&#xA;    # 数组实现，线程安全，增删慢，查询慢&#xA;&#xA;HashMap&#xA;    # hash表实现，支持null的键和值&#xA;    实现&#xA;        数组存Entry, 位置称为bucket&#xA;        Entry为元素，单链表拉链解决碰撞&#xA;        hashcode(key)得到bucket索引&#xA;        扩容要rehash&#xA;    类&#xA;        Entry&#xA;&#xA;    computeIfAbsent()                                               # 无值时用计算新值&#xA;    forEach()&#xA;LinkedHashMap&#xA;    # 继承HashMap，hash表和链表实现，保存了插入顺序&#xA;HashTable&#xA;    # 线程安全，不支持null的键和值&#xA;TreeMap&#xA;    # 红黑树实现，有序，实现SortedMap接口&#xA;&#xA;HashSet&#xA;    # HashMap实现，有时需要重写equals()和hashCode()&#xA;    # HashSet先按hashCode分区, 后比较equals的值再存放。修改参与hashCode值运算的属性后, 该元素删除会因无法定位,导致内存泄漏&#xA;LinkedHashSet&#xA;    # 继承HashSet。LinkedHashMap实现&#xA;List、Map、Set区别&#xA;    List、Set单列，Map双列&#xA;    List有序可重复, 可索引, Map无序，键不重复，值可重复，Set无序，不重复&#xA;Queue&#xA;    Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;String&amp;gt;();&#xA;    queue.offer(&amp;quot;a&amp;quot;);            # 添加&#xA;    queue.poll();                # 返回第一个元素并删除&#xA;    queue.element();            # 返回第一个元素, empty时抛异常&#xA;    queue.peek();                # 同element(), 但empty时返回null&#xA;Collections&#xA;    sort(List, Comparator)&#xA;    synchronizedCollection()&#xA;        # 线程不安全集合方法调用前加锁&#xA;    synchronizedList()&#xA;    synchronizedMap()&#xA;    synchronizedSet()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;流&#34;&gt;&#xA;  流&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;函数流特点&#xA;    Iterator是外部迭代，串行化操作。Stream是内部迭代, 自动并行处理&#xA;    方法分惰性和及早执行&#xA;    有序集合有序处理，无序集合无序处理&#xA;Stream&#xA;    of()                                                            # 静态方法，产生流&#xA;&#xA;    forEach()&#xA;    collect()                                                       # 用收集器, 转出结构化数据&#xA;        collect(Collectors.toList())                                # 转出List&#xA;    map()&#xA;        map(s -&amp;gt; s.toUpperCase())&#xA;    reduce()&#xA;        reduce(0, (acc, element) -&amp;gt; acc + element)                  # acc是累加器&#xA;    filter()&#xA;        filter(s -&amp;gt; isDigit(s.charAt(0)))&#xA;    flatMap()                                                       # 平铺多stream&#xA;        flatMap(numbers -&amp;gt; numbers.stream())&#xA;    min()&#xA;        min(Comparator.comparing(track -&amp;gt; track.getLength()))&#xA;    max()&#xA;    peek()&#xA;    get()                                                           # 执行得到结果&#xA;    count()&#xA;&#xA;    mapToInt()                                                      # IntStream, LongStream, DoubleStream, 对基本类型做特殊优化(如不装箱占内存)&#xA;IntStream&#xA;    range(0, N)&#xA;    sequential()                                                    # 串行&#xA;    parallel()                                                      # 并行, fork-join结构。注意数据结构(arrayList快于linkedList)。有状态操作会线程通信, 如sorted, distinct, limit&#xA;    mapToObj()&#xA;    summaryStatistics()&#xA;IntSummaryStatistics&#xA;    getAverage()&#xA;Optional&#xA;    of(&amp;quot;a&amp;quot;)&#xA;    ofNullable(null)&#xA;    empty()&#xA;&#xA;    get()                                                           # 空时抛异常&#xA;    isPresent()&#xA;    ifPresent((s) -&amp;gt; {})&#xA;    orElse(&amp;quot;b&amp;quot;)                                                     # 空返回b&#xA;    orElseGet(() -&amp;gt; &amp;quot;b&amp;quot;)&#xA;    orElseThrow(ValuesAsentException::new)&#xA;    map((s) -&amp;gt; s + &amp;quot;b&amp;quot;)                                             # map非空值，返回Optional&#xA;    flatMap((s) -&amp;gt; Optinal.of(s + &amp;quot;b&amp;quot;))&#xA;    filter((s) -&amp;gt; s.length() &amp;gt; 6)&#xA;Collectors&#xA;    toList()&#xA;    toSet()&#xA;    toCollection(TreeSet::new)&#xA;    minBy()&#xA;    maxBy()&#xA;    averagingInt()&#xA;    summingInt()&#xA;    partitioningBy()                                                # 按true, false分两组&#xA;    groupingBy()                                                    # 分多组&#xA;    joining(&amp;quot;,&amp;quot;, &amp;quot;[&amp;quot;, &amp;quot;]&amp;quot;)                                          # 拼字符串, 传参是分隔符、前缀、后缀&#xA;&#xA;    o-&amp;gt; 自定义收集器&#xA;    public class StringCombiner {&#xA;        public StringCombiner add(String element) {&#xA;            if (atStart()) {&#xA;                builder.append(prefix);&#xA;            } else {&#xA;                builder.append(delim);&#xA;            }&#xA;            builder.append(element);&#xA;            return this;&#xA;        }&#xA;        public StringCombiner merge(StringCombiner other) {&#xA;            builder.append(other.builder);&#xA;            return this;&#xA;        }&#xA;    }&#xA;    public class StringCollector implements Collector&amp;lt;String, StringCombiner, String&amp;gt; {&#xA;        public Supplier&amp;lt;StringCombiner&amp;gt; supplier(){&#xA;            return () -&amp;gt; new StringCombiner(delim, prefix, suffix);&#xA;        }&#xA;        public BiConsumer&amp;lt;StringCombiner, String&amp;gt; accumulator(){&#xA;            return StringCombiner::add;&#xA;        }&#xA;        public BinaryOperator&amp;lt;StringCombiner&amp;gt; combiner(){&#xA;            return StringCombiner::merge;&#xA;        }&#xA;        public Function&amp;lt;StringCombiner, String&amp;gt; finisher(){&#xA;            return StringCombiner::toString;&#xA;        }&#xA;        characteristics()                                           # 描述特征&#xA;    }&#xA;    o-&amp;gt; predicate&#xA;        void filter(list list, Predicate condition)&#xA;        list1.stream().filter((s) -&amp;gt; (condition.test(s))).forEach((s) -&amp;gt; { System.out.println(s)})&#xA;&#xA;&#xA;io流分类&#xA;    输入、输出&#xA;    节点流(如FileReader)、处理流(抽象处理方法)&#xA;    字节流(InputStream)、字符流(InputStreamReader)&#xA;        字节流处理一个字节，字符流包装字节流，设置编码类型映射成字符，处理字符&#xA;InputStream&#xA;    BufferedInputStream&#xA;    FileInputStream&#xA;OutputStream&#xA;    BufferedOutputStream&#xA;    FileOutputStream&#xA;Reader&#xA;    InputStreamReader&#xA;        FilerReader&#xA;    BufferedReader&#xA;        readLine()&#xA;Writer&#xA;    OutputStreamWriter&#xA;        FileWriter&#xA;    BufferedWriter&#xA;        newLine()&#xA;        write(String)&#xA;Serializable接口&#xA;    # 对象流化&#xA;    需求例如&#xA;        spring中配置的bean&#xA;        session中用到的类&#xA;    为什么实现序列化接口&#xA;        为了注册序列化序号（不显式注册会自动注册）来标识java类，区分相同类名不同包名的类&#xA;实现深拷贝&#xA;    public static &amp;lt;T extends Serializable&amp;gt; T clone(T obj) throws Exception {&#xA;        // 不必调close(), 因为gc时流对象释放&#xA;        ByteArrayOutputStream bout = new ByteArrayOutputStream()&#xA;&#xA;        ObjectOutputStream oos = new ObjectOutputStream(bout)&#xA;        oos.writeObject(obj)&#xA;&#xA;        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray())&#xA;        ObjectInputStream ois = new ObjectInputStream(bin)&#xA;&#xA;        return (T)ois.readObject()&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;并行&#34;&gt;&#xA;  并行&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e8%a1%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;线程通信&#xA;    共享变量&#xA;    wait(), notify()实现生产和消费通知&#xA;同步线程&#xA;    wait(), sleep(), notify(), notifyAll()&#xA;ThreadLocal&#xA;    # 线程内数据共享，线程隔离&#xA;    withInitial(() -&amp;gt; new SimpleDateFormat())                       # 直接get()时返回调用结果&#xA;    set(T t)                                                        # 向当前线程对象放入泛型对象&#xA;    get()                                                           # 得到当前线程已放入的对象&#xA;&#xA;InheritableThreadLocal&amp;lt;T&amp;gt;&#xA;    # 继承ThreadLocal, 子线程可使用父线程变量&#xA;Timer&#xA;    o-&amp;gt;&#xA;    class MyTask extends java.util.TimerTask{&#xA;        @Override&#xA;        public void run() {&#xA;            // TODO Auto-generated method stub&#xA;            System.out.println(&amp;quot;________&amp;quot;);&#xA;        }&#xA;    }&#xA;    Timer timer = new Timer()&#xA;    timer.schedule(new MyTask(), 1000, 2000)    // 1秒后执行，每两秒执行一次&#xA;    timer.cancel();     // 停止任务&#xA;Thread&#xA;    currentThread().getContextClassLoader().getResource(&amp;quot;/&amp;quot;).getPath()  # 静态路径&#xA;    run()&#xA;    start()&#xA;    sleep() # 占有锁&#xA;    o-&amp;gt;&#xA;        # 异常抛出不到父线程&#xA;    new Thread(){&#xA;        @Override&#xA;        public void run(){&#xA;            while(count &amp;gt; 0){&#xA;                synchronized(AboutThread.class){&#xA;                    count--;&#xA;                }&#xA;            }&#xA;        }&#xA;    }.start();&#xA;&#xA;    o-&amp;gt;&#xA;        # 异常抛出不到父线程&#xA;    new Thread(new Runnable() {&#xA;        @Override&#xA;        public void run() {&#xA;            while(count &amp;gt; 0){&#xA;                synchronized(AboutThread.class){&#xA;                    count--;&#xA;                }&#xA;            }&#xA;        }&#xA;    }).start();&#xA;&#xA;FutureTask  # java5&#xA;    o-&amp;gt;&#xA;        # 有结果和异常&#xA;    FutureTask&amp;lt;String&amp;gt; future = new FutureTask(new Callable&amp;lt;String&amp;gt;(){&#xA;        @Override&#xA;        public String call() {&#xA;            return &amp;quot;&amp;quot;&#xA;        }&#xA;    })&#xA;    new Thread(future).start()&#xA;    future.get()&#xA;java.util.concurrent&#xA;    Executors   # 线程池工厂&#xA;        策略&#xA;            1 创建并设置&#xA;            2 execute()时&#xA;                1 线程数小于corePoolSize, 创建线程并执行&#xA;                2 线程数大于或等于corePoolSize, 任务入队列&#xA;                3 队列满，线程数小于maximumPoolSize, 创建线程并执行&#xA;                4 队列满，线程数大于maximumPoolSize, 抛出异常&#xA;            3 线程完成任务，从队列取任务执行&#xA;            4 线程空闲，超过keepAliveTime, 运行线程大于corePoolSize, 线程停掉&#xA;        newFixedThreadPool(3)   # 固定数量&#xA;            ExecutorService Pool = Executors.newFixedThreadPool(2);&#xA;            pool.execute(new MyRunnable())&#xA;            pool.shutdown()&#xA;        newCachedThreadPool()   # 根据情况创建数量&#xA;        newSingleThreadExecutor()   # 数量为1&#xA;        newScheduledThreadPool(2)   # 延时&#xA;            ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);&#xA;            Thread r1 = new MyRunnable();&#xA;            pool.execute();&#xA;            pool.schedule(r1, 10, TimeUnit.MILLISECONDS);    # t1在10秒后执行&#xA;            pool.shutdown();&#xA;    &amp;lt;&amp;lt;ExecutorService&amp;gt;&amp;gt;&#xA;        execute(Runnable)&#xA;        submit(Runnable)        # 返回Future&#xA;            # submit(Callable)&#xA;        invokeAny()     # 返回执行最快的一个结果&#xA;        invokeAll()     # 所有执行结束后返回&#xA;        shutdown()  #   只interrupt()空闲线程&#xA;        shutdownNow()   # interrupt()所有线程&#xA;    ThreadPoolExecutor&#xA;        corePoolSize    # 最小数量&#xA;        maximumPoolSize # 最大数量&#xA;        keepAliveTime   # 线程空闲等待时间&#xA;    &amp;lt;&amp;lt;ScheduledExecutorService&amp;gt;&amp;gt;&#xA;        schedule(r1, 10, TimeUnit.MILLISECONDS) # 10秒后执行&#xA;        scheduleAtFixedRate(r1, 1, 2, TimeUnit.MILLISECONDS)    # 1秒后执行，2秒一次，间隔计算开始时间。异常直接关闭&#xA;        scheduleWithFixedDelay(r1, 1, 2, TimeUnit.MILLISECONDS)     # 同上，间隔计算结束时间&#xA;    ScheduledExecutorPoolService&#xA;&#xA;&#xA;    ForkJoinPool    # java7&#xA;        ForJoinPool(4)  # 并行级别&#xA;        invoke()&#xA;    RecursiveAction # 没返回值&#xA;        MyRecursiveAction extends RecursiveAction {&#xA;            @Override&#xA;            protected void compute() {&#xA;                new MyRecursiveAction().fork()&#xA;            }&#xA;        }&#xA;    RecursiveTask   # 有返回值&#xA;        MyRecursiveTask extends RecursiveTask&amp;lt;Long&amp;gt; {&#xA;            @Override&#xA;            protected Long Compute() {&#xA;                MyRecursiveTask t1 = new MyRecursiveTask()&#xA;                t1.fork()&#xA;                retrun t1.join()&#xA;            }&#xA;        }&#xA;&#xA;&#xA;    CopyOnWriteArrayList&#xA;        # 列表被修改时，使用旧副本(保护性复制)&#xA;    &amp;lt;&amp;lt;BlockingQueue&amp;gt;&amp;gt;   # 锁实现，插入和取值阻塞, 不能插入null&#xA;        add()   # 抛异常&#xA;        offer() # 超时退出，返回特殊值&#xA;        put()   # 阻塞&#xA;        remove()    # 抛异常&#xA;        poll()      # 超时退出，返回特殊值&#xA;        take()      # 阻塞&#xA;        element()   # 检查，抛异常&#xA;        peek()      # 返回特殊值&#xA;    ArrayBlockingQueue  # 固定大小&#xA;        size()&#xA;&#xA;        o-&amp;gt;&#xA;        queue.put(new PoisonPill())     # 毒丸, 标志数据取完&#xA;        obj.isPoisonPill()&#xA;    LinkedBlockingQueue     # 链式&#xA;        # 两个ReentrantLock(可重入锁)分别控制元素入队和出队&#xA;        # tomcat用TaskQueue的父类，它重写offer方法减少创建多余线程&#xA;    PriorityBkockingQueue   # 无界，排序&#xA;        # 一个独占锁控制入队和出队, 通过cas(无锁算法)保证同时只有一个线程扩容成功&#xA;    DelayQueue  # 无界, 延迟期满才能提取。内部用PriorityQueue实现&#xA;    SynchronousQueue    # 单元素, cas实现&#xA;    ConcurrentQueue&#xA;        add()&#xA;        offer()&#xA;        poll()&#xA;        peek()&#xA;    ConcurrentLinkedQueue   # 无界队列, 使用cas&#xA;        isEmpty()&#xA;        size()&#xA;        remove()&#xA;        contains()&#xA;    ConcurrentHashMap&#xA;        # 并发集合通过复杂的策略提高效率, 用ReentrantLock&#xA;        # 加了concurrencyLevel属性，决定锁分段个数，取2的次幂。内部用分段锁技术，每段Segment中再存放Entity[]数组&#xA;    ConcurrentSkipListMap   # 非阻塞Hash跳表, 功能同TreeMap，线程安全，用跳表实现&#xA;java.util.concurrent.atomic     # 基本数据&#xA;    AtomicBoolean&#xA;        get()&#xA;        set()&#xA;        getAndSet()&#xA;        compareAndSet()&#xA;    AtomicInteger&#xA;        get()&#xA;        set()&#xA;        getAndSet()&#xA;        compareAndSet()&#xA;        getAndIncrement()&#xA;        getAndDecrement()&#xA;        getAndAdd()&#xA;    AtomicIntegerArray  # 对int[]类型封装，使用Unsafe类通过cas方式实现线程安全&#xA;        get()&#xA;        length()&#xA;        getAndSet()&#xA;        compareAndSet()&#xA;        getAndIncrement()&#xA;        getAndDecrement()&#xA;        addAndGet()&#xA;    AtomicLong&#xA;    AtomicLongArray&#xA;&#xA;    Semaphore&#xA;        # 信号量控制并发&#xA;        semaphore(5, true)  # 5个信号量，公平(先启动线程大概率先获得锁)&#xA;        o-&amp;gt;&#xA;        Semaphore semaphore = new Semaphore(5, true)&#xA;        semaphore.acquire()&#xA;        semaphore.release()&#xA;java.util.concurrent.locks     # 锁&#xA;    &amp;lt;&amp;lt;Lock&amp;gt;&amp;gt;    # 主要是可重入锁，非阻塞结构上下文使用&#xA;        ReentrantLock&#xA;            # 多线程不可同时访问一个类中2个加Lock的方法, 因为是2个锁。&#xA;            lock()&#xA;            unlock&#xA;                # 用lock, unlock可设置交替锁(hand-over-hand locking), 轮流锁、解锁一部分&#xA;            tryLcok()&#xA;                # 可设置超时&#xA;                # 同时超时，再尝试失败再尝试而进入活锁。设置不同超时时间减少活锁机率&#xA;            lockInterruptibly()&#xA;                # 突破死锁&#xA;            newCondition()&#xA;                # 条件变量, 原子地阻塞并解锁，直到条件满足(如有容量，队列非空)&#xA;                condition.await()&#xA;                condition.signal()&#xA;                condition.signalAll()&#xA;    &amp;lt;&amp;lt;ReadWriteLock&amp;gt;&amp;gt;   # 读写锁，写独占&#xA;    &amp;lt;&amp;lt;Condition&amp;gt;&amp;gt;   # 替代wait(), notify()&#xA;        await()&#xA;        signal()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内省&#34;&gt;&#xA;  内省&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%9c%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# IntroSpector，操作javabean&#xA;例子&#xA;    Point p = new Point();&#xA;    PropertyDescriptor pd = new PropertyDescriptor(&amp;quot;x&amp;quot;, p.getClass());&#xA;    Method methodGetX = pd.getReadMethod();&#xA;    Method methodSetX = pd.getWriteMethod();&#xA;    methodSetX.invoke(p, 7);&#xA;    System.out.println(methodGetX.invoke(p));&#xA;&#xA;    BeanInfo beanInfo = Introspector.getBeanInfo(p.getClass());&#xA;    PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();&#xA;    for(PropertyDescriptor pd2 : pds){&#xA;        if(pd.getName().equals(&amp;quot;x&amp;quot;)){&#xA;            System.out.println(pd.getReadMethod().invoke(p));&#xA;            break;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;反射&#34;&gt;&#xA;  反射&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%8d%e5%b0%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 类中成分映射为类&#xA;字节码&#xA;    Class类型对象指向类加载器中加载的字节码&#xA;    Class对象不可以new, 因为字节码是类加载器中加载的, 不可能new出来&#xA;    虚拟机中同一个类的字节码只有一份&#xA;    预定义的class实例对象9个&#xA;        # 包装类型中Type就是class，如int.class == Integer.Type&#xA;        # void的包装类型为Void&#xA;        void&#xA;        byte short int long&#xA;        float double&#xA;        boolean&#xA;        char&#xA;    获得字节码三种方法&#xA;        Class.forName(类名)&#xA;        类名.class&#xA;        this.getClass()&#xA;    内部类&#xA;        内部类不为public时，会在前面加上public 的类的类名和$，所以不能用其类名.class来得到它的字节码&#xA;    泛型&#xA;        父类可以通过反射泛型类得到泛型的class, 通过该class创建泛型实例&#xA;        方法中泛型类实例通过传入class创建(如dbutils)&#xA;用途&#xA;    1. 根据配置文件实例化并注入对象(如spring)&#xA;    2. 实现框架&#xA;        # 运行时调用自定义类的指定方法(如struts的Action)&#xA;代理&#xA;    动态代理机制  # 运行时确定, 用来AOP编程&#xA;        没有接口的类：CGlib通过派生子类实现。运行时动态修改字节码&#xA;        有接口的类:Proxy生成代理，但是生成的类是接口类型&#xA;    静态代理    # 代理指定类，编译时确定&#xA;&#xA;Class&#xA;    Type        # 该类对应的字节码对象&#xA;&#xA;    isPrimitive()       # 是否是基本类型&#xA;    isArray()       # 是否是数组&#xA;    getConstructor(Class&amp;lt;?&amp;gt;... parameterTypes)&#xA;    newInstance()                    # 用不带参数的构造方法创建对象&#xA;    getField(&amp;quot;y&amp;quot;) : Field                    # 得到属性&#xA;        field.get(该class的对象);            # 得到属性的值&#xA;    getDeclaredField(&amp;quot;x&amp;quot;) : Field&#xA;        field.setAccessible(true);&#xA;        field.get(该class的对象);            # 暴力反射&#xA;    getFields() : Field[]&#xA;        field.set(该class的对象, 新的值);&#xA;    getMethod(方法名, 方法参数类型的字节码对象) : Method&#xA;        method.invoke(该class的对象, 该方法的参数);&#xA;            # invoke中调用对象为null表是调用静态方法&#xA;            # 注意，jdk1.5中为了兼容jdk1.4(jdk1.4中如果用到可变参数传递的是一个参数的数组),&#xA;            ## 在invoke中第二个参数为数组时，会把数组拆开成可变参数传递。但是这样的话，当我们传递的参数本身就是数组时，&#xA;            ## 如main(String[] args)中的参数, 就会变成多个参数。解决办法是：对要传递的数组参数进行打包，&#xA;            ## 如new Object[]{new String[]{&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;}},&#xA;                # 注：基本类型的数组是Object对象，String[]不是Object对象，而是Object[]对象&#xA;            ## 参数也可以写成(Object)new String[]{&amp;quot;aa&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;cc&amp;quot;};&#xA;                # 这里把Object[]强转为是个Object对象, 这样jdk就不会对数组对象Object[]进行拆分了&#xA;    getClassLoader()&#xA;        getResourceAsStream(&amp;quot;&amp;quot;)                    # 相对路径从class根目录开始。没有绝对路径，&amp;quot;/&amp;quot;会报错&#xA;    getResourceAsStream(&amp;quot;&amp;quot;)                        # 相对路径从当前包目录开始。&amp;quot;/&amp;quot;绝对路径从class根目录开始&#xA;&#xA;    使用class&#xA;        Class cls1 = Data.class;                    # 虚拟机中已经加载过该类的字节码时&#xA;        Class cls2 = p1.getClass();&#xA;        Class cls3 = Class.forName(&amp;quot;java.lang.String&amp;quot;);        # 在虚拟机中没有加载过该类的字节码时&#xA;    使用constructor新建实例&#xA;        Constructor constructor1 = String.class.getConstructor(StringBuffer.class);&#xA;        String str1 = (String)constructor1.newInstance(new StringBuffer(&amp;quot;abc&amp;quot;));&#xA;    数组&#xA;        class上的isArray()判断是否数组&#xA;            # 不同维度(一维、二维等), 不同类型的数组，不是同一份字节码。只有同维度同类型的数组是相同的字节码&#xA;            ## 基本类型的数组是Object对象，如int[]。String[]是一个Object[]对象，不是Object对象&#xA;            Arrays.asList()&#xA;                # 打印Object[], 不能打印基本类型数组的Object&#xA;            Array.getLength(obj)&#xA;                # 得到长度&#xA;            Array.get(obj, i)&#xA;                # 得到数组中的元素&#xA;                # 没有办法得到int[] 对象的元素类型(即int), 只能取得其元素之后得到其类型&#xA;    泛型&#xA;        public class BaseDao&amp;lt;T&amp;gt; 中&#xA;            // 得到的是继承类的字节码&#xA;            // hibernate.basedao2.HeroDao&#xA;            Class subClass = this.getClass();&#xA;            // 直接超类&#xA;            // hibernate.basedao2.BaseDao&amp;lt;hibernate.domain.Hero&amp;gt;&#xA;            Type type = subClass.getGenericSuperclass();&#xA;            // 得到参数&#xA;            ParameterizedType pt = (ParameterizedType) type;&#xA;            // 参数数组&#xA;            Type[] types = pt.getActualTypeArguments();&#xA;            // hibernate.domain.Hero&#xA;            type = types[0];&#xA;            //User&#xA;            this.clazz= (Class) type;&#xA;Proxy   # 只代理有接口的类&#xA;    o-&amp;gt;&#xA;    final List&amp;lt;String&amp;gt; list = newArrayList&amp;lt;String&amp;gt;()&#xA;    List&amp;lt;String&amp;gt; proxyInstance = (List&amp;lt;String&amp;gt;) Proxy.newProxyInstance(list.getClass().getClassLoader(), list.getClass().getInterfaces(), new InvocationHandler() {&#xA;        @Override&#xA;        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{&#xA;            return method.invoke(list, args)&#xA;        }&#xA;    })&#xA;    proxyInstance.add(1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;web-service&#34;&gt;&#xA;  web service&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web-service&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;常识&#xA;    基于socket                # socket可以跨语言访问&#xA;        # 单用socket提供网络服务出现的问题：&#xA;        1.不能处理不同协议的请求，如http协议发送的是请求头信息&#xA;            #　http调用socket:127.0.0.1:8888/或action=&amp;quot;127.0.0.1:8888&amp;quot;&#xA;        2.添加新参数，客户端也要修改&#xA;    版本&#xA;        jdk6之后的版本开始支持web service&#xA;        jdk6不支持soap1.2&#xA;    传输标准：xml或json                # 普遍使用xml,RestFul使用json&#xA;优点&#xA;    易推广、协议匹配、便于升级（加参数）&#xA;服务方式&#xA;    # 返回的结果均为xml&#xA;    http get&#xA;    http post&#xA;        # get与post方式直接传递参数，参数易混淆，所以有soap发送xml的方式&#xA;    soap1.1&#xA;    soap1.2&#xA;soap&#xA;    常识：&#xA;        soap:simple object access protocol&#xA;        soap是以post方式传输的&#xA;&#xA;    内容&#xA;        请求soap&#xA;            &amp;lt;soapenv:Envelope xmlns:soapenv=&amp;quot;http://schemas.xmlsoap.org/soap/envelope/&amp;quot; xmlns:q0=&amp;quot;http://my.test/&amp;quot; xmlns:xsd=&amp;quot;http://www.w3.org/2001/XMLSchema&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&amp;gt;&#xA;            &amp;lt;soapenv:Body&amp;gt;&#xA;                &amp;lt;q0:sayHello&amp;gt;&#xA;                &amp;lt;arg0&amp;gt;小明&amp;lt;/arg0&amp;gt;&#xA;                &amp;lt;/q0:sayHello&amp;gt;&#xA;            &amp;lt;/soapenv:Body&amp;gt;&#xA;            &amp;lt;/soapenv:Envelope&amp;gt;&#xA;        响应soap&#xA;            &amp;lt;S:Envelope xmlns:S=&amp;quot;http://schemas.xmlsoap.org/soap/envelope/&amp;quot;&amp;gt;&#xA;            &amp;lt;S:Body&amp;gt;&#xA;                &amp;lt;ns2:sayHelloResponse xmlns:ns2=&amp;quot;http://my.test/&amp;quot;&amp;gt;&#xA;                &amp;lt;return&amp;gt;hello,小明&amp;lt;/return&amp;gt;&#xA;                &amp;lt;/ns2:sayHelloResponse&amp;gt;&#xA;            &amp;lt;/S:Body&amp;gt;&#xA;            &amp;lt;/S:Envelope&amp;gt;&#xA;wsdl&#xA;    获得&#xA;        http://192.168.10.3:1234/hello?wsdl                # 发布url后面加?wsdl&#xA;    内容                        # 查看时从后向前看&#xA;        &amp;lt;service&amp;gt;标签&#xA;                name属性：默认 发布类名 + Service&#xA;            &amp;lt;port&amp;gt;标签&#xA;                    name属性：默认有soap1.1 soap1.2 get post(jdk1.6只有soap1.1)，默认 类名 + port&#xA;                binding属性:真正的实现者    # 指向&amp;lt;binding&amp;gt;标签&#xA;                &amp;lt;soap:address&amp;gt;标签&#xA;                        location属性:访问的地址&#xA;        &amp;lt;binding&amp;gt;标签：是真正的实现类,soap协议，是文本，方法名&#xA;        &amp;lt;portType&amp;gt;标签：&#xA;            input&#xA;            output&#xA;        &amp;lt;message&amp;gt;标签 用schema格式来描述参数类型&#xA;        xsd:schema关联的schema文件中&#xA;            &amp;lt;element&amp;gt;标签  ，约定了参数类型&#xA;创建与发布&#xA;    发布到eclipse的jetty容器&#xA;        @WebService&#xA;        MyWebService&#xA;            public String showName(Strng name)&#xA;                System.out.println(&amp;quot;name=&amp;quot; + name);&#xA;                return name + &amp;quot;你好!&amp;quot;;&#xA;            main&#xA;                Endpoint.publish(&amp;quot;http://localhost:8888/hello&amp;quot;,new MyWebService());&#xA;                                        # 发布webService&#xA;                    ## 1.6.0_13及之前的版本不支持,1.6.0_14之后的版本支持&#xA;                    ## 发布之后http://localhost:8888/hello?wsdl中有wsdl文件&#xA;    可以发布成服务的方法&#xA;            1.非final、static修饰的public方法&#xA;            2.@WebMethod(exclude=true)方法前加该注解时不发布该方法&#xA;调用&#xA;    HttpClient&#xA;        get&#xA;        post&#xA;        soap&#xA;    wsdl.xml&#xA;        #　web service提供给不同平台生成解决方案的配置文件&#xA;        ## HttpClient发送soap时充当了:wsdl.xml解决方案调用的过程&#xA;        o-&amp;gt; wsimport.exe(jdk1.6)&#xA;            解析wsdl.xml文件&#xA;                命令：wsimport -s . -p cn.itcast                # -s 保存源码（默认不保存）,-p指定包名&#xA;                生成类：&#xA;                            # jdk1.6中解析时忽略生成soap12服务类文件（jdk1.6不支持）与get post服务类文件(默认忽略)&#xA;                    XxxService&#xA;                    XxxServicePort&#xA;                    Xxx&#xA;                    ..&#xA;                调用：&#xA;                    MyWSService mywsService = new MyWSService();&#xA;                    String retVal = mywsService.getMyWSPort().sayHello();&#xA;        o-&amp;gt; myeclipse的web service soap浏览器&#xA;            # 可以从soap浏览器中查看请求和返回的soap.xml文件的源码&#xA;            |-&amp;gt; 右上角wsdl page&#xA;            |-&amp;gt; 左边栏 uddi main&#xA;            |-&amp;gt; 右边栏按提示输入即可&#xA;        o-&amp;gt; ajax&#xA;            方式一：直接调用&#xA;            缺点&#xA;                新版浏览器（ie10等）不支持跨域请求(为了安全)，所以只能请求localhost&#xA;                会把数据暴露在客户端&#xA;注解&#xA;    @WebMethod(exclude=true)    # 对此方法不进行发布&#xA;    @WebService     # 声明为web service服务类&#xA;        ## 可选属性&#xA;        name=&amp;quot;服务名&amp;quot;,&#xA;        portName=&amp;quot;端口名&amp;quot;,&#xA;        serviceName=&amp;quot;真正服务类的名字&amp;quot;,&#xA;        targetNamespace=&amp;quot;包名a.b.c&amp;quot;&#xA;    @WebResult(name=&amp;quot;&amp;quot;)     # 方法返回值类型前，指定返回值名（如果返回的是集合，则指定的是集合内元素的名）&#xA;    @WebParam(name=&amp;quot;&amp;quot;)     # 方法参数值类型前，指定参数名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;框架&#34;&gt;&#xA;  框架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;cglib&#xA;    # 构造接口&#xA;dbutils&#xA;fastjson&#xA;    # 淘宝json&#xA;beanUtils&#xA;ioUtils&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jvm&#34;&gt;&#xA;  jvm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础-2&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80-2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;继承&#xA;    被继承的对象是会单例，不会新创建。如果被继承的对象没有，则创建一个&#xA;多态&#xA;    父类(接口)中定义的引用变量，在运行时动态绑定到具体实例的方法执行&#xA;内部unicode编码&#xA;类&#xA;    初始化时机&#xA;        new&#xA;        访问静态变量，或对静态变量赋值&#xA;        调用静态方法&#xA;        反射 Class.forName(&amp;quot;&amp;quot;)&#xA;        初始化子类，会先初始化父类&#xA;        jvm启动时标明的类 (java com.a.A中的A类)&#xA;    步骤&#xA;        类加载&#xA;        链接&#xA;            验证&#xA;            准备  # 静态变量分配内存，设置默认初始值&#xA;            解析  # 符号引用替换直接引用&#xA;        初始化父类(非接口)&#xA;        初始化&#xA;            父类&#xA;            初始化语句   # 如static块和static变量&#xA;线程&#xA;    运行时都有线程栈，保存变量值信息。访问对象值时，建立变量副本。修改后(线程退出前)副本值写到对象&#xA;JIT(just in time)&#xA;    # 热点代码检测, 运行时编译和优化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# java自动管理堆栈, c++手动分配&#xA;组成&#xA;    方法区(method area)&#xA;        组成&#xA;            类信息&#xA;                class&#xA;            数据区(data segment)&#xA;                运行时常量池(constant pool) # 编译期确定，保存在.class中的数据&#xA;                    字面量&#xA;                    文本形式的符号引用&#xA;                        字段名称和描述符&#xA;                        方法名称和描述符&#xA;                        类和接口的全限定名&#xA;                静态区(static segment)&#xA;                    静态变量&#xA;            代码区(code segement)&#xA;                JIT编译后的代码&#xA;        特点&#xA;            线程共享&#xA;            静态分配, 位置不改变&#xA;    栈(stack)&#xA;        分类&#xA;            虚拟机栈(vm stack)&#xA;            本地方法栈(native method stack)&#xA;        保存&#xA;            基础数据类型&#xA;            引用类型在栈分配地址, 局部变量生命周期结束后，栈空间立即回收&#xA;            方法调用    # 一次调用一个帧(frame)&#xA;            方法的形参, 调用完回收&#xA;            方法引用参数, 在栈上分配地址, 调用完回收&#xA;            方法实参，栈空间分配，调用完释放&#xA;        特点&#xA;            线程隔离&#xA;            逻辑概念，可连续可不连续, 系统自动分配。栈中的字面值可共享,如int i = 3&#xA;            StackOverflowError&#xA;        实现&#xA;            java的stack存放的是frames, frames由heap分配，所以stack内存不连续&#xA;            只存在本地变量、返回值、调用方法，不能直接push和pop frams&#xA;    堆(heap)&#xA;        保存&#xA;            引用类型在堆分配类变量, 局部变量生命周期结束后，堆空间等待gc回收&#xA;            this&#xA;        特点&#xA;            线程共享&#xA;            以随意顺序，运行时分配和回收空间, 代码申请&#xA;            大小、数量、生命期常常在编译时不确定&#xA;            细分为新生代和老年代, 再具体为 eden survivor(from survivor、to survivor), tenured&#xA;            OutOfMemoryError&#xA;        实现&#xA;            存放所有runtime data&#xA;            heap是jvm启动时创建&#xA;    程序计数器(program counter register)&#xA;        特点&#xA;            线程隔离&#xA;机制&#xA;    程序计数器、虚拟机栈、本地方法栈 是线程私有空间&#xA;        随线程产生和销毁，每个栈帧分配多少内存在随类结构确定。内存分配回收都是确定的&#xA;    方法区和堆&#xA;        一个接口的各实现类需要内存可能不一样, 所以运行时才知道创建哪些对象，内存分配和回收是动态的，gc主要关注&#xA;内存溢出&#xA;    原因&#xA;        加载数据过大  # 大约10万条以上, 应分页查询&#xA;        集合中对象引用未清除&#xA;        代码循环产生对象&#xA;        第三方软件bug&#xA;        启动参数内存设置过小&#xA;    方案&#xA;        jvm启动参数 -Xms, -Xmx&#xA;        jvm错误日志, OutOfMemory前信息&#xA;        内存查看工具动态查看&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类加载器&#34;&gt;&#xA;  类加载器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;父亲委派机制(java2)&#xA;    # 常用类不被替代&#xA;    先试上层类加载器&#xA;&#xA;4种类加载器(加载类文件位置不同)&#xA;    层级关系&#xA;        # 父级类加载器向下加载子加载&#xA;        BootStrap&#xA;            ExtClassLoader&#xA;                AppClassLoader&#xA;                    自己的类加载器&#xA;    优先级&#xA;        只加载层级关系靠前面的同名类&#xA;&#xA;    BootStrap&#xA;        # c++写的二进制代码，jvm中启动时创建,无法获得引用对象&#xA;        位置&#xA;            JRE/lib/rt.jar  # java9后为jrt-fs.jar&#xA;            参数-Xbootclasspath指定&#xA;        代码&#xA;            System.class.getClassLoader()&#xA;                # null&#xA;                ## 说明是BootStrap类加载器加载的，不能得到该类加载器&#xA;    ExtClassLoader(sun.misc.Launcher$ExtClassLoader)&#xA;        位置&#xA;            JRE/lib/ext/*.jar&#xA;            参数-Djava.ext.dirs指定&#xA;    AppClassLoader(sun.misc.Launcher$AppClassLoader)&#xA;        位置&#xA;            环境变量CLASSPATH 或 系统属性java.class.path&#xA;            参数-cp覆盖&#xA;        代码&#xA;            ClassLoaderText.class.getClassLoader().getClass().getName()&#xA;                # AppClassLoader&#xA;    自定义     # 如tomcat的StandardClassLoader&#xA;        # 继承ClassLoader&#xA;api&#xA;    TestClass.class.getClassLoader()&#xA;        getParent()                        # 得到加载该类加载器的类加载器&#xA;        loadClass(String name)                # 找parent委托，没有加载时执行findClass(String name)&#xA;                                                ## 模板方法的设计模式，见 note-&amp;gt; 设计模式&#xA;        findClass(String name)                # 自己加载&#xA;        defineClass(..)                                # 将二进制数据转换为class&#xA;    线程&#xA;        # 该线程类加载器加载线程中的第一个类&#xA;        线程.setContextClassLoader(ClassLoader cl)    # 指定一个线程的类加载器&#xA;自己的类加载器&#xA;    挂在AppClassLoader下面&#xA;    加载指定的目录&#xA;        该目录下的class加密后，自己的类加载器解密&#xA;    写法&#xA;        覆盖findClass(String name)&#xA;    例子&#xA;        public class MyClassLoader extends ClassLoader{&#xA;            private String classDir;&#xA;            @Override&#xA;            protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException{&#xA;                // 传入的name是全限定名&#xA;                String classFileName = classDir + &amp;quot;\\&amp;quot; + name.substring(name.lastIndexOf(&#39;.&#39;) + 1) + &amp;quot;.class&amp;quot;;&#xA;                // 处理异常&#xA;                FileInputStream fis = new FileInputStream(classFileName);&#xA;                ByteArayOutputStream bos = new ByteArraOutputStream();&#xA;                cypher(fis, bos);&#xA;                fis.close();&#xA;                byte[] bytes = bos.toByteArray();&#xA;                return defineClass(bytes, 0, bytes.length);&#xA;                // 抛出异常时 return super.findClass(name);&#xA;            }&#xA;            public MyClassLoader(){}&#xA;            public MyClassLoader(String classDir){this.classDir = classDir;}&#xA;            private static void cypher(InputStream ips, OutputStream ops){...}&#xA;        }&#xA;        // 删掉父类的ClassLoaderAttachment.class&#xA;        // new 的MyClassLoader挂在了AppClassLoader这个类加载器上&#xA;        Class clazz = new MyClassLoader(&amp;quot;itcastLib&amp;quot;).loadClass(&amp;quot;cn.itcast.day2.ClassLoaderAttachment&amp;quot;);&#xA;        // 错误写法。因为这样写 jvm编译器要加载ClassLoaderAttachment类，但是该类已经加密&#xA;        ClassLoaderAttachment d1 = (ClassLoaderAttachment)clazz.newInstance();&#xA;        // 正确写法。用该加密类继承的父类来引用它的实例&#xA;        Date d1 = (Date)clazz.newInstance();&#xA;servlet部署&#xA;    tomcat类加载器&#xA;        AppClassLoader&#xA;            StandardClassLoader&#xA;                WebappClassLoader&#xA;    输出Servlet.class的jar与servlet-api.jar到jdk/lib/ext&#xA;        # 因为servlet.class加载的时候需要HttpServlet类，该类在tomcat提供的servlet-api.jar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;规范&#34;&gt;&#xA;  规范&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%84%e8%8c%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;命名与写法&#xA;    包名 小写、只用一个单词、只用单数&#xA;    类名 UpperCamelCase&#xA;        类名可以使用复数&#xA;        抽象类开头 Abstract或Base&#xA;        异常类结尾 Exception&#xA;        测试类以要测试类名开始，以Test结尾&#xA;        使用的设计模式，可以写在类名上&#xA;        接口类形容能力时，用形容词做名字(一般是-able, 如Translatable)&#xA;            实现类1: 结尾加Impl&#xA;            实现类2: Translatable的实现类名Translator&#xA;        枚举类结尾加Enum&#xA;            成员全大写,下划线隔开&#xA;    方法名、参数名、成员变量、局部变量 lowerCamelCase&#xA;        获得单个对象前缀get&#xA;        获得多个对象前缀list&#xA;        获得统计值前缀count&#xA;        插入前缀save或insert&#xA;        删除前缀remove或delete&#xA;        修改前缀update&#xA;        方法按顺序排列&#xA;            # 公有或保护 -&amp;gt; 私有 -&amp;gt; getter/setter&#xA;    常量 MAX_COUNT&#xA;    布尔类型变量不以is开头&#xA;    保留字和运算符左右加空格, 参数逗号后加空格&#xA;    缩进用4空格&#xA;    杜绝不规范的缩写&#xA;        如 AbstractClass写成AbsClass、condition写成condi&#xA;    换行&#xA;        # 单行120要换行&#xA;        运算符、点号在下一行&#xA;        参数中的逗号在上一行&#xA;        括号前不换行，如append(&amp;quot;a&amp;quot;)的括号前&#xA;    空行&#xA;        执行语句组、变量定义语句组、业务逻辑或不同语义之间插入空行&#xA;            # 相同业务逻辑和语义间不要空行&#xA;    领域模型&#xA;        # POJO是 DO/DTO/BO/VO 的统称，禁止命名xxxPOJO&#xA;        数据对象 xxxDO&#xA;        数据传输对象 xxxDTO&#xA;        展示对象 xxxVO&#xA;    ide的text file encoding设置为utf-8, 文件换行用unix格式&#xA;类&#xA;    类成员和方法，访问控制从严&#xA;    构造方法不加业务逻辑&#xA;    POJO类要实现toString (避免继承)&#xA;    接口类&#xA;        接口类中方法和属性，不要加修饰(如public)，&#xA;        尽量不定义变量和default实现&#xA;    枚举类&#xA;        变量值在一范围内变化的，用Enum类，有延伸属性的(如MONDAY(1))，用Enum类&#xA;方法&#xA;    覆写方法一定加@Override，可判断是否覆盖成功&#xA;    过时方法要加@Deprecated，并写明新接口是什么&#xA;    可变参数只用在ids之类的地方&#xA;    不使用过时方法&#xA;变量&#xA;    常量&#xA;        不要定义一个总常量类，应分类定义单独的类&#xA;        共享常量&#xA;            跨应用，放在二方库，如client.jar中的constant目录&#xA;            应用内，放在一方库modules中的constant目录&#xA;            子工程内部，放在子工程的constant目录&#xA;            包内，放在包的constant目录&#xA;            类内，在类中定义private static final&#xA;        不写魔法值，如key=&amp;quot;Id#toabao&amp;quot;&#xA;        long型赋值用大写L, 如Long a = 2L&#xA;    数组 String[] args,而不是String args[]&#xA;&#xA;编程&#xA;    方法可以反回null, 但要注释充分&#xA;    POJO类属性和RPC方法参数返回值使用包装类型，局部变量使用基本类型&#xA;    避免所有NPE(空指针)问题(赋初值或非空检查)&#xA;    用&amp;quot;a&amp;quot;.equals(object)而不是object.equals(&amp;quot;a&amp;quot;),否则容易抛空指针&#xA;        # 也可以用java.util.Objects#equals&#xA;    String.split时，要检查最后分隔符后有无内容 (如 &amp;quot;a,b,,&amp;quot;, 使用arr[3]时异常)&#xA;    包装类比较，用equals&#xA;        # 只有Integer -128到127在IntegerCache中运用享元，才==&#xA;    用StringBuilder扩展字符串&#xA;    慎用Object.clone，是浅拷贝，要重写&#xA;    final&#xA;        不需要重新赋值的变量&#xA;        对象参数加final，表示不修改引用&#xA;        类方法不重写&#xA;    正则要预编译&#xA;        # Patern.compile()在外&#xA;    Math.random()可以取到0，取整数时用nextInt或nextLong方法&#xA;    用System.currentTimeMillis()而不是new Date().getTime()&#xA;    任何数据结构的构造或初始化，都要指定大小，避免OOM&#xA;    NPE(空指针异常)场景&#xA;        返回包装类型为null时，解包NPE&#xA;        数据库查询结果&#xA;        集合里元素即使isNotEmpty，也可取出null&#xA;        远程调用结果要判null&#xA;        Session中数据判null&#xA;        级联调用 a.b().c()&#xA;集合&#xA;    初始化时，尽量指定大小&#xA;    hashCode与equals&#xA;        # 同时重写&#xA;        Set存的对象与Map的键，要重写hashCode与equals&#xA;    sublist只是个视图，不能转ArrayList&#xA;        sublist修改原集合个数，会引起之后使用的CuncurrentModificationException异常&#xA;    集合转数组要用toArray(T[])&#xA;    Arrays.asList返回的集合不要add/remove/clear&#xA;        # 只是适配器，内部还是数组&#xA;    &amp;lt;? extends T&amp;gt;接收的对象，不能用add方法&#xA;    remove/add用Iterator，并发要加锁，不能foreach&#xA;    JDK7以上版本，Comparator要满足3个条件，不然Arrays.sort和Collections.sort会报异常&#xA;        x,y比较结果和y,x相反&#xA;        x&amp;gt;y, y&amp;gt;z, 则x&amp;gt;z&#xA;        x=y则x, z比较结果与y, z比较结果相同&#xA;    使用entrySet遍历Map, 而不是KeySet, JDK8使用Map.foreach&#xA;        # KeySet遍历了2次，一次转为Iterator对象，一次从hashMap取key的value&#xA;    null情况&#xA;        集合类                 Key      Value     Super       说明&#xA;        Hashtable           非null       非null   Dictionary  线程安全&#xA;        ConcurrentHashMap   非null       非null   AbstractMap 分段锁技术&#xA;        TreeMap             非null       可null   AbstractMap 线程不安全&#xA;        HashMap             可null       可null   AbstractMap 线程不安全&#xA;    稳定性和有序性&#xA;        ArrayList   order/unsort&#xA;        HashMap     unorder/unsort&#xA;        TreeSet     order/sort&#xA;并发&#xA;    单例方法要线程安全, 获取单例要注意线程安全&#xA;    线程或线程池指定有意义的名称&#xA;        public class TimerTaskThread extends Thread {&#xA;            public TimerTaskThread() {&#xA;                super.setName(&amp;quot;TimerTaskThread&amp;quot;)&#xA;    线程资源只从线程池取，不要自行创建&#xA;    不用Executors而用ThreadPoolExecutor创建&#xA;        FixedThreadPool和SingleThreadPool允许请求队列长度为Integer.MAX_VALUE, 可能堆积大量请求OOM(out of memory)&#xA;        CachedThreadPool和ScheduledThreadPool允许创建线程数量为Integer.MAX_VALUE，可能创建大量线程，导致OOM&#xA;    SimpleDateFormat线程不安全，不要static。应使用DateUtils&#xA;        JDK8用Instant代替Date, LOcalDateTime代替Calendar, DateTimeFormatter代替Simpledateformatter&#xA;    尽量锁小范围&#xA;    多线程中，都对多对象加锁，加锁顺序要一致，否则会死锁&#xA;    并发修改时，在应用层加锁或在缓存加锁或在数据库层加乐观锁并使用version作更新依据&#xA;        每次访问冲突率小于20%, 使用乐观锁，否则用悲观锁。&#xA;        乐观锁重试次数不得小于3&#xA;    Timer的多个TimeTask，一个没有捕获异常会同时终止。应使用ScheduledExecutorServcie&#xA;    CountDownLatch进行异步转同步时，线程代码注意catch异常，确保countDown执行&#xA;        # 子线程异常，主线程catch不到&#xA;    Random多线程下，会因竞争同一seed导致性能下降。JDK7后用ThreadLocalRandom&#xA;    延迟初始化的双重检查锁隐患。将目标属性声明为volatile&#xA;    volatile不能解决多写问题, 使用AtomicInteger或JDK8的LongAdder，它减少了乐观锁的重试次数&#xA;    HashMap在容量不够进行resize时，高并发可能会出现死链，导致cpu飙升&#xA;    ThreadLocal使用static修饰&#xA;控制语句&#xA;    switch中，case要么有break/return，要么注释执行到哪个case。switch都要有default&#xA;    不要省略大括号&#xA;    尽量少用else，用卫语句（只有一个if）或状态模式&#xA;    条件判断只调用getXxx/isXxx，运算赋值给布尔变量判断，提高可读性&#xA;    循环体中语句考量性能&#xA;    参数校验场景&#xA;        调用频次低的方法&#xA;        执行时间大的方法&#xA;        需要极高稳定性和可用性&#xA;        对外开放接口&#xA;        敏感权限入口&#xA;    不需参数校验场景&#xA;        可能被循环调用     # 要注明外部参数检查&#xA;        底层方法，如DAO&#xA;        private方法明确入参已校验&#xA;注释&#xA;    # 自解释代码少注释，注释要反应设计思想与代码逻辑，描述业务含义&#xA;    类、类属性、类方法使用/**内容*/      # Javadoc规范&#xA;    抽象方法要Javadoc注释，除返回值、参数、异常说明外，还要指出做什么事，实现什么功能&#xA;    类要添加创建者&#xA;    枚举类型都要注释&#xA;    用中文说清楚&#xA;    注释要跟进修改&#xA;    注释掉的代码要有说明&#xA;    特殊注释，要注明标记人和标记时间&#xA;        TODO: (标记人，标记时间，[预计处理时间])&#xA;异常&#xA;    事先检查值，而不是调用后处理异常&#xA;    异常不要用来做流程控制，效率低&#xA;    异常要对小段代码, 要细分&#xA;    异常要处理或上抛，最外层一定要处理&#xA;    注意事务回滚&#xA;    finally资源要关闭，异常要处理，JDK7用 try-with-resources&#xA;    finally中不要return，否则不执行try中return&#xA;    不要捕获异常的父类&#xA;    rpc异常定义自己的result，好处一是调用方不会漏查，二是可以加异常栈&#xA;    不抛RuntimeException，Exception和Throwable。抛确定异常&#xA;日志&#xA;    不直接用日志系统，用门面模式的日志框架&#xA;    日志保存15天，因为有“周”频次发生的异常&#xA;    利用日志文件名和目录 stats/desc/monitor/visit/appName_logType_logName.log&#xA;    直接logger.debug(a + b)，级别为warn是表达式还会执行。用2种方式避免&#xA;        if logger.isDebugEnabled() {...}&#xA;        logger.debug(&amp;quot;{} {}&amp;quot;, id, symbol)&#xA;    设置log4j.xml的additivity=false，防止重复打印&#xA;    要记录异常堆栈。logger.error(参数或对象toString + &amp;quot;_&amp;quot; + e.getMessage(), e)&#xA;    可以用warn记录用户输入参数错误的情况，避免用户投诉时无所适从&#xA;    生产环境禁止输出debug日志，有选择地输出info。如果用warn来记录刚上线业务，要注意量的问题&#xA;mysql&#xA;    类型&#xA;        is_xxx  unsigned tinyint    # 1是0否&#xA;        唯一索引名 uk_字段名，普通索引idx_字段名        # unique key, index&#xA;    表名、字段名&#xA;        库名与应用名尽量一致&#xA;        小写与数字&#xA;        不数字开头&#xA;        不能下划线间仅有数字&#xA;        不使用复数&#xA;        不用保留字&#xA;            desc、range、match、delayed等&#xA;        必有三字段&#xA;            id unsigned bigint，单表时自增，步长为1&#xA;            gmt_create date_time&#xA;            gmt_modified date_time&#xA;        表名 业务名称_表的作用，如tiger_task, mpp_config&#xA;        字段含义修改或追加状态时，及时更新注释&#xA;    orm&#xA;        boolean属性POJO不加is, 数据库前缀is_&#xA;            # mybatis generator生成的代码中需要修改&#xA;        不能返回resultClass, HashMap, Hashtable&#xA;        xml配置用 #{}, #param#, 不要${}，容易sql注入&#xA;        尽量不用ibatis的queryForList(String statementName, int start, int size)&#xA;            # 会查整表&#xA;            应在sqlmap.xml中引入#start# #size#&#xA;        更新时要同时更新gmt_modified&#xA;        不要大而全的更新接口，传入POJO类。会更新无改动字段，易出错，效率低，增加binlog存储&#xA;        @Transactional事务不要滥用，影响qps&#xA;            事务回滚方案包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等&#xA;分层&#xA;    开放接口层&#xA;    终端显示层&#xA;    web层&#xA;        对访问控制进行转发，参数校验，不复用业务简单处理&#xA;    service层&#xA;    manager层&#xA;        对第三方封装&#xA;        service通用能力下沉，如缓存方案、中间件通用处理&#xA;        与dao层交互，对dao业务通用能力封装&#xA;    dao层&#xA;        直接抛DAOException，由service层处理&#xA;    外部接口或第三方平台&#xA;    分层领域模型&#xA;        DO (Data Object)&#xA;        DTO (Data Transfer Object)&#xA;        BO (Business Object)&#xA;        QUERY&#xA;        VO (View Object)&#xA;服务器&#xA;    JVM设置- XX :+ HeapDumpOnOutOfMemoryError, OOM时输出dump信息&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>JavaWeb</title>
      <link>https://ukeate.com/docs/pl/java/javaweb/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/java/javaweb/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分层&#xA;    视图层         jsp&#xA;    控制层         servlet&#xA;    业务层         过滤数据&#xA;    manager层     封装第三方，service能力下沉，dao中间件&#xA;    数据访问层对象  封装对象&#xA;    数据库&#xA;java web 13种技术&#xA;    JDBC        Java Database Connectivty&#xA;    JNDI        Java Name and Directory Interface&#xA;    EJB        Enterprise JavaBean&#xA;    RMI        Remote Method Invoke&#xA;    Java IDL/CORBA&#xA;    JSP        Java Server Pages&#xA;    Java Servlet&#xA;    XML        Extensible Markup Language&#xA;    JMS        Java Message Service&#xA;    JTS        Java Transaction Service&#xA;    JTA        Java Transaction Architecture&#xA;    JavaMail&#xA;    JAF        JavaBeans Activation Framework&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jsp&#34;&gt;&#xA;  jsp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层&#xA;域对象&#xA;    pageContext     # 当前页面有效&#xA;    request         # 一次请求范围&#xA;    session         # 会话&#xA;    application context     # 同一服务器&#xA;内置对象&#xA;    Request&#xA;    Response&#xA;    Session&#xA;    Out             # 输出流&#xA;    PageContext     # context&#xA;    Page            # jsp的this&#xA;    Exception       # &amp;lt;%@ page isErrorPage=&amp;quot;true&amp;quot;%&amp;gt; 时使用，显示异常信息&#xA;    Application     # 服务器&#xA;    Config          # 服务器配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp-el表达式&#34;&gt;&#xA;  jsp-el表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp-el%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;${  }&#xA;11个内置对象&#xA;    pageContext    // pageContext&#xA;    page        // map （相当于pageScope，不过写法上省略了Scope）&#xA;    requestScope    // map&#xA;    sessionScope    // map&#xA;    applicationScope    // map&#xA;    param        // map        ,用${param.name}的形式得到传递的参数&#xA;    paramValues    // map&amp;lt;String,String []&amp;gt;&#xA;    header        // map&#xA;    hearderValues    // map&amp;lt;String, String []&amp;gt;&#xA;    cookie        // map&#xA;    initParam        // map&#xA;&#xA;语法&#xA;${list[0]}&amp;lt;br&amp;gt;&#xA;    ${map.mapteststring}&amp;lt;br&amp;gt;&#xA;    ${map[mapkey]}&amp;lt;br&amp;gt;&#xA;    ${map[&#39;mapteststring&#39;]}&amp;lt;br&amp;gt;&#xA;    ${request }&#xA;    ${pageContext.request.contextPath }&amp;lt;br&amp;gt;        # el表达式中访问内置对象&#xA;    ${requestScope.aaa }                # 访问内置对象requestScope，得到request作用域中的aaa元素&#xA;    ${pageContext.servletContext.contextPath }&amp;lt;br&amp;gt;&#xA;    ${param}&amp;lt;br&amp;gt;&#xA;    ${paramValues[&#39;a&#39;] }&amp;lt;br&amp;gt;&#xA;    ${paramValues[&#39;a&#39;][0] }&#xA;    ${paramValues[&#39;a&#39;][1] }&#xA;    ${paramValues[&#39;a&#39;][2] }&amp;lt;br&amp;gt;&#xA;    ${empty novalue}&amp;lt;br&amp;gt;&#xA;    ${1&amp;gt;2?&amp;quot;yes&amp;quot; : &amp;quot;no&amp;quot;}&amp;lt;br&amp;gt;&#xA;&#xA;        #  . 与 [] 可以替换使用，但有两点需要注意&#xA;        1  .1不行，但是[1]可以&#xA;        2    1&amp;gt; map[&amp;quot;key&amp;quot;]    是取map中&amp;quot;key&amp;quot;对应的值&#xA;            2&amp;gt; map[key]是先从作用域中取得key的字符串如&amp;quot;aaa&amp;quot;,再取map中&amp;quot;aaa&amp;quot;对应的值&#xA;            3&amp;gt; .key    相当于1&amp;gt;中的介绍，是取map中&amp;quot;key&amp;quot;对应的值&#xA;            4&amp;gt; .是不能相当于2&amp;gt;中的介绍那样使用的&#xA;比较符${ }中使用&#xA;    empty&#xA;    not empty&#xA;    三元式（?:）&#xA;    简单的算术运算&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp-taglib标签库&#34;&gt;&#xA;  jsp-taglib标签库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp-taglib%e6%a0%87%e7%ad%be%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;jstl标签库1.1 或1.2&#xA;    标签库1.1中需要    jstl.jar 与 standard.jar 库&#xA;可放入域scope的类型&#xA;    page&#xA;    request&#xA;    session&#xA;    application&#xA;    functions&#xA;el表达式级使用，其它都标签级使用&#xA;functions&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;fn&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/functions&amp;quot;%&amp;gt;&#xA;    ${fn:contains(&amp;quot;gzitcast&amp;quot;, &amp;quot;itcast&amp;quot;) }  &amp;lt;br&amp;gt;&#xA;    ${fn:containsIgnoreCase(&amp;quot;gzitcast&amp;quot;, &amp;quot;ITCAST&amp;quot;) }  &amp;lt;br&amp;gt;&#xA;    ${fn:endsWith(&amp;quot;gzitcast&amp;quot;, &amp;quot;st&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:indexOf(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:join(arr, &amp;quot;-&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:length(&amp;quot;gzitcast&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:replace(&amp;quot;gzitcast&amp;quot;, &amp;quot;gz&amp;quot;, &amp;quot;广州&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:split(&amp;quot;gz,it,cast&amp;quot;, &amp;quot;,&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:startsWith(&amp;quot;gzitcsat&amp;quot;, &amp;quot;gz&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:substring(&amp;quot;gzitcsat&amp;quot;, 3, 8) } &amp;lt;br&amp;gt;&#xA;    ${fn:substringAfter(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:substringBefore(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:toLowerCase(&amp;quot;gziTCsat&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:toUpperCase(&amp;quot;gziTCsat&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:trim(&amp;quot;  gzitcsat  &amp;quot;) } &amp;lt;br&amp;gt;&#xA;    &amp;lt;%-- 对字符串中进行转义处理，如：会把&amp;quot;&amp;lt;&amp;quot;替换为&amp;quot;&amp;amp;lt;&amp;quot;，把&amp;quot;&amp;gt;&amp;quot;替换为&amp;quot;&amp;amp;gt;&amp;quot; --%&amp;gt;&#xA;    ${fn:escapeXml(&amp;quot;&amp;lt;h3&amp;gt;gzitcsat&amp;lt;/h3&amp;gt;&amp;quot;) } &amp;lt;br&amp;gt;&#xA;core&#xA;    所有标签：&#xA;        out&#xA;        set&#xA;        remove&#xA;        catch&#xA;        if&#xA;        choose&#xA;        when&#xA;        otherwise&#xA;        forEach&#xA;        url&#xA;        param&#xA;        redirect&#xA;        forTokens&#xA;        import&#xA;&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/cores&amp;quot;%&amp;gt;&#xA;    &amp;lt;c:out var=&amp;quot;&amp;quot;    default=&amp;quot;&amp;quot;    escapeXml=&amp;quot;true&amp;quot;&amp;gt;    &amp;lt;%--    放过xml过滤，让它显示，默认不显示    --%&amp;gt;&#xA;    -------------------------------------&#xA;    scope方式&#xA;    &amp;lt;c:set    var=&amp;quot;&amp;quot;    value=&amp;quot;&amp;quot;    scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    target方式    &amp;lt;%--    这个放入page作用域中的map值    --%&amp;gt;&#xA;    &amp;lt;%  Map map = new HashMap();  %&amp;gt;&#xA;    &amp;lt;c:set    property=&amp;quot;key1&amp;quot;    value=&amp;quot;key1value&amp;quot;    target=&amp;quot;&amp;lt;%=map%&amp;gt;&amp;quot;&#xA;    &amp;lt;%  pageContext.setAttribute(&amp;quot;map&amp;quot;, map);  %&amp;gt;&#xA;    &amp;lt;c:out    value=&amp;quot;${map[key2]}&amp;quot;&#xA;&#xA;    -------------------------------------&#xA;    &amp;lt;c:catch var=&amp;quot;e&amp;quot;&amp;gt;&amp;lt;/c:catch&amp;gt;&#xA;    &amp;lt;c:out value=&#39;&amp;lt;%= ((Exception)pageContext.getAttribute(&amp;quot;e&amp;quot;,PageContext.PAGE_SCOPE)).getMessage() %&amp;gt;&#39;&amp;gt;&amp;lt;/c:out&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:remove    var=&amp;quot;&amp;quot;    scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:if test=&amp;quot;${not empty    }&amp;quot; scope=&amp;quot;&amp;quot;    var=&amp;quot;&amp;quot;&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;%--    if...else标签    --%&amp;gt;&#xA;    &amp;lt;c:choose&amp;gt;&#xA;    &amp;lt;c:when test=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;c:otherwise&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:forEach  begin=&amp;quot;&amp;quot;    end=&amp;quot;&amp;quot;    step=&amp;quot;&amp;quot;    items=&amp;quot;&amp;quot;    var=&amp;quot;&amp;quot;    varStatus=&amp;quot;state&amp;quot;&amp;gt;          &amp;lt;%--    varStatus中的函数有first last count begin end    --%&amp;gt;&#xA;    &amp;lt;tr bgcolor=&#39;${state.count%2 == 0? &amp;quot;red&amp;quot; : &amp;quot;pink&amp;quot;}&#39; &amp;gt;&#xA;    &amp;lt;/c:forEach&amp;gt;&#xA;&#xA;    varStatus可用的函数&#xA;        current    // 当前这次迭代的项&#xA;        index    // 索引&#xA;        count    // 计数&#xA;        first        // 第一个&#xA;        last        // 最后一个&#xA;        begin    // begin属性值&#xA;        end        // end 属性值&#xA;        step        // step属性值&#xA;    -------------------------------------&#xA;    uri 代表所有协议路径&#xA;&#xA;    &amp;lt;c:url    var=&amp;quot;itcast&amp;quot;    value=&amp;quot;http://www.itcast.cn&amp;quot;    scope=&amp;quot;page&amp;quot;    context=&amp;quot;&amp;quot;    &amp;gt;    &amp;lt;%--    context 是整个网站    --%&amp;gt;&#xA;    &amp;lt;c:param    name=&amp;quot;name&amp;quot;    value=&amp;quot;中文&amp;quot;&amp;gt;    &amp;lt;%--    这样传参数有编码    --%&amp;gt;&#xA;&#xA;    如果value值为&amp;quot;/&amp;quot; 则加入context属性提供上下文名称，如果context也被省略，就使用当前servlet的上下文名称&#xA;    -------------------------------------&#xA;    &amp;lt;c:redirect    url=&amp;quot;${itcast}&amp;quot;    context=&amp;quot;&amp;quot;    &amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:set    var=&amp;quot;name&amp;quot;    value=&amp;quot;xx,xxx,xxx,xx&amp;quot;    scope=&amp;quot;request&amp;quot;    &amp;gt;&#xA;    &amp;lt;c:forTokens    items=&amp;quot;${name}&amp;quot;    delims=&amp;quot;,&amp;quot;    begin=&amp;quot;&amp;quot;    end=&amp;quot;&amp;quot;    step=&amp;quot;1&amp;quot;    var=&amp;quot;name&amp;quot;    varStatus=&amp;quot;&amp;quot;    &amp;gt;    &amp;lt;%--切割字符串--%&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:import    url=&amp;quot;/publics/head.jsp&amp;quot;    &amp;gt;    &amp;lt;%--动态包含，引入公共文件--%&amp;gt;&amp;lt;%--网站publics文件夹--%&amp;gt;&#xA;&#xA;&#xA;sql标签库&#xA;    # 以前没有mvc模式的时候，通过页面访问数据库时用的，现在不用&#xA;    引入&#xA;        &amp;lt;%@ taglib prefix=&amp;quot;sql&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/sql&amp;quot; %&amp;gt;&#xA;    设置数据源&#xA;        &amp;lt;sql:setDataSource dataSource=”dataSource”[var=”name”]&#xA;                            [scope=”page|request|session|application”]/&amp;gt;&#xA;    jdbc连接&#xA;        &amp;lt;sql:setDataSource driver=”driverClass” url=”jdbcURL”&#xA;                user=”username”&#xA;                password=”pwd”&#xA;                [var=”name”]&#xA;                [scope=”page|request|session|application”]/&amp;gt;&#xA;&#xA;    JSTL提供了&amp;lt;sql:query&amp;gt;、&amp;lt;sql:update&amp;gt;、&amp;lt;sql:param&amp;gt;、&amp;lt;sql:dateParam&amp;gt;和&amp;lt;sql:transaction&amp;gt;这5个标签&#xA;        1.query:&#xA;        query必需指定数据源&#xA;        &amp;lt;sql:query sql=”sqlQuery” var=”name” [scope=”page|request|session|application”]&#xA;        [dataSource=”dateSource”]&#xA;        [maxRow=”maxRow”]&#xA;        [startRow=”starRow”]/&amp;gt;&#xA;        或&#xA;        &amp;lt;sql:query var=”name” [scope=”page|request|session|application”]&#xA;        [dataSource=”dateSource”]&#xA;        [maxRow=”maxRow”]    # 设定最多可以暂存数据的长度&#xA;        [startRow=”starRow”]    # 设定从哪一行开始&#xA;                &amp;gt;&#xA;                sqlQuery&#xA;                &amp;lt;/sql:query&amp;gt;&#xA;&#xA;        结果集的参数&#xA;            rowCount    # 结果集中的记录总数&#xA;            rowsByIndex    # 以数字为作索引的查询结果&#xA;            columnNames    # 字段名称数组&#xA;            Rows    # 以字段为索引查询的结果&#xA;            limitedByMaxRows    # 是否设置了maxRows属性来限制查询记录的数量&#xA;                limitedByMaxRows用来判断程序是否收到maxRows属性的限制。&#xA;                并不是说设定了maxRows属性，得到结果集的limitedByMaxRows的属性都为true，&#xA;                当取出的结果集小于maxRows时，则maxRows没有对结果集起到作用此时也为false。&#xA;                例如可以使用startRow属性限制结果集的数据量。&#xA;&#xA;        2.update:&#xA;        &amp;lt;/sql:update&amp;gt;&#xA;        &amp;lt;sql:update sql=”SQL语句” [var=”name”] [scope=”page|request|session|application”]&#xA;                [dateSource=”dateSource”]/&amp;gt;&#xA;        或&#xA;    &amp;lt;sql:update [var=”name”] [scope=”page|request|session|application”]&#xA;                [dateSource=”dateSource”]&#xA;                    &amp;gt;&#xA;                    SQL语句&#xA;        参数说明&#xA;            dataSource    # 数据源对象&#xA;            其它与query一样&#xA;&#xA;        3.param 参数设置&#xA;        &amp;lt;sql:param value=”value”/&amp;gt;&#xA;        或&#xA;        &amp;lt;sql:param&amp;gt;&#xA;            Value&#xA;            &amp;lt;/sql:param&amp;gt;&#xA;&#xA;        4.dataParam 标签    # 用于为SQL标签填充日期类型的参数值&#xA;&#xA;        参数说明&#xA;            value：java.util.Date类型的参数。&#xA;            type属性：指定填充日期的类型timestamp（全部日期和时间）、time（填充的参数为时间）、date（填充的参数为日期）。&#xA;&#xA;        5.transaction 标签&#xA;&#xA;        &amp;lt;sql:transaction [dataSource=”dataSource”]&#xA;            [isolation=”read_committed|read_uncommitted|repeatable|serializable”]&#xA;            &amp;gt;&#xA;            &amp;lt;sql:query&amp;gt;&#xA;            &amp;lt;sql:uptade&amp;gt;&#xA;        &amp;lt;/sql:transation&amp;gt;&#xA;&#xA;xml标签库&#xA;    核心操作&#xA;    out    # 主要用来取出XML中的字符串。&#xA;        属性&#xA;        select    # XPath语句&#xA;        escapeXml    # 是否转换特殊字符&#xA;&#xA;    parse    # 用来解析xml文件&#xA;        属性&#xA;        doc    # XML文件&#xA;        systemId    # XML文件的URL&#xA;        filter    # XMLFilter过滤器&#xA;        varDom    # 储存解析后的XML文件&#xA;        scopeDom    # varDom的范围&#xA;&#xA;    set    # 将从XML文件取得的内容储存至属性范围中&#xA;        属性&#xA;        select    # XPath语句&#xA;&#xA;    流程控制&#xA;    if&#xA;    choose when otherwise&#xA;        属性&#xA;        select    # XPath语句&#xA;    文件转换&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]/&amp;gt;&#xA;    或&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]&#xA;        &amp;gt;&#xA;        &amp;lt;x:param/&amp;gt;&#xA;        &amp;lt;/x:transform&amp;gt;&#xA;    或&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]&#xA;        &amp;gt;&#xA;&#xA;        属性&#xA;        doc    # 指定xml文件来源&#xA;        xslt    # 转化xml的样式模板&#xA;        docSystemId    # xml文件的URI&#xA;        xsltSystemId    # xslt文件的URI&#xA;        result    # 用来存储转换后的结果对象&#xA;&#xA;国际化&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;fmt&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/fmt&amp;quot; %&amp;gt;&#xA;    国际化标签&#xA;    1.setLocale    # 设置一个全局的地区代码,设定的是本地的环境&#xA;        中文－大陆:&amp;lt;fmt:setLocale value=&amp;quot;zh_CN&amp;quot;/&amp;gt; &amp;lt;fmt:formatDate value=&amp;quot;${todayValue}&amp;quot;/&amp;gt;&amp;lt;br&amp;gt;&#xA;&#xA;    2.requestEncoding    # 设置统一的请求编码&#xA;        &amp;lt;fmt:requestEncoding value=&amp;quot;GB2312&amp;quot;/&amp;gt;&#xA;&#xA;    信息显示标签&#xA;    1.&amp;lt;fmt:bundle&amp;gt; 设置临时要读取的资源文件&#xA;    2.&amp;lt;fmt:message&amp;gt;  通过key取得value&#xA;    3.&amp;lt;fmt:setBundle&amp;gt;  设置一个要读取的全局的资源文件&#xA;        如&#xA;        &amp;lt;fmt:setBundle basename=&amp;quot;applicationMessage&amp;quot; var=&amp;quot;MyResourse&amp;quot;/&amp;gt;    # 绑定了名为applicationMessage_zh_CN.properties一类 的文件&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot; prefix=&amp;quot;label.&amp;quot;&amp;gt;&#xA;        &amp;lt;fmt:message key=&amp;quot;backcolor&amp;quot; bundle=&amp;quot;${applicationBundle}&amp;quot;/&amp;gt;&#xA;        &amp;lt;fmt:message key=&amp;quot;fontcolor&amp;quot; /&amp;gt;&#xA;    &amp;lt;/fmt:bundle&amp;gt;&#xA;&#xA;&#xA;    数字及日期格式化标签&#xA;    1.&amp;lt;fmt:formatDate&amp;gt;  日期的格式化&#xA;        属性&#xA;        value:格式化的日期，该属性的内容应该是 java.util.Date 类型的实例&#xA;        type:格式化的类型&#xA;        pattern:格式化模式&#xA;        timeZone:指定格式化日期的时区&#xA;    2.&amp;lt;fmt:parseDate&amp;gt;  解析日期&#xA;        属性&#xA;        value:将被解析的字符串&#xA;        type:解析格式化的类型&#xA;        pattern:解析格式化模式&#xA;        parseLocale:以本地化的形式来解析字符串，该属性的内容为 String 或 java.util.Locale 类型的实例&#xA;        timeZone:指定解析格式化日期的时区&#xA;    3.&amp;lt;fmt:formatNumber&amp;gt;  数字格式化&#xA;        属性&#xA;        value:格式化的数字,该数值可以是 String 类型或 java.lang.Number 类型的实例&#xA;        type:格式化的类型,可能值包括:currency（货币）、number（数字）和percent（百分比）&#xA;        pattern:格式化模式&#xA;        maxIntegerDigits:指定格式化结果的最大值&#xA;        minIntegerDigits:指定格式化结果的最小值&#xA;        maxFractionDigits:指定格式化结果的最大值，带小数&#xA;        minFractionDigits:指定格式化结果的最小值，带小数&#xA;        如&#xA;        &amp;lt;fmt:formatNumber value=&amp;quot;1000.888&amp;quot; type=&amp;quot;currency&amp;quot; var=&amp;quot;money&amp;quot;/&amp;gt;&#xA;&#xA;    4.&amp;lt;fmt:parseNumber&amp;gt;  解析数字&#xA;        属性&#xA;        value:将被解析的字符串&#xA;        type:解析格式化的类型&#xA;        pattern:解析格式化模式&#xA;        如&#xA;        &amp;lt;fmt:parseNumber value=&amp;quot;15%&amp;quot; type=&amp;quot;percent&amp;quot; var=&amp;quot;num&amp;quot;/&amp;gt;&#xA;    5.&amp;lt;fmt:setTimeZone&amp;gt;  标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行属性描述&#xA;        属性&#xA;        value    # 时区的设置&#xA;        var    # 用于保存时区为一个变量&#xA;    6.&amp;lt;fmt:timeZone&amp;gt;  标签将使得在其标签体内的工作可以使用该时区设置&#xA;        属性&#xA;        value    # 时区的设置&#xA;    7.&amp;lt;fmt:param&amp;gt; 标签:用于参数传递&#xA;        如：在MyResourse.properties文件中,有一个索引值如下(其中,{0}代表占位符):&#xA;        Str2=Hi,{0}&#xA;        则,使用&amp;lt;fmt:param&amp;gt;标签传入值如下:&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:message key=&amp;quot;Str2&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:param value=&amp;quot;张三&amp;quot; /&amp;gt;&#xA;            &amp;lt;/fmt:message&amp;gt;&#xA;        &amp;lt;/fmt:bundle&amp;gt;&#xA;        也可以在资源文件中指定参数的类型:&#xA;        如:在MyResourse.properties文件中,有一个索引值如下:&#xA;        Str3={0,date}&#xA;        则,使用&amp;lt;fmt:param&amp;gt;标签传入值如下:&#xA;        &amp;lt;% request.setAttribute(&amp;quot;now&amp;quot;,new Date()); %&amp;gt;&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:message key=&amp;quot;Str3&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:param value=&amp;quot;${now}&amp;quot; /&amp;gt;&#xA;            &amp;lt;/fmt:message&amp;gt;&#xA;        &amp;lt;/fmt:bundle&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp动作标签&#34;&gt;&#xA;  jsp动作标签&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%8a%a8%e4%bd%9c%e6%a0%87%e7%ad%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。&#xA;&#xA;一、Include行为&#xA;&#xA;    &amp;lt;jsp:include&amp;gt;标签表示动态包含一个静态的或者动态的文件。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot; /&amp;gt;&#xA;    or&#xA;    &amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot;&amp;gt;&#xA;    &amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;&#xA;    &amp;lt;/jsp:include&amp;gt;&#xA;&#xA;    注：&#xA;    1、page=&amp;quot;path&amp;quot; 为相对路径，或者代表相对路径的表达式。&#xA;    2、flush=&amp;quot;true&amp;quot; 必须使用flush为true，它默认值是false。&#xA;    3、&amp;lt;jsp:param&amp;gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&amp;lt;jsp:param&amp;gt;来传递多个参数给动态文件。&#xA;    4、&amp;lt;jsp:include page=&amp;quot;&amp;quot; flush=&amp;quot;&amp;quot;&amp;gt; 与&amp;lt;%@ include file=&amp;quot;&amp;quot;%&amp;gt;的区别：&#xA;        &amp;lt;jsp:include &amp;gt;是动态包含&amp;lt;%@include%&amp;gt;是静态包含。&#xA;        # jsp页面是把include指令元素（&amp;lt;%@ include file=&amp;quot;&amp;quot;%&amp;gt;）所指定的页面的实际内容（也就是代码段）加入到引入它的jsp页面中,合成一个文件后被jsp容器将它转化成servlet。&#xA;        ## 可以看到这时会产生一个临时class文件和一个servlet源文件。&#xA;        ## 而动作元素（&amp;lt;jsp:include page=&amp;quot;&amp;quot;/&amp;gt;）是在请求处理阶段引入的，会被JSP容器生成两个临时class文件和两个servlet原文件。&#xA;        ## 而引入的只是servlet的输出结果，即JspWriter对象的输出结果，而不是jsp的源代码。&#xA;&#xA;二、Forward行为&#xA;&#xA;    &amp;lt;jsp:forward&amp;gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} /&amp;gt;&#xA;    or&#xA;    &amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} &amp;gt;&#xA;    &amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;……&#xA;    &amp;lt;/jsp:forward&amp;gt;&#xA;&#xA;    注：&#xA;    1、page=&amp;quot;path&amp;quot; 为一个表达式，或者一个字符串。&#xA;    2、&amp;lt;jsp:param&amp;gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&amp;lt;jsp:param&amp;gt;将多个参数发送到一个动态文件中。&#xA;&#xA;三、UseBean行为&#xA;&#xA;    &amp;lt;jsp:useBean&amp;gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;name&amp;quot; scope=&amp;quot;page | request | session | application&amp;quot; typeSpec /&amp;gt;&#xA;    其中typeSpec有以下几种可能的情况：&#xA;    class=&amp;quot;className&amp;quot; | class=&amp;quot;className&amp;quot; type=&amp;quot;typeName&amp;quot; | beanName=&amp;quot;beanName&amp;quot; type=&amp;quot;typeName&amp;quot; | type=&amp;quot;typeName&amp;quot; |&#xA;&#xA;    注：&#xA;    你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。&#xA;&#xA;四、GetProperty行为&#xA;&#xA;    &amp;lt;jsp:getProperty&amp;gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:getProperty name=&amp;quot;name&amp;quot; property=&amp;quot;propertyName&amp;quot; /&amp;gt;&#xA;&#xA;    注：&#xA;    1、在使用&amp;lt;jsp:getProperty&amp;gt;之前，必须用&amp;lt;jsp:useBean&amp;gt;来创建它。&#xA;    2、不能使用&amp;lt;jsp:getProperty&amp;gt;来检索一个已经被索引了的属性。&#xA;    3、能够和JavaBeans组件一起使用&amp;lt;jsp:getProperty&amp;gt;，但是不能与Enterprise Java Bean一起使用。&#xA;JavaScript通用库  Jsp语法&#xA;JSP的动作标签  2008-04-01 11:47:49|  分类： JSP学习 |  标签： |字号大&#xA;中&#xA;小 订阅&#xA;在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。&#xA;&#xA;一、Include行为&#xA;&#xA;&amp;lt;jsp:include&amp;gt;标签表示包含一个静态的或者动态的文件。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot; /&amp;gt;&#xA;or&#xA;&amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot;&amp;gt;&#xA;&amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;&#xA;&amp;lt;/jsp:include&amp;gt;&#xA;&#xA;注：&#xA;1、page=&amp;quot;path&amp;quot; 为相对路径，或者代表相对路径的表达式。&#xA;2、flush=&amp;quot;true&amp;quot; 必须使用flush为true，它默认值是false。&#xA;3、&amp;lt;jsp:param&amp;gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&amp;lt;jsp:param&amp;gt;来传递多个参数给动态文件。&#xA;&#xA;二、Forward行为&#xA;&#xA;&amp;lt;jsp:forward&amp;gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} /&amp;gt;&#xA;or&#xA;&amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} &amp;gt;&#xA;&amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;……&#xA;&amp;lt;/jsp:forward&amp;gt;&#xA;&#xA;注：&#xA;1、page=&amp;quot;path&amp;quot; 为一个表达式，或者一个字符串。&#xA;2、&amp;lt;jsp:param&amp;gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&amp;lt;jsp:param&amp;gt;将多个参数发送到一个动态文件中。&#xA;&#xA;三、UseBean行为&#xA;&#xA;&amp;lt;jsp:useBean&amp;gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:useBean id=&amp;quot;name&amp;quot; scope=&amp;quot;page | request | session | application&amp;quot; typeSpec /&amp;gt;&#xA;其中typeSpec有以下几种可能的情况：&#xA;class=&amp;quot;className&amp;quot; | class=&amp;quot;className&amp;quot; type=&amp;quot;typeName&amp;quot; | beanName=&amp;quot;beanName&amp;quot; type=&amp;quot;typeName&amp;quot; | type=&amp;quot;typeName&amp;quot; |&#xA;&#xA;注：&#xA;你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。&#xA;&#xA;四、GetProperty行为&#xA;&#xA;&amp;lt;jsp:getProperty&amp;gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:getProperty name=&amp;quot;name&amp;quot; property=&amp;quot;propertyName&amp;quot; /&amp;gt;&#xA;&#xA;注：&#xA;1、在使用&amp;lt;jsp:getProperty&amp;gt;之前，必须用&amp;lt;jsp:useBean&amp;gt;来创建它。&#xA;2、不能使用&amp;lt;jsp:getProperty&amp;gt;来检索一个已经被索引了的属性。&#xA;3、能够和JavaBeans组件一起使用&amp;lt;jsp:getProperty&amp;gt;，但是不能与Enterprise Java Bean一起使用。&#xA;&#xA;五、SetProperty行为&#xA;&#xA;    &amp;lt;jsp:setProperty&amp;gt;标签表示用来设置Bean中的属性值。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;beanName&amp;quot; prop_expr /&amp;gt;&#xA;    其中prop_expr有以下几种可能的情形：&#xA;    property=&amp;quot;*&amp;quot; | property=&amp;quot;propertyName&amp;quot; | property=&amp;quot;propertyName&amp;quot; param=&amp;quot;parameterName&amp;quot; | property=&amp;quot;propertyName&amp;quot; value=&amp;quot;propertyValue&amp;quot;&#xA;&#xA;    注：&#xA;    使用 jsp:setProperty 来为一个Bean的属性赋值；可以使用两种方式来实现。&#xA;    1、在jsp:useBean后使用jsp:setProperty：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;myUser&amp;quot; … /&amp;gt;&#xA;    …&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;user&amp;quot; property=&amp;quot;user&amp;quot; … /&amp;gt;&#xA;    在这种方式中，jsp:setProperty将被执行。&#xA;    2、jsp:setProperty出现在jsp:useBean标签内：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;myUser&amp;quot; … &amp;gt;&#xA;    …&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;user&amp;quot; property=&amp;quot;user&amp;quot; … /&amp;gt;&#xA;    &amp;lt;/jsp:useBean&amp;gt;&#xA;    在这种方式中，jsp:setProperty只会在新的对象被实例化时才将被执行。&#xA;&#xA;    * 在&amp;lt;jsp:setProperty&amp;gt;中的name值应当和&amp;lt;jsp:useBean&amp;gt;中的id值相同。&#xA;&#xA;六、Plugin行为&#xA;&#xA;    &amp;lt;jsp:plugin&amp;gt;标签表示执行一个applet或Bean，有可能的话还要下载一个Java插件用于执行它。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:plugin&#xA;    type=&amp;quot;bean | applet&amp;quot;&#xA;    code=&amp;quot;classFileName&amp;quot;&#xA;    codebase=&amp;quot;classFileDirectoryName&amp;quot;&#xA;    [ name=&amp;quot;instanceName&amp;quot; ]&#xA;    [ archive=&amp;quot;URIToArchive, ...&amp;quot; ]&#xA;    [ align=&amp;quot;bottom | top | middle | left | right&amp;quot; ]&#xA;    [ height=&amp;quot;displayPixels&amp;quot; ]&#xA;    [ width=&amp;quot;displayPixels&amp;quot; ]&#xA;    [ hspace=&amp;quot;leftRightPixels&amp;quot; ]&#xA;    [ vspace=&amp;quot;topBottomPixels&amp;quot; ]&#xA;    [ jreversion=&amp;quot;JREVersionNumber | 1.1&amp;quot; ]&#xA;    [ nspluginurl=&amp;quot;URLToPlugin&amp;quot; ]&#xA;    [ iepluginurl=&amp;quot;URLToPlugin&amp;quot; ] &amp;gt;&#xA;    [ &amp;lt;jsp:params&amp;gt;&#xA;    [ &amp;lt;jsp:param name=&amp;quot;parameterName&amp;quot; value=&amp;quot;{parameterValue | &amp;lt;％= expression ％&amp;gt;}&amp;quot; /&amp;gt; ]+&#xA;    &amp;lt;/jsp:params&amp;gt; ]&#xA;    [ &amp;lt;jsp:fallback&amp;gt; text message for user &amp;lt;/jsp:fallback&amp;gt; ]&#xA;    &amp;lt;/jsp:plugin&amp;gt;&#xA;&#xA;    注：&#xA;    &amp;lt;jsp:plugin&amp;gt;元素用于在浏览器中播放或显示一个对象（典型的就是applet和Bean),而这种显示需要在浏览器的java插件。&#xA;    当Jsp文件被编译，送往浏览器时，&amp;lt;jsp:plugin&amp;gt;元素将会根据浏览器的版本替换成&amp;lt;object&amp;gt;或者&amp;lt;embed&amp;gt;元素。注意，&amp;lt;object&amp;gt;用于HTML 4.0 ，&amp;lt;embed&amp;gt;用于HTML 3.2。&#xA;    一般来说，&amp;lt;jsp:plugin&amp;gt;元素会指定对象是Applet还是Bean,同样也会指定class的名字，还有位置，另外还会指定将从哪里下载这个Java插件。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp函数&#34;&gt;&#xA;  jsp函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;用response.getOutputStream返回数据（而非JspWriter）时，调用：&#xA;    # 如输出图片对象：ImageIO.write(image, &amp;quot;jpeg&amp;quot;, response.getOutputStream());&#xA;    out.clear();        # 清空 out&#xA;    out = pageContext.pushBody()    # 将图片对象的流从out输出，直到整个输出结束（接收方网页加载全部完成时）后才断开&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp基本&#34;&gt;&#xA;  jsp基本&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%9f%ba%e6%9c%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;模板元素&#xA;脚本&#xA;&amp;lt;%    %&amp;gt;&#xA;脚本表达式&#xA;&amp;lt;%=    %&amp;gt;&#xA;注释&#xA;&amp;lt;%--    --%&amp;gt;&#xA;指令&#xA;    &amp;lt;%@ page%&amp;gt;&#xA;    language=&amp;quot;java&amp;quot;&#xA;    import=&amp;quot;java.util.*,java.io.*&amp;quot;&#xA;    contentType=&amp;quot;mineType [; charset=characterSet]&amp;quot;&#xA;    pageEncoding=&amp;quot;characterSet&amp;quot;&#xA;    session=&amp;quot;true&amp;quot;&#xA;    buffer=&amp;quot;none | 8kb | sizekb&amp;quot;&#xA;    autoFlush=&amp;quot;true&amp;quot;&#xA;    isThreadSafe=&amp;quot;true&amp;quot;&#xA;    info=&amp;quot;text&amp;quot;&#xA;    errorPage=&amp;quot;relative_url&amp;quot;&#xA;    isErrorPage=&amp;quot;true&amp;quot;&#xA;    isELIgnored=&amp;quot;true&amp;quot;&#xA;    &amp;lt;%@ include%&amp;gt;    # &amp;lt;%@ include file=&amp;quot;in.jspf&amp;quot; %&amp;gt; 是静态包含（原代码中包含），一般包含名字为*.jspf的jsp文件&#xA;    &amp;lt;%@ taglib%&amp;gt;    # 标签库&#xA;声明&#xA;    &amp;lt;%!    %&amp;gt;    # 全局声明（刷新页面仍然保存数据）&#xA;    &amp;lt;% %&amp;gt;    # 局部的声明（刷新页面不保存数据）&#xA;标签&#xA;    &amp;lt;jsp:forward page=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/jsp:forward&amp;gt;&#xA;    &amp;lt;jsp:include page=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/jsp:include&amp;gt;&#xA;内置对象 9个&#xA;    pageContext&#xA;    request&#xA;    response&#xA;    config&#xA;    session&#xA;    application&#xA;    page&#xA;    out&#xA;    exception&#xA;&#xA;    全局变量&#xA;    static final JspFactory        _jspxFactory&#xA;    static java.util.List        _jspx_dependants&#xA;    javax.el.ExpressionFactory    _el_expressionfactory&#xA;    org.apache.AnnotationProcessor    _jsp_annotationprocessor&#xA;    在_jspService中的变量&#xA;    HttpServletRequest        request&#xA;    HttpServletResponse        response&#xA;    PageContext        pageContext = null;&#xA;                pageContext = _jspxFactory.getPageContext(this,request,response,null,true,8192,ture);&#xA;    HttpSession        session = null;&#xA;                session = pageContext.getSession();&#xA;    ServletContext        application = null;&#xA;                application = pageContext.getServletContext();&#xA;    ServletConfig        config = null;&#xA;                config = pageContext.getServletConfig();&#xA;    JspWriter            out = null;&#xA;                out = pageContext.getOut();&#xA;    Object            page = this;&#xA;    JspWriter            _jspx_out = null;&#xA;                _jspx_out = out;&#xA;    PageContext        _jspx_page_context = null;&#xA;                _jspx_page_context = pageContext;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp验证码&#34;&gt;&#xA;  jsp验证码&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e9%aa%8c%e8%af%81%e7%a0%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;实例    # 在&amp;lt;img&amp;gt;标签的src属性中指定该jsp文件即可&#xA;&#xA;    ## out.clear();out = pageContext.pushBody();两条语句的作用是&#xA;    ## 使该验证码jsp文件的传输不会默认地在返回数据后中断，而是在&amp;lt;img&amp;gt;标签调用该jsp的页面加载结束之后再中断数据的传输&#xA;    &amp;lt;%@ page language=&amp;quot;java&amp;quot; pageEncoding=&amp;quot;UTF-8&amp;quot;%&amp;gt;&#xA;&amp;lt;%@ page contentType=&amp;quot;image/jpeg&amp;quot; import=&amp;quot;java.util.*,java.awt.*,java.awt.image.*,javax.imageio.*&amp;quot;%&amp;gt;&#xA;&amp;lt;%!&#xA;    // 声明区，定义产生颜色和验证内容的全局方法&#xA;    public Color getColor(){&#xA;&#xA;    Random random = new Random();&#xA;    int r = random.nextInt(256);&#xA;    int g = random.nextInt(256);&#xA;    int b = random.nextInt(256);&#xA;    return new Color(r,g,b);&#xA;    }&#xA;    public String getNum(){&#xA;    String str = &amp;quot;&amp;quot;;&#xA;    Random random = new Random();&#xA;    for(int i = 0; i &amp;lt; 4; i++){&#xA;        str += random.nextInt(10) + &amp;quot; &amp;quot;;&#xA;    }&#xA;    return str;&#xA;    }&#xA;%&amp;gt;&#xA;&amp;lt;%&#xA;    // 设置响应无缓存&#xA;    response.setHeader(&amp;quot;pragma&amp;quot;, &amp;quot;mo-cache&amp;quot;);&#xA;    response.setHeader(&amp;quot;cache-control&amp;quot;, &amp;quot;no-cache&amp;quot;);&#xA;    response.setDateHeader(&amp;quot;expires&amp;quot;, 0);&#xA;    // 图片对象,画笔对象&#xA;    BufferedImage image = new BufferedImage(80,30,BufferedImage.TYPE_INT_RGB);&#xA;    Graphics g = image.getGraphics();&#xA;    // 画背景&#xA;    g.setColor(new Color(200,200,200));&#xA;    g.fillRect(0, 0, 80, 30);&#xA;    // 画干扰线&#xA;    for(int i = 0; i &amp;lt; 30; i++){&#xA;    Random random = new Random();&#xA;    int x = random.nextInt(80);&#xA;    int y = random.nextInt(30);&#xA;    int xl = random.nextInt(x+10);&#xA;    int yl = random.nextInt(y+10);&#xA;    g.setColor(getColor());&#xA;    g.drawLine(x, y, x + xl, y + yl);&#xA;    }&#xA;    // 画内容&#xA;    g.setFont(new Font(&amp;quot;serif&amp;quot;, Font.BOLD,16));&#xA;    g.setColor(Color.BLACK);&#xA;    String checkNum = getNum();&#xA;    g.drawString(checkNum,15,20);&#xA;    // 放内容到session中，返回图片流&#xA;    session.setAttribute(&amp;quot;validateCode&amp;quot;, checkNum.replaceAll(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;));&#xA;    ImageIO.write(image, &amp;quot;jpeg&amp;quot;, response.getOutputStream());&#xA;    out.clear();&#xA;    out = pageContext.pushBody();    // 不按照jsp默认的getWriter()方法输出，用我们定义的流的方法进行输出&#xA;%&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;自定义标签&#34;&gt;&#xA;  自定义标签&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a0%87%e7%ad%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;1、JspTag 接口（标记接口，类以Serializable）&#xA;2、Tag 接口（空标签，如&amp;lt;img/&amp;gt;）&#xA;    属性：&#xA;    static int EVAL_BODY_INCLUDE        通过流执行标签体&#xA;    static int EVAL_PAGE              继续执行页面&#xA;    static int SKIP_BODY            忽略执行标签体&#xA;    static int SKIP_PAGE            忽略后面的JSP页面&#xA;    方法：&#xA;    // 生命周期方法&#xA;    int doEndTag()            当遇到标签结束的时候自动执行&#xA;    int doStartTag()            当遇到标签开始的时候自动执行&#xA;    // 实现方法&#xA;    Tag getParent()            获取当前标签的父标签处理类对象&#xA;    void release()            当事件改变的时候自动执行&#xA;    void setPageContext(PageContext pc)    设置当前的JSP上下文环境&#xA;    void setParent(Tag t)        设置当前标签的父标签对象&#xA;3、TagSupport 类（有属性的标签，如&amp;lt;img src=&amp;quot;&amp;quot;/&amp;gt;）&#xA;    实现了Tag接口并且提供处理标签属性的方法(set和get)。而且内部定义了一个PageContext变量并且已经初始化开发者可以直接使用this或者super直接方法该属性。&#xA;4、BodyTagSupport类（有属性有文本内容和标签，如&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;aaa&amp;lt;/img&amp;gt;）&#xA;    新属性&#xA;    protected  BodyContent bodyContent&#xA;    新方法&#xA;    void setBodyContent(BodyContent b)&#xA;    BodyContent getBodyContent()&#xA;&#xA;    BodyContent类&#xA;        abstract String getString()    //获取标签体&#xA;&#xA;    写Tag接口的标签库&#xA;    1、写Tag接口实现类&#xA;        写属性pageContext（getter 和setter），从setPageContext(PageContext pc)方法中获得该属性&#xA;        复写方法&#xA;    2、写tld文件，放到/META-INF文件夹中&#xA;        &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;        &amp;lt;taglib xmlns=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot;&#xA;        xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&#xA;        xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&amp;quot;&#xA;        version=&amp;quot;2.1&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;tlib-version&amp;gt;1.0&amp;lt;/tlib-version&amp;gt;&#xA;        &amp;lt;short-name&amp;gt;ouru&amp;lt;/short-name&amp;gt;    # 简称&#xA;        &amp;lt;uri&amp;gt;/outrun-tags&amp;lt;/uri&amp;gt;    # 自定义引入标签时写的路径&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;testDate&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.test.DataImplTag&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;empty&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;/taglib&amp;gt;&#xA;    3、jsp 中引用它&#xA;        &amp;lt;%@ taglib prefix=&amp;quot;ouru&amp;quot; uri=&amp;quot;/META-INF/myUtil.tld&amp;quot; %&amp;gt;&#xA;    写TagSupport接口的实现类&#xA;    pageContext已内置&#xA;    定义接收属性&#xA;    tld文件中加入attribute属性&#xA;        &amp;lt;attribute&amp;gt;        属性描述的开始&#xA;        &amp;lt;name&amp;gt;pattern&amp;lt;/name&amp;gt;    描述属性名&#xA;        &amp;lt;required&amp;gt;true&amp;lt;/required&amp;gt;    描述属性是否是必须的&#xA;        &amp;lt;rtexprvalue&amp;gt;true&amp;lt;/rtexprvalue&amp;gt;  描述属性值是否可以是输出表达式&#xA;        &amp;lt;/attribute&amp;gt;&#xA;    写BodyTagSupport接口的实现类&#xA;    BodyContent body = this.getBodyContent();&#xA;    String desc = body.getString();&#xA;&#xA;    tld 文件中&#xA;    &amp;lt;body-content&amp;gt;JSP&amp;lt;/body-content&amp;gt;    # 有标签体，可执行脚本表达式&#xA;                        ## scriptless，有标签体，不执委脚本表达式&#xA;                        ## empty,没有标签体&#xA;&#xA;Jsp2.0&#xA;    JspTag — SimpleTag — SimpleTagSupport&#xA;&#xA;    SimpleTagSupport类&#xA;    该类可以直接进行操作标签的属性和标签体。&#xA;    void doTag()                遇到标签的时候自动指定&#xA;    protected  JspFragment getJspBody()          获取标签体对象&#xA;    protected  JspContext getJspContext()      获取JSP上下文环境对象&#xA;    JspTag getParent()            获取该标签的父标签处理类对象&#xA;        JspFragment类&#xA;        该类代表的标签的标签体。&#xA;        abstract  void invoke(Writer out)    输出数据到指定的流，null输出到JSP页面&#xA;    获得标签体的方法：&#xA;        Writer writer = new StringWriter();&#xA;        JspFragment jspFragment = getJspBody();&#xA;        jspFragment.invoke(writer);&#xA;        String text = writer.toString();&#xA;    项目：实现 if else 判断&#xA;    Choose.java&#xA;        private boolean tag = true;&#xA;&#xA;        public boolean isTag() {&#xA;            return tag;&#xA;        }&#xA;&#xA;        public void setTag(boolean tag) {&#xA;            this.tag = tag;&#xA;        }&#xA;&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            getJspBody().invoke(null);&#xA;            super.doTag();&#xA;        }&#xA;    when.java 文件&#xA;        private boolean test = false;&#xA;        public boolean isTest() {&#xA;            return test;&#xA;        }&#xA;&#xA;        public void setTest(boolean test) {&#xA;            this.test = test;&#xA;        }&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            Choose parent = (Choose) getParent();&#xA;            if(isTest() &amp;amp;&amp;amp; parent.isTag()){&#xA;            // 条件成立&#xA;            getJspBody().invoke(null);&#xA;            // 设置父的tag为false&#xA;            parent.setTag(false);&#xA;            }&#xA;            super.doTag();&#xA;        }&#xA;    Otherwise.java 文件&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            Choose parent = (Choose) getParent();&#xA;            if(parent.isTag()){&#xA;            // 条件成立&#xA;            getJspBody().invoke(null);&#xA;            parent.setTag(false);&#xA;            }&#xA;            super.doTag();&#xA;        }&#xA;    tld文件&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;choose&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.Choose&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;    # 有标签体，可执行脚本表达式&#xA;                                ## scriptless，有标签体，不执委脚本表达式&#xA;                                ## empty,没有标签体&#xA;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;when&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.When&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;attribute&amp;gt;&#xA;        &amp;lt;name&amp;gt;test&amp;lt;/name&amp;gt;&#xA;        &amp;lt;required&amp;gt;true&amp;lt;/required&amp;gt;&#xA;        &amp;lt;rtexprvalue&amp;gt;true&amp;lt;/rtexprvalue&amp;gt;&#xA;        &amp;lt;/attribute&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;otherwise&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.Otherwise&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;&#xA;&#xA;控件标签：&#xA;自定义函数库&#xA;    1 创建函数库类&#xA;    public class MyFunctions {&#xA;    public static String formatMyName(String name) {&#xA;    return &amp;quot;your name is &amp;quot; + name;&#xA;    }&#xA;    public static int add(int a, int b) {&#xA;    return a+b;&#xA;    }&#xA;    }&#xA;&#xA;    2 在TLD文件中配置 (引用于目标1中的tld文件)&#xA;    &amp;lt;function&amp;gt;&#xA;    &amp;lt;name&amp;gt;formatMyName&amp;lt;/name&amp;gt;&#xA;    &amp;lt;function-class&amp;gt;com.taglib.MyFunctions&amp;lt;/function-class&amp;gt;&#xA;    &amp;lt;function-signature&amp;gt;java.lang.String formatMyName(java.lang.String)&amp;lt;/function-signature&amp;gt;&#xA;    &amp;lt;/function&amp;gt;&#xA;&#xA;    &amp;lt;function&amp;gt;&#xA;    &amp;lt;name&amp;gt;add&amp;lt;/name&amp;gt;&#xA;    &amp;lt;function-class&amp;gt;com.taglib.MyFunctions&amp;lt;/function-class&amp;gt;&#xA;    &amp;lt;function-signature&amp;gt;java.lang.String add(int, int)&amp;lt;/function-signature&amp;gt;&#xA;    &amp;lt;/function&amp;gt;&#xA;&#xA;    3 JSP中调用&#xA;&#xA;    ${cc:formatMyName(&amp;quot;wangfei&amp;quot;) }&#xA;    ${cc:add(12, 34) }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jdbc&#34;&gt;&#xA;  jdbc&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdbc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;流程&#xA;    Class.forName()     # 加载驱动&#xA;    DriverManager.getConnection()&#xA;    获得sql会话对象 Statement或PreparedStatement&#xA;    设置参数setXxx(), 执行sql，处理结果集&#xA;    关闭结果集、关闭会话、关闭连接&#xA;Statement&#xA;    execute&#xA;    executeQuery&#xA;    executeUpdate&#xA;    不要使用Statement&#xA;        容易sql注入&#xA;        代码可读性可维护性差&#xA;        PreparedStatement性能高，db缓存机制，相同预编译语句调用不再编译&#xA;PreparedStatement&#xA;    # 继承Statement, 预编译sql&#xA;&#xA;事务怎么写&#xA;    编程式&#xA;    声明式: 用aop注入&#xA;三种连接&#xA;    Connection&#xA;        默认自动提交&#xA;        禁止自动提交开启事务, 后调commit&#xA;    Pooled Connection&#xA;        使用完后不用关闭&#xA;    XA Connection&#xA;        分布式事务&#xA;        XAResource获得&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;i18n&#34;&gt;&#xA;  i18n&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#i18n&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;页面需要获取用户信息，从数据库中取数据显示&#xA;&#xA;java类中试用：&#xA;cn.itcast.resource包中&#xA;    hello_en_US.properties&#xA;    hello=hello&#xA;    hello_zh_CN.properties&#xA;    hello=编码后的“你好”&#xA;    Test.java&#xA;    #  获取信息&#xA;    Locale locale = locale.CHINA;&#xA;    #  加载资源&#xA;    ResourceBundle bundler = ResourceBundle.getBundle(&amp;quot;cn.itcast.resource.hello&amp;quot;,locale);&#xA;    #  取出数据&#xA;    String str = bundler.getString(&amp;quot;hello&amp;quot;);&#xA;&#xA;jsp中&#xA;&amp;lt;%&#xA;    ResourceBundle bundler = ResourceBundle.getBundle(&amp;quot;lang.properties.hello&amp;quot;, request.getLocale());&#xA;    out.write(bundler.getString(&amp;quot;title&amp;quot;));&#xA;%&amp;gt;&#xA;&amp;lt;fmt&amp;gt;标签&#xA;    &amp;lt;fmt:setLocale value=&amp;quot;${pageContext.request.locale }&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&#xA;    &amp;lt;fmt:setBundle basename=&amp;quot;lang.properties.hello&amp;quot; var=&amp;quot;bundler&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&#xA;    &amp;lt;fmt:message bundle=&amp;quot;${bundler }&amp;quot; key=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;/fmt:message&amp;gt;&#xA;资源转码&#xA;    native2ascii.exe&#xA;    myeclipse properties文件编辑器&#xA;ie 中得到en_US&#xA;Locale locale&#xA;    getLanguage();&#xA;    getCountry();&#xA;    getDefault();&#xA;ResourceBundle&#xA;    读取文件cn.itcast.resource.hello省略_en_US.properties&#xA;    getString(String key)&#xA;实例1：&#xA;    创建页面&#xA;    创建资源文件&#xA;    编辑页面&#xA;    request.getLocale();&#xA;    ResourceBundle.getBundle(&amp;quot;&amp;quot;,locale);&#xA;    getString(&amp;quot;&amp;quot;)&#xA;实例2：&#xA;    编辑页面&#xA;    &amp;lt;%@ taglib%&amp;gt;&#xA;    &amp;lt;f:setLocale scope=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;f:setBundle basename=&amp;quot;&amp;quot; var=&amp;quot;&amp;quot; scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;f:message bundle=&amp;quot;&amp;quot; key=&amp;quot;&amp;quot; &amp;gt;&#xA;动态数据国际化&#xA;日期国际化&#xA;    SimpleDateFormat    #  继承DateFormat&#xA;    getDateTimeInstance&#xA;    getDateInstance&#xA;    getTimeInstance&#xA;&#xA;    static int FULL&#xA;    static int LONG&#xA;    static int MEDIUM&#xA;    static int SHORT&#xA;实例3：&#xA;    cn.itcast.i18n.MyDateI18n&#xA;    DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);&#xA;    String str = format.format(new Date());&#xA;    解析页面中的字符串&#xA;    FULL 和 LONG  和 MEDIUM 和 SHORT 的 区别&#xA;    DataFomat&#xA;    String format(Date date)&#xA;    Date parse(String source)&#xA;    创建static string2Date(String str)&#xA;    #  分析区域&#xA;    Locale locale = Locale.CHINA;&#xA;&#xA;    #  分析日期的风格&#xA;    int dateType = DateFormat.SHORT;&#xA;    int timeType = DateFormat.FULL;&#xA;&#xA;    #  获取对象&#xA;    DateFormat format = DateFormat.getDateTimeInstance(dateType,timeType,locale);&#xA;&#xA;    #  解析&#xA;    format.parse(str);&#xA;动态数字国际化&#xA;    java.text.*;&#xA;    Number类&#xA;    NumberFormat(普通数字，货币，百分比)&#xA;    getIntegetInstance&#xA;    getCurrencyInstance&#xA;    getPercentInstance(Locale inLocale)&#xA;&#xA;    format&#xA;    parse&#xA;    创建cn.itcast.i18n.MyNumberI18n&#xA;    #  获取对象&#xA;    #  getPercentInstance&#xA;    #  getCurrencyInstance&#xA;    NumberFormat format = NumberFormat.getIntegerInstance(Locale.CHINA);&#xA;&#xA;    #  格式化 或解析&#xA;    long num = 10000000000L;&#xA;    #  Number num = format.parse(str);&#xA;    #  double price = num.doubleValue();&#xA;    format.format(num);&#xA;动态文本国际化&#xA;    At 12:30 pm on jul 3,1998, a hurricance destroyed 99 houses and caused $1000000 of damage.&#xA;    MessageFormat&#xA;    MessageFormat(String pattern,Locale locale)&#xA;    format(String pattern,Object...arguments)&#xA;    format(Object)&#xA;    parse()&#xA;    占位&#xA;    At{0}  on {0}, a hurricance destroyed{1} houses and caused {2} of damage.&#xA;&#xA;    实例1：&#xA;    MyMessageI18n.java&#xA;    #  定义模式字符串&#xA;    String pattern&#xA;    #  定义locale对象&#xA;    MessageFormat format = new MessageFormat(pattern,Locale.CHINA);&#xA;    #  定义参数数组&#xA;    DateFormat datef = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.SHORT,Locale.US);&#xA;    Date date = datef.parse(&amp;quot;Jul 3,1998 12:30 PM&amp;quot;);&#xA;&#xA;    Integer num = new Integer(99);&#xA;&#xA;    long currency = NumberFormat.getCurrencyInstance(Locale.US).parse(&amp;quot;$1000000&amp;quot;);&#xA;    String damage = NumberFormat.getCurrencyInstance(locale).format(currency);&#xA;&#xA;    Object [] values = {date,num,damage};&#xA;    #  格式化&#xA;    String str = format.format(values);&#xA;&#xA;    分析：{索引，对象，类型}&#xA;    MessageFormat messf = new MessageFormat(&amp;quot;{0,time,short} on {0,date}, a hurricance destroyed {1} houses and caused {2,number,currency} of damage.&amp;quot;,Locale.CHINA);&#xA;&#xA;    Object [] values = {new Date(),new Integer(100),1000};&#xA;&#xA;    String str = messf.format(values);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;中间件&#34;&gt;&#xA;  中间件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e9%97%b4%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;顺序&#xA;    监听器 -&amp;gt; 过滤器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;监听器&#34;&gt;&#xA;  监听器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e5%90%ac%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    ServletContextListener&#xA;    ServletContextAttributeListener&#xA;    HttpSessionListener&#xA;    HttpSessionAttributeListener&#xA;    HttpSessionActivationListener&#xA;web.xml 注册在过滤器后面，servlet前面&#xA;    &amp;lt;listener&amp;gt;&#xA;    &amp;lt;listener-class&amp;gt;cn.listen.MyListener&amp;lt;/listener-class&amp;gt;&#xA;    &amp;lt;/listener&amp;gt;&#xA;自定义&#xA;    public class MyListener implements ServletContextListener {&#xA;        public void contextDestroyed(ServletContextEvent sce) {&#xA;            System.out.println(&amp;quot;die&amp;quot;);&#xA;        }&#xA;        public void contextInitialized(ServletContextEvent sce) {&#xA;            System.out.println(&amp;quot;init&amp;quot;);&#xA;        }&#xA;&#xA;        // 当过滤器被销毁时自动执行&#xA;        public void destroy(){&#xA;            System.out.println(&amp;quot;Filterdestroyed&amp;quot;);&#xA;        }&#xA;        // 当拦截的时候&#xA;        public void doFilter(request,response,chain){&#xA;            System.out.println(&amp;quot;doFilter&amp;quot;);&#xA;            System.out.println(&amp;quot;放行目标资源&amp;quot;);&#xA;            chain.doFilter(request,response);&#xA;            System.out.println(&amp;quot;目标已经放行&amp;quot;);&#xA;        }&#xA;        // 初始化的时候&#xA;        public void init(FilterConfig config){&#xA;            System.out.println(&amp;quot;FilterInited&amp;quot;);&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;过滤器&#34;&gt;&#xA;  过滤器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%87%e6%bb%a4%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;web.xml&#xA;    &amp;lt;filter&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;testFilter&#xA;        &amp;lt;filter-class&amp;gt;cn.itcast.filter.text.TestFilter&#xA;        &amp;lt;init-param&amp;gt;&#xA;            &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;&#xA;            &amp;lt;param-value&amp;gt;GB2312&amp;lt;/param-value&amp;gt;&#xA;        &amp;lt;/init-param&amp;gt;&#xA;    &amp;lt;/filter&amp;gt;&#xA;    &amp;lt;filter-mapping&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;testFilter&#xA;        &amp;lt;url-pattern&amp;gt;/*&#xA;    &amp;lt;/filter-mapping&amp;gt;&#xA;&#xA;api&#xA;    Filter接口&#xA;        ## 多个过滤器, 按web.xml中注册的顺序映射调用。servlet执行完后, 从后向前返回执行chain.doFilter之后的方法&#xA;        init&#xA;        destroy&#xA;        doFilter(ServletRequest request, ServletResponse response, FilterChain chain)&#xA;    FilterChain接口&#xA;        doFilter(ServletRequest request, ServletResponse response)&#xA;    FilterConfig接口&#xA;        private FilterConfig config = null;&#xA;        init()&#xA;            this.config = config;&#xA;        doFilter()&#xA;            String ip = this.config.getInitParameter(&amp;quot;ip&amp;quot;);&#xA;&#xA;映射&#xA;    1.映射的url&#xA;    2.servlet的名字&#xA;        # 通配servlet &amp;lt;url-pattern&amp;gt;/servlet/*&amp;lt;/url-pattern&amp;gt;&#xA;    3.为了映射servlet中的转发, 映射一个过滤器到某种传递方式&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;            &amp;lt;dispatcher&amp;gt;FORWARD&#xA;                # FORWARD 转发方式&#xA;                # REQUEST  请求方式&#xA;                # INCLUDE  包含方式&#xA;                # ERROR  错误页面&#xA;            &amp;lt;/dispatcher&amp;gt;&#xA;        &amp;lt;/filter-mapping&amp;gt;&#xA;设置编码&#xA;    doFilter()&#xA;        HttpServletRequest httpRequest = (HttpServletRequest) request;&#xA;        HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;        httpRequest.setCharacterEncoding(&amp;quot;utf-8&amp;quot;)&#xA;        String method = httpRequest.getMethod();&#xA;        if(&amp;quot;get&amp;quot;.equalsIgnoreCase(method)){&#xA;            chain.doFilter(new MyWapperRequest(httpRequest),response);&#xA;        }else{&#xA;            request.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);&#xA;        }&#xA;&#xA;    class MyWapperRequest extends HttpServletRequestWrapper{&#xA;        private HttpServletRequest request = null;&#xA;&#xA;        public MyWapperRequest (HttpServletRequest request){&#xA;            super(request);&#xA;            this.request = request;&#xA;        }&#xA;&#xA;        @Override&#xA;        public String getParameter(String name){&#xA;            String value = request.getParameter(name);&#xA;            String method = request.getMethod();&#xA;            if(value != null &amp;amp;&amp;amp;&amp;quot;get&amp;quot;.equalsIgnoreCase(method)){&#xA;                value = new String(value.getBytes(&amp;quot;iso8859-1&amp;quot;),request.getCharacterEncoding())&#xA;            }&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;设置缓存&#xA;    # Expires:-1&#xA;    # Cache-Control:no-cache&#xA;    # Pragma:no-cache&#xA;&#xA;    NoCacheFilter implements Filter # 设置不缓存&#xA;        doFilter()&#xA;            HttpServletResponse httpResponse = response;&#xA;            httpResponse.setHeader(&amp;quot;Expires&amp;quot;,-1 + &amp;quot;&amp;quot;);&#xA;            //  setDataHeader(&amp;quot;expires&amp;quot;,-1);&#xA;            httpResponse.setHeader(&amp;quot;cache-control&amp;quot;,&amp;quot;no-cache&amp;quot;);&#xA;            httpResponse.setHeader(&amp;quot;pragma&amp;quot;,&amp;quot;no-cache&amp;quot;);&#xA;            chain.doFilter(request,httpResponse);&#xA;&#xA;&#xA;&#xA;    CacheFilter&#xA;        # 缓存静态资源&#xA;        # web.xml中url-pattern 可以映射多个 param-name=jpg param-value=2&#xA;        private FilterConfig config = null;&#xA;&#xA;        doFilter()&#xA;            HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;            HttpServletResponse httpRequest = (HttpServletRequest) request;&#xA;&#xA;        String resource = request.getRequestURI();&#xA;        String date  = null;&#xA;        if(resource.endsWith(&amp;quot;jpg&amp;quot;)){&#xA;            date =  config.getInitParameter(&amp;quot;jpg&amp;quot;);&#xA;            httpResponse.setDateHeader(&amp;quot;expires&amp;quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);    // 换算成秒&#xA;        } else if(resource.endsWith(&amp;quot;js&amp;quot;)){&#xA;            String date  = config.getInitParameter(&amp;quot;js&amp;quot;);&#xA;            config.getInitParameter(&amp;quot;js&amp;quot;);&#xA;            httpResponse.setDateHeader(&amp;quot;expires&amp;quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);&#xA;        }&#xA;&#xA;        chain.doFilter(httpRequest,httpResponse);&#xA;&#xA;修改编码&#xA;    EncodingFilter implements Filter{&#xA;        doFilter(request,response){&#xA;            HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;            HttpServletResponse httpRequest = (HttpServletRequest) request;&#xA;            httpRequest.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);&#xA;            chain.doFilter(httpRequest,httpResponse);&#xA;        }&#xA;    }&#xA;    class EncodingRequest extends HttpServletRequestWrapper{&#xA;        private HttpServletRequest request;&#xA;        public EncodingRequest (HttpServletRequest request){&#xA;            super(request);&#xA;            this.request = request;&#xA;        }&#xA;&#xA;        @Override&#xA;        public String getParameter(String name){&#xA;            String value = request.getParameter(name)&#xA;            if(value != null &amp;amp;&amp;amp; &amp;quot;get&amp;quot;.equalsIgnoreCase(request.getMethod)){&#xA;                value = new String(value.getBytes(&amp;quot;iso8859&amp;quot;),&amp;quot;utf-8&amp;quot;);&#xA;            }&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;登录&#xA;    LoginFilter&#xA;        init(){&#xA;            this.config  = config;&#xA;        }&#xA;        private FilterConfig config = null;&#xA;        doFilter(){&#xA;            String path = this.config.getInitParameter(&amp;quot;loginPage&amp;quot;);&#xA;            HttpSession session = httpRequest.getSession(false);&#xA;&#xA;            // 判断用户请求的是否是UserServlet&#xA;            String servletName = httpRequest.getServletPath();&#xA;            servletName = substring(servletName.lastIndexOf(&amp;quot;/&amp;quot;)+1);&#xA;            if(&amp;quot;UsersServlet&amp;quot;.equals(servletName)){&#xA;            }else{ // 一般的servlet&#xA;                if(session != null){&#xA;                    // 获取登录标记&#xA;                    User user = null;&#xA;                    user = (User)session.getAttribute(&amp;quot;user&amp;quot;);&#xA;&#xA;                    // 判断&#xA;                    if(user != null){&#xA;                        // 放行资源&#xA;                        chain.doFilter(httpRequest,httpResponse);&#xA;                    }else{&#xA;                        // 页面重定向到登录页面&#xA;                        httpResponse.sendRedirect(httpRequest.getContextPath() + &amp;quot;/&amp;quot; + path);&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    web.xml&#xA;        &amp;lt;filter&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;loginFilter&#xA;            &amp;lt;filter-class&amp;gt;&#xA;            &amp;lt;init-param&amp;gt;&#xA;                &amp;lt;param-name&amp;gt;loginPage&#xA;                &amp;lt;param-value&amp;gt;&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;/jsps/*&#xA;                &amp;lt;url-pattern&amp;gt;/servlet/*&#xA;                &amp;lt;url-pattern&amp;gt;/publics/*&#xA;            &amp;lt;filter-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;/publics/head.jsp&#xA;                &amp;lt;dispatcher&amp;gt;INCLUDE&#xA;                &amp;lt;dispatcher&amp;gt;FORWARD&#xA;                &amp;lt;dispatcher&amp;gt;ERROR&#xA;                &amp;lt;dispatcher&amp;gt;REQUEST&#xA;                    # 默认是request，当加上其它参数时（如include），request会没有，所以要加两个forward,request&#xA;                    ## 是指向里面以该方法请求的时候进行过滤&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;struts2&#34;&gt;&#xA;  struts2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#struts2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Java并发</title>
      <link>https://ukeate.com/docs/pl/java/juc/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/java/juc/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;并发编程三大特性&#xA;    可见性(visibility)&#xA;        synchronized会刷新线程栈&#xA;    有序性(ordering)&#xA;    原子性(atomicity)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  CPU&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;PC寄存器(Program Counter Register, 存下一指令)&#xA;优化&#xA;    乱序读&#xA;    合并写&#xA;    乱序执行(流水线)&#xA;ALU&#xA;    访问速度&#xA;        Registers: &amp;lt; 1ns&#xA;        L1 cache(核内): 1ns&#xA;        WC(Writer Comblining) Buffer    # 合并写, 一般4个字节&#xA;        L2 cache(核内): 3ns&#xA;        L3 cache(CPU内): 15ns&#xA;        memory: 80ns&#xA;局部性原理&#xA;    空间&#xA;        按块读取(cache line)&#xA;            一次读64Bytes               # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知&#xA;            Java1.8注解@Contended       # 保证不在同一行，需要JVM参数-XX:-RestrictContended&#xA;    时间&#xA;        批量读指令&#xA;内存屏障                        # 不同CPU不一样&#xA;    Intel&#xA;        sfence                      # save, 之前写操作必须完成&#xA;        lfence                      # load, 之前读操作必须完成&#xA;        mfence                      # mix(save + load)&#xA;lock指令                            # 指令执行完之前，锁内存&#xA;    lock_add&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;cpu缓存一致性协议&#34;&gt;&#xA;  CPU缓存一致性协议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁&#xA;状态&#xA;    MESI Cache一致性协议                    # Intel CPU，实现方式为主动监听&#xA;        Modified                            # 一行数据在CPU Modified, 其它CPU为Invalid&#xA;        Exclusive                           # 独享，其它CPU没有&#xA;        Shared                              # 别人也在读&#xA;        Invalid                             # 别人改过了&#xA;    MSI&#xA;    MOSI&#xA;缓存行                                      # 多数64字节&#xA;    伪共享                                  # 缓存行内无关数据也要同步&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;os&#34;&gt;&#xA;  OS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#os&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;进程&#xA;    # 资源分配&#xA;线程&#xA;    # 调度执行&#xA;    切换(Context Switch)&#xA;        CPU导出原线程指令和data到cache, 再导入新线程数据&#xA;    线程数&#xA;        N(threads) = N(CPU) * U(CPU) * (1 + W/C)&#xA;            # N(CPU): CPU数&#xA;            # U(CPU): 期望CPU利用率, 0到1&#xA;            # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析&#xA;        压测决定&#xA;CPU性能压榨&#xA;    单进程&#xA;    批处理&#xA;    多进程切换&#xA;    多线程进程内切换&#xA;        I/O复用&#xA;    协程(纤程、绿色线程)用户空间切换&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jvm&#34;&gt;&#xA;  JVM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;内存屏障&#34;&gt;&#xA;  内存屏障&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;LoadLoad&#xA;StoreStore&#xA;LoadStore&#xA;StoreLoad&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;乱序执行指令重排序&#34;&gt;&#xA;  乱序执行(指令重排序)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;为什么&#xA;    CPU快, 指令1阻塞时，指令2先执行&#xA;判断&#xA;    代码不影响单线程最终一致性&#xA;例子，多线程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0, b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Long.&lt;span style=&#34;color:#a6e22e&#34;&gt;MAX_VALUE&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&amp;gt;&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                x&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                y&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                CountDownLatch latch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CountDownLatch(2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Thread one &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Thread other &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                one.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                other.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;例子，类初始化指令换顺序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 8;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        T t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; T();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        汇编码&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            0 &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 变量半初始化状态为0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            3 dup&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            4 invokespecial &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;3 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T.&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;init&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            7 astore_1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;线程访问时中间状态逸出&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            8 &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;)).&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; C();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#a6e22e&#34;&gt;in&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;unsafe类&#34;&gt;&#xA;  Unsafe类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#unsafe%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 相当于指针。1.8只能根部类用, 11可以直接用&#xA;操作内存&#xA;    allocateMemory&#xA;    putXX&#xA;    freeMemory&#xA;    pageSize&#xA;生成类实例&#xA;    allocateInstance&#xA;操作类或实例&#xA;    objectFieldOffset&#xA;    getInt&#xA;    getObject&#xA;CAS&#xA;    compareAndSwapObject()          # JDK1.8&#xA;    compareAndSetObject()&#xA;    weakCompareAndSetObject()       # JDK11&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;修饰符与锁&#34;&gt;&#xA;  修饰符与锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e4%b8%8e%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;&#xA;  概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;锁细化                              # 少代码加轻量锁&#xA;锁粗化                              # 锁太多时，如行锁变表锁&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;synchronized&#34;&gt;&#xA;  synchronized&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;实现方式&#xA;    JVM没要求实现方式&#xA;    早期都是OS调度&#xA;    HotSpot&#xA;        在对象头(64位)上用2位实现，组合成锁的类型&#xA;        锁升级                      # 不比原子类慢，升完不降&#xA;            偏向锁, 第一个线程第一次访问只记线程id&#xA;            自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平&#xA;            重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景&#xA;原子性、可见性&#xA;可重入                              # 同一个对象同线程可重入&#xA;加锁对象&#xA;    方法锁和对象锁锁this&#xA;    static方法锁和类锁锁class类&#xA;    继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象&#xA;使用注意&#xA;    抛异常立即释放锁，但被锁数据已更新&#xA;    不能用的对象&#xA;        String常量，可能未知地方锁同一个&#xA;        Integer、Long等基本类型, 值变化会生成新对象&#xA;    synchronized的属性加final防止赋值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;volatile&#34;&gt;&#xA;  volatile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#volatile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 用synchronized性能差不多，volatile一般不用&#xA;作用&#xA;    # 没有原子性，可能写同一值&#xA;    变量在线程见可见性&#xA;        依靠CPU缓存一致性协议&#xA;    禁止指令重排序                  # 用JVM的读写屏障&#xA;        &#xA;修饰引用类型，内部属性不监控&#xA;&#xA;DCL(Double Check Lock)单例volatile问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; C c;    &lt;span style=&#34;color:#75715e&#34;&gt;// 禁止了创建c指令重排序&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;(){}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; C &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (C.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// 申请内存(半初始化状态默认0)，成员变量初始化，赋值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; C();    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; c;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cas&#34;&gt;&#xA;  CAS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Compare And Set/Swap, 无锁优化, 乐观锁, 自旋&#xA;# Unsafe类支持&#xA;CPU原语&#xA;    cas(V, Expected, NewValue)&#xA;        if V == E                   # 无并发值判断问题，原语上加了屏障&#xA;        V = New&#xA;        else try again or fail&#xA;Java&#xA;    AtomicInteger&#xA;        incrementAndGet()&#xA;ABA问题&#xA;    # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据&#xA;    版本号                          # Java版本号类AtomicStampedReference&#xA;LongAdder&#xA;    LongAdder每次加数字, LongAccumulator用lambda&#xA;    分段锁(CAS)。值分开放数组里, 多线程对应一个item&#xA;性能测试&#xA;    LongAdder(713) &amp;gt; Atomic(2166) &amp;gt; Synchronized(3129)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;锁&#34;&gt;&#xA;  锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;aqs&#34;&gt;&#xA;  AQS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种&#xA;# 实现方式: CAS，volatile, 模板方法&#xA;类图&#xA;    AbstractQueueSynchronizer&#xA;        Sync&#xA;            NonfairSync&#xA;方法&#xA;    AbstractQueueSynchronizer&#xA;        # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待)&#xA;        Node&#xA;            volatile Node prev&#xA;            volatile Node next&#xA;            volatile Thread thread&#xA;        VarHandle&#xA;            # JDK1.9，保存引用，普通属性原子操作。&#xA;            # 相比反射，直接操作二进制码&#xA;            get()&#xA;            set()&#xA;            compareAndSet()         # 原子性&#xA;            getAndAdd()             # 原子性&#xA;            class C {&#xA;                int x = 0;&#xA;                private static VarHandle handle;&#xA;                static {&#xA;                    handle = MethodHandles.lookup().findVarHandle(C.class, &amp;quot;x&amp;quot;, int.class)&#xA;                    handle.compareAndSet(c, 0, 1);&#xA;&#xA;                }&#xA;            }&#xA;        volatile state              # 多态实现&#xA;        acquire()&#xA;        tryAcquire()                # 模板方法&#xA;        acquireQueued()             # 获得&#xA;        addWaiter(Node.EXCLUSIVE)   # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表)&#xA;        cancelAcquire()             # status CANCELLED, tail时设置null, 非tail时unpark下一节点&#xA;    NonfairSync&#xA;        nonfairTryAcquire()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reentrantlock&#34;&gt;&#xA;  ReentrantLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reentrantlock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 可重入锁，CAS实现, state记重入多少次&#xA;    new ReentrantLock(true)         # 公平锁&#xA;    tryLock(long, TimeUnit)&#xA;    lockInterruptibly()             # 响应interrupt()标记&#xA;    newCondition()                  # 多一个等待队列&#xA;&#xA;    源码&#xA;        调NonfairSync&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;countdownlatch&#34;&gt;&#xA;  CountDownLatch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#countdownlatch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 比join()灵活&#xA;    new CountDownLatch(4)&#xA;    countDown()&#xA;    await()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;cyclicbarrier&#34;&gt;&#xA;  CyclicBarrier&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cyclicbarrier&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 满了一起放行, 场景如I/O批量消费&#xA;    new CyclicBarrier(4, ()-&amp;gt;{})&#xA;    await()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;phaser&#34;&gt;&#xA;  Phaser&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#phaser&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 阶段批量执行过滤&#xA;    class MyPhaser extends Phaser {&#xA;        @Override&#xA;        protected boolean onAdvance(int phase, int registeredParties) {&#xA;            switch(phase) {&#xA;                case 0:&#xA;                    print(&amp;quot;arrived&amp;quot; + registeredParties);&#xA;                    return false;&#xA;                case 1:&#xA;                    print(&amp;quot;eated&amp;quot; + registeredParties);&#xA;                    return false;&#xA;                case 2:&#xA;                    print(&amp;quot;hugged&amp;quot; + registeredParties);&#xA;                    return true;&#xA;                default:&#xA;                    return true;&#xA;            }&#xA;        }&#xA;    }&#xA;    Person implements Runnable {&#xA;        private int i;&#xA;        public Person(int i) {&#xA;            this.i = i;&#xA;        }&#xA;        public void arrive() {&#xA;            phaser.arriveAndAwaitAdvance();&#xA;        }&#xA;        public void eat() {&#xA;            phaser.arriveAndAwaitAdvance();&#xA;        }&#xA;        public void hug() {&#xA;            if (i == 0 || i == 1) {&#xA;                phaser.arriveAndAwaitAdvance();&#xA;            } else {&#xA;                phaser.arriveAndDeregister();&#xA;            }&#xA;        }&#xA;&#xA;        @Override&#xA;        public void run() {&#xA;            arrive();&#xA;            eat();&#xA;            hug();&#xA;        }&#xA;    }&#xA;    phaser = new MyPhaser();&#xA;    phaser.bulkRegister(5);&#xA;    for (int i = 0; i &amp;lt; 5; i++) {&#xA;        new Thread(new Person(i)).start()&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;readwritelock&#34;&gt;&#xA;  ReadWriteLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readwritelock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 读锁是共享锁，不能写，悲观锁&#xA;    # 写锁是排他锁，不能读写&#xA;    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();&#xA;    Lock readLock = readWriteLock.readLock();&#xA;    Lock writeLock = readWriteLock.writeLock();&#xA;    void read(Lock lock) {&#xA;        lock.lock()&#xA;        lock.unlock()&#xA;    }&#xA;    void write(Lock lock) {&#xA;        lock.lock()&#xA;        lock.unlock()&#xA;    }&#xA;    for (int i =0; i&amp;lt;10;i++) {&#xA;        new Thread(()-&amp;gt;read(readLock)).start();&#xA;    }&#xA;    for (int i =0; i&amp;lt;2; i++) {&#xA;        new Thread(()-&amp;gt;write(writeLock)).start();&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;stampedlock&#34;&gt;&#xA;  StampedLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stampedlock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 读时允许写，读完判断不一致再读一遍，乐观锁&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;semaphore&#34;&gt;&#xA;  Semaphore&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#semaphore&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 信号量, 限流同时运行, 用于线程间同步。可设置公平&#xA;    Semaphore s = new Semaphore(1, true)&#xA;    new Thread(() -&amp;gt; {&#xA;        s.acquire();&#xA;        s.release()&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;exchanger&#34;&gt;&#xA;  Exchanger&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#exchanger&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 线程间通信, 阻塞交换&#xA;    exchange()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;locksupport&#34;&gt;&#xA;  LockSupport&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#locksupport&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 线程间通信，非锁阻塞，指定线程唤醒&#xA;    # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1)&#xA;    Thread t = new Thread(() -&amp;gt; {&#xA;        for (int i = 0; i &amp;lt; 10; i++) {&#xA;            if (i == 5) {&#xA;                LockSupport.park();&#xA;            }&#xA;        }&#xA;    })&#xA;    t.start();&#xA;    TimeUnit.SECONDS.sleep(1);&#xA;    LockSupport.unpark(t);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;线程及线程池&#34;&gt;&#xA;  线程及线程池&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%8f%8a%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;使用注意&#34;&gt;&#xA;  使用注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;为什么不用Executors线程池&#xA;    用LinkedBlockingQueue超数量OOM&#xA;    拒绝策略&#xA;    线程命名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类&#34;&gt;&#xA;  类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Object&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;wait&lt;/span&gt;()                              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 释放synchronized锁并加入等待队列&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;唤醒后执行需要得到synchronized锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;notify&lt;/span&gt;()                            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 只唤醒&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不释放当前synchronized锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentThread&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yield&lt;/span&gt;()                      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 让出CPU, 进Ready队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        getState()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        join()                              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 等待结束&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;setDaemon&lt;/span&gt;()                         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 是否后台&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;setPriority&lt;/span&gt;(Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;NORM_PRIORITY&lt;/span&gt;)   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 优先级&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;没有用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Runnable&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Callable&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        V &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Future&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        get(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cancel(&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        isCanceled()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        isDone()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RunnableFuture&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FutureTask&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompletableFuture&lt;/span&gt;         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; parallel&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;supplyAsync&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;allOf&lt;/span&gt;(CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;...)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;anyOf&lt;/span&gt;(CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;...)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            T &lt;span style=&#34;color:#a6e22e&#34;&gt;join&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;thenApply&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;thenAccept&lt;/span&gt;(Consumer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadFactory&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread &lt;span style=&#34;color:#a6e22e&#34;&gt;newThread&lt;/span&gt;(Runnable)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DefaultThreadFactory&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Executor&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExecutorService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;shutdown&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            shutdownNow()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            isShutdown()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            isTerminated()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            awaitTermination(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Future &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Future &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Runnable, T)                     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 手动设个result&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Runnable)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; AbstractExecutorService&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                RunnableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newTaskFor&lt;/span&gt;(Runnable, T)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                RunnableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newTaskFor&lt;/span&gt;(Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                T &lt;span style=&#34;color:#a6e22e&#34;&gt;doInvokeAny&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; timed, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                submit()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 忽略CancellationException, ExecutionException&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其它异常抛出并取消未完成任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;invokeAll&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 忽略CancellationException, ExecutionException, TimeoutException&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其它异常抛出并取消未完成任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;invokeAny&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadPoolExecutor&lt;/span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 线程池&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;任务队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 任务顺序: 核心线程, 任务队列&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;起新线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;拒绝策略&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledThreadPoolExecutor&lt;/span&gt;       &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 用DelayedWorkQueue&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#a6e22e&#34;&gt;scheduleAtFixedRate&lt;/span&gt;(()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{}, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; initial, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; period, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ForkJoinPool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;(ForkJoinTask)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledExecutorService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompletionService&lt;/span&gt;                             &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 不阻塞全部任务&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;已有结果入队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExecutorCompletionService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Executors&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newSingleThreadExecutor&lt;/span&gt;()                           &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 为了用任务队列和生命周期管理&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newCachedThreadPool&lt;/span&gt;()                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 超时60s, max为MAX_VALUE, 任务不堆积场景&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newFixedThreadPool&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        newScheduledThreadPool()                            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; AbstractQueuedSynchronizer&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newWorkStealingPool&lt;/span&gt;()                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; ForkJoinPool, go的M,G,P&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 每个线程单独队列, 尾部偷加尾部&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;创建线程&#34;&gt;&#xA;  创建线程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 继承&#xA;class MyThread extendws Thread {&#xA;    @Override&#xA;    public void run(){}&#xA;}&#xA;new MyThread().start();&#xA;&#xA;# 组合&#xA;class MyRun implements Runnable {&#xA;    @Override&#xA;    public void run(){}&#xA;}&#xA;new Thread(new MyRun()).start();&#xA;&#xA;# 返回值&#xA;class myCall implements Callable&amp;lt;String&amp;gt; {&#xA;    @Override&#xA;    public String call(){}&#xA;}&#xA;FutureTask = ft = new FutureTask&amp;lt;String&amp;gt;(new MyCall())&#xA;new Thread(ft).start();&#xA;ft.get();&#xA;&#xA;# 线程池&#xA;// execute无返回值&#xA;ExecutorService service = Executors.newCachedThreadPool()&#xA;service.execute(()-&amp;gt;{});&#xA;// submit有返回值 &#xA;Future&amp;lt;String&amp;gt; f = service.submit(new MyCall());&#xA;service.shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程状态&#34;&gt;&#xA;  线程状态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;NEW&#xA;RUNNABLE            # 可调度&#xA;    READY&#xA;    RUNNING&#xA;WAITING             # 等待唤醒，忙等待(一直占CPU)&#xA;    o.wait()&#xA;    t.join()&#xA;    LockSupport.park()&#xA;    Lock.lock()&#xA;&#xA;    o.notify()&#xA;    o.notifyAll()&#xA;    LockSupport.unpark()&#xA;    Lock.unlock()&#xA;TIMED WAITING&#xA;    Thread.sleep(time)&#xA;    o.wait(time)&#xA;    t.join(time)&#xA;    LockSupport.parkNanos()&#xA;    LockSupport.parkUntil()&#xA;BLOCKING            # 阻塞等待（不占CPU但经过OS调度)&#xA;    synchronized&#xA;TERMINATED&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程打断&#34;&gt;&#xA;  线程打断&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%89%93%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法 &#xA;    interrupt()                 # 设置打断标记位&#xA;    isInterrupted()             # 检查标记位&#xA;    static interrupted()        # 检查当前线程标记位，并重置&#xA;检测当前线程打断标记的方法      # 抛异常并重置&#xA;    Thread.sleep()&#xA;    o.wait();&#xA;    o.join();&#xA;    ReentrantLock&#xA;        lockInterruptibly()&#xA;不检测当前线程打断标记的方法&#xA;    synchronized                # 不是代码实现检测不了&#xA;    ReentrantLock&#xA;        lock()&#xA;强制打断&#xA;    Thread&#xA;        stop()                  # 已废弃, 立即释放所有锁&#xA;        suspend()               # 已废弃，强制暂停，所有锁不释放容易死锁&#xA;        resume()                # 已废弃，强制恢复&#xA;volatile&#xA;    判断数字不准，有同步的时间延迟, interrupt()也有延迟&#xA;    也需要代码中判断, 但interrupt()有wait()等系统方法支持&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程间通信&#34;&gt;&#xA;  线程间通信&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;通知&#34;&gt;&#xA;  通知&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%9a%e7%9f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# synchronized wait() notify(), CountDownLatch, LockSupport&#xA;volatile List c = new ArrayList();&#xA;final Object lock = new Object();&#xA;new Thread(() -&amp;gt; {&#xA;    synchronized(lock) {&#xA;        if (c.size() != 5) {&#xA;            lock.wait();&#xA;        }&#xA;        lock.notify();              // 唤醒t1&#xA;    }&#xA;}, &amp;quot;t2&amp;quot;).start();&#xA;&#xA;TimeUnit.SECONDS.sleep(1);&#xA;&#xA;new Thread(() -&amp;gt; {&#xA;    synchronized(lock) {&#xA;        for (int i = 0; i &amp;lt; 10; i++) {&#xA;            c.add(new Object());&#xA;            if (c.size() == 5) {&#xA;                lock.notify();&#xA;                lock.wait();        // 让出sychronized锁&#xA;            }&#xA;        }&#xA;    }&#xA;}, &amp;quot;t1&amp;quot;).start();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;生产消费&#34;&gt;&#xA;  生产消费&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e4%ba%a7%e6%b6%88%e8%b4%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 优化count可以用CAS加(有ABA问题)&#xA;class MyContainer&amp;lt;T&amp;gt; {&#xA;    final private List&amp;lt;T&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&#xA;    final private int MAX = 10;&#xA;    private int count = 0;&#xA;&#xA;    public synchronized void put(T t) {&#xA;        while(list.size() == MAX) {&#xA;            this.wait();            // 期间可能有add() &#xA;        }&#xA;        list.add(t);&#xA;        count++;&#xA;        this.notifyAll();           // 应该只唤醒消费者&#xA;    }&#xA;&#xA;    public synchronized T get() {&#xA;        T t = null;&#xA;        while(list.size() == 0) {&#xA;            this.wait();&#xA;        }&#xA;        t = list.removeFirst();&#xA;        count--;&#xA;        this.notifyAll();           // 应该只唤醒生产者&#xA;        return t;&#xA;    }&#xA;}&#xA;&#xA;# 同步容器, ReentrantLock Condition&#xA;private Lock lock = new ReentrantLock();&#xA;private Condition producer = lock.newCondition();&#xA;private Condition consumer = lock.newCondition();&#xA;&#xA;public void put(T t) {&#xA;    try {&#xA;        lock.lock();&#xA;        while(list.size() == MAX) {&#xA;            producer.await();&#xA;        }&#xA;        list.add(t);&#xA;        count++;&#xA;        consumer.signalAll();&#xA;    } finally {&#xA;        lock.unlock();&#xA;    }&#xA;}&#xA;&#xA;public T get() {&#xA;    T t = null;&#xA;    try {&#xA;        lock.lock();&#xA;        while(list.size() == 0) {&#xA;            consumer.await();&#xA;        }&#xA;        t = list.removeFirst();&#xA;        count--;&#xA;        producer.signalAll();&#xA;    } finally {&#xA;        lock.unlock();&#xA;    }&#xA;    return t;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;协程&#34;&gt;&#xA;  协程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%8f%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;quasar库                            # 需要设javaagent, 每个fiber生成栈&#xA;    fiber =  new Fiber&amp;lt;Void&amp;gt;()&#xA;    fiber.start()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发api&#34;&gt;&#xA;  并发API&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;stream&#34;&gt;&#xA;  Stream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;parallelStream()                    # ForkJoinPool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;threadlocal&#34;&gt;&#xA;  ThreadLocal&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;内部类&#xA;    ThreadLocalMap&amp;lt;ThreadLocal, Object&amp;gt;&#xA;        # 存在每个线程里。场景如声明式事务拿conn&#xA;        # key是弱引用指向ThreadLocal, value是强引用。&#xA;    Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {&#xA;        Object value;&#xA;        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&#xA;            super(k);&#xA;            value = v;&#xA;        }&#xA;    }&#xA;方法&#xA;    set(T)&#xA;内存泄露问题&#xA;    ThreadLocal&amp;lt;M&amp;gt; tl = new ThreadLocal();&#xA;    tl.set(new M());&#xA;    tl = null;&#xA;        # threadLocalMap中key弱引用回收, value不回收&#xA;    tl.remove();&#xA;        # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pipedstream&#34;&gt;&#xA;  PipedStream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pipedstream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 效率不高&#xA;PipedInputStream&#xA;    connect(PipedOutputStream)&#xA;    read(byte[])&#xA;PipedOutputStream&#xA;    write(byte[])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jmh&#34;&gt;&#xA;  JMH&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmh&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Java Microbenchmark Harness&#xA;概念&#xA;    Warmup                              # 预热&#xA;    Mesurement                          # 总执行次数&#xA;    Timeout                             # 每次执行超时时间&#xA;    Threads                             # fork线程数&#xA;    Benchmark mode                      # 模式&#xA;    Benchmark                           # 方法名&#xA;环境变量&#xA;    TEMP或TMP                           # JHM临时文件存放&#xA;使用&#xA;    @Benchmark&#xA;    @Warmup(iterations = 2, time = 3)           # 执行2次, 每次隔3秒&#xA;    @Fork(5)                                    # 多少线程&#xA;    @BenchmarkMode(Mode.Throughput)             # 显示每秒多少次&#xA;    @Measurement(iterations = 10, time = 3)     # 共测10次, 每次隔3秒&#xA;    public void testA() {&#xA;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;disruptor&#34;&gt;&#xA;  Disruptor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#disruptor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    CAS, 环形数组Buffer&#xA;        数组用sequence定位修改快,也避免了头尾加锁&#xA;        直接覆盖降低GC&#xA;            覆盖前有等待策略&#xA;    单机MQ&#xA;        发布订阅模式&#xA;        观察者模式&#xA;    EventFactory&#xA;        会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC&#xA;使用&#xA;    class MyEvent {}&#xA;    class MyEventFactory implements EventFactory&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        public MyEvent newInstance() {}&#xA;    }&#xA;    class MyEventHandler implements EventHandler&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        void onEvent(MyEvent, long sequence, boolean endOfBatch) {}&#xA;    }&#xA;    class MyExceptionHandler implements ExceptionHandler&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        void handleEventException()&#xA;        @Override&#xA;        void handleOnStartException()&#xA;        @Override&#xA;        void handleOnShutdownException()&#xA;    }&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(factory, 1024, Executors,defaultThreadFactory())&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(MyEvent::new, 1024, Executors,defaultThreadFactory())&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(factory, 1024, Executors,defaultThreadFactory(), &#xA;        ProducerType.SINGLE, new BlockingWaitStrategy())&#xA;        # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁&#xA;    // 消费&#xA;    disruptor.handleEventsWith(handler1, handler2)&#xA;    disruptor.handleEventsWith((event,seq,end)-&amp;gt;{})&#xA;    disruptor.handleExceptionsFor(handler1).with(excptionHandler1)&#xA;&#xA;    disruptor.start()&#xA;&#xA;    // 生产&#xA;    ringBuffer = disruptor.getRingBuffer()&#xA;    sequence = ringBuffer.next()&#xA;    event = ringBuffer.get(sequence)&#xA;    event.set(&amp;quot;&amp;quot;)&#xA;    ringBuffer.publish(sequence)&#xA;    translator = new EventTranslator&amp;lt;&amp;gt;() {&#xA;        @Override&#xA;        void translateTo(event, sequence) {&#xA;            event.set(&amp;quot;&amp;quot;)&#xA;        }&#xA;    }&#xA;    ringBuffer.publishEvent(translator)&#xA;    ringBuffer.publishEvent((event,seq, &amp;quot;&amp;quot;) -&amp;gt; event.set(l), &amp;quot;&amp;quot;)&#xA;等待策略&#xA;    BlockingWaitStrategy                # 阻塞直到再次唤醒&#xA;    BusySpinWaitStrategy                # 自旋等待&#xA;    SleepingWaitStrategy                # sleep等待&#xA;    LiteBlockingWaitStrategy            # 同BlockingWaitStrategy减少加锁次数                &#xA;    LiteTimeoutBlockingWaitStrategy     # 同LiteBlockingWaitStrategy加超时            &#xA;    PhasedBackoffWaitStrategy&#xA;    TimeoutBlockingWaitStrategy         # 同BlockingWaitStrategy加超时                &#xA;    YieldingWaitStrategy                # 尝试100然后Thread.yield()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;源码分析&#34;&gt;&#xA;  源码分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;threadpoolexecutor&#34;&gt;&#xA;  ThreadPoolExecutor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadpoolexecutor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;new ThreadPoolExecutor()                    &#xA;    int corePoolSize                    # 核心线程数, 永远存活。可设置参与回收&#xA;    int maximumPoolSize                 # 最大线程数&#xA;    long keepAliveTime                  # 生存时间&#xA;    TimeUnit&#xA;    BlockingQueue&amp;lt;Runnable&amp;gt;             # 任务队列&#xA;    ThreadFactory                       # 线程工厂, 设线程名&#xA;    RejectedExecutionHandler            # 拒绝策略&#xA;        Abort                           # 抛异常&#xA;        Discard                         # 忽略掉&#xA;        DiscardOldest                   # 忽略掉排除最久的&#xA;        CallerRuns                      # 调用者线程执行, 再多就阻塞&#xA;AtomicInteger ctl&#xA;    # 高3位线程池状态，低29位线程数量&#xA;void execute()&#xA;    判断添加核心线程&#xA;    放入队列成功&#xA;        拒绝或添加非核心线程&#xA;    添加非核心线程失败&#xA;        拒绝&#xA;boolean addWorker(Runable, boolean)&#xA;    线程数量加1&#xA;    添加Worker&#xA;        加锁&#xA;        加线程&#xA;        启动&#xA;class Worker extends AbstractQueuedSynchronizer implements Runnable&#xA;    # 本身是AQS锁, 被多任务(线程)访问&#xA;    Tread thread&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;forkjoinpool&#34;&gt;&#xA;  ForkJoinPool&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#forkjoinpool&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;abstract class ForkJoinTask&#xA;    ForkJoinTask&amp;lt;V&amp;gt; fork()&#xA;    V join()&#xA;    abstract class RecursiveAction          # 无返回值&#xA;        void compute()&#xA;    abstract class RecursiveTask            # 有返回值&#xA;例子&#xA;    class MyTask extends RecursiveTask&amp;lt;Long&amp;gt; {&#xA;        int start;&#xA;        int end;&#xA;        @Override&#xA;        Long compute() {&#xA;            if (end - start &amp;lt;= MAX_NUM) {&#xA;                return sum&#xA;            }&#xA;            subTask1 = new MyTask(start, mid)&#xA;            subTask2 = new MyTask(mid, end)&#xA;            subTask1.fork()&#xA;            subTask2.fork()&#xA;            return subTask1.join() + subTask2.join();&#xA;        }&#xA;    }&#xA;    fjp = new ForkJoinPool()&#xA;    task = new MyTask(0, nums.length)&#xA;    fjp .execute(task)&#xA;    result = task.join()&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>JVM</title>
      <link>https://ukeate.com/docs/pl/java/jvm/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/java/jvm/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;定义&#xA;    JVM规范说明书, JVMS(Java Virtual Machine Specifications)&#xA;    Java语言规范, JLS(Java Language Specification)&#xA;    虚拟机&#xA;        指令集&#xA;        内存管理&#xA;过程&#xA;    x.java -&amp;gt; javac -&amp;gt; x.class -&amp;gt; ClassLoader -&amp;gt; (字节码解释器、JIT) -&amp;gt; 执行引擎&#xA;JVM语言&#xA;    Scala, Kotlin, Groovy, Clojure, jython, jruby等100多个&#xA;JVM实现&#xA;    HotSpot                 # Oracle官方, 8之后收费, OpenJDK为开源版本&#xA;    Jrockit                 # Oracle收购, 合并入HotSpot&#xA;    J9                      # IBM&#xA;    Microsoft VM&#xA;    TaobaoVM                # HotSpot深度定制&#xA;    LiquidVM                # 直接匹配专门硬件&#xA;    azul zing               # 收费，快, GC1mm, HotSpot参考写的G1&#xA;JRE, JDK&#xA;    JRE = jvm + core lib&#xA;    JDK = JRE + development kit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jvm构造&#34;&gt;&#xA;  JVM构造&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm%e6%9e%84%e9%80%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;指标&#34;&gt;&#xA;  指标&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e6%a0%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;吞吐量: 代码时间 / (代码时间 + GC时间)&#xA;响应时间: STW越短, 响应时间越好&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;指令instructions&#34;&gt;&#xA;  指令(Instructions)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e4%bb%a4instructions&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    基于栈的指令类          # 简单, HotSpot&#xA;    基于寄存器的指令集      # 复杂但快, HotSpot局部变量表&#xA;8大原子操作(JSR-133已放弃这个描述，但指令没变化)&#xA;    lock                    # 主内存，标识变量线程独占&#xA;    unlock                  # 主内存，解锁独占&#xA;    read                    # 主内存，读到工作内存&#xA;    load                    # 工作内存，read后的值放入线程本地变量副本&#xA;    use                     # 工作内存，传值给执行引擎&#xA;    assign                  # 工作内存，执行引擎结果赋值给线程本地变量 &#xA;    store                   # 工作内存，存值到主内存给write备用&#xA;    write                   # 主内存，写变量值&#xA;方法指令                    # 在methods的Code中罗列&#xA;    aload_0                 # 变量表第0项入栈&#xA;    invokespecial #1        # 调private(无多态)的方法&#xA;    invokevirtual           # 调有多态可能性的方法&#xA;    invokestatic            # 调静态方法&#xA;    invokeinterface         # 调interface方法&#xA;    invokedynamic           # 1.7加入，定义类似函数指针时生成(但每个函数都创建了类)&#xA;        调用动态产生的类&#xA;            lambda&#xA;            反射&#xA;            scala等JVM语言&#xA;            CGLib ASM&#xA;        组成&#xA;            bootstrapMethod&#xA;            方法签名&#xA;        &amp;lt;1.8的bug           # 类产生于Perm Space，内存不回收&#xA;            for(;;) {I j = C::n;}&#xA;    return                  # 方法返回&#xA;    bipush 8                # byte扩展成int类型，放到方法栈中&#xA;    sipush 200              # short&#xA;    istore_1                # 出栈，放到下标为1的局部变量表&#xA;    iload_1                 # 局部变量表下标1位置值压栈&#xA;    iinc 1 by 1             # 局部变量表1位置值+1&#xA;    iadd                    # 出栈两个，相加压栈&#xA;    new                     # new对象, 地址压栈&#xA;    dup                     # 复制栈顶并压栈&#xA;    pop                     # 弹出栈顶&#xA;    if_icmpne 7             # int值比较，不等时跳到第7条指令&#xA;    mul                     # 乘法&#xA;    sub                     # 减法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;class结构&#34;&gt;&#xA;  class结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#class%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;javap -v a.class&#xA;jetbrain jclasslib&#xA;jetbrain BinEd&#xA;JBE                         # 可编辑&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;二进制&#34;&gt;&#xA;  二进制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Magic Number(4字节)&#xA;    cafe babe&#xA;Minor Version(2字节)        # 小版本&#xA;Major Version(2字节)        # 大版本&#xA;    JDK1.7是51.0&#xA;    JDK1.8是52.0&#xA;constant_pool_count(2字节)&#xA;    # 长度constant_pool_count-1的表&#xA;constant_pool               # 索引、tag、类型&#xA;    1 CONSTANT_Utf8_info                        # 存一些描述字符串&#xA;    2 标记&#xA;    3 CONSTANT_Integer_info&#xA;    4 CONSTANT_Float_info&#xA;    5 CONSTANT_Long_info&#xA;    6 CONSTANT_Double_info&#xA;    7 CONSTANT_Class_info&#xA;    8 CONSTANT_String_info&#xA;    9 CONSTANT_Fieldref_info                &#xA;    10 CONSTANT_Methodref_info                  # 方法引用&#xA;        指向CONSTANT_Class_info&#xA;        指向CONSTANT_NameAndType_info&#xA;    11 CONSTANT_InterfaceMethodref_info&#xA;    12 CONSTANT_NameAndType_info                # 方法名与类型&#xA;    15 CONSTANT_MethodHandle_info&#xA;    16 CONSTANT_MethodType_info&#xA;    18 CONSTANT_InvokeDynamic_info&#xA;access_flags(2字节)         # bitmap按位与组合&#xA;    # class的修饰符&#xA;    ACC_PUBLIC 0x0001 public&#xA;    ACC_FINAL 0x0010 final&#xA;    ACC_SUPER 0x0020 JDK1.0.2之后必须为真, 表示invokespectial用新语义&#xA;    ACC_INTERFACE 0x0200 是否接口&#xA;    ACC_ABSTRACT 0x0400 抽象类&#xA;    ACC_SYNTHETIC 0x1000 编译器自动生成&#xA;    ACC_ANNOTATION 0x2000 &#xA;    ACC_ENUM 0x2000 &#xA;this_class(2字节)&#xA;    存名字对应指向常量池序号&#xA;super_class(2字节)&#xA;    存名字对应指向常量池序号&#xA;interfaces_count(2字节)&#xA;interfaces&#xA;fields_count(2字节)&#xA;fields&#xA;    access_flags(2字节)&#xA;    name_index              # 存常量池索引&#xA;    descriptor_index&#xA;        byte B&#xA;        char C&#xA;        double D&#xA;        float F&#xA;        int I&#xA;        long L&#xA;        short S&#xA;        boolean Z&#xA;        void V&#xA;        Object Ljava/lang/Object&#xA;        数组&#xA;            一维数组 [B&#xA;            多维数组 [[C&#xA;    attributes_count        # 赋加属性&#xA;    attributes&#xA;methods_count(2字节)&#xA;methods&#xA;    access_flags(2字节)&#xA;    name_index&#xA;    descriptor_index        # 先参数列表，后返回值&#xA;        void m() -&amp;gt; ()V&#xA;        String toString() -&amp;gt; Ljava/lang/String;&#xA;    attributes_count&#xA;    attributes              # 赋加属性&#xA;        Code                # 指令列表, 一般先压栈this(aload_0)&#xA;            LineNumberTable&#xA;            LocalVariableTable&#xA;attributes_count(2字节)&#xA;attributes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;agent&#34;&gt;&#xA;  Agent&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#agent&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;例子&#xA;    打包 a.jar&#xA;        MANIFEST.MF&#xA;            Premain_Class: MyAgent&#xA;        public class MyAgent {&#xA;            public static Instrumentation inst;&#xA;            public static void premain(String agentArgs, Instrumentation _inst) {&#xA;                inst = _inst;&#xA;            } &#xA;        }&#xA;    JVM参数 -javaagent: a.jar&#xA;    使用 MyAgent.inst&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jmmjava-memory-model&#34;&gt;&#xA;  JMM(Java Memory Model)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmmjava-memory-model&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;运行时区域&#34;&gt;&#xA;  运行时区域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8c%ba%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Runtime data areas&#xA;分类&#xA;    Program Counter             # 程序计数器，下一条指令位置&#xA;    Method Area                 # 方法区,线程间共享&#xA;        存储&#xA;            Class元信息&#xA;            代码编译信息, JIT编译信息&#xA;            常量池(Runtime Constant Pool)           # 常量池在运行时存放区&#xA;        版本区别&#xA;            Perm Space(&amp;lt;1.8)    # 要设定大小, 会溢出报错&#xA;                存字符串常量&#xA;                lambda生成临时类永远存在&#xA;                Full GC不清理&#xA;            Meta Space(&amp;gt;=1.8)   # 自动大小无上限&#xA;                字符串常量位于堆&#xA;                会触发Full GC&#xA;    JVM stacks                  # 线程栈 &#xA;        Frame(栈帧)             # 一个方法一个栈帧&#xA;            Local Variable Table                # 局部变量表, 方法内的局部变量，值在常量池&#xA;                默认第0个为this&#xA;            Operand Stack                       # 操作数栈&#xA;            Dynamic Linking                     # 指向调用方法的 运行时常量池的符号连接&#xA;            return address                      # 当前方法执行完的返回地址&#xA;    Native Method Stacks        # C/C++方法栈&#xA;    Direct Memory               # 直接内存&#xA;    Heap                        # 堆, 线程间共享&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;屏障&#34;&gt;&#xA;  屏障&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%8f%e9%9a%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;CPU屏障&#xA;JVM规范&#xA;    LoadLoad                # 上load和下load不能重排&#xA;    StoreStore&#xA;    LoadStore&#xA;    StoreLoad               # 最强&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;对象内存存储&#34;&gt;&#xA;  对象内存存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%86%85%e5%ad%98%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;普通对象&#xA;    对象头: markword 8字节&#xA;    ClassPointer            # 指向Class对象, 启用压缩4字节，不启用8字节&#xA;    实例数据&#xA;        引用类型            # 启用压缩4字节，不启用8字节&#xA;    Padding: 对齐8的倍数&#xA;数组对象&#xA;    对象头&#xA;    ClassPointer&#xA;    数组长度4字节&#xA;    数组数据&#xA;    Padding&#xA;对象头&#xA;    # 32位64位(25位没用到)，内容不同&#xA;    锁标志位2位             # 根据锁标志位判断存储内容&#xA;        01 无锁/偏向锁&#xA;        00 轻量级锁&#xA;        10 重量级锁&#xA;        11 GC标记&#xA;    是否偏向锁1位&#xA;    剩余位 &#xA;        无锁状态&#xA;            对象hashCode(25位或31位)&#xA;                没重写过时默认计算(System.identityHashCode())&#xA;                重写过的hashCode()结果不存在这里&#xA;            分代年龄&#xA;        轻量级锁&#xA;            指向栈中锁记录的指针&#xA;        重量级锁&#xA;            指向互斥量（重量级锁）的指针&#xA;        偏向锁&#xA;            线程ID 23位&#xA;            Epoch 2位&#xA;            分代年龄4位(所以分代年龄只有15)&#xA;    其它问题&#xA;        对象计算过hashCode，对象不能进入偏向锁状态(位已经被占了)&#xA;实验工具 javaagent&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;对象定位&#34;&gt;&#xA;  对象定位&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%ae%9a%e4%bd%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;句柄池                      # 指向句柄，句柄有对象指针和class指针, 三色标记GC提高效率&#xA;直接指针                    # 指向对象，对象指class, HotSpot使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;并发&#34;&gt;&#xA;  并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;硬件层数据一致性&#34;&gt;&#xA;  硬件层数据一致性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a1%ac%e4%bb%b6%e5%b1%82%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;硬件结构&#xA;    L0寄存器                # 1 cycles&#xA;    L1高速缓存              # 3-4 cycles, 1ns&#xA;    L2高速缓存              # 10 cycles, 3ns&#xA;    L3高速缓存              # 40-45 cycles, 15ns, 在主板&#xA;    (QPI总线传输)           # 20ns&#xA;    L4主存                  # 60-80ns&#xA;    L5磁盘&#xA;    L6远程文件存储&#xA;数据不一致                  # 从L2多CPU开始&#xA;    锁总线(bus lock)&#xA;    CPU缓存一致性协议(如intel MESI)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;volatile&#34;&gt;&#xA;  volatile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#volatile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;工具&#xA;    hsdis                   # HotSpot Dis Assembler, 虚拟机字节码对应汇编&#xA;bytecode&#xA;    ACC_VOLATILE&#xA;JVM&#xA;    StoreStoreBarrier&#xA;    volatile写操作          # 上边写完再写，写完下边再读，写一致&#xA;    StoreLoadBarrier&#xA;&#xA;    LoadLoadBarrier&#xA;    volatile读操作          # 上边读完再读，读完下边再写，读一致&#xA;    LoadStoreBarrier&#xA;OS&#xA;    windows&#xA;        lock&#xA;    linux&#xA;        上下屏障，最后lock&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;synchronized&#34;&gt;&#xA;  synchronized&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;bytecode&#xA;    方法修饰&#xA;        synchronized&#xA;    代码&#xA;        monitorenter&#xA;        monitorexit&#xA;JVM&#xA;    C/C++实现，会调用OS的同步机制&#xA;OS&#xA;    lock&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;happens-before原则&#34;&gt;&#xA;  happens-before原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#happens-before%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Java要求指令不能重排的几种情况&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;as-if-serial&#34;&gt;&#xA;  as if serial&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#as-if-serial&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 不管如何重排序，单线程执行结果不变&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;过程&#34;&gt;&#xA;  过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;编译&#34;&gt;&#xA;  编译&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%af%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;过程&#xA;    代码 -&amp;gt; bytecode -&amp;gt; JVM指令 -&amp;gt; OS指令&#xA;解释器(bytecode intepreter)&#xA;JIT(Just In-Time compiler)&#xA;混合模式&#xA;    解释器 + 热点代码编译&#xA;    热点代码检测&#xA;        方法计数器&#xA;        循环计数器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;加载&#34;&gt;&#xA;  加载&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a0%e8%bd%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;HotSpot C++代码加载&#xA;    class对象加载到MethodArea&#xA;        metaspace(JDK1.8)&#xA;        permGeneration(JDK1.8之前)&#xA;class加载过程&#xA;    loading                 # 读到内存&#xA;    linking&#xA;        verification        # 校验&#xA;        preparation         # 静态变量赋默认值&#xA;        resolution          # 解析, loadClass()可指定是否解析。常量池的符号引用转换成内存地址引用&#xA;    initializing            # 静态变量赋初始值，执行静态代码&#xA;对象加载&#xA;    new过程&#xA;        class加载&#xA;        申请对象内存&#xA;        成员变量赋默认值&#xA;        调用构造方法&amp;lt;init&amp;gt;&#xA;            成员变量顺序赋初始值&#xA;            执行构造方法语句(先super)&#xA;双亲委派                &#xA;    过程&#xA;        类名一层层向上找&#xA;        找不到时，一层层找再向下委派找&#xA;        都不能加载时, 抛ClassNotFound&#xA;    为什么&#xA;        安全, 自定义类不能覆盖&#xA;        已加载不用重复加载&#xA;    父加载器&#xA;        不是类加载器的加载器&#xA;        不是父类&#xA;        是组合的parent对象&#xA;    打破&#xA;        为什么                    &#xA;            JDK1.2之前都重写loadClass()&#xA;            thread.setContextClassLoader()指定线程上下文classLoader&#xA;            热启动/热部署(OSGi tomcat)加载同一类不同版本&#xA;        做法&#xA;            重写loadClass(), new多个ClassLoader&#xA;类加载器&#xA;    Bootstrap               # 加载核心类 lib/rt.jar charset.jar等, C++实现所以get时为null&#xA;        如加载String&#xA;    Extension               # 加载扩展jar jre/lib/ext/*.jar, 由-Djava.ext.dirs指定&#xA;    App                     # 加载classpatch指定内容&#xA;    Custom ClassLoader      # 自定义ClassLoader&#xA;加载路径环境变量            # 来自Launcher源码&#xA;    Bootstrap.ClassLoader   sun.boot.class.path&#xA;    ExtensionClassLoader    java.ext.dirs&#xA;    AppClassLoader          java.class.path&#xA;API&#xA;    Class&#xA;        getClassLoader()&#xA;    ClassLoader             # findInCache() -&amp;gt; parent.loadClass() -&amp;gt; findClass()&#xA;        private final ClassLoader parent&#xA;        loadClass           # 热加载&#xA;    Launcher&#xA;        $AppClassLoader&#xA;        $ExtClassLoader&#xA;自定义类加载器&#xA;    class MyClassLoader extends ClassLoader {&#xA;        @Override&#xA;        Class findClass(String) {&#xA;            return defineClass()&#xA;        }&#xA;    }&#xA;懒加载                      # JVM未规定什么时候加载,但规定了什么时候初始化&#xA;初始化&#xA;    new getstatic putstatic invokestatic指令，访问final变量除外&#xA;    java.lang.reflect对类进行反射调用&#xA;    初始化子类时，父类首先初始化&#xA;    虚拟机启动时，被执行的主类&#xA;    动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic, REF_putstatic, REF_invokestatic的方法句柄时, 该类初始化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gc&#34;&gt;&#xA;  GC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引用方式强软弱虚&#34;&gt;&#xA;  引用方式(强软弱虚)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e7%94%a8%e6%96%b9%e5%bc%8f%e5%bc%ba%e8%bd%af%e5%bc%b1%e8%99%9a&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;软引用&#xA;    # 内存不够用时回收，用做缓存&#xA;    # -Xms20M -Xmx20M&#xA;    SoftReference&amp;lt;byte[]&amp;gt; m = new SoftReference&amp;lt;&amp;gt;(new byte[1024*1024*10]);&#xA;    System.gc();&#xA;    m.get();&#xA;    new byte[1024*1024*15]&#xA;    m.get();&#xA;弱引用&#xA;    # 只要gc就回收，用做容器如WeakHashMap(key是弱引用), ThreadLocalMap的key&#xA;    WeakReference&amp;lt;M&amp;gt; m = new WeakReference&amp;lt;&amp;gt;(new M());&#xA;    System.gc();&#xA;    m.get();&#xA;虚引用&#xA;    # 值被回收时放入队列来通知, 用来触发回收堆外内存(用Unsafe的freeMemory())&#xA;    # 如NIO的直接内存DirectByteBuffer&#xA;    PhantomReference&amp;lt;M&amp;gt; r = new PhantomReference&amp;lt;&amp;gt;(new M(), QUEUE);&#xA;    r.get() // 自己写永远返回null                     &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;对象分配过程&#34;&gt;&#xA;  对象分配过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;向栈分配                # 不要调参数&#xA;    好处&#xA;        不必GC&#xA;    条件&#xA;        线程私有小对象&#xA;        无逃逸&#xA;        可标量替换(基本类型替换整个对象)&#xA;过大，分配到老年代&#xA;线程本地分配            # TLAB(Thread Local Allocation Buffer), 不要调参数&#xA;    好处&#xA;        为了减少线程争用&#xA;    条件&#xA;        小对象&#xA;        占用eden, 默认每个线程占1%&#xA;伊甸区&#xA;s1,s2&#xA;    次数                   # 最大15(对象头上空间决定)&#xA;        Parallel Scavenge 15&#xA;        CMS 6&#xA;        G1 15&#xA;    动态年龄&#xA;        eden + s1 复制到s2, 超过s2总内存一半时，年龄最大的对象进入老年代&#xA;    分配担保&#xA;        YGC时survivor区空间不够, 直接进入老年代&#xA;GC清除或到老年代&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;gc分代过程&#34;&gt;&#xA;  GC分代过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gc%e5%88%86%e4%bb%a3%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;YGC -&amp;gt; s0&#xA;YGC, eden + s0 -&amp;gt; s1&#xA;    年龄足够 -&amp;gt; old&#xA;    s区装不下 -&amp;gt; old&#xA;YGC, eden + s1 -&amp;gt; s0&#xA;old满了 -&amp;gt; FGC&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;常见的回收器&#34;&gt;&#xA;  常见的回收器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%9b%9e%e6%94%b6%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    Safe Point              # STW时机&#xA;    没有无STW的回收器&#xA;分代&#xA;    Young&#xA;        Serial              # 第一个GC&#xA;            STW, 单线程串行回收&#xA;        Parallel Scavenge&#xA;            STW, 并行回收&#xA;        ParNew              # Parallel New&#xA;            增强PS, 以配合CMS并行回收, CMS到某阶段时PN运行&#xA;    Old&#xA;        Serial Old&#xA;            特点&#xA;                适用几十M&#xA;                mark-sweep-compact，单线程&#xA;        Parallel Old&#xA;            特点&#xA;                适用几个G&#xA;                mark-sweep-compact，多线程&#xA;        CMS                 # concurrent mark sweep, 1.4后期引入, JDK11取消&#xA;            特点&#xA;                适用20G&#xA;                多线程并行回收, 并发回收(GC与程序同时运行)，降低STW时间(200ms)&#xA;            不足            # 问题多，没有版本默认CMS&#xA;                浮动垃圾&#xA;                碎片多，新对象分配不下时，使用SerialOld&#xA;                    设低GC阈值回收浮动垃圾&#xA;            清理过程&#xA;                初始标记(initial mark)&#xA;                    STW, 单线程, 标记根对象&#xA;                [预标记]                        # Card Marking, 把Card标为Dirty&#xA;                并发标记(concurrent mark)&#xA;                    不STW, 多线程, 执行多次&#xA;                重新标记(remark)                # 处理并发标记过程中的变化&#xA;                    STW, 多线程, &#xA;                并发清理(concurrent sweep)      # 过程中产生的浮动垃圾, 下次回收&#xA;                    不STW, 多线程, &#xA;                [整理阶段]&#xA;            日志&#xA;                [GC(Allocation Failure)[ParNew:6144K-&amp;gt;640K(6144K)], 0.02 secs] 6585K-&amp;gt;2770K(19840K),0.02 secs][Times:user=0.02 sys=0.00, real=0.02 secs]&#xA;                    6144K-&amp;gt;640K(6144K): 回收前 回收后 总容量&#xA;                    6585K-&amp;gt;2770K(19840K): 堆回收前 回收后 总大小  &#xA;&#xA;                [GC (CMS Initial Mark)]&#xA;                    [1 CMS-initail-mark]&#xA;                [CMS-concurrent-mark-start]&#xA;                [CMS-concurrent-preclean-start]&#xA;                [GC (CMS Final Remark)]&#xA;                    [YG occupancy]              # 清理后年轻代占用及容量&#xA;                    [Rescan(parallel)]          # STW下标记存活对象&#xA;                    [weak refs processing]      # 弱引用处理&#xA;                    [class unloading]           # 卸载用不到的class&#xA;                    [scrub symbol table]        # 清理常量池&#xA;                    [scrub string table]        # 清理常量池&#xA;                    [1 CMS-remark]              # 清理后老年代占用及容量&#xA;                [CMS-concurrent-sweep-start]&#xA;                [CMS-concurrent-reset-start]&#xA;&#xA;不分代&#xA;    G1                      # Garbage First, 1.7引入, 1.8完善, 1.9默认&#xA;        特点&#xA;            适用上百G&#xA;            STW 10ms回收&#xA;                容易预测STW时间&#xA;                低latency, 但throughput也低&#xA;            并发回收, 三色标记&#xA;            只逻辑分代, 不物理分代 &#xA;                内存分Region, Region组成不同大小块，块在逻辑分代中&#xA;                Eden和Old区的内存映射会变化&#xA;            动态新老代空间                      # 如果YGC频繁，就Young调大&#xA;                不要手工指定, 是G1预测YGC停顿时间的基准, 停顿时间通过参数设置&#xA;        概念&#xA;            CSet            # Collection Set&#xA;                可回收Region集合, 回收时存活的对象被移动&#xA;                占堆空间不到1%&#xA;            RSet            # Remembered Set&#xA;                用于找到谁引用当前对象(对象级别), 记录其他Region的引用&#xA;                赋值时有GC写屏障                # 非内存屏障&#xA;            CardTable       # YGC定位垃圾，要从Root查所有Old区对象，效率低&#xA;                Old区对象引用Young区时, bitmap标DirtyCard。YGC时只扫描DirtyCard&#xA;            MixedGC         # 默认45%, 同CMS&#xA;                初始标记&#xA;                重新标记&#xA;                筛选回收    # 筛选Region回收，有用对象复制到其它Region&#xA;        日志&#xA;            [GC pause (G1 Evacuation Pause) (young) (initial-mark)]         # 复制存活对象, initial-mark在MixedGC时有&#xA;            [GC concurrent-root-region-scan-start]                          # 混合回收&#xA;            [GC concurrent-mark-start]                                      # 混合回收&#xA;            [Full GC (Allocation Failure)]                                  # 无法evacuation时, G1中很严重&#xA;    ZGC                     # JDK11, 不分代(SingleGeneration)&#xA;        特点&#xA;            STW设计10ms, 实际1ms&#xA;            适用4T（JDK13 16T）&#xA;            内存分块（有大有小）&#xA;        概念&#xA;            没有RSet, 改进了SATB指针&#xA;    Shenandoah              # JDK11&#xA;    Epsilon                 # JDK11, debug用&#xA;    Zulu&#xA;组合&#xA;    S + SO&#xA;    PS + PO                 # 1.8默认, 10G内存10+秒&#xA;    PN + CMS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;算法&#34;&gt;&#xA;  算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;定位&#xA;    引用计数(ReferenceCount)&#xA;        循环引用问题        # 内部互相引用，没有外部引用&#xA;    根可达算法(RootSearching)&#xA;        线程栈变量 &#xA;        静态变量&#xA;        常量池&#xA;        JNI指针             # 本地方法用到的对象&#xA;并发标记&#xA;    三色标记&#xA;        白                  # 未被标记&#xA;        灰                  # 自身被遍历到，成员变量未被遍历到&#xA;        黑                  # 自身、成员变量都被遍历到&#xA;        漏标问题 &#xA;            两个必要条件 &#xA;                黑引用白后，灰对白的引用断开&#xA;            算法&#xA;                incremental update                      # 增量更新，关注引用的增加, CMS用的&#xA;                    增加引用后，标记为灰, 重新标记阶段再扫描&#xA;                    缺点是灰色还要重新扫描&#xA;                SATB snapshot at the beginning          # 关注引用的删除, G1用的&#xA;                    开始时快照, 引用消失时，引用推到堆栈, 下次扫描还扫白色对象&#xA;                    优点是只扫描修改过的对象, 看RSet中有没有引用&#xA;    颜色指针                # 信息记在指针里&#xA;    租户隔离, Session Base GC           # Web专用, 基于session, session断开后删除&#xA;    各GC应用&#xA;        CMS&#xA;            三色标记 + Incremental Update&#xA;        G1&#xA;            三色标记 + SATB&#xA;        ZGC&#xA;            颜色指针 + 写屏障&#xA;        Shenandoah&#xA;            颜色指针 + 读屏障&#xA;清除&#xA;    标记清除(Mark-Sweep)    # 一遍标记，一遍清理, 适合老年代&#xA;        算法简单，戚对象多时效率高&#xA;        两遍扫描效率低，容易产生碎片&#xA;    拷贝(Copying)           # 存活对象copy到新内存, 旧内存直接清理，适合伊甸区(新生代)&#xA;        适用存活对象少的情况&#xA;        内存减半&#xA;    标记压缩(Mark-Compact)  # 有用的填到前边去空隙去, 适合老年代&#xA;        不会碎片，不会内存减半&#xA;        扫描两次，还要移动&#xA;分代模型&#xA;    分代模型                # -Xms -Xmx设置大小&#xA;        new/young(新生代)   # MinorGC/YGC, -Xmn设置大小, 默认占比1&#xA;            eden(伊甸)      # 默认占比8&#xA;            survivor x 2    # 默认每个占比1&#xA;        old(老年代)         # MajorGC/FullGC, 1.8默认占比2, 之前是3&#xA;            tenured(终身)&#xA;        methodArea          # 1.7永久代, 1.8元数据区&#xA;    各JVM的分代模型&#xA;        Epsilon ZGC Shenandoah不是分代模型&#xA;        G1是逻辑分代，物理不分代&#xA;        其他都是逻辑分代 + 物理分代&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;调优tuning&#34;&gt;&#xA;  调优(Tuning)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b0%83%e4%bc%98tuning&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;前提&#xA;    从业务场景开始&#xA;    无监控(能压测), 不调优&#xA;目标&#xA;    减少FGC&#xA;    确定倾向                        # 吞吐量, 或响应时间&#xA;        吞吐量好: PS + PO&#xA;        响应时间好: G1 或 PN + CMS  # G1吞吐量少10%&#xA;组成部分&#xA;    JVM预规划&#xA;    优化JVM运行环境(慢、卡顿)&#xA;    解决JVM运行时出现的问题(OOM)&#xA;步骤&#xA;    熟悉业务场景&#xA;        响应时间&#xA;        吞吐量&#xA;    选择回收器组合&#xA;    计算内存需求(小的快，大的少gc)&#xA;    选CPU&#xA;    设定年代大小、升级年龄&#xA;    设定日志参数&#xA;    观察日志情况&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;问题分析&#34;&gt;&#xA;  问题分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工具-1&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;CPU经常100%&#xA;    top查进程CPU(top)&#xA;    进程中线程CPU(top -Hp)&#xA;    导出该线程堆栈(jstack)&#xA;    查哪个方法(栈帧)消耗时间(jstack)&#xA;内存高&#xA;    导出堆内存(jmap)&#xA;    分析(jhat jvisualvm mat jprofiler ...)&#xA;监控JVM&#xA;    jstat jvisualvm jprofiler arthas top ...&#xA;    网管: Ansible&#xA;流程&#xA;    网管报警&#xA;    top -Hp 进程号&#xA;    jstack 进程号               # 列出所有线程号, 线程状态&#xA;        WAITING, 一直等不到, BLOCKED, 拿不到锁&#xA;        waiting on &amp;lt;0x0000&amp;gt; (a java.lang.Object)    # 找到目标等待的线程&#xA;    jstack -l 16进制线程号      &#xA;    jps&#xA;    jinfo 进程号                # 列JVM信息&#xA;    jstat -gc 进程号 500        # 每500ms打印一次gc信息&#xA;    jmap -histo 进程号 | head -20                   # 列所有对象&#xA;        有性能消耗，但不很高，可以在线执行&#xA;    jmap -dump:format=b, file=x pid                 # 导出转储文件&#xA;        内存特别大时，jmap会卡顿&#xA;        多个服务器可用，停一个不影响&#xA;        设定HeapDumpOnOutOfMemoryError产生堆转储文件                 &#xA;        在线定位(中小型公司用不到)&#xA;    jhat -J-mx512M x.hprof      # 分析堆dump文件, 有OQL&#xA;    arthas                      # 在线定位&#xA;        启动&#xA;            java -jar arthas-boot.jar&#xA;        常用命令                # 没有集成jmap功能&#xA;            jvm                 # jinfo&#xA;            thread              # jstack&#xA;                thread 1&#xA;            dashboard           # top&#xA;            heapdump            # jmap -dump&#xA;            dump&#xA;            redefine            # 热替换&#xA;                目前只能改method实现，不能改方法名与属性&#xA;            jad                 # 反编译类&#xA;                看动态代理生成的类&#xA;                看第三方类&#xA;                看版本&#xA;            sc                  # search class, 显示class信息&#xA;            watch               # watch method&#xA;    MAT                         # 分析dump文件&#xA;    jprofiler&#xA;    jconsole                    # 需要JMX&#xA;        JMX会消耗性能生产服务器不开&#xA;        JMX图形界面只用于压测&#xA;    jvisualVM                   # 需要JMX, 可分析dump文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;内存-1&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;现象&#xA;    OOM崩溃&#xA;    CPU飙高, 不断FGC&#xA;线程池不当运用&#xA;加内存反而卡顿&#xA;    GC, 应该用CMS或G1替换 PS+PO&#xA;JIRA不停FGC, 没定位出来&#xA;    扩内存到50G, GC换G1, 重启&#xA;tomcat server.max-http-header-size过大&#xA;    默认4096, 每个请求都分配&#xA;lambda表达式导致方法区溢出&#xA;    java.lang.OutofMemoryError: Compressed class space&#xA;disruptor不释放缓存&#xA;使用Unsafe分配内存, 直接内存溢出&#xA;-Xss设定小, 栈溢出&#xA;重写finalize()引发GC&#xA;    finalize()耗时长, GC时回收不过来，不停GC&#xA;内存不到10%，频繁FGC&#xA;    有人显式调用System.gc()                         # 不定时调，但会频繁调&#xA;大量线程, native thread OOM&#xA;    减少堆空间，留更多系统内存产生native thread&#xA;G1产生FGC&#xA;    降低MixedGC触发的阈值       # 默认45%&#xA;    扩内存&#xA;    提高CPU                     # 回收快&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hotspot参数&#34;&gt;&#xA;  HotSpot参数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hotspot%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;辅助&#xA;    -XX:+PrintCommandLineFlags -version             # 打印启动参数, -version是随便一个命令&#xA;    -XX:+PrintFlagsFinal -version                   # 打印所有XX参数&#xA;    -XX:+PrintFlagsInitial      # 打印默认参数&#xA;    -XX:+PrintVMOptions         # 显示VM启动参数&#xA;    -                           # 标准参数&#xA;    -X                          # 显示非标参数&#xA;    -XX                         # 显示不稳定参数&#xA;内存&#xA;    -XX:+HeapDumpOnOutOfMemoryError                 # OOM时产生堆转储文件 &#xA;    -Xms40M                     # 堆起始大小&#xA;    -Xmx60M                     # 堆最大大小, 最好和Xms一样以免堆弹大弹小&#xA;    -Xmn                        # 年经代&#xA;    -Xss                        # 栈空间&#xA;    -XX:InitialHeapSize         # 起始堆大小，自动算&#xA;    -XX:MaxHeapSize             # 堆最大大小，自动算&#xA;内存模型&#xA;    -XX:-DoEscapeAnalysis       # 去逃逸分析&#xA;    -XX:-EliminateAllocations   # 去标量替换&#xA;    -XX:-UseTLAB                # 去tlab&#xA;    -XX:TLABSize                # 设置TLAB大小&#xA;    -XX:+PrintTLAB&#xA;    -XX:MaxTenuringThreshold    # 进老年代（升代）回收次数, 最大值15， CMS默认6，其它默认15&#xA;对象和类&#xA;    -XX:+UseCompressedClassPointers                 # class指针压缩&#xA;        开启时4字节，不开启时8字节&#xA;    -XX:+UseCompressedOops                          # 引用类型指针压缩, Ordinary Object Pointers&#xA;        开启为4字节，不开启时8字节&#xA;    -verbose:class              # 类加载详细过程&#xA;    -XX:PreBlockSpin            # 锁自旋次数&#xA;编译&#xA;    -Xmixed                     # 混合模式&#xA;    -Xint                       # 解释模式&#xA;    -Xcomp                      # 编译模式&#xA;    -XX:CompileThreshold = 10000                    # 检测热点代码次数&#xA;GC&#xA;    -XX:+PrintGC                # 打印GC信息&#xA;    PrintGCDetails              # 打印GC更详细&#xA;    PrintGCTimeStamps           # 打印GC时间&#xA;    PrintGCCauses               # GC原因&#xA;    PrintHeapAtGC&#xA;    PrintGCApplicationConcurrentTime                # GC应用程序时间&#xA;    PrintCApplicationStoppedTime                    # 打印STW时长&#xA;    -XX:+PrintReferenceGC       # 打印回收多少种引用类型&#xA;    -XX:+UseConcMarkSweepGC     # 用CMS&#xA;    -XX:+DisableExplictGC       # System.gc()不管用&#xA;&#xA;    Parallel常用&#xA;        -XX:SurvivorRatio           # 新生代Eden区和Surivor区的比例&#xA;        -XX:PreTenureSizeThreshold  # 大对象到底多大&#xA;        -XX:+ParallelGCThreads      # 并发线程数, 默认是CPU数&#xA;        -XX:+UseAdaptiveSizePolicy  # 自动调所有区比例&#xA;    CMS常用&#xA;        -XX:ParallelCMSThreads      # 并发线程数，默认是CPU数一半&#xA;        -XX:CMSInitiatingOccupancyFraction 92%          # 老年代占多少时触发GC, 1.8 92%, 之前68%&#xA;            设小一点，清除浮动垃圾&#xA;            过大时，栈分配不下，Promotion Failure，触发FGC&#xA;        -XX:+UseCMSCompactAtFullCollection              # GC时压缩，避免碎片片&#xA;        -XX:CMSFullGCsBeforeCompaction                  # 多少次GC后压缩&#xA;        -XX:+CMSClassUnloadingEnabled                   # 回收方法区&#xA;        -XX:CMSInitiatingPermOccupancyFraction          # 到什么比例时进行Perm回收, 1.8之前&#xA;        GCTimeRatio                                     # GC占程序运行时间的百分比&#xA;        -XX:MaxGCPauseMillis                            # GC停顿时间, CMS会减少年轻代大小&#xA;    G1&#xA;        -XX:MaxGCPauseMillis                            # STW时间, 区别CMS, G1会调整Young区的块数&#xA;        GCTimeRatio&#xA;        -XX:GCPauseIntervalMillis                       # STW之间间隔时间&#xA;        -XX:+G1HeapRegionSize                           # Region大小, 1 2 4 8 16 32, 逐渐增大, GC间隔更长, 每次GC时间更长&#xA;            ZGC是动态调整的&#xA;        G1NewSizePercent                                # 新生代最小比例, 默认5%&#xA;        G1MaxNewSizePercent                             # 新生代最大比例，默认60%&#xA;        ConcGCThreads                                   # GC线程数&#xA;        InitiatingHeapOccupancyPercent                  # 启动GC的堆空间占用比例&#xA;&#xA;JMX监控&#xA;    -Djava.rmi.server.hostname=192.168.1.1&#xA;    -Dcom.sun.management.jmxremote &#xA;    -Dcom.sun.management.jmxremote.port=11111 &#xA;    -Dcom.sun.management.jmxremote.authenticate=false &#xA;    -Dcom.sun.management.jmxremote.ssl=false&#xA;调优                            # 参数越来越少&#xA;    JVM参数800个&#xA;    CMS参数300个&#xA;    G1参数100个&#xA;    ZGC更少&#xA;    Zing1个&#xA;GC组合参数&#xA;    -XX:+UseSerialGC&#xA;        S + SO&#xA;    -XX:+UseParNewGC                # 已废弃&#xA;        PN + SO&#xA;    -XX:+UseConc(urrent)MarkSweepGC&#xA;        PN + CMS + SO&#xA;    -XX:+UseParallelGC               # 1.8默认&#xA;        PS + PO&#xA;    -XX:+UseParallelOldGC&#xA;        PS + PO&#xA;    -XX:+UseG1GC&#xA;        G1&#xA;日志参数&#xA;    -Xloggc:/logs/xx-xx-%t.log&#xA;    -XX:+UseGCLogFileRotation           # 5个满了，覆盖第一个&#xA;    -XX:NumberOfGCLogFiles=5&#xA;    -XX:GCLogFileSize=1024M&#xA;    -XX:+PrintGCDetails&#xA;    -XX:+PrintGCDateStamps&#xA;    -XX:+PrintGCCause&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hotspot日志&#34;&gt;&#xA;  HotSpot日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hotspot%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;GC                          # PrintGCDetails&#xA;    [GC&#xA;        GC表示YGC, Full GC是FGC&#xA;    (Allocation Failure)&#xA;        原因&#xA;    [DefNew:4544k-&amp;gt;259k(6144k), 0.0873 secs]&#xA;        DefNew表示年轻代, 回收前后的大小, 6144是年轻代总大小，回收时间&#xA;    4544k-&amp;gt;4356k(19840k), 0.0812 secs]&#xA;        堆的前后大小, 19840是堆总空间, 回收时间&#xA;    [Times: user=0.01 sys=0.00, real=0.01 secs]&#xA;        linux time命令，用户态时间，内核态时间，总时间&#xA;异常退出dump堆&#xA;    def new generation total 6144k, used 5504k [0x00, 0x00, 0x00]&#xA;        新生代总共多少，用了多少。内存起始地址，使用空间结束地址，整体空间结束地址&#xA;        total = eden + 1个survivor&#xA;    eden space 5504k, 100% used []&#xA;        eden&#xA;    from space 640k, 0% used []&#xA;        s0&#xA;    to space 640, 0% used []&#xA;        s1&#xA;    tenured generation total 13696k, used 13312k []&#xA;        old&#xA;    the space 13696k, 97% used []&#xA;        old&#xA;    Metaspace used 2538k, capacity 4486k, committed 4864k, reserved 1056768k&#xA;        used真正使用的大小&#xA;        capacity目前指定的容量 &#xA;        committed 表示预先占用的大小&#xA;        reserved表示共保留的大小&#xA;    class space used 275k, capacity 386k, committed 512k, reserved 1048576k&#xA;        metaspace中存class的部分&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
