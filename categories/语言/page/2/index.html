<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://ukeate.com/categories/%E8%AF%AD%E8%A8%80/">
  <meta property="og:site_name" content="ukeate的笔记">
  <meta property="og:title" content="语言">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
<title>语言 | ukeate的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://ukeate.com/categories/%E8%AF%AD%E8%A8%80/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.0f6a4302fe56c30046fd4c5181451fa23f629020e991f9cf123032b5e26b06f9.js" integrity="sha256-D2pDAv5WwwBG/UxRgUUfoj9ikCDpkfnPEjAyteJrBvk=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="https://ukeate.com/categories/%E8%AF%AD%E8%A8%80/index.xml" title="ukeate的笔记" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span>ukeate的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/" class="">基本功</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/speach/" class="">演说</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/body/" class="">身体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/" class="">Computer</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/principle/" class="">支撑-原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/performance/" class="">Performance</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/" class="">算法</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/thought/" class="">算法思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/data_structure/" class="">数据结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/math/" class="">数学</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/" class="">架构</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/" class="">代码</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/security/" class="">Security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/design_mode/" class="">Java设计模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/" class="">工程设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/ddd/" class="">工程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/frontend/" class="">前端</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>战略性技术</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/" class="">AI</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/map/" class="">知识图谱</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/framework/" class="">Framework</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/media/" class="">媒体</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/middle_platform/" class="">中台</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/block_chain/" class="">Block Chain</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Cloud</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/" class="">Datalake</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/ecology/" class="">Ecology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/edge/" class="">Edge</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/" class="">Manage</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/" class="">组织</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/people/" class="">人员</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/" class="">Method</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/product_plan/" class="">产品规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/code_plan/" class="">代码规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/ops_plan/" class="">运维规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/advice_plan/" class="">咨询规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/architect/" class="">服务治理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/project_plan/" class="">项目规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/test_plan/" class="">测试规划</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/summary/" class="">这些年我做过的技术</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/" class="">程序语言</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/principle/" class="">程序语言原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/haskell/" class="">Haskell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/elixir/" class="">Elixir</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/clojure/" class="">Clojure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/js/" class="">JS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/java_reactive/" class="">Java响应式编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/javaweb/" class="">JavaWeb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/juc/" class="">Java并发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/jvm/" class="">JVM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/collection/" class="">Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/spring/" class="">Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/" class="">Markup Language</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/html/" class="">Html</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/css/" class="">Css</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/" class="">工具</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/" class="">运维</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/monitor/" class="">Monitor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/docker/" class="">Docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/k8s/" class="">Kubernetes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/enterprise_system/" class="">企业级系统</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/" class="">Develop</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/eclipse/" class="">Eclipse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/vim/" class="">VIM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/apple/" class="">Apple</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/jetbrains/" class="">Jetbrains</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/" class="">Linux</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_program/" class="">LinuxProgram</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/scene/" class="">LinuxScene</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_tool/" class="">LinuxTool</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/framework/" class="">Framework</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/physics/" class="">实物工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/" class="">测试</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/debug/" class="">程序调试</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/" class="">数据库</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mongodb/" class="">Mongodb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/postgresql/" class="">Postgre SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/oracle/" class="">Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/" class="">中间件</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/" class="">支撑-分布式</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/spring_cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/" class="">前端</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/bootstrap/" class="">Bootstrap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/threejs/" class="">Threejs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/angular/" class="">Angular</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/jquery/" class="">Jquery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/react/" class="">React</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/" class="">小功能</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/hibernate/" class="">Hibernate</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Container</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nginx/" class="">Nginx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nodejs/" class="">Nodejs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/" class="">Cache</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/ops/" class="">Ops</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/work_code/" class="">Work Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/template/" class="">模板配置</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/soft_arch/" class="">软考架构师</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/misc/" class="">杂项</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>语言</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  <nav>
  <ul>
  
    
    <li class="book-section-flat">
      <strong>Categories</strong>
      <ul>
      
        <li class="flex justify-between">
          <a href="/categories/linux%E5%9C%BA%E6%99%AF/">Linux场景</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%AE%89%E5%85%A8/">安全</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">系统编程</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
          <span>6</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
          <span>2</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
          <span>4</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%94%AF%E6%92%91/">支撑</a>
          <span>2</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
          <span>6</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%A7%84%E5%88%92/">规划</a>
          <span>5</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/">设计</a>
          <span>8</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
          <span>8</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%85%83%E5%AE%87%E5%AE%99Web3.0/">元宇宙Web3.0</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%AA%92%E4%BD%93/">媒体</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E4%B8%9A%E5%8A%A1/">业务</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%8A%9F%E8%83%BD/">功能</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
          <span>13</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
          <span>3</span>
        </li>
      
      </ul>
    </li>
    
  
    
    <li class="book-section-flat">
      <strong>Tags</strong>
      <ul>
      
      </ul>
    </li>
    
  
  </ul>
</nav>


  </aside>
  
 
      </header>

      
      
  
  <article class="markdown book-post">
    <h2>
      <a href="/docs/pl/java/javaweb/">JavaWeb</a>
    </h2>
    
  <div class="flex align-center text-small book-post-date">
    <img src="/svg/calendar.svg" class="book-icon " alt="" />
    <span>Oct 9, 2018</span>
  </div>



  
  <div class="text-small">
    
      <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
  </div>
  

  


    <p><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>分层
    视图层         jsp
    控制层         servlet
    业务层         过滤数据
    manager层     封装第三方，service能力下沉，dao中间件
    数据访问层对象  封装对象
    数据库
java web 13种技术
    JDBC        Java Database Connectivty
    JNDI        Java Name and Directory Interface
    EJB        Enterprise JavaBean
    RMI        Remote Method Invoke
    Java IDL/CORBA
    JSP        Java Server Pages
    Java Servlet
    XML        Extensible Markup Language
    JMS        Java Message Service
    JTS        Java Transaction Service
    JTA        Java Transaction Architecture
    JavaMail
    JAF        JavaBeans Activation Framework
</code></pre>
<h2 id="jsp">
  jsp
  <a class="anchor" href="#jsp">#</a>
</h2>
<pre><code>基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层
域对象
    pageContext     # 当前页面有效
    request         # 一次请求范围
    session         # 会话
    application context     # 同一服务器
内置对象
    Request
    Response
    Session
    Out             # 输出流
    PageContext     # context
    Page            # jsp的this
    Exception       # &lt;%@ page isErrorPage=&quot;true&quot;%&gt; 时使用，显示异常信息
    Application     # 服务器
    Config          # 服务器配置
</code></pre>
<h3 id="jsp-el表达式">
  jsp-el表达式
  <a class="anchor" href="#jsp-el%e8%a1%a8%e8%be%be%e5%bc%8f">#</a>
</h3>
<pre><code>${  }
11个内置对象
    pageContext    // pageContext
    page        // map （相当于pageScope，不过写法上省略了Scope）
    requestScope    // map
    sessionScope    // map
    applicationScope    // map
    param        // map        ,用${param.name}的形式得到传递的参数
    paramValues    // map&lt;String,String []&gt;
    header        // map
    hearderValues    // map&lt;String, String []&gt;
    cookie        // map
    initParam        // map

语法
${list[0]}&lt;br&gt;
    ${map.mapteststring}&lt;br&gt;
    ${map[mapkey]}&lt;br&gt;
    ${map['mapteststring']}&lt;br&gt;
    ${request }
    ${pageContext.request.contextPath }&lt;br&gt;        # el表达式中访问内置对象
    ${requestScope.aaa }                # 访问内置对象requestScope，得到request作用域中的aaa元素
    ${pageContext.servletContext.contextPath }&lt;br&gt;
    ${param}&lt;br&gt;
    ${paramValues['a'] }&lt;br&gt;
    ${paramValues['a'][0] }
    ${paramValues['a'][1] }
    ${paramValues['a'][2] }&lt;br&gt;
    ${empty novalue}&lt;br&gt;
    ${1&gt;2?&quot;yes&quot; : &quot;no&quot;}&lt;br&gt;

        #  . 与 [] 可以替换使用，但有两点需要注意
        1  .1不行，但是[1]可以
        2    1&gt; map[&quot;key&quot;]    是取map中&quot;key&quot;对应的值
            2&gt; map[key]是先从作用域中取得key的字符串如&quot;aaa&quot;,再取map中&quot;aaa&quot;对应的值
            3&gt; .key    相当于1&gt;中的介绍，是取map中&quot;key&quot;对应的值
            4&gt; .是不能相当于2&gt;中的介绍那样使用的
比较符${ }中使用
    empty
    not empty
    三元式（?:）
    简单的算术运算
</code></pre>
<h3 id="jsp-taglib标签库">
  jsp-taglib标签库
  <a class="anchor" href="#jsp-taglib%e6%a0%87%e7%ad%be%e5%ba%93">#</a>
</h3>
<pre><code>jstl标签库1.1 或1.2
    标签库1.1中需要    jstl.jar 与 standard.jar 库
可放入域scope的类型
    page
    request
    session
    application
    functions
el表达式级使用，其它都标签级使用
functions
    &lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt;
    ${fn:contains(&quot;gzitcast&quot;, &quot;itcast&quot;) }  &lt;br&gt;
    ${fn:containsIgnoreCase(&quot;gzitcast&quot;, &quot;ITCAST&quot;) }  &lt;br&gt;
    ${fn:endsWith(&quot;gzitcast&quot;, &quot;st&quot;) } &lt;br&gt;
    ${fn:indexOf(&quot;gzitcsat&quot;, &quot;cs&quot;) } &lt;br&gt;
    ${fn:join(arr, &quot;-&quot;) } &lt;br&gt;
    ${fn:length(&quot;gzitcast&quot;) } &lt;br&gt;
    ${fn:replace(&quot;gzitcast&quot;, &quot;gz&quot;, &quot;广州&quot;) } &lt;br&gt;
    ${fn:split(&quot;gz,it,cast&quot;, &quot;,&quot;) } &lt;br&gt;
    ${fn:startsWith(&quot;gzitcsat&quot;, &quot;gz&quot;) } &lt;br&gt;
    ${fn:substring(&quot;gzitcsat&quot;, 3, 8) } &lt;br&gt;
    ${fn:substringAfter(&quot;gzitcsat&quot;, &quot;cs&quot;) } &lt;br&gt;
    ${fn:substringBefore(&quot;gzitcsat&quot;, &quot;cs&quot;) } &lt;br&gt;
    ${fn:toLowerCase(&quot;gziTCsat&quot;) } &lt;br&gt;
    ${fn:toUpperCase(&quot;gziTCsat&quot;) } &lt;br&gt;
    ${fn:trim(&quot;  gzitcsat  &quot;) } &lt;br&gt;
    &lt;%-- 对字符串中进行转义处理，如：会把&quot;&lt;&quot;替换为&quot;&amp;lt;&quot;，把&quot;&gt;&quot;替换为&quot;&amp;gt;&quot; --%&gt;
    ${fn:escapeXml(&quot;&lt;h3&gt;gzitcsat&lt;/h3&gt;&quot;) } &lt;br&gt;
core
    所有标签：
        out
        set
        remove
        catch
        if
        choose
        when
        otherwise
        forEach
        url
        param
        redirect
        forTokens
        import

    &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/cores&quot;%&gt;
    &lt;c:out var=&quot;&quot;    default=&quot;&quot;    escapeXml=&quot;true&quot;&gt;    &lt;%--    放过xml过滤，让它显示，默认不显示    --%&gt;
    -------------------------------------
    scope方式
    &lt;c:set    var=&quot;&quot;    value=&quot;&quot;    scope=&quot;&quot;&gt;
    target方式    &lt;%--    这个放入page作用域中的map值    --%&gt;
    &lt;%  Map map = new HashMap();  %&gt;
    &lt;c:set    property=&quot;key1&quot;    value=&quot;key1value&quot;    target=&quot;&lt;%=map%&gt;&quot;
    &lt;%  pageContext.setAttribute(&quot;map&quot;, map);  %&gt;
    &lt;c:out    value=&quot;${map[key2]}&quot;

    -------------------------------------
    &lt;c:catch var=&quot;e&quot;&gt;&lt;/c:catch&gt;
    &lt;c:out value='&lt;%= ((Exception)pageContext.getAttribute(&quot;e&quot;,PageContext.PAGE_SCOPE)).getMessage() %&gt;'&gt;&lt;/c:out&gt;
    -------------------------------------
    &lt;c:remove    var=&quot;&quot;    scope=&quot;&quot;&gt;
    -------------------------------------
    &lt;c:if test=&quot;${not empty    }&quot; scope=&quot;&quot;    var=&quot;&quot;&gt;
    -------------------------------------
    &lt;%--    if...else标签    --%&gt;
    &lt;c:choose&gt;
    &lt;c:when test=&quot;&quot;&gt;
    &lt;c:otherwise&gt;
    -------------------------------------
    &lt;c:forEach  begin=&quot;&quot;    end=&quot;&quot;    step=&quot;&quot;    items=&quot;&quot;    var=&quot;&quot;    varStatus=&quot;state&quot;&gt;          &lt;%--    varStatus中的函数有first last count begin end    --%&gt;
    &lt;tr bgcolor='${state.count%2 == 0? &quot;red&quot; : &quot;pink&quot;}' &gt;
    &lt;/c:forEach&gt;

    varStatus可用的函数
        current    // 当前这次迭代的项
        index    // 索引
        count    // 计数
        first        // 第一个
        last        // 最后一个
        begin    // begin属性值
        end        // end 属性值
        step        // step属性值
    -------------------------------------
    uri 代表所有协议路径

    &lt;c:url    var=&quot;itcast&quot;    value=&quot;http://www.itcast.cn&quot;    scope=&quot;page&quot;    context=&quot;&quot;    &gt;    &lt;%--    context 是整个网站    --%&gt;
    &lt;c:param    name=&quot;name&quot;    value=&quot;中文&quot;&gt;    &lt;%--    这样传参数有编码    --%&gt;

    如果value值为&quot;/&quot; 则加入context属性提供上下文名称，如果context也被省略，就使用当前servlet的上下文名称
    -------------------------------------
    &lt;c:redirect    url=&quot;${itcast}&quot;    context=&quot;&quot;    &gt;
    -------------------------------------
    &lt;c:set    var=&quot;name&quot;    value=&quot;xx,xxx,xxx,xx&quot;    scope=&quot;request&quot;    &gt;
    &lt;c:forTokens    items=&quot;${name}&quot;    delims=&quot;,&quot;    begin=&quot;&quot;    end=&quot;&quot;    step=&quot;1&quot;    var=&quot;name&quot;    varStatus=&quot;&quot;    &gt;    &lt;%--切割字符串--%&gt;
    -------------------------------------
    &lt;c:import    url=&quot;/publics/head.jsp&quot;    &gt;    &lt;%--动态包含，引入公共文件--%&gt;&lt;%--网站publics文件夹--%&gt;


sql标签库
    # 以前没有mvc模式的时候，通过页面访问数据库时用的，现在不用
    引入
        &lt;%@ taglib prefix=&quot;sql&quot; uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; %&gt;
    设置数据源
        &lt;sql:setDataSource dataSource=”dataSource”[var=”name”]
                            [scope=”page|request|session|application”]/&gt;
    jdbc连接
        &lt;sql:setDataSource driver=”driverClass” url=”jdbcURL”
                user=”username”
                password=”pwd”
                [var=”name”]
                [scope=”page|request|session|application”]/&gt;

    JSTL提供了&lt;sql:query&gt;、&lt;sql:update&gt;、&lt;sql:param&gt;、&lt;sql:dateParam&gt;和&lt;sql:transaction&gt;这5个标签
        1.query:
        query必需指定数据源
        &lt;sql:query sql=”sqlQuery” var=”name” [scope=”page|request|session|application”]
        [dataSource=”dateSource”]
        [maxRow=”maxRow”]
        [startRow=”starRow”]/&gt;
        或
        &lt;sql:query var=”name” [scope=”page|request|session|application”]
        [dataSource=”dateSource”]
        [maxRow=”maxRow”]    # 设定最多可以暂存数据的长度
        [startRow=”starRow”]    # 设定从哪一行开始
                &gt;
                sqlQuery
                &lt;/sql:query&gt;

        结果集的参数
            rowCount    # 结果集中的记录总数
            rowsByIndex    # 以数字为作索引的查询结果
            columnNames    # 字段名称数组
            Rows    # 以字段为索引查询的结果
            limitedByMaxRows    # 是否设置了maxRows属性来限制查询记录的数量
                limitedByMaxRows用来判断程序是否收到maxRows属性的限制。
                并不是说设定了maxRows属性，得到结果集的limitedByMaxRows的属性都为true，
                当取出的结果集小于maxRows时，则maxRows没有对结果集起到作用此时也为false。
                例如可以使用startRow属性限制结果集的数据量。

        2.update:
        &lt;/sql:update&gt;
        &lt;sql:update sql=”SQL语句” [var=”name”] [scope=”page|request|session|application”]
                [dateSource=”dateSource”]/&gt;
        或
    &lt;sql:update [var=”name”] [scope=”page|request|session|application”]
                [dateSource=”dateSource”]
                    &gt;
                    SQL语句
        参数说明
            dataSource    # 数据源对象
            其它与query一样

        3.param 参数设置
        &lt;sql:param value=”value”/&gt;
        或
        &lt;sql:param&gt;
            Value
            &lt;/sql:param&gt;

        4.dataParam 标签    # 用于为SQL标签填充日期类型的参数值

        参数说明
            value：java.util.Date类型的参数。
            type属性：指定填充日期的类型timestamp（全部日期和时间）、time（填充的参数为时间）、date（填充的参数为日期）。

        5.transaction 标签

        &lt;sql:transaction [dataSource=”dataSource”]
            [isolation=”read_committed|read_uncommitted|repeatable|serializable”]
            &gt;
            &lt;sql:query&gt;
            &lt;sql:uptade&gt;
        &lt;/sql:transation&gt;

xml标签库
    核心操作
    out    # 主要用来取出XML中的字符串。
        属性
        select    # XPath语句
        escapeXml    # 是否转换特殊字符

    parse    # 用来解析xml文件
        属性
        doc    # XML文件
        systemId    # XML文件的URL
        filter    # XMLFilter过滤器
        varDom    # 储存解析后的XML文件
        scopeDom    # varDom的范围

    set    # 将从XML文件取得的内容储存至属性范围中
        属性
        select    # XPath语句

    流程控制
    if
    choose when otherwise
        属性
        select    # XPath语句
    文件转换
    &lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]
        [result=”result”]
        [var=”name”]
        [scope=”scopeName”]
        [xsltSystemId=”xsltsystemid”]/&gt;
    或
    &lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]
        [result=”result”]
        [var=”name”]
        [scope=”scopeName”]
        [xsltSystemId=”xsltsystemid”]
        &gt;
        &lt;x:param/&gt;
        &lt;/x:transform&gt;
    或
    &lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]
        [result=”result”]
        [var=”name”]
        [scope=”scopeName”]
        [xsltSystemId=”xsltsystemid”]
        &gt;

        属性
        doc    # 指定xml文件来源
        xslt    # 转化xml的样式模板
        docSystemId    # xml文件的URI
        xsltSystemId    # xslt文件的URI
        result    # 用来存储转换后的结果对象

国际化
    &lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
    国际化标签
    1.setLocale    # 设置一个全局的地区代码,设定的是本地的环境
        中文－大陆:&lt;fmt:setLocale value=&quot;zh_CN&quot;/&gt; &lt;fmt:formatDate value=&quot;${todayValue}&quot;/&gt;&lt;br&gt;

    2.requestEncoding    # 设置统一的请求编码
        &lt;fmt:requestEncoding value=&quot;GB2312&quot;/&gt;

    信息显示标签
    1.&lt;fmt:bundle&gt; 设置临时要读取的资源文件
    2.&lt;fmt:message&gt;  通过key取得value
    3.&lt;fmt:setBundle&gt;  设置一个要读取的全局的资源文件
        如
        &lt;fmt:setBundle basename=&quot;applicationMessage&quot; var=&quot;MyResourse&quot;/&gt;    # 绑定了名为applicationMessage_zh_CN.properties一类 的文件
        &lt;fmt:bundle basename=&quot;MyResourse&quot; prefix=&quot;label.&quot;&gt;
        &lt;fmt:message key=&quot;backcolor&quot; bundle=&quot;${applicationBundle}&quot;/&gt;
        &lt;fmt:message key=&quot;fontcolor&quot; /&gt;
    &lt;/fmt:bundle&gt;


    数字及日期格式化标签
    1.&lt;fmt:formatDate&gt;  日期的格式化
        属性
        value:格式化的日期，该属性的内容应该是 java.util.Date 类型的实例
        type:格式化的类型
        pattern:格式化模式
        timeZone:指定格式化日期的时区
    2.&lt;fmt:parseDate&gt;  解析日期
        属性
        value:将被解析的字符串
        type:解析格式化的类型
        pattern:解析格式化模式
        parseLocale:以本地化的形式来解析字符串，该属性的内容为 String 或 java.util.Locale 类型的实例
        timeZone:指定解析格式化日期的时区
    3.&lt;fmt:formatNumber&gt;  数字格式化
        属性
        value:格式化的数字,该数值可以是 String 类型或 java.lang.Number 类型的实例
        type:格式化的类型,可能值包括:currency（货币）、number（数字）和percent（百分比）
        pattern:格式化模式
        maxIntegerDigits:指定格式化结果的最大值
        minIntegerDigits:指定格式化结果的最小值
        maxFractionDigits:指定格式化结果的最大值，带小数
        minFractionDigits:指定格式化结果的最小值，带小数
        如
        &lt;fmt:formatNumber value=&quot;1000.888&quot; type=&quot;currency&quot; var=&quot;money&quot;/&gt;

    4.&lt;fmt:parseNumber&gt;  解析数字
        属性
        value:将被解析的字符串
        type:解析格式化的类型
        pattern:解析格式化模式
        如
        &lt;fmt:parseNumber value=&quot;15%&quot; type=&quot;percent&quot; var=&quot;num&quot;/&gt;
    5.&lt;fmt:setTimeZone&gt;  标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行属性描述
        属性
        value    # 时区的设置
        var    # 用于保存时区为一个变量
    6.&lt;fmt:timeZone&gt;  标签将使得在其标签体内的工作可以使用该时区设置
        属性
        value    # 时区的设置
    7.&lt;fmt:param&gt; 标签:用于参数传递
        如：在MyResourse.properties文件中,有一个索引值如下(其中,{0}代表占位符):
        Str2=Hi,{0}
        则,使用&lt;fmt:param&gt;标签传入值如下:
        &lt;fmt:bundle basename=&quot;MyResourse&quot;&gt;
            &lt;fmt:message key=&quot;Str2&quot;&gt;
            &lt;fmt:param value=&quot;张三&quot; /&gt;
            &lt;/fmt:message&gt;
        &lt;/fmt:bundle&gt;
        也可以在资源文件中指定参数的类型:
        如:在MyResourse.properties文件中,有一个索引值如下:
        Str3={0,date}
        则,使用&lt;fmt:param&gt;标签传入值如下:
        &lt;% request.setAttribute(&quot;now&quot;,new Date()); %&gt;
        &lt;fmt:bundle basename=&quot;MyResourse&quot;&gt;
            &lt;fmt:message key=&quot;Str3&quot;&gt;
            &lt;fmt:param value=&quot;${now}&quot; /&gt;
            &lt;/fmt:message&gt;
        &lt;/fmt:bundle&gt;
</code></pre>
<h3 id="jsp动作标签">
  jsp动作标签
  <a class="anchor" href="#jsp%e5%8a%a8%e4%bd%9c%e6%a0%87%e7%ad%be">#</a>
</h3>
<pre><code>在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。

一、Include行为

    &lt;jsp:include&gt;标签表示动态包含一个静态的或者动态的文件。

    语法：
    &lt;jsp:include page=&quot;path&quot; flush=&quot;true&quot; /&gt;
    or
    &lt;jsp:include page=&quot;path&quot; flush=&quot;true&quot;&gt;
    &lt;jsp:param name=&quot;paramName&quot; value=&quot;paramValue&quot; /&gt;
    &lt;/jsp:include&gt;

    注：
    1、page=&quot;path&quot; 为相对路径，或者代表相对路径的表达式。
    2、flush=&quot;true&quot; 必须使用flush为true，它默认值是false。
    3、&lt;jsp:param&gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&lt;jsp:param&gt;来传递多个参数给动态文件。
    4、&lt;jsp:include page=&quot;&quot; flush=&quot;&quot;&gt; 与&lt;%@ include file=&quot;&quot;%&gt;的区别：
        &lt;jsp:include &gt;是动态包含&lt;%@include%&gt;是静态包含。
        # jsp页面是把include指令元素（&lt;%@ include file=&quot;&quot;%&gt;）所指定的页面的实际内容（也就是代码段）加入到引入它的jsp页面中,合成一个文件后被jsp容器将它转化成servlet。
        ## 可以看到这时会产生一个临时class文件和一个servlet源文件。
        ## 而动作元素（&lt;jsp:include page=&quot;&quot;/&gt;）是在请求处理阶段引入的，会被JSP容器生成两个临时class文件和两个servlet原文件。
        ## 而引入的只是servlet的输出结果，即JspWriter对象的输出结果，而不是jsp的源代码。

二、Forward行为

    &lt;jsp:forward&gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。

    语法：
    &lt;jsp:forward page=&quot;path&quot;} /&gt;
    or
    &lt;jsp:forward page=&quot;path&quot;} &gt;
    &lt;jsp:param name=&quot;paramName&quot; value=&quot;paramValue&quot; /&gt;……
    &lt;/jsp:forward&gt;

    注：
    1、page=&quot;path&quot; 为一个表达式，或者一个字符串。
    2、&lt;jsp:param&gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&lt;jsp:param&gt;将多个参数发送到一个动态文件中。

三、UseBean行为

    &lt;jsp:useBean&gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。

    语法：
    &lt;jsp:useBean id=&quot;name&quot; scope=&quot;page | request | session | application&quot; typeSpec /&gt;
    其中typeSpec有以下几种可能的情况：
    class=&quot;className&quot; | class=&quot;className&quot; type=&quot;typeName&quot; | beanName=&quot;beanName&quot; type=&quot;typeName&quot; | type=&quot;typeName&quot; |

    注：
    你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。

四、GetProperty行为

    &lt;jsp:getProperty&gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。

    语法：
    &lt;jsp:getProperty name=&quot;name&quot; property=&quot;propertyName&quot; /&gt;

    注：
    1、在使用&lt;jsp:getProperty&gt;之前，必须用&lt;jsp:useBean&gt;来创建它。
    2、不能使用&lt;jsp:getProperty&gt;来检索一个已经被索引了的属性。
    3、能够和JavaBeans组件一起使用&lt;jsp:getProperty&gt;，但是不能与Enterprise Java Bean一起使用。
JavaScript通用库  Jsp语法
JSP的动作标签  2008-04-01 11:47:49|  分类： JSP学习 |  标签： |字号大
中
小 订阅
在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。

一、Include行为

&lt;jsp:include&gt;标签表示包含一个静态的或者动态的文件。

语法：
&lt;jsp:include page=&quot;path&quot; flush=&quot;true&quot; /&gt;
or
&lt;jsp:include page=&quot;path&quot; flush=&quot;true&quot;&gt;
&lt;jsp:param name=&quot;paramName&quot; value=&quot;paramValue&quot; /&gt;
&lt;/jsp:include&gt;

注：
1、page=&quot;path&quot; 为相对路径，或者代表相对路径的表达式。
2、flush=&quot;true&quot; 必须使用flush为true，它默认值是false。
3、&lt;jsp:param&gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&lt;jsp:param&gt;来传递多个参数给动态文件。

二、Forward行为

&lt;jsp:forward&gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。

语法：
&lt;jsp:forward page=&quot;path&quot;} /&gt;
or
&lt;jsp:forward page=&quot;path&quot;} &gt;
&lt;jsp:param name=&quot;paramName&quot; value=&quot;paramValue&quot; /&gt;……
&lt;/jsp:forward&gt;

注：
1、page=&quot;path&quot; 为一个表达式，或者一个字符串。
2、&lt;jsp:param&gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&lt;jsp:param&gt;将多个参数发送到一个动态文件中。

三、UseBean行为

&lt;jsp:useBean&gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。

语法：
&lt;jsp:useBean id=&quot;name&quot; scope=&quot;page | request | session | application&quot; typeSpec /&gt;
其中typeSpec有以下几种可能的情况：
class=&quot;className&quot; | class=&quot;className&quot; type=&quot;typeName&quot; | beanName=&quot;beanName&quot; type=&quot;typeName&quot; | type=&quot;typeName&quot; |

注：
你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。

四、GetProperty行为

&lt;jsp:getProperty&gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。

语法：
&lt;jsp:getProperty name=&quot;name&quot; property=&quot;propertyName&quot; /&gt;

注：
1、在使用&lt;jsp:getProperty&gt;之前，必须用&lt;jsp:useBean&gt;来创建它。
2、不能使用&lt;jsp:getProperty&gt;来检索一个已经被索引了的属性。
3、能够和JavaBeans组件一起使用&lt;jsp:getProperty&gt;，但是不能与Enterprise Java Bean一起使用。

五、SetProperty行为

    &lt;jsp:setProperty&gt;标签表示用来设置Bean中的属性值。

    语法：
    &lt;jsp:setProperty name=&quot;beanName&quot; prop_expr /&gt;
    其中prop_expr有以下几种可能的情形：
    property=&quot;*&quot; | property=&quot;propertyName&quot; | property=&quot;propertyName&quot; param=&quot;parameterName&quot; | property=&quot;propertyName&quot; value=&quot;propertyValue&quot;

    注：
    使用 jsp:setProperty 来为一个Bean的属性赋值；可以使用两种方式来实现。
    1、在jsp:useBean后使用jsp:setProperty：
    &lt;jsp:useBean id=&quot;myUser&quot; … /&gt;
    …
    &lt;jsp:setProperty name=&quot;user&quot; property=&quot;user&quot; … /&gt;
    在这种方式中，jsp:setProperty将被执行。
    2、jsp:setProperty出现在jsp:useBean标签内：
    &lt;jsp:useBean id=&quot;myUser&quot; … &gt;
    …
    &lt;jsp:setProperty name=&quot;user&quot; property=&quot;user&quot; … /&gt;
    &lt;/jsp:useBean&gt;
    在这种方式中，jsp:setProperty只会在新的对象被实例化时才将被执行。

    * 在&lt;jsp:setProperty&gt;中的name值应当和&lt;jsp:useBean&gt;中的id值相同。

六、Plugin行为

    &lt;jsp:plugin&gt;标签表示执行一个applet或Bean，有可能的话还要下载一个Java插件用于执行它。

    语法：
    &lt;jsp:plugin
    type=&quot;bean | applet&quot;
    code=&quot;classFileName&quot;
    codebase=&quot;classFileDirectoryName&quot;
    [ name=&quot;instanceName&quot; ]
    [ archive=&quot;URIToArchive, ...&quot; ]
    [ align=&quot;bottom | top | middle | left | right&quot; ]
    [ height=&quot;displayPixels&quot; ]
    [ width=&quot;displayPixels&quot; ]
    [ hspace=&quot;leftRightPixels&quot; ]
    [ vspace=&quot;topBottomPixels&quot; ]
    [ jreversion=&quot;JREVersionNumber | 1.1&quot; ]
    [ nspluginurl=&quot;URLToPlugin&quot; ]
    [ iepluginurl=&quot;URLToPlugin&quot; ] &gt;
    [ &lt;jsp:params&gt;
    [ &lt;jsp:param name=&quot;parameterName&quot; value=&quot;{parameterValue | &lt;％= expression ％&gt;}&quot; /&gt; ]+
    &lt;/jsp:params&gt; ]
    [ &lt;jsp:fallback&gt; text message for user &lt;/jsp:fallback&gt; ]
    &lt;/jsp:plugin&gt;

    注：
    &lt;jsp:plugin&gt;元素用于在浏览器中播放或显示一个对象（典型的就是applet和Bean),而这种显示需要在浏览器的java插件。
    当Jsp文件被编译，送往浏览器时，&lt;jsp:plugin&gt;元素将会根据浏览器的版本替换成&lt;object&gt;或者&lt;embed&gt;元素。注意，&lt;object&gt;用于HTML 4.0 ，&lt;embed&gt;用于HTML 3.2。
    一般来说，&lt;jsp:plugin&gt;元素会指定对象是Applet还是Bean,同样也会指定class的名字，还有位置，另外还会指定将从哪里下载这个Java插件。
</code></pre>
<h3 id="jsp函数">
  jsp函数
  <a class="anchor" href="#jsp%e5%87%bd%e6%95%b0">#</a>
</h3>
<pre><code>用response.getOutputStream返回数据（而非JspWriter）时，调用：
    # 如输出图片对象：ImageIO.write(image, &quot;jpeg&quot;, response.getOutputStream());
    out.clear();        # 清空 out
    out = pageContext.pushBody()    # 将图片对象的流从out输出，直到整个输出结束（接收方网页加载全部完成时）后才断开
</code></pre>
<h3 id="jsp基本">
  jsp基本
  <a class="anchor" href="#jsp%e5%9f%ba%e6%9c%ac">#</a>
</h3>
<pre><code>模板元素
脚本
&lt;%    %&gt;
脚本表达式
&lt;%=    %&gt;
注释
&lt;%--    --%&gt;
指令
    &lt;%@ page%&gt;
    language=&quot;java&quot;
    import=&quot;java.util.*,java.io.*&quot;
    contentType=&quot;mineType [; charset=characterSet]&quot;
    pageEncoding=&quot;characterSet&quot;
    session=&quot;true&quot;
    buffer=&quot;none | 8kb | sizekb&quot;
    autoFlush=&quot;true&quot;
    isThreadSafe=&quot;true&quot;
    info=&quot;text&quot;
    errorPage=&quot;relative_url&quot;
    isErrorPage=&quot;true&quot;
    isELIgnored=&quot;true&quot;
    &lt;%@ include%&gt;    # &lt;%@ include file=&quot;in.jspf&quot; %&gt; 是静态包含（原代码中包含），一般包含名字为*.jspf的jsp文件
    &lt;%@ taglib%&gt;    # 标签库
声明
    &lt;%!    %&gt;    # 全局声明（刷新页面仍然保存数据）
    &lt;% %&gt;    # 局部的声明（刷新页面不保存数据）
标签
    &lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt;
    &lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;
内置对象 9个
    pageContext
    request
    response
    config
    session
    application
    page
    out
    exception

    全局变量
    static final JspFactory        _jspxFactory
    static java.util.List        _jspx_dependants
    javax.el.ExpressionFactory    _el_expressionfactory
    org.apache.AnnotationProcessor    _jsp_annotationprocessor
    在_jspService中的变量
    HttpServletRequest        request
    HttpServletResponse        response
    PageContext        pageContext = null;
                pageContext = _jspxFactory.getPageContext(this,request,response,null,true,8192,ture);
    HttpSession        session = null;
                session = pageContext.getSession();
    ServletContext        application = null;
                application = pageContext.getServletContext();
    ServletConfig        config = null;
                config = pageContext.getServletConfig();
    JspWriter            out = null;
                out = pageContext.getOut();
    Object            page = this;
    JspWriter            _jspx_out = null;
                _jspx_out = out;
    PageContext        _jspx_page_context = null;
                _jspx_page_context = pageContext;
</code></pre>
<h3 id="jsp验证码">
  jsp验证码
  <a class="anchor" href="#jsp%e9%aa%8c%e8%af%81%e7%a0%81">#</a>
</h3>
<pre><code>实例    # 在&lt;img&gt;标签的src属性中指定该jsp文件即可

    ## out.clear();out = pageContext.pushBody();两条语句的作用是
    ## 使该验证码jsp文件的传输不会默认地在返回数据后中断，而是在&lt;img&gt;标签调用该jsp的页面加载结束之后再中断数据的传输
    &lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page contentType=&quot;image/jpeg&quot; import=&quot;java.util.*,java.awt.*,java.awt.image.*,javax.imageio.*&quot;%&gt;
&lt;%!
    // 声明区，定义产生颜色和验证内容的全局方法
    public Color getColor(){

    Random random = new Random();
    int r = random.nextInt(256);
    int g = random.nextInt(256);
    int b = random.nextInt(256);
    return new Color(r,g,b);
    }
    public String getNum(){
    String str = &quot;&quot;;
    Random random = new Random();
    for(int i = 0; i &lt; 4; i++){
        str += random.nextInt(10) + &quot; &quot;;
    }
    return str;
    }
%&gt;
&lt;%
    // 设置响应无缓存
    response.setHeader(&quot;pragma&quot;, &quot;mo-cache&quot;);
    response.setHeader(&quot;cache-control&quot;, &quot;no-cache&quot;);
    response.setDateHeader(&quot;expires&quot;, 0);
    // 图片对象,画笔对象
    BufferedImage image = new BufferedImage(80,30,BufferedImage.TYPE_INT_RGB);
    Graphics g = image.getGraphics();
    // 画背景
    g.setColor(new Color(200,200,200));
    g.fillRect(0, 0, 80, 30);
    // 画干扰线
    for(int i = 0; i &lt; 30; i++){
    Random random = new Random();
    int x = random.nextInt(80);
    int y = random.nextInt(30);
    int xl = random.nextInt(x+10);
    int yl = random.nextInt(y+10);
    g.setColor(getColor());
    g.drawLine(x, y, x + xl, y + yl);
    }
    // 画内容
    g.setFont(new Font(&quot;serif&quot;, Font.BOLD,16));
    g.setColor(Color.BLACK);
    String checkNum = getNum();
    g.drawString(checkNum,15,20);
    // 放内容到session中，返回图片流
    session.setAttribute(&quot;validateCode&quot;, checkNum.replaceAll(&quot; &quot;, &quot;&quot;));
    ImageIO.write(image, &quot;jpeg&quot;, response.getOutputStream());
    out.clear();
    out = pageContext.pushBody();    // 不按照jsp默认的getWriter()方法输出，用我们定义的流的方法进行输出
%&gt;
</code></pre>
<h3 id="自定义标签">
  自定义标签
  <a class="anchor" href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a0%87%e7%ad%be">#</a>
</h3>
<pre><code>1、JspTag 接口（标记接口，类以Serializable）
2、Tag 接口（空标签，如&lt;img/&gt;）
    属性：
    static int EVAL_BODY_INCLUDE        通过流执行标签体
    static int EVAL_PAGE              继续执行页面
    static int SKIP_BODY            忽略执行标签体
    static int SKIP_PAGE            忽略后面的JSP页面
    方法：
    // 生命周期方法
    int doEndTag()            当遇到标签结束的时候自动执行
    int doStartTag()            当遇到标签开始的时候自动执行
    // 实现方法
    Tag getParent()            获取当前标签的父标签处理类对象
    void release()            当事件改变的时候自动执行
    void setPageContext(PageContext pc)    设置当前的JSP上下文环境
    void setParent(Tag t)        设置当前标签的父标签对象
3、TagSupport 类（有属性的标签，如&lt;img src=&quot;&quot;/&gt;）
    实现了Tag接口并且提供处理标签属性的方法(set和get)。而且内部定义了一个PageContext变量并且已经初始化开发者可以直接使用this或者super直接方法该属性。
4、BodyTagSupport类（有属性有文本内容和标签，如&lt;img src=&quot;&quot;&gt;aaa&lt;/img&gt;）
    新属性
    protected  BodyContent bodyContent
    新方法
    void setBodyContent(BodyContent b)
    BodyContent getBodyContent()

    BodyContent类
        abstract String getString()    //获取标签体

    写Tag接口的标签库
    1、写Tag接口实现类
        写属性pageContext（getter 和setter），从setPageContext(PageContext pc)方法中获得该属性
        复写方法
    2、写tld文件，放到/META-INF文件夹中
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
        &lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot;
        version=&quot;2.1&quot;&gt;

        &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
        &lt;short-name&gt;ouru&lt;/short-name&gt;    # 简称
        &lt;uri&gt;/outrun-tags&lt;/uri&gt;    # 自定义引入标签时写的路径

        &lt;tag&gt;
        &lt;name&gt;testDate&lt;/name&gt;
        &lt;tag-class&gt;outrun.util.jsp.taglib.test.DataImplTag&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
        &lt;/tag&gt;

        &lt;/taglib&gt;
    3、jsp 中引用它
        &lt;%@ taglib prefix=&quot;ouru&quot; uri=&quot;/META-INF/myUtil.tld&quot; %&gt;
    写TagSupport接口的实现类
    pageContext已内置
    定义接收属性
    tld文件中加入attribute属性
        &lt;attribute&gt;        属性描述的开始
        &lt;name&gt;pattern&lt;/name&gt;    描述属性名
        &lt;required&gt;true&lt;/required&gt;    描述属性是否是必须的
        &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;  描述属性值是否可以是输出表达式
        &lt;/attribute&gt;
    写BodyTagSupport接口的实现类
    BodyContent body = this.getBodyContent();
    String desc = body.getString();

    tld 文件中
    &lt;body-content&gt;JSP&lt;/body-content&gt;    # 有标签体，可执行脚本表达式
                        ## scriptless，有标签体，不执委脚本表达式
                        ## empty,没有标签体

Jsp2.0
    JspTag — SimpleTag — SimpleTagSupport

    SimpleTagSupport类
    该类可以直接进行操作标签的属性和标签体。
    void doTag()                遇到标签的时候自动指定
    protected  JspFragment getJspBody()          获取标签体对象
    protected  JspContext getJspContext()      获取JSP上下文环境对象
    JspTag getParent()            获取该标签的父标签处理类对象
        JspFragment类
        该类代表的标签的标签体。
        abstract  void invoke(Writer out)    输出数据到指定的流，null输出到JSP页面
    获得标签体的方法：
        Writer writer = new StringWriter();
        JspFragment jspFragment = getJspBody();
        jspFragment.invoke(writer);
        String text = writer.toString();
    项目：实现 if else 判断
    Choose.java
        private boolean tag = true;

        public boolean isTag() {
            return tag;
        }

        public void setTag(boolean tag) {
            this.tag = tag;
        }

        @Override
        public void doTag() throws JspException, IOException {
            getJspBody().invoke(null);
            super.doTag();
        }
    when.java 文件
        private boolean test = false;
        public boolean isTest() {
            return test;
        }

        public void setTest(boolean test) {
            this.test = test;
        }
        @Override
        public void doTag() throws JspException, IOException {
            Choose parent = (Choose) getParent();
            if(isTest() &amp;&amp; parent.isTag()){
            // 条件成立
            getJspBody().invoke(null);
            // 设置父的tag为false
            parent.setTag(false);
            }
            super.doTag();
        }
    Otherwise.java 文件
        @Override
        public void doTag() throws JspException, IOException {
            Choose parent = (Choose) getParent();
            if(parent.isTag()){
            // 条件成立
            getJspBody().invoke(null);
            parent.setTag(false);
            }
            super.doTag();
        }
    tld文件
        &lt;tag&gt;
        &lt;name&gt;choose&lt;/name&gt;
        &lt;tag-class&gt;outrun.util.jsp.taglib.ifelse.Choose&lt;/tag-class&gt;
        &lt;body-content&gt;scriptless&lt;/body-content&gt;    # 有标签体，可执行脚本表达式
                                ## scriptless，有标签体，不执委脚本表达式
                                ## empty,没有标签体

        &lt;/tag&gt;

        &lt;tag&gt;
        &lt;name&gt;when&lt;/name&gt;
        &lt;tag-class&gt;outrun.util.jsp.taglib.ifelse.When&lt;/tag-class&gt;
        &lt;body-content&gt;scriptless&lt;/body-content&gt;
        &lt;attribute&gt;
        &lt;name&gt;test&lt;/name&gt;
        &lt;required&gt;true&lt;/required&gt;
        &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
        &lt;/tag&gt;

        &lt;tag&gt;
        &lt;name&gt;otherwise&lt;/name&gt;
        &lt;tag-class&gt;outrun.util.jsp.taglib.ifelse.Otherwise&lt;/tag-class&gt;
        &lt;body-content&gt;scriptless&lt;/body-content&gt;
        &lt;/tag&gt;



控件标签：
自定义函数库
    1 创建函数库类
    public class MyFunctions {
    public static String formatMyName(String name) {
    return &quot;your name is &quot; + name;
    }
    public static int add(int a, int b) {
    return a+b;
    }
    }

    2 在TLD文件中配置 (引用于目标1中的tld文件)
    &lt;function&gt;
    &lt;name&gt;formatMyName&lt;/name&gt;
    &lt;function-class&gt;com.taglib.MyFunctions&lt;/function-class&gt;
    &lt;function-signature&gt;java.lang.String formatMyName(java.lang.String)&lt;/function-signature&gt;
    &lt;/function&gt;

    &lt;function&gt;
    &lt;name&gt;add&lt;/name&gt;
    &lt;function-class&gt;com.taglib.MyFunctions&lt;/function-class&gt;
    &lt;function-signature&gt;java.lang.String add(int, int)&lt;/function-signature&gt;
    &lt;/function&gt;

    3 JSP中调用

    ${cc:formatMyName(&quot;wangfei&quot;) }
    ${cc:add(12, 34) }
</code></pre>
<h2 id="jdbc">
  jdbc
  <a class="anchor" href="#jdbc">#</a>
</h2>
<pre><code>流程
    Class.forName()     # 加载驱动
    DriverManager.getConnection()
    获得sql会话对象 Statement或PreparedStatement
    设置参数setXxx(), 执行sql，处理结果集
    关闭结果集、关闭会话、关闭连接
Statement
    execute
    executeQuery
    executeUpdate
    不要使用Statement
        容易sql注入
        代码可读性可维护性差
        PreparedStatement性能高，db缓存机制，相同预编译语句调用不再编译
PreparedStatement
    # 继承Statement, 预编译sql

事务怎么写
    编程式
    声明式: 用aop注入
三种连接
    Connection
        默认自动提交
        禁止自动提交开启事务, 后调commit
    Pooled Connection
        使用完后不用关闭
    XA Connection
        分布式事务
        XAResource获得
</code></pre>
<h2 id="i18n">
  i18n
  <a class="anchor" href="#i18n">#</a>
</h2>
<pre><code>页面需要获取用户信息，从数据库中取数据显示

java类中试用：
cn.itcast.resource包中
    hello_en_US.properties
    hello=hello
    hello_zh_CN.properties
    hello=编码后的“你好”
    Test.java
    #  获取信息
    Locale locale = locale.CHINA;
    #  加载资源
    ResourceBundle bundler = ResourceBundle.getBundle(&quot;cn.itcast.resource.hello&quot;,locale);
    #  取出数据
    String str = bundler.getString(&quot;hello&quot;);

jsp中
&lt;%
    ResourceBundle bundler = ResourceBundle.getBundle(&quot;lang.properties.hello&quot;, request.getLocale());
    out.write(bundler.getString(&quot;title&quot;));
%&gt;
&lt;fmt&gt;标签
    &lt;fmt:setLocale value=&quot;${pageContext.request.locale }&quot; scope=&quot;page&quot;/&gt;
    &lt;fmt:setBundle basename=&quot;lang.properties.hello&quot; var=&quot;bundler&quot; scope=&quot;page&quot;/&gt;
    &lt;fmt:message bundle=&quot;${bundler }&quot; key=&quot;title&quot;&gt;&lt;/fmt:message&gt;
资源转码
    native2ascii.exe
    myeclipse properties文件编辑器
ie 中得到en_US
Locale locale
    getLanguage();
    getCountry();
    getDefault();
ResourceBundle
    读取文件cn.itcast.resource.hello省略_en_US.properties
    getString(String key)
实例1：
    创建页面
    创建资源文件
    编辑页面
    request.getLocale();
    ResourceBundle.getBundle(&quot;&quot;,locale);
    getString(&quot;&quot;)
实例2：
    编辑页面
    &lt;%@ taglib%&gt;
    &lt;f:setLocale scope=&quot;&quot; value=&quot;&quot;&gt;
    &lt;f:setBundle basename=&quot;&quot; var=&quot;&quot; scope=&quot;&quot;&gt;
    &lt;f:message bundle=&quot;&quot; key=&quot;&quot; &gt;
动态数据国际化
日期国际化
    SimpleDateFormat    #  继承DateFormat
    getDateTimeInstance
    getDateInstance
    getTimeInstance

    static int FULL
    static int LONG
    static int MEDIUM
    static int SHORT
实例3：
    cn.itcast.i18n.MyDateI18n
    DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);
    String str = format.format(new Date());
    解析页面中的字符串
    FULL 和 LONG  和 MEDIUM 和 SHORT 的 区别
    DataFomat
    String format(Date date)
    Date parse(String source)
    创建static string2Date(String str)
    #  分析区域
    Locale locale = Locale.CHINA;

    #  分析日期的风格
    int dateType = DateFormat.SHORT;
    int timeType = DateFormat.FULL;

    #  获取对象
    DateFormat format = DateFormat.getDateTimeInstance(dateType,timeType,locale);

    #  解析
    format.parse(str);
动态数字国际化
    java.text.*;
    Number类
    NumberFormat(普通数字，货币，百分比)
    getIntegetInstance
    getCurrencyInstance
    getPercentInstance(Locale inLocale)

    format
    parse
    创建cn.itcast.i18n.MyNumberI18n
    #  获取对象
    #  getPercentInstance
    #  getCurrencyInstance
    NumberFormat format = NumberFormat.getIntegerInstance(Locale.CHINA);

    #  格式化 或解析
    long num = 10000000000L;
    #  Number num = format.parse(str);
    #  double price = num.doubleValue();
    format.format(num);
动态文本国际化
    At 12:30 pm on jul 3,1998, a hurricance destroyed 99 houses and caused $1000000 of damage.
    MessageFormat
    MessageFormat(String pattern,Locale locale)
    format(String pattern,Object...arguments)
    format(Object)
    parse()
    占位
    At{0}  on {0}, a hurricance destroyed{1} houses and caused {2} of damage.

    实例1：
    MyMessageI18n.java
    #  定义模式字符串
    String pattern
    #  定义locale对象
    MessageFormat format = new MessageFormat(pattern,Locale.CHINA);
    #  定义参数数组
    DateFormat datef = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.SHORT,Locale.US);
    Date date = datef.parse(&quot;Jul 3,1998 12:30 PM&quot;);

    Integer num = new Integer(99);

    long currency = NumberFormat.getCurrencyInstance(Locale.US).parse(&quot;$1000000&quot;);
    String damage = NumberFormat.getCurrencyInstance(locale).format(currency);

    Object [] values = {date,num,damage};
    #  格式化
    String str = format.format(values);

    分析：{索引，对象，类型}
    MessageFormat messf = new MessageFormat(&quot;{0,time,short} on {0,date}, a hurricance destroyed {1} houses and caused {2,number,currency} of damage.&quot;,Locale.CHINA);

    Object [] values = {new Date(),new Integer(100),1000};

    String str = messf.format(values);
</code></pre>
<h1 id="中间件">
  中间件
  <a class="anchor" href="#%e4%b8%ad%e9%97%b4%e4%bb%b6">#</a>
</h1>
<pre><code>顺序
    监听器 -&gt; 过滤器
</code></pre>
<h2 id="监听器">
  监听器
  <a class="anchor" href="#%e7%9b%91%e5%90%ac%e5%99%a8">#</a>
</h2>
<pre><code>分类
    ServletContextListener
    ServletContextAttributeListener
    HttpSessionListener
    HttpSessionAttributeListener
    HttpSessionActivationListener
web.xml 注册在过滤器后面，servlet前面
    &lt;listener&gt;
    &lt;listener-class&gt;cn.listen.MyListener&lt;/listener-class&gt;
    &lt;/listener&gt;
自定义
    public class MyListener implements ServletContextListener {
        public void contextDestroyed(ServletContextEvent sce) {
            System.out.println(&quot;die&quot;);
        }
        public void contextInitialized(ServletContextEvent sce) {
            System.out.println(&quot;init&quot;);
        }

        // 当过滤器被销毁时自动执行
        public void destroy(){
            System.out.println(&quot;Filterdestroyed&quot;);
        }
        // 当拦截的时候
        public void doFilter(request,response,chain){
            System.out.println(&quot;doFilter&quot;);
            System.out.println(&quot;放行目标资源&quot;);
            chain.doFilter(request,response);
            System.out.println(&quot;目标已经放行&quot;);
        }
        // 初始化的时候
        public void init(FilterConfig config){
            System.out.println(&quot;FilterInited&quot;);
        }
    }
</code></pre>
<h2 id="过滤器">
  过滤器
  <a class="anchor" href="#%e8%bf%87%e6%bb%a4%e5%99%a8">#</a>
</h2>
<pre><code>web.xml
    &lt;filter&gt;
        &lt;filter-name&gt;testFilter
        &lt;filter-class&gt;cn.itcast.filter.text.TestFilter
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;GB2312&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;testFilter
        &lt;url-pattern&gt;/*
    &lt;/filter-mapping&gt;

api
    Filter接口
        ## 多个过滤器, 按web.xml中注册的顺序映射调用。servlet执行完后, 从后向前返回执行chain.doFilter之后的方法
        init
        destroy
        doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
    FilterChain接口
        doFilter(ServletRequest request, ServletResponse response)
    FilterConfig接口
        private FilterConfig config = null;
        init()
            this.config = config;
        doFilter()
            String ip = this.config.getInitParameter(&quot;ip&quot;);

映射
    1.映射的url
    2.servlet的名字
        # 通配servlet &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
    3.为了映射servlet中的转发, 映射一个过滤器到某种传递方式
        &lt;filter-mapping&gt;
            &lt;dispatcher&gt;FORWARD
                # FORWARD 转发方式
                # REQUEST  请求方式
                # INCLUDE  包含方式
                # ERROR  错误页面
            &lt;/dispatcher&gt;
        &lt;/filter-mapping&gt;
设置编码
    doFilter()
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        httpRequest.setCharacterEncoding(&quot;utf-8&quot;)
        String method = httpRequest.getMethod();
        if(&quot;get&quot;.equalsIgnoreCase(method)){
            chain.doFilter(new MyWapperRequest(httpRequest),response);
        }else{
            request.setCharacterEncoding(&quot;utf-8&quot;);
        }

    class MyWapperRequest extends HttpServletRequestWrapper{
        private HttpServletRequest request = null;

        public MyWapperRequest (HttpServletRequest request){
            super(request);
            this.request = request;
        }

        @Override
        public String getParameter(String name){
            String value = request.getParameter(name);
            String method = request.getMethod();
            if(value != null &amp;&amp;&quot;get&quot;.equalsIgnoreCase(method)){
                value = new String(value.getBytes(&quot;iso8859-1&quot;),request.getCharacterEncoding())
            }
            return value;
        }
    }

设置缓存
    # Expires:-1
    # Cache-Control:no-cache
    # Pragma:no-cache

    NoCacheFilter implements Filter # 设置不缓存
        doFilter()
            HttpServletResponse httpResponse = response;
            httpResponse.setHeader(&quot;Expires&quot;,-1 + &quot;&quot;);
            //  setDataHeader(&quot;expires&quot;,-1);
            httpResponse.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;);
            httpResponse.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);
            chain.doFilter(request,httpResponse);



    CacheFilter
        # 缓存静态资源
        # web.xml中url-pattern 可以映射多个 param-name=jpg param-value=2
        private FilterConfig config = null;

        doFilter()
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            HttpServletResponse httpRequest = (HttpServletRequest) request;

        String resource = request.getRequestURI();
        String date  = null;
        if(resource.endsWith(&quot;jpg&quot;)){
            date =  config.getInitParameter(&quot;jpg&quot;);
            httpResponse.setDateHeader(&quot;expires&quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);    // 换算成秒
        } else if(resource.endsWith(&quot;js&quot;)){
            String date  = config.getInitParameter(&quot;js&quot;);
            config.getInitParameter(&quot;js&quot;);
            httpResponse.setDateHeader(&quot;expires&quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);
        }

        chain.doFilter(httpRequest,httpResponse);

修改编码
    EncodingFilter implements Filter{
        doFilter(request,response){
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            HttpServletResponse httpRequest = (HttpServletRequest) request;
            httpRequest.setCharacterEncoding(&quot;utf-8&quot;);
            chain.doFilter(httpRequest,httpResponse);
        }
    }
    class EncodingRequest extends HttpServletRequestWrapper{
        private HttpServletRequest request;
        public EncodingRequest (HttpServletRequest request){
            super(request);
            this.request = request;
        }

        @Override
        public String getParameter(String name){
            String value = request.getParameter(name)
            if(value != null &amp;&amp; &quot;get&quot;.equalsIgnoreCase(request.getMethod)){
                value = new String(value.getBytes(&quot;iso8859&quot;),&quot;utf-8&quot;);
            }
            return value;
        }
    }

登录
    LoginFilter
        init(){
            this.config  = config;
        }
        private FilterConfig config = null;
        doFilter(){
            String path = this.config.getInitParameter(&quot;loginPage&quot;);
            HttpSession session = httpRequest.getSession(false);

            // 判断用户请求的是否是UserServlet
            String servletName = httpRequest.getServletPath();
            servletName = substring(servletName.lastIndexOf(&quot;/&quot;)+1);
            if(&quot;UsersServlet&quot;.equals(servletName)){
            }else{ // 一般的servlet
                if(session != null){
                    // 获取登录标记
                    User user = null;
                    user = (User)session.getAttribute(&quot;user&quot;);

                    // 判断
                    if(user != null){
                        // 放行资源
                        chain.doFilter(httpRequest,httpResponse);
                    }else{
                        // 页面重定向到登录页面
                        httpResponse.sendRedirect(httpRequest.getContextPath() + &quot;/&quot; + path);
                    }
                }
            }
        }
    web.xml
        &lt;filter&gt;
            &lt;filter-name&gt;loginFilter
            &lt;filter-class&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;loginPage
                &lt;param-value&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;
                &lt;url-pattern&gt;/jsps/*
                &lt;url-pattern&gt;/servlet/*
                &lt;url-pattern&gt;/publics/*
            &lt;filter-name&gt;
                &lt;url-pattern&gt;/publics/head.jsp
                &lt;dispatcher&gt;INCLUDE
                &lt;dispatcher&gt;FORWARD
                &lt;dispatcher&gt;ERROR
                &lt;dispatcher&gt;REQUEST
                    # 默认是request，当加上其它参数时（如include），request会没有，所以要加两个forward,request
                    ## 是指向里面以该方法请求的时候进行过滤
</code></pre>
<h2 id="struts2">
  struts2
  <a class="anchor" href="#struts2">#</a>
</h2>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/docs/pl/java/juc/">Java并发</a>
    </h2>
    
  <div class="flex align-center text-small book-post-date">
    <img src="/svg/calendar.svg" class="book-icon " alt="" />
    <span>Oct 9, 2018</span>
  </div>



  
  <div class="text-small">
    
      <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
  </div>
  

  


    <p><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>并发编程三大特性
    可见性(visibility)
        synchronized会刷新线程栈
    有序性(ordering)
    原子性(atomicity)
</code></pre>
<h2 id="cpu">
  CPU
  <a class="anchor" href="#cpu">#</a>
</h2>
<pre><code>PC寄存器(Program Counter Register, 存下一指令)
优化
    乱序读
    合并写
    乱序执行(流水线)
ALU
    访问速度
        Registers: &lt; 1ns
        L1 cache(核内): 1ns
        WC(Writer Comblining) Buffer    # 合并写, 一般4个字节
        L2 cache(核内): 3ns
        L3 cache(CPU内): 15ns
        memory: 80ns
局部性原理
    空间
        按块读取(cache line)
            一次读64Bytes               # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知
            Java1.8注解@Contended       # 保证不在同一行，需要JVM参数-XX:-RestrictContended
    时间
        批量读指令
内存屏障                        # 不同CPU不一样
    Intel
        sfence                      # save, 之前写操作必须完成
        lfence                      # load, 之前读操作必须完成
        mfence                      # mix(save + load)
lock指令                            # 指令执行完之前，锁内存
    lock_add
</code></pre>
<h3 id="cpu缓存一致性协议">
  CPU缓存一致性协议
  <a class="anchor" href="#cpu%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%8d%8f%e8%ae%ae">#</a>
</h3>
<pre><code># 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁
状态
    MESI Cache一致性协议                    # Intel CPU，实现方式为主动监听
        Modified                            # 一行数据在CPU Modified, 其它CPU为Invalid
        Exclusive                           # 独享，其它CPU没有
        Shared                              # 别人也在读
        Invalid                             # 别人改过了
    MSI
    MOSI
缓存行                                      # 多数64字节
    伪共享                                  # 缓存行内无关数据也要同步
</code></pre>
<h2 id="os">
  OS
  <a class="anchor" href="#os">#</a>
</h2>
<pre><code>进程
    # 资源分配
线程
    # 调度执行
    切换(Context Switch)
        CPU导出原线程指令和data到cache, 再导入新线程数据
    线程数
        N(threads) = N(CPU) * U(CPU) * (1 + W/C)
            # N(CPU): CPU数
            # U(CPU): 期望CPU利用率, 0到1
            # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析
        压测决定
CPU性能压榨
    单进程
    批处理
    多进程切换
    多线程进程内切换
        I/O复用
    协程(纤程、绿色线程)用户空间切换
</code></pre>
<h2 id="jvm">
  JVM
  <a class="anchor" href="#jvm">#</a>
</h2>
<h3 id="内存屏障">
  内存屏障
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c">#</a>
</h3>
<pre><code>LoadLoad
StoreStore
LoadStore
StoreLoad
</code></pre>
<h3 id="乱序执行指令重排序">
  乱序执行(指令重排序)
  <a class="anchor" href="#%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f">#</a>
</h3>
<pre><code>为什么
    CPU快, 指令1阻塞时，指令2先执行
判断
    代码不影响单线程最终一致性
例子，多线程
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0, y <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 0, b <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> Long.<span style="color:#a6e22e">MAX_VALUE</span>; i<span style="color:#f92672">++&gt;</span>) {
</span></span><span style="display:flex;"><span>                x<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                y<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                a<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                b<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                CountDownLatch latch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CountDownLatch(2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Thread one <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>                        a <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>                        x <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>                        latch.<span style="color:#a6e22e">countDown</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                Thread other <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>                        b <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>                        y <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>                        latch.<span style="color:#a6e22e">countDown</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                one.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>                other.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>                latch.<span style="color:#a6e22e">await</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><pre><code>例子，类初始化指令换顺序
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> 8;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        T t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T();
</span></span><span style="display:flex;"><span>        汇编码
</span></span><span style="display:flex;"><span>            0 <span style="color:#66d9ef">new</span> <span style="color:#960050;background-color:#1e0010">#</span>2 <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">#</span> 变量半初始化状态为0
</span></span><span style="display:flex;"><span>            3 dup
</span></span><span style="display:flex;"><span>            4 invokespecial <span style="color:#960050;background-color:#1e0010">#</span>3 <span style="color:#f92672">&lt;</span>T.<span style="color:#f92672">&lt;</span>init<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>            7 astore_1
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">#</span> 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0<span style="color:#960050;background-color:#1e0010">。</span>线程访问时中间状态逸出
</span></span><span style="display:flex;"><span>            8 <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">C</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">num</span>)).<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> C();
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">read</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h2 id="unsafe类">
  Unsafe类
  <a class="anchor" href="#unsafe%e7%b1%bb">#</a>
</h2>
<pre><code># 相当于指针。1.8只能根部类用, 11可以直接用
操作内存
    allocateMemory
    putXX
    freeMemory
    pageSize
生成类实例
    allocateInstance
操作类或实例
    objectFieldOffset
    getInt
    getObject
CAS
    compareAndSwapObject()          # JDK1.8
    compareAndSetObject()
    weakCompareAndSetObject()       # JDK11
</code></pre>
<h1 id="修饰符与锁">
  修饰符与锁
  <a class="anchor" href="#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e4%b8%8e%e9%94%81">#</a>
</h1>
<h2 id="概念">
  概念
  <a class="anchor" href="#%e6%a6%82%e5%bf%b5">#</a>
</h2>
<pre><code>锁细化                              # 少代码加轻量锁
锁粗化                              # 锁太多时，如行锁变表锁
</code></pre>
<h2 id="synchronized">
  synchronized
  <a class="anchor" href="#synchronized">#</a>
</h2>
<pre><code>实现方式
    JVM没要求实现方式
    早期都是OS调度
    HotSpot
        在对象头(64位)上用2位实现，组合成锁的类型
        锁升级                      # 不比原子类慢，升完不降
            偏向锁, 第一个线程第一次访问只记线程id
            自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平
            重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景
原子性、可见性
可重入                              # 同一个对象同线程可重入
加锁对象
    方法锁和对象锁锁this
    static方法锁和类锁锁class类
    继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象
使用注意
    抛异常立即释放锁，但被锁数据已更新
    不能用的对象
        String常量，可能未知地方锁同一个
        Integer、Long等基本类型, 值变化会生成新对象
    synchronized的属性加final防止赋值
</code></pre>
<h2 id="volatile">
  volatile
  <a class="anchor" href="#volatile">#</a>
</h2>
<pre><code># 用synchronized性能差不多，volatile一般不用
作用
    # 没有原子性，可能写同一值
    变量在线程见可见性
        依靠CPU缓存一致性协议
    禁止指令重排序                  # 用JVM的读写屏障
        
修饰引用类型，内部属性不监控

DCL(Double Check Lock)单例volatile问题
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> C c;    <span style="color:#75715e">// 禁止了创建c指令重排序</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">C</span>(){}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> C <span style="color:#a6e22e">getInstance</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">synchronized</span> (C.<span style="color:#a6e22e">class</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 申请内存(半初始化状态默认0)，成员变量初始化，赋值</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象</span>
</span></span><span style="display:flex;"><span>                        c <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> C();    
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h2 id="cas">
  CAS
  <a class="anchor" href="#cas">#</a>
</h2>
<pre><code># Compare And Set/Swap, 无锁优化, 乐观锁, 自旋
# Unsafe类支持
CPU原语
    cas(V, Expected, NewValue)
        if V == E                   # 无并发值判断问题，原语上加了屏障
        V = New
        else try again or fail
Java
    AtomicInteger
        incrementAndGet()
ABA问题
    # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据
    版本号                          # Java版本号类AtomicStampedReference
LongAdder
    LongAdder每次加数字, LongAccumulator用lambda
    分段锁(CAS)。值分开放数组里, 多线程对应一个item
性能测试
    LongAdder(713) &gt; Atomic(2166) &gt; Synchronized(3129)
</code></pre>
<h2 id="锁">
  锁
  <a class="anchor" href="#%e9%94%81">#</a>
</h2>
<h3 id="aqs">
  AQS
  <a class="anchor" href="#aqs">#</a>
</h3>
<pre><code># AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种
# 实现方式: CAS，volatile, 模板方法
类图
    AbstractQueueSynchronizer
        Sync
            NonfairSync
方法
    AbstractQueueSynchronizer
        # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待)
        Node
            volatile Node prev
            volatile Node next
            volatile Thread thread
        VarHandle
            # JDK1.9，保存引用，普通属性原子操作。
            # 相比反射，直接操作二进制码
            get()
            set()
            compareAndSet()         # 原子性
            getAndAdd()             # 原子性
            class C {
                int x = 0;
                private static VarHandle handle;
                static {
                    handle = MethodHandles.lookup().findVarHandle(C.class, &quot;x&quot;, int.class)
                    handle.compareAndSet(c, 0, 1);

                }
            }
        volatile state              # 多态实现
        acquire()
        tryAcquire()                # 模板方法
        acquireQueued()             # 获得
        addWaiter(Node.EXCLUSIVE)   # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表)
        cancelAcquire()             # status CANCELLED, tail时设置null, 非tail时unpark下一节点
    NonfairSync
        nonfairTryAcquire()
</code></pre>
<h3 id="reentrantlock">
  ReentrantLock
  <a class="anchor" href="#reentrantlock">#</a>
</h3>
<pre><code>    # 可重入锁，CAS实现, state记重入多少次
    new ReentrantLock(true)         # 公平锁
    tryLock(long, TimeUnit)
    lockInterruptibly()             # 响应interrupt()标记
    newCondition()                  # 多一个等待队列

    源码
        调NonfairSync
</code></pre>
<h3 id="countdownlatch">
  CountDownLatch
  <a class="anchor" href="#countdownlatch">#</a>
</h3>
<pre><code>    # 比join()灵活
    new CountDownLatch(4)
    countDown()
    await()
</code></pre>
<h3 id="cyclicbarrier">
  CyclicBarrier
  <a class="anchor" href="#cyclicbarrier">#</a>
</h3>
<pre><code>    # 满了一起放行, 场景如I/O批量消费
    new CyclicBarrier(4, ()-&gt;{})
    await()
</code></pre>
<h3 id="phaser">
  Phaser
  <a class="anchor" href="#phaser">#</a>
</h3>
<pre><code>    # 阶段批量执行过滤
    class MyPhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch(phase) {
                case 0:
                    print(&quot;arrived&quot; + registeredParties);
                    return false;
                case 1:
                    print(&quot;eated&quot; + registeredParties);
                    return false;
                case 2:
                    print(&quot;hugged&quot; + registeredParties);
                    return true;
                default:
                    return true;
            }
        }
    }
    Person implements Runnable {
        private int i;
        public Person(int i) {
            this.i = i;
        }
        public void arrive() {
            phaser.arriveAndAwaitAdvance();
        }
        public void eat() {
            phaser.arriveAndAwaitAdvance();
        }
        public void hug() {
            if (i == 0 || i == 1) {
                phaser.arriveAndAwaitAdvance();
            } else {
                phaser.arriveAndDeregister();
            }
        }

        @Override
        public void run() {
            arrive();
            eat();
            hug();
        }
    }
    phaser = new MyPhaser();
    phaser.bulkRegister(5);
    for (int i = 0; i &lt; 5; i++) {
        new Thread(new Person(i)).start()
    }
</code></pre>
<h3 id="readwritelock">
  ReadWriteLock
  <a class="anchor" href="#readwritelock">#</a>
</h3>
<pre><code>    # 读锁是共享锁，不能写，悲观锁
    # 写锁是排他锁，不能读写
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    void read(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    void write(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    for (int i =0; i&lt;10;i++) {
        new Thread(()-&gt;read(readLock)).start();
    }
    for (int i =0; i&lt;2; i++) {
        new Thread(()-&gt;write(writeLock)).start();
    }
</code></pre>
<h3 id="stampedlock">
  StampedLock
  <a class="anchor" href="#stampedlock">#</a>
</h3>
<pre><code>    # 读时允许写，读完判断不一致再读一遍，乐观锁
</code></pre>
<h3 id="semaphore">
  Semaphore
  <a class="anchor" href="#semaphore">#</a>
</h3>
<pre><code>    # 信号量, 限流同时运行, 用于线程间同步。可设置公平
    Semaphore s = new Semaphore(1, true)
    new Thread(() -&gt; {
        s.acquire();
        s.release()
    })
</code></pre>
<h3 id="exchanger">
  Exchanger
  <a class="anchor" href="#exchanger">#</a>
</h3>
<pre><code>    # 线程间通信, 阻塞交换
    exchange()
</code></pre>
<h3 id="locksupport">
  LockSupport
  <a class="anchor" href="#locksupport">#</a>
</h3>
<pre><code>    # 线程间通信，非锁阻塞，指定线程唤醒
    # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1)
    Thread t = new Thread(() -&gt; {
        for (int i = 0; i &lt; 10; i++) {
            if (i == 5) {
                LockSupport.park();
            }
        }
    })
    t.start();
    TimeUnit.SECONDS.sleep(1);
    LockSupport.unpark(t);
</code></pre>
<h1 id="线程及线程池">
  线程及线程池
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e5%8f%8a%e7%ba%bf%e7%a8%8b%e6%b1%a0">#</a>
</h1>
<h2 id="使用注意">
  使用注意
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%b3%a8%e6%84%8f">#</a>
</h2>
<pre><code>为什么不用Executors线程池
    用LinkedBlockingQueue超数量OOM
    拒绝策略
    线程命名
</code></pre>
<h2 id="类">
  类
  <a class="anchor" href="#%e7%b1%bb">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    Object
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wait</span>()                              <span style="color:#960050;background-color:#1e0010">#</span> 释放synchronized锁并加入等待队列<span style="color:#960050;background-color:#1e0010">，</span>唤醒后执行需要得到synchronized锁
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">notify</span>()                            <span style="color:#960050;background-color:#1e0010">#</span> 只唤醒<span style="color:#960050;background-color:#1e0010">，</span>不释放当前synchronized锁
</span></span><span style="display:flex;"><span>    Thread
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">currentThread</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">sleep</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">yield</span>()                      <span style="color:#960050;background-color:#1e0010">#</span> 让出CPU, 进Ready队列
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>        getState()
</span></span><span style="display:flex;"><span>        join()                              <span style="color:#960050;background-color:#1e0010">#</span> 等待结束
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setDaemon</span>()                         <span style="color:#960050;background-color:#1e0010">#</span> 是否后台
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setPriority</span>(Thread.<span style="color:#a6e22e">NORM_PRIORITY</span>)   <span style="color:#960050;background-color:#1e0010">#</span> 优先级<span style="color:#960050;background-color:#1e0010">，</span>没有用
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Runnable</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Callable</span>
</span></span><span style="display:flex;"><span>        V <span style="color:#a6e22e">call</span>() <span style="color:#66d9ef">throws</span> Exception
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Future</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">get</span>()
</span></span><span style="display:flex;"><span>        get(<span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>        cancel(<span style="color:#66d9ef">boolean</span>)
</span></span><span style="display:flex;"><span>        isCanceled()
</span></span><span style="display:flex;"><span>        isDone()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">RunnableFuture</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FutureTask</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CompletableFuture</span>         <span style="color:#960050;background-color:#1e0010">#</span> parallel
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">supplyAsync</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">allOf</span>(CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>...)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">anyOf</span>(CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>...)
</span></span><span style="display:flex;"><span>            T <span style="color:#a6e22e">join</span>()
</span></span><span style="display:flex;"><span>            CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenApply</span>()
</span></span><span style="display:flex;"><span>            CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenAccept</span>(Consumer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ThreadFactory</span>
</span></span><span style="display:flex;"><span>        Thread <span style="color:#a6e22e">newThread</span>(Runnable)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DefaultThreadFactory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Executor</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ExecutorService</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">shutdown</span>()
</span></span><span style="display:flex;"><span>            shutdownNow()
</span></span><span style="display:flex;"><span>            isShutdown()
</span></span><span style="display:flex;"><span>            isTerminated()
</span></span><span style="display:flex;"><span>            awaitTermination(<span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            Future <span style="color:#a6e22e">submit</span>(Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>            Future <span style="color:#a6e22e">submit</span>(Runnable, T)                     <span style="color:#960050;background-color:#1e0010">#</span> 手动设个result
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">submit</span>(Runnable)
</span></span><span style="display:flex;"><span>            invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>            invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>            invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">abstract</span> AbstractExecutorService
</span></span><span style="display:flex;"><span>                RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">newTaskFor</span>(Runnable, T)
</span></span><span style="display:flex;"><span>                RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">newTaskFor</span>(Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>                T <span style="color:#a6e22e">doInvokeAny</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">boolean</span> timed, <span style="color:#66d9ef">long</span>)
</span></span><span style="display:flex;"><span>                submit()
</span></span><span style="display:flex;"><span>                invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 忽略CancellationException, ExecutionException<span style="color:#960050;background-color:#1e0010">，</span>其它异常抛出并取消未完成任务
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">invokeAll</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 忽略CancellationException, ExecutionException, TimeoutException<span style="color:#960050;background-color:#1e0010">，</span>其它异常抛出并取消未完成任务
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">invokeAny</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>                invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutor</span>                    <span style="color:#960050;background-color:#1e0010">#</span> 线程池<span style="color:#f92672">+</span>任务队列
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 任务顺序: 核心线程, 任务队列<span style="color:#960050;background-color:#1e0010">，</span>起新线程<span style="color:#960050;background-color:#1e0010">，</span>拒绝策略
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>       <span style="color:#960050;background-color:#1e0010">#</span> 用DelayedWorkQueue
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">scheduleAtFixedRate</span>(()<span style="color:#f92672">-&gt;</span>{}, <span style="color:#66d9ef">int</span> initial, <span style="color:#66d9ef">int</span> period, TimeUnit)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForkJoinPool</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">execute</span>(ForkJoinTask)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ScheduledExecutorService</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">[</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CompletionService</span>                             <span style="color:#960050;background-color:#1e0010">#</span> 不阻塞全部任务<span style="color:#960050;background-color:#1e0010">，</span>已有结果入队列
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">poll</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExecutorCompletionService</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Executors</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newSingleThreadExecutor</span>()                           <span style="color:#960050;background-color:#1e0010">#</span> 为了用任务队列和生命周期管理
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newCachedThreadPool</span>()                               <span style="color:#960050;background-color:#1e0010">#</span> 超时60s, max为MAX_VALUE, 任务不堆积场景
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newFixedThreadPool</span>()
</span></span><span style="display:flex;"><span>        newScheduledThreadPool()                            <span style="color:#960050;background-color:#1e0010">#</span> AbstractQueuedSynchronizer
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newWorkStealingPool</span>()                               <span style="color:#960050;background-color:#1e0010">#</span> ForkJoinPool, go的M,G,P
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span> 每个线程单独队列, 尾部偷加尾部
</span></span></code></pre></div><h2 id="创建线程">
  创建线程
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b">#</a>
</h2>
<pre><code># 继承
class MyThread extendws Thread {
    @Override
    public void run(){}
}
new MyThread().start();

# 组合
class MyRun implements Runnable {
    @Override
    public void run(){}
}
new Thread(new MyRun()).start();

# 返回值
class myCall implements Callable&lt;String&gt; {
    @Override
    public String call(){}
}
FutureTask = ft = new FutureTask&lt;String&gt;(new MyCall())
new Thread(ft).start();
ft.get();

# 线程池
// execute无返回值
ExecutorService service = Executors.newCachedThreadPool()
service.execute(()-&gt;{});
// submit有返回值 
Future&lt;String&gt; f = service.submit(new MyCall());
service.shutdown();
</code></pre>
<h2 id="线程状态">
  线程状态
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81">#</a>
</h2>
<pre><code>NEW
RUNNABLE            # 可调度
    READY
    RUNNING
WAITING             # 等待唤醒，忙等待(一直占CPU)
    o.wait()
    t.join()
    LockSupport.park()
    Lock.lock()

    o.notify()
    o.notifyAll()
    LockSupport.unpark()
    Lock.unlock()
TIMED WAITING
    Thread.sleep(time)
    o.wait(time)
    t.join(time)
    LockSupport.parkNanos()
    LockSupport.parkUntil()
BLOCKING            # 阻塞等待（不占CPU但经过OS调度)
    synchronized
TERMINATED
</code></pre>
<h2 id="线程打断">
  线程打断
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%89%93%e6%96%ad">#</a>
</h2>
<pre><code>方法 
    interrupt()                 # 设置打断标记位
    isInterrupted()             # 检查标记位
    static interrupted()        # 检查当前线程标记位，并重置
检测当前线程打断标记的方法      # 抛异常并重置
    Thread.sleep()
    o.wait();
    o.join();
    ReentrantLock
        lockInterruptibly()
不检测当前线程打断标记的方法
    synchronized                # 不是代码实现检测不了
    ReentrantLock
        lock()
强制打断
    Thread
        stop()                  # 已废弃, 立即释放所有锁
        suspend()               # 已废弃，强制暂停，所有锁不释放容易死锁
        resume()                # 已废弃，强制恢复
volatile
    判断数字不准，有同步的时间延迟, interrupt()也有延迟
    也需要代码中判断, 但interrupt()有wait()等系统方法支持
</code></pre>
<h2 id="线程间通信">
  线程间通信
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1">#</a>
</h2>
<h3 id="通知">
  通知
  <a class="anchor" href="#%e9%80%9a%e7%9f%a5">#</a>
</h3>
<pre><code># synchronized wait() notify(), CountDownLatch, LockSupport
volatile List c = new ArrayList();
final Object lock = new Object();
new Thread(() -&gt; {
    synchronized(lock) {
        if (c.size() != 5) {
            lock.wait();
        }
        lock.notify();              // 唤醒t1
    }
}, &quot;t2&quot;).start();

TimeUnit.SECONDS.sleep(1);

new Thread(() -&gt; {
    synchronized(lock) {
        for (int i = 0; i &lt; 10; i++) {
            c.add(new Object());
            if (c.size() == 5) {
                lock.notify();
                lock.wait();        // 让出sychronized锁
            }
        }
    }
}, &quot;t1&quot;).start();
</code></pre>
<h3 id="生产消费">
  生产消费
  <a class="anchor" href="#%e7%94%9f%e4%ba%a7%e6%b6%88%e8%b4%b9">#</a>
</h3>
<pre><code># 优化count可以用CAS加(有ABA问题)
class MyContainer&lt;T&gt; {
    final private List&lt;T&gt; list = new LinkedList&lt;&gt;();
    final private int MAX = 10;
    private int count = 0;

    public synchronized void put(T t) {
        while(list.size() == MAX) {
            this.wait();            // 期间可能有add() 
        }
        list.add(t);
        count++;
        this.notifyAll();           // 应该只唤醒消费者
    }

    public synchronized T get() {
        T t = null;
        while(list.size() == 0) {
            this.wait();
        }
        t = list.removeFirst();
        count--;
        this.notifyAll();           // 应该只唤醒生产者
        return t;
    }
}

# 同步容器, ReentrantLock Condition
private Lock lock = new ReentrantLock();
private Condition producer = lock.newCondition();
private Condition consumer = lock.newCondition();

public void put(T t) {
    try {
        lock.lock();
        while(list.size() == MAX) {
            producer.await();
        }
        list.add(t);
        count++;
        consumer.signalAll();
    } finally {
        lock.unlock();
    }
}

public T get() {
    T t = null;
    try {
        lock.lock();
        while(list.size() == 0) {
            consumer.await();
        }
        t = list.removeFirst();
        count--;
        producer.signalAll();
    } finally {
        lock.unlock();
    }
    return t;
}
</code></pre>
<h1 id="协程">
  协程
  <a class="anchor" href="#%e5%8d%8f%e7%a8%8b">#</a>
</h1>
<pre><code>quasar库                            # 需要设javaagent, 每个fiber生成栈
    fiber =  new Fiber&lt;Void&gt;()
    fiber.start()
</code></pre>
<h1 id="并发api">
  并发API
  <a class="anchor" href="#%e5%b9%b6%e5%8f%91api">#</a>
</h1>
<h2 id="stream">
  Stream
  <a class="anchor" href="#stream">#</a>
</h2>
<pre><code>parallelStream()                    # ForkJoinPool
</code></pre>
<h2 id="threadlocal">
  ThreadLocal
  <a class="anchor" href="#threadlocal">#</a>
</h2>
<pre><code>内部类
    ThreadLocalMap&lt;ThreadLocal, Object&gt;
        # 存在每个线程里。场景如声明式事务拿conn
        # key是弱引用指向ThreadLocal, value是强引用。
    Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        Object value;
        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
方法
    set(T)
内存泄露问题
    ThreadLocal&lt;M&gt; tl = new ThreadLocal();
    tl.set(new M());
    tl = null;
        # threadLocalMap中key弱引用回收, value不回收
    tl.remove();
        # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在
</code></pre>
<h2 id="pipedstream">
  PipedStream
  <a class="anchor" href="#pipedstream">#</a>
</h2>
<pre><code># 效率不高
PipedInputStream
    connect(PipedOutputStream)
    read(byte[])
PipedOutputStream
    write(byte[])
</code></pre>
<h2 id="jmh">
  JMH
  <a class="anchor" href="#jmh">#</a>
</h2>
<pre><code># Java Microbenchmark Harness
概念
    Warmup                              # 预热
    Mesurement                          # 总执行次数
    Timeout                             # 每次执行超时时间
    Threads                             # fork线程数
    Benchmark mode                      # 模式
    Benchmark                           # 方法名
环境变量
    TEMP或TMP                           # JHM临时文件存放
使用
    @Benchmark
    @Warmup(iterations = 2, time = 3)           # 执行2次, 每次隔3秒
    @Fork(5)                                    # 多少线程
    @BenchmarkMode(Mode.Throughput)             # 显示每秒多少次
    @Measurement(iterations = 10, time = 3)     # 共测10次, 每次隔3秒
    public void testA() {

    }
</code></pre>
<h2 id="disruptor">
  Disruptor
  <a class="anchor" href="#disruptor">#</a>
</h2>
<pre><code>介绍
    CAS, 环形数组Buffer
        数组用sequence定位修改快,也避免了头尾加锁
        直接覆盖降低GC
            覆盖前有等待策略
    单机MQ
        发布订阅模式
        观察者模式
    EventFactory
        会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC
使用
    class MyEvent {}
    class MyEventFactory implements EventFactory&lt;MyEvent&gt; {
        @Override
        public MyEvent newInstance() {}
    }
    class MyEventHandler implements EventHandler&lt;MyEvent&gt; {
        @Override
        void onEvent(MyEvent, long sequence, boolean endOfBatch) {}
    }
    class MyExceptionHandler implements ExceptionHandler&lt;MyEvent&gt; {
        @Override
        void handleEventException()
        @Override
        void handleOnStartException()
        @Override
        void handleOnShutdownException()
    }
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(MyEvent::new, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory(), 
        ProducerType.SINGLE, new BlockingWaitStrategy())
        # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁
    // 消费
    disruptor.handleEventsWith(handler1, handler2)
    disruptor.handleEventsWith((event,seq,end)-&gt;{})
    disruptor.handleExceptionsFor(handler1).with(excptionHandler1)

    disruptor.start()

    // 生产
    ringBuffer = disruptor.getRingBuffer()
    sequence = ringBuffer.next()
    event = ringBuffer.get(sequence)
    event.set(&quot;&quot;)
    ringBuffer.publish(sequence)
    translator = new EventTranslator&lt;&gt;() {
        @Override
        void translateTo(event, sequence) {
            event.set(&quot;&quot;)
        }
    }
    ringBuffer.publishEvent(translator)
    ringBuffer.publishEvent((event,seq, &quot;&quot;) -&gt; event.set(l), &quot;&quot;)
等待策略
    BlockingWaitStrategy                # 阻塞直到再次唤醒
    BusySpinWaitStrategy                # 自旋等待
    SleepingWaitStrategy                # sleep等待
    LiteBlockingWaitStrategy            # 同BlockingWaitStrategy减少加锁次数                
    LiteTimeoutBlockingWaitStrategy     # 同LiteBlockingWaitStrategy加超时            
    PhasedBackoffWaitStrategy
    TimeoutBlockingWaitStrategy         # 同BlockingWaitStrategy加超时                
    YieldingWaitStrategy                # 尝试100然后Thread.yield()
</code></pre>
<h1 id="源码分析">
  源码分析
  <a class="anchor" href="#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90">#</a>
</h1>
<h2 id="threadpoolexecutor">
  ThreadPoolExecutor
  <a class="anchor" href="#threadpoolexecutor">#</a>
</h2>
<pre><code>new ThreadPoolExecutor()                    
    int corePoolSize                    # 核心线程数, 永远存活。可设置参与回收
    int maximumPoolSize                 # 最大线程数
    long keepAliveTime                  # 生存时间
    TimeUnit
    BlockingQueue&lt;Runnable&gt;             # 任务队列
    ThreadFactory                       # 线程工厂, 设线程名
    RejectedExecutionHandler            # 拒绝策略
        Abort                           # 抛异常
        Discard                         # 忽略掉
        DiscardOldest                   # 忽略掉排除最久的
        CallerRuns                      # 调用者线程执行, 再多就阻塞
AtomicInteger ctl
    # 高3位线程池状态，低29位线程数量
void execute()
    判断添加核心线程
    放入队列成功
        拒绝或添加非核心线程
    添加非核心线程失败
        拒绝
boolean addWorker(Runable, boolean)
    线程数量加1
    添加Worker
        加锁
        加线程
        启动
class Worker extends AbstractQueuedSynchronizer implements Runnable
    # 本身是AQS锁, 被多任务(线程)访问
    Tread thread
</code></pre>
<h2 id="forkjoinpool">
  ForkJoinPool
  <a class="anchor" href="#forkjoinpool">#</a>
</h2>
<pre><code>abstract class ForkJoinTask
    ForkJoinTask&lt;V&gt; fork()
    V join()
    abstract class RecursiveAction          # 无返回值
        void compute()
    abstract class RecursiveTask            # 有返回值
例子
    class MyTask extends RecursiveTask&lt;Long&gt; {
        int start;
        int end;
        @Override
        Long compute() {
            if (end - start &lt;= MAX_NUM) {
                return sum
            }
            subTask1 = new MyTask(start, mid)
            subTask2 = new MyTask(mid, end)
            subTask1.fork()
            subTask2.fork()
            return subTask1.join() + subTask2.join();
        }
    }
    fjp = new ForkJoinPool()
    task = new MyTask(0, nums.length)
    fjp .execute(task)
    result = task.join()
</code></pre>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/docs/pl/java/jvm/">JVM</a>
    </h2>
    
  <div class="flex align-center text-small book-post-date">
    <img src="/svg/calendar.svg" class="book-icon " alt="" />
    <span>Oct 9, 2018</span>
  </div>



  
  <div class="text-small">
    
      <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
  </div>
  

  


    <p><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>定义
    JVM规范说明书, JVMS(Java Virtual Machine Specifications)
    Java语言规范, JLS(Java Language Specification)
    虚拟机
        指令集
        内存管理
过程
    x.java -&gt; javac -&gt; x.class -&gt; ClassLoader -&gt; (字节码解释器、JIT) -&gt; 执行引擎
JVM语言
    Scala, Kotlin, Groovy, Clojure, jython, jruby等100多个
JVM实现
    HotSpot                 # Oracle官方, 8之后收费, OpenJDK为开源版本
    Jrockit                 # Oracle收购, 合并入HotSpot
    J9                      # IBM
    Microsoft VM
    TaobaoVM                # HotSpot深度定制
    LiquidVM                # 直接匹配专门硬件
    azul zing               # 收费，快, GC1mm, HotSpot参考写的G1
JRE, JDK
    JRE = jvm + core lib
    JDK = JRE + development kit
</code></pre>
<h1 id="jvm构造">
  JVM构造
  <a class="anchor" href="#jvm%e6%9e%84%e9%80%a0">#</a>
</h1>
<h2 id="指标">
  指标
  <a class="anchor" href="#%e6%8c%87%e6%a0%87">#</a>
</h2>
<pre><code>吞吐量: 代码时间 / (代码时间 + GC时间)
响应时间: STW越短, 响应时间越好
</code></pre>
<h2 id="指令instructions">
  指令(Instructions)
  <a class="anchor" href="#%e6%8c%87%e4%bb%a4instructions">#</a>
</h2>
<pre><code>分类
    基于栈的指令类          # 简单, HotSpot
    基于寄存器的指令集      # 复杂但快, HotSpot局部变量表
8大原子操作(JSR-133已放弃这个描述，但指令没变化)
    lock                    # 主内存，标识变量线程独占
    unlock                  # 主内存，解锁独占
    read                    # 主内存，读到工作内存
    load                    # 工作内存，read后的值放入线程本地变量副本
    use                     # 工作内存，传值给执行引擎
    assign                  # 工作内存，执行引擎结果赋值给线程本地变量 
    store                   # 工作内存，存值到主内存给write备用
    write                   # 主内存，写变量值
方法指令                    # 在methods的Code中罗列
    aload_0                 # 变量表第0项入栈
    invokespecial #1        # 调private(无多态)的方法
    invokevirtual           # 调有多态可能性的方法
    invokestatic            # 调静态方法
    invokeinterface         # 调interface方法
    invokedynamic           # 1.7加入，定义类似函数指针时生成(但每个函数都创建了类)
        调用动态产生的类
            lambda
            反射
            scala等JVM语言
            CGLib ASM
        组成
            bootstrapMethod
            方法签名
        &lt;1.8的bug           # 类产生于Perm Space，内存不回收
            for(;;) {I j = C::n;}
    return                  # 方法返回
    bipush 8                # byte扩展成int类型，放到方法栈中
    sipush 200              # short
    istore_1                # 出栈，放到下标为1的局部变量表
    iload_1                 # 局部变量表下标1位置值压栈
    iinc 1 by 1             # 局部变量表1位置值+1
    iadd                    # 出栈两个，相加压栈
    new                     # new对象, 地址压栈
    dup                     # 复制栈顶并压栈
    pop                     # 弹出栈顶
    if_icmpne 7             # int值比较，不等时跳到第7条指令
    mul                     # 乘法
    sub                     # 减法
</code></pre>
<h2 id="class结构">
  class结构
  <a class="anchor" href="#class%e7%bb%93%e6%9e%84">#</a>
</h2>
<h3 id="工具">
  工具
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7">#</a>
</h3>
<pre><code>javap -v a.class
jetbrain jclasslib
jetbrain BinEd
JBE                         # 可编辑
</code></pre>
<h3 id="二进制">
  二进制
  <a class="anchor" href="#%e4%ba%8c%e8%bf%9b%e5%88%b6">#</a>
</h3>
<pre><code>Magic Number(4字节)
    cafe babe
Minor Version(2字节)        # 小版本
Major Version(2字节)        # 大版本
    JDK1.7是51.0
    JDK1.8是52.0
constant_pool_count(2字节)
    # 长度constant_pool_count-1的表
constant_pool               # 索引、tag、类型
    1 CONSTANT_Utf8_info                        # 存一些描述字符串
    2 标记
    3 CONSTANT_Integer_info
    4 CONSTANT_Float_info
    5 CONSTANT_Long_info
    6 CONSTANT_Double_info
    7 CONSTANT_Class_info
    8 CONSTANT_String_info
    9 CONSTANT_Fieldref_info                
    10 CONSTANT_Methodref_info                  # 方法引用
        指向CONSTANT_Class_info
        指向CONSTANT_NameAndType_info
    11 CONSTANT_InterfaceMethodref_info
    12 CONSTANT_NameAndType_info                # 方法名与类型
    15 CONSTANT_MethodHandle_info
    16 CONSTANT_MethodType_info
    18 CONSTANT_InvokeDynamic_info
access_flags(2字节)         # bitmap按位与组合
    # class的修饰符
    ACC_PUBLIC 0x0001 public
    ACC_FINAL 0x0010 final
    ACC_SUPER 0x0020 JDK1.0.2之后必须为真, 表示invokespectial用新语义
    ACC_INTERFACE 0x0200 是否接口
    ACC_ABSTRACT 0x0400 抽象类
    ACC_SYNTHETIC 0x1000 编译器自动生成
    ACC_ANNOTATION 0x2000 
    ACC_ENUM 0x2000 
this_class(2字节)
    存名字对应指向常量池序号
super_class(2字节)
    存名字对应指向常量池序号
interfaces_count(2字节)
interfaces
fields_count(2字节)
fields
    access_flags(2字节)
    name_index              # 存常量池索引
    descriptor_index
        byte B
        char C
        double D
        float F
        int I
        long L
        short S
        boolean Z
        void V
        Object Ljava/lang/Object
        数组
            一维数组 [B
            多维数组 [[C
    attributes_count        # 赋加属性
    attributes
methods_count(2字节)
methods
    access_flags(2字节)
    name_index
    descriptor_index        # 先参数列表，后返回值
        void m() -&gt; ()V
        String toString() -&gt; Ljava/lang/String;
    attributes_count
    attributes              # 赋加属性
        Code                # 指令列表, 一般先压栈this(aload_0)
            LineNumberTable
            LocalVariableTable
attributes_count(2字节)
attributes
</code></pre>
<h2 id="agent">
  Agent
  <a class="anchor" href="#agent">#</a>
</h2>
<pre><code>例子
    打包 a.jar
        MANIFEST.MF
            Premain_Class: MyAgent
        public class MyAgent {
            public static Instrumentation inst;
            public static void premain(String agentArgs, Instrumentation _inst) {
                inst = _inst;
            } 
        }
    JVM参数 -javaagent: a.jar
    使用 MyAgent.inst
</code></pre>
<h1 id="jmmjava-memory-model">
  JMM(Java Memory Model)
  <a class="anchor" href="#jmmjava-memory-model">#</a>
</h1>
<h2 id="内存">
  内存
  <a class="anchor" href="#%e5%86%85%e5%ad%98">#</a>
</h2>
<h3 id="运行时区域">
  运行时区域
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8c%ba%e5%9f%9f">#</a>
</h3>
<pre><code># Runtime data areas
分类
    Program Counter             # 程序计数器，下一条指令位置
    Method Area                 # 方法区,线程间共享
        存储
            Class元信息
            代码编译信息, JIT编译信息
            常量池(Runtime Constant Pool)           # 常量池在运行时存放区
        版本区别
            Perm Space(&lt;1.8)    # 要设定大小, 会溢出报错
                存字符串常量
                lambda生成临时类永远存在
                Full GC不清理
            Meta Space(&gt;=1.8)   # 自动大小无上限
                字符串常量位于堆
                会触发Full GC
    JVM stacks                  # 线程栈 
        Frame(栈帧)             # 一个方法一个栈帧
            Local Variable Table                # 局部变量表, 方法内的局部变量，值在常量池
                默认第0个为this
            Operand Stack                       # 操作数栈
            Dynamic Linking                     # 指向调用方法的 运行时常量池的符号连接
            return address                      # 当前方法执行完的返回地址
    Native Method Stacks        # C/C++方法栈
    Direct Memory               # 直接内存
    Heap                        # 堆, 线程间共享
</code></pre>
<h3 id="屏障">
  屏障
  <a class="anchor" href="#%e5%b1%8f%e9%9a%9c">#</a>
</h3>
<pre><code>CPU屏障
JVM规范
    LoadLoad                # 上load和下load不能重排
    StoreStore
    LoadStore
    StoreLoad               # 最强
</code></pre>
<h2 id="对象">
  对象
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1">#</a>
</h2>
<h3 id="对象内存存储">
  对象内存存储
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1%e5%86%85%e5%ad%98%e5%ad%98%e5%82%a8">#</a>
</h3>
<pre><code>普通对象
    对象头: markword 8字节
    ClassPointer            # 指向Class对象, 启用压缩4字节，不启用8字节
    实例数据
        引用类型            # 启用压缩4字节，不启用8字节
    Padding: 对齐8的倍数
数组对象
    对象头
    ClassPointer
    数组长度4字节
    数组数据
    Padding
对象头
    # 32位64位(25位没用到)，内容不同
    锁标志位2位             # 根据锁标志位判断存储内容
        01 无锁/偏向锁
        00 轻量级锁
        10 重量级锁
        11 GC标记
    是否偏向锁1位
    剩余位 
        无锁状态
            对象hashCode(25位或31位)
                没重写过时默认计算(System.identityHashCode())
                重写过的hashCode()结果不存在这里
            分代年龄
        轻量级锁
            指向栈中锁记录的指针
        重量级锁
            指向互斥量（重量级锁）的指针
        偏向锁
            线程ID 23位
            Epoch 2位
            分代年龄4位(所以分代年龄只有15)
    其它问题
        对象计算过hashCode，对象不能进入偏向锁状态(位已经被占了)
实验工具 javaagent
</code></pre>
<h3 id="对象定位">
  对象定位
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1%e5%ae%9a%e4%bd%8d">#</a>
</h3>
<pre><code>句柄池                      # 指向句柄，句柄有对象指针和class指针, 三色标记GC提高效率
直接指针                    # 指向对象，对象指class, HotSpot使用
</code></pre>
<h2 id="并发">
  并发
  <a class="anchor" href="#%e5%b9%b6%e5%8f%91">#</a>
</h2>
<h3 id="硬件层数据一致性">
  硬件层数据一致性
  <a class="anchor" href="#%e7%a1%ac%e4%bb%b6%e5%b1%82%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7">#</a>
</h3>
<pre><code>硬件结构
    L0寄存器                # 1 cycles
    L1高速缓存              # 3-4 cycles, 1ns
    L2高速缓存              # 10 cycles, 3ns
    L3高速缓存              # 40-45 cycles, 15ns, 在主板
    (QPI总线传输)           # 20ns
    L4主存                  # 60-80ns
    L5磁盘
    L6远程文件存储
数据不一致                  # 从L2多CPU开始
    锁总线(bus lock)
    CPU缓存一致性协议(如intel MESI)
</code></pre>
<h3 id="volatile">
  volatile
  <a class="anchor" href="#volatile">#</a>
</h3>
<pre><code>工具
    hsdis                   # HotSpot Dis Assembler, 虚拟机字节码对应汇编
bytecode
    ACC_VOLATILE
JVM
    StoreStoreBarrier
    volatile写操作          # 上边写完再写，写完下边再读，写一致
    StoreLoadBarrier

    LoadLoadBarrier
    volatile读操作          # 上边读完再读，读完下边再写，读一致
    LoadStoreBarrier
OS
    windows
        lock
    linux
        上下屏障，最后lock
</code></pre>
<h3 id="synchronized">
  synchronized
  <a class="anchor" href="#synchronized">#</a>
</h3>
<pre><code>bytecode
    方法修饰
        synchronized
    代码
        monitorenter
        monitorexit
JVM
    C/C++实现，会调用OS的同步机制
OS
    lock
</code></pre>
<h3 id="happens-before原则">
  happens-before原则
  <a class="anchor" href="#happens-before%e5%8e%9f%e5%88%99">#</a>
</h3>
<pre><code># Java要求指令不能重排的几种情况
</code></pre>
<h3 id="as-if-serial">
  as if serial
  <a class="anchor" href="#as-if-serial">#</a>
</h3>
<pre><code># 不管如何重排序，单线程执行结果不变
</code></pre>
<h1 id="过程">
  过程
  <a class="anchor" href="#%e8%bf%87%e7%a8%8b">#</a>
</h1>
<h2 id="编译">
  编译
  <a class="anchor" href="#%e7%bc%96%e8%af%91">#</a>
</h2>
<pre><code>过程
    代码 -&gt; bytecode -&gt; JVM指令 -&gt; OS指令
解释器(bytecode intepreter)
JIT(Just In-Time compiler)
混合模式
    解释器 + 热点代码编译
    热点代码检测
        方法计数器
        循环计数器
</code></pre>
<h2 id="加载">
  加载
  <a class="anchor" href="#%e5%8a%a0%e8%bd%bd">#</a>
</h2>
<pre><code>HotSpot C++代码加载
    class对象加载到MethodArea
        metaspace(JDK1.8)
        permGeneration(JDK1.8之前)
class加载过程
    loading                 # 读到内存
    linking
        verification        # 校验
        preparation         # 静态变量赋默认值
        resolution          # 解析, loadClass()可指定是否解析。常量池的符号引用转换成内存地址引用
    initializing            # 静态变量赋初始值，执行静态代码
对象加载
    new过程
        class加载
        申请对象内存
        成员变量赋默认值
        调用构造方法&lt;init&gt;
            成员变量顺序赋初始值
            执行构造方法语句(先super)
双亲委派                
    过程
        类名一层层向上找
        找不到时，一层层找再向下委派找
        都不能加载时, 抛ClassNotFound
    为什么
        安全, 自定义类不能覆盖
        已加载不用重复加载
    父加载器
        不是类加载器的加载器
        不是父类
        是组合的parent对象
    打破
        为什么                    
            JDK1.2之前都重写loadClass()
            thread.setContextClassLoader()指定线程上下文classLoader
            热启动/热部署(OSGi tomcat)加载同一类不同版本
        做法
            重写loadClass(), new多个ClassLoader
类加载器
    Bootstrap               # 加载核心类 lib/rt.jar charset.jar等, C++实现所以get时为null
        如加载String
    Extension               # 加载扩展jar jre/lib/ext/*.jar, 由-Djava.ext.dirs指定
    App                     # 加载classpatch指定内容
    Custom ClassLoader      # 自定义ClassLoader
加载路径环境变量            # 来自Launcher源码
    Bootstrap.ClassLoader   sun.boot.class.path
    ExtensionClassLoader    java.ext.dirs
    AppClassLoader          java.class.path
API
    Class
        getClassLoader()
    ClassLoader             # findInCache() -&gt; parent.loadClass() -&gt; findClass()
        private final ClassLoader parent
        loadClass           # 热加载
    Launcher
        $AppClassLoader
        $ExtClassLoader
自定义类加载器
    class MyClassLoader extends ClassLoader {
        @Override
        Class findClass(String) {
            return defineClass()
        }
    }
懒加载                      # JVM未规定什么时候加载,但规定了什么时候初始化
初始化
    new getstatic putstatic invokestatic指令，访问final变量除外
    java.lang.reflect对类进行反射调用
    初始化子类时，父类首先初始化
    虚拟机启动时，被执行的主类
    动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic, REF_putstatic, REF_invokestatic的方法句柄时, 该类初始化
</code></pre>
<h2 id="gc">
  GC
  <a class="anchor" href="#gc">#</a>
</h2>
<h3 id="引用方式强软弱虚">
  引用方式(强软弱虚)
  <a class="anchor" href="#%e5%bc%95%e7%94%a8%e6%96%b9%e5%bc%8f%e5%bc%ba%e8%bd%af%e5%bc%b1%e8%99%9a">#</a>
</h3>
<pre><code>软引用
    # 内存不够用时回收，用做缓存
    # -Xms20M -Xmx20M
    SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024*1024*10]);
    System.gc();
    m.get();
    new byte[1024*1024*15]
    m.get();
弱引用
    # 只要gc就回收，用做容器如WeakHashMap(key是弱引用), ThreadLocalMap的key
    WeakReference&lt;M&gt; m = new WeakReference&lt;&gt;(new M());
    System.gc();
    m.get();
虚引用
    # 值被回收时放入队列来通知, 用来触发回收堆外内存(用Unsafe的freeMemory())
    # 如NIO的直接内存DirectByteBuffer
    PhantomReference&lt;M&gt; r = new PhantomReference&lt;&gt;(new M(), QUEUE);
    r.get() // 自己写永远返回null                     
</code></pre>
<h3 id="对象分配过程">
  对象分配过程
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d%e8%bf%87%e7%a8%8b">#</a>
</h3>
<pre><code>向栈分配                # 不要调参数
    好处
        不必GC
    条件
        线程私有小对象
        无逃逸
        可标量替换(基本类型替换整个对象)
过大，分配到老年代
线程本地分配            # TLAB(Thread Local Allocation Buffer), 不要调参数
    好处
        为了减少线程争用
    条件
        小对象
        占用eden, 默认每个线程占1%
伊甸区
s1,s2
    次数                   # 最大15(对象头上空间决定)
        Parallel Scavenge 15
        CMS 6
        G1 15
    动态年龄
        eden + s1 复制到s2, 超过s2总内存一半时，年龄最大的对象进入老年代
    分配担保
        YGC时survivor区空间不够, 直接进入老年代
GC清除或到老年代
</code></pre>
<h3 id="gc分代过程">
  GC分代过程
  <a class="anchor" href="#gc%e5%88%86%e4%bb%a3%e8%bf%87%e7%a8%8b">#</a>
</h3>
<pre><code>YGC -&gt; s0
YGC, eden + s0 -&gt; s1
    年龄足够 -&gt; old
    s区装不下 -&gt; old
YGC, eden + s1 -&gt; s0
old满了 -&gt; FGC
</code></pre>
<h3 id="常见的回收器">
  常见的回收器
  <a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%9b%9e%e6%94%b6%e5%99%a8">#</a>
</h3>
<pre><code>概念
    Safe Point              # STW时机
    没有无STW的回收器
分代
    Young
        Serial              # 第一个GC
            STW, 单线程串行回收
        Parallel Scavenge
            STW, 并行回收
        ParNew              # Parallel New
            增强PS, 以配合CMS并行回收, CMS到某阶段时PN运行
    Old
        Serial Old
            特点
                适用几十M
                mark-sweep-compact，单线程
        Parallel Old
            特点
                适用几个G
                mark-sweep-compact，多线程
        CMS                 # concurrent mark sweep, 1.4后期引入, JDK11取消
            特点
                适用20G
                多线程并行回收, 并发回收(GC与程序同时运行)，降低STW时间(200ms)
            不足            # 问题多，没有版本默认CMS
                浮动垃圾
                碎片多，新对象分配不下时，使用SerialOld
                    设低GC阈值回收浮动垃圾
            清理过程
                初始标记(initial mark)
                    STW, 单线程, 标记根对象
                [预标记]                        # Card Marking, 把Card标为Dirty
                并发标记(concurrent mark)
                    不STW, 多线程, 执行多次
                重新标记(remark)                # 处理并发标记过程中的变化
                    STW, 多线程, 
                并发清理(concurrent sweep)      # 过程中产生的浮动垃圾, 下次回收
                    不STW, 多线程, 
                [整理阶段]
            日志
                [GC(Allocation Failure)[ParNew:6144K-&gt;640K(6144K)], 0.02 secs] 6585K-&gt;2770K(19840K),0.02 secs][Times:user=0.02 sys=0.00, real=0.02 secs]
                    6144K-&gt;640K(6144K): 回收前 回收后 总容量
                    6585K-&gt;2770K(19840K): 堆回收前 回收后 总大小  

                [GC (CMS Initial Mark)]
                    [1 CMS-initail-mark]
                [CMS-concurrent-mark-start]
                [CMS-concurrent-preclean-start]
                [GC (CMS Final Remark)]
                    [YG occupancy]              # 清理后年轻代占用及容量
                    [Rescan(parallel)]          # STW下标记存活对象
                    [weak refs processing]      # 弱引用处理
                    [class unloading]           # 卸载用不到的class
                    [scrub symbol table]        # 清理常量池
                    [scrub string table]        # 清理常量池
                    [1 CMS-remark]              # 清理后老年代占用及容量
                [CMS-concurrent-sweep-start]
                [CMS-concurrent-reset-start]

不分代
    G1                      # Garbage First, 1.7引入, 1.8完善, 1.9默认
        特点
            适用上百G
            STW 10ms回收
                容易预测STW时间
                低latency, 但throughput也低
            并发回收, 三色标记
            只逻辑分代, 不物理分代 
                内存分Region, Region组成不同大小块，块在逻辑分代中
                Eden和Old区的内存映射会变化
            动态新老代空间                      # 如果YGC频繁，就Young调大
                不要手工指定, 是G1预测YGC停顿时间的基准, 停顿时间通过参数设置
        概念
            CSet            # Collection Set
                可回收Region集合, 回收时存活的对象被移动
                占堆空间不到1%
            RSet            # Remembered Set
                用于找到谁引用当前对象(对象级别), 记录其他Region的引用
                赋值时有GC写屏障                # 非内存屏障
            CardTable       # YGC定位垃圾，要从Root查所有Old区对象，效率低
                Old区对象引用Young区时, bitmap标DirtyCard。YGC时只扫描DirtyCard
            MixedGC         # 默认45%, 同CMS
                初始标记
                重新标记
                筛选回收    # 筛选Region回收，有用对象复制到其它Region
        日志
            [GC pause (G1 Evacuation Pause) (young) (initial-mark)]         # 复制存活对象, initial-mark在MixedGC时有
            [GC concurrent-root-region-scan-start]                          # 混合回收
            [GC concurrent-mark-start]                                      # 混合回收
            [Full GC (Allocation Failure)]                                  # 无法evacuation时, G1中很严重
    ZGC                     # JDK11, 不分代(SingleGeneration)
        特点
            STW设计10ms, 实际1ms
            适用4T（JDK13 16T）
            内存分块（有大有小）
        概念
            没有RSet, 改进了SATB指针
    Shenandoah              # JDK11
    Epsilon                 # JDK11, debug用
    Zulu
组合
    S + SO
    PS + PO                 # 1.8默认, 10G内存10+秒
    PN + CMS
</code></pre>
<h3 id="算法">
  算法
  <a class="anchor" href="#%e7%ae%97%e6%b3%95">#</a>
</h3>
<pre><code>定位
    引用计数(ReferenceCount)
        循环引用问题        # 内部互相引用，没有外部引用
    根可达算法(RootSearching)
        线程栈变量 
        静态变量
        常量池
        JNI指针             # 本地方法用到的对象
并发标记
    三色标记
        白                  # 未被标记
        灰                  # 自身被遍历到，成员变量未被遍历到
        黑                  # 自身、成员变量都被遍历到
        漏标问题 
            两个必要条件 
                黑引用白后，灰对白的引用断开
            算法
                incremental update                      # 增量更新，关注引用的增加, CMS用的
                    增加引用后，标记为灰, 重新标记阶段再扫描
                    缺点是灰色还要重新扫描
                SATB snapshot at the beginning          # 关注引用的删除, G1用的
                    开始时快照, 引用消失时，引用推到堆栈, 下次扫描还扫白色对象
                    优点是只扫描修改过的对象, 看RSet中有没有引用
    颜色指针                # 信息记在指针里
    租户隔离, Session Base GC           # Web专用, 基于session, session断开后删除
    各GC应用
        CMS
            三色标记 + Incremental Update
        G1
            三色标记 + SATB
        ZGC
            颜色指针 + 写屏障
        Shenandoah
            颜色指针 + 读屏障
清除
    标记清除(Mark-Sweep)    # 一遍标记，一遍清理, 适合老年代
        算法简单，戚对象多时效率高
        两遍扫描效率低，容易产生碎片
    拷贝(Copying)           # 存活对象copy到新内存, 旧内存直接清理，适合伊甸区(新生代)
        适用存活对象少的情况
        内存减半
    标记压缩(Mark-Compact)  # 有用的填到前边去空隙去, 适合老年代
        不会碎片，不会内存减半
        扫描两次，还要移动
分代模型
    分代模型                # -Xms -Xmx设置大小
        new/young(新生代)   # MinorGC/YGC, -Xmn设置大小, 默认占比1
            eden(伊甸)      # 默认占比8
            survivor x 2    # 默认每个占比1
        old(老年代)         # MajorGC/FullGC, 1.8默认占比2, 之前是3
            tenured(终身)
        methodArea          # 1.7永久代, 1.8元数据区
    各JVM的分代模型
        Epsilon ZGC Shenandoah不是分代模型
        G1是逻辑分代，物理不分代
        其他都是逻辑分代 + 物理分代
</code></pre>
<h1 id="调优tuning">
  调优(Tuning)
  <a class="anchor" href="#%e8%b0%83%e4%bc%98tuning">#</a>
</h1>
<pre><code>前提
    从业务场景开始
    无监控(能压测), 不调优
目标
    减少FGC
    确定倾向                        # 吞吐量, 或响应时间
        吞吐量好: PS + PO
        响应时间好: G1 或 PN + CMS  # G1吞吐量少10%
组成部分
    JVM预规划
    优化JVM运行环境(慢、卡顿)
    解决JVM运行时出现的问题(OOM)
步骤
    熟悉业务场景
        响应时间
        吞吐量
    选择回收器组合
    计算内存需求(小的快，大的少gc)
    选CPU
    设定年代大小、升级年龄
    设定日志参数
    观察日志情况
</code></pre>
<h2 id="问题分析">
  问题分析
  <a class="anchor" href="#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h2>
<h3 id="工具-1">
  工具
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7-1">#</a>
</h3>
<pre><code>CPU经常100%
    top查进程CPU(top)
    进程中线程CPU(top -Hp)
    导出该线程堆栈(jstack)
    查哪个方法(栈帧)消耗时间(jstack)
内存高
    导出堆内存(jmap)
    分析(jhat jvisualvm mat jprofiler ...)
监控JVM
    jstat jvisualvm jprofiler arthas top ...
    网管: Ansible
流程
    网管报警
    top -Hp 进程号
    jstack 进程号               # 列出所有线程号, 线程状态
        WAITING, 一直等不到, BLOCKED, 拿不到锁
        waiting on &lt;0x0000&gt; (a java.lang.Object)    # 找到目标等待的线程
    jstack -l 16进制线程号      
    jps
    jinfo 进程号                # 列JVM信息
    jstat -gc 进程号 500        # 每500ms打印一次gc信息
    jmap -histo 进程号 | head -20                   # 列所有对象
        有性能消耗，但不很高，可以在线执行
    jmap -dump:format=b, file=x pid                 # 导出转储文件
        内存特别大时，jmap会卡顿
        多个服务器可用，停一个不影响
        设定HeapDumpOnOutOfMemoryError产生堆转储文件                 
        在线定位(中小型公司用不到)
    jhat -J-mx512M x.hprof      # 分析堆dump文件, 有OQL
    arthas                      # 在线定位
        启动
            java -jar arthas-boot.jar
        常用命令                # 没有集成jmap功能
            jvm                 # jinfo
            thread              # jstack
                thread 1
            dashboard           # top
            heapdump            # jmap -dump
            dump
            redefine            # 热替换
                目前只能改method实现，不能改方法名与属性
            jad                 # 反编译类
                看动态代理生成的类
                看第三方类
                看版本
            sc                  # search class, 显示class信息
            watch               # watch method
    MAT                         # 分析dump文件
    jprofiler
    jconsole                    # 需要JMX
        JMX会消耗性能生产服务器不开
        JMX图形界面只用于压测
    jvisualVM                   # 需要JMX, 可分析dump文件
</code></pre>
<h3 id="内存-1">
  内存
  <a class="anchor" href="#%e5%86%85%e5%ad%98-1">#</a>
</h3>
<pre><code>现象
    OOM崩溃
    CPU飙高, 不断FGC
线程池不当运用
加内存反而卡顿
    GC, 应该用CMS或G1替换 PS+PO
JIRA不停FGC, 没定位出来
    扩内存到50G, GC换G1, 重启
tomcat server.max-http-header-size过大
    默认4096, 每个请求都分配
lambda表达式导致方法区溢出
    java.lang.OutofMemoryError: Compressed class space
disruptor不释放缓存
使用Unsafe分配内存, 直接内存溢出
-Xss设定小, 栈溢出
重写finalize()引发GC
    finalize()耗时长, GC时回收不过来，不停GC
内存不到10%，频繁FGC
    有人显式调用System.gc()                         # 不定时调，但会频繁调
大量线程, native thread OOM
    减少堆空间，留更多系统内存产生native thread
G1产生FGC
    降低MixedGC触发的阈值       # 默认45%
    扩内存
    提高CPU                     # 回收快
</code></pre>
<h2 id="hotspot参数">
  HotSpot参数
  <a class="anchor" href="#hotspot%e5%8f%82%e6%95%b0">#</a>
</h2>
<pre><code>辅助
    -XX:+PrintCommandLineFlags -version             # 打印启动参数, -version是随便一个命令
    -XX:+PrintFlagsFinal -version                   # 打印所有XX参数
    -XX:+PrintFlagsInitial      # 打印默认参数
    -XX:+PrintVMOptions         # 显示VM启动参数
    -                           # 标准参数
    -X                          # 显示非标参数
    -XX                         # 显示不稳定参数
内存
    -XX:+HeapDumpOnOutOfMemoryError                 # OOM时产生堆转储文件 
    -Xms40M                     # 堆起始大小
    -Xmx60M                     # 堆最大大小, 最好和Xms一样以免堆弹大弹小
    -Xmn                        # 年经代
    -Xss                        # 栈空间
    -XX:InitialHeapSize         # 起始堆大小，自动算
    -XX:MaxHeapSize             # 堆最大大小，自动算
内存模型
    -XX:-DoEscapeAnalysis       # 去逃逸分析
    -XX:-EliminateAllocations   # 去标量替换
    -XX:-UseTLAB                # 去tlab
    -XX:TLABSize                # 设置TLAB大小
    -XX:+PrintTLAB
    -XX:MaxTenuringThreshold    # 进老年代（升代）回收次数, 最大值15， CMS默认6，其它默认15
对象和类
    -XX:+UseCompressedClassPointers                 # class指针压缩
        开启时4字节，不开启时8字节
    -XX:+UseCompressedOops                          # 引用类型指针压缩, Ordinary Object Pointers
        开启为4字节，不开启时8字节
    -verbose:class              # 类加载详细过程
    -XX:PreBlockSpin            # 锁自旋次数
编译
    -Xmixed                     # 混合模式
    -Xint                       # 解释模式
    -Xcomp                      # 编译模式
    -XX:CompileThreshold = 10000                    # 检测热点代码次数
GC
    -XX:+PrintGC                # 打印GC信息
    PrintGCDetails              # 打印GC更详细
    PrintGCTimeStamps           # 打印GC时间
    PrintGCCauses               # GC原因
    PrintHeapAtGC
    PrintGCApplicationConcurrentTime                # GC应用程序时间
    PrintCApplicationStoppedTime                    # 打印STW时长
    -XX:+PrintReferenceGC       # 打印回收多少种引用类型
    -XX:+UseConcMarkSweepGC     # 用CMS
    -XX:+DisableExplictGC       # System.gc()不管用

    Parallel常用
        -XX:SurvivorRatio           # 新生代Eden区和Surivor区的比例
        -XX:PreTenureSizeThreshold  # 大对象到底多大
        -XX:+ParallelGCThreads      # 并发线程数, 默认是CPU数
        -XX:+UseAdaptiveSizePolicy  # 自动调所有区比例
    CMS常用
        -XX:ParallelCMSThreads      # 并发线程数，默认是CPU数一半
        -XX:CMSInitiatingOccupancyFraction 92%          # 老年代占多少时触发GC, 1.8 92%, 之前68%
            设小一点，清除浮动垃圾
            过大时，栈分配不下，Promotion Failure，触发FGC
        -XX:+UseCMSCompactAtFullCollection              # GC时压缩，避免碎片片
        -XX:CMSFullGCsBeforeCompaction                  # 多少次GC后压缩
        -XX:+CMSClassUnloadingEnabled                   # 回收方法区
        -XX:CMSInitiatingPermOccupancyFraction          # 到什么比例时进行Perm回收, 1.8之前
        GCTimeRatio                                     # GC占程序运行时间的百分比
        -XX:MaxGCPauseMillis                            # GC停顿时间, CMS会减少年轻代大小
    G1
        -XX:MaxGCPauseMillis                            # STW时间, 区别CMS, G1会调整Young区的块数
        GCTimeRatio
        -XX:GCPauseIntervalMillis                       # STW之间间隔时间
        -XX:+G1HeapRegionSize                           # Region大小, 1 2 4 8 16 32, 逐渐增大, GC间隔更长, 每次GC时间更长
            ZGC是动态调整的
        G1NewSizePercent                                # 新生代最小比例, 默认5%
        G1MaxNewSizePercent                             # 新生代最大比例，默认60%
        ConcGCThreads                                   # GC线程数
        InitiatingHeapOccupancyPercent                  # 启动GC的堆空间占用比例

JMX监控
    -Djava.rmi.server.hostname=192.168.1.1
    -Dcom.sun.management.jmxremote 
    -Dcom.sun.management.jmxremote.port=11111 
    -Dcom.sun.management.jmxremote.authenticate=false 
    -Dcom.sun.management.jmxremote.ssl=false
调优                            # 参数越来越少
    JVM参数800个
    CMS参数300个
    G1参数100个
    ZGC更少
    Zing1个
GC组合参数
    -XX:+UseSerialGC
        S + SO
    -XX:+UseParNewGC                # 已废弃
        PN + SO
    -XX:+UseConc(urrent)MarkSweepGC
        PN + CMS + SO
    -XX:+UseParallelGC               # 1.8默认
        PS + PO
    -XX:+UseParallelOldGC
        PS + PO
    -XX:+UseG1GC
        G1
日志参数
    -Xloggc:/logs/xx-xx-%t.log
    -XX:+UseGCLogFileRotation           # 5个满了，覆盖第一个
    -XX:NumberOfGCLogFiles=5
    -XX:GCLogFileSize=1024M
    -XX:+PrintGCDetails
    -XX:+PrintGCDateStamps
    -XX:+PrintGCCause
</code></pre>
<h2 id="hotspot日志">
  HotSpot日志
  <a class="anchor" href="#hotspot%e6%97%a5%e5%bf%97">#</a>
</h2>
<pre><code>GC                          # PrintGCDetails
    [GC
        GC表示YGC, Full GC是FGC
    (Allocation Failure)
        原因
    [DefNew:4544k-&gt;259k(6144k), 0.0873 secs]
        DefNew表示年轻代, 回收前后的大小, 6144是年轻代总大小，回收时间
    4544k-&gt;4356k(19840k), 0.0812 secs]
        堆的前后大小, 19840是堆总空间, 回收时间
    [Times: user=0.01 sys=0.00, real=0.01 secs]
        linux time命令，用户态时间，内核态时间，总时间
异常退出dump堆
    def new generation total 6144k, used 5504k [0x00, 0x00, 0x00]
        新生代总共多少，用了多少。内存起始地址，使用空间结束地址，整体空间结束地址
        total = eden + 1个survivor
    eden space 5504k, 100% used []
        eden
    from space 640k, 0% used []
        s0
    to space 640, 0% used []
        s1
    tenured generation total 13696k, used 13312k []
        old
    the space 13696k, 97% used []
        old
    Metaspace used 2538k, capacity 4486k, committed 4864k, reserved 1056768k
        used真正使用的大小
        capacity目前指定的容量 
        committed 表示预先占用的大小
        reserved表示共保留的大小
    class space used 275k, capacity 386k, committed 512k, reserved 1048576k
        metaspace中存class的部分
</code></pre>
    </p>
  </article>
  

  
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/categories/%E8%AF%AD%E8%A8%80/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/categories/%E8%AF%AD%E8%A8%80/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/categories/%E8%AF%AD%E8%A8%80/" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item disabled">
        <a aria-disabled="true" aria-label="Next" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item disabled">
        <a aria-disabled="true" aria-label="Last" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  <nav>
  <ul>
  
    
    <li class="book-section-flat">
      <strong>Categories</strong>
      <ul>
      
        <li class="flex justify-between">
          <a href="/categories/linux%E5%9C%BA%E6%99%AF/">Linux场景</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%AE%89%E5%85%A8/">安全</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">系统编程</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
          <span>6</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
          <span>2</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
          <span>4</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%94%AF%E6%92%91/">支撑</a>
          <span>2</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
          <span>6</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%A7%84%E5%88%92/">规划</a>
          <span>5</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/">设计</a>
          <span>8</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
          <span>8</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%85%83%E5%AE%87%E5%AE%99Web3.0/">元宇宙Web3.0</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%AA%92%E4%BD%93/">媒体</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E4%B8%9A%E5%8A%A1/">业务</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%8A%9F%E8%83%BD/">功能</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
          <span>13</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
          <span>3</span>
        </li>
      
      </ul>
    </li>
    
  
    
    <li class="book-section-flat">
      <strong>Tags</strong>
      <ul>
      
      </ul>
    </li>
    
  
  </ul>
</nav>

 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












