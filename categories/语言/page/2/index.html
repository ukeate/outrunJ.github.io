<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://runout.run/categories/%E8%AF%AD%E8%A8%80/">
  <meta property="og:site_name" content="outrun的笔记">
  <meta property="og:title" content="语言">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
<title>语言 | outrun的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://runout.run/categories/%E8%AF%AD%E8%A8%80/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.82b3d863368d576b09dc9142a93468d8170f7706990cff55b58bfe72c4930b4b.js" integrity="sha256-grPYYzaNV2sJ3JFCqTRo2BcPdwaZDP9VtYv&#43;csSTC0s=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="https://runout.run/categories/%E8%AF%AD%E8%A8%80/index.xml" title="outrun的笔记" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span>outrun的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-28d9e6987399d0da843d24373bb5310b" class="toggle"  />
    <label for="section-28d9e6987399d0da843d24373bb5310b" class="flex justify-between">
      <a href="/docs/architect/" class="">架构</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/" class="">代码</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/security/" class="">Security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/design_mode/" class="">Java设计模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/" class="">工程设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/ddd/" class="">工程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/frontend/" class="">前端</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>战略性技术</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/" class="">AI</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/map/" class="">知识图谱</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/framework/" class="">Framework</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/media/" class="">媒体</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/middle_platform/" class="">中台</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/block_chain/" class="">Block Chain</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Cloud</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/" class="">Datalake</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/ecology/" class="">Ecology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/edge/" class="">Edge</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/" class="">Manage</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/" class="">组织</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/people/" class="">人员</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/" class="">Method</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/product_plan/" class="">产品规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/code_plan/" class="">代码规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/ops_plan/" class="">运维规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/advice_plan/" class="">咨询规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/architect/" class="">服务治理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/project_plan/" class="">项目规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/test_plan/" class="">测试规划</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/summary/" class="">这些年我做过的技术</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-669f1276b655f93b7e7c5d3bcda5ec19" class="toggle"  />
    <label for="section-669f1276b655f93b7e7c5d3bcda5ec19" class="flex justify-between">
      <a href="/docs/misc/" class="">杂项</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ad4b307ab1b99c68532f747347427ad2" class="toggle"  />
    <label for="section-ad4b307ab1b99c68532f747347427ad2" class="flex justify-between">
      <a href="/docs/middleware/" class="">中间件</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/" class="">支撑-分布式</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/spring_cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/" class="">前端</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/bootstrap/" class="">Bootstrap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/threejs/" class="">Threejs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/angular/" class="">Angular</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/jquery/" class="">Jquery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/react/" class="">React</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/" class="">小功能</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/hibernate/" class="">Hibernate</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Container</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nginx/" class="">Nginx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nodejs/" class="">Nodejs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9d4b4d3532e4d7688278a56c3607ee43" class="toggle"  />
    <label for="section-9d4b4d3532e4d7688278a56c3607ee43" class="flex justify-between">
      <a href="/docs/cache/" class="">Cache</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/ops/" class="">Ops</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/work_code/" class="">Work Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/template/" class="">模板配置</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/soft_arch/" class="">软考架构师</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-75015a3dca1e5254e5fd64787822da31" class="toggle"  />
    <label for="section-75015a3dca1e5254e5fd64787822da31" class="flex justify-between">
      <a href="/docs/basic/" class="">基本功</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/speach/" class="">演说</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/body/" class="">身体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/" class="">Computer</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/principle/" class="">支撑-原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/performance/" class="">Performance</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/" class="">算法</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/thought/" class="">算法思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/data_structure/" class="">数据结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/math/" class="">数学</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-57edaab097f41efb493c8fe5461c9d46" class="toggle"  />
    <label for="section-57edaab097f41efb493c8fe5461c9d46" class="flex justify-between">
      <a href="/docs/tool/" class="">工具</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/" class="">运维</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/monitor/" class="">Monitor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/docker/" class="">Docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/k8s/" class="">Kubernetes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/enterprise_system/" class="">企业级系统</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/" class="">Develop</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/eclipse/" class="">Eclipse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/vim/" class="">VIM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/apple/" class="">Apple</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/jetbrains/" class="">Jetbrains</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/" class="">Linux</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_program/" class="">LinuxProgram</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/scene/" class="">LinuxScene</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_tool/" class="">LinuxTool</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/framework/" class="">Framework</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/physics/" class="">实物工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/" class="">测试</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/debug/" class="">程序调试</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-42c70ef47fd41d9af53858047493d78c" class="toggle"  />
    <label for="section-42c70ef47fd41d9af53858047493d78c" class="flex justify-between">
      <a href="/docs/db/" class="">数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mongodb/" class="">Mongodb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/postgresql/" class="">Postgre SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/oracle/" class="">Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2c3dac8cc024b2be2734e956eea228c9" class="toggle"  />
    <label for="section-2c3dac8cc024b2be2734e956eea228c9" class="flex justify-between">
      <a href="/docs/pl/" class="">程序语言</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/principle/" class="">程序语言原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/haskell/" class="">Haskell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/elixir/" class="">Elixir</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/clojure/" class="">Clojure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/js/" class="">JS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/java_reactive/" class="">Java响应式编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/javaweb/" class="">JavaWeb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/juc/" class="">Java并发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/jvm/" class="">JVM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/collection/" class="">Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/spring/" class="">Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/" class="">Markup Language</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/html/" class="">Html</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/css/" class="">Css</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>语言</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  <nav>
  <ul>
  
    
    <li class="book-section-flat">
      <strong>Categories</strong>
      <ul>
      
        <li class="flex justify-between">
          <a href="/categories/linux%E5%9C%BA%E6%99%AF/">Linux场景</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%AE%89%E5%85%A8/">安全</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">系统编程</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
          <span>6</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
          <span>2</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
          <span>4</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%94%AF%E6%92%91/">支撑</a>
          <span>2</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
          <span>6</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%A7%84%E5%88%92/">规划</a>
          <span>5</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/">设计</a>
          <span>8</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
          <span>8</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%85%83%E5%AE%87%E5%AE%99Web3.0/">元宇宙Web3.0</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%AA%92%E4%BD%93/">媒体</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E4%B8%9A%E5%8A%A1/">业务</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%8A%9F%E8%83%BD/">功能</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
          <span>13</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
          <span>3</span>
        </li>
      
      </ul>
    </li>
    
  
    
    <li class="book-section-flat">
      <strong>Tags</strong>
      <ul>
      
      </ul>
    </li>
    
  
  </ul>
</nav>


  </aside>
  
 
      </header>

      
      
  
  <article class="markdown book-post">
    <h2>
      <a href="/docs/pl/java/juc/">Java并发</a>
    </h2>
    
  <div class="flex align-center text-small book-post-date">
    <img src="/svg/calendar.svg" class="book-icon " alt="" />
    <span>Oct 9, 2018</span>
  </div>



  
  <div class="text-small">
    
      <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
  </div>
  

  


    <p><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>并发编程三大特性
    可见性(visibility)
        synchronized会刷新线程栈
    有序性(ordering)
    原子性(atomicity)
</code></pre>
<h2 id="cpu">
  CPU
  <a class="anchor" href="#cpu">#</a>
</h2>
<pre><code>PC寄存器(Program Counter Register, 存下一指令)
优化
    乱序读
    合并写
    乱序执行(流水线)
ALU
    访问速度
        Registers: &lt; 1ns
        L1 cache(核内): 1ns
        WC(Writer Comblining) Buffer    # 合并写, 一般4个字节
        L2 cache(核内): 3ns
        L3 cache(CPU内): 15ns
        memory: 80ns
局部性原理
    空间
        按块读取(cache line)
            一次读64Bytes               # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知
            Java1.8注解@Contended       # 保证不在同一行，需要JVM参数-XX:-RestrictContended
    时间
        批量读指令
内存屏障                        # 不同CPU不一样
    Intel
        sfence                      # save, 之前写操作必须完成
        lfence                      # load, 之前读操作必须完成
        mfence                      # mix(save + load)
lock指令                            # 指令执行完之前，锁内存
    lock_add
</code></pre>
<h3 id="cpu缓存一致性协议">
  CPU缓存一致性协议
  <a class="anchor" href="#cpu%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%8d%8f%e8%ae%ae">#</a>
</h3>
<pre><code># 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁
状态
    MESI Cache一致性协议                    # Intel CPU，实现方式为主动监听
        Modified                            # 一行数据在CPU Modified, 其它CPU为Invalid
        Exclusive                           # 独享，其它CPU没有
        Shared                              # 别人也在读
        Invalid                             # 别人改过了
    MSI
    MOSI
缓存行                                      # 多数64字节
    伪共享                                  # 缓存行内无关数据也要同步
</code></pre>
<h2 id="os">
  OS
  <a class="anchor" href="#os">#</a>
</h2>
<pre><code>进程
    # 资源分配
线程
    # 调度执行
    切换(Context Switch)
        CPU导出原线程指令和data到cache, 再导入新线程数据
    线程数
        N(threads) = N(CPU) * U(CPU) * (1 + W/C)
            # N(CPU): CPU数
            # U(CPU): 期望CPU利用率, 0到1
            # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析
        压测决定
CPU性能压榨
    单进程
    批处理
    多进程切换
    多线程进程内切换
        I/O复用
    协程(纤程、绿色线程)用户空间切换
</code></pre>
<h2 id="jvm">
  JVM
  <a class="anchor" href="#jvm">#</a>
</h2>
<h3 id="内存屏障">
  内存屏障
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c">#</a>
</h3>
<pre><code>LoadLoad
StoreStore
LoadStore
StoreLoad
</code></pre>
<h3 id="乱序执行指令重排序">
  乱序执行(指令重排序)
  <a class="anchor" href="#%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f">#</a>
</h3>
<pre><code>为什么
    CPU快, 指令1阻塞时，指令2先执行
判断
    代码不影响单线程最终一致性
例子，多线程
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0, y <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 0, b <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> Long.<span style="color:#a6e22e">MAX_VALUE</span>; i<span style="color:#f92672">++&gt;</span>) {
</span></span><span style="display:flex;"><span>                x<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                y<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                a<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                b<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                CountDownLatch latch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CountDownLatch(2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Thread one <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>                        a <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>                        x <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>                        latch.<span style="color:#a6e22e">countDown</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                Thread other <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>                        b <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>                        y <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>                        latch.<span style="color:#a6e22e">countDown</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                one.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>                other.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>                latch.<span style="color:#a6e22e">await</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><pre><code>例子，类初始化指令换顺序
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> 8;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        T t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T();
</span></span><span style="display:flex;"><span>        汇编码
</span></span><span style="display:flex;"><span>            0 <span style="color:#66d9ef">new</span> <span style="color:#960050;background-color:#1e0010">#</span>2 <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">#</span> 变量半初始化状态为0
</span></span><span style="display:flex;"><span>            3 dup
</span></span><span style="display:flex;"><span>            4 invokespecial <span style="color:#960050;background-color:#1e0010">#</span>3 <span style="color:#f92672">&lt;</span>T.<span style="color:#f92672">&lt;</span>init<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>            7 astore_1
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">#</span> 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0<span style="color:#960050;background-color:#1e0010">。</span>线程访问时中间状态逸出
</span></span><span style="display:flex;"><span>            8 <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">C</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">num</span>)).<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> C();
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">read</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h2 id="unsafe类">
  Unsafe类
  <a class="anchor" href="#unsafe%e7%b1%bb">#</a>
</h2>
<pre><code># 相当于指针。1.8只能根部类用, 11可以直接用
操作内存
    allocateMemory
    putXX
    freeMemory
    pageSize
生成类实例
    allocateInstance
操作类或实例
    objectFieldOffset
    getInt
    getObject
CAS
    compareAndSwapObject()          # JDK1.8
    compareAndSetObject()
    weakCompareAndSetObject()       # JDK11
</code></pre>
<h1 id="修饰符与锁">
  修饰符与锁
  <a class="anchor" href="#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e4%b8%8e%e9%94%81">#</a>
</h1>
<h2 id="概念">
  概念
  <a class="anchor" href="#%e6%a6%82%e5%bf%b5">#</a>
</h2>
<pre><code>锁细化                              # 少代码加轻量锁
锁粗化                              # 锁太多时，如行锁变表锁
</code></pre>
<h2 id="synchronized">
  synchronized
  <a class="anchor" href="#synchronized">#</a>
</h2>
<pre><code>实现方式
    JVM没要求实现方式
    早期都是OS调度
    HotSpot
        在对象头(64位)上用2位实现，组合成锁的类型
        锁升级                      # 不比原子类慢，升完不降
            偏向锁, 第一个线程第一次访问只记线程id
            自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平
            重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景
原子性、可见性
可重入                              # 同一个对象同线程可重入
加锁对象
    方法锁和对象锁锁this
    static方法锁和类锁锁class类
    继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象
使用注意
    抛异常立即释放锁，但被锁数据已更新
    不能用的对象
        String常量，可能未知地方锁同一个
        Integer、Long等基本类型, 值变化会生成新对象
    synchronized的属性加final防止赋值
</code></pre>
<h2 id="volatile">
  volatile
  <a class="anchor" href="#volatile">#</a>
</h2>
<pre><code># 用synchronized性能差不多，volatile一般不用
作用
    # 没有原子性，可能写同一值
    变量在线程见可见性
        依靠CPU缓存一致性协议
    禁止指令重排序                  # 用JVM的读写屏障
        
修饰引用类型，内部属性不监控

DCL(Double Check Lock)单例volatile问题
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> C c;    <span style="color:#75715e">// 禁止了创建c指令重排序</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">C</span>(){}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> C <span style="color:#a6e22e">getInstance</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">synchronized</span> (C.<span style="color:#a6e22e">class</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 申请内存(半初始化状态默认0)，成员变量初始化，赋值</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象</span>
</span></span><span style="display:flex;"><span>                        c <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> C();    
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h2 id="cas">
  CAS
  <a class="anchor" href="#cas">#</a>
</h2>
<pre><code># Compare And Set/Swap, 无锁优化, 乐观锁, 自旋
# Unsafe类支持
CPU原语
    cas(V, Expected, NewValue)
        if V == E                   # 无并发值判断问题，原语上加了屏障
        V = New
        else try again or fail
Java
    AtomicInteger
        incrementAndGet()
ABA问题
    # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据
    版本号                          # Java版本号类AtomicStampedReference
LongAdder
    LongAdder每次加数字, LongAccumulator用lambda
    分段锁(CAS)。值分开放数组里, 多线程对应一个item
性能测试
    LongAdder(713) &gt; Atomic(2166) &gt; Synchronized(3129)
</code></pre>
<h2 id="锁">
  锁
  <a class="anchor" href="#%e9%94%81">#</a>
</h2>
<h3 id="aqs">
  AQS
  <a class="anchor" href="#aqs">#</a>
</h3>
<pre><code># AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种
# 实现方式: CAS，volatile, 模板方法
类图
    AbstractQueueSynchronizer
        Sync
            NonfairSync
方法
    AbstractQueueSynchronizer
        # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待)
        Node
            volatile Node prev
            volatile Node next
            volatile Thread thread
        VarHandle
            # JDK1.9，保存引用，普通属性原子操作。
            # 相比反射，直接操作二进制码
            get()
            set()
            compareAndSet()         # 原子性
            getAndAdd()             # 原子性
            class C {
                int x = 0;
                private static VarHandle handle;
                static {
                    handle = MethodHandles.lookup().findVarHandle(C.class, &quot;x&quot;, int.class)
                    handle.compareAndSet(c, 0, 1);

                }
            }
        volatile state              # 多态实现
        acquire()
        tryAcquire()                # 模板方法
        acquireQueued()             # 获得
        addWaiter(Node.EXCLUSIVE)   # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表)
        cancelAcquire()             # status CANCELLED, tail时设置null, 非tail时unpark下一节点
    NonfairSync
        nonfairTryAcquire()
</code></pre>
<h3 id="reentrantlock">
  ReentrantLock
  <a class="anchor" href="#reentrantlock">#</a>
</h3>
<pre><code>    # 可重入锁，CAS实现, state记重入多少次
    new ReentrantLock(true)         # 公平锁
    tryLock(long, TimeUnit)
    lockInterruptibly()             # 响应interrupt()标记
    newCondition()                  # 多一个等待队列

    源码
        调NonfairSync
</code></pre>
<h3 id="countdownlatch">
  CountDownLatch
  <a class="anchor" href="#countdownlatch">#</a>
</h3>
<pre><code>    # 比join()灵活
    new CountDownLatch(4)
    countDown()
    await()
</code></pre>
<h3 id="cyclicbarrier">
  CyclicBarrier
  <a class="anchor" href="#cyclicbarrier">#</a>
</h3>
<pre><code>    # 满了一起放行, 场景如I/O批量消费
    new CyclicBarrier(4, ()-&gt;{})
    await()
</code></pre>
<h3 id="phaser">
  Phaser
  <a class="anchor" href="#phaser">#</a>
</h3>
<pre><code>    # 阶段批量执行过滤
    class MyPhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch(phase) {
                case 0:
                    print(&quot;arrived&quot; + registeredParties);
                    return false;
                case 1:
                    print(&quot;eated&quot; + registeredParties);
                    return false;
                case 2:
                    print(&quot;hugged&quot; + registeredParties);
                    return true;
                default:
                    return true;
            }
        }
    }
    Person implements Runnable {
        private int i;
        public Person(int i) {
            this.i = i;
        }
        public void arrive() {
            phaser.arriveAndAwaitAdvance();
        }
        public void eat() {
            phaser.arriveAndAwaitAdvance();
        }
        public void hug() {
            if (i == 0 || i == 1) {
                phaser.arriveAndAwaitAdvance();
            } else {
                phaser.arriveAndDeregister();
            }
        }

        @Override
        public void run() {
            arrive();
            eat();
            hug();
        }
    }
    phaser = new MyPhaser();
    phaser.bulkRegister(5);
    for (int i = 0; i &lt; 5; i++) {
        new Thread(new Person(i)).start()
    }
</code></pre>
<h3 id="readwritelock">
  ReadWriteLock
  <a class="anchor" href="#readwritelock">#</a>
</h3>
<pre><code>    # 读锁是共享锁，不能写，悲观锁
    # 写锁是排他锁，不能读写
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    void read(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    void write(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    for (int i =0; i&lt;10;i++) {
        new Thread(()-&gt;read(readLock)).start();
    }
    for (int i =0; i&lt;2; i++) {
        new Thread(()-&gt;write(writeLock)).start();
    }
</code></pre>
<h3 id="stampedlock">
  StampedLock
  <a class="anchor" href="#stampedlock">#</a>
</h3>
<pre><code>    # 读时允许写，读完判断不一致再读一遍，乐观锁
</code></pre>
<h3 id="semaphore">
  Semaphore
  <a class="anchor" href="#semaphore">#</a>
</h3>
<pre><code>    # 信号量, 限流同时运行, 用于线程间同步。可设置公平
    Semaphore s = new Semaphore(1, true)
    new Thread(() -&gt; {
        s.acquire();
        s.release()
    })
</code></pre>
<h3 id="exchanger">
  Exchanger
  <a class="anchor" href="#exchanger">#</a>
</h3>
<pre><code>    # 线程间通信, 阻塞交换
    exchange()
</code></pre>
<h3 id="locksupport">
  LockSupport
  <a class="anchor" href="#locksupport">#</a>
</h3>
<pre><code>    # 线程间通信，非锁阻塞，指定线程唤醒
    # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1)
    Thread t = new Thread(() -&gt; {
        for (int i = 0; i &lt; 10; i++) {
            if (i == 5) {
                LockSupport.park();
            }
        }
    })
    t.start();
    TimeUnit.SECONDS.sleep(1);
    LockSupport.unpark(t);
</code></pre>
<h1 id="线程及线程池">
  线程及线程池
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e5%8f%8a%e7%ba%bf%e7%a8%8b%e6%b1%a0">#</a>
</h1>
<h2 id="使用注意">
  使用注意
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%b3%a8%e6%84%8f">#</a>
</h2>
<pre><code>为什么不用Executors线程池
    用LinkedBlockingQueue超数量OOM
    拒绝策略
    线程命名
</code></pre>
<h2 id="类">
  类
  <a class="anchor" href="#%e7%b1%bb">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    Object
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wait</span>()                              <span style="color:#960050;background-color:#1e0010">#</span> 释放synchronized锁并加入等待队列<span style="color:#960050;background-color:#1e0010">，</span>唤醒后执行需要得到synchronized锁
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">notify</span>()                            <span style="color:#960050;background-color:#1e0010">#</span> 只唤醒<span style="color:#960050;background-color:#1e0010">，</span>不释放当前synchronized锁
</span></span><span style="display:flex;"><span>    Thread
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">currentThread</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">sleep</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">yield</span>()                      <span style="color:#960050;background-color:#1e0010">#</span> 让出CPU, 进Ready队列
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>        getState()
</span></span><span style="display:flex;"><span>        join()                              <span style="color:#960050;background-color:#1e0010">#</span> 等待结束
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setDaemon</span>()                         <span style="color:#960050;background-color:#1e0010">#</span> 是否后台
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setPriority</span>(Thread.<span style="color:#a6e22e">NORM_PRIORITY</span>)   <span style="color:#960050;background-color:#1e0010">#</span> 优先级<span style="color:#960050;background-color:#1e0010">，</span>没有用
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Runnable</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Callable</span>
</span></span><span style="display:flex;"><span>        V <span style="color:#a6e22e">call</span>() <span style="color:#66d9ef">throws</span> Exception
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Future</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">get</span>()
</span></span><span style="display:flex;"><span>        get(<span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>        cancel(<span style="color:#66d9ef">boolean</span>)
</span></span><span style="display:flex;"><span>        isCanceled()
</span></span><span style="display:flex;"><span>        isDone()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">RunnableFuture</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FutureTask</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CompletableFuture</span>         <span style="color:#960050;background-color:#1e0010">#</span> parallel
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">supplyAsync</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">allOf</span>(CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>...)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">anyOf</span>(CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>...)
</span></span><span style="display:flex;"><span>            T <span style="color:#a6e22e">join</span>()
</span></span><span style="display:flex;"><span>            CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenApply</span>()
</span></span><span style="display:flex;"><span>            CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenAccept</span>(Consumer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ThreadFactory</span>
</span></span><span style="display:flex;"><span>        Thread <span style="color:#a6e22e">newThread</span>(Runnable)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DefaultThreadFactory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Executor</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ExecutorService</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">shutdown</span>()
</span></span><span style="display:flex;"><span>            shutdownNow()
</span></span><span style="display:flex;"><span>            isShutdown()
</span></span><span style="display:flex;"><span>            isTerminated()
</span></span><span style="display:flex;"><span>            awaitTermination(<span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            Future <span style="color:#a6e22e">submit</span>(Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>            Future <span style="color:#a6e22e">submit</span>(Runnable, T)                     <span style="color:#960050;background-color:#1e0010">#</span> 手动设个result
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">submit</span>(Runnable)
</span></span><span style="display:flex;"><span>            invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>            invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>            invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">abstract</span> AbstractExecutorService
</span></span><span style="display:flex;"><span>                RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">newTaskFor</span>(Runnable, T)
</span></span><span style="display:flex;"><span>                RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">newTaskFor</span>(Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>                T <span style="color:#a6e22e">doInvokeAny</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">boolean</span> timed, <span style="color:#66d9ef">long</span>)
</span></span><span style="display:flex;"><span>                submit()
</span></span><span style="display:flex;"><span>                invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 忽略CancellationException, ExecutionException<span style="color:#960050;background-color:#1e0010">，</span>其它异常抛出并取消未完成任务
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">invokeAll</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 忽略CancellationException, ExecutionException, TimeoutException<span style="color:#960050;background-color:#1e0010">，</span>其它异常抛出并取消未完成任务
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">invokeAny</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>                invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutor</span>                    <span style="color:#960050;background-color:#1e0010">#</span> 线程池<span style="color:#f92672">+</span>任务队列
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 任务顺序: 核心线程, 任务队列<span style="color:#960050;background-color:#1e0010">，</span>起新线程<span style="color:#960050;background-color:#1e0010">，</span>拒绝策略
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>       <span style="color:#960050;background-color:#1e0010">#</span> 用DelayedWorkQueue
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">scheduleAtFixedRate</span>(()<span style="color:#f92672">-&gt;</span>{}, <span style="color:#66d9ef">int</span> initial, <span style="color:#66d9ef">int</span> period, TimeUnit)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForkJoinPool</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">execute</span>(ForkJoinTask)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ScheduledExecutorService</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">[</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CompletionService</span>                             <span style="color:#960050;background-color:#1e0010">#</span> 不阻塞全部任务<span style="color:#960050;background-color:#1e0010">，</span>已有结果入队列
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">poll</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExecutorCompletionService</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Executors</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newSingleThreadExecutor</span>()                           <span style="color:#960050;background-color:#1e0010">#</span> 为了用任务队列和生命周期管理
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newCachedThreadPool</span>()                               <span style="color:#960050;background-color:#1e0010">#</span> 超时60s, max为MAX_VALUE, 任务不堆积场景
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newFixedThreadPool</span>()
</span></span><span style="display:flex;"><span>        newScheduledThreadPool()                            <span style="color:#960050;background-color:#1e0010">#</span> AbstractQueuedSynchronizer
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newWorkStealingPool</span>()                               <span style="color:#960050;background-color:#1e0010">#</span> ForkJoinPool, go的M,G,P
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span> 每个线程单独队列, 尾部偷加尾部
</span></span></code></pre></div><h2 id="创建线程">
  创建线程
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b">#</a>
</h2>
<pre><code># 继承
class MyThread extendws Thread {
    @Override
    public void run(){}
}
new MyThread().start();

# 组合
class MyRun implements Runnable {
    @Override
    public void run(){}
}
new Thread(new MyRun()).start();

# 返回值
class myCall implements Callable&lt;String&gt; {
    @Override
    public String call(){}
}
FutureTask = ft = new FutureTask&lt;String&gt;(new MyCall())
new Thread(ft).start();
ft.get();

# 线程池
// execute无返回值
ExecutorService service = Executors.newCachedThreadPool()
service.execute(()-&gt;{});
// submit有返回值 
Future&lt;String&gt; f = service.submit(new MyCall());
service.shutdown();
</code></pre>
<h2 id="线程状态">
  线程状态
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81">#</a>
</h2>
<pre><code>NEW
RUNNABLE            # 可调度
    READY
    RUNNING
WAITING             # 等待唤醒，忙等待(一直占CPU)
    o.wait()
    t.join()
    LockSupport.park()
    Lock.lock()

    o.notify()
    o.notifyAll()
    LockSupport.unpark()
    Lock.unlock()
TIMED WAITING
    Thread.sleep(time)
    o.wait(time)
    t.join(time)
    LockSupport.parkNanos()
    LockSupport.parkUntil()
BLOCKING            # 阻塞等待（不占CPU但经过OS调度)
    synchronized
TERMINATED
</code></pre>
<h2 id="线程打断">
  线程打断
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%89%93%e6%96%ad">#</a>
</h2>
<pre><code>方法 
    interrupt()                 # 设置打断标记位
    isInterrupted()             # 检查标记位
    static interrupted()        # 检查当前线程标记位，并重置
检测当前线程打断标记的方法      # 抛异常并重置
    Thread.sleep()
    o.wait();
    o.join();
    ReentrantLock
        lockInterruptibly()
不检测当前线程打断标记的方法
    synchronized                # 不是代码实现检测不了
    ReentrantLock
        lock()
强制打断
    Thread
        stop()                  # 已废弃, 立即释放所有锁
        suspend()               # 已废弃，强制暂停，所有锁不释放容易死锁
        resume()                # 已废弃，强制恢复
volatile
    判断数字不准，有同步的时间延迟, interrupt()也有延迟
    也需要代码中判断, 但interrupt()有wait()等系统方法支持
</code></pre>
<h2 id="线程间通信">
  线程间通信
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1">#</a>
</h2>
<h3 id="通知">
  通知
  <a class="anchor" href="#%e9%80%9a%e7%9f%a5">#</a>
</h3>
<pre><code># synchronized wait() notify(), CountDownLatch, LockSupport
volatile List c = new ArrayList();
final Object lock = new Object();
new Thread(() -&gt; {
    synchronized(lock) {
        if (c.size() != 5) {
            lock.wait();
        }
        lock.notify();              // 唤醒t1
    }
}, &quot;t2&quot;).start();

TimeUnit.SECONDS.sleep(1);

new Thread(() -&gt; {
    synchronized(lock) {
        for (int i = 0; i &lt; 10; i++) {
            c.add(new Object());
            if (c.size() == 5) {
                lock.notify();
                lock.wait();        // 让出sychronized锁
            }
        }
    }
}, &quot;t1&quot;).start();
</code></pre>
<h3 id="生产消费">
  生产消费
  <a class="anchor" href="#%e7%94%9f%e4%ba%a7%e6%b6%88%e8%b4%b9">#</a>
</h3>
<pre><code># 优化count可以用CAS加(有ABA问题)
class MyContainer&lt;T&gt; {
    final private List&lt;T&gt; list = new LinkedList&lt;&gt;();
    final private int MAX = 10;
    private int count = 0;

    public synchronized void put(T t) {
        while(list.size() == MAX) {
            this.wait();            // 期间可能有add() 
        }
        list.add(t);
        count++;
        this.notifyAll();           // 应该只唤醒消费者
    }

    public synchronized T get() {
        T t = null;
        while(list.size() == 0) {
            this.wait();
        }
        t = list.removeFirst();
        count--;
        this.notifyAll();           // 应该只唤醒生产者
        return t;
    }
}

# 同步容器, ReentrantLock Condition
private Lock lock = new ReentrantLock();
private Condition producer = lock.newCondition();
private Condition consumer = lock.newCondition();

public void put(T t) {
    try {
        lock.lock();
        while(list.size() == MAX) {
            producer.await();
        }
        list.add(t);
        count++;
        consumer.signalAll();
    } finally {
        lock.unlock();
    }
}

public T get() {
    T t = null;
    try {
        lock.lock();
        while(list.size() == 0) {
            consumer.await();
        }
        t = list.removeFirst();
        count--;
        producer.signalAll();
    } finally {
        lock.unlock();
    }
    return t;
}
</code></pre>
<h1 id="协程">
  协程
  <a class="anchor" href="#%e5%8d%8f%e7%a8%8b">#</a>
</h1>
<pre><code>quasar库                            # 需要设javaagent, 每个fiber生成栈
    fiber =  new Fiber&lt;Void&gt;()
    fiber.start()
</code></pre>
<h1 id="并发api">
  并发API
  <a class="anchor" href="#%e5%b9%b6%e5%8f%91api">#</a>
</h1>
<h2 id="stream">
  Stream
  <a class="anchor" href="#stream">#</a>
</h2>
<pre><code>parallelStream()                    # ForkJoinPool
</code></pre>
<h2 id="threadlocal">
  ThreadLocal
  <a class="anchor" href="#threadlocal">#</a>
</h2>
<pre><code>内部类
    ThreadLocalMap&lt;ThreadLocal, Object&gt;
        # 存在每个线程里。场景如声明式事务拿conn
        # key是弱引用指向ThreadLocal, value是强引用。
    Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        Object value;
        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
方法
    set(T)
内存泄露问题
    ThreadLocal&lt;M&gt; tl = new ThreadLocal();
    tl.set(new M());
    tl = null;
        # threadLocalMap中key弱引用回收, value不回收
    tl.remove();
        # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在
</code></pre>
<h2 id="pipedstream">
  PipedStream
  <a class="anchor" href="#pipedstream">#</a>
</h2>
<pre><code># 效率不高
PipedInputStream
    connect(PipedOutputStream)
    read(byte[])
PipedOutputStream
    write(byte[])
</code></pre>
<h2 id="jmh">
  JMH
  <a class="anchor" href="#jmh">#</a>
</h2>
<pre><code># Java Microbenchmark Harness
概念
    Warmup                              # 预热
    Mesurement                          # 总执行次数
    Timeout                             # 每次执行超时时间
    Threads                             # fork线程数
    Benchmark mode                      # 模式
    Benchmark                           # 方法名
环境变量
    TEMP或TMP                           # JHM临时文件存放
使用
    @Benchmark
    @Warmup(iterations = 2, time = 3)           # 执行2次, 每次隔3秒
    @Fork(5)                                    # 多少线程
    @BenchmarkMode(Mode.Throughput)             # 显示每秒多少次
    @Measurement(iterations = 10, time = 3)     # 共测10次, 每次隔3秒
    public void testA() {

    }
</code></pre>
<h2 id="disruptor">
  Disruptor
  <a class="anchor" href="#disruptor">#</a>
</h2>
<pre><code>介绍
    CAS, 环形数组Buffer
        数组用sequence定位修改快,也避免了头尾加锁
        直接覆盖降低GC
            覆盖前有等待策略
    单机MQ
        发布订阅模式
        观察者模式
    EventFactory
        会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC
使用
    class MyEvent {}
    class MyEventFactory implements EventFactory&lt;MyEvent&gt; {
        @Override
        public MyEvent newInstance() {}
    }
    class MyEventHandler implements EventHandler&lt;MyEvent&gt; {
        @Override
        void onEvent(MyEvent, long sequence, boolean endOfBatch) {}
    }
    class MyExceptionHandler implements ExceptionHandler&lt;MyEvent&gt; {
        @Override
        void handleEventException()
        @Override
        void handleOnStartException()
        @Override
        void handleOnShutdownException()
    }
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(MyEvent::new, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory(), 
        ProducerType.SINGLE, new BlockingWaitStrategy())
        # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁
    // 消费
    disruptor.handleEventsWith(handler1, handler2)
    disruptor.handleEventsWith((event,seq,end)-&gt;{})
    disruptor.handleExceptionsFor(handler1).with(excptionHandler1)

    disruptor.start()

    // 生产
    ringBuffer = disruptor.getRingBuffer()
    sequence = ringBuffer.next()
    event = ringBuffer.get(sequence)
    event.set(&quot;&quot;)
    ringBuffer.publish(sequence)
    translator = new EventTranslator&lt;&gt;() {
        @Override
        void translateTo(event, sequence) {
            event.set(&quot;&quot;)
        }
    }
    ringBuffer.publishEvent(translator)
    ringBuffer.publishEvent((event,seq, &quot;&quot;) -&gt; event.set(l), &quot;&quot;)
等待策略
    BlockingWaitStrategy                # 阻塞直到再次唤醒
    BusySpinWaitStrategy                # 自旋等待
    SleepingWaitStrategy                # sleep等待
    LiteBlockingWaitStrategy            # 同BlockingWaitStrategy减少加锁次数                
    LiteTimeoutBlockingWaitStrategy     # 同LiteBlockingWaitStrategy加超时            
    PhasedBackoffWaitStrategy
    TimeoutBlockingWaitStrategy         # 同BlockingWaitStrategy加超时                
    YieldingWaitStrategy                # 尝试100然后Thread.yield()
</code></pre>
<h1 id="源码分析">
  源码分析
  <a class="anchor" href="#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90">#</a>
</h1>
<h2 id="threadpoolexecutor">
  ThreadPoolExecutor
  <a class="anchor" href="#threadpoolexecutor">#</a>
</h2>
<pre><code>new ThreadPoolExecutor()                    
    int corePoolSize                    # 核心线程数, 永远存活。可设置参与回收
    int maximumPoolSize                 # 最大线程数
    long keepAliveTime                  # 生存时间
    TimeUnit
    BlockingQueue&lt;Runnable&gt;             # 任务队列
    ThreadFactory                       # 线程工厂, 设线程名
    RejectedExecutionHandler            # 拒绝策略
        Abort                           # 抛异常
        Discard                         # 忽略掉
        DiscardOldest                   # 忽略掉排除最久的
        CallerRuns                      # 调用者线程执行, 再多就阻塞
AtomicInteger ctl
    # 高3位线程池状态，低29位线程数量
void execute()
    判断添加核心线程
    放入队列成功
        拒绝或添加非核心线程
    添加非核心线程失败
        拒绝
boolean addWorker(Runable, boolean)
    线程数量加1
    添加Worker
        加锁
        加线程
        启动
class Worker extends AbstractQueuedSynchronizer implements Runnable
    # 本身是AQS锁, 被多任务(线程)访问
    Tread thread
</code></pre>
<h2 id="forkjoinpool">
  ForkJoinPool
  <a class="anchor" href="#forkjoinpool">#</a>
</h2>
<pre><code>abstract class ForkJoinTask
    ForkJoinTask&lt;V&gt; fork()
    V join()
    abstract class RecursiveAction          # 无返回值
        void compute()
    abstract class RecursiveTask            # 有返回值
例子
    class MyTask extends RecursiveTask&lt;Long&gt; {
        int start;
        int end;
        @Override
        Long compute() {
            if (end - start &lt;= MAX_NUM) {
                return sum
            }
            subTask1 = new MyTask(start, mid)
            subTask2 = new MyTask(mid, end)
            subTask1.fork()
            subTask2.fork()
            return subTask1.join() + subTask2.join();
        }
    }
    fjp = new ForkJoinPool()
    task = new MyTask(0, nums.length)
    fjp .execute(task)
    result = task.join()
</code></pre>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/docs/pl/java/jvm/">JVM</a>
    </h2>
    
  <div class="flex align-center text-small book-post-date">
    <img src="/svg/calendar.svg" class="book-icon " alt="" />
    <span>Oct 9, 2018</span>
  </div>



  
  <div class="text-small">
    
      <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
  </div>
  

  


    <p><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>定义
    JVM规范说明书, JVMS(Java Virtual Machine Specifications)
    Java语言规范, JLS(Java Language Specification)
    虚拟机
        指令集
        内存管理
过程
    x.java -&gt; javac -&gt; x.class -&gt; ClassLoader -&gt; (字节码解释器、JIT) -&gt; 执行引擎
JVM语言
    Scala, Kotlin, Groovy, Clojure, jython, jruby等100多个
JVM实现
    HotSpot                 # Oracle官方, 8之后收费, OpenJDK为开源版本
    Jrockit                 # Oracle收购, 合并入HotSpot
    J9                      # IBM
    Microsoft VM
    TaobaoVM                # HotSpot深度定制
    LiquidVM                # 直接匹配专门硬件
    azul zing               # 收费，快, GC1mm, HotSpot参考写的G1
JRE, JDK
    JRE = jvm + core lib
    JDK = JRE + development kit
</code></pre>
<h1 id="jvm构造">
  JVM构造
  <a class="anchor" href="#jvm%e6%9e%84%e9%80%a0">#</a>
</h1>
<h2 id="指标">
  指标
  <a class="anchor" href="#%e6%8c%87%e6%a0%87">#</a>
</h2>
<pre><code>吞吐量: 代码时间 / (代码时间 + GC时间)
响应时间: STW越短, 响应时间越好
</code></pre>
<h2 id="指令instructions">
  指令(Instructions)
  <a class="anchor" href="#%e6%8c%87%e4%bb%a4instructions">#</a>
</h2>
<pre><code>分类
    基于栈的指令类          # 简单, HotSpot
    基于寄存器的指令集      # 复杂但快, HotSpot局部变量表
8大原子操作(JSR-133已放弃这个描述，但指令没变化)
    lock                    # 主内存，标识变量线程独占
    unlock                  # 主内存，解锁独占
    read                    # 主内存，读到工作内存
    load                    # 工作内存，read后的值放入线程本地变量副本
    use                     # 工作内存，传值给执行引擎
    assign                  # 工作内存，执行引擎结果赋值给线程本地变量 
    store                   # 工作内存，存值到主内存给write备用
    write                   # 主内存，写变量值
方法指令                    # 在methods的Code中罗列
    aload_0                 # 变量表第0项入栈
    invokespecial #1        # 调private(无多态)的方法
    invokevirtual           # 调有多态可能性的方法
    invokestatic            # 调静态方法
    invokeinterface         # 调interface方法
    invokedynamic           # 1.7加入，定义类似函数指针时生成(但每个函数都创建了类)
        调用动态产生的类
            lambda
            反射
            scala等JVM语言
            CGLib ASM
        组成
            bootstrapMethod
            方法签名
        &lt;1.8的bug           # 类产生于Perm Space，内存不回收
            for(;;) {I j = C::n;}
    return                  # 方法返回
    bipush 8                # byte扩展成int类型，放到方法栈中
    sipush 200              # short
    istore_1                # 出栈，放到下标为1的局部变量表
    iload_1                 # 局部变量表下标1位置值压栈
    iinc 1 by 1             # 局部变量表1位置值+1
    iadd                    # 出栈两个，相加压栈
    new                     # new对象, 地址压栈
    dup                     # 复制栈顶并压栈
    pop                     # 弹出栈顶
    if_icmpne 7             # int值比较，不等时跳到第7条指令
    mul                     # 乘法
    sub                     # 减法
</code></pre>
<h2 id="class结构">
  class结构
  <a class="anchor" href="#class%e7%bb%93%e6%9e%84">#</a>
</h2>
<h3 id="工具">
  工具
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7">#</a>
</h3>
<pre><code>javap -v a.class
jetbrain jclasslib
jetbrain BinEd
JBE                         # 可编辑
</code></pre>
<h3 id="二进制">
  二进制
  <a class="anchor" href="#%e4%ba%8c%e8%bf%9b%e5%88%b6">#</a>
</h3>
<pre><code>Magic Number(4字节)
    cafe babe
Minor Version(2字节)        # 小版本
Major Version(2字节)        # 大版本
    JDK1.7是51.0
    JDK1.8是52.0
constant_pool_count(2字节)
    # 长度constant_pool_count-1的表
constant_pool               # 索引、tag、类型
    1 CONSTANT_Utf8_info                        # 存一些描述字符串
    2 标记
    3 CONSTANT_Integer_info
    4 CONSTANT_Float_info
    5 CONSTANT_Long_info
    6 CONSTANT_Double_info
    7 CONSTANT_Class_info
    8 CONSTANT_String_info
    9 CONSTANT_Fieldref_info                
    10 CONSTANT_Methodref_info                  # 方法引用
        指向CONSTANT_Class_info
        指向CONSTANT_NameAndType_info
    11 CONSTANT_InterfaceMethodref_info
    12 CONSTANT_NameAndType_info                # 方法名与类型
    15 CONSTANT_MethodHandle_info
    16 CONSTANT_MethodType_info
    18 CONSTANT_InvokeDynamic_info
access_flags(2字节)         # bitmap按位与组合
    # class的修饰符
    ACC_PUBLIC 0x0001 public
    ACC_FINAL 0x0010 final
    ACC_SUPER 0x0020 JDK1.0.2之后必须为真, 表示invokespectial用新语义
    ACC_INTERFACE 0x0200 是否接口
    ACC_ABSTRACT 0x0400 抽象类
    ACC_SYNTHETIC 0x1000 编译器自动生成
    ACC_ANNOTATION 0x2000 
    ACC_ENUM 0x2000 
this_class(2字节)
    存名字对应指向常量池序号
super_class(2字节)
    存名字对应指向常量池序号
interfaces_count(2字节)
interfaces
fields_count(2字节)
fields
    access_flags(2字节)
    name_index              # 存常量池索引
    descriptor_index
        byte B
        char C
        double D
        float F
        int I
        long L
        short S
        boolean Z
        void V
        Object Ljava/lang/Object
        数组
            一维数组 [B
            多维数组 [[C
    attributes_count        # 赋加属性
    attributes
methods_count(2字节)
methods
    access_flags(2字节)
    name_index
    descriptor_index        # 先参数列表，后返回值
        void m() -&gt; ()V
        String toString() -&gt; Ljava/lang/String;
    attributes_count
    attributes              # 赋加属性
        Code                # 指令列表, 一般先压栈this(aload_0)
            LineNumberTable
            LocalVariableTable
attributes_count(2字节)
attributes
</code></pre>
<h2 id="agent">
  Agent
  <a class="anchor" href="#agent">#</a>
</h2>
<pre><code>例子
    打包 a.jar
        MANIFEST.MF
            Premain_Class: MyAgent
        public class MyAgent {
            public static Instrumentation inst;
            public static void premain(String agentArgs, Instrumentation _inst) {
                inst = _inst;
            } 
        }
    JVM参数 -javaagent: a.jar
    使用 MyAgent.inst
</code></pre>
<h1 id="jmmjava-memory-model">
  JMM(Java Memory Model)
  <a class="anchor" href="#jmmjava-memory-model">#</a>
</h1>
<h2 id="内存">
  内存
  <a class="anchor" href="#%e5%86%85%e5%ad%98">#</a>
</h2>
<h3 id="运行时区域">
  运行时区域
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8c%ba%e5%9f%9f">#</a>
</h3>
<pre><code># Runtime data areas
分类
    Program Counter             # 程序计数器，下一条指令位置
    Method Area                 # 方法区,线程间共享
        存储
            Class元信息
            代码编译信息, JIT编译信息
            常量池(Runtime Constant Pool)           # 常量池在运行时存放区
        版本区别
            Perm Space(&lt;1.8)    # 要设定大小, 会溢出报错
                存字符串常量
                lambda生成临时类永远存在
                Full GC不清理
            Meta Space(&gt;=1.8)   # 自动大小无上限
                字符串常量位于堆
                会触发Full GC
    JVM stacks                  # 线程栈 
        Frame(栈帧)             # 一个方法一个栈帧
            Local Variable Table                # 局部变量表, 方法内的局部变量，值在常量池
                默认第0个为this
            Operand Stack                       # 操作数栈
            Dynamic Linking                     # 指向调用方法的 运行时常量池的符号连接
            return address                      # 当前方法执行完的返回地址
    Native Method Stacks        # C/C++方法栈
    Direct Memory               # 直接内存
    Heap                        # 堆, 线程间共享
</code></pre>
<h3 id="屏障">
  屏障
  <a class="anchor" href="#%e5%b1%8f%e9%9a%9c">#</a>
</h3>
<pre><code>CPU屏障
JVM规范
    LoadLoad                # 上load和下load不能重排
    StoreStore
    LoadStore
    StoreLoad               # 最强
</code></pre>
<h2 id="对象">
  对象
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1">#</a>
</h2>
<h3 id="对象内存存储">
  对象内存存储
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1%e5%86%85%e5%ad%98%e5%ad%98%e5%82%a8">#</a>
</h3>
<pre><code>普通对象
    对象头: markword 8字节
    ClassPointer            # 指向Class对象, 启用压缩4字节，不启用8字节
    实例数据
        引用类型            # 启用压缩4字节，不启用8字节
    Padding: 对齐8的倍数
数组对象
    对象头
    ClassPointer
    数组长度4字节
    数组数据
    Padding
对象头
    # 32位64位(25位没用到)，内容不同
    锁标志位2位             # 根据锁标志位判断存储内容
        01 无锁/偏向锁
        00 轻量级锁
        10 重量级锁
        11 GC标记
    是否偏向锁1位
    剩余位 
        无锁状态
            对象hashCode(25位或31位)
                没重写过时默认计算(System.identityHashCode())
                重写过的hashCode()结果不存在这里
            分代年龄
        轻量级锁
            指向栈中锁记录的指针
        重量级锁
            指向互斥量（重量级锁）的指针
        偏向锁
            线程ID 23位
            Epoch 2位
            分代年龄4位(所以分代年龄只有15)
    其它问题
        对象计算过hashCode，对象不能进入偏向锁状态(位已经被占了)
实验工具 javaagent
</code></pre>
<h3 id="对象定位">
  对象定位
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1%e5%ae%9a%e4%bd%8d">#</a>
</h3>
<pre><code>句柄池                      # 指向句柄，句柄有对象指针和class指针, 三色标记GC提高效率
直接指针                    # 指向对象，对象指class, HotSpot使用
</code></pre>
<h2 id="并发">
  并发
  <a class="anchor" href="#%e5%b9%b6%e5%8f%91">#</a>
</h2>
<h3 id="硬件层数据一致性">
  硬件层数据一致性
  <a class="anchor" href="#%e7%a1%ac%e4%bb%b6%e5%b1%82%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7">#</a>
</h3>
<pre><code>硬件结构
    L0寄存器                # 1 cycles
    L1高速缓存              # 3-4 cycles, 1ns
    L2高速缓存              # 10 cycles, 3ns
    L3高速缓存              # 40-45 cycles, 15ns, 在主板
    (QPI总线传输)           # 20ns
    L4主存                  # 60-80ns
    L5磁盘
    L6远程文件存储
数据不一致                  # 从L2多CPU开始
    锁总线(bus lock)
    CPU缓存一致性协议(如intel MESI)
</code></pre>
<h3 id="volatile">
  volatile
  <a class="anchor" href="#volatile">#</a>
</h3>
<pre><code>工具
    hsdis                   # HotSpot Dis Assembler, 虚拟机字节码对应汇编
bytecode
    ACC_VOLATILE
JVM
    StoreStoreBarrier
    volatile写操作          # 上边写完再写，写完下边再读，写一致
    StoreLoadBarrier

    LoadLoadBarrier
    volatile读操作          # 上边读完再读，读完下边再写，读一致
    LoadStoreBarrier
OS
    windows
        lock
    linux
        上下屏障，最后lock
</code></pre>
<h3 id="synchronized">
  synchronized
  <a class="anchor" href="#synchronized">#</a>
</h3>
<pre><code>bytecode
    方法修饰
        synchronized
    代码
        monitorenter
        monitorexit
JVM
    C/C++实现，会调用OS的同步机制
OS
    lock
</code></pre>
<h3 id="happens-before原则">
  happens-before原则
  <a class="anchor" href="#happens-before%e5%8e%9f%e5%88%99">#</a>
</h3>
<pre><code># Java要求指令不能重排的几种情况
</code></pre>
<h3 id="as-if-serial">
  as if serial
  <a class="anchor" href="#as-if-serial">#</a>
</h3>
<pre><code># 不管如何重排序，单线程执行结果不变
</code></pre>
<h1 id="过程">
  过程
  <a class="anchor" href="#%e8%bf%87%e7%a8%8b">#</a>
</h1>
<h2 id="编译">
  编译
  <a class="anchor" href="#%e7%bc%96%e8%af%91">#</a>
</h2>
<pre><code>过程
    代码 -&gt; bytecode -&gt; JVM指令 -&gt; OS指令
解释器(bytecode intepreter)
JIT(Just In-Time compiler)
混合模式
    解释器 + 热点代码编译
    热点代码检测
        方法计数器
        循环计数器
</code></pre>
<h2 id="加载">
  加载
  <a class="anchor" href="#%e5%8a%a0%e8%bd%bd">#</a>
</h2>
<pre><code>HotSpot C++代码加载
    class对象加载到MethodArea
        metaspace(JDK1.8)
        permGeneration(JDK1.8之前)
class加载过程
    loading                 # 读到内存
    linking
        verification        # 校验
        preparation         # 静态变量赋默认值
        resolution          # 解析, loadClass()可指定是否解析。常量池的符号引用转换成内存地址引用
    initializing            # 静态变量赋初始值，执行静态代码
对象加载
    new过程
        class加载
        申请对象内存
        成员变量赋默认值
        调用构造方法&lt;init&gt;
            成员变量顺序赋初始值
            执行构造方法语句(先super)
双亲委派                
    过程
        类名一层层向上找
        找不到时，一层层找再向下委派找
        都不能加载时, 抛ClassNotFound
    为什么
        安全, 自定义类不能覆盖
        已加载不用重复加载
    父加载器
        不是类加载器的加载器
        不是父类
        是组合的parent对象
    打破
        为什么                    
            JDK1.2之前都重写loadClass()
            thread.setContextClassLoader()指定线程上下文classLoader
            热启动/热部署(OSGi tomcat)加载同一类不同版本
        做法
            重写loadClass(), new多个ClassLoader
类加载器
    Bootstrap               # 加载核心类 lib/rt.jar charset.jar等, C++实现所以get时为null
        如加载String
    Extension               # 加载扩展jar jre/lib/ext/*.jar, 由-Djava.ext.dirs指定
    App                     # 加载classpatch指定内容
    Custom ClassLoader      # 自定义ClassLoader
加载路径环境变量            # 来自Launcher源码
    Bootstrap.ClassLoader   sun.boot.class.path
    ExtensionClassLoader    java.ext.dirs
    AppClassLoader          java.class.path
API
    Class
        getClassLoader()
    ClassLoader             # findInCache() -&gt; parent.loadClass() -&gt; findClass()
        private final ClassLoader parent
        loadClass           # 热加载
    Launcher
        $AppClassLoader
        $ExtClassLoader
自定义类加载器
    class MyClassLoader extends ClassLoader {
        @Override
        Class findClass(String) {
            return defineClass()
        }
    }
懒加载                      # JVM未规定什么时候加载,但规定了什么时候初始化
初始化
    new getstatic putstatic invokestatic指令，访问final变量除外
    java.lang.reflect对类进行反射调用
    初始化子类时，父类首先初始化
    虚拟机启动时，被执行的主类
    动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic, REF_putstatic, REF_invokestatic的方法句柄时, 该类初始化
</code></pre>
<h2 id="gc">
  GC
  <a class="anchor" href="#gc">#</a>
</h2>
<h3 id="引用方式强软弱虚">
  引用方式(强软弱虚)
  <a class="anchor" href="#%e5%bc%95%e7%94%a8%e6%96%b9%e5%bc%8f%e5%bc%ba%e8%bd%af%e5%bc%b1%e8%99%9a">#</a>
</h3>
<pre><code>软引用
    # 内存不够用时回收，用做缓存
    # -Xms20M -Xmx20M
    SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024*1024*10]);
    System.gc();
    m.get();
    new byte[1024*1024*15]
    m.get();
弱引用
    # 只要gc就回收，用做容器如WeakHashMap(key是弱引用), ThreadLocalMap的key
    WeakReference&lt;M&gt; m = new WeakReference&lt;&gt;(new M());
    System.gc();
    m.get();
虚引用
    # 值被回收时放入队列来通知, 用来触发回收堆外内存(用Unsafe的freeMemory())
    # 如NIO的直接内存DirectByteBuffer
    PhantomReference&lt;M&gt; r = new PhantomReference&lt;&gt;(new M(), QUEUE);
    r.get() // 自己写永远返回null                     
</code></pre>
<h3 id="对象分配过程">
  对象分配过程
  <a class="anchor" href="#%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d%e8%bf%87%e7%a8%8b">#</a>
</h3>
<pre><code>向栈分配                # 不要调参数
    好处
        不必GC
    条件
        线程私有小对象
        无逃逸
        可标量替换(基本类型替换整个对象)
过大，分配到老年代
线程本地分配            # TLAB(Thread Local Allocation Buffer), 不要调参数
    好处
        为了减少线程争用
    条件
        小对象
        占用eden, 默认每个线程占1%
伊甸区
s1,s2
    次数                   # 最大15(对象头上空间决定)
        Parallel Scavenge 15
        CMS 6
        G1 15
    动态年龄
        eden + s1 复制到s2, 超过s2总内存一半时，年龄最大的对象进入老年代
    分配担保
        YGC时survivor区空间不够, 直接进入老年代
GC清除或到老年代
</code></pre>
<h3 id="gc分代过程">
  GC分代过程
  <a class="anchor" href="#gc%e5%88%86%e4%bb%a3%e8%bf%87%e7%a8%8b">#</a>
</h3>
<pre><code>YGC -&gt; s0
YGC, eden + s0 -&gt; s1
    年龄足够 -&gt; old
    s区装不下 -&gt; old
YGC, eden + s1 -&gt; s0
old满了 -&gt; FGC
</code></pre>
<h3 id="常见的回收器">
  常见的回收器
  <a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%9b%9e%e6%94%b6%e5%99%a8">#</a>
</h3>
<pre><code>概念
    Safe Point              # STW时机
    没有无STW的回收器
分代
    Young
        Serial              # 第一个GC
            STW, 单线程串行回收
        Parallel Scavenge
            STW, 并行回收
        ParNew              # Parallel New
            增强PS, 以配合CMS并行回收, CMS到某阶段时PN运行
    Old
        Serial Old
            特点
                适用几十M
                mark-sweep-compact，单线程
        Parallel Old
            特点
                适用几个G
                mark-sweep-compact，多线程
        CMS                 # concurrent mark sweep, 1.4后期引入, JDK11取消
            特点
                适用20G
                多线程并行回收, 并发回收(GC与程序同时运行)，降低STW时间(200ms)
            不足            # 问题多，没有版本默认CMS
                浮动垃圾
                碎片多，新对象分配不下时，使用SerialOld
                    设低GC阈值回收浮动垃圾
            清理过程
                初始标记(initial mark)
                    STW, 单线程, 标记根对象
                [预标记]                        # Card Marking, 把Card标为Dirty
                并发标记(concurrent mark)
                    不STW, 多线程, 执行多次
                重新标记(remark)                # 处理并发标记过程中的变化
                    STW, 多线程, 
                并发清理(concurrent sweep)      # 过程中产生的浮动垃圾, 下次回收
                    不STW, 多线程, 
                [整理阶段]
            日志
                [GC(Allocation Failure)[ParNew:6144K-&gt;640K(6144K)], 0.02 secs] 6585K-&gt;2770K(19840K),0.02 secs][Times:user=0.02 sys=0.00, real=0.02 secs]
                    6144K-&gt;640K(6144K): 回收前 回收后 总容量
                    6585K-&gt;2770K(19840K): 堆回收前 回收后 总大小  

                [GC (CMS Initial Mark)]
                    [1 CMS-initail-mark]
                [CMS-concurrent-mark-start]
                [CMS-concurrent-preclean-start]
                [GC (CMS Final Remark)]
                    [YG occupancy]              # 清理后年轻代占用及容量
                    [Rescan(parallel)]          # STW下标记存活对象
                    [weak refs processing]      # 弱引用处理
                    [class unloading]           # 卸载用不到的class
                    [scrub symbol table]        # 清理常量池
                    [scrub string table]        # 清理常量池
                    [1 CMS-remark]              # 清理后老年代占用及容量
                [CMS-concurrent-sweep-start]
                [CMS-concurrent-reset-start]

不分代
    G1                      # Garbage First, 1.7引入, 1.8完善, 1.9默认
        特点
            适用上百G
            STW 10ms回收
                容易预测STW时间
                低latency, 但throughput也低
            并发回收, 三色标记
            只逻辑分代, 不物理分代 
                内存分Region, Region组成不同大小块，块在逻辑分代中
                Eden和Old区的内存映射会变化
            动态新老代空间                      # 如果YGC频繁，就Young调大
                不要手工指定, 是G1预测YGC停顿时间的基准, 停顿时间通过参数设置
        概念
            CSet            # Collection Set
                可回收Region集合, 回收时存活的对象被移动
                占堆空间不到1%
            RSet            # Remembered Set
                用于找到谁引用当前对象(对象级别), 记录其他Region的引用
                赋值时有GC写屏障                # 非内存屏障
            CardTable       # YGC定位垃圾，要从Root查所有Old区对象，效率低
                Old区对象引用Young区时, bitmap标DirtyCard。YGC时只扫描DirtyCard
            MixedGC         # 默认45%, 同CMS
                初始标记
                重新标记
                筛选回收    # 筛选Region回收，有用对象复制到其它Region
        日志
            [GC pause (G1 Evacuation Pause) (young) (initial-mark)]         # 复制存活对象, initial-mark在MixedGC时有
            [GC concurrent-root-region-scan-start]                          # 混合回收
            [GC concurrent-mark-start]                                      # 混合回收
            [Full GC (Allocation Failure)]                                  # 无法evacuation时, G1中很严重
    ZGC                     # JDK11, 不分代(SingleGeneration)
        特点
            STW设计10ms, 实际1ms
            适用4T（JDK13 16T）
            内存分块（有大有小）
        概念
            没有RSet, 改进了SATB指针
    Shenandoah              # JDK11
    Epsilon                 # JDK11, debug用
    Zulu
组合
    S + SO
    PS + PO                 # 1.8默认, 10G内存10+秒
    PN + CMS
</code></pre>
<h3 id="算法">
  算法
  <a class="anchor" href="#%e7%ae%97%e6%b3%95">#</a>
</h3>
<pre><code>定位
    引用计数(ReferenceCount)
        循环引用问题        # 内部互相引用，没有外部引用
    根可达算法(RootSearching)
        线程栈变量 
        静态变量
        常量池
        JNI指针             # 本地方法用到的对象
并发标记
    三色标记
        白                  # 未被标记
        灰                  # 自身被遍历到，成员变量未被遍历到
        黑                  # 自身、成员变量都被遍历到
        漏标问题 
            两个必要条件 
                黑引用白后，灰对白的引用断开
            算法
                incremental update                      # 增量更新，关注引用的增加, CMS用的
                    增加引用后，标记为灰, 重新标记阶段再扫描
                    缺点是灰色还要重新扫描
                SATB snapshot at the beginning          # 关注引用的删除, G1用的
                    开始时快照, 引用消失时，引用推到堆栈, 下次扫描还扫白色对象
                    优点是只扫描修改过的对象, 看RSet中有没有引用
    颜色指针                # 信息记在指针里
    租户隔离, Session Base GC           # Web专用, 基于session, session断开后删除
    各GC应用
        CMS
            三色标记 + Incremental Update
        G1
            三色标记 + SATB
        ZGC
            颜色指针 + 写屏障
        Shenandoah
            颜色指针 + 读屏障
清除
    标记清除(Mark-Sweep)    # 一遍标记，一遍清理, 适合老年代
        算法简单，戚对象多时效率高
        两遍扫描效率低，容易产生碎片
    拷贝(Copying)           # 存活对象copy到新内存, 旧内存直接清理，适合伊甸区(新生代)
        适用存活对象少的情况
        内存减半
    标记压缩(Mark-Compact)  # 有用的填到前边去空隙去, 适合老年代
        不会碎片，不会内存减半
        扫描两次，还要移动
分代模型
    分代模型                # -Xms -Xmx设置大小
        new/young(新生代)   # MinorGC/YGC, -Xmn设置大小, 默认占比1
            eden(伊甸)      # 默认占比8
            survivor x 2    # 默认每个占比1
        old(老年代)         # MajorGC/FullGC, 1.8默认占比2, 之前是3
            tenured(终身)
        methodArea          # 1.7永久代, 1.8元数据区
    各JVM的分代模型
        Epsilon ZGC Shenandoah不是分代模型
        G1是逻辑分代，物理不分代
        其他都是逻辑分代 + 物理分代
</code></pre>
<h1 id="调优tuning">
  调优(Tuning)
  <a class="anchor" href="#%e8%b0%83%e4%bc%98tuning">#</a>
</h1>
<pre><code>前提
    从业务场景开始
    无监控(能压测), 不调优
目标
    减少FGC
    确定倾向                        # 吞吐量, 或响应时间
        吞吐量好: PS + PO
        响应时间好: G1 或 PN + CMS  # G1吞吐量少10%
组成部分
    JVM预规划
    优化JVM运行环境(慢、卡顿)
    解决JVM运行时出现的问题(OOM)
步骤
    熟悉业务场景
        响应时间
        吞吐量
    选择回收器组合
    计算内存需求(小的快，大的少gc)
    选CPU
    设定年代大小、升级年龄
    设定日志参数
    观察日志情况
</code></pre>
<h2 id="问题分析">
  问题分析
  <a class="anchor" href="#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#</a>
</h2>
<h3 id="工具-1">
  工具
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7-1">#</a>
</h3>
<pre><code>CPU经常100%
    top查进程CPU(top)
    进程中线程CPU(top -Hp)
    导出该线程堆栈(jstack)
    查哪个方法(栈帧)消耗时间(jstack)
内存高
    导出堆内存(jmap)
    分析(jhat jvisualvm mat jprofiler ...)
监控JVM
    jstat jvisualvm jprofiler arthas top ...
    网管: Ansible
流程
    网管报警
    top -Hp 进程号
    jstack 进程号               # 列出所有线程号, 线程状态
        WAITING, 一直等不到, BLOCKED, 拿不到锁
        waiting on &lt;0x0000&gt; (a java.lang.Object)    # 找到目标等待的线程
    jstack -l 16进制线程号      
    jps
    jinfo 进程号                # 列JVM信息
    jstat -gc 进程号 500        # 每500ms打印一次gc信息
    jmap -histo 进程号 | head -20                   # 列所有对象
        有性能消耗，但不很高，可以在线执行
    jmap -dump:format=b, file=x pid                 # 导出转储文件
        内存特别大时，jmap会卡顿
        多个服务器可用，停一个不影响
        设定HeapDumpOnOutOfMemoryError产生堆转储文件                 
        在线定位(中小型公司用不到)
    jhat -J-mx512M x.hprof      # 分析堆dump文件, 有OQL
    arthas                      # 在线定位
        启动
            java -jar arthas-boot.jar
        常用命令                # 没有集成jmap功能
            jvm                 # jinfo
            thread              # jstack
                thread 1
            dashboard           # top
            heapdump            # jmap -dump
            dump
            redefine            # 热替换
                目前只能改method实现，不能改方法名与属性
            jad                 # 反编译类
                看动态代理生成的类
                看第三方类
                看版本
            sc                  # search class, 显示class信息
            watch               # watch method
    MAT                         # 分析dump文件
    jprofiler
    jconsole                    # 需要JMX
        JMX会消耗性能生产服务器不开
        JMX图形界面只用于压测
    jvisualVM                   # 需要JMX, 可分析dump文件
</code></pre>
<h3 id="内存-1">
  内存
  <a class="anchor" href="#%e5%86%85%e5%ad%98-1">#</a>
</h3>
<pre><code>现象
    OOM崩溃
    CPU飙高, 不断FGC
线程池不当运用
加内存反而卡顿
    GC, 应该用CMS或G1替换 PS+PO
JIRA不停FGC, 没定位出来
    扩内存到50G, GC换G1, 重启
tomcat server.max-http-header-size过大
    默认4096, 每个请求都分配
lambda表达式导致方法区溢出
    java.lang.OutofMemoryError: Compressed class space
disruptor不释放缓存
使用Unsafe分配内存, 直接内存溢出
-Xss设定小, 栈溢出
重写finalize()引发GC
    finalize()耗时长, GC时回收不过来，不停GC
内存不到10%，频繁FGC
    有人显式调用System.gc()                         # 不定时调，但会频繁调
大量线程, native thread OOM
    减少堆空间，留更多系统内存产生native thread
G1产生FGC
    降低MixedGC触发的阈值       # 默认45%
    扩内存
    提高CPU                     # 回收快
</code></pre>
<h2 id="hotspot参数">
  HotSpot参数
  <a class="anchor" href="#hotspot%e5%8f%82%e6%95%b0">#</a>
</h2>
<pre><code>辅助
    -XX:+PrintCommandLineFlags -version             # 打印启动参数, -version是随便一个命令
    -XX:+PrintFlagsFinal -version                   # 打印所有XX参数
    -XX:+PrintFlagsInitial      # 打印默认参数
    -XX:+PrintVMOptions         # 显示VM启动参数
    -                           # 标准参数
    -X                          # 显示非标参数
    -XX                         # 显示不稳定参数
内存
    -XX:+HeapDumpOnOutOfMemoryError                 # OOM时产生堆转储文件 
    -Xms40M                     # 堆起始大小
    -Xmx60M                     # 堆最大大小, 最好和Xms一样以免堆弹大弹小
    -Xmn                        # 年经代
    -Xss                        # 栈空间
    -XX:InitialHeapSize         # 起始堆大小，自动算
    -XX:MaxHeapSize             # 堆最大大小，自动算
内存模型
    -XX:-DoEscapeAnalysis       # 去逃逸分析
    -XX:-EliminateAllocations   # 去标量替换
    -XX:-UseTLAB                # 去tlab
    -XX:TLABSize                # 设置TLAB大小
    -XX:+PrintTLAB
    -XX:MaxTenuringThreshold    # 进老年代（升代）回收次数, 最大值15， CMS默认6，其它默认15
对象和类
    -XX:+UseCompressedClassPointers                 # class指针压缩
        开启时4字节，不开启时8字节
    -XX:+UseCompressedOops                          # 引用类型指针压缩, Ordinary Object Pointers
        开启为4字节，不开启时8字节
    -verbose:class              # 类加载详细过程
    -XX:PreBlockSpin            # 锁自旋次数
编译
    -Xmixed                     # 混合模式
    -Xint                       # 解释模式
    -Xcomp                      # 编译模式
    -XX:CompileThreshold = 10000                    # 检测热点代码次数
GC
    -XX:+PrintGC                # 打印GC信息
    PrintGCDetails              # 打印GC更详细
    PrintGCTimeStamps           # 打印GC时间
    PrintGCCauses               # GC原因
    PrintHeapAtGC
    PrintGCApplicationConcurrentTime                # GC应用程序时间
    PrintCApplicationStoppedTime                    # 打印STW时长
    -XX:+PrintReferenceGC       # 打印回收多少种引用类型
    -XX:+UseConcMarkSweepGC     # 用CMS
    -XX:+DisableExplictGC       # System.gc()不管用

    Parallel常用
        -XX:SurvivorRatio           # 新生代Eden区和Surivor区的比例
        -XX:PreTenureSizeThreshold  # 大对象到底多大
        -XX:+ParallelGCThreads      # 并发线程数, 默认是CPU数
        -XX:+UseAdaptiveSizePolicy  # 自动调所有区比例
    CMS常用
        -XX:ParallelCMSThreads      # 并发线程数，默认是CPU数一半
        -XX:CMSInitiatingOccupancyFraction 92%          # 老年代占多少时触发GC, 1.8 92%, 之前68%
            设小一点，清除浮动垃圾
            过大时，栈分配不下，Promotion Failure，触发FGC
        -XX:+UseCMSCompactAtFullCollection              # GC时压缩，避免碎片片
        -XX:CMSFullGCsBeforeCompaction                  # 多少次GC后压缩
        -XX:+CMSClassUnloadingEnabled                   # 回收方法区
        -XX:CMSInitiatingPermOccupancyFraction          # 到什么比例时进行Perm回收, 1.8之前
        GCTimeRatio                                     # GC占程序运行时间的百分比
        -XX:MaxGCPauseMillis                            # GC停顿时间, CMS会减少年轻代大小
    G1
        -XX:MaxGCPauseMillis                            # STW时间, 区别CMS, G1会调整Young区的块数
        GCTimeRatio
        -XX:GCPauseIntervalMillis                       # STW之间间隔时间
        -XX:+G1HeapRegionSize                           # Region大小, 1 2 4 8 16 32, 逐渐增大, GC间隔更长, 每次GC时间更长
            ZGC是动态调整的
        G1NewSizePercent                                # 新生代最小比例, 默认5%
        G1MaxNewSizePercent                             # 新生代最大比例，默认60%
        ConcGCThreads                                   # GC线程数
        InitiatingHeapOccupancyPercent                  # 启动GC的堆空间占用比例

JMX监控
    -Djava.rmi.server.hostname=192.168.1.1
    -Dcom.sun.management.jmxremote 
    -Dcom.sun.management.jmxremote.port=11111 
    -Dcom.sun.management.jmxremote.authenticate=false 
    -Dcom.sun.management.jmxremote.ssl=false
调优                            # 参数越来越少
    JVM参数800个
    CMS参数300个
    G1参数100个
    ZGC更少
    Zing1个
GC组合参数
    -XX:+UseSerialGC
        S + SO
    -XX:+UseParNewGC                # 已废弃
        PN + SO
    -XX:+UseConc(urrent)MarkSweepGC
        PN + CMS + SO
    -XX:+UseParallelGC               # 1.8默认
        PS + PO
    -XX:+UseParallelOldGC
        PS + PO
    -XX:+UseG1GC
        G1
日志参数
    -Xloggc:/logs/xx-xx-%t.log
    -XX:+UseGCLogFileRotation           # 5个满了，覆盖第一个
    -XX:NumberOfGCLogFiles=5
    -XX:GCLogFileSize=1024M
    -XX:+PrintGCDetails
    -XX:+PrintGCDateStamps
    -XX:+PrintGCCause
</code></pre>
<h2 id="hotspot日志">
  HotSpot日志
  <a class="anchor" href="#hotspot%e6%97%a5%e5%bf%97">#</a>
</h2>
<pre><code>GC                          # PrintGCDetails
    [GC
        GC表示YGC, Full GC是FGC
    (Allocation Failure)
        原因
    [DefNew:4544k-&gt;259k(6144k), 0.0873 secs]
        DefNew表示年轻代, 回收前后的大小, 6144是年轻代总大小，回收时间
    4544k-&gt;4356k(19840k), 0.0812 secs]
        堆的前后大小, 19840是堆总空间, 回收时间
    [Times: user=0.01 sys=0.00, real=0.01 secs]
        linux time命令，用户态时间，内核态时间，总时间
异常退出dump堆
    def new generation total 6144k, used 5504k [0x00, 0x00, 0x00]
        新生代总共多少，用了多少。内存起始地址，使用空间结束地址，整体空间结束地址
        total = eden + 1个survivor
    eden space 5504k, 100% used []
        eden
    from space 640k, 0% used []
        s0
    to space 640, 0% used []
        s1
    tenured generation total 13696k, used 13312k []
        old
    the space 13696k, 97% used []
        old
    Metaspace used 2538k, capacity 4486k, committed 4864k, reserved 1056768k
        used真正使用的大小
        capacity目前指定的容量 
        committed 表示预先占用的大小
        reserved表示共保留的大小
    class space used 275k, capacity 386k, committed 512k, reserved 1048576k
        metaspace中存class的部分
</code></pre>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/docs/pl/">程序语言</a>
    </h2>
    


  
  <div class="text-small">
    
      <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
  </div>
  

  


    <p><h1 id="c">
  c
  <a class="anchor" href="#c">#</a>
</h1>
<pre><code>库
    libvirt
</code></pre>
<h1 id="c-1">
  c++
  <a class="anchor" href="#c-1">#</a>
</h1>
<pre><code>问题
    野指针、迷途指针 Double Free问题
    智能指针
    RAII资源获取就是初始化
    二级指针
库
    opencv
            iplimage
                    # 图像处理
</code></pre>
<h1 id="php">
  php
  <a class="anchor" href="#php">#</a>
</h1>
<pre><code>安装
        php, php-cgi, php-fpm
    编译安装
        yum install libxml2-devel  openssl-devel  bzip2-devel libmcrypt-devel  -y
        ./configure --prefix=/opt/zly/php --with-mysql=mysqlnd --with-openssl --with-mysqli=mysqlnd --enable-mbstring --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml  --enable-sockets --enable-fpm --with-mcrypt  --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --with-bz2
        make
        make install
        cp php.ini-production /etc/php.ini
        cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm
        chmod +x /etc/rc.d/init.d/php-fpm
        cp /opt/zly/php/etc/php-fpm.conf.default /opt/zly/php/etc/php-fpm.conf
        chkconfig --add php-fpm
        chkconfig php-fpm on
        /etc/init.d/php-fpm start
命令
        php -S localhost:8000 -t dir/
配置
        /etc/php/php.ini
        date.timezone = Europe/Berlin
            # 时区设置
        display_errors = On


框架
    zend opcache
        # php5.5集成，把php执行后的数据缓冲到内存中从而避免重复编译
工具
    fpm
        # php fastCGI 进程管理器
</code></pre>
<h1 id="scheme">
  scheme
  <a class="anchor" href="#scheme">#</a>
</h1>
<pre><code># 特点
    词法定界(Lexical Scoping)
    动态类型(Dynamic Typing)
    良好的可扩展性
    尾递归(Tail Recursive)
    函数作为值返回
    计算连续
    传值调用(passing-by-value)
    算术运算相对独立
# 标准
    R5RS (Revised5 Report on the Algorithmic Language Scheme)
    Guile (GNU's extension language)
# guile脚本中(.scm)
    #! /usr/local/bin/guile -s
    !#

# 语法
    注释
        ;
                # 注释到行尾
        #! ... !#
                # 标准中没有，实现中有的多行注释
    类型
        1
        'symbol
        &quot;str&quot;
        true, false
        struct
        empty
            # 表示一个空表
    块(form)
        (define x 123)
        (set! x &quot;abc&quot;)
        (+ 1 2)
        (* (+ 2 (* 3 4)) (+ 5 6 7))
        (display &quot;hello world&quot;)
        (not #f)
            # #t
        (not #t)
            # #f
            # not 后不是逻辑型，都返回#f

    非精确数
        (- #i1.0 #i0.9)
    函数
        or
        and
        not
        (sqrt A)
        (expt A B)
            # A^B
        (remainder A B)
            # A%B
        (log A)
            # A的自然对数
        (sin A)
        (cond
            [(&lt; n 10) 5.0]
            [else .06])
        (if (&lt; x 0)
            (- x)
            x)
        (symbol=? 'Hello x)
            # 符号，比较。符号还有字符串和图像
        (string=? &quot;the dog&quot; x)
            # 字符串，系统看作符号
        (make-posn 3 4)
            # 创建posn结构体
            (poson-x (make-posn 7 0))
                # 7
        (define-struct posn (x y))
            # 定义结构体
        (number?)
        (boolean?)
        (struct?)
        (zero?)
        (posn?)
            # 可以是自定义结构体名
        (null?)
            # 检查是否空list
        (eq? i list)
            # 元素i是否在list中， 否返回false, 是返回所在的子表
            # 可以比较符号
        (memq)
            # eq?的内部调用
        (error ''checked-number &quot;number expected&quot;)
            # 马上出错
        (cons 'Mercury empty)
            # push
            (cons? alon)
                # 是否有元素
            (define x (cons 1 2))
                # 序对, 可嵌套
                (car x)
                    # 1
                (cdr x)
                    # 2
        (define (dispatch m)
            # 传0返回x, 传1返回y
            (cond ((= m 0) x)
                ((= m 1) y)
                (else (error &quot;&quot; m))))
        (first)
        (rest)
        (list (list 'bob 0 'a) (list 'car1 1 'a))
        (local)
            # 局部定义使用
        (lambda)
            # 匿名函数
        (append)
        (set! x 5)
# 例子
    复合数据
        (define-struct student (last first teacher))
        (define (subst-teacher a-student a-teacher)
            (cond
                [(symbol=? (student-teacher a-student) 'Fritz)
                    # 如果教师的名字是'Fritz
                    (make-student (student-last a-student)
                        # 创建student结构体，设置新教师名
                        (student-first a-student)
                        a-teacher)]
                [else a-student]))
    递归列表
        (define (contains-doll? a-list-of-symbols)
            (cond
                [(empty? a-list-of-symbols) false]
                [else (cond
                    [(symbol=? (first a-list-of-symbols) 'doll) true]
                    [else (contains-doll? (rest a-list-of-symbols))])]))
    排序
        (define (sort alon)
            (cond
                [(empty? alon) empty]
                [(cons? alon) (insert (first alon) (sort (rest alon)))]))
        (define (insert n alon)
            (cond
                [(empty? alon) (cons n empty)]
                [else (cond
                    [(&gt;= n (first alon)) (cons n alon)]
                    [(&lt; n (first alon)) (cons (first alon) (insert n (rest alon)))])]))
    or函数
        (define (blue-eyed-ancestor? a-ftree)
            (cond
                [(empty? a-ftree) false]
                [else (or (symbol=? (child-eyes a-ftree) 'blue)
                    (or (blue-eyed-ancestor? (child-father a-ftree))
                        (blue-eyed-ancestor? (child-mother a-ftree))))]))
    列表替换
        (define (replace-eol-with alon1 alon2)
            (cond
                ((empty? alon1) alon2)
                (else (cons (first alon1) (replace-eol-with (rest alon1) alon2)))))
    列表相等
        (define (list=? a-list another-list)
            (cond
                [(empty? a-list) (empty? another-list)]
                [(cons? a-list)
                    (and (cons? another-list)
                        (and (= (first a-list) (first another-list))
                            (list=? (rest a-list) (rest another-list))))]))
    匿名函数
        (define (find aloir t)
            (filter1 (local ((define (eq-ir? ir p)
                (symbol=? (ir-name ir) p)))
                    eq-ir?)
                aloir t))
        (lambda (ir p) (symbol=? (ir-name ir) p))
    快速排序
        (define (quick-sort alon)
            (cond
                [(empty? alon) empty]
                [else (append
                    (quick-sort (smaller-items alon (first alon)))
                    (list (first alon))
                    (quick-sort (larger-items alon (first alon))))]))
        (define (larger-items alon threshold)
            (cond
                [(empty? alon) empty]
                [else (if (&gt; (first alon) threshold)
                    (cons (first alon) (larger-items (rest alon) threshold))
                    (larger-items (rest alon) threshold))]))
        (define (smaller-items alon threshold)
            (cond
                [(empty? alon) empty]
                [else (if (&lt; (first alon) threshold)
                    (cons (first alon) (smaller-items (rest alon) threshold))
                    (smaller-items (rest alon) threshold))]))
</code></pre>
<h1 id="erlang">
  erlang
  <a class="anchor" href="#erlang">#</a>
</h1>
<pre><code>特点
    由爱立信所辖CS-Lab开发，目的是创造一种可以应对大规模并发活动的编程语言。易于编写分布式应用。
    面向并发(concurrent-oriented)
            在语言中定义了erlang进程的概念和行为，使它特别经量级(309字节)，创建和结束一个进程时间为1-3ms
            该进程(绿进程)在rlang虚拟机内管理和高度，是用户态进程
            进程堆栈占用233字节
            erlang虚拟机支持几十万甚至更多进程
    结构化，动态，函数式
</code></pre>
<h1 id="lisp">
  lisp
  <a class="anchor" href="#lisp">#</a>
</h1>
<pre><code>介绍
    为人工智能开发的函数语言
    目前最主要两大方言为scheme和commonLisp。Emacs扩展语言为Lisp，有一种Emacs Lisp语言
    拥有理论上最高的运算能力

编译器
    sbcl
            # steel bank common lisp
</code></pre>
<h1 id="lua">
  lua
  <a class="anchor" href="#lua">#</a>
</h1>
<pre><code>介绍
    lua语言，来实现逻辑。 c/c++来实现功能
    eclipse ldt 来开发（cdt 再安装 ldt 使用更方便）
使用
    lua Hello.lua                # 执行脚本
    luac Hello.lua                # 编译字节码
    #-&gt; lua luac.out
语法
    --                # 注释
    num = 10                # 定义
</code></pre>
<h1 id="perl">
  perl
  <a class="anchor" href="#perl">#</a>
</h1>
<pre><code>标准
    pcre: Perl Compatible Regular Expressions
</code></pre>
<h1 id="prolog">
  prolog
  <a class="anchor" href="#prolog">#</a>
</h1>
<pre><code>介绍
    programming in logic缩写， 是一种逻辑编程语言。广泛应用于人工智能
    不是真正意义上的程序，运行步骤由计算机决定。没有if, when, case, for这样的控制流程语句
    很难分清哪些是程序，哪些是数据，程序就是数据，是一个智能数据库
    有强大的递归功能。
</code></pre>
<h1 id="r">
  R
  <a class="anchor" href="#r">#</a>
</h1>
<pre><code>介绍
    本身是GNU的一个开源软件
    用于统计分析、绘图
    是S语言的一个分支(实现)
特点
    数据存储和处理
    数组运算(向量、矩阵运算强大)
</code></pre>
<h1 id="d">
  D
  <a class="anchor" href="#d">#</a>
</h1>
<pre><code># 并发
</code></pre>
<h1 id="ruby">
  ruby
  <a class="anchor" href="#ruby">#</a>
</h1>
<pre><code>工具
    gems
        gem update --system
</code></pre>
<h1 id="rust">
  rust
  <a class="anchor" href="#rust">#</a>
</h1>
<pre><code>介绍
    mozilla开发的,注重安全, 性能, 并发的系统编程语言
    js之父Brendan Eich设计
</code></pre>
<h1 id="scala">
  scala
  <a class="anchor" href="#scala">#</a>
</h1>
<pre><code>介绍
    haskell衍生语言
    集成了面向对象和函数语言的特性
    可以很简单地与已有的java代码交互，只需要反java相关类导入就可以了
    面向对象语言同时结合命令式和函数式编程风格
工具
    sbt
        simple build tool
语法
    表达式
        actor1 ! case1          # 异步消息
        actor1 !? case1         # 同步消息, 需要对方一定返回
        actor1 !! case1         # 异步消息, 需要对方一定返回
    Actor
        o-&gt;
        import scala.actors.Actor

        class HelloActor extends Actor {
        def act() {
            while (true) {
            receive {
                case name: String =&gt; println(&quot;Hello, &quot; + name)
            }
            }
        }
        }

        val helloActor = new HelloActor
        helloActor.start()
        helloActor ! &quot;leo&quot;
    case                        # 模式匹配
        case class Login(username: String, password: String)
        class UserManageActor extends Actor {
        def act() {
            while (true) {
            receive {
                case Login(username, password) =&gt; println(username + password)
            }
            }
        }
        }
        val userManageActor = new UserManageActor
        userManageActor.start()
        userManageActor ! Login(&quot;leo&quot;, &quot;1234&quot;)
</code></pre>
<h1 id="net">
  .net
  <a class="anchor" href="#net">#</a>
</h1>
<h1 id="objective-c">
  objective-c
  <a class="anchor" href="#objective-c">#</a>
</h1>
<h1 id="swift">
  swift
  <a class="anchor" href="#swift">#</a>
</h1>
<h1 id="groovy">
  groovy
  <a class="anchor" href="#groovy">#</a>
</h1>
<pre><code>    # 基于jvm，结合python, ruby, smalltalk的特性
</code></pre>
<h1 id="dart">
  dart
  <a class="anchor" href="#dart">#</a>
</h1>
<pre><code>    # 谷歌发布的基于javascript的编程语言
</code></pre>
<h1 id="hack">
  hack
  <a class="anchor" href="#hack">#</a>
</h1>
<pre><code>    # facebook开发的基于HHVM，可与PHP无缝对接
    特点
            结合了PHP开发高效性同时，有了静态语言的报错特性
            支持lambda表达式和强制返回等流行特性
</code></pre>
<h1 id="roy">
  roy
  <a class="anchor" href="#roy">#</a>
</h1>
<pre><code>    # 可编译到js
</code></pre>
<h1 id="elm">
  elm
  <a class="anchor" href="#elm">#</a>
</h1>
<pre><code>    # 可编译到js
</code></pre>
<h1 id="jujia">
  jujia
  <a class="anchor" href="#jujia">#</a>
</h1>
<pre><code>    # 动态语言，用于科学和数值计算
</code></pre>
<h1 id="fortran">
  Fortran
  <a class="anchor" href="#fortran">#</a>
</h1>
<pre><code>    # 最早出现的高级语言，用于工程计算领域
</code></pre>
<h1 id="ml">
  ML
  <a class="anchor" href="#ml">#</a>
</h1>
<pre><code>    # meta language, 非纯函数式编程,允许副作用和指令式编程
</code></pre>
<h1 id="ocaml">
  OCaml
  <a class="anchor" href="#ocaml">#</a>
</h1>
<pre><code>    # 在caml上加上oo, 源于ML
</code></pre>
<h1 id="simula">
  simula
  <a class="anchor" href="#simula">#</a>
</h1>
<pre><code>    # 专注于仿真的语言，由类创建的对象会在协调的多线程模式下，像erlang的进程一样并行处理
</code></pre>
    </p>
  </article>
  

  
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/categories/%E8%AF%AD%E8%A8%80/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/categories/%E8%AF%AD%E8%A8%80/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/categories/%E8%AF%AD%E8%A8%80/" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item disabled">
        <a aria-disabled="true" aria-label="Next" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item disabled">
        <a aria-disabled="true" aria-label="Last" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  <nav>
  <ul>
  
    
    <li class="book-section-flat">
      <strong>Categories</strong>
      <ul>
      
        <li class="flex justify-between">
          <a href="/categories/linux%E5%9C%BA%E6%99%AF/">Linux场景</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%AE%89%E5%85%A8/">安全</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">系统编程</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
          <span>6</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
          <span>2</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
          <span>4</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%94%AF%E6%92%91/">支撑</a>
          <span>2</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
          <span>6</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%A7%84%E5%88%92/">规划</a>
          <span>5</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/">设计</a>
          <span>8</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
          <span>8</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%85%83%E5%AE%87%E5%AE%99Web3.0/">元宇宙Web3.0</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%AA%92%E4%BD%93/">媒体</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E4%B8%9A%E5%8A%A1/">业务</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E5%8A%9F%E8%83%BD/">功能</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AF%AD%E8%A8%80/">语言</a>
          <span>13</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
          <span>1</span>
        </li>
      
        <li class="flex justify-between">
          <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
          <span>3</span>
        </li>
      
      </ul>
    </li>
    
  
    
    <li class="book-section-flat">
      <strong>Tags</strong>
      <ul>
      
      </ul>
    </li>
    
  
  </ul>
</nav>

 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












