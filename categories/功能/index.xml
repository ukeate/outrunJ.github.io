<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>功能 on ukeate的笔记</title>
    <link>https://ukeate.com/categories/%E5%8A%9F%E8%83%BD/</link>
    <description>Recent content in 功能 on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 22 Sep 2021 21:45:53 +0800</lastBuildDate>
    <atom:link href="https://ukeate.com/categories/%E5%8A%9F%E8%83%BD/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>小功能</title>
      <link>https://ukeate.com/docs/middleware/library/</link>
      <pubDate>Wed, 10 Oct 2018 14:36:50 +0800</pubDate>
      <guid>https://ukeate.com/docs/middleware/library/</guid>
      <description>&lt;h1 id=&#34;名词&#34;&gt;&#xA;  名词&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8d%e8%af%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;dom                文档对象模型&#xA;dao                数据访问对象&#xA;ucs                unicode character set&#xA;utf                ucs Transformation Format&#xA;bmp                Basic Multilingual plane&#xA;bom                Byte Order Mark&#xA;asp                Active Server Pages&#xA;iis                Internet Information services&#xA;validate code                 验证码&#xA;tld                 tag library description&#xA;jsp                 java server page&#xA;xsd                XML Schemas Definition&#xA;suffix              后缀&#xA;ide                Integrated Development Environment&#xA;RIA                Rich internet Applications                富互联网应用（富客户端）C/S架构是胖客户端，B/S架构是瘦客户端。比如 flash就是ria(其它如js, SilverLight，unity3d，flash3d,adobe air,HTML5/css3，adobe Flex等)&#xA;JPA                Java Persistence API                        java持久层api&#xA;JDBC                Java DataBase Connectivity&#xA;DHTML                DynamicHTML&#xA;cvs                Concurrent Version System&#xA;svn                subversion&#xA;uml                UnifiedModelingLanguage&#xA;AJAX            Asynchronous JavaScript and XML&#xA;bnf                命令书写格式规范: 巴科斯范式&#xA;desc            description&#xA;capacity        容量&#xA;component       组件&#xA;association         联合&#xA;aggregation         聚合&#xA;composition         组合&#xA;alpha           开端&#xA;inherit         继承&#xA;dhtml           dynamic html ,是 html css 客户端script                        不是规范，是现有技术、标准的整合运用&#xA;css             Cascading Style Sheet   级联样式表&#xA;associated                交互的&#xA;perspective                视图&#xA;adapter         适配器&#xA;jit             just in time (compilation)&#xA;webdav          Web-based Distributed Authoring and Versioning        Web 分布式创作和版本管理 (WebDAV) 扩展了 HTTP/1.1 协议，允许客户端发布、锁定和管理 Web 上的资源&#xA;CMS             Content Management System        内容管理系统        它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。&#xA;constraint      约束&#xA;JSON            javascript object notation(标记)&#xA;OGNL            Object-Graph Navigation Language 对象图导航语言&#xA;jmf               java media frame java 媒体框架 是一个jar 包&#xA;dwr                Direct Web Remoting 是一个ajax框架。它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数，就像它就在浏览器里一样。&#xA;CXF                 apache的 Celtix + XFire,用于实现 web services的发布的使用&#xA;oa                Office Automation 办公自动化&#xA;dml                data manipulation language        数据操作语言&#xA;ddl                data definition language        数据定义语言&#xA;dcl                data control language                数据控制语言&#xA;ioc                inversion of control        控制反转（spring）&#xA;di                 dependence injection        依赖注入 （spring）&#xA;crud               增加(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete)&#xA;ssh                Secure Shell,由IETF制定，为建立在应用层和传输层基础上的安全协议。&#xA;pojo                pure old java object&#xA;oop                object oriented programming&#xA;aop                aspect oriented programming                面向切面编程&#xA;hdfs                Hierarchical Data Format        层次型资料格式（分布式存储）&#xA;ftp                File Transfer Protocol&#xA;ssl                Secure Sockets Layer 安全套接层。端口40&#xA;tls                Transport Layer Security 传输层安全(ssl的继任者)&#xA;https            Hypertext Transfer Protocol Secure 应用ssl作为应用层子层对数据进行压缩与解压。端口443&#xA;jsf                JavaServer Faces 是sun开发的web框架，相当于ssh(spring + struts + hibernate)&#xA;sns                Social Network Services        社会性网络服务&#xA;uml                Unified modeling language 统一建模语言&#xA;jta                java transaction api (hibernate中) java事务处理api&#xA;asm                Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。&#xA;                    汇编语言(Assembly Language)的扩展名&#xA;jsr                Java Specification Requests 是Java规范请求，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。jsr303:基于注解的java bean 验证&#xA;dto                data transfer object 数据传输对象&#xA;antlr             another tool for language recognition        一个开源的语法分析器&#xA;soap              simple object access protocol 简单对象访问协议&#xA;uefi              unified extensible firmware interface 统一可扩展固件接口&#xA;sso                single sign on 单点登录&#xA;erp                enterprise resource plan 企业资源计划&#xA;sap                Systems Applications and Products in Data Procession 企业系列软件(全世界排名第一的erp软件)&#xA;ssi                Server Side Include 服务器端嵌入&#xA;jmx                Java Management Extensions java管理扩展，是一个为应用程序、设备、系统等植入管理功能的框架。&#xA;jaas                Java Authentication Authorization Service Java验证和授权API&#xA;jca(J2C， J2CA)        Java Connector Architecture java连接器架构&#xA;jms                    Java Message Service java消息服务，用于在两个应用程序之间，或分布式系统中发送消息&#xA;jaf                    JavaBeans Activation Framework JAF是一个专用的数据处理框架，它用于封装数据，并为应用程序提供访问和操作数据的接口。JAF的主要作用在于让java应用程序知道如何对一个数据源进行查看、编辑和打印等操作。&#xA;jta                    Java Transaction API Java事务API,和jts为J2EE平台提供了分布式事务服务&#xA;jts                    Java Transaction Service java事务服务&#xA;scm                    Supply chain management 一种集成的管理思想和方法，执行供应商到最终用户的物流计划控制职能&#xA;ctr                    click-through-rate 网络广告&#xA;ioc/di                    inversion of control/ dependency injection&#xA;o2o                    online to offline 网站提供平台, 用户线下交易&#xA;cas                    central authentication service 单点登录&#xA;foobar                FTP Operation Over Big Address Records(RFC1545文档)ftp命令列表&#xA;modular              模块化&#xA;enumeration         计数&#xA;navigate            导航&#xA;fragment             碎片&#xA;posix                可移植的&#xA;intersection        截断&#xA;categories          类别&#xA;encounter           遭遇&#xA;recursion           递归&#xA;evaluate            评价&#xA;indent                缩进&#xA;collation         校对&#xA;schema              模式、图表&#xA;generate            生成&#xA;Presentation         描述&#xA;hierarchical         垂直分层&#xA;stereotype         策略&#xA;numerous            许多&#xA;KISS                keep it simple, stupid&#xA;cross-origin         跨域&#xA;CORS             Cross-Origin Resourse Sharing&#xA;NIH             not invented here 自己造轮子&#xA;mis                 management information system&#xA;crm                 customer relationship management&#xA;erp             enterprise resource planning&#xA;webRTC          web Real-Time Communication&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;库&#34;&gt;&#xA;  库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;日志&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;log4j&#xA;    # java&#xA;logback&#xA;    # log4j后续版本&#xA;slf4j&#xA;    # java&#xA;log4js&#xA;    # js&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;格式模板&#34;&gt;&#xA;  格式|模板&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%bc%e5%bc%8f%e6%a8%a1%e6%9d%bf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;moment&#xA;    # js格式化时间&#xA;iconv&#xA;    # nodejs调用c++ libiconv库来转码&#xA;iconv-lite&#xA;    # nodejs实现的转码，比调用c++ 的iconv更高效&#xA;poi&#xA;    # java 文件处理&#xA;jFreeChart&#xA;    # java图表库&#xA;jackson&#xA;    # java json序列化&#xA;json-smart&#xA;    # java json&#xA;xstream&#xA;    # java xml序列化&#xA;pango2&#xA;    # 国际化模板&#xA;snakeyaml&#xA;    # java yaml&#xA;js-beautify&#xA;    # js, html格式化&#xA;xmlbeans&#xA;    # java xml&#xA;joda-time&#xA;    # java日期&#xA;dom4j&#xA;    # java dom &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;生成压缩加密计算特征&#34;&gt;&#xA;  生成|压缩|加密|计算特征&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90%e5%8e%8b%e7%bc%a9%e5%8a%a0%e5%af%86%e8%ae%a1%e7%ae%97%e7%89%b9%e5%be%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;simhash&#xA;    # google 文档hash&#xA;pygments&#xA;    # python 生成高亮html&#xA;mako&#xA;    # python 模板&#xA;jinja2&#xA;    # python 模板&#xA;freemarker&#xA;    # java 模板&#xA;proguard&#xA;    # java 混淆&#xA;snappy&#xA;    # google java 压缩&#xA;jbcrypt&#xA;    # java加密, scrypt更强&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;客户端邮件&#34;&gt;&#xA;  客户端|邮件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%a2%e6%88%b7%e7%ab%af%e9%82%ae%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;javamail&#xA;    # java mail&#xA;nodemailer&#xA;    # node mail&#xA;mailapi&#xA;    # java mail&#xA;c3p0&#xA;    # java rds 连接池&#xA;dbcp&#xA;    # java rds 连接池&#xA;druid&#xA;    # java rds 连接池。可监控sql执行性能，记sql日志&#xA;jdbc&#xA;    # java rds client&#xA;dbutil&#xA;hibernate&#xA;ef&#xA;    # .net orm&#xA;NHibernate&#xA;    # .net orm&#xA;peewee&#xA;    # python orm&#xA;node-mysql&#xA;mongoose&#xA;httpClient&#xA;    # java http&#xA;request&#xA;    # js http&#xA;superagent&#xA;    # js http&#xA;mybatis&#xA;hsqldb&#xA;    # java内置, 单文件/内存数据库&#xA;mqttv&#xA;    # java mqtt客户端&#xA;libthrift&#xA;    # java thrift&#xA;kafka-clients&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;领域语言&#34;&gt;&#xA;  领域语言&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a2%86%e5%9f%9f%e8%af%ad%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;lex&#xA;    # 生成词法分析程序&#xA;yacc&#xA;    # 生成自底向上语法分析程序&#xA;antlr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;图形&#34;&gt;&#xA;  图形&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be%e5%bd%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ccap&#xA;    # 基于c++的图形CImg库，就是一个CImg.h文件&#xA;canvas&#xA;    # node canvas&#xA;tesseract&#xA;    # node 验证码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;运维控制&#34;&gt;&#xA;  运维控制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e7%bb%b4%e6%8e%a7%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;later&#xA;    # nodejs corntab&#xA;glob&#xA;    # nodejs 匹配获得文件&#xA;rd&#xA;    # node 遍历文件&#xA;commander&#xA;    # node制作命令&#xA;mkdirp&#xA;    # node 递归makedir&#xA;fs-extra&#xA;    # node扩展fs包&#xA;testcontainers&#xA;    # java, 运行docker&#xA;jOptSimple&#xA;    # java, 命令解析&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;协议&#34;&gt;&#xA;  协议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;spring-websocket&#xA;    # java&#xA;httpcore-nio&#xA;    # java&#xA;grpc-context&#xA;    # java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;高可用--性能&#34;&gt;&#xA;  高可用 | 性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e5%8f%af%e7%94%a8--%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;retry&#xA;    # js retry&#xA;ehcache&#xA;    # 缓存&#xA;tagg&#xA;    # node线程池&#xA;cluster&#xA;    # node单机集群&#xA;fiber&#xA;    # node协程&#xA;driud&#xA;    # 连接池，阿里开源&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;akka&#34;&gt;&#xA;  akka&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#akka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# scala并发、分布式、容错工具&#xA;使用&#xA;    system = ActorSystem.create(&amp;quot;hello&amp;quot;)&#xA;    system.actorOf() ## 前端 ### dwr&#xA;介绍&#xA;    java函数通过ajax映射到前端js调用&#xA;使用&#xA;    ajax框架&#xA;    1.导入jar包 dwr.jar&#xA;    2.web-inf/下的配置文件&#xA;        web.xml文件&#xA;            &amp;lt;servlet&amp;gt;&#xA;                &amp;lt;servlet-name&amp;gt;dwr-invoker&amp;lt;/servlet-name&amp;gt;&#xA;                &amp;lt;servlet-class&amp;gt;org.directwebremoting.servlet.DwrServlet&amp;lt;/servlet-class&amp;gt;&#xA;                        # 固定写法&#xA;                &amp;lt;init-param&amp;gt;&#xA;                        &amp;lt;param-name&amp;gt;debug&amp;lt;/param-name&amp;gt;&#xA;                        &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;&#xA;                &amp;lt;/init-param&amp;gt;&#xA;                &amp;lt;init-param&amp;gt;&#xA;                        &amp;lt;param-name&amp;gt;scriptCompressed&amp;lt;/param-name&amp;gt;        # 允许在javascript中执行&#xA;                        &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;&#xA;                &amp;lt;/init-param&amp;gt;&#xA;                &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;        # web工程启动时加载&#xA;            &amp;lt;/servlet&amp;gt;&#xA;            &amp;lt;servlet-mapping&amp;gt;&#xA;                &amp;lt;servlet-name&amp;gt;dwr-invoker&amp;lt;/servlet-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;/dwr/*&amp;lt;/url-pattern&amp;gt;&#xA;            &amp;lt;/servlet-mapping&amp;gt;&#xA;        dwr.xml文件&#xA;            &amp;lt;dwr&amp;gt;&#xA;                &amp;lt;allow&amp;gt;&#xA;                    &amp;lt;create creator=&amp;quot;new&amp;quot; javascript=&amp;quot;DWRUserAccess&amp;quot;&amp;gt;        # 生成js文件的名（页面中引用）&#xA;                            &amp;lt;param name=&amp;quot;class&amp;quot; value=&amp;quot;outrun.dwr.DWRUserAccess&amp;quot; /&amp;gt;                # 曝露的类&#xA;                    &amp;lt;/create&amp;gt;&#xA;                    &amp;lt;convert converter=&amp;quot;bean&amp;quot; match=&amp;quot;outrun.dwr.User&amp;quot; /&amp;gt;        # 注册实体类，可以在js中进行实例化&#xA;                &amp;lt;/allow&amp;gt;&#xA;            &amp;lt;/dwr&amp;gt;&#xA;    3.写outrun.dwr.DWRUserAccess中的方法&#xA;    4.页面调用&#xA;        test.html&#xA;            &amp;lt;script src=&amp;quot;/outrun/dwr/engine.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;            &amp;lt;script src=&amp;quot;/outrun/dwr/util.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;            &amp;lt;script src=&amp;quot;/outrun/dwr/interface/DWRUserAccess.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#xA;            &amp;lt;SCRIPT LANGUAGE=&amp;quot;JavaScript&amp;quot;&amp;gt;&#xA;                DWRUserAccess.方法(参数,执行完运行的js函数)&#xA;                    # 参数可以是一个map,如&#xA;                        var userMap = {};&#xA;                        userMap.id = regForm.id.value;&#xA;                        userMap.password = regForm.password.value;&#xA;                        userMap.name = regForm.name.value;&#xA;                        userMap.email = regForm.email.value;&#xA;                        DWRUserAccess.save(userMap, saveFun);&#xA;                                # 其中的regForm是页面中的表单（的name属性,dom支持直接使用名字引用表单）&#xA;            &amp;lt;/SCRIPT&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;开发&#34;&gt;&#xA;  开发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;脚手架&#34;&gt;&#xA;  脚手架&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%84%9a%e6%89%8b%e6%9e%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spring-boot&#34;&gt;&#xA;  spring boot&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;drapwizard&#34;&gt;&#xA;  drapWizard&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#drapwizard&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# java，类spring boot&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;写法&#34;&gt;&#xA;  写法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%99%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;traits-decorator&#xA;    # js mixin&#xA;q&#xA;    # js 流程控制&#xA;co&#xA;    # js generator to async&#xA;async&#xA;    # js 流程控制&#xA;thunkify&#xA;    # js函数Thunk化, 确保回调调用一次&#xA;step&#xA;    # async轻量库&#xA;wind&#xA;    # js定义的宏&#xA;streamline&#xA;    # 基于源代码编译来实现流程控制简化&#xA;eventproxy&#xA;    # js event回调&#xA;spring&#xA;    # java ioc&#xA;guice&#xA;# google的java ioc轻量框架&#xA;castle&#xA;    # .net ioc&#xA;spring.net&#xA;    # .net ioc&#xA;anko&#xA;    # go 代码解释器&#xA;antlr&#xA;    # java dsl&#xA;aopalliance&#xA;    # java aop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;ejb&#34;&gt;&#xA;  ejb&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ejb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    分布式，j2ee一部分&#xA;&#xA;组成&#xA;    会话bean(session)&#xA;    实体bean(entity)&#xA;    消息驱动bean(message driven)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;语言增强&#34;&gt;&#xA;  语言增强&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e8%a8%80%e5%a2%9e%e5%bc%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;guava&#34;&gt;&#xA;  guava&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#guava&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# google工具集&#xA;maven&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;组件&#xA;    o-&amp;gt; 增强&#xA;    Optional                            # null处理&#xA;    Preconditions                       # 准入检查&#xA;    Ordering&#xA;    Throwables&#xA;&#xA;    o-&amp;gt; 集合&#xA;    Multiset                            # 存重复元素&#xA;    Multimap                            # 多值&#xA;    BiMap                               # 双向映射&#xA;    Table                               # 两键一值&#xA;    Range                               # 连续值&#xA;    &#xA;    o-&amp;gt; 字符串&#xA;    Joiner&#xA;    Spilter&#xA;    CharMatcher&#xA;    CaseFormat&#xA;&#xA;    o-&amp;gt; 类型&#xA;    Objects&#xA;    Bytes&#xA;    Shorts&#xA;    Ints&#xA;    Longs&#xA;    Floats&#xA;    Doubles&#xA;    Chars&#xA;    Booleans&#xA;&#xA;    o-&amp;gt; 数学&#xA;    IntMath&#xA;    LongMath&#xA;    BigIntegerMath&#xA;&#xA;    o-&amp;gt; 高可用&#xA;    LoadingCache                        # 堆内缓存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;接口&#34;&gt;&#xA;  接口&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;luavit&#xA;    # lua实现, 类node&#xA;scotty&#xA;    # haskell&#xA;webapi&#xA;    # .net&#xA;meteor.js&#xA;    # 基于node.js + mongodb的网站开发平台，把这个基础构架延伸到浏览器端, 本地和远程数据通过DDP(Distributed Data Protocol)协议传输&#xA;restify&#xA;    # 基于nodejs的rest应用框架，去掉express中的 template, render等功能, 提供DTrace功能，方便调试&#xA;ssh&#xA;    # java&#xA;spring site&#xA;    # spring整合&#xA;tapestry&#xA;    # 基于servlet的mvc框架&#xA;jersey&#xA;    # java restful服务&#xA;naga&#xA;    # java nio&#xA;echo&#xA;    # go&#xA;beego&#xA;    # go&#xA;gorilla&#xA;    # go&#xA;gin&#xA;    # go，类express&#xA;iris&#xA;    # go, fasthttp的一种实现&#xA;tornado&#xA;    # python nio&#xA;web.py&#xA;twisted&#xA;    # event driven&#xA;flask&#xA;django&#xA;bottle&#xA;    # python wsgi&#xA;rails&#xA;    # ruby的web mvc开发框架&#xA;ror&#xA;    # ror(ruby on rails)&#xA;sinatra&#xA;    # 微型web&#xA;grape&#xA;    # 运行在rack或rails/sinatra配合使用的restful风格的ruby微框架&#xA;yii&#xA;    # php&#xA;laravel&#xA;    # php&#xA;codelgniter&#xA;    # php&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;restful&#34;&gt;&#xA;  RESTful&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#restful&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;connect&#34;&gt;&#xA;  connect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#connect&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    nodejs处理http中req、res的中间件框架&#xA;    中间件分类&#xA;        pre-request用来改写request原始数据&#xA;        request/response功能各异&#xA;        post-response全局异常处理，改写response数据等&#xA;内置中间件介绍&#xA;    logger&#xA;    csrf&#xA;    compress             # gzip压缩&#xA;    basicAuth            # basic认证&#xA;    body parser          # 请求内容解析&#xA;    json&#xA;    urlencoded           # application/x-www-form-urlencode请求解析&#xA;    multipart            # multipart/form-data请求解析&#xA;    timeout&#xA;    cookieParser&#xA;    session&#xA;    cookieSession&#xA;    methodOverride       # http伪造&#xA;    responseTime         # 计算响应时间&#xA;    staticCache          # 缓存&#xA;    directory            # 目录列表&#xA;    vhost                # 虚拟二级域名映射&#xA;    favicon&#xA;    limit                # 请求内容大小限制&#xA;    query                # url解析&#xA;    errorHandler         # 错误处理&#xA;使用&#xA;    var connect = require(&#39;connect&#39;);&#xA;    var app = connect()&#xA;        .use(connect.logger(&#39;dev&#39;))&#xA;        .use(function(req, res){&#xA;            res.end(&#39;hello world\n&#39;);&#xA;        })&#xA;        .listen(3000);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;express&#34;&gt;&#xA;  express&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#express&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;安装&#xA;    npm install -g express-generator&#xA;    npm install express -d                        # g代表安装到NODE_PATH的lib里面, d代表关联套件一起安装&#xA;cookie-parser&#xA;    使用&#xA;        var cookieParser = require(&#39;cookie-parser&#39;);&#xA;        app.use(cookieParser());&#xA;&#xA;        JSON.stringify(req.cookies);&#xA;        req.cookies.yourCookie&#xA;cookie-session&#xA;    使用&#xA;        var cookieSession = require(&#39;cookie-session&#39;);&#xA;        app.use(cookieSession())&#xA;        req.session = null&#xA;&#xA;express-session&#xA;    options可选参数&#xA;        name                        # 表示cookie中保存session的字段名称，默认为connect.sid&#xA;        store                        # session的存储方式，默认存放在内存中，也有redis、mongodb、等模块支持&#xA;        secret                        # 设置secrect来计算hash放在cookie中产生signedCookie，来防篡改&#xA;        genid                        # 规定产生一个新的session_id时所用的函数，默认用uid2这个包&#xA;        rolling                        # 每个请求都重新设置一个cookie，默认为false&#xA;        resave                        # 即使session没有被修改，也保存session的值&#xA;    使用&#xA;        var session = require(&#39;express-session&#39;);&#xA;        app.use(session(options));&#xA;&#xA;connect-redis&#xA;    使用&#xA;        var express = require(&#39;express&#39;);&#xA;        var session = require(&#39;express-session&#39;);&#xA;        var redisStore = require(&#39;connect-redis&#39;)(session);&#xA;&#xA;        app.use(session({&#xA;            store: new redisStore(),&#xA;            secret: &#39;somesecrettoken&#39;&#xA;        }));&#xA;serve-static&#xA;    # 静态文件&#xA;passport&#xA;    介绍&#xA;        登录验证中间件&#xA;        支持connect express sails等web框架&#xA;        支持Basic, Digest, OAuth(1.0和2.0的三种实现), Bearer等&#xA;    安装&#xA;        npm i passport&#xA;        npm i passport-local&#xA;    o-&amp;gt; 配置&#xA;    var express = require(&#39;express&#39;);&#xA;    var cookieParser = require(&#39;cookie-parser&#39;);&#xA;    var session = require(&#39;express-session&#39;);&#xA;    var flash = require(&#39;express-flash&#39;);&#xA;    var passport = require(&#39;passport&#39;);&#xA;&#xA;    ...&#xA;&#xA;    app.use(cookieParser());&#xA;    app.use(session({...}));&#xA;    app.use(passport.initialize());&#xA;    app.use(passport.session());&#xA;    app.use(flash())&#xA;&#xA;    passport.serializeUser(function (user, done) {&#xA;            done(null, user.id)&#xA;    })&#xA;    passport.deserializeUser(function (id, done) {&#xA;            User.findById(id, function (err, user) {&#xA;                    done(err, user)&#xA;            })&#xA;    })&#xA;&#xA;    app.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;, {&#xA;            # passport.authenticate是个登录中间件，通过就走后面回调，否则返回401&#xA;            # local是自定义的名称&#xA;            successRedirect: &#39;/&#39;,&#xA;            failureRedirect: &#39;/login&#39;,&#xA;            failureFlash: true,&#xA;    }, function (req, res) {&#xA;            res.redirect(&#39;/users/&#39; + req.user.username)&#xA;    }))&#xA;&#xA;    app.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;, function(err, user, info) {&#xA;            if (err) return next(err)&#xA;            if (!user) {&#xA;                    req.flash(&#39;errors&#39;, {msg: info.message})&#xA;                    return res.redirect(&#39;/login&#39;)&#xA;            }&#xA;            req.logIn(user, function (err) {})&#xA;    })(req, res, next))&#xA;    app.get(&#39;/logout&#39;, function(req, res) {&#xA;            req.logout()&#xA;            res.redirect(&#39;/&#39;)&#xA;    })&#xA;    app.get(&#39;/user&#39;, isAuthenticated, getUser)&#xA;    var isAuthenticated = function (req, res, next) {&#xA;            if (req.isAuthenticated()) {&#xA;                    return next()&#xA;            }&#xA;            res.redirect(&#39;/login&#39;)&#xA;    }&#xA;&#xA;&#xA;    o-&amp;gt; local验证&#xA;    var LocalStrategy = require(&#39;passport-local&#39;).Strategy&#xA;    passport.use(new LocalStrategy(&#xA;            function(username, password, done) {&#xA;                    User.findOne({username: username}, function(err, user) {&#xA;                            if (err) {return done (err)}&#xA;                            if (!user) {return done(null, false, {message: &#39;no user&#39;})}&#xA;                            if (!user.validPassword(password)) {...}&#xA;                            return done(null, user)&#xA;                    })&#xA;            }&#xA;    ))&#xA;&#xA;    o-&amp;gt; usernameField&#xA;    passport.use(new LocalStrategy({&#xA;            usernameField: &#39;email&#39;,&#xA;            passwordField: &#39;passwd&#39;&#xA;    }, function (username, password, done) {...}&#xA;    ))&#xA;&#xA;    o-&amp;gt; OAuth&#xA;    介绍&#xA;        第三方登录协议&#xA;        三个步骤&#xA;            1. 获取未授权的request token&#xA;            2. 获取用户授权的request token&#xA;            3. 用授权的request token换取access token&#xA;    使用&#xA;        网页上申请开发github应用&#xA;        npm install passport-github&#xA;            # 安装passport的github扩展&#xA;        // app.js&#xA;        passport.use(new GithubStrategy({        // 增加github认证策略&#xA;            clientID: &#39;XXXX&#39;,&#xA;            clientSecret: &#39;YYYY&#39;,        // 已从github上申请&#xA;            callbackURL: &#39;http://localhost:3000/auth/github/callback&#39;&#xA;        }, function(accessToken, refreshToken, profile, done){&#xA;            done(null, profile);&#xA;        }));&#xA;        // 定义路由&#xA;        app.all(&#39;/github&#39;, isLoggedIn);&#xA;        app.get(&#39;/github&#39;, user.github);&#xA;        app.get(&#39;/auth/github&#39;, passport.authenticate(&#39;github&#39;, {scope: &#39;email&#39;}));&#xA;        app.get(&#39;/auth/github/callback&#39;, passport.authenticate(&#39;github&#39;, {&#xA;            successRedirect: &#39;/github&#39;,&#xA;            failureRedirect: &#39;/&#39;&#xA;        }));&#xA;kraken&#xA;    介绍&#xA;        基于express之上的基于设置结构化代码工具&#xA;    功能&#xA;        post请求_csrf验证&#xA;&#xA;    基本用法&#xA;        &#39;use strict&#39;&#xA;        var express = require(&#39;express&#39;),&#xA;            kraken = require(&#39;kraken-js&#39;);&#xA;        var app = express();&#xA;        app.use(kraken());&#xA;        app.listen(8000);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;koa&#34;&gt;&#xA;  koa&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#koa&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    express原班人马打造的，更小，更健壮，更有表现力的web框架&#xA;    免除重复繁琐的回调函数嵌套，提高错误处理效率&#xA;    不绑定任何中间件，只是提供一个轻量优雅的函数库&#xA;    &amp;gt;=node0.11.16&#xA;配置&#xA;    app.name              # 应用名称&#xA;    app.env                  # 执行环境，默认是NODE_ENV 或 &#39;development&#39;&#xA;    app.proxy              # 决定哪些proxy header被加到信任列表中&#xA;    app.subdomainOffset      # 被忽略的.subdomains列表&#xA;    app.jsonSpaces          # 输出json时是否填充空格&#xA;    app.outputErrors        # 是否输出错误堆栈(err.stack)到stderr(app.env是&#39;test&#39;时，此值为false)&#xA;&#xA;使用&#xA;    $ npm install koa&#xA;    $ node --harmony app.js                        # 必需使用harmony模式运行程序&#xA;    var koa = require(&#39;koa&#39;);&#xA;    var app = koa();&#xA;    app.use(function *(){&#xA;        this.body = &#39;Hello World&#39;;&#xA;    });        # function*  声明的generator function支持yield&#xA;               ## yield是ES6定义的新语法&#xA;    app.listen(3000);&#xA;使用(downstream &amp;amp; upstream)&#xA;    var koa = require(&#39;koa&#39;);&#xA;    var app = koa();&#xA;&#xA;    // x-response-time&#xA;    app.use(function *(next){&#xA;    // (1) 进入路由&#xA;    var start = new Date;&#xA;    yield next;&#xA;    // (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间&#xA;    var ms = new Date - start;&#xA;    this.set(&#39;X-Response-Time&#39;, ms + &#39;ms&#39;);&#xA;    // (6) 返回 this.body&#xA;    });&#xA;&#xA;    // logger&#xA;    app.use(function *(next){&#xA;    // (2) 进入 logger 中间件&#xA;    var start = new Date;&#xA;    yield next;&#xA;    // (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间&#xA;    var ms = new Date - start;&#xA;    console.log(&#39;%s %s - %s&#39;, this.method, this.url, ms);&#xA;    });&#xA;&#xA;    // response&#xA;    app.use(function *(){&#xA;    // (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream&#xA;    this.body = &#39;Hello World&#39;;&#xA;    });&#xA;&#xA;    app.listen(3000);&#xA;&#xA;    this&#xA;        request&#xA;            header&#xA;            headers&#xA;            url&#xA;            accepts&#xA;        response&#xA;            header&#xA;            headers&#xA;            status&#xA;        cookies&#xA;            set(&#39;name&#39;, &#39;tobi&#39;, {signed: true})&#xA;                signed&#xA;                expires&#xA;                path&#xA;                domain&#xA;                secure&#xA;                httpOnly&#xA;            get&#xA;        type&#xA;        length&#xA;        path&#xA;        method&#xA;        state&#xA;        throw&#xA;        assert&#xA;    app&#xA;        use&#xA;        listen&#xA;        callback&#xA;        keys&#xA;        context&#xA;            db&#xA;中间件&#xA;    koa-router&#xA;    trie-router&#xA;    route&#xA;    basic-auth&#xA;    etag&#xA;    compose&#xA;    static&#xA;    static-cache&#xA;    session&#xA;    compress&#xA;    csrf&#xA;    logger&#xA;    mount&#xA;    send&#xA;    error&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;实时&#34;&gt;&#xA;  实时&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e6%97%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;sockjs&#xA;        # node websock&#xA;postal&#xA;        # nodejs 在内存上构建的发布订阅框架&#xA;pusher&#xA;        # 发布订阅模式socketio框架&#xA;juggernaut&#xA;        # 基于socketio&#xA;datachannel.io&#xA;        # 基于socket.io和html5 webRTC的实时聊天室框架&#xA;faye-websocket-node&#xA;        # 扩展faye项目开发的websocket的一个实现, 非常简单，而且不依赖其他库&#xA;websocket-node&#xA;        # 一个简单的websocket库，支持draft-10及之前的各种版本, 支持同样是node的c/s交互模式&#xA;ejabberd&#xA;        # 基于erlang/OTP 的xmpp im 开源框架&#xA;singalR&#xA;        # .net sock服务&#xA;nsq&#xA;        # go&#xA;openfire&#xA;        # java, 性能较差, 最多单机10w并发&#xA;webrtc&#xA;        # c++实现的web视频聊天&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;socketio&#34;&gt;&#xA;  socket.io&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#socketio&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 介绍&#xA;    socket.io: 基于任何浏览器, mobile设备的&amp;quot;webSocket&amp;quot;&#xA;# 安装&#xA;        npm install socket.io&#xA;# 使用&#xA;        var socketIo = require(&#39;socket.io&#39;);&#xA;        socketIo.listen(app).on(&#39;connection&#39;, function (socket) {                # require(&#39;socket.io&#39;)(app);&#xA;                                                                        ## var io = require(&#39;socket.io&#39;)(80);&#xA;        socket.emit(&#39;news&#39;, { hello: &#39;world&#39; });&#xA;        socket.on(&#39;my other event&#39;, function (data) {&#xA;                console.log(data);&#xA;        });&#xA;        });&#xA;# api&#xA;    server&#xA;            io.on(&#39;connection&#39;, function(socket){});&#xA;            io.on(&#39;disconnect&#39;, function(){});&#xA;            socket.on(&#39;message&#39;, function(msg){});&#xA;    client-js&#xA;            socket = io.connect(url);&#xA;            socket.on(&#39;&#39;, function(json){});&#xA;            socket.send(json);&#xA;    io&#xA;            on(&#39;connection&#39;, function(socket){});&#xA;                    # disconnect&#xA;    socket&#xA;            on(&#39;disconnect&#39;, function(){ });&#xA;            socket.on(&#39;say to someone&#39;, function(id, msg){&#xA;                    socket.broadcast.to(id).emit(&#39;my message&#39;, msg);&#xA;            });&#xA;                    # Socket#id为内部指定的&#xA;    遍历用户&#xA;            var roster = io.sockets.clients(&#39;chatroom&#39;);&#xA;            roster.forEach(function(client){&#xA;                    console.log(&#39;Username: &#39; + client.nickname);&#xA;            });                        // 1.0之前版本可用&#xA;# 方案&#xA;    namespace&#xA;            server&#xA;                    var nsp = io.of(&#39;/my-namespace&#39;);&#xA;                    Onsp.emit(&#39;hi&#39;, &#39;everyone!&#39;);                # ns广播&#xA;            client&#xA;                    var socket = io(&#39;/my-namespace&#39;);&#xA;    room&#xA;            server&#xA;                    socket.join(&#39;some room&#39;);&#xA;                    io.to(&#39;some room&#39;).emit(&#39;some event&#39;):        # room广播&#xA;                    socket.leave(&#39;some room&#39;);&#xA;# 子模块&#xA;    socket.io-redis&#xA;        介绍&#xA;                用于从外部发消息，与socket.io-emitter一起使用&#xA;        使用&#xA;                var io = require(&#39;socket.io&#39;)(3000);&#xA;                var redis = require(&#39;socket.io-redis&#39;);&#xA;                io.adapter(redis({ host: &#39;localhost&#39;, port: 6379 }));&#xA;    socket.io-emitter&#xA;        介绍&#xA;                用于从外部发消息，与socket.io-redis一起使用&#xA;        使用&#xA;                var io = require(&#39;socket.io-emitter&#39;)();&#xA;                io.emit(&#39;time&#39;, new Date);&#xA;    socket.io-client&#xA;        介绍&#xA;                用于创建客户端来连接socket.io&#xA;        使用&#xA;                var iocl = require(&#39;socket.io-client&#39;);&#xA;                var socket = iocl.connect(&#39;127.0.0.1:5555&#39;);&#xA;                socket.on(&#39;connect&#39;, function(){&#xA;&#xA;                });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;展示&#34;&gt;&#xA;  展示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%95%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;titles&#xA;    # java apache的标签库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-mvc&#34;&gt;&#xA;  spring mvc&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;struts2&#34;&gt;&#xA;  struts2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#struts2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 基础&#xA;    介绍&#xA;        struts1和WebWork的发展&#xA;        引入值栈的概念     # 一次请求的参数和处理数据放在一个map结构中&#xA;    原理&#xA;        基于拦截器, 解耦servlet, 再提供自己的拦截器(interceptor)操作数据, 反射调用业务类&#xA;        FilterDispatcher通过配置文件来映射设置请求地址与处理类&#xA;            ActionMapper判断请求是否struts处理&#xA;            ActionProxy扩展实现方式(如web service)&#xA;            ConfigurationManager对应struts.xml配置文件&#xA;            ActionInvocation执行Action与拦截器&#xA;            Action处理请求，封装数据&#xA;                # Action是非单例的，效率低&#xA;    过滤器与拦截器&#xA;        过滤器基于回调，拦截器基于反射&#xA;        过滤器依赖servlet, 拦截器在struts中处理action&#xA;&#xA;# 思想&#xA;    Action类中的无侵入设计（新技术中不出现旧技术）：map代替了作用域&#xA;        ActionContext actionContext = actionContext.getContext()&#xA;        actionContext.getApplication()&#xA;        actionContext.getSession()&#xA;&#xA;        好处&#xA;            map是java中的api，不出现旧技术&#xA;            测试方便（ servlet不能测试，只能发布测试）&#xA;                # 注意：Action类中用到作用域map的方法也不能测试&#xA;&#xA;&#xA;# 结构&#xA;    apps: 例子程序&#xA;    docs:帮助文件&#xA;    lib:程序包&#xA;    src:源码&#xA;# 使用&#xA;    要求&#xA;        jdk5&#xA;        jsp2&#xA;        servlet api2.4&#xA;&#xA;    导入核心的8个包&#xA;        struts2-core-2.3.1.1.jar        # struts的过滤器&#xA;        xwork-core-2.3.1.1.jar                # 验证工具&#xA;        freemarker-2.3.18.jar                # 标签&#xA;        javassist-3.11.0.GA.jar                # 动态代理&#xA;        commons-fileupload-1.2.2.jar&#xA;        commons-io-2.0.1.jar                # 文件处理&#xA;        commons-lang-2.5.jar                # 基础包&#xA;        ognl-3.0.3.jar                                # 表达式语言&#xA;    web.xml文件中配置过滤器&#xA;        &amp;lt;filter&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;struts&amp;lt;/filter-name&amp;gt;&#xA;            &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-class&amp;gt;&#xA;        &amp;lt;/filter&amp;gt;&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;struts&amp;lt;/filter-name&amp;gt;&#xA;            &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;&#xA;        &amp;lt;/filter-mapping&amp;gt;&#xA;    写jsp页面，get或post路径为struts2的名称空间、扩展名，被配置的struts2过滤器处理&#xA;    写Action类（继承ActionSupport类）&#xA;    配置src/struts.xml文件与src/struts.properties文件，映射类、方法等到请求路径，映射返回字符串到任何方式&#xA;&#xA;&#xA;# 核心包：8个&#xA;    struts2-core-2.3.1.1.jar        # struts的过滤器&#xA;    xwork-core-2.3.1.1.jar                # 验证工具&#xA;    freemarker-2.3.18.jar                # 标签&#xA;    javassist-3.11.0.GA.jar                # 动态代理&#xA;    commons-fileupload-1.2.2.jar&#xA;    commons-io-2.0.1.jar                # 文件处理&#xA;    commons-lang-2.5.jar                # 基础包&#xA;    ognl-3.0.3.jar                                # 表达式语言&#xA;&#xA;# 配置&#xA;    struts2以包的形式管理action 包名必须唯一，包里的每个action唯一&#xA;    使用步骤&#xA;        导入lib包&#xA;        写jsp&#xA;        编写Action方法&#xA;        web.xml中配置&#xA;            &amp;lt;filter-class&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&#xA;            &amp;lt;url-pattern&amp;gt;/*&#xA;        ../xx_struts.xml中配置请求响应&#xA;        src/struts.xml 中引入配置文件&#xA;            &amp;lt;include file=&amp;quot;cn/itcast/javaee/cal/cal_struts.xml&amp;quot;/&amp;gt;&#xA;&#xA;    配置文件（配置包）路径&#xA;        重要路径：4个&#xA;            1./struts-default.xml[框架]&#xA;                # 是框架自带的abstract包（包括上传，下载，验证等），继承它以后可以用其中的功能&#xA;            2./org/apache/struts2/default.properties[框架]&#xA;            3.src/struts.xml # 必有&#xA;            4.src/struts.properties # 可选&#xA;        验证返回消息的配置文件&#xA;            struts2-core-2.3.1.1.jar包中的&#xA;                /org/apache/struts2/struts-messages.properties文件&#xA;&#xA;    xml 中配置的简化&#xA;        *&#xA;            o-&amp;gt; 只能在name 中写*_* 等&#xA;            o-&amp;gt; 引用第一个* 用{1}        引用第二个用{2} 以此类推&#xA;&#xA;&#xA;    类路径&#xA;        com.opensymphony.xwork2.ActionSupport  默认关联到的类&#xA;&#xA;    处理请求的扩展名配置&#xA;        # 扩展名配置只有一个会生效&#xA;        1./org/apache/struts2/default.properties&#xA;                struts.action.extension=action,,&#xA;                # 框架中初始的默认扩展名，最后的&#39;,&#39;代表了无扩展名&#xA;        2.src/struts.xml中&#xA;                &amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;do,,&amp;quot;&amp;gt;&#xA;                        # 必需配置&#xA;        3.src/struts.properties中&#xA;                        struts.action.extension=xx,yy&#xA;                        # 选择配置，优先级高&#xA;&#xA;    默认配置&#xA;        struts2内置了请求字符串与基本类型的相互转换，不用手工转换&#xA;&#xA;        /org/apache/struts2/default.properties文件中&#xA;                struts.i18n.encoding=UTF-8        # post方式请求响应的编码方式&#xA;                                                                        ## get方式的没有默认值，需要自己转码&#xA;                struts.action.extension=action,,  # 框架中初始的默认扩展名,最后的&#39;,&#39;代表了无扩展名&#xA;&#xA;        每个&amp;lt;package&amp;gt;标签中配置&#xA;        &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt; 为默认的拦截器&#xA;&#xA;    src/struts.xml配置文件&#xA;&#xA;    src/struts.properties配置文件&#xA;&#xA;# 原理流程&#xA;    请求/qq.action -&amp;gt; StrutsPreparedAndExecuteFilter（核心过滤器）-&amp;gt; 匹配扩展名 -&amp;gt; 匹配命名空间&#xA;        #（ 全限定名：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.class）&#xA;            -&amp;gt; src/struts.xml                -&amp;gt; name&#xA;                class&#xA;                method&#xA;            -&amp;gt; name&#xA;                type&#xA;                内容&#xA;            -&amp;gt; 响应&#xA;            -&amp;gt; 拦截器 -&amp;gt; ConfigAction类&#xA;&#xA;        # 1.部署时读取src/struts.xml和src/struts.properties文件，形成JavaBean对象&#xA;                # 两个文件同时存在时src/struts.properties文件为准&#xA;        ## 2.请求/*路径时，StrutsPreparedAndExecuteFilter过滤&#xA;        ## 3.获取JavaBean中的actionName ,actionClass, actionMethod, 执行方法&#xA;        ## 4.执行的返回值与resultName, resultType, resultContent进行比较&#xA;        ## 5.按resultType类型返回resultContent（路径和内容）&#xA;&#xA;# 缺点&#xA;    8个jar包，慢，servlet 快&#xA;    配置繁琐&#xA;# 编码&#xA;    struts2默认编码方式:utf-8&#xA;&#xA;    返回的图片相对路径中有中文时设置tomcat&#xA;        tomcat/conf/server.xml&#xA;            &amp;lt;Connector port=&amp;quot;8080&amp;quot; .. URIEncoding=&amp;quot;utf-8&amp;quot;/&amp;gt;&#xA;&#xA;        这时点击下载的请求路径中有中文时在以post方式提交 ,struts自动转码。若以get方式提交，需要在Action类的相应的get方法中转换url编码（iso8859-1）到u8&#xA;&#xA;        原理&#xA;                改了tomcat的内部编码以后，struts中的编码是u8，放在session 中，jsp支持u8,解释后发送的html中的编码没问题，查看没问题。&#xA;                下载post发送请求，浏览器请求的是url编码的u8,struts中也是u8执行下载&#xA;&#xA;                如果不改编码，struts 中是u8,如果以List方式放入session的话,session存储的是u8&#xA;                如果直接放入数据的话,session中存储的是8859-1,jsp取出数据需要转码为u8并设置自己的编码是u8,再发送给浏览器。&#xA;                浏览器这时获取图片正常,post方式提交的是u8,经过tomcat转换为8859-1,struts中自动转换编码到u8&#xA;                如果是以get方式提交请求，get中的中文在浏览器时进行url编码到8859-1,经过tomcat，再到struts,struts不对get方式的请自动进行转码&#xA;                向action类中注入参数时是8859-1编码,需要手动在action类中的属性的get方法中进行8859-1到u8的转码操作&#xA;# 内置对象&#xA;    struts中的6个内置对象&#xA;        # request请求进入struts中时创建，request请求结束时销毁。&#xA;        requestMap&#xA;        sessionMap&#xA;        applicationMap&#xA;        parameters&#xA;        attr                        # page -&amp;gt; request -&amp;gt; session -&amp;gt; application 的顺序查找&#xA;        valueStack                # 定义实例变量，直接放入valueStack的 list（栈） 中,map（值）很少向内存储数据&#xA;            # 定义的实例变量必须提供相应的get方法,否则ognl标签中取其数据时没有方法调用，就得不到它的值&#xA;            # list 中的值优先访问 ，但是map 中的值起决定作用&#xA;            # map中存放着一个大map,其中注入了所有页面的请求信息&#xA;                # requestMap sessionMap applicationMap 并不是真正的域对象，但最后通过拦截器放入到域对象中&#xA;&#xA;# 异常处理&#xA;    配置src/strut.xml 文件&#xA;        &amp;lt;global-results&amp;gt; 全局结果（用来跳转全局异常等）&#xA;        &amp;lt;global-exception-mappings&amp;gt; 全局异常&#xA;        &amp;lt;exception-mapping result=&amp;quot;nullJsp&amp;quot;        exception=&amp;quot;java.lang.NullPointerException&amp;quot; /&amp;gt;&#xA;            # &amp;lt;action&amp;gt;标签中的局部异常&#xA;            ## &amp;lt;action&amp;gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&amp;quot;nullJsp&amp;quot;的字符串交给本&amp;lt;action&amp;gt;标签中相应的&amp;lt;result&amp;gt;标签来处理&#xA;&#xA;&#xA;    处理机制&#xA;        o-&amp;gt; 多个异常时走子异常，父异常被忽略&#xA;        o-&amp;gt; 先处理小范围异常，大范围忽略&#xA;        o-&amp;gt;  如果异常没有处理，抛出到web服务器处理,web.xml的&amp;lt;error-page&amp;gt;&amp;lt;error-code&amp;gt;&amp;lt;location&amp;gt;&#xA;    全局异常&#xA;        xml文件中&#xA;            &amp;lt;global-results&amp;gt;&#xA;                &amp;lt;result name=&amp;quot;error&amp;quot;&amp;gt;&#xA;                    /error.jsp&#xA;                &amp;lt;/result&amp;gt;&#xA;            &amp;lt;/global-results&amp;gt;&#xA;            &amp;lt;global-exception-mappings&amp;gt;&#xA;                &amp;lt;exception-mapping result=&amp;quot;error&amp;quot; exception=&amp;quot;java.lang.Exception&amp;quot;/&amp;gt;&#xA;            &amp;lt;/global-exception-mappings&amp;gt;&#xA;        error.jsp页面中&#xA;            &amp;lt;%@ taglib prefix=&amp;quot;s&amp;quot; uri=&amp;quot;/struts-tags&amp;quot; %&amp;gt;&#xA;            异常信息：&amp;lt;s:property value=&amp;quot;exception.message&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;&#xA;            详细信息：&amp;lt;s:property value=&amp;quot;exceptionStack&amp;quot;/&amp;gt;&amp;lt;br/&amp;gt;&#xA;&#xA;&#xA;# 转递方式&#xA;    chain                        # action类之间转发&#xA;    dispatcher                # 转发到jsp&#xA;    freemarker&#xA;    httpheader&#xA;    redirect                # 重定向到页面&#xA;    redirectAction        # action 类之间重定向&#xA;    stream                        # 返回 InputStream流&#xA;    velocity&#xA;    xslt&#xA;    plainText&#xA;# Action类&#xA;    注意&#xA;        1.所有Action类都要继承ActionSupport类，否则execute方法返回的字符串不会回到struts拦截器再根据xml文件的配置进行转发&#xA;        2.action类是非单例的。        # 所有多实例的对象全部是因为有私有属性，否则全部应该是单例的&#xA;        3.action类放在栈的顶端，用于注入数据&#xA;&#xA;    传统方式得到request,response,servletContext,pageContext&#xA;        ServletActionContext.getPageContext()&#xA;        HttpServletRequest request = ServletActionContext.getRequest()&#xA;        ServletActionContext.getResponse()&#xA;        ServletActionContext.getServletContext();&#xA;&#xA;    优势&#xA;        实现与servlet的解耦&#xA;&#xA;    验证&#xA;        验证分类&#xA;                前台验证：javascript等&#xA;                后台验证：服务器&#xA;        struts2验证&#xA;                    后台验证&#xA;            1.代码式验证&#xA;            2.声明式验证:xml文件&#xA;&#xA;    ActionContext类&#xA;        调用方法&#xA;        ActionContext actionContext = ActionContext.getContext();&#xA;        得到内置对象        # 这几种得到作用域的方法均可以得到作用域中原有的值，也可以放入值&#xA;        request&#xA;                actionContext.put(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;);&#xA;        application&#xA;                Map&amp;lt;String,Object&amp;gt; applicationMap = actionContext.getApplication();&#xA;        session&#xA;                Map&amp;lt;String,Object&amp;gt; sessionMap = actionContext.getSession();&#xA;                        # 或 actionContext.get(&amp;quot;session&amp;quot;)得到，因为actionContext中存储着大map&#xA;        parameters&#xA;                Map&amp;lt;String,Object&amp;gt; parametersMap = actionContext.getParameters();&#xA;        valueStack&#xA;                ValueStack valueStack = actionContext.getValueStack()&#xA;                valueStack.getRoot()                        # 得到当前值栈的顺序&#xA;&#xA;    参数&#xA;        1.action类中可以直接创建属性与其get方法得到客户端get方法或post表单请求的参数(由struts2自动注入)&#xA;        2.action类中可以创建 JavaBean的属性来接收struts注入的参数，这时用户请求的参数名字要写成JavaBean名.JavaBean中的属性名（这样struts2会自动调用JavaBean的set方法来注入其中相应的参数 ）&#xA;## BaseAction&#xA;    作用&#xA;        权限管理&#xA;        存放常驻内存数据&#xA;        抽取常用的方法&#xA;# web.xml配置&#xA;    &amp;lt;filter&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;&#xA;        &amp;lt;filter-class&amp;gt; org.apache.struts2.dispatcher.FilterDispatcher &amp;lt;/filter-class&amp;gt;&#xA;        &amp;lt;init-param&amp;gt;&#xA;            &amp;lt;param-name&amp;gt;struts.action.extension&amp;lt;/param-name&amp;gt;&#xA;            &amp;lt;param-value&amp;gt;do&amp;lt;/param-value&amp;gt;&#xA;        &amp;lt;/init-param&amp;gt;&#xA;    &amp;lt;/filter&amp;gt;&#xA;    &amp;lt;filter-mapping&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;&#xA;        &amp;lt;url-pattern&amp;gt;*.json&amp;lt;/url-pattern&amp;gt;&#xA;    &amp;lt;/filter-mapping&amp;gt;&#xA;        # 设置全局过滤器，并且修改过滤扩展名&#xA;# default.properties&#xA;    src/struts.properties配置文件&#xA;        struts.custom.i18n.resources=struts    # 使自己的普通配置生效。如：/org/apache/struts2/struts-messages.properties文件的&#xA;            ## struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} &amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; {3}  属性，&amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; &amp;quot;{3}&amp;quot;是显示消息的占位符&#xA;            ## struts.action.extension=action,,可以不配置&#xA;            # 由于只加载properties文件，所以省略.properties&#xA;            ## =后面的是相对于src目录的文件&#xA;# ognl标签&#xA;    注意&#xA;        # jquery中不能定位ognl标签，而要用标签自己生成的id定位（看源码得到）&#xA;    使用：&#xA;        &amp;lt;%@ taglib uri=&amp;quot;/struts-tags&amp;quot; prefix=&amp;quot;s&amp;quot; %&amp;gt;&#xA;        tld映射文件路径&#xA;            struts2-core-2.3.1.1.jar包中&#xA;            /META-INF/struts-tags.tld&#xA;&#xA;    &#39;#&#39;出现的地方&#xA;        o-&amp;gt; 除ValueStack 之外的所有struts内置对象的取值前面都要加&#xA;        o-&amp;gt; 取JavaBean中的属性时要加 &#39;#&#39;，如&amp;quot;#user.username&amp;quot;,ValueStack中也不例外&#xA;        o-&amp;gt; 构造Map对象，Map：#{&#39;male&#39;:&#39;[男]&#39;,&#39;female&#39;:&#39;[女]&#39;}，构造radio和select标签，如&#xA;                        # &amp;lt;s:radio list=&amp;quot;#{&#39;male&#39;:&#39;aa&#39;,&#39;bb&#39;:&#39;cc&#39;}&amp;quot; name=&amp;quot;gender2&amp;quot; /&amp;gt;&#xA;        o-&amp;gt; 迭代数组或list集合&#xA;            集合的投影：userList.{username}&#xA;            集合的过滤：userList.{?#this.age&amp;gt;22}&#xA;&#xA;    主题与模板&#xA;        主题：为多个模板提供风格&#xA;            struts2-core-2.3.1.1.jar包中&#xA;                template中的四个主题&#xA;                    archive                # 其中是.vm文件，其它是.ftl文件。vm与ftl是两种视图技术&#xA;                        ajax        # 除此之外其它都不支持ajax&#xA;                        simple&#xA;                        xhtml&#xA;                    xhtml                # 默认主题,default.properties配置文件中定义&#xA;                    css_xhtml&#xA;                    simple&#xA;            修改主题&#xA;                1.struts.properties 中修改&#xA;                    struts.ui.theme=simple          # 针对当前webapp&#xA;                2.&amp;lt;s:form theme=&amp;quot;xhtml&amp;quot;&amp;gt;            # 只针对当前表单&#xA;                3.&amp;lt;s:textfield name=&amp;quot;username&amp;quot; theme=&amp;quot;simple&amp;quot;&amp;gt;  # 修改某个标签的属性&#xA;        模板：为标签提供样式&#xA;                做模板的技术freemarker&#xA;&#xA;    ognl标签的优点：自动排版、验证数据回显、国际化&#xA;&#xA;    所有标签：&#xA;        逻辑标签&#xA;            对 Map 集合的迭代：&#xA;                &amp;lt;s:iterator value=&amp;quot;#session.fileMap&amp;quot; var=&amp;quot;entry&amp;quot; status=&amp;quot;stat&amp;quot;&amp;gt;&#xA;                    &amp;lt;s:property value=&amp;quot;#entry.key&amp;quot;/&amp;gt;&#xA;                &amp;lt;s:if test=&amp;quot;#stat.count%4==0&amp;quot;&amp;gt;&amp;lt;/s:if&amp;gt;&#xA;                &amp;lt;/s:iterator&amp;gt;&#xA;            对 List 集合的迭代  List&amp;lt;User&amp;gt; userList&#xA;                普通迭代&#xA;                    &amp;lt;s:iterator var=&amp;quot;user&amp;quot; value=&amp;quot;userList&amp;quot;&amp;gt;      # 投影语法List&amp;lt;user&amp;gt;中的所有username&#xA;                    &amp;lt;s:property value=&amp;quot;#user.username&amp;quot;/&amp;gt;&#xA;                        投影语法&#xA;                    &amp;lt;s:iterator var=&amp;quot;username&amp;quot; value=&amp;quot;userList.{username}&amp;quot;&amp;gt;&#xA;                    &amp;lt;s:property/&amp;gt;                        # 这里不用写属性value=&amp;quot;username&amp;quot;就可以对page域中的username进行显示&#xA;                过滤语法&#xA;                    &amp;lt;s:iterator var=&amp;quot;user&amp;quot; value=&amp;quot;userList.{?#this.age&amp;gt;9}&amp;quot;&amp;gt;&#xA;                        # this代表当前被迭代的元素 ?#是所有 ^#是第一个 $#是最后一个  ?#...[0]按标记取&#xA;                    &amp;lt;s:property value=&amp;quot;#user.username&amp;quot; /&amp;gt;&#xA;        显示标签（UI标签）&#xA;            普通字符串中使用ognl&#xA;                jsp中用%{}      xml中用${}&#xA;                例如&#xA;                jsp中：&amp;lt;s:textfield label=&amp;quot;%{#attr.testValueStack}&amp;quot;/&amp;gt;&#xA;                xml中：&amp;lt;param name=&amp;quot;min&amp;quot;&amp;gt;4000&amp;lt;/param&amp;gt;&#xA;                                            &amp;lt;message&amp;gt;${min}&amp;lt;/message&amp;gt;&#xA;            普通信息&#xA;                &amp;lt;s:text name=&amp;quot;&amp;quot;/&amp;gt;&#xA;            输出值&#xA;                迭代器中&#xA;                        &amp;lt;s:property/&amp;gt;        # 直接输出被迭代的内容（简单）&#xA;                        &amp;lt;s:property value=&amp;quot;aa&amp;quot;/&amp;gt;&#xA;                        &amp;lt;s:property value=&amp;quot;#aa&amp;quot;/&amp;gt;&#xA;                普通&#xA;                        &amp;lt;s:property value=&amp;quot;username&amp;quot;/&amp;gt;      # 输出标签,得到valueStack中属性&#xA;                        &amp;lt;s:property value=&amp;quot;#request.name&amp;quot;/&amp;gt;                # 得到request域对象中的值&#xA;                                # request #session #application #parameters #attr&#xA;                                # &#39;#attr&#39;优先级：page,request,valueStack,session,application&#xA;            显示验证拦截器的验证信息集合中的数据：&#xA;                &amp;lt;s:fielderror/&amp;gt;                                                        # 显示所有错误信息&#xA;                &amp;lt;s:fielderror fieldName=&amp;quot;&amp;quot;/&amp;gt;                        # 显示验证返回的错误信息&#xA;            单选&#xA;                &amp;lt;s:radio list=&amp;quot;#{&#39;male&#39;:&#39;男&#39;,&#39;female&#39;:&#39;女&#39;}&amp;quot; name=&amp;quot;gender2&amp;quot; value=&#39;男&#39;&amp;gt;&#xA;                                # 自动加class id &amp;lt;label for=&amp;quot;gender2male&amp;quot;&amp;gt;等&#xA;                                # list键值对中male是实际值,男是显示值&#xA;                                # name是&amp;lt;input radio &amp;gt;的name属性&#xA;                                # value中是选中的项&#xA;            多选&#xA;                &amp;lt;s:select multiple=&amp;quot;true&amp;quot; list=&amp;quot;#{&#39;bj&#39;:&#39;北京&#39;,&#39;sh&#39;:&#39;上海&#39;,&#39;gz&#39;:&#39;广州&#39;}&amp;quot; name=&amp;quot;select1&amp;quot; value=&amp;quot;{&#39;sh&#39;,&#39;bj&#39;}&amp;quot;/&amp;gt;&#xA;            表单                        # 在ognl的标签中， struts的验证消息自动回显，不用加&amp;lt;s:fielderror/&amp;gt;标签&#xA;                &amp;lt;s:form action=&amp;quot;&amp;quot;&amp;gt;                # 默认中加上了 method=&amp;quot;post&amp;quot; action中加上了当前网站了contextPath路径&#xA;                        &amp;lt;s:textfield label=&amp;quot;用户名&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt;&#xA;                        &amp;lt;s:password label=&amp;quot;密码&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt;&#xA;                        &amp;lt;s:submit value=&amp;quot;登录&amp;quot; /&amp;gt;&#xA;            国际化                # 国际化一般放在整个网站的最后写&#xA;                                ##　伪国际化：将不同语言的页面放在不同文件夹中分别访问&#xA;                        # 国际化是通过i18n拦截器实现的&#xA;                1.创建国际化信息文件&#xA;                        message_zh_CH.properties      # 基名_语言名_国家名.properties&#xA;                                username=xxx&#xA;                                password=xxxx&#xA;                                submit=xx&#xA;                        message_en_US.properties&#xA;                        ..&#xA;                        message.properties                # 默认的显示语言&#xA;                                # 找伊拉克没有的话找本地区语言，本地语言没有的话找其它(默认的或美国等)&#xA;                2.struts.properties中引入国际化配置的属性文件&#xA;                        struts.custom,i18n.resources=struts2/tag/i18n/message        # 从src文件夹路径开始，只写基名&#xA;                3.验证消息国际化&#xA;                        message.properties文件中配置属性validationRequiredUsername=用户名错误&#xA;                        validation.xml文件中&#xA;                        &amp;lt;message key=&amp;quot;validationRequiredUsername&amp;quot;&amp;gt;&amp;lt;/message&amp;gt;&#xA;                4.jsp文件中用key属性代替 label属性(或其它在页面上显示信息的属性),key中写国际化信息文件中的key&#xA;                        &amp;lt;s:form action=&amp;quot;taglogin&amp;quot;&amp;gt;&#xA;                                &amp;lt;s:textfield key=&amp;quot;username&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt;&#xA;                                &amp;lt;s:password key=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt;&#xA;                                &amp;lt;s:submit key=&amp;quot;submit&amp;quot;/&amp;gt;&#xA;                        &amp;lt;/s:form&amp;gt;&#xA;                5.普通信息的国际化&#xA;                        message.properties中配置属性 normalMessage:普通信息&#xA;                        jsp中&amp;lt;s:text name=&amp;quot;normalMessage&amp;quot;/&amp;gt;&#xA;                6.测试&#xA;                        intername选项 -- 语言 改地区访问&#xA;&#xA;    xml文件中的ognl标签&#xA;            o-&amp;gt; ${aa}&#xA;                    1.调用转到该标签类的getAa()方法得到aa的值替换${aa}&#xA;                    2.本标签中name=&amp;quot;aa&amp;quot;的标签的文本节点的内容&#xA;            o-&amp;gt; {1}{2}{3}..{n}&#xA;                    匹配本标签中name=&amp;quot;*a*&amp;quot; 中的第n个‘*’,用于通配传递过来的参数的一部分的值&#xA;# ognl表达式&#xA;    ognl 开源，java写的免费标签,是struts2特有的&#xA;&#xA;    xml文件中&#xA;        ${Xxx}                取值栈中栈中的东西，如action类中的属性&#xA;        ${#Xxx}                取值栈中值的东西，如request,session域中的数据（其实就是老师说的内置对象【valueStack就是值栈】）&#xA;&#xA;    jsp文件中&#xA;        &amp;lt;s:iterator value=&amp;quot;#session.fileMap&amp;quot; var=&amp;quot;entry&amp;quot; status=&amp;quot;stat&amp;quot;&amp;gt;&#xA;            &amp;lt;s:property value=&amp;quot;#entry.key&amp;quot;/&amp;gt;&#xA;            &amp;lt;s:if test=&amp;quot;#stat.count%4==0&amp;quot;&amp;gt;&amp;lt;/s:if&amp;gt;&#xA;        &amp;lt;/s:iterator&amp;gt;&#xA;# strut.xml配置&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;!DOCTYPE struts PUBLIC&#xA;            &amp;quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&amp;quot;&#xA;            &amp;quot;http://struts.apache.org/dtds/struts-2.0.dtd&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;struts&amp;gt;&#xA;        &amp;lt;constant name=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/constant&amp;gt;&#xA;        &amp;lt;include file=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/include&amp;gt;&#xA;        &amp;lt;package name=&amp;quot;&amp;quot;&amp;gt;&#xA;                &amp;lt;interceptors&amp;gt;&#xA;                        &amp;lt;interceptor name=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/interceptor&amp;gt;&#xA;                        &amp;lt;interceptor-stack name=&amp;quot;&amp;quot;&amp;gt;&#xA;                                &amp;lt;interceptor-ref name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt;&#xA;                        &amp;lt;/interceptor-stack&amp;gt;&#xA;                &amp;lt;/interceptors&amp;gt;&#xA;                &amp;lt;default-interceptor-ref name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/default-interceptor-ref&amp;gt;&#xA;                &amp;lt;global-results&amp;gt;&#xA;                        &amp;lt;result name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;&#xA;                &amp;lt;/global-results&amp;gt;&#xA;                &amp;lt;global-exception-mappings&amp;gt;&#xA;                        &amp;lt;exception-mapping result=&amp;quot;&amp;quot; exception=&amp;quot;&amp;quot;/&amp;gt;&#xA;                &amp;lt;/global-exception-mappings&amp;gt;&#xA;                &amp;lt;action name=&amp;quot;&amp;quot;&amp;gt;&#xA;                        &amp;lt;param name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/param&amp;gt;&#xA;                        &amp;lt;result&amp;gt;&amp;lt;/result&amp;gt;&#xA;                        &amp;lt;result name=&amp;quot;input&amp;quot;&amp;gt;&amp;lt;/result&amp;gt;&#xA;                        &amp;lt;exception-mapping result=&amp;quot;&amp;quot; exception=&amp;quot;&amp;quot;/&amp;gt;&#xA;                        &amp;lt;interceptor-ref name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt;&#xA;                &amp;lt;/action&amp;gt;&#xA;        &amp;lt;/package&amp;gt;&#xA;    &amp;lt;/struts&amp;gt;&#xA;&#xA;    设置&#xA;        &amp;lt;constant name=&amp;quot;struts.devMode&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;                # 开启debug模式&#xA;                                                                # debug模式，不用重启调试(添加新的方法要重启，方法中改代码不用重启)&#xA;        &amp;lt;constant name=&amp;quot;struts.i18n.encoding&amp;quot; value=&amp;quot;utf-8&amp;quot;/&amp;gt;&#xA;                                                                # 配置struts的编码&#xA;        &amp;lt;constant name=&amp;quot;struts.configuration.xml.reload&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;&#xA;                                                                # 配置本属性，可以使得改动struts配置文件不用重启应用服务器&#xA;        &amp;lt;constant name=&amp;quot;struts.multipart.saveDir&amp;quot; value=&amp;quot;/upload&amp;quot;/&amp;gt;&#xA;                                                                # 配置上传存储路径&#xA;        &amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;action,do&amp;quot; /&amp;gt;&#xA;                                                                    # 配置过滤路径&#xA;    详细解释&#xA;        o-&amp;gt; 存放路径src/&#xA;        o-&amp;gt; 可以在struts-2.3.15.1的src\apps\blank\src\main\resources\struts.xml中参考配置文件&#xA;        o-&amp;gt; &amp;lt;include file=&amp;quot;struts2/cal/cal_struts.xml&amp;quot;/&amp;gt;标签包含其它路径的xml配置文件&#xA;                        #　被include的文件不能再include其它文件&#xA;        o-&amp;gt; &amp;lt;constant name=&amp;quot;struts.action.extension&amp;quot; value=&amp;quot;do,,&amp;quot;&amp;gt;&#xA;                默认值&#xA;                        default.properties中配置了默扩展名：struts.action.extension=action,,&#xA;                # 配置匹配到框架处理的扩展名，空逗号代表匹配没有扩展名&#xA;        o-&amp;gt; &amp;lt;package name=&amp;quot;xxPackage&amp;quot; extends=&amp;quot;struts-default&amp;quot; namespace=&amp;quot;/xx/&amp;quot;&amp;gt;&#xA;                默认值&#xA;                        namespace=&amp;quot;/&amp;quot;&#xA;                        extends=&amp;quot;struts-default&amp;quot;        # 不可省略&#xA;                # name是包的唯一标识，不可以写路径&#xA;                ## namespace 访问路径如/xx/a.do会匹配到该包执行其中的映射，按照域命名空间链的方式匹配，如：&#xA;                                                        /xx/yy/a.do也会匹配到该包，但是它优先匹配到/xx/yy的命名空间&#xA;                                                        /a.do 不会匹配到该包&#xA;                        注意：匹配/sys/*的名称空间是/sys 而非 /sys/&#xA;                ## struts的包有抽象包，普通包两种，通过继承可以加入包内容，相当于复制、粘贴&#xA;                ## 继承的包是struts-default，其路径是/struts-default.xml&#xA;                ## ，它定义了核心的bean和拦截器&#xA;        o-&amp;gt; &amp;lt;interceptors&amp;gt;&#xA;                        &amp;lt;interceptor name=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot;/&amp;gt;&#xA;                        &amp;lt;interceptor-stack name=&amp;quot;&amp;quot;&amp;gt;&#xA;                                &amp;lt;interceptor-ref name=&amp;quot;/&amp;quot;&amp;gt;&#xA;                                # 定义拦截器、定义拦截器栈（加入拦截器）&#xA;                                ## 拦截器栈中可以加栈&#xA;        o-&amp;gt; &amp;lt;default-interceptor-ref name=&amp;quot;&amp;quot;&amp;gt; 默认拦截器（可以用于验证用户登录）&#xA;        o-&amp;gt; &amp;lt;global-results&amp;gt; 全局结果（用来跳转全局异常等）&#xA;        o-&amp;gt; &amp;lt;global-exception-mappings&amp;gt; 全局异常&#xA;        o-&amp;gt; &amp;lt;action name=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot; method=&amp;quot;&amp;quot;&amp;gt;&#xA;                默认值&#xA;                        class=&amp;quot;com.opensymphony.xwork2.ActionSupport&amp;quot;&#xA;                        method=&amp;quot;execute&amp;quot;&#xA;                # name=&amp;quot;aa&amp;quot;时 .../aa.do的请求匹配到该方法执行&#xA;                ## class 是类字节码路径，method是其中的方法名&#xA;        o-&amp;gt; &amp;lt;param name=&amp;quot;aaa&amp;quot;&amp;gt;bbb&amp;lt;/param&amp;gt;&#xA;                调用 &amp;lt;action&amp;gt;标签中对象的实例的方法：setAaa(&amp;quot;bbb&amp;quot;);&#xA;        o-&amp;gt; &amp;lt;result name=&amp;quot;&amp;quot; type=&amp;quot;&amp;quot;&amp;gt;/ok.jsp&#xA;                默认值&#xA;                        name=&amp;quot;success&amp;quot;&#xA;                        type=&amp;quot;dispatcher&amp;quot;&#xA;                # name=&amp;quot;success&amp;quot;时，映射的method返回&amp;quot;success&amp;quot;时进入该result处理&#xA;                ## type是返回方式 ，如dispatcher redirect等&#xA;                        type的返回类型&#xA;                                dispatcher : 转发到jsp页面&#xA;                                redirect : 重定向到 jsp html 等页面&#xA;                                chain : Action 类之间的转发&#xA;                                redirectAction : Action 类之间的重定向&#xA;                                stream : 以 inputStream 的数据类型返回&#xA;                                        stream的参数                        # 可以从struts-default.xml文件中对应的stream参数对应的类的源码中查看其中的set方法找到要写参数的名称&#xA;                                                &amp;lt;param name=&amp;quot;contentType&amp;quot;&amp;gt;image/pjpeg&amp;lt;/param&amp;gt;                # 下载文件的类型                  另外如text/html; charset=utf-8返回给ajax异步数据&#xA;                                                &amp;lt;param name=&amp;quot;bufferSize&amp;quot;&amp;gt;2048&amp;lt;/param&amp;gt;                # 缓冲byte[]的大小，单位字节&#xA;                                                &amp;lt;param name=&amp;quot;contentDisposition&amp;quot;&amp;gt;attachment;filename=${uuidFileName}&amp;lt;/param&amp;gt;                # 设置下载响应头，只的下载时才设置。${uuidFileName}是一个OGNL表达式&#xA;                                                &amp;lt;param name=&amp;quot;inputName&amp;quot;&amp;gt;imageStream&amp;lt;/param&amp;gt;        # 框架调用传递给result标签结果字符串的对象中的getImageStream()方法，来获取InputStream流对象&#xA;                                                # 返回stream类型不指定返回的路径&#xA;                ## 标签间的内容：/ok.jsp 是响应的路径&#xA;        o-&amp;gt; &amp;lt;result name=&amp;quot;input&amp;quot; type=&amp;quot;&amp;quot;&amp;gt;/ok.jsp&#xA;                type中的参数                        # 可以从struts-default.xml配置文件中查到&#xA;                        dispatcher        # 转发&#xA;                        redirect        # 重定向&#xA;                        chain                # Action类之间转发，需要加参数，参数的名字&#xA;                                                ## ：struts-default.xml文件中找到&amp;quot;chain&amp;quot;对应的类，按快捷键ctrl + shift + T 关联类的源码文件，查找set方法改名即可&#xA;                                &amp;lt;param name=&amp;quot;actionName&amp;quot;&amp;gt;to&amp;lt;/param&amp;gt;&#xA;                                        # action标签的 name属性值&#xA;                                &amp;lt;param name=&amp;quot;namespace&amp;quot;&amp;gt;/&amp;lt;/param&amp;gt;&#xA;                                        # action的名称空间&#xA;                        redirectAction                # Action类之间重定向&#xA;&#xA;                # 各种拦截器不通过时默认的返回input，同时向request作用域中加入了相关错误信息供struts2的jsp标签进行显示&#xA;                ## 处理 返回值是input的返回信息跳转，就是处理拦截器拦截后的信息跳转&#xA;        o-&amp;gt; &amp;lt;exception-mapping result=&amp;quot;nullJsp&amp;quot;        exception=&amp;quot;java.lang.NullPointerException&amp;quot; /&amp;gt;&#xA;                # &amp;lt;action&amp;gt;标签中的局部异常&#xA;                ## &amp;lt;action&amp;gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&amp;quot;nullJsp&amp;quot;的字符串交给本&amp;lt;action&amp;gt;标签中相应的&amp;lt;result&amp;gt;标签来处理&#xA;        o-&amp;gt; &amp;lt;interceptor-ref name=&amp;quot;loginInterceptor&amp;quot;/&amp;gt;&#xA;                默认值&#xA;                        name=&amp;quot;defaultStack&amp;quot;&#xA;                # 指定在本&amp;lt;action&amp;gt;标签中使用的拦截器或拦截器栈&#xA;                ## 当指定了拦截器或拦截器栈以后，默认的defaultStack将会没有,此时defaultStack中的18个拦截器将不再执行&#xA;&#xA;    使用：OGNL对象图导航语言对标签中的路径进行动态设置&#xA;&#xA;# 验证&#xA;    struts2验证&#xA;        1.代码式: validate(),validateXxx()方法&#xA;                        # 单个验证与全部验证都存在时先单个验证，再全部验证，验证信息都加入验证信息集合&#xA;        2.声明式: Action类名-validation.xml&#xA;                                Action类名-&amp;lt;action标签的name属性&amp;gt;-validation.xml&#xA;                            # 单个验证与全部验证都存在时先全部验证，再单个验证，验证信息都加入验证信息集合&#xA;                    # 先声明验证，后代码验证&#xA;    参数驱动&#xA;        1.属性驱动: action中用属性收集表单参数&#xA;        2.模型驱动: javaBean收集参数&#xA;&#xA;    代码式（属性驱动）：&#xA;        步骤&#xA;        1.需要验证的Action类  继承 ActionSupport 类&#xA;                        # ActionSupport 类 实现了Validateable接口，该接口是验证接口&#xA;&#xA;        2.写验证方法&#xA;                1&amp;gt; public void validate()&#xA;                                # 方法重写（通用验证方法，本类中的所有其它方法执行前都执行）&#xA;&#xA;                2&amp;gt; public void validateXxxMethod()&#xA;                                # 或者自定义专用验证方法 xxxMethod为要验证的方法名，首字母要大写&#xA;&#xA;                        # 注意，通用、专用验证方法同时存在时，先执行专用验证方法，再执行通用验证方法&#xA;                        ## ，但是通用验证方法的错误消息无法加入到返回的错误集合中&#xA;&#xA;                3&amp;gt; this.addFieldError(&amp;quot;password&amp;quot;,&amp;quot;密码必填&amp;quot;);&#xA;&#xA;                        # 验证方法中添加错误信息到错误信息集合&#xA;                        ## addFieldError(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;)是从ActionSupport父类中继承的方法&#xA;&#xA;        3.jsp文件中通过验证标签：&#xA;                        &amp;lt;%@ taglib uri=&amp;quot;/struts-tags&amp;quot; prefix=&amp;quot;s&amp;quot;%&amp;gt;&#xA;                        &amp;lt;s:fielderror/&amp;gt;                # 显示所有错误信息&#xA;                        &amp;lt;s:fielderror fieldName=&amp;quot;password&amp;quot;/&amp;gt;&#xA;                显示验证出错信息&#xA;&#xA;        4.xml配置&#xA;            &amp;lt;!-- 验证错误信息处理 --&amp;gt;&#xA;                &amp;lt;result name=&amp;quot;input&amp;quot; type=&amp;quot;dispatcher&amp;quot;&amp;gt;&#xA;                        /error.jsp&#xA;                &amp;lt;/result&amp;gt;&#xA;                        # 写在需要验证的方法对应的标签中，验证错误时验证方法会优先返回&amp;quot;input&amp;quot;字符串&#xA;&#xA;&#xA;    声明式（属性驱动）：&#xA;        1.验证Action类继承ActionSupport&#xA;        2.验证Action类目录下配置文件&#xA;            Action类名-validation.xml&#xA;            Action类名-&amp;lt;action标签的name属性&amp;gt;-validation.xml&#xA;                # 放入此名字的配置文件就相当于加了验证，不需要做其它事情&#xA;                ## ，相当于分别向Actioin类中加入了validate()validateXxx()方法进行了相应验证&#xA;                文件内容&#xA;                &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;                    &amp;lt;!DOCTYPE validators PUBLIC&#xA;                    &amp;quot;-//Apache Struts//XWork Validator 1.0.3//EN&amp;quot;&#xA;                    &amp;quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&amp;quot;&amp;gt;&#xA;                    &amp;lt;validators&amp;gt;&#xA;                            &amp;lt;field name=&amp;quot;username&amp;quot;&amp;gt;                # 要验证的属性&#xA;                                    &amp;lt;field-validator type=&amp;quot;requiredstring&amp;quot;&amp;gt;&#xA;                                            &amp;lt;message&amp;gt;用户名必填&amp;lt;/message&amp;gt;&#xA;                                    &amp;lt;/field-validator&amp;gt;&#xA;                            &amp;lt;/field&amp;gt;&#xA;                            &amp;lt;field-validator type=&amp;quot;regex&amp;quot;&amp;gt;&#xA;                                    &amp;lt;param name=&amp;quot;expression&amp;quot;&amp;gt;^[\u3447-\uFA29]+$&amp;lt;/param&amp;gt;&#xA;                                    &amp;lt;message&amp;gt;UserAction2-validation==&amp;gt;必须写中文&amp;lt;/message&amp;gt;&#xA;                            &amp;lt;/field-validator&amp;gt;&#xA;                    &amp;lt;/validators&amp;gt;&#xA;&#xA;                            # xml文件的头在 xwork-core-2.3.1.1.jar包的&#xA;                                    xwork-validator-1.0.3.dtd中复制&#xA;                            ## 关联约束在&#xA;                                    \struts-2.3.15.1\src\xwork-core\src\main\resources\xwork-validator-1.0.3.dtd文件&#xA;                            ## &amp;lt;field-validator type=&amp;quot;&amp;quot;&amp;gt;的约束类型在xwork-core-2.3.1.1.jar包的&#xA;                                            /com/opensymphony/xwork2/validator/validators/default.xml文件中&#xA;                                                    # 16个规则&#xA;                                                    ## type=&amp;quot;regex&amp;quot;相当于调用了default.xml文件中配置的&#xA;                                                        ## RegexFieldValidator类的 setExpression方法&#xA;        3.jsp文件中通过验证标签（同上）&#xA;        4.xml配置（同上）&#xA;            # 出错信息&#xA;                1.验证文件名写错，无提示，不验证&#xA;                2.&amp;lt;field-validator type=&amp;quot;&amp;quot;&amp;gt;写错，有明显提示&#xA;                2.&amp;lt;field name=&amp;quot;salaryy&amp;quot;&amp;gt;写错，获取的salaryy为空。&#xA;&#xA;    声明式（模型驱动）&#xA;            1.创建bean对象，bean对象中封装属性&#xA;            2.验证Action类继承ActionSupport类，声明bean对象实例&#xA;            3.action类同目录 中  ：Action类名-&amp;lt;action标签的name属性&amp;gt;-validation.xml&#xA;                            # &amp;lt;field-validator type=&amp;quot;visitor&amp;quot;&amp;gt;&#xA;                    # bean类同目录中：bean类名-validation.xml配置验证文件&#xA;            4.jsp文件请求参数改为：action类中bean对象名.bean对象封装的属性名。用&amp;lt;s:fielderror/&amp;gt;标签得到返回的错误信息&#xA;            5.xml配置（同上）&#xA;&#xA;    原理&#xA;    StrutsPreparedAndExecuteFilter&#xA;        1.注入参数&#xA;                setUsername()&#xA;            setPassword()&#xA;        2.验证方法：validate()或validateXxx()&#xA;                        验证配置文件中验证：Action类名-validation.xml&#xA;        3.转发：根据验证成功或失败返回消息&#xA;                        验证集合无错误消息成功Action --&amp;gt; execute或同签名的方法&#xA;                        验证集合有错误消息失败&amp;lt;result name = &amp;quot;input&amp;quot; type=&amp;quot;dispatcher&amp;quot;&#xA;                                            register.jsp/login.jsp&#xA;# 过滤器&#xA;    StrutsPrepareAndExecuteFilter&#xA;        中查看Dispathcer类，从中找到配置struts-default.xml,struts-plugin.xml,struts.xml值的属性DEFAULT_CONFIGURATION_PATHS&#xA;        查找引用该属性的方法为init_TraditionalXmlConfigurations&#xA;        查看引用该方法的方法为init&#xA;        回头看StrutsPrepareAndExecuteFilter中初始化dispatcher对象的方法initDispatcher&#xA;                其中调用了dispatcher.init();方法来配置dispatcher&#xA;        由此可以知道struts在启动时加载了struts-default.xml,struts-plugin.xml,struts.xml配置文件&#xA;# 拦截器&#xA;    struts-core-2.3.1.1.jar包中的&#xA;        struts-default.xml文件中&#xA;                定义了32个interceptor（拦截器）&#xA;                        i18n    # 国际化&#xA;            token  # 表单重复提交&#xA;            validation  # 验证&#xA;            params  # 参数拦截器,向Action类中注入参数&#xA;            cookie&#xA;        interceptor-tack    # 拦截栈&#xA;                # 拦截栈中的拦截器的先后顺序有影响&#xA;                basicStack&#xA;            defaultStack    # 每个http请求都会经过该拦截栈&#xA;                            ## 其中的18个拦截器, &amp;lt;default-interceptor-ref&amp;gt;中定义&#xA;    原理&#xA;            拦截器仿照过滤器建立，内部实现原理是完全相同的&#xA;    执行流程&#xA;            拦截器构构造函数 -&amp;gt; action构造函数 -&amp;gt; 拦截器1 in -&amp;gt; 拦截器2 in -&amp;gt; demo -&amp;gt; 拦截器2 out -&amp;gt; 拦截器1 out&#xA;        exception拦截器最先进，最后出&#xA;    自定义拦截器&#xA;        1.定义Action类，继承Interceptor接口，重写生命周期方法&#xA;            public LoginInterceptor() {&#xA;            }&#xA;            public void destroy() {&#xA;            }&#xA;            public void init() {&#xA;            }&#xA;            public String intercept(ActionInvocation invocation)  {&#xA;            }&#xA;        2.配置struts.xml文件&#xA;            1&amp;gt; 定义拦截器、拦截器栈&#xA;                &amp;lt;interceptors&amp;gt;&#xA;                    &amp;lt;interceptor name=&amp;quot;loginInterceptor&amp;quot; class=&amp;quot;interceptor.LoginInterceptor&amp;quot;/&amp;gt;&#xA;                    &amp;lt;interceptor name=&amp;quot;roleInterceptor&amp;quot; class=&amp;quot;interceptor.RoleInterceptor&amp;quot;/&amp;gt;&#xA;                    &amp;lt;interceptor-stack name=&amp;quot;crmStack&amp;quot;&amp;gt;&#xA;                        &amp;lt;interceptor-ref name=&amp;quot;loginInterceptor&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt;&#xA;                        &amp;lt;interceptor-ref name=&amp;quot;roleInterceptor&amp;quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt;&#xA;                    &amp;lt;/interceptor-stack&amp;gt;&#xA;                &amp;lt;/interceptors&amp;gt;&#xA;            2&amp;gt; &amp;lt;action&amp;gt;标签中声明用到的拦截器或拦截器栈&#xA;                    &amp;lt;interceptor-ref name=&amp;quot;loginInterceptor&amp;quot; /&amp;gt;                # 此时默认的defaultStack拦截器栈会被替代掉&#xA;    自定义方法过滤拦截器&#xA;        # MethodFilterInterceptor继承AbstractInterceptor继承Interceptor，前两个是struts自己实现的自己的包装类&#xA;        ## 原理：自己实现intercept方法，实现对方法名的过滤。如果符合通过条件，则执行自己的doIntercept方法。所以要求用户重写doIntercept方法实现业务逻辑&#xA;        &amp;lt;interceptor name=&amp;quot;aloginInterceptor&amp;quot; class=&amp;quot;cn.it.shop.interceptor.AloginInterceptor&amp;quot;&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;excludeMethods&amp;quot;&amp;gt;*$&amp;lt;/param&amp;gt;                # 除了*$匹配的方法都执行此拦截器&#xA;                    ## includeMethods为包含匹配的方法执行拦截器&#xA;        &amp;lt;/interceptor&amp;gt;&#xA;    生命周期&#xA;        部署时初始化，每次符合&amp;lt;action&amp;gt;的请求时，执行拦截器&#xA;    拦截器Action 类&#xA;        o-&amp;gt; 继承Interceptor 接口&#xA;        o-&amp;gt; 重写生命周期方法&#xA;            String intercept(ActionInvocation invocation)方法中调用&#xA;                invocation.invoke() 放行&#xA;                invocation.getAction()得到当前的Action类&#xA;                invocation.getStack()得到值栈中的栈&#xA;                    # invocation用于调试18个拦截器&#xA;    具体拦截器&#xA;        struts-default.xml 文件中定义了32种拦截器&#xA;                alias&#xA;        autowiring&#xA;        chain&#xA;        conversionError&#xA;        cookie&#xA;        clearSession&#xA;        createSession&#xA;        debugging&#xA;        execAndWait&#xA;        exception&#xA;        fileUpload                                # 只用来验证已经注入的文件是否合格，合格则通过，不合格则不执行action类中对应请求的方法&#xA;        i18n&#xA;        logger&#xA;        modelDriven                                # 用于检查action类是否实现ModelDriven&amp;lt;T&amp;gt;接口，然后调用getModel()方法注入得到的对象到栈的项端。&#xA;        scopedModelDriven&#xA;        params                                        # 注入参数用，包括注入文件（级联注入文件的ContentType与FileName）&#xA;        actionMappingParams&#xA;        prepare&#xA;        staticParams&#xA;        scope&#xA;        servletConfig                                # 向自定义的实现RequestAware等接口的Action类（一般是BaseAction类）中注入request等相应的map对象&#xA;        timer&#xA;        token                                                # 防止重复提交&#xA;        tokenSession&#xA;        validation                                # 验证&#xA;        workflow&#xA;        store&#xA;        checkbox&#xA;        profiling&#xA;        roles&#xA;        annotationWorkflow&#xA;        multiselect&#xA;    数据传递&#xA;        o-&amp;gt; 拦截器不会向其它拦截器中注入参数，所以自定义拦截器中了参数要从request中获取&#xA;        o-&amp;gt; 如果想 显式的引用了自己的拦截栈，默认的拦截栈就不引用了，要自己引用，其中的注入参数拦截器向action类中注入参数&#xA;    技巧&#xA;        &amp;lt;interceptor-stack name=&amp;quot;defaultStack&amp;quot;&amp;gt;    # 对defaultStack进行替换，在它前面添加自定义的拦截器&#xA;        &amp;lt;interceptor-ref name=&amp;quot;aloginInterceptor&amp;quot;/&amp;gt;&#xA;        &amp;lt;interceptor-ref name=&amp;quot;defaultStack&amp;quot;/&amp;gt;&#xA;    拦截器中的ActionInvocation对象&#xA;        可以得到ActionContext&#xA;&#xA;# 文件处理&#xA;## 上传&#xA;    struts2文件上传步骤&#xA;        1.编写jsp文件&#xA;                1&amp;gt; post方式提交&#xA;                2&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file1&amp;quot;/&amp;gt; 要添加name属性&#xA;                3&amp;gt; post表单上传的编码方式是enctype=&amp;quot;multipart/formdata&amp;quot;&#xA;        2.创建Action类，不必继承任何类(但是如果不继承ActionSupport类的话，拦截器将不会返回提示消息)&#xA;                1&amp;gt; 定义参数        # 如果不接收上传文件名字符串数组而从文件对象中获取文件名的话，得到的文件名将会是乱码&#xA;                        private File[] image;                                                # 字段名&#xA;                        private String[] imageContentType;                        # 文件类型&#xA;                        private String[] imageFileName;                                # 文件名&#xA;                        private String uploadPath;&#xA;                                        # 前三个参数可以不是数组，在 struts-default.xml配置文件fileUpload拦截器对应的源码中可以找到定义规则：&#xA;                                                &amp;lt;li&amp;gt;[File Name] : File - the actual File&amp;lt;/li&amp;gt;&#xA;                                                &amp;lt;p/&amp;gt; &amp;lt;li&amp;gt;[FileName]ContentType : String - the content type of the file&amp;lt;/li&amp;gt;&#xA;                                                &amp;lt;p/&amp;gt;&amp;lt;li&amp;gt;[File Name]FileName : String - the actual name of the file uploaded(not the HTML name)&amp;lt;/li&amp;gt;&#xA;                                        # uploadPath是我们自定义的配置文件中注入过来的文件存储位置&#xA;&#xA;                2&amp;gt; 写execute方法保存文件到路径，返回成功消息&#xA;        3.Action类的配置文件，include到src/struts.xml文件中&#xA;                        1&amp;gt; &amp;lt;action&amp;gt;标签中配置name=&amp;quot;input&amp;quot;的标签&amp;lt;result&amp;gt;来返回出错消息&#xA;                        2&amp;gt; &amp;lt;action&amp;gt;标签中用param标签注入文件存储路径：uploadPath 底层执行setUploadPath()方法&#xA;                        3&amp;gt; &amp;lt;action&amp;gt;标签中通过&amp;lt;interceptor-ref name=&amp;quot;fileUpload&amp;quot;&amp;gt;标签对上传文件进行参数上的限定&#xA;                                1&amp;gt; &amp;lt;param name=&amp;quot;maximumSize&amp;quot;&amp;gt; 单个文件的最大尺寸(字节)&#xA;                                2&amp;gt; &amp;lt;param name=&amp;quot;allowedExtensions&amp;quot;&amp;gt; 文件扩展名&#xA;                                3&amp;gt; &amp;lt;param name=&amp;quot;allowedTypes&amp;quot;&amp;gt; 文件实际类型，如image/jpeg，可从tomcat配置文件web.xml中查找&#xA;        4.配置返回消息的信息&#xA;                ：src/struts.properties文件中&#xA;                        struts.custom.i18n.resources=struts                # 解锁自/org/apache/struts2/default.properties总配置文件&#xA;                                        # 加载自己，=后面是参照src/目录的相对路径 ，省略掉.properties扩展名&#xA;                        struts.multipart.maxSize=2097152                #  解锁自/org/apache/struts2/default.properties总配置文件&#xA;                                        # 设置上传文件总量的大小&#xA;                        struts.messages.error.file.too.large=\u6587\u4EF6\u592A\u5927\: {0} &amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; {3}&#xA;                        struts.messages.error.content.type.not.allowed=\u6587\u4EF6\u7C7B\u578B\u4E0D\u6B63\u786E\: {0} &amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; {3}&#xA;                        struts.messages.error.file.extension.not.allowed=\u6269\u5C55\u540D\u4E0D\u6B63\u786E\: {0} &amp;quot;{1}&amp;quot; &amp;quot;{2}&amp;quot; {3}&#xA;                                        # 覆盖/org/apache/struts2/default.properties总配置文件的响应消息,=后面是中文的unicode编码的iso8859-1的表示形式，通过视图可以直接配置，也可以用java/bin目录下的native2ascii.exe工具进行转码&#xA;&#xA;    多文件上传&#xA;        出现有多个文件共同上传时，文件拦截器会出现一错全错的情况，这时我们利用struts的一个&#xA;                小bug---文件拦截不成功也调用action类的setXxx方法传入文件，从set函数中对文件进行筛选和转存&#xA;                这时文件拦截器已经形同虚设，一点作用也不起了。&#xA;&#xA;    原理过程&#xA;        1.上传请求经过struts2的过滤器匹配扩展名&#xA;        2.按src/struts.xml文件中声明的配置包映射的名称空间映射到配置包&#xA;        3.根据action标签的name属性匹配名称空间与扩展名之间的“文件名”,映射到该action标签&#xA;                1&amp;gt; 经过多层拦截器&#xA;                2&amp;gt; 用param标签注入文件存储路径&#xA;                3&amp;gt; 通过&amp;lt;interceptor-ref name=&amp;quot;fileUpload&amp;quot;&amp;gt;标签对上传文件进行参数上的限定&#xA;                2&amp;gt; 执行action标签对应类的方法，该方法返回的返回的字符串进行响应&#xA;&#xA;    默认配置&#xA;        1.defaultStack拦截栈中的fileUpload拦截器进行处理&#xA;        2.default.properties配置文件中 对multipart的上传方式进行了配置&#xA;                struts.multipart.parser=jakarta                  # struts使用了第三方的jakerta来给上传文件解码&#xA;                struts.multipart.saveDir=                      # 缓存文件的临时目录，不填默认是&#xA;                                                                                        ## work/catalina/localhost/web工程名/upload_.....00000..tmp&#xA;                struts.multipart.maxSize=2097152      # 默认支持的上传文件的大小 (字节，2m)，是总大小&#xA;        3.多数服务器自己删除缓存文件&#xA;## 下载&#xA;    用传递类型为stream 来返回要下载的文件&#xA;    写法&#xA;        &amp;lt;result name=&amp;quot;success&amp;quot; type=&amp;quot;stream&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- 下载文件的类型 --&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;contentType&amp;quot;&amp;gt;image/pjpeg&amp;lt;/param&amp;gt;&#xA;            &amp;lt;!-- byte[]的大小，单位字节 --&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;bufferSize&amp;quot;&amp;gt;2048&amp;lt;/param&amp;gt;&#xA;            &amp;lt;!-- 设置下载响应头，${uuidFileName}是一个OGNL表达式，不是EL表达式 --&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;contentDisposition&amp;quot;&amp;gt;attachment;filename=${uuidFileName}&amp;lt;/param&amp;gt;&#xA;            &amp;lt;!-- 框架调用getXxx()方法，来获取InputStream流对象 --&amp;gt;&#xA;            &amp;lt;param name=&amp;quot;inputName&amp;quot;&amp;gt;imageStream&amp;lt;/param&amp;gt;&#xA;        &amp;lt;/result&amp;gt;&#xA;            # 与其它同样，要注入的参数从stream类型对应的类中可以进行查看&#xA;    显示与下载的编码问题&#xA;        o-&amp;gt; 设置tomcat/conf/server.xml&#xA;            &amp;lt;Connector port=&amp;quot;8080&amp;quot; .. URIEncoding=&amp;quot;utf-8&amp;quot;/&amp;gt;&#xA;        o-&amp;gt; 提交下载请求用post方式，struts框架自动给post请求编码解码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据&#34;&gt;&#xA;  数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;日志-1&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;scribe&#xA;    facebook出品&#xA;    特点&#xA;        支持nfs存储&#xA;    结构&#xA;        scribe agent&#xA;            向scribe发送数据&#xA;        scribe&#xA;            接收数据，不同topic 的数据发送给不同的store中&#xA;        存储系统(store)&#xA;            file, buffer, network, bucket, null, thriftfile, multi&#xA;chukwa&#xA;    # apache出品，hadoop系列产品&#xA;flume&#xA;    cloudera出品&#xA;    特点&#xA;        可靠性(节点故障时，日志传送到其他节点)&#xA;            三种级别&#xA;                end-to-end 发送前写磁盘，成功时删除&#xA;                store on failure 失败返回时写磁盘&#xA;                best effort 不确认数据是否成功&#xA;        可扩展性&#xA;            agent collector storage三层架构，每层可扩展。&#xA;                agent: 将数据源数据发送给collector&#xA;                collector: 将多个agent数据汇总后, 加载到storage中&#xA;                storge: 存储系统, 可以是file, hdfs, hive, hbase等&#xA;            agent collector 由master统一&#xA;logstash&#xA;    # 分布式日志收集，需结合kafka&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;爬虫&#34;&gt;&#xA;  爬虫&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%88%ac%e8%99%ab&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;cheerio&#xA;    # node解析html，如jquery&#xA;scrapy-redis&#xA;    # python 分布式爬虫框架&#xA;phantomjs&#xA;    # js浏览器模拟框架&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分析&#34;&gt;&#xA;  分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pandas&#xA;    # python数据分析&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;计算&#34;&gt;&#xA;  计算&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;druid&#xA;    # apache&#xA;    特点&#xA;        分布式, 扩展性强&#xA;        高可用，可回滚&#xA;        内存, 时序数据库&#xA;        亚秒级OLAP,  实时分析&#xA;        多租户&#xA;spark&#xA;stream&#xA;hadoop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;搜索&#34;&gt;&#xA;  搜索&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%90%9c%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    垂直搜索引擎&#xA;        针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。&#xA;    通用搜索引擎&#xA;        通过关键字的方式实现的，是语义上的搜索，返回的结果倾向于知识成果，比如文章，论文，新闻等&#xA;        通用搜索引擎的信息量大、查询不准确、深度不够&#xA;        通用搜索引擎的海量信息无序化&#xA;&#xA;部分&#xA;    １.索引&#xA;    ２.分词&#xA;    ３.搜索&#xA;&#xA;compass&#xA;    # 基于lucene&#xA;nutch&#xA;    # 基于lucene&#xA;sunspot&#xA;    # 基于Rsolr，以dsl结构用ruby调solr&#xA;sphinx&#xA;    # 基于sql的全文检索引擎&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;lucene&#34;&gt;&#xA;  lucene&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lucene&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 原理&#xA;    block k-d tree&#xA;    倒排索引&#xA;        词典&#xA;            排序数组&#xA;                # 为了二分查找&#xA;                # 实现简单，性能差&#xA;            哈希表&#xA;                # 性能好，占内存大&#xA;            跳跃表&#xA;                # 内存小且可调节, 模糊查询不好&#xA;            B/B+树&#xA;                # 磁盘索引 ，更新方便，检索慢&#xA;            trie树&#xA;                # 效率与字符串长度有关，只适合做英文词典&#xA;            dat&#xA;                # 可做中文词典，内存占用小&#xA;            fst&#xA;                # 共享前缀，内存占用小，要求输入有序，不易更新&#xA;                内存存前缀索引、磁盘存后缀词块&#xA;        倒排表&#xA;        正向文件&#xA;            # 行式存储，原始文档&#xA;        doc-values&#xA;            # 列式存储，文档号到值的映射&#xA;    文件指纹&#xA;&#xA;# 概念&#xA;    index&#xA;        # 一个倒排表，对应一个目录&#xA;    segment&#xA;        # index的存储单元，包含多个文档&#xA;    document&#xA;        # 创建单位&#xA;    field&#xA;        # 文档里的键值对&#xA;    term&#xA;        # 分词后的字符串&#xA;    analyzer&#xA;        tokenizer&#xA;            # 切分文本到索引单元&#xA;        tokenfilter&#xA;            # 对token预处理&#xA;# 常识&#xA;    特性&#xA;        索引&#xA;        高亮&#xA;        命中率排序&#xA;        分词&#xA;    与数据库的区别：数据库注重存储、全文检索注重查询&#xA;    其它搜索：多媒体搜索&#xA;    索引库(文件夹 或 内存中)：&#xA;        只存储了商品的基本信息&#xA;         索引库与数据库定时同步&#xA;        索引库 -&amp;gt; document -&amp;gt; field                # field是键值对,值只能存数据&#xA;                同步&#xA;        IndexWriter:addDocumnet(),delteDocument(),updateDocument()&#xA;                查询&#xA;                        IndexSearch:search(),get()&#xA;        Field的内部结构&#xA;                    # 不存不索引会报错&#xA;        Store:控制此Field字段是否存储到索引库中&#xA;        Index:是否建立索引（索引不区分大小写,过滤词不创建索引）&#xA;            NO:不建立索引，可以通过field的key查到，但是不能通过关键字查询到&#xA;            NOT_ANALYZED:建立索引，但是不分词&#xA;            ANALYZEd:建立索引又分词&#xA;# 使用到的对象&#xA;    Directory&#xA;    Analyzer&#xA;        TokenStream tokenStream = analyzer.tokenStream(&amp;quot;eldName&amp;quot;,new StringReader(&amp;quot;测试字符串&amp;quot;))&#xA;        while(tokenStream.incrementToken()){&#xA;                TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class);&#xA;                System.out.println(termAttribute.term());&#xA;        }                # 使用分词器测试分词&#xA;    Document&#xA;        add(Field)&#xA;        document = indexSearcher.doc(ScoreDoc)&#xA;        get(String)                # 通过key查找value&#xA;    IndexWriter&#xA;        IndexWriter(directory,analyzer,MaxFieldLength.LIMITED);       # LIMITED限定Field的数量(源码中规定默认值)&#xA;        addDocument(Document)&#xA;        commit()&#xA;        close()                        # 自带commit()&#xA;        rollback()&#xA;    IndexSearcher&#xA;    QueryParser&#xA;        QueryParser(Version.LUCENE_30,&amp;quot;name&amp;quot;,analyzer)&#xA;    Query&#xA;        query = parser.parse(用户传递的字符串);&#xA;        query = parser.parseMultiField(String [], 用户传递的字符串);&#xA;    TopDocs&#xA;        topDocs = indexSearcher.search(query, 10);                # 10是期望的结果数&#xA;                                                                                                        ## 最终查询到的结果数是：期望结果数与实际结果数的最小值&#xA;        totalHits                # 命中的结果数&#xA;    ScoreDoc&#xA;        ScoreDoc [] scoreDocs = topDocs.scoreDocs;&#xA;        scoreDoc.score                # 命中率积分&#xA;        scoreDoc.doc                # 命中文档编号，该编号由lucene自动生成&#xA;    Term                # 索引项&#xA;        Term(&amp;quot;field中的key&amp;quot;,&amp;quot;field中value解析出的关键字&amp;quot;)&#xA;# 索引的结构&#xA;    Term(&amp;quot;key&amp;quot;,&amp;quot;value&amp;quot;)[0,3,4]                        # key 为对应的field中的&amp;quot;key&amp;quot;,value对应的是解析field的&amp;quot;value&amp;quot;出的关键字&#xA;                                                                                ## []中的内容为匹配的文档编号，该编号为系统自动生成的&#xA;# 注意&#xA;    lucene创建索引时field的key都可以重复，没有主键方面的限制。但是实际应用时要求我们为document有唯一的标识“主键”field,便于对每个document进行更新与删除&#xA;# 使用&#xA;    包：IKAnalyzer,lucence-analyzer(英文分词，不需要),memory,core,highlighter&#xA;    工具：lukeAll 用来查看索引库&#xA;    添加、查询、删除、修改&#xA;    抽取配置类（构造方法私有化）&#xA;        Configuration&#xA;            维护了directory与analyzer&#xA;        DocumentUtil&#xA;            goodsToDocument(Goods)&#xA;            documentToGoods(Document)&#xA;        LuceneUtil&#xA;            维护了indexWriter与indexSearcher&#xA;            注意&#xA;                    1.indexWriter在static代码块中初始化&#xA;                    2.getIndexWriter&#xA;        LuceneService&#xA;            用indexWriter与indexSearcher处理业务逻辑&#xA;            添加&#xA;                indexWriter.addDocument(Document)&#xA;                indexWriter.rollback()&#xA;            删除&#xA;                indexWriter.deleteDocument(Term)&#xA;                indexWriter.optimize()                # 删除document的时候同步索引库，没有设置的话只是删除document，但是索引中还是可以查到&#xA;            更新&#xA;                indexWriter.updateDocument(Term,Document)&#xA;                indexWriter.optimize()                # 更新是先删除再添加（所以如果updateDocument(Term,Document)中匹配多个Document时，会出现删除了多个Document,而添加了一个Document的情况）&#xA;            查询&#xA;                QueryParser parser = new QueryParser(Version.LUCENE_30, &amp;quot;field中的key&amp;quot;, analyzer);&#xA;                Query query = IKQueryParser.parseMultiField(new String[]{&amp;quot;name&amp;quot;,&amp;quot;remark&amp;quot;}, &amp;quot;ee&amp;quot;);                # 多字段查询，IKAnalyzer特有&#xA;                    #　多字段查询到的第二个字段的结果，在转换高管时（调用getBestFragment时）只会对该方法指定的一个字段进行匹配，如果该字段不匹配时（但是第二个字段匹配），则会返回空。&#xA;                    ## 针对这一个bug,在getBestFragment处理匹配的结果返回空时，不使用空而直接返回没有高亮的字符串即可。&#xA;                parser.parse(用户传递的字符串);&#xA;                TopDocs topDocs = indexSearcher.search(query, 3);        # 3是期望结果数&#xA;                ScoreDoc [] scoreDocs = topDocs.scoreDocs;&#xA;                Document document = indexSearcher.doc(scoreDoc.doc);                scoreDoc.doc得到文档编号&#xA;                分页查询：&#xA;                    传递当前页码与一页记录数&#xA;                    利用topDocs.totalHits得到总记录数&#xA;                    查询本页与前面所有页的期望数据量，然后只截取本页的文档编号，得到document并返回数据&#xA;&#xA;# 分词器&#xA;    IKAnalyzer&#xA;        配置文件&#xA;            src/IKAnalyzer.cfg.xml中配置&#xA;                &amp;lt;properties&amp;gt;&#xA;                    &amp;lt;entry key=&amp;quot;ext_dict&amp;quot;&amp;gt;/mydict.dic&amp;lt;/entry&amp;gt;                 # 配置自己的字典（不分词）&#xA;                    &amp;lt;entry key=&amp;quot;ext_stopwords&amp;quot;&amp;gt;/ext_stopword.dic&amp;lt;/entry&amp;gt;                 # 配置跳过的字&#xA;                &amp;lt;/properties&amp;gt;&#xA;        Query query = IKQueryParser.parse(&amp;quot;name&amp;quot;,name);                # IKAnalyzer特有&#xA;# 排序&#xA;    Directory directory = FSDirectory.open(new File(&amp;quot;d:/lucene&amp;quot;));&#xA;    IndexSearcher indexSearcher = new IndexSearcher(directory);&#xA;    Query query = IKQueryParser.parse(&amp;quot;name&amp;quot;,&amp;quot;cc&amp;quot;);&#xA;    Sort sort = new Sort(new SortField(&amp;quot;id&amp;quot;, SortField.INT,true));                # 这里可以排序多个字段&#xA;        # 参数1：&amp;quot;id&amp;quot;是排序的field字段,参数2：是字段内容的类型,参数3 true代表降序排列&#xA;        ## 此时命中率不再计算（因为不按命中率排序）&#xA;        ## 排序的field必须建立索引&#xA;    indexSearcher.search(query, null,10,sort);&#xA;高亮&#xA;    导入包:highlight与memory&#xA;    Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(&amp;quot;&amp;lt;font color=&#39;red&#39;&amp;quot;,&amp;quot;&amp;lt;/font&amp;gt;&amp;quot;),new QueryScorer(query));&#xA;    highlighter.setTextFragmenter(new SimpleFragmenter(10));                # 限制字符长度&#xA;    ..&#xA;    String result = highlighter.getBastFragment(analyzer,&amp;quot;name&amp;quot;,doc.get(&amp;quot;name&amp;quot;));&#xA;        # 返回高亮处理字符串&#xA;        ## 参数1：解析用户输入词的分词器,参数2：是要查询的field的key(没有用)，参数3：field的value&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;solr&#34;&gt;&#xA;  solr&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#solr&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基于lucene&#xA;    搜索服务器，http请求提交和返回xml&#xA;功能&#xA;    丰富了查询语言&#xA;    实现可配置、可扩展&#xA;    优化了性能&#xA;    提供了管理界面&#xA;    缓存功能&#xA;    垂直搜索&#xA;    高亮&#xA;    data schema定义字段&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;elasticsearch&#34;&gt;&#xA;  elasticsearch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elasticsearch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基于lucene&#xA;性能&#xA;    第一次查秒级响应(5-10秒)，放到文件系统缓存(filesystem cache)&#xA;    再查命令缓存毫秒级响应                              # 热点数据要预热&#xA;    文件系统缓存(内存中分配)和数据量同样大，才有效率        # 冷热分离&#xA;&#xA;    分页，会查前面所有数据                              # 用scroll api, 快照 + 游标&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;权限&#34;&gt;&#xA;  权限&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;shiro&#34;&gt;&#xA;  shiro&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shiro&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;功能&#xA;    认证&#xA;    授权&#xA;    加密&#xA;    会话管理&#xA;    Web集成&#xA;    缓存&#xA;组件&#xA;    Subject     # 当前用户,绑定到SecurityManager&#xA;    SecurityManager     # 门面模式，管理组件&#xA;    Realms      # 连接认证数据(用户、角色、权限)&#xA;    Authenticator   # 认证principals和credentials&#xA;    Authorizer  # 校验权限&#xA;    SessionManager      # 异构客户端&#xA;控制方式&#xA;    url&#xA;    注解&#xA;    代码&#xA;    页面标签&#xA;模块&#xA;    Authenticator&#xA;        # SecurityManager继承Authenticator&#xA;        public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  throws AuthenticationException;&#xA;    permission&#xA;        概念&#xA;            subject&#xA;            resource&#xA;            permission&#xA;            role&#xA;                隐式角色&#xA;                显示角色&#xA;        配置&#xA;            shiro.ini&#xA;                [users]&#xA;                zhang=123, role1, role2                # 用户名=密码, 角色1, 角色2&#xA;        判断角色&#xA;            o-&amp;gt;&#xA;                subject.hasRole(&amp;quot;admin&amp;quot;);&#xA;            o-&amp;gt;&#xA;                @RequiresRoles(&amp;quot;admin&amp;quot;)&#xA;                @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)&#xA;                    # 表示当前Subject需要角色admin和user。&#xA;            o-&amp;gt;&#xA;                &amp;lt;shiro:hasRole name=&amp;quot;admin&amp;quot;&amp;gt;&amp;lt;/shiro:hasRole&amp;gt;&#xA;        权限注解&#xA;            @RequiresAuthentication&#xA;                # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。&#xA;            @RequiresUser&#xA;                # 表示当前Subject已经身份验证或者通过记住我登录的。&#xA;            @RequiresGuest&#xA;                # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。&#xA;            @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)&#xA;                # 表示当前Subject需要权限user:a或user:b。&#xA;    credential&#xA;        散列&#xA;            String str = &amp;quot;hello&amp;quot;;&#xA;            String salt = &amp;quot;123&amp;quot;;&#xA;            //内部使用MessageDigest&#xA;            String simpleHash&#xA;        密码生成工具&#xA;            //输入明文密码得到密文密码&#xA;            String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;&#xA;            //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）&#xA;            boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);&#xA;    filter&#xA;        NameableFilter                        ＃根据名字找到相应的拦截器实例&#xA;        OncePerRequestFilter                # 控制开启、关闭拦截器实例&#xA;        ShiroFilter                        # 安全控制&#xA;        AdviceFilter                        # aop&#xA;            preHandle                        # 前置增强&#xA;            postHandle                        # 后置增强&#xA;            afterCompletion                # 后置最终增强(异常也执行，相当于finally的概念)&#xA;        PathMatchingFilter                # 匹配请求路径&#xA;        AccessControlFilter                # 允许或拒绝访问，拒绝时如何处理&#xA;    jsp标签&#xA;        &amp;lt;%@taglib prefix=&amp;quot;shiro&amp;quot; uri=&amp;quot;http://shiro.apache.org/tags&amp;quot; %&amp;gt;&#xA;&#xA;        &amp;lt;shiro:guest&amp;gt;&#xA;        欢迎游客访问，&amp;lt;a href=&amp;quot;${pageContext.request.contextPath}/login.jsp&amp;quot;&amp;gt;登录&amp;lt;/a&amp;gt;&#xA;        &amp;lt;/shiro:guest&amp;gt;&#xA;&#xA;        &amp;lt;shiro:user&amp;gt;&#xA;        欢迎[&amp;lt;shiro:principal/&amp;gt;]登录，&amp;lt;a href=&amp;quot;${pageContext.request.contextPath}/logout&amp;quot;&amp;gt;退出&amp;lt;/a&amp;gt;&#xA;        &amp;lt;/shiro:user&amp;gt;&#xA;            # 用户已经身份验证/记住我登录后显示相应的信息。&#xA;&#xA;        &amp;lt;shiro:authenticated&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]已身份验证通过&#xA;        &amp;lt;/shiro:authenticated&amp;gt;&#xA;            # 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。&#xA;&#xA;        &amp;lt;shiro:notAuthenticated&amp;gt;&#xA;            未身份验证（包括记住我）&#xA;        &amp;lt;/shiro:notAuthenticated&amp;gt;&#xA;            # 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证。&#xA;&#xA;        &amp;lt;shiro: principal/&amp;gt;&#xA;            # 显示用户身份信息，默认调用Subject.getPrincipal()获取&#xA;            &amp;lt;shiro:principal type=&amp;quot;java.lang.String&amp;quot;/&amp;gt;&#xA;            &amp;lt;shiro:principal property=&amp;quot;username&amp;quot;/&amp;gt;&#xA;&#xA;        &amp;lt;shiro:hasRole name=&amp;quot;admin&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]拥有角色admin&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:hasRole&amp;gt;&#xA;&#xA;        &amp;lt;shiro:hasAnyRoles name=&amp;quot;admin,user&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]拥有角色admin或user&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:hasAnyRoles&amp;gt;&#xA;&#xA;        &amp;lt;shiro:lacksRole name=&amp;quot;abc&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]没有角色abc&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:lacksRole&amp;gt;&#xA;                        # 如果当前Subject没有角色将显示body体内容。&#xA;&#xA;        &amp;lt;shiro:hasPermission name=&amp;quot;user:create&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]拥有权限user:create&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:hasPermission&amp;gt;&#xA;&#xA;        &amp;lt;shiro:lacksPermission name=&amp;quot;org:create&amp;quot;&amp;gt;&#xA;            用户[&amp;lt;shiro:principal/&amp;gt;]没有权限org:create&amp;lt;br/&amp;gt;&#xA;        &amp;lt;/shiro:lacksPermission&amp;gt;&#xA;    session&#xA;        得到会话&#xA;            login(&amp;quot;classpath:shiro.ini&amp;quot;, &amp;quot;zhang&amp;quot;, &amp;quot;123&amp;quot;);&#xA;            Subject subject = SecurityUtils.getSubject();&#xA;            Session session = subject.getSession();&#xA;        api&#xA;            Session&#xA;                getId()&#xA;                getHost()                # 调用HostAuthenticationToken.getHost(), 得到主机地址&#xA;                getTimeout()&#xA;                setTimeout(1000)&#xA;                getStartTimestamp()&#xA;                setLastAccessTime()&#xA;                touch()                        # 更新会话最后访问时间&#xA;                stop()                        # 销毁会话, Subject.logout()与HttpSession.invalidate()会自动调用该api&#xA;                setAttribute(&amp;quot;key&amp;quot;, &amp;quot;123&amp;quot;)&#xA;                getAttribute(&amp;quot;key&amp;quot;)&#xA;                removeAttribute(&amp;quot;key&amp;quot;)&#xA;            SecurityManager&#xA;                Session start(SessionContext context)&#xA;                Session getSession(SessionKey key) throws SessionException&#xA;            WebSessionManager&#xA;                boolean isServletContainerSessions();                # 是否使用Servlet容器的会话&#xA;            ValidatingSessionManager&#xA;                void validateSessions();                                # 验证所有会话是否过期&#xA;    cache&#xA;        接口&#xA;            Cach&amp;lt;K, V&amp;gt;&#xA;            CacheManager&#xA;            CacheManagerAware&#xA;        ini配置&#xA;            userRealm.cachingEnabled                        # 启用缓存，默认false&#xA;            userRealm.authenticationCachingEnabled        # 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false&#xA;            userRealm.authenticationCacheName                # 缓存AuthenticationInfo信息的缓存名称&#xA;            userRealm. authorizationCachingEnabled        # 启用授权缓存，即缓存AuthorizationInfo信息，默认false&#xA;            userRealm. authorizationCacheName                # 缓存AuthorizationInfo信息的缓存名称&#xA;            securityManager.realms=$userRealm&#xA;&#xA;            cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager&#xA;            cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml&#xA;            securityManager.cacheManager=$cacheManager&#xA;&#xA;            sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager&#xA;            securityManager.sessionManager=$sessionManager&#xA;    rememberme&#xA;    ssl&#xA;        o-&amp;gt; keytool -genkey -keystore &amp;quot;D:\localhost.keystore&amp;quot; -alias localhost -keyalg RSA&#xA;            # jdk自带的生成证书工具(包含证书/公钥/私钥）&#xA;        o-&amp;gt; 设置tomcat server.xml&#xA;            &amp;lt;Connector port=&amp;quot;8443&amp;quot; protocol=&amp;quot;HTTP/1.1&amp;quot; SSLEnabled=&amp;quot;true&amp;quot;&#xA;            maxThreads=&amp;quot;150&amp;quot; scheme=&amp;quot;https&amp;quot; secure=&amp;quot;true&amp;quot;&#xA;            clientAuth=&amp;quot;false&amp;quot; sslProtocol=&amp;quot;TLS&amp;quot;&#xA;            keystoreFile=&amp;quot;D:\localhost.keystore&amp;quot; keystorePass=&amp;quot;123456&amp;quot;/&amp;gt;&#xA;        o-&amp;gt;&#xA;    jasig cas&#xA;api&#xA;    Subject: 主体, 如用户&#xA;    SecurityManager: 安全管理器, 管理subject&#xA;    Realm: 权限数据域&#xA;&#xA;    授权&#xA;        对象流程&#xA;            Subject.isPermitted -&amp;gt; SecurityManager -&amp;gt; Authorizer&#xA;        对象&#xA;            ModularRealmAuthorizer        # 多realm授权&#xA;            PermissionResolver                # 解析权限字符串到Permission实例&#xA;            RolePermissionResolver                # 从角色得到权限集合&#xA;配置&#xA;    参数&#xA;        filterChainDefinitions&#xA;            rest：比如/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user：method] ,其中method为post，get，delete等。&#xA;&#xA;            port：比如/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal：//serverName：8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。&#xA;&#xA;            perms：比如/admins/user/**=perms[user：add：*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，比如/admins/user/**=perms[&amp;quot;user：add：*,user：modify：*&amp;quot;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。&#xA;&#xA;            roles：比如/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，比如/admins/user/**=roles[&amp;quot;admin,guest&amp;quot;],每个参数通过才算通过，相当于hasAllRoles()方法。&#xA;&#xA;            anon：比如/admins/**=anon 没有参数，表示可以匿名使用。&#xA;&#xA;            authc：比如/admins/user/**=authc表示需要认证才能使用，没有参数&#xA;&#xA;            authcBasic：比如/admins/user/**=authcBasic没有参数表示httpBasic认证&#xA;&#xA;            ssl：比如/admins/user/**=ssl没有参数，表示安全的url请求，协议为https&#xA;&#xA;            user：比如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查&#xA;                    # remember me可登录&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;分布式&#34;&gt;&#xA;  分布式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;redisson&#34;&gt;&#xA;  redisson&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redisson&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    使用redis外部存储，实现分布式功能&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
