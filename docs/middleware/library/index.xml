<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小功能 on outrun的笔记</title>
    <link>https://runout.run/docs/middleware/library/</link>
    <description>Recent content in 小功能 on outrun的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 22 Sep 2021 21:45:53 +0800</lastBuildDate>
    <atom:link href="https://runout.run/docs/middleware/library/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://runout.run/docs/middleware/library/hibernate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/middleware/library/hibernate/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;优点&#xA;    完全面向对象编程思想，无sql&#xA;    减少代码&#xA;    控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率&#xA;    hibernate具有独立性（访问层随时可以更换）&#xA;特性&#xA;    不写hbm.xml映射文件，而是基于注解的验证&#xA;    对象、集合、属性的延迟加载&#xA;        dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常&#xA;目录&#xA;    .                                        # hibernate程序包&#xA;    documentation                # 文档&#xA;    lib                                        # 所有依赖包&#xA;    project                                # 源码文件&#xA;加载顺序&#xA;    后面的覆盖前面的&#xA;    hibernate.properties中的配置被覆盖&#xA;        # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置   hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准）&#xA;开发流程&#xA;    加载配置: jdbc参数，数据库方言，hbm映射&#xA;    创建SessionFactory    # 内有连接池&#xA;    创建session&#xA;    事务处理&#xA;    关闭session&#xA;    关闭连接池&#xA;对象状态&#xA;    𣊬时态     # 没有OID(持久化标识), 没有关联session&#xA;    持久态     # 有OID, 与session关联, 事务未提交&#xA;    脱管态     # 有OID, 没有关联session&#xA;缓存机制&#xA;    一级缓存(session)&#xA;        事务级，事务结束缓存失效    # 请求同一对象，取得同一实例&#xA;        总是打开&#xA;    二级缓存&#xA;        SessionFactory级别，session共享&#xA;        缓存散装持久化实例, 有不同缓存策略&#xA;        先设置策略，再设置过期时间与cache提供器&#xA;    优点&#xA;        提高速度、减小压力&#xA;        缓存失效时，不立即查找，而是合并sql查找&#xA;查询方式&#xA;    HQL&#xA;    QBC(命名查询)&#xA;    SQL&#xA;get与load&#xA;    get立即加载，load延时加载&#xA;    get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库&#xA;        # 代理对象只存id&#xA;    get没有时返回null, load抛异常&#xA;检索策略            # 取关联对象&#xA;    立即检索        # 一次全加载, select多&#xA;    延迟检索        # 访问游离状态代理类，需要在持久化状态时已被初始化&#xA;    迫切左外连接检索 # 用外连接取代select，全加载&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;优化&#34;&gt;&#xA;  优化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据库设计调整&#xA;HQL优化&#xA;api正确使用&#xA;配置参数          # 日志、查询缓存，fetch_size, batch_size等&#xA;映射文件优化      # id生成策略，二级缓存，延迟加载，关联优化&#xA;一级缓存管理, 二级缓存策略&#xA;事务控制策略&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;基本概念&#34;&gt;&#xA;  基本概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题&#xA;o-&amp;gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想)&#xA;    DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准&#xA;    它们的区别在于&#xA;        hibernate中不写sql语句&#xA;        ibatis中写少量sql语句&#xA;        DBUtils中写sql语句&#xA;    它们的另一个相同点是&#xA;         底层全都是jdbc&#xA;o-&amp;gt; 结构对应 javabean中的 类，对象，属性&#xA;         数据库中的            表，记录，字段&#xA;o-&amp;gt; hql        hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用&#xA;o-&amp;gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;1.导入核心包(10 + 1个)&#xA;    hibernate3.jar                                # 核心包&#xA;    c3p0-0.9.1.jar&#xA;    antlr-2.7.6.jar                                # 转换hql到sql&#xA;    commons-collections-3.1.jar        # apache的集合增强包&#xA;    dom4j-1.6.1.jar&#xA;    javassist-3.9.0.GA.jar                # 动态代理&#xA;    jta-1.1.jar                                        # java transaction api        处理事务用&#xA;    slf4j-api-1.5.8.jar&#xA;    log4j.jar&#xA;    slf4j-log4j12.jar                        # 三个日志&#xA;    +&#xA;    mysql-connector-java-5.1.7.bin.jar&#xA;        &#xA;2.建立目录&#xA;    hibernate.dao&#xA;            demo.java&#xA;    hibernate.db&#xA;            xx.sql&#xA;    hibernate.domain&#xA;            xx.java&#xA;    hibernate.util&#xA;            HibernateUtil.java&#xA;3.创建映射文件&#xA;    xx.java文件的同目录下，创建&#xA;            xx.hbm.xml&#xA;4.创建配置文件&#xA;    src/hibernate.cfg.xml        (可变)&#xA;    src/hibernate.properties&#xA;5.写提供hibernate session的工具类&#xA;    HibernateUtil&#xA;6.demo中用hibernate session创建事务进行数据库操作&#xA;    demo.java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;session&#34;&gt;&#xA;  session&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#session&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;查询不需要事务，其它都需要事务&#xA;&#xA;流程&#xA;    Session session = HibernateUtil.getSession();&#xA;    Transaction t = session.getTransaction();&#xA;    t.begin();&#xA;    session.update(hero);&#xA;    session.delete(hero);&#xA;    t.comment();&#xA;    &#xA;批量&#xA;    t.begin();&#xA;    session.save(hero);&#xA;    t.commit();&#xA;    session.clear();&#xA;    &#xA;    查询&#xA;    Query query = session.createQuery(hql);&#xA;    List&amp;lt;Hero&amp;gt; heroList = query.list();&#xA;    &#xA;    查询2&#xA;    Query query = session.createQuery(hql);&#xA;    query.setString(0,name);                // hql中参数从0开始&#xA;    query.setString(1,des);&#xA;    Hero hero = (Hero) query.uniqueResult();        // 只有一个结果时使用&#xA;    &#xA;    修改&#xA;    Query query = session.createQuery(hql);&#xA;    int i = query.executeUpdate();&#xA;&#xA;结尾&#xA;    }catch(Exception e){&#xA;            e.printStackTrace();&#xA;            t.rollback();&#xA;    }finally{&#xA;            HibernateUtil.closeSession(); // session.close();&#xA;    }&#xA;        &#xA;session&#xA;    元素的状态&#xA;        # oid: object id,hibernate 的id值唯一并且与表中的数据一一对应&#xA;        ## hibernate中分辨数据只看oid&#xA;        临时（new），无oid,不在session中.生成sql语句&#xA;            持久化（persistence object）：session.save(hero),有oid,在session中;(saveOrUpdate(hero))&#xA;            游离：session.evict(hero),有oid,不在session中,session.update(hero)重新持久化&#xA;            删除：sesssion.delete(hero),有oid,不在session中,不可恢复,提交后可修改数据库&#xA;                # 隐含将po对象转成持久化状态，并生成delete语句。提交后成delete状态，执行语句&#xA;                ## 临时、持久、游离都可以调用&#xA;                ## 临时调用delete时会删除数据库中相应id的值 ，危险&#xA;    函数&#xA;        get 与 load&#xA;            session.get(hero.class,1),从数据库得到持久状态对象&#xA;                与数据库交互&#xA;                查到时返回po&#xA;                查不到时返回null&#xA;            session.load(hero.class,1)&#xA;                不与数据库交互,返回自己创建的po(只有id)&#xA;            访问非id值的时候，与数据库交互&#xA;        session.clear() # session中的引用变量清空&#xA;        session.close() # clear() + 关闭session对象，回收资源，但session非空&#xA;        session.isOpen()&#xA;        session.flush() # 对session中的更改部分生成相应的sql语句,只在session中，不访问数据库&#xA;        session.update()    # 只是将游离重新持久化,不产生sql语句。（执行更新语句时加上它增加可读性）&#xA;                                                ## update()方法执行时会检验一级缓存（session）中是否有 oid相同的po&#xA;                                                ## ,同时会连接数据库，查询一级缓存中po与数据库中记录的一一对应关系&#xA;        session.commit()    # flush() + 提交事务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hibernatecfgxml&#34;&gt;&#xA;  hibernate.cfg.xml&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hibernatecfgxml&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;必要性&#xA;        必须配置&#xA;&#xA;目录与文件名&#xA;        任意，建议 src/hibernate.cfg.xml&#xA;&#xA;源码中的案例文件：&#xA;        \project\tutorials\web\src\main\resources\hibernate.cfg.xml&#xA;        \project\etc\hibernate.cfg.xml&#xA;约束文件位置&#xA;        hibernate3.jar/org/hibernate/hibernate-configuration-3.0.dtd&#xA;数据库连接属性与方言属性的属性名和值可以查找&#xA;        \project\etc\hibernate.properties                # 由于xml文件中配置要覆盖的是hibernate.properties文件中的属性&#xA;                                                                                        ## 所以属性内容从hibernate.properties文件的属性中查找&#xA;        方言类的位置是：hibernate3.jar/org.hibernate/dialect/中查找到相应的类，&#xA;                这是最终的路径，（oracle的通用方言类的类路径 可以用这种方法找到，hibernate.properties配置文件中没有写）&#xA;        &#xA;加载&#xA;        该配置文件属于纯人为配置，需要在Configuration类的实例中调用addResource(&amp;quot;&amp;quot;)方法加载&#xA;        addResource()方法中的参数是本配置文件相对于src/目录的全限定名&#xA;        &#xA;作用&#xA;        1.映射数据库&#xA;        2.配置 类-表映射 资源xml文件的路径&#xA;        &#xA;内容&#xA;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;&amp;lt;!DOCTYPE hibernate-configuration PUBLIC&#xA;        &amp;quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&amp;quot;&#xA;        &amp;quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&amp;quot;&amp;gt;&#xA;&amp;lt;hibernate-configuration&amp;gt;&#xA;        &amp;lt;session-factory&amp;gt;&#xA;                &amp;lt;!-- 配置访问数据库需要的属性 --&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;connection.driver_class&amp;quot;&amp;gt;oracle.jdbc.driver.OracleDriver&amp;lt;/property&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;connection.url&amp;quot;&amp;gt;jdbc:oracle:thin:@localhost:1521:orcl&amp;lt;/property&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;connection.username&amp;quot;&amp;gt;scott&amp;lt;/property&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;connection.password&amp;quot;&amp;gt;tiger&amp;lt;/property&amp;gt;&#xA;                &amp;lt;!-- 配置方言 通知hibernate访问哪种数据库的语法结构--&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;dialect&amp;quot;&amp;gt;org.hibernate.dialect.OracleDialect&amp;lt;/property&amp;gt;&#xA;                &amp;lt;!-- 类表映射文件 --&amp;gt;&#xA;                &amp;lt;mapping resource=&amp;quot;hibernate/domain/Hero.hbm.xml&amp;quot;/&amp;gt;&#xA;        &amp;lt;/session-factory&amp;gt;&#xA;&amp;lt;/hibernate-configuration&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hibernateproperties&#34;&gt;&#xA;  hibernate.properties&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hibernateproperties&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;必要性&#xA;        不必须配置&#xA;位置：&#xA;        该文件的位置在src/目录下是不可以改变的，是hibernate加载配置的入口 &#xA;&#xA;源码中的参考文件：&#xA;        /project/etc/hibernate.properties&#xA;                # oracle的通用驱动可以从hibernate3.jar/org.hibernate/dialect包中查找&#xA;        &#xA;作用&#xA;        1.配置连接的数据库，更换数据库只需要更改配置文件即可&#xA;        2.配置数据库方言&#xA;        3.其它控制开关&#xA;&#xA;方言的作用&#xA;        更换数据库访问形式，实现通用性&#xA;&#xA;内容&#xA;        hibernate.dialect org.hibernate.dialect.MySQLDialect&#xA;        hibernate.connection.driver_class com.mysql.jdbc.Driver&#xA;        hibernate.connection.url jdbc:mysql:///outrun&#xA;        hibernate.connection.username outrun&#xA;        hibernate.connection.password asdf&#xA;        hibernate.show_sql true                # 开关：显示实际操作数据库的sql语句&#xA;自动创建表&#xA;    hibernate.hbm2ddl.auto=create      # 每次都创建&#xA;    hibernate.hbm2ddl.auto=update      # 没有时再创建(有但是结构不同时会按照酌情增加列字段)&#xA;                                                                            ## 当更新或插入记录不满足条件时会出错&#xA;缓存&#xA;        hibernate.cache.provider_class                # 开启二级缓存中的普通区           &#xA;        hibernate.cache.use_query_cache                # 开启二级缓存中的查询区&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hibernateutil&#34;&gt;&#xA;  HibernateUtil&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hibernateutil&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;目的&#xA;        对SessionFactory返回Session的方式进行了重构，通过调用该静态工具方法&#xA;        实现只有一个SessionFactory实例，由它产生和销毁很多Session的工厂机制。&#xA;&#xA;缓存&#xA;        SessionFactory 是二级缓存&#xA;        Session 是一级缓存&#xA;                # 查询时，先在二级缓存中查找，没有数据时查找一级缓存，最后查询数据库&#xA;                # 缓存中的数据会用镜像联系着数据库，如果数据库有更新，缓存中的数据会自动更新&#xA;&#xA;SessionFactory对象与Session对象&#xA;        SessionFactory:只创建一次，重量级对象，线程安全，可以共享，实例变量，开始时创建 &#xA;        Session:创建多次，轻量级对象，线程不安全，不可以共享，局部变量，临时创建 &#xA;        &#xA;&#xA;实现代码&#xA;/**&#xA;* 提供hibernate session &#xA;* 并且用threadLocal跟踪实现无参删除&#xA;* &#xA;* @author Administrator&#xA;*&#xA;*/&#xA;public final class HibernateUtil {&#xA;        // 单例的SessionFactory工厂 &#xA;        private static SessionFactory sessionFactory;&#xA;        // 单例的ThreadLocal&amp;lt;Session&amp;gt;实例，但是每个调用者都有自己独有的方法？&#xA;        private static ThreadLocal&amp;lt;Session&amp;gt; threadLocal;&#xA;        /**&#xA;        * 解析配置文件（properties,xml）到hibernate 的配置JavaBean,常驻内存&#xA;        * &#xA;        */&#xA;        static{&#xA;                // 在这里加载了hibernate.properties配置文件（这里可以配置数据库），执行其它配置&#xA;                // 相当于jdbc中的DriverManager类（如果配置了数据库，相当于也注册了连接数据库的类文件 【Class.forName(&amp;quot;..Driver&amp;quot;)语句 ..Driver 新建实例的时候自动向DriverManager注册自己】）&#xA;                Configuration config = new Configuration();&#xA;                // 这里写xml配置文件对于src/目录的相对路径,加载映射用xml文件&#xA;                config.addResource(&amp;quot;hibernate.hbm.xml&amp;quot;);&#xA;                // 加载src/目录下的hibernate.cfg.xml配置文件&#xA;                config.configure();                # configure(&amp;quot;classpath:hibernate.cfg.xml&amp;quot;);&#xA;                                                                        1.configure方法中可以加路径&#xA;                                                                        2.classpath:代表src/目录&#xA;                // 导入org.hibernate.SessionFactory类而非org.hibernate.classic.SessionFactory类&#xA;                sessionFactory = config.buildSessionFactory();&#xA;        }&#xA;        /**&#xA;        * 从单例工厂中得到被跟踪定位(每个调用者)的Session对象,没有就创建&#xA;        * &#xA;        * @return&#xA;        */&#xA;        public static Session getSession(){&#xA;                /* 根据不同的调用者返回跟踪的不同的Session对象,如果是第一次调用，就创建新的session，绑定到单例的ThreadLocal对象中记录，返回给调用者&#xA;                * 如果不是第一次调用 ，也能返回让其得到原来为它创建的Session对象 &#xA;                */ &#xA;                Session session = threadLocal.get();&#xA;                if(session == null){&#xA;                        session = sessionFactory.openSession();&#xA;                        threadLocal.set(session);&#xA;                }&#xA;                return session;&#xA;        }&#xA;        /**&#xA;        * 删除调用者在ThreadLocal实例中的跟踪记录，并且关闭该Session实例&#xA;        * &#xA;        */&#xA;        public static void closeSession(){&#xA;                &#xA;                Session session = threadLocal.get();&#xA;                if(session != null){&#xA;                        session.close();&#xA;                        threadLocal.remove();&#xA;                }&#xA;        }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;hql&#34;&gt;&#xA;  hql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;hql特性&#xA;    1.hql是hibernate专用，有专用的技术转换hql到sql,但降低效率&#xA;    2.hql完全面向对象,只出现类，属性，操作符和关键字,例如sum(),order by&#xA;            而sql是面向关系的语言&#xA;使用语句&#xA;        Query query = session.createQuery(hql);&#xA;        Customer c = (Customer)query.uniqueResult();        # 只返回一条结果&#xA;        List&amp;lt;Customer&amp;gt; list = query.list();                        # 返回多条结果&#xA;&#xA;常用 api&#xA;        session.createQuery()&#xA;        session.getNamedQuery()                # 从映射文件中加载&amp;lt;query&amp;gt;标签配置的与&amp;lt;class&amp;gt;标签同级的hql语句&#xA;        query.setString(&amp;quot;&amp;quot;,&amp;quot;&amp;quot;)&#xA;        Object o = query.uniqueResult();&#xA;        List list = query.list();&#xA;        分页&#xA;                query.setFirstResult(0);        # 开始标号&#xA;                setMaxResults(3);              # 最多显示的条数&#xA;        &#xA;query语句                习惯用别名替代类名&#xA;                # from后面出现的是类名，where中比较的是对象属性（已经在映射文件中映射到了表名与字段名）&#xA;        占位符&#xA;                冒号占位符&#xA;                        &amp;quot;from Customer c where c.name = :cname&amp;quot;&#xA;                        query.setString(&amp;quot;cname&amp;quot;,&amp;quot;司马懿&amp;quot;);&#xA;                问号占位符&#xA;                        &amp;quot;from Customer c where c.name = ?&amp;quot;&#xA;                        query.setString(0,&amp;quot;司马懿&amp;quot;);&#xA;        映射文件中分离hql语句&#xA;                        # &amp;lt;query&amp;gt;标签与&amp;lt;class&amp;gt;标签同级&#xA;                &amp;lt;Query name=&amp;quot;findCustomerByAge&amp;quot;&amp;gt;&#xA;        &amp;lt;![CDATA[&#xA;            from Customer c where c.age &amp;lt; ? &#xA;        ]]&amp;gt;&#xA;        Query query = session.getNamedQuery(&amp;quot;findCustomerByAge&amp;quot;);&#xA;        query.setInteger(0,60);&#xA;        查询&#xA;                &amp;quot;from Customer where id = 1&amp;quot;&#xA;            &amp;quot;from Customer as c where c.name = &#39;司马懿&#39; &amp;quot;&#xA;            &amp;quot;from java.lang.Object&amp;quot;    # 映射中没有，写类的全称。查找 src/hibernate.cfg.xml中加载到内存中的映射的类对应的表中的所有记录&#xA;            &amp;quot;from Order o order by o.price desc&amp;quot;&#xA;                投影查询&#xA;                        1.&amp;quot;select c.name,c.age from Customer c &amp;quot;&#xA;                        List&amp;lt;Object[]&amp;gt; list = query.list();        # Object[]中存储的是查询的select 语句中的数值&#xA;                        for(Object [] o : list){&#xA;                System.out.println(o[0]);&#xA;                System.out.println(o[1]);&#xA;            }&#xA;            2.&amp;quot;select count(o), sum(o.price),min(o.price) from Order o&amp;quot;                # count()中的是表类名，统计实例数，查询Order表记录对象的个数 &#xA;            3.&amp;quot;select o.customer.id from Order o&amp;quot;&#xA;用到过的hql&#xA;        级联抓取&#xA;                FROM Role r LEFT JOIN FETCH r.privilegeSet WHERE r.id = :id&#xA;        级联抓取顶级权限表（去重复）&#xA;                SELECT DISTINCT p FROM Privilege p LEFT JOIN FETCH p.childrenSet WHERE p.parent IS NULL&#xA;        级联抓取角色        &#xA;                FROM Account a LEFT JOIN FETCH a.roleSet WHERE a.id = :id&#xA;        三级级联抓取                # 对抓取的集合也可以直接抓取下一层&#xA;                FROM Account a LEFT JOIN FETCH a.roleSet r LEFT JOIN FETCH r.privilegeSet WHERE a.login = :login AND a.pass = :pass&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;编码&#xA;    hibernate用用户操作系统的编码作为自己的编码&#xA;&#xA;    mysql5.5中设置编码：根目录下my文件 default-character-set=gbk&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;查询&#34;&gt;&#xA;  查询&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;hibernate的查询方式&#xA;    1.session.get(字节码,1)&#xA;    2.session.load(字节码,1)&#xA;    3.HQL查询session.createQuery()        session.getNamedQuery()        # 后面是从配置文件中载入hql语句&#xA;    4.对象导航，如多表映射中&#xA;            # 以对象的形式操作数据库中的表，如&#xA;                ## p是person表的一个对象，c是card（身份证表）表的一个对象，p通过配置外键时定义的属性card得到自己的身份证表对象&#xA;                ## 1.从表对象中：Card c = p.getCard();&#xA;                ## 2.从hql语句中：select o.customer.id,o.customer.name,sum(o.price) from Order o group by o.customer.id&#xA;        5.createSQLQuery原生sql语句查询：        # 不要用，用了以后 hibernate跨平台的特性就没有了&#xA;                String sql = &amp;quot;select {a.*} from sysgroup {a} where department regexp ?&amp;quot;;&#xA;                Query query = session.createSQLQuery(sql).addEntity(&amp;quot;a&amp;quot;,SysGroup.class);&#xA;                        # addEntity将表的别名与类字节码关联起来（否则返回的表字段数据是Object类型,jsp页面读取时会出错）&#xA;连接查询的hql语法&#xA;                # 只能连接有外键关系的表类，用表类中的关系类来表示第二张表，不能用笛卡尔积查询&#xA;                ## 也就是说只能查一个表类&#xA;                注意&#xA;                        hql连接查询的语法中用where替代了sql语法中的on&#xA;                        外连接与 sql不同，只能查询与一个表类有关系的外连接表（from语句后面不能写两个表类）&#xA;        内连接&#xA;            from Customer c join c.orderSet o where c.id = o.customer.id&#xA;        外连接                # 这里与 sql不同，只能查询与一个表类有关系的外连接表&#xA;            select c.name,count(o.orderno) from Customer c left join c.orderSet o group by c.name;&#xA;        自连接&#xA;            select a.name, b.name from emp a, emp b where a.mgr=b.id;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;多表映射&#34;&gt;&#xA;  多表映射&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e8%a1%a8%e6%98%a0%e5%b0%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;主控方                # 就是只有主控方的操作成立，非主控方的改变忽略&#xA;        inverse=&amp;quot;true&amp;quot;&#xA;                # false:主表管理，主表插入成功后，再发送n条更新语句来更新外键&#xA;        ## true:从表管理，自己插入时加上：自己javabean中存放的外键关联&#xA;            # 所以购物项中要关联购物车，由于购物车中已经一对多购物项，所以形成了双向关联&#xA;        有该属性的标签&#xA;                &amp;lt;set&amp;gt;&#xA;        缺少主控方出现的问题&#xA;                双向一对多中&#xA;                        1.hibernate生成的sql语句产生重复&#xA;                        2.主键冲突                # 插入操作时，由于“一”表级联插入“多”表，“多”表也要插入自己，它们的主键是相同的，会引起主键冲突&#xA;&#xA;级联                # 数据库只有级联删除&#xA;        cascade=&amp;quot;save-update&amp;quot;  # 插入和更新&#xA;                        # 一般使用save-update，因为表一般软删除，（更新也没有，因为主键不更新，但是hibernate没有单save）&#xA;    cascade=&amp;quot;delete&amp;quot;;  # 删除订单，级联删上层客户&#xA;    cascade=&amp;quot;none&amp;quot;  # 什么都不做（默认）&#xA;    cascade=&amp;quot;all&amp;quot;  # save-update + delete&#xA;        有级联属性的标签&#xA;                class标签下的&#xA;                        &amp;lt;set&amp;gt;&#xA;                        &amp;lt;one-to-one&amp;gt;&#xA;                        &amp;lt;many-to-one&amp;gt;&#xA;        注意&#xA;                级联插入的子表的id内容要为空，否则会变成级联更新                # 这里和单个数据插入时设置对象的id属性不起作用【只有hibernate的主键增长策略起作用】是不同的&#xA;                &#xA;单向一对多                        # 集合映射的一种&#xA;        “一”的类中&#xA;                private Set&amp;lt;Order&amp;gt; orderSet = new LinkedHashSet&amp;lt;Order&amp;gt;();&#xA;        映射xml文件中&#xA;                &amp;lt;!-- set标签用于映射单向一对多 &#xA;                    name表示单方的关联属性&#xA;                    table表示多方对应表的名字&#xA;                    key-column表示多方对应表的外健&#xA;                    one-to-many-class表示单方关联属性中的每个元素的类型&#xA;                --&amp;gt;&#xA;                &amp;lt;set name=&amp;quot;orderSet&amp;quot; table=&amp;quot;ORDERS&amp;quot; cascade=&amp;quot;all&amp;quot;&amp;gt;&#xA;                        &amp;lt;key column=&amp;quot;CUSTOMERS_ID&amp;quot;/&amp;gt;&#xA;                        &amp;lt;one-to-many class=&amp;quot;Order&amp;quot;/&amp;gt;&#xA;                &amp;lt;/set&amp;gt;&#xA;单向多对一                        # 常用&#xA;        映射xml文件中&#xA;                &amp;lt;!--&#xA;                many-to-one映射多方的关联属性&#xA;                name表示多方的关联属性名&#xA;                column表示多方对应表的外健(存储关联类对应表的主键)&#xA;                cascade 级联&#xA;                lazy表示“一”的类数据是否在一开始的时候就查询                # 如果lazy=&amp;quot;proxy&amp;quot;【相当于懒加载】，action类中加载“一”方数据时会出错，因为调用service类结束后线程中的session销毁,延迟加载找不到session会失败&#xA;                fetch表示抓取策略&#xA;                                # 这里产生了hibernate的n+1问题：一条查询语句查出&amp;quot;一&amp;quot;的集合，n条查询语句查出集合中每个元素的一&#xA;                        join代表用join语句查询(一条语句),但是hibernate在多对一的时候不支持fetch=&amp;quot;join&amp;quot;&#xA;                        默认是select，每次查询用一条select语句（多条语句）&#xA;                                解决：自己写新的查询方法查询,执行hql如：FROM Category c LEFT JOIN FETCH c.account&#xA;                --&amp;gt;&#xA;                &amp;lt;many-to-one &#xA;                        name=&amp;quot;customer&amp;quot; &#xA;                        column=&amp;quot;CUSTOMERS_ID&amp;quot; &#xA;                        cascade=&amp;quot;all&amp;quot;&#xA;                /&amp;gt;&#xA;        &#xA;双向一对多  # 双向映射就存在主控方的问题  &#xA;                ##　主表从表（外键【可以为空】）        &#xA;                ## 集合映射的应用&#xA;        1.同时配置单向一对多与单向多对一&#xA;        2.在&amp;quot;一&amp;quot;表中配置inverse=&amp;quot;true&amp;quot;,反转权力，“多”表为主控方&#xA;双向一对一      # 主表从表（从表id既是主键又是外键）&#xA;                ## 双方都是主控方 &#xA;    1.两表都配置&amp;lt;one-to-one/&amp;gt;&#xA;    2.主表配置cascade&#xA;        3.从表中constrained=true属性（主键是否同时为外键约束）&#xA;        &#xA;多对多（单向左到右，单向右到左，双向）                # 集合映射的应用&#xA;                                                                ## 多对多关系中一定要有主控方，否则主键冲突问题&#xA;        1.创建中间表  &#xA;                        # 中间表可以没有自己的JavaBean类文件对应，这时默认有联合主键（联合主键分别是保存的两个外键）&#xA;                students_id&#xA;                teachers_id &#xA;                        # student_id 与 teachers_id为联合主键&#xA;            ## sql语句是primary key(student_id,teacher_id);&#xA;                创建中间表原因：&#xA;                        之所以中间表是因为两边的表中主键唯一，所以不能在一个记录中对对应另一个表的多个记录&#xA;                        中间表相当于把多对多分成两个一对多。&#xA;        2.表对象类中都有对方表的set集合 &#xA;        3.映射xml中      # 可以用inverse,cascade&#xA;                                ##  cascade=&amp;quot;none&amp;quot;时,middle表中的记录也会被删除&#xA;                ## 不配置主控方的话一边更新另一边，另一边也更新自己，会出错&#xA;        &amp;lt;set table=&amp;quot;MIDDLES&amp;quot; name=&amp;quot;teacherSet&amp;quot;&amp;gt;&#xA;            &amp;lt;key columnet=&amp;quot;STUDENTS_ID&amp;quot;/&amp;gt; &#xA;            &amp;lt;many-to-many class=&amp;quot;Teacher&amp;quot; column=&amp;quot;TEACHERS_ID&amp;quot;/&amp;gt;&#xA;        4.dao中&#xA;                在cascade=&amp;quot;all&amp;quot;的配置下实现只删除老师与middle表中的教学关系          # 手工解除关系&#xA;                        # 不手工解除关系的话， 表记录对象：Teacher t1&#xA;                                ，t1删除时,级联删除middle表中数据，middle表中对应了学生的外键&#xA;                                ，由于多对一级联，会删除学生，由于该学生的主键可能会被middle表中的其它记录作为外键引用，所以不能删除，删除时会出错。 &#xA;                &#xA;                查询1号老师对应的学生,并解除关系 &#xA;                        Teacher t1&#xA;                        for(Student s: t1.getStudentSet()){&#xA;                            s.getTeacherSet().remove(t1);&#xA;                        }&#xA;                        1号老师解除关系&#xA;                        t1.setStudentSet(null);&#xA;                        session.delete(t1);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;缓存&#34;&gt;&#xA;  缓存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;缓存        &#xA;        1.一级缓存(session)中的数据是独享的，二级缓存(sessionFactory)中的数据是共享的&#xA;        2.一级缓存中的数据改变时会更新二级缓存(如果二级缓存设置为read-only时，会更新出错)&#xA;        3.二级缓存默认不能存po(持久化对象) ，只存放连接数据库的信息和映射文件 &#xA;                # 这时查询数据时的顺序是 一级缓存 -&amp;gt; 数据库&#xA;                &#xA;启用二级缓存                # 开启的二级缓存中可以保存po&#xA;                                ## 二级缓存的两个空间：普通缓存区(get、load)、查询缓存区(query对象查询)&#xA;        普通缓存区&#xA;        hibernate.properties文件中配置&#xA;            hibernate.cache.provider_class &#xA;                    org.hibernate.cache.HashtableCacheProvider                # 只能内存缓存&#xA;                    org.hibernate.cache.EhCacheProvider                                # 也能磁盘缓存ehcache的jar包中ehcache-failsafe.xml配置文件中可以查到默认缓存配置&#xA;                                                                            # 可以在hibernate的中文官方教程中查到缓存策略提供商的类&#xA;                                                                            ## hibernate3.2之前缓存类jar包是集成的，默认是EhCache&#xA;                                                                            ## hibernate3.2之后缓存类jar包要自己导入&#xA;                                                                            ## ...Provider类并不是实现类，而是桥接类&#xA;            cache.use_second_level_cache&#xA;                    true                                                # 开启二级缓存（默认是true,但是没有配置缓存提供商之前不开启）&#xA;        hibernate.cfg.xml文件中配置使用二级缓存的类              # 可以设置&amp;lt;cache&amp;gt;的标签&amp;lt;class&amp;gt;&amp;lt;set&amp;gt;&#xA;                                                                                        ## 设置&amp;lt;set&amp;gt;时，set对应表类的也要设置&amp;lt;cache&amp;gt;标签&#xA;                &amp;lt;class-cache usage=&amp;quot;read-write&amp;quot; class=&amp;quot;pojo.Goods&amp;quot; /&amp;gt;&#xA;                usage属性&#xA;                        read-only：二级缓存只读(只是不能进行修改，但是从表中读取数据时一级缓存可以向二级缓存中放入数据)&#xA;                        read-write:可读写&#xA;        查询缓存区（hql语句）：默认不开启&#xA;                        # 因为hql命中率低(要求hql语句相同才行，模糊查询每次基本不同),每次查找会到缓存，找不到再到数据库，查询完数据再存入缓存，效率低&#xA;            ## 不配置的话查询还会存到缓存，但只提供get使用，hql自己不用&#xA;                1.首先开启普通缓存区（设置了表类可以缓存）&#xA;                2.在query对象中开启查询缓存区&#xA;                        query.setCacheable(true);&#xA;        查询顺序：一级缓存 -&amp;gt; 二级缓存 -&amp;gt; 数据库&#xA;&#xA;缓存提供商配置&#xA;        ehcache缓存提供商&#xA;                创建src/ehcache.xml配置文件，使用ehcache缓存时会自动加载其中的配置&#xA;                        &amp;lt;diskStore path=&amp;quot;java.io.tmpdir&amp;quot;/&amp;gt;        # 设置缓存目录，java.io.tmpdir指操作系统的临时目录&#xA;                        diskPersistent&#xA;                        diskExpiryThreadIntervalSeconds                # 这两个集群中使用，上面是是否集群持久化，下面是设置持久化时间&#xA;                        maxElementsInMemory                                        # 内存支持最大对象数目(溢出的对象会存到硬盘中)&#xA;                        overflowToDisk                                                # 内在到最大数目时是否缓存到硬盘&#xA;                        eternal                                                                # 缓存是否永久有效，如果为true，则timeToIdleSeconds与timeToLiveSeconds不起作用&#xA;                        timeToLiveSeconds                                        # 内存中缓存最大存活时间，服务器启动的时间加入其中&#xA;                        timeToIdleSeconds                                        # 缓存不被访问时最大存活时间&#xA;                        memoryStoreEvictionPolicy                        # 内存中对象的替换算法FIFO(先进先出first in first out) &#xA;                                                                                                ## LRU(最近最未使用算法,最久没有被访问的对象踢出) &#xA;                                                                                                ## LFU(最少未被使用算法,考虑了对象的访问频率,踢出最近最少被访问的对象)      &#xA;                                                                                                ## 是windows自己的替换算法&#xA;清空缓存&#xA;        一级缓存：session.clear();&#xA;        二级缓存：sessionFactory.close();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;集合映射&#34;&gt;&#xA;  集合映射&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e5%90%88%e6%98%a0%e5%b0%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;作用&#xA;        集合包含于表类中，对应其一个属性，相当于该类对应表的一个子表&#xA;        每种集合对应一张表，内容对应记录。&#xA;        把java类中经常使用的数据结构对应到表中&#xA;&#xA;使用&#xA;        javaBean（User）中&#xA;                private Set&amp;lt;String&amp;gt; telSet = new LinkedHashSet&amp;lt;String&amp;gt;();&#xA;                private List&amp;lt;String&amp;gt; cityList = new ArrayList&amp;lt;String&amp;gt;();&#xA;                private Map&amp;lt;String,String&amp;gt; telCityMap = new LinkedHashMap&amp;lt;String,String&amp;gt;();&#xA;        xml文件中&#xA;                &amp;lt;set name=&amp;quot;telSet&amp;quot; table=&amp;quot;TELS&amp;quot;&amp;gt;&#xA;            &amp;lt;key column=&amp;quot;USERS_ID&amp;quot;/&amp;gt;        # 外键列：集合所创建的表的外键列名&#xA;            &amp;lt;element column=&amp;quot;TEL&amp;quot; type=&amp;quot;string&amp;quot;/&amp;gt;      # 内容列：这里必需要有type &#xA;                    # set中也可以把&amp;lt;element&amp;gt;标签换成&amp;lt;one-to-many class=&amp;quot;Order&amp;quot;/&amp;gt;标签来对应JaveBean作为值，这就是一对多的映射&#xA;        &amp;lt;list name table&amp;gt;&#xA;            &amp;lt;key column/&amp;gt;&#xA;            &amp;lt;list-index column=&amp;quot;IDX&amp;quot;/&amp;gt;      # 索引列：表中的索引号列(对应在list中的索引)&#xA;            &amp;lt;element column type/&amp;gt;&#xA;        &amp;lt;map name table&amp;gt;&#xA;            &amp;lt;key&amp;gt;&#xA;            &amp;lt;map-key type column&amp;gt;                        # map对应key的列&#xA;            &amp;lt;element column type&amp;gt;&#xA;        dao中使用&#xA;                user.getTelSet().add(&amp;quot;131&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;检索策略&#34;&gt;&#xA;  检索策略&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a3%80%e7%b4%a2%e7%ad%96%e7%95%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;hibernate检索的两种类型&#xA;        立刻检索:session.get,query.list        &amp;lt;class lazy=&amp;quot;true&amp;quot;&amp;gt;标签中类的检索策略，get方法与list都不遵循&#xA;        延迟检索:session.load      # 初始时是代理对象,使用时查询  只有load方法遵循&amp;lt;class lazy=&amp;quot;true&amp;quot;&amp;gt;标签中类的检索策略&#xA;            检索方法是load时&#xA;                lazy属性出现在&amp;lt;class&amp;gt;与&amp;lt;set&amp;gt;标签中,两个标签中lazy属性的含义是不同的，两个lazy属性都是对load方法执行时是否查询数据库进行设置。&#xA;                        # &amp;lt;class&amp;gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中除了set集合之外的所有属性&#xA;                        ## &amp;lt;set&amp;gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中set集合的数据&#xA;                        ## &amp;lt;class&amp;gt;中默认lazy属性的值为true&#xA;                        ## &amp;lt;set&amp;gt;中默认lazy属性的值为true&#xA;                true true 时    查类时没有查集合&#xA;                false true 时    查类时没有查集合&#xA;                false false 时    查类时查集合&#xA;                true false 时    查类时没有查集合&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;经验&#34;&gt;&#xA;  经验&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%8f%e9%aa%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;删除的两种方法 &#xA;        session.delete(session.get(Category.class,id));    # 先查询再删除，效率低&#xA;    session.createQuery(&amp;quot;delete Categroy c where c.id=:id&amp;quot;).setInteger(&amp;quot;id&amp;quot;,id).executeUpdate();&#xA;                    # 执行hql语句，效率高&#xA;                    &#xA;hibernate注解&#xA;        hibernate3.6支持注解&#xA;                javaee5不支持，默认关闭&#xA;                javaee6支持，默认开启，此时不加载注解配置文件会报错，所以要关掉&#xA;                        hibernate.cfg.xml中&#xA;                        &amp;lt;property name=&amp;quot;javax.persistence.validation.mode&amp;quot;&amp;gt;none&amp;lt;/property&amp;gt;&#xA;                        &#xA;DB Browser反射编译表的生成映射文件和类的时候，会生成项目目录下hibernate.reveng.xml的临时配置文件，可以删掉&#xA;&#xA;映射文件class属性&#xA;        dynamic-update=&amp;quot;true&amp;quot;                # 动态更新，只有对相同的session有效，而且性能不好&#xA;                                                                ## 用字段设置中的update=&amp;quot;false&amp;quot;（对象中有字段值时更新，没有时不更新）属性来设置动态更新&#xA;映射文件set标签属性&#xA;        Order-by=&amp;quot;id&amp;quot;                                # set中级联对象按照&amp;quot;id&amp;quot;属性进行排序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;c3p0&#34;&gt;&#xA;  c3p0&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#c3p0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;c3p0并不是hibernate默认的连接池（默认的是hibernate自带的连接池算法）&#xA;        配置c3p0以后自动关闭Hibernate自带的连接池，而使用c3p0连接池&#xA;&#xA;&#xA;hibernate.cfg.xml文件中&#xA;        &amp;lt;!-- 最大连接数 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.max_size&amp;quot;&amp;gt;20&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 最小连接数 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.min_size&amp;quot;&amp;gt;5&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.timeout&amp;quot;&amp;gt;120&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 最大的PreparedStatement的数量 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.max_statements&amp;quot;&amp;gt;100&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.idle_test_period&amp;quot;&amp;gt;120&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.acquire_increment&amp;quot;&amp;gt;2&amp;lt;/property&amp;gt; &#xA;        &amp;lt;!-- 每次都验证连接是否可用 --&amp;gt; &#xA;        &amp;lt;property name=&amp;quot;hibernate.c3p0.validate&amp;quot;&amp;gt;true&amp;lt;/property&amp;gt; &#xA;hibernate.properties文件中&#xA;        hibernate.c3p0.min_size=5 &#xA;        hibernate.c3p0.max_size=20 &#xA;        hibernate.c3p0.timeout=1800 &#xA;        hibernate.c3p0.max_statements=50 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;映射&#34;&gt;&#xA;  映射&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%a0%e5%b0%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;hbm.xml&#xA;    位置与名称：&#xA;            domain.xx.java 文件同级目录 xx.hbm.xml&#xA;&#xA;    约束文件位置&#xA;            hibernate3.jar/org/hibernate/hibernate-mapping-3.0.dtd&#xA;            从其中复制约束头&#xA;            &#xA;    源码中的案例文件&#xA;            \project\tutorials\中搜索 hbm.xml&#xA;&#xA;    类-表映射的特点&#xA;            1.映射JavaBean到表字段（动态占位符），可以使用面向对象的hql语名生成sql语句&#xA;            2.session中保存类对象，缓存查询过的表的内容&#xA;            3.在映射关系的xml文件中可以设置主键的改变方式（这样以后dao类中设置的主键内容被配置文件中的设置覆盖）&#xA;            &#xA;    主键&#xA;            表中的主键&#xA;                    自然主键：有业务逻辑含义的字段（如name）（多个自然主键：联合主键）&#xA;                    代理主键&#xA;            hibernate中id的增加类型&#xA;                    increment  整型,不依赖数据库自增,多线程不安全&#xA;                uuid        缺点：占空间&#xA;                identity    整型，依赖数据库自增,线程安全&#xA;                sequence    专用于oracle数据库,要用特定名字的序列，create sequence hibernate_sequence;线程安全&#xA;                native(重点)    根据情况判断是identity或sequence&#xA;                assigned    自然主键：&amp;lt;id name=&amp;quot;name&amp;quot; column=&amp;quot;name&amp;quot;&amp;gt;,线程不安全&#xA;                composite-id    多个自然主键,表的javaBean必须实现序列化(1.对象序列化到硬盘、数据库【其它JavaBean有id属性，hibernate自动实现序列化】2.线程间传递数据)&#xA;                    &amp;lt;composite-id&amp;gt;&amp;lt;key-property name=&amp;quot;firstname&amp;quot; column=&amp;quot;firstname&amp;quot;/&amp;gt;&amp;lt;key-property name=&amp;quot;firstname&amp;quot; column=&amp;quot;lastname&amp;quot;/&amp;gt;&#xA;&#xA;    持久化对象的两种类型&#xA;            实体型：具有id属性的类，映射成一条含有id主键的完整记录&#xA;            值类型或组件：与上面相反(被实体型包含)，如&#xA;                            # 包含以后会把组件的属性添加到实体类属性的后面，一起当作一张表，仅此而已&#xA;            # Address   &#xA;                province&#xA;                city&#xA;                area&#xA;            映射组件型属性&#xA;            1.类中引用组件：private Address address&#xA;            2.映射 &amp;lt;component name=&amp;quot;address&amp;quot; class=&amp;quot;Address&amp;quot;&amp;gt;&amp;lt;property name column/&amp;gt;&#xA;            3.dao中    star.setAdrress(address);&#xA;    内容&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;!DOCTYPE hibernate-mapping PUBLIC &#xA;        &amp;quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&amp;quot;&#xA;        &amp;quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&amp;quot;&amp;gt;        &#xA;    &amp;lt;hibernate-mapping package=&amp;quot;hibernate.domain&amp;quot;&amp;gt;&#xA;            &amp;lt;class name=&amp;quot;Hero&amp;quot; table=&amp;quot;heros&amp;quot; dynamic-insert=&amp;quot;true&amp;quot;&amp;gt;&#xA;                                    # 设置动态插入为true:如果是null的值，不再插入&#xA;                                    ## 如果不设定动态插入，会插入数据库null值，数据库中设定的默认值不会起作用&#xA;                    &amp;lt;!-- hibernate通过自己内部的类型type=&amp;quot;&amp;quot;,来转换java类型与sql类型之间的转换，一般不必写，自动反射 --&amp;gt;&#xA;                    &amp;lt;!-- id 是指主键，property是属性 --&amp;gt;&#xA;                    &amp;lt;id name=&amp;quot;id&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;&#xA;                            &amp;lt;!-- hibernate内部的主键生成器 --&amp;gt;&#xA;                            &amp;lt;generator class=&amp;quot;increment&amp;quot;/&amp;gt;&#xA;                    &amp;lt;/id&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;name&amp;quot; column=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;gender&amp;quot; column=&amp;quot;gender&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;age&amp;quot; column=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;birthday&amp;quot; column=&amp;quot;birthday&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                    &amp;lt;property name=&amp;quot;des&amp;quot; column=&amp;quot;des&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;            &amp;lt;/class&amp;gt;&#xA;    &amp;lt;/hibernate-mapping&amp;gt;&#xA;javaBean&#xA;    实现序列化接口&#xA;            在有名为id属性的JavaBean中，hibernate会自动实现序列化接口&#xA;            没有名为id属性的JavaBean中，需要我们自己实现序列化接口&#xA;&#xA;    public class Hero implements java.io.Serializable{&#xA;                private Integer id;&#xA;                private String name;&#xA;                private String gender;&#xA;                private Integer age;&#xA;                private Date birthday;&#xA;                private String des;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
