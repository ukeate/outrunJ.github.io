<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  名词
  #

dom                文档对象模型
dao                数据访问对象
ucs                unicode character set
utf                ucs Transformation Format
bmp                Basic Multilingual plane
bom                Byte Order Mark
asp                Active Server Pages
iis                Internet Information services
validate code                 验证码
tld                 tag library description
jsp                 java server page
xsd                XML Schemas Definition
suffix              后缀
ide                Integrated Development Environment
RIA                Rich internet Applications                富互联网应用（富客户端）C/S架构是胖客户端，B/S架构是瘦客户端。比如 flash就是ria(其它如js, SilverLight，unity3d，flash3d,adobe air,HTML5/css3，adobe Flex等)
JPA                Java Persistence API                        java持久层api
JDBC                Java DataBase Connectivity
DHTML                DynamicHTML
cvs                Concurrent Version System
svn                subversion
uml                UnifiedModelingLanguage
AJAX            Asynchronous JavaScript and XML
bnf                命令书写格式规范: 巴科斯范式
desc            description
capacity        容量
component       组件
association         联合
aggregation         聚合
composition         组合
alpha           开端
inherit         继承
dhtml           dynamic html ,是 html css 客户端script                        不是规范，是现有技术、标准的整合运用
css             Cascading Style Sheet   级联样式表
associated                交互的
perspective                视图
adapter         适配器
jit             just in time (compilation)
webdav          Web-based Distributed Authoring and Versioning        Web 分布式创作和版本管理 (WebDAV) 扩展了 HTTP/1.1 协议，允许客户端发布、锁定和管理 Web 上的资源
CMS             Content Management System        内容管理系统        它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。
constraint      约束
JSON            javascript object notation(标记)
OGNL            Object-Graph Navigation Language 对象图导航语言
jmf               java media frame java 媒体框架 是一个jar 包
dwr                Direct Web Remoting 是一个ajax框架。它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数，就像它就在浏览器里一样。
CXF                 apache的 Celtix &#43; XFire,用于实现 web services的发布的使用
oa                Office Automation 办公自动化
dml                data manipulation language        数据操作语言
ddl                data definition language        数据定义语言
dcl                data control language                数据控制语言
ioc                inversion of control        控制反转（spring）
di                 dependence injection        依赖注入 （spring）
crud               增加(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete)
ssh                Secure Shell,由IETF制定，为建立在应用层和传输层基础上的安全协议。
pojo                pure old java object
oop                object oriented programming
aop                aspect oriented programming                面向切面编程
hdfs                Hierarchical Data Format        层次型资料格式（分布式存储）
ftp                File Transfer Protocol
ssl                Secure Sockets Layer 安全套接层。端口40
tls                Transport Layer Security 传输层安全(ssl的继任者)
https            Hypertext Transfer Protocol Secure 应用ssl作为应用层子层对数据进行压缩与解压。端口443
jsf                JavaServer Faces 是sun开发的web框架，相当于ssh(spring &#43; struts &#43; hibernate)
sns                Social Network Services        社会性网络服务
uml                Unified modeling language 统一建模语言
jta                java transaction api (hibernate中) java事务处理api
asm                Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。
                    汇编语言(Assembly Language)的扩展名
jsr                Java Specification Requests 是Java规范请求，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。jsr303:基于注解的java bean 验证
dto                data transfer object 数据传输对象
antlr             another tool for language recognition        一个开源的语法分析器
soap              simple object access protocol 简单对象访问协议
uefi              unified extensible firmware interface 统一可扩展固件接口
sso                single sign on 单点登录
erp                enterprise resource plan 企业资源计划
sap                Systems Applications and Products in Data Procession 企业系列软件(全世界排名第一的erp软件)
ssi                Server Side Include 服务器端嵌入
jmx                Java Management Extensions java管理扩展，是一个为应用程序、设备、系统等植入管理功能的框架。
jaas                Java Authentication Authorization Service Java验证和授权API
jca(J2C， J2CA)        Java Connector Architecture java连接器架构
jms                    Java Message Service java消息服务，用于在两个应用程序之间，或分布式系统中发送消息
jaf                    JavaBeans Activation Framework JAF是一个专用的数据处理框架，它用于封装数据，并为应用程序提供访问和操作数据的接口。JAF的主要作用在于让java应用程序知道如何对一个数据源进行查看、编辑和打印等操作。
jta                    Java Transaction API Java事务API,和jts为J2EE平台提供了分布式事务服务
jts                    Java Transaction Service java事务服务
scm                    Supply chain management 一种集成的管理思想和方法，执行供应商到最终用户的物流计划控制职能
ctr                    click-through-rate 网络广告
ioc/di                    inversion of control/ dependency injection
o2o                    online to offline 网站提供平台, 用户线下交易
cas                    central authentication service 单点登录
foobar                FTP Operation Over Big Address Records(RFC1545文档)ftp命令列表
modular              模块化
enumeration         计数
navigate            导航
fragment             碎片
posix                可移植的
intersection        截断
categories          类别
encounter           遭遇
recursion           递归
evaluate            评价
indent                缩进
collation         校对
schema              模式、图表
generate            生成
Presentation         描述
hierarchical         垂直分层
stereotype         策略
numerous            许多
KISS                keep it simple, stupid
cross-origin         跨域
CORS             Cross-Origin Resourse Sharing
NIH             not invented here 自己造轮子
mis                 management information system
crm                 customer relationship management
erp             enterprise resource planning
webRTC          web Real-Time Communication


  库
  #


  日志
  #

log4j
    # java
logback
    # log4j后续版本
slf4j
    # java
log4js
    # js


  格式|模板
  #

moment
    # js格式化时间
iconv
    # nodejs调用c&#43;&#43; libiconv库来转码
iconv-lite
    # nodejs实现的转码，比调用c&#43;&#43; 的iconv更高效
poi
    # java 文件处理
jFreeChart
    # java图表库
jackson
    # java json序列化
json-smart
    # java json
xstream
    # java xml序列化
pango2
    # 国际化模板
snakeyaml
    # java yaml
js-beautify
    # js, html格式化
xmlbeans
    # java xml
joda-time
    # java日期
dom4j
    # java dom 


  生成|压缩|加密|计算特征
  #

simhash
    # google 文档hash
pygments
    # python 生成高亮html
mako
    # python 模板
jinja2
    # python 模板
freemarker
    # java 模板
proguard
    # java 混淆
snappy
    # google java 压缩
jbcrypt
    # java加密, scrypt更强


  客户端|邮件
  #

javamail
    # java mail
nodemailer
    # node mail
mailapi
    # java mail
c3p0
    # java rds 连接池
dbcp
    # java rds 连接池
druid
    # java rds 连接池。可监控sql执行性能，记sql日志
jdbc
    # java rds client
dbutil
hibernate
ef
    # .net orm
NHibernate
    # .net orm
peewee
    # python orm
node-mysql
mongoose
httpClient
    # java http
request
    # js http
superagent
    # js http
mybatis
hsqldb
    # java内置, 单文件/内存数据库
mqttv
    # java mqtt客户端
libthrift
    # java thrift
kafka-clients


  领域语言
  #

lex
    # 生成词法分析程序
yacc
    # 生成自底向上语法分析程序
antlr


  图形
  #

ccap
    # 基于c&#43;&#43;的图形CImg库，就是一个CImg.h文件
canvas
    # node canvas
tesseract
    # node 验证码


  运维控制
  #

later
    # nodejs corntab
glob
    # nodejs 匹配获得文件
rd
    # node 遍历文件
commander
    # node制作命令
mkdirp
    # node 递归makedir
fs-extra
    # node扩展fs包
testcontainers
    # java, 运行docker
jOptSimple
    # java, 命令解析


  协议
  #

spring-websocket
    # java
httpcore-nio
    # java
grpc-context
    # java


  高可用 | 性能
  #

retry
    # js retry
ehcache
    # 缓存
tagg
    # node线程池
cluster
    # node单机集群
fiber
    # node协程
driud
    # 连接池，阿里开源


  akka
  #

# scala并发、分布式、容错工具
使用
    system = ActorSystem.create(&quot;hello&quot;)
    system.actorOf() ## 前端 ### dwr
介绍
    java函数通过ajax映射到前端js调用
使用
    ajax框架
    1.导入jar包 dwr.jar
    2.web-inf/下的配置文件
        web.xml文件
            &lt;servlet&gt;
                &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt;
                &lt;servlet-class&gt;org.directwebremoting.servlet.DwrServlet&lt;/servlet-class&gt;
                        # 固定写法
                &lt;init-param&gt;
                        &lt;param-name&gt;debug&lt;/param-name&gt;
                        &lt;param-value&gt;true&lt;/param-value&gt;
                &lt;/init-param&gt;
                &lt;init-param&gt;
                        &lt;param-name&gt;scriptCompressed&lt;/param-name&gt;        # 允许在javascript中执行
                        &lt;param-value&gt;false&lt;/param-value&gt;
                &lt;/init-param&gt;
                &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;        # web工程启动时加载
            &lt;/servlet&gt;
            &lt;servlet-mapping&gt;
                &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt;
                &lt;url-pattern&gt;/dwr/*&lt;/url-pattern&gt;
            &lt;/servlet-mapping&gt;
        dwr.xml文件
            &lt;dwr&gt;
                &lt;allow&gt;
                    &lt;create creator=&quot;new&quot; javascript=&quot;DWRUserAccess&quot;&gt;        # 生成js文件的名（页面中引用）
                            &lt;param name=&quot;class&quot; value=&quot;outrun.dwr.DWRUserAccess&quot; /&gt;                # 曝露的类
                    &lt;/create&gt;
                    &lt;convert converter=&quot;bean&quot; match=&quot;outrun.dwr.User&quot; /&gt;        # 注册实体类，可以在js中进行实例化
                &lt;/allow&gt;
            &lt;/dwr&gt;
    3.写outrun.dwr.DWRUserAccess中的方法
    4.页面调用
        test.html
            &lt;script src=&quot;/outrun/dwr/engine.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;/outrun/dwr/util.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;/outrun/dwr/interface/DWRUserAccess.js&quot;&gt;&lt;/script&gt;
            &lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;
                DWRUserAccess.方法(参数,执行完运行的js函数)
                    # 参数可以是一个map,如
                        var userMap = {};
                        userMap.id = regForm.id.value;
                        userMap.password = regForm.password.value;
                        userMap.name = regForm.name.value;
                        userMap.email = regForm.email.value;
                        DWRUserAccess.save(userMap, saveFun);
                                # 其中的regForm是页面中的表单（的name属性,dom支持直接使用名字引用表单）
            &lt;/SCRIPT&gt;


  开发
  #


  脚手架
  #


  spring boot
  #


  drapWizard
  #

# java，类spring boot


  写法
  #

traits-decorator
    # js mixin
q
    # js 流程控制
co
    # js generator to async
async
    # js 流程控制
thunkify
    # js函数Thunk化, 确保回调调用一次
step
    # async轻量库
wind
    # js定义的宏
streamline
    # 基于源代码编译来实现流程控制简化
eventproxy
    # js event回调
spring
    # java ioc
guice
# google的java ioc轻量框架
castle
    # .net ioc
spring.net
    # .net ioc
anko
    # go 代码解释器
antlr
    # java dsl
aopalliance
    # java aop


  ejb
  #

特点
    分布式，j2ee一部分

组成
    会话bean(session)
    实体bean(entity)
    消息驱动bean(message driven)


  语言增强
  #


  guava
  #

# google工具集
maven
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
        &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;/dependency&gt;
组件
    o-&gt; 增强
    Optional                            # null处理
    Preconditions                       # 准入检查
    Ordering
    Throwables

    o-&gt; 集合
    Multiset                            # 存重复元素
    Multimap                            # 多值
    BiMap                               # 双向映射
    Table                               # 两键一值
    Range                               # 连续值
    
    o-&gt; 字符串
    Joiner
    Spilter
    CharMatcher
    CaseFormat

    o-&gt; 类型
    Objects
    Bytes
    Shorts
    Ints
    Longs
    Floats
    Doubles
    Chars
    Booleans

    o-&gt; 数学
    IntMath
    LongMath
    BigIntegerMath

    o-&gt; 高可用
    LoadingCache                        # 堆内缓存


  接口
  #

luavit
    # lua实现, 类node
scotty
    # haskell
webapi
    # .net
meteor.js
    # 基于node.js &#43; mongodb的网站开发平台，把这个基础构架延伸到浏览器端, 本地和远程数据通过DDP(Distributed Data Protocol)协议传输
restify
    # 基于nodejs的rest应用框架，去掉express中的 template, render等功能, 提供DTrace功能，方便调试
ssh
    # java
spring site
    # spring整合
tapestry
    # 基于servlet的mvc框架
jersey
    # java restful服务
naga
    # java nio
echo
    # go
beego
    # go
gorilla
    # go
gin
    # go，类express
iris
    # go, fasthttp的一种实现
tornado
    # python nio
web.py
twisted
    # event driven
flask
django
bottle
    # python wsgi
rails
    # ruby的web mvc开发框架
ror
    # ror(ruby on rails)
sinatra
    # 微型web
grape
    # 运行在rack或rails/sinatra配合使用的restful风格的ruby微框架
yii
    # php
laravel
    # php
codelgniter
    # php


  RESTful
  #


  connect
  #

介绍
    nodejs处理http中req、res的中间件框架
    中间件分类
        pre-request用来改写request原始数据
        request/response功能各异
        post-response全局异常处理，改写response数据等
内置中间件介绍
    logger
    csrf
    compress             # gzip压缩
    basicAuth            # basic认证
    body parser          # 请求内容解析
    json
    urlencoded           # application/x-www-form-urlencode请求解析
    multipart            # multipart/form-data请求解析
    timeout
    cookieParser
    session
    cookieSession
    methodOverride       # http伪造
    responseTime         # 计算响应时间
    staticCache          # 缓存
    directory            # 目录列表
    vhost                # 虚拟二级域名映射
    favicon
    limit                # 请求内容大小限制
    query                # url解析
    errorHandler         # 错误处理
使用
    var connect = require(&#39;connect&#39;);
    var app = connect()
        .use(connect.logger(&#39;dev&#39;))
        .use(function(req, res){
            res.end(&#39;hello world\n&#39;);
        })
        .listen(3000);


  express
  #

安装
    npm install -g express-generator
    npm install express -d                        # g代表安装到NODE_PATH的lib里面, d代表关联套件一起安装
cookie-parser
    使用
        var cookieParser = require(&#39;cookie-parser&#39;);
        app.use(cookieParser());

        JSON.stringify(req.cookies);
        req.cookies.yourCookie
cookie-session
    使用
        var cookieSession = require(&#39;cookie-session&#39;);
        app.use(cookieSession())
        req.session = null

express-session
    options可选参数
        name                        # 表示cookie中保存session的字段名称，默认为connect.sid
        store                        # session的存储方式，默认存放在内存中，也有redis、mongodb、等模块支持
        secret                        # 设置secrect来计算hash放在cookie中产生signedCookie，来防篡改
        genid                        # 规定产生一个新的session_id时所用的函数，默认用uid2这个包
        rolling                        # 每个请求都重新设置一个cookie，默认为false
        resave                        # 即使session没有被修改，也保存session的值
    使用
        var session = require(&#39;express-session&#39;);
        app.use(session(options));

connect-redis
    使用
        var express = require(&#39;express&#39;);
        var session = require(&#39;express-session&#39;);
        var redisStore = require(&#39;connect-redis&#39;)(session);

        app.use(session({
            store: new redisStore(),
            secret: &#39;somesecrettoken&#39;
        }));
serve-static
    # 静态文件
passport
    介绍
        登录验证中间件
        支持connect express sails等web框架
        支持Basic, Digest, OAuth(1.0和2.0的三种实现), Bearer等
    安装
        npm i passport
        npm i passport-local
    o-&gt; 配置
    var express = require(&#39;express&#39;);
    var cookieParser = require(&#39;cookie-parser&#39;);
    var session = require(&#39;express-session&#39;);
    var flash = require(&#39;express-flash&#39;);
    var passport = require(&#39;passport&#39;);

    ...

    app.use(cookieParser());
    app.use(session({...}));
    app.use(passport.initialize());
    app.use(passport.session());
    app.use(flash())

    passport.serializeUser(function (user, done) {
            done(null, user.id)
    })
    passport.deserializeUser(function (id, done) {
            User.findById(id, function (err, user) {
                    done(err, user)
            })
    })

    app.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;, {
            # passport.authenticate是个登录中间件，通过就走后面回调，否则返回401
            # local是自定义的名称
            successRedirect: &#39;/&#39;,
            failureRedirect: &#39;/login&#39;,
            failureFlash: true,
    }, function (req, res) {
            res.redirect(&#39;/users/&#39; &#43; req.user.username)
    }))

    app.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;, function(err, user, info) {
            if (err) return next(err)
            if (!user) {
                    req.flash(&#39;errors&#39;, {msg: info.message})
                    return res.redirect(&#39;/login&#39;)
            }
            req.logIn(user, function (err) {})
    })(req, res, next))
    app.get(&#39;/logout&#39;, function(req, res) {
            req.logout()
            res.redirect(&#39;/&#39;)
    })
    app.get(&#39;/user&#39;, isAuthenticated, getUser)
    var isAuthenticated = function (req, res, next) {
            if (req.isAuthenticated()) {
                    return next()
            }
            res.redirect(&#39;/login&#39;)
    }


    o-&gt; local验证
    var LocalStrategy = require(&#39;passport-local&#39;).Strategy
    passport.use(new LocalStrategy(
            function(username, password, done) {
                    User.findOne({username: username}, function(err, user) {
                            if (err) {return done (err)}
                            if (!user) {return done(null, false, {message: &#39;no user&#39;})}
                            if (!user.validPassword(password)) {...}
                            return done(null, user)
                    })
            }
    ))

    o-&gt; usernameField
    passport.use(new LocalStrategy({
            usernameField: &#39;email&#39;,
            passwordField: &#39;passwd&#39;
    }, function (username, password, done) {...}
    ))

    o-&gt; OAuth
    介绍
        第三方登录协议
        三个步骤
            1. 获取未授权的request token
            2. 获取用户授权的request token
            3. 用授权的request token换取access token
    使用
        网页上申请开发github应用
        npm install passport-github
            # 安装passport的github扩展
        // app.js
        passport.use(new GithubStrategy({        // 增加github认证策略
            clientID: &#39;XXXX&#39;,
            clientSecret: &#39;YYYY&#39;,        // 已从github上申请
            callbackURL: &#39;http://localhost:3000/auth/github/callback&#39;
        }, function(accessToken, refreshToken, profile, done){
            done(null, profile);
        }));
        // 定义路由
        app.all(&#39;/github&#39;, isLoggedIn);
        app.get(&#39;/github&#39;, user.github);
        app.get(&#39;/auth/github&#39;, passport.authenticate(&#39;github&#39;, {scope: &#39;email&#39;}));
        app.get(&#39;/auth/github/callback&#39;, passport.authenticate(&#39;github&#39;, {
            successRedirect: &#39;/github&#39;,
            failureRedirect: &#39;/&#39;
        }));
kraken
    介绍
        基于express之上的基于设置结构化代码工具
    功能
        post请求_csrf验证

    基本用法
        &#39;use strict&#39;
        var express = require(&#39;express&#39;),
            kraken = require(&#39;kraken-js&#39;);
        var app = express();
        app.use(kraken());
        app.listen(8000);


  koa
  #

介绍
    express原班人马打造的，更小，更健壮，更有表现力的web框架
    免除重复繁琐的回调函数嵌套，提高错误处理效率
    不绑定任何中间件，只是提供一个轻量优雅的函数库
    &gt;=node0.11.16
配置
    app.name              # 应用名称
    app.env                  # 执行环境，默认是NODE_ENV 或 &#39;development&#39;
    app.proxy              # 决定哪些proxy header被加到信任列表中
    app.subdomainOffset      # 被忽略的.subdomains列表
    app.jsonSpaces          # 输出json时是否填充空格
    app.outputErrors        # 是否输出错误堆栈(err.stack)到stderr(app.env是&#39;test&#39;时，此值为false)

使用
    $ npm install koa
    $ node --harmony app.js                        # 必需使用harmony模式运行程序
    var koa = require(&#39;koa&#39;);
    var app = koa();
    app.use(function *(){
        this.body = &#39;Hello World&#39;;
    });        # function*  声明的generator function支持yield
               ## yield是ES6定义的新语法
    app.listen(3000);
使用(downstream &amp; upstream)
    var koa = require(&#39;koa&#39;);
    var app = koa();

    // x-response-time
    app.use(function *(next){
    // (1) 进入路由
    var start = new Date;
    yield next;
    // (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间
    var ms = new Date - start;
    this.set(&#39;X-Response-Time&#39;, ms &#43; &#39;ms&#39;);
    // (6) 返回 this.body
    });

    // logger
    app.use(function *(next){
    // (2) 进入 logger 中间件
    var start = new Date;
    yield next;
    // (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间
    var ms = new Date - start;
    console.log(&#39;%s %s - %s&#39;, this.method, this.url, ms);
    });

    // response
    app.use(function *(){
    // (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream
    this.body = &#39;Hello World&#39;;
    });

    app.listen(3000);

    this
        request
            header
            headers
            url
            accepts
        response
            header
            headers
            status
        cookies
            set(&#39;name&#39;, &#39;tobi&#39;, {signed: true})
                signed
                expires
                path
                domain
                secure
                httpOnly
            get
        type
        length
        path
        method
        state
        throw
        assert
    app
        use
        listen
        callback
        keys
        context
            db
中间件
    koa-router
    trie-router
    route
    basic-auth
    etag
    compose
    static
    static-cache
    session
    compress
    csrf
    logger
    mount
    send
    error


  实时
  #

sockjs
        # node websock
postal
        # nodejs 在内存上构建的发布订阅框架
pusher
        # 发布订阅模式socketio框架
juggernaut
        # 基于socketio
datachannel.io
        # 基于socket.io和html5 webRTC的实时聊天室框架
faye-websocket-node
        # 扩展faye项目开发的websocket的一个实现, 非常简单，而且不依赖其他库
websocket-node
        # 一个简单的websocket库，支持draft-10及之前的各种版本, 支持同样是node的c/s交互模式
ejabberd
        # 基于erlang/OTP 的xmpp im 开源框架
singalR
        # .net sock服务
nsq
        # go
openfire
        # java, 性能较差, 最多单机10w并发
webrtc
        # c&#43;&#43;实现的web视频聊天


  socket.io
  #

# 介绍
    socket.io: 基于任何浏览器, mobile设备的&quot;webSocket&quot;
# 安装
        npm install socket.io
# 使用
        var socketIo = require(&#39;socket.io&#39;);
        socketIo.listen(app).on(&#39;connection&#39;, function (socket) {                # require(&#39;socket.io&#39;)(app);
                                                                        ## var io = require(&#39;socket.io&#39;)(80);
        socket.emit(&#39;news&#39;, { hello: &#39;world&#39; });
        socket.on(&#39;my other event&#39;, function (data) {
                console.log(data);
        });
        });
# api
    server
            io.on(&#39;connection&#39;, function(socket){});
            io.on(&#39;disconnect&#39;, function(){});
            socket.on(&#39;message&#39;, function(msg){});
    client-js
            socket = io.connect(url);
            socket.on(&#39;&#39;, function(json){});
            socket.send(json);
    io
            on(&#39;connection&#39;, function(socket){});
                    # disconnect
    socket
            on(&#39;disconnect&#39;, function(){ });
            socket.on(&#39;say to someone&#39;, function(id, msg){
                    socket.broadcast.to(id).emit(&#39;my message&#39;, msg);
            });
                    # Socket#id为内部指定的
    遍历用户
            var roster = io.sockets.clients(&#39;chatroom&#39;);
            roster.forEach(function(client){
                    console.log(&#39;Username: &#39; &#43; client.nickname);
            });                        // 1.0之前版本可用
# 方案
    namespace
            server
                    var nsp = io.of(&#39;/my-namespace&#39;);
                    Onsp.emit(&#39;hi&#39;, &#39;everyone!&#39;);                # ns广播
            client
                    var socket = io(&#39;/my-namespace&#39;);
    room
            server
                    socket.join(&#39;some room&#39;);
                    io.to(&#39;some room&#39;).emit(&#39;some event&#39;):        # room广播
                    socket.leave(&#39;some room&#39;);
# 子模块
    socket.io-redis
        介绍
                用于从外部发消息，与socket.io-emitter一起使用
        使用
                var io = require(&#39;socket.io&#39;)(3000);
                var redis = require(&#39;socket.io-redis&#39;);
                io.adapter(redis({ host: &#39;localhost&#39;, port: 6379 }));
    socket.io-emitter
        介绍
                用于从外部发消息，与socket.io-redis一起使用
        使用
                var io = require(&#39;socket.io-emitter&#39;)();
                io.emit(&#39;time&#39;, new Date);
    socket.io-client
        介绍
                用于创建客户端来连接socket.io
        使用
                var iocl = require(&#39;socket.io-client&#39;);
                var socket = iocl.connect(&#39;127.0.0.1:5555&#39;);
                socket.on(&#39;connect&#39;, function(){

                });


  展示
  #

titles
    # java apache的标签库


  spring mvc
  #


  struts2
  #

# 基础
    介绍
        struts1和WebWork的发展
        引入值栈的概念     # 一次请求的参数和处理数据放在一个map结构中
    原理
        基于拦截器, 解耦servlet, 再提供自己的拦截器(interceptor)操作数据, 反射调用业务类
        FilterDispatcher通过配置文件来映射设置请求地址与处理类
            ActionMapper判断请求是否struts处理
            ActionProxy扩展实现方式(如web service)
            ConfigurationManager对应struts.xml配置文件
            ActionInvocation执行Action与拦截器
            Action处理请求，封装数据
                # Action是非单例的，效率低
    过滤器与拦截器
        过滤器基于回调，拦截器基于反射
        过滤器依赖servlet, 拦截器在struts中处理action

# 思想
    Action类中的无侵入设计（新技术中不出现旧技术）：map代替了作用域
        ActionContext actionContext = actionContext.getContext()
        actionContext.getApplication()
        actionContext.getSession()

        好处
            map是java中的api，不出现旧技术
            测试方便（ servlet不能测试，只能发布测试）
                # 注意：Action类中用到作用域map的方法也不能测试


# 结构
    apps: 例子程序
    docs:帮助文件
    lib:程序包
    src:源码
# 使用
    要求
        jdk5
        jsp2
        servlet api2.4

    导入核心的8个包
        struts2-core-2.3.1.1.jar        # struts的过滤器
        xwork-core-2.3.1.1.jar                # 验证工具
        freemarker-2.3.18.jar                # 标签
        javassist-3.11.0.GA.jar                # 动态代理
        commons-fileupload-1.2.2.jar
        commons-io-2.0.1.jar                # 文件处理
        commons-lang-2.5.jar                # 基础包
        ognl-3.0.3.jar                                # 表达式语言
    web.xml文件中配置过滤器
        &lt;filter&gt;
            &lt;filter-name&gt;struts&lt;/filter-name&gt;
            &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
        &lt;/filter&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;struts&lt;/filter-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;/filter-mapping&gt;
    写jsp页面，get或post路径为struts2的名称空间、扩展名，被配置的struts2过滤器处理
    写Action类（继承ActionSupport类）
    配置src/struts.xml文件与src/struts.properties文件，映射类、方法等到请求路径，映射返回字符串到任何方式


# 核心包：8个
    struts2-core-2.3.1.1.jar        # struts的过滤器
    xwork-core-2.3.1.1.jar                # 验证工具
    freemarker-2.3.18.jar                # 标签
    javassist-3.11.0.GA.jar                # 动态代理
    commons-fileupload-1.2.2.jar
    commons-io-2.0.1.jar                # 文件处理
    commons-lang-2.5.jar                # 基础包
    ognl-3.0.3.jar                                # 表达式语言

# 配置
    struts2以包的形式管理action 包名必须唯一，包里的每个action唯一
    使用步骤
        导入lib包
        写jsp
        编写Action方法
        web.xml中配置
            &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter
            &lt;url-pattern&gt;/*
        ../xx_struts.xml中配置请求响应
        src/struts.xml 中引入配置文件
            &lt;include file=&quot;cn/itcast/javaee/cal/cal_struts.xml&quot;/&gt;

    配置文件（配置包）路径
        重要路径：4个
            1./struts-default.xml[框架]
                # 是框架自带的abstract包（包括上传，下载，验证等），继承它以后可以用其中的功能
            2./org/apache/struts2/default.properties[框架]
            3.src/struts.xml # 必有
            4.src/struts.properties # 可选
        验证返回消息的配置文件
            struts2-core-2.3.1.1.jar包中的
                /org/apache/struts2/struts-messages.properties文件

    xml 中配置的简化
        *
            o-&gt; 只能在name 中写*_* 等
            o-&gt; 引用第一个* 用{1}        引用第二个用{2} 以此类推


    类路径
        com.opensymphony.xwork2.ActionSupport  默认关联到的类

    处理请求的扩展名配置
        # 扩展名配置只有一个会生效
        1./org/apache/struts2/default.properties
                struts.action.extension=action,,
                # 框架中初始的默认扩展名，最后的&#39;,&#39;代表了无扩展名
        2.src/struts.xml中
                &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do,,&quot;&gt;
                        # 必需配置
        3.src/struts.properties中
                        struts.action.extension=xx,yy
                        # 选择配置，优先级高

    默认配置
        struts2内置了请求字符串与基本类型的相互转换，不用手工转换

        /org/apache/struts2/default.properties文件中
                struts.i18n.encoding=UTF-8        # post方式请求响应的编码方式
                                                                        ## get方式的没有默认值，需要自己转码
                struts.action.extension=action,,  # 框架中初始的默认扩展名,最后的&#39;,&#39;代表了无扩展名

        每个&lt;package&gt;标签中配置
        &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; 为默认的拦截器

    src/struts.xml配置文件

    src/struts.properties配置文件

# 原理流程
    请求/qq.action -&gt; StrutsPreparedAndExecuteFilter（核心过滤器）-&gt; 匹配扩展名 -&gt; 匹配命名空间
        #（ 全限定名：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.class）
            -&gt; src/struts.xml                -&gt; name
                class
                method
            -&gt; name
                type
                内容
            -&gt; 响应
            -&gt; 拦截器 -&gt; ConfigAction类

        # 1.部署时读取src/struts.xml和src/struts.properties文件，形成JavaBean对象
                # 两个文件同时存在时src/struts.properties文件为准
        ## 2.请求/*路径时，StrutsPreparedAndExecuteFilter过滤
        ## 3.获取JavaBean中的actionName ,actionClass, actionMethod, 执行方法
        ## 4.执行的返回值与resultName, resultType, resultContent进行比较
        ## 5.按resultType类型返回resultContent（路径和内容）

# 缺点
    8个jar包，慢，servlet 快
    配置繁琐
# 编码
    struts2默认编码方式:utf-8

    返回的图片相对路径中有中文时设置tomcat
        tomcat/conf/server.xml
            &lt;Connector port=&quot;8080&quot; .. URIEncoding=&quot;utf-8&quot;/&gt;

        这时点击下载的请求路径中有中文时在以post方式提交 ,struts自动转码。若以get方式提交，需要在Action类的相应的get方法中转换url编码（iso8859-1）到u8

        原理
                改了tomcat的内部编码以后，struts中的编码是u8，放在session 中，jsp支持u8,解释后发送的html中的编码没问题，查看没问题。
                下载post发送请求，浏览器请求的是url编码的u8,struts中也是u8执行下载

                如果不改编码，struts 中是u8,如果以List方式放入session的话,session存储的是u8
                如果直接放入数据的话,session中存储的是8859-1,jsp取出数据需要转码为u8并设置自己的编码是u8,再发送给浏览器。
                浏览器这时获取图片正常,post方式提交的是u8,经过tomcat转换为8859-1,struts中自动转换编码到u8
                如果是以get方式提交请求，get中的中文在浏览器时进行url编码到8859-1,经过tomcat，再到struts,struts不对get方式的请自动进行转码
                向action类中注入参数时是8859-1编码,需要手动在action类中的属性的get方法中进行8859-1到u8的转码操作
# 内置对象
    struts中的6个内置对象
        # request请求进入struts中时创建，request请求结束时销毁。
        requestMap
        sessionMap
        applicationMap
        parameters
        attr                        # page -&gt; request -&gt; session -&gt; application 的顺序查找
        valueStack                # 定义实例变量，直接放入valueStack的 list（栈） 中,map（值）很少向内存储数据
            # 定义的实例变量必须提供相应的get方法,否则ognl标签中取其数据时没有方法调用，就得不到它的值
            # list 中的值优先访问 ，但是map 中的值起决定作用
            # map中存放着一个大map,其中注入了所有页面的请求信息
                # requestMap sessionMap applicationMap 并不是真正的域对象，但最后通过拦截器放入到域对象中

# 异常处理
    配置src/strut.xml 文件
        &lt;global-results&gt; 全局结果（用来跳转全局异常等）
        &lt;global-exception-mappings&gt; 全局异常
        &lt;exception-mapping result=&quot;nullJsp&quot;        exception=&quot;java.lang.NullPointerException&quot; /&gt;
            # &lt;action&gt;标签中的局部异常
            ## &lt;action&gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&quot;nullJsp&quot;的字符串交给本&lt;action&gt;标签中相应的&lt;result&gt;标签来处理


    处理机制
        o-&gt; 多个异常时走子异常，父异常被忽略
        o-&gt; 先处理小范围异常，大范围忽略
        o-&gt;  如果异常没有处理，抛出到web服务器处理,web.xml的&lt;error-page&gt;&lt;error-code&gt;&lt;location&gt;
    全局异常
        xml文件中
            &lt;global-results&gt;
                &lt;result name=&quot;error&quot;&gt;
                    /error.jsp
                &lt;/result&gt;
            &lt;/global-results&gt;
            &lt;global-exception-mappings&gt;
                &lt;exception-mapping result=&quot;error&quot; exception=&quot;java.lang.Exception&quot;/&gt;
            &lt;/global-exception-mappings&gt;
        error.jsp页面中
            &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;
            异常信息：&lt;s:property value=&quot;exception.message&quot;/&gt;&lt;br/&gt;
            详细信息：&lt;s:property value=&quot;exceptionStack&quot;/&gt;&lt;br/&gt;


# 转递方式
    chain                        # action类之间转发
    dispatcher                # 转发到jsp
    freemarker
    httpheader
    redirect                # 重定向到页面
    redirectAction        # action 类之间重定向
    stream                        # 返回 InputStream流
    velocity
    xslt
    plainText
# Action类
    注意
        1.所有Action类都要继承ActionSupport类，否则execute方法返回的字符串不会回到struts拦截器再根据xml文件的配置进行转发
        2.action类是非单例的。        # 所有多实例的对象全部是因为有私有属性，否则全部应该是单例的
        3.action类放在栈的顶端，用于注入数据

    传统方式得到request,response,servletContext,pageContext
        ServletActionContext.getPageContext()
        HttpServletRequest request = ServletActionContext.getRequest()
        ServletActionContext.getResponse()
        ServletActionContext.getServletContext();

    优势
        实现与servlet的解耦

    验证
        验证分类
                前台验证：javascript等
                后台验证：服务器
        struts2验证
                    后台验证
            1.代码式验证
            2.声明式验证:xml文件

    ActionContext类
        调用方法
        ActionContext actionContext = ActionContext.getContext();
        得到内置对象        # 这几种得到作用域的方法均可以得到作用域中原有的值，也可以放入值
        request
                actionContext.put(&quot;&quot;,&quot;&quot;);
        application
                Map&lt;String,Object&gt; applicationMap = actionContext.getApplication();
        session
                Map&lt;String,Object&gt; sessionMap = actionContext.getSession();
                        # 或 actionContext.get(&quot;session&quot;)得到，因为actionContext中存储着大map
        parameters
                Map&lt;String,Object&gt; parametersMap = actionContext.getParameters();
        valueStack
                ValueStack valueStack = actionContext.getValueStack()
                valueStack.getRoot()                        # 得到当前值栈的顺序

    参数
        1.action类中可以直接创建属性与其get方法得到客户端get方法或post表单请求的参数(由struts2自动注入)
        2.action类中可以创建 JavaBean的属性来接收struts注入的参数，这时用户请求的参数名字要写成JavaBean名.JavaBean中的属性名（这样struts2会自动调用JavaBean的set方法来注入其中相应的参数 ）
## BaseAction
    作用
        权限管理
        存放常驻内存数据
        抽取常用的方法
# web.xml配置
    &lt;filter&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;filter-class&gt; org.apache.struts2.dispatcher.FilterDispatcher &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;struts.action.extension&lt;/param-name&gt;
            &lt;param-value&gt;do&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;url-pattern&gt;*.json&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
        # 设置全局过滤器，并且修改过滤扩展名
# default.properties
    src/struts.properties配置文件
        struts.custom.i18n.resources=struts    # 使自己的普通配置生效。如：/org/apache/struts2/struts-messages.properties文件的
            ## struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} &quot;{1}&quot; &quot;{2}&quot; {3}  属性，&quot;{1}&quot; &quot;{2}&quot; &quot;{3}&quot;是显示消息的占位符
            ## struts.action.extension=action,,可以不配置
            # 由于只加载properties文件，所以省略.properties
            ## =后面的是相对于src目录的文件
# ognl标签
    注意
        # jquery中不能定位ognl标签，而要用标签自己生成的id定位（看源码得到）
    使用：
        &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt;
        tld映射文件路径
            struts2-core-2.3.1.1.jar包中
            /META-INF/struts-tags.tld

    &#39;#&#39;出现的地方
        o-&gt; 除ValueStack 之外的所有struts内置对象的取值前面都要加
        o-&gt; 取JavaBean中的属性时要加 &#39;#&#39;，如&quot;#user.username&quot;,ValueStack中也不例外
        o-&gt; 构造Map对象，Map：#{&#39;male&#39;:&#39;[男]&#39;,&#39;female&#39;:&#39;[女]&#39;}，构造radio和select标签，如
                        # &lt;s:radio list=&quot;#{&#39;male&#39;:&#39;aa&#39;,&#39;bb&#39;:&#39;cc&#39;}&quot; name=&quot;gender2&quot; /&gt;
        o-&gt; 迭代数组或list集合
            集合的投影：userList.{username}
            集合的过滤：userList.{?#this.age&gt;22}

    主题与模板
        主题：为多个模板提供风格
            struts2-core-2.3.1.1.jar包中
                template中的四个主题
                    archive                # 其中是.vm文件，其它是.ftl文件。vm与ftl是两种视图技术
                        ajax        # 除此之外其它都不支持ajax
                        simple
                        xhtml
                    xhtml                # 默认主题,default.properties配置文件中定义
                    css_xhtml
                    simple
            修改主题
                1.struts.properties 中修改
                    struts.ui.theme=simple          # 针对当前webapp
                2.&lt;s:form theme=&quot;xhtml&quot;&gt;            # 只针对当前表单
                3.&lt;s:textfield name=&quot;username&quot; theme=&quot;simple&quot;&gt;  # 修改某个标签的属性
        模板：为标签提供样式
                做模板的技术freemarker

    ognl标签的优点：自动排版、验证数据回显、国际化

    所有标签：
        逻辑标签
            对 Map 集合的迭代：
                &lt;s:iterator value=&quot;#session.fileMap&quot; var=&quot;entry&quot; status=&quot;stat&quot;&gt;
                    &lt;s:property value=&quot;#entry.key&quot;/&gt;
                &lt;s:if test=&quot;#stat.count%4==0&quot;&gt;&lt;/s:if&gt;
                &lt;/s:iterator&gt;
            对 List 集合的迭代  List&lt;User&gt; userList
                普通迭代
                    &lt;s:iterator var=&quot;user&quot; value=&quot;userList&quot;&gt;      # 投影语法List&lt;user&gt;中的所有username
                    &lt;s:property value=&quot;#user.username&quot;/&gt;
                        投影语法
                    &lt;s:iterator var=&quot;username&quot; value=&quot;userList.{username}&quot;&gt;
                    &lt;s:property/&gt;                        # 这里不用写属性value=&quot;username&quot;就可以对page域中的username进行显示
                过滤语法
                    &lt;s:iterator var=&quot;user&quot; value=&quot;userList.{?#this.age&gt;9}&quot;&gt;
                        # this代表当前被迭代的元素 ?#是所有 ^#是第一个 $#是最后一个  ?#...[0]按标记取
                    &lt;s:property value=&quot;#user.username&quot; /&gt;
        显示标签（UI标签）
            普通字符串中使用ognl
                jsp中用%{}      xml中用${}
                例如
                jsp中：&lt;s:textfield label=&quot;%{#attr.testValueStack}&quot;/&gt;
                xml中：&lt;param name=&quot;min&quot;&gt;4000&lt;/param&gt;
                                            &lt;message&gt;${min}&lt;/message&gt;
            普通信息
                &lt;s:text name=&quot;&quot;/&gt;
            输出值
                迭代器中
                        &lt;s:property/&gt;        # 直接输出被迭代的内容（简单）
                        &lt;s:property value=&quot;aa&quot;/&gt;
                        &lt;s:property value=&quot;#aa&quot;/&gt;
                普通
                        &lt;s:property value=&quot;username&quot;/&gt;      # 输出标签,得到valueStack中属性
                        &lt;s:property value=&quot;#request.name&quot;/&gt;                # 得到request域对象中的值
                                # request #session #application #parameters #attr
                                # &#39;#attr&#39;优先级：page,request,valueStack,session,application
            显示验证拦截器的验证信息集合中的数据：
                &lt;s:fielderror/&gt;                                                        # 显示所有错误信息
                &lt;s:fielderror fieldName=&quot;&quot;/&gt;                        # 显示验证返回的错误信息
            单选
                &lt;s:radio list=&quot;#{&#39;male&#39;:&#39;男&#39;,&#39;female&#39;:&#39;女&#39;}&quot; name=&quot;gender2&quot; value=&#39;男&#39;&gt;
                                # 自动加class id &lt;label for=&quot;gender2male&quot;&gt;等
                                # list键值对中male是实际值,男是显示值
                                # name是&lt;input radio &gt;的name属性
                                # value中是选中的项
            多选
                &lt;s:select multiple=&quot;true&quot; list=&quot;#{&#39;bj&#39;:&#39;北京&#39;,&#39;sh&#39;:&#39;上海&#39;,&#39;gz&#39;:&#39;广州&#39;}&quot; name=&quot;select1&quot; value=&quot;{&#39;sh&#39;,&#39;bj&#39;}&quot;/&gt;
            表单                        # 在ognl的标签中， struts的验证消息自动回显，不用加&lt;s:fielderror/&gt;标签
                &lt;s:form action=&quot;&quot;&gt;                # 默认中加上了 method=&quot;post&quot; action中加上了当前网站了contextPath路径
                        &lt;s:textfield label=&quot;用户名&quot; name=&quot;username&quot; /&gt;
                        &lt;s:password label=&quot;密码&quot; name=&quot;password&quot; /&gt;
                        &lt;s:submit value=&quot;登录&quot; /&gt;
            国际化                # 国际化一般放在整个网站的最后写
                                ##　伪国际化：将不同语言的页面放在不同文件夹中分别访问
                        # 国际化是通过i18n拦截器实现的
                1.创建国际化信息文件
                        message_zh_CH.properties      # 基名_语言名_国家名.properties
                                username=xxx
                                password=xxxx
                                submit=xx
                        message_en_US.properties
                        ..
                        message.properties                # 默认的显示语言
                                # 找伊拉克没有的话找本地区语言，本地语言没有的话找其它(默认的或美国等)
                2.struts.properties中引入国际化配置的属性文件
                        struts.custom,i18n.resources=struts2/tag/i18n/message        # 从src文件夹路径开始，只写基名
                3.验证消息国际化
                        message.properties文件中配置属性validationRequiredUsername=用户名错误
                        validation.xml文件中
                        &lt;message key=&quot;validationRequiredUsername&quot;&gt;&lt;/message&gt;
                4.jsp文件中用key属性代替 label属性(或其它在页面上显示信息的属性),key中写国际化信息文件中的key
                        &lt;s:form action=&quot;taglogin&quot;&gt;
                                &lt;s:textfield key=&quot;username&quot; name=&quot;username&quot; /&gt;
                                &lt;s:password key=&quot;password&quot; name=&quot;password&quot; /&gt;
                                &lt;s:submit key=&quot;submit&quot;/&gt;
                        &lt;/s:form&gt;
                5.普通信息的国际化
                        message.properties中配置属性 normalMessage:普通信息
                        jsp中&lt;s:text name=&quot;normalMessage&quot;/&gt;
                6.测试
                        intername选项 -- 语言 改地区访问

    xml文件中的ognl标签
            o-&gt; ${aa}
                    1.调用转到该标签类的getAa()方法得到aa的值替换${aa}
                    2.本标签中name=&quot;aa&quot;的标签的文本节点的内容
            o-&gt; {1}{2}{3}..{n}
                    匹配本标签中name=&quot;*a*&quot; 中的第n个‘*’,用于通配传递过来的参数的一部分的值
# ognl表达式
    ognl 开源，java写的免费标签,是struts2特有的

    xml文件中
        ${Xxx}                取值栈中栈中的东西，如action类中的属性
        ${#Xxx}                取值栈中值的东西，如request,session域中的数据（其实就是老师说的内置对象【valueStack就是值栈】）

    jsp文件中
        &lt;s:iterator value=&quot;#session.fileMap&quot; var=&quot;entry&quot; status=&quot;stat&quot;&gt;
            &lt;s:property value=&quot;#entry.key&quot;/&gt;
            &lt;s:if test=&quot;#stat.count%4==0&quot;&gt;&lt;/s:if&gt;
        &lt;/s:iterator&gt;
# strut.xml配置
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE struts PUBLIC
            &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
            &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;

    &lt;struts&gt;
        &lt;constant name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constant&gt;
        &lt;include file=&quot;&quot;&gt;&lt;/include&gt;
        &lt;package name=&quot;&quot;&gt;
                &lt;interceptors&gt;
                        &lt;interceptor name=&quot;&quot; class=&quot;&quot;&gt;&lt;/interceptor&gt;
                        &lt;interceptor-stack name=&quot;&quot;&gt;
                                &lt;interceptor-ref name=&quot;&quot;&gt;&lt;/interceptor-ref&gt;
                        &lt;/interceptor-stack&gt;
                &lt;/interceptors&gt;
                &lt;default-interceptor-ref name=&quot;&quot;&gt;&lt;/default-interceptor-ref&gt;
                &lt;global-results&gt;
                        &lt;result name=&quot;&quot;&gt;&lt;/result&gt;
                &lt;/global-results&gt;
                &lt;global-exception-mappings&gt;
                        &lt;exception-mapping result=&quot;&quot; exception=&quot;&quot;/&gt;
                &lt;/global-exception-mappings&gt;
                &lt;action name=&quot;&quot;&gt;
                        &lt;param name=&quot;&quot;&gt;&lt;/param&gt;
                        &lt;result&gt;&lt;/result&gt;
                        &lt;result name=&quot;input&quot;&gt;&lt;/result&gt;
                        &lt;exception-mapping result=&quot;&quot; exception=&quot;&quot;/&gt;
                        &lt;interceptor-ref name=&quot;&quot;&gt;&lt;/interceptor-ref&gt;
                &lt;/action&gt;
        &lt;/package&gt;
    &lt;/struts&gt;

    设置
        &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;/&gt;                # 开启debug模式
                                                                # debug模式，不用重启调试(添加新的方法要重启，方法中改代码不用重启)
        &lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;utf-8&quot;/&gt;
                                                                # 配置struts的编码
        &lt;constant name=&quot;struts.configuration.xml.reload&quot; value=&quot;true&quot;/&gt;
                                                                # 配置本属性，可以使得改动struts配置文件不用重启应用服务器
        &lt;constant name=&quot;struts.multipart.saveDir&quot; value=&quot;/upload&quot;/&gt;
                                                                # 配置上传存储路径
        &lt;constant name=&quot;struts.action.extension&quot; value=&quot;action,do&quot; /&gt;
                                                                    # 配置过滤路径
    详细解释
        o-&gt; 存放路径src/
        o-&gt; 可以在struts-2.3.15.1的src\apps\blank\src\main\resources\struts.xml中参考配置文件
        o-&gt; &lt;include file=&quot;struts2/cal/cal_struts.xml&quot;/&gt;标签包含其它路径的xml配置文件
                        #　被include的文件不能再include其它文件
        o-&gt; &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do,,&quot;&gt;
                默认值
                        default.properties中配置了默扩展名：struts.action.extension=action,,
                # 配置匹配到框架处理的扩展名，空逗号代表匹配没有扩展名
        o-&gt; &lt;package name=&quot;xxPackage&quot; extends=&quot;struts-default&quot; namespace=&quot;/xx/&quot;&gt;
                默认值
                        namespace=&quot;/&quot;
                        extends=&quot;struts-default&quot;        # 不可省略
                # name是包的唯一标识，不可以写路径
                ## namespace 访问路径如/xx/a.do会匹配到该包执行其中的映射，按照域命名空间链的方式匹配，如：
                                                        /xx/yy/a.do也会匹配到该包，但是它优先匹配到/xx/yy的命名空间
                                                        /a.do 不会匹配到该包
                        注意：匹配/sys/*的名称空间是/sys 而非 /sys/
                ## struts的包有抽象包，普通包两种，通过继承可以加入包内容，相当于复制、粘贴
                ## 继承的包是struts-default，其路径是/struts-default.xml
                ## ，它定义了核心的bean和拦截器
        o-&gt; &lt;interceptors&gt;
                        &lt;interceptor name=&quot;&quot; class=&quot;&quot;/&gt;
                        &lt;interceptor-stack name=&quot;&quot;&gt;
                                &lt;interceptor-ref name=&quot;/&quot;&gt;
                                # 定义拦截器、定义拦截器栈（加入拦截器）
                                ## 拦截器栈中可以加栈
        o-&gt; &lt;default-interceptor-ref name=&quot;&quot;&gt; 默认拦截器（可以用于验证用户登录）
        o-&gt; &lt;global-results&gt; 全局结果（用来跳转全局异常等）
        o-&gt; &lt;global-exception-mappings&gt; 全局异常
        o-&gt; &lt;action name=&quot;&quot; class=&quot;&quot; method=&quot;&quot;&gt;
                默认值
                        class=&quot;com.opensymphony.xwork2.ActionSupport&quot;
                        method=&quot;execute&quot;
                # name=&quot;aa&quot;时 .../aa.do的请求匹配到该方法执行
                ## class 是类字节码路径，method是其中的方法名
        o-&gt; &lt;param name=&quot;aaa&quot;&gt;bbb&lt;/param&gt;
                调用 &lt;action&gt;标签中对象的实例的方法：setAaa(&quot;bbb&quot;);
        o-&gt; &lt;result name=&quot;&quot; type=&quot;&quot;&gt;/ok.jsp
                默认值
                        name=&quot;success&quot;
                        type=&quot;dispatcher&quot;
                # name=&quot;success&quot;时，映射的method返回&quot;success&quot;时进入该result处理
                ## type是返回方式 ，如dispatcher redirect等
                        type的返回类型
                                dispatcher : 转发到jsp页面
                                redirect : 重定向到 jsp html 等页面
                                chain : Action 类之间的转发
                                redirectAction : Action 类之间的重定向
                                stream : 以 inputStream 的数据类型返回
                                        stream的参数                        # 可以从struts-default.xml文件中对应的stream参数对应的类的源码中查看其中的set方法找到要写参数的名称
                                                &lt;param name=&quot;contentType&quot;&gt;image/pjpeg&lt;/param&gt;                # 下载文件的类型                  另外如text/html; charset=utf-8返回给ajax异步数据
                                                &lt;param name=&quot;bufferSize&quot;&gt;2048&lt;/param&gt;                # 缓冲byte[]的大小，单位字节
                                                &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${uuidFileName}&lt;/param&gt;                # 设置下载响应头，只的下载时才设置。${uuidFileName}是一个OGNL表达式
                                                &lt;param name=&quot;inputName&quot;&gt;imageStream&lt;/param&gt;        # 框架调用传递给result标签结果字符串的对象中的getImageStream()方法，来获取InputStream流对象
                                                # 返回stream类型不指定返回的路径
                ## 标签间的内容：/ok.jsp 是响应的路径
        o-&gt; &lt;result name=&quot;input&quot; type=&quot;&quot;&gt;/ok.jsp
                type中的参数                        # 可以从struts-default.xml配置文件中查到
                        dispatcher        # 转发
                        redirect        # 重定向
                        chain                # Action类之间转发，需要加参数，参数的名字
                                                ## ：struts-default.xml文件中找到&quot;chain&quot;对应的类，按快捷键ctrl &#43; shift &#43; T 关联类的源码文件，查找set方法改名即可
                                &lt;param name=&quot;actionName&quot;&gt;to&lt;/param&gt;
                                        # action标签的 name属性值
                                &lt;param name=&quot;namespace&quot;&gt;/&lt;/param&gt;
                                        # action的名称空间
                        redirectAction                # Action类之间重定向

                # 各种拦截器不通过时默认的返回input，同时向request作用域中加入了相关错误信息供struts2的jsp标签进行显示
                ## 处理 返回值是input的返回信息跳转，就是处理拦截器拦截后的信息跳转
        o-&gt; &lt;exception-mapping result=&quot;nullJsp&quot;        exception=&quot;java.lang.NullPointerException&quot; /&gt;
                # &lt;action&gt;标签中的局部异常
                ## &lt;action&gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&quot;nullJsp&quot;的字符串交给本&lt;action&gt;标签中相应的&lt;result&gt;标签来处理
        o-&gt; &lt;interceptor-ref name=&quot;loginInterceptor&quot;/&gt;
                默认值
                        name=&quot;defaultStack&quot;
                # 指定在本&lt;action&gt;标签中使用的拦截器或拦截器栈
                ## 当指定了拦截器或拦截器栈以后，默认的defaultStack将会没有,此时defaultStack中的18个拦截器将不再执行

    使用：OGNL对象图导航语言对标签中的路径进行动态设置

# 验证
    struts2验证
        1.代码式: validate(),validateXxx()方法
                        # 单个验证与全部验证都存在时先单个验证，再全部验证，验证信息都加入验证信息集合
        2.声明式: Action类名-validation.xml
                                Action类名-&lt;action标签的name属性&gt;-validation.xml
                            # 单个验证与全部验证都存在时先全部验证，再单个验证，验证信息都加入验证信息集合
                    # 先声明验证，后代码验证
    参数驱动
        1.属性驱动: action中用属性收集表单参数
        2.模型驱动: javaBean收集参数

    代码式（属性驱动）：
        步骤
        1.需要验证的Action类  继承 ActionSupport 类
                        # ActionSupport 类 实现了Validateable接口，该接口是验证接口

        2.写验证方法
                1&gt; public void validate()
                                # 方法重写（通用验证方法，本类中的所有其它方法执行前都执行）

                2&gt; public void validateXxxMethod()
                                # 或者自定义专用验证方法 xxxMethod为要验证的方法名，首字母要大写

                        # 注意，通用、专用验证方法同时存在时，先执行专用验证方法，再执行通用验证方法
                        ## ，但是通用验证方法的错误消息无法加入到返回的错误集合中

                3&gt; this.addFieldError(&quot;password&quot;,&quot;密码必填&quot;);

                        # 验证方法中添加错误信息到错误信息集合
                        ## addFieldError(&quot;&quot;,&quot;&quot;)是从ActionSupport父类中继承的方法

        3.jsp文件中通过验证标签：
                        &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt;
                        &lt;s:fielderror/&gt;                # 显示所有错误信息
                        &lt;s:fielderror fieldName=&quot;password&quot;/&gt;
                显示验证出错信息

        4.xml配置
            &lt;!-- 验证错误信息处理 --&gt;
                &lt;result name=&quot;input&quot; type=&quot;dispatcher&quot;&gt;
                        /error.jsp
                &lt;/result&gt;
                        # 写在需要验证的方法对应的标签中，验证错误时验证方法会优先返回&quot;input&quot;字符串


    声明式（属性驱动）：
        1.验证Action类继承ActionSupport
        2.验证Action类目录下配置文件
            Action类名-validation.xml
            Action类名-&lt;action标签的name属性&gt;-validation.xml
                # 放入此名字的配置文件就相当于加了验证，不需要做其它事情
                ## ，相当于分别向Actioin类中加入了validate()validateXxx()方法进行了相应验证
                文件内容
                &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
                    &lt;!DOCTYPE validators PUBLIC
                    &quot;-//Apache Struts//XWork Validator 1.0.3//EN&quot;
                    &quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&quot;&gt;
                    &lt;validators&gt;
                            &lt;field name=&quot;username&quot;&gt;                # 要验证的属性
                                    &lt;field-validator type=&quot;requiredstring&quot;&gt;
                                            &lt;message&gt;用户名必填&lt;/message&gt;
                                    &lt;/field-validator&gt;
                            &lt;/field&gt;
                            &lt;field-validator type=&quot;regex&quot;&gt;
                                    &lt;param name=&quot;expression&quot;&gt;^[\u3447-\uFA29]&#43;$&lt;/param&gt;
                                    &lt;message&gt;UserAction2-validation==&gt;必须写中文&lt;/message&gt;
                            &lt;/field-validator&gt;
                    &lt;/validators&gt;

                            # xml文件的头在 xwork-core-2.3.1.1.jar包的
                                    xwork-validator-1.0.3.dtd中复制
                            ## 关联约束在
                                    \struts-2.3.15.1\src\xwork-core\src\main\resources\xwork-validator-1.0.3.dtd文件
                            ## &lt;field-validator type=&quot;&quot;&gt;的约束类型在xwork-core-2.3.1.1.jar包的
                                            /com/opensymphony/xwork2/validator/validators/default.xml文件中
                                                    # 16个规则
                                                    ## type=&quot;regex&quot;相当于调用了default.xml文件中配置的
                                                        ## RegexFieldValidator类的 setExpression方法
        3.jsp文件中通过验证标签（同上）
        4.xml配置（同上）
            # 出错信息
                1.验证文件名写错，无提示，不验证
                2.&lt;field-validator type=&quot;&quot;&gt;写错，有明显提示
                2.&lt;field name=&quot;salaryy&quot;&gt;写错，获取的salaryy为空。

    声明式（模型驱动）
            1.创建bean对象，bean对象中封装属性
            2.验证Action类继承ActionSupport类，声明bean对象实例
            3.action类同目录 中  ：Action类名-&lt;action标签的name属性&gt;-validation.xml
                            # &lt;field-validator type=&quot;visitor&quot;&gt;
                    # bean类同目录中：bean类名-validation.xml配置验证文件
            4.jsp文件请求参数改为：action类中bean对象名.bean对象封装的属性名。用&lt;s:fielderror/&gt;标签得到返回的错误信息
            5.xml配置（同上）

    原理
    StrutsPreparedAndExecuteFilter
        1.注入参数
                setUsername()
            setPassword()
        2.验证方法：validate()或validateXxx()
                        验证配置文件中验证：Action类名-validation.xml
        3.转发：根据验证成功或失败返回消息
                        验证集合无错误消息成功Action --&gt; execute或同签名的方法
                        验证集合有错误消息失败&lt;result name = &quot;input&quot; type=&quot;dispatcher&quot;
                                            register.jsp/login.jsp
# 过滤器
    StrutsPrepareAndExecuteFilter
        中查看Dispathcer类，从中找到配置struts-default.xml,struts-plugin.xml,struts.xml值的属性DEFAULT_CONFIGURATION_PATHS
        查找引用该属性的方法为init_TraditionalXmlConfigurations
        查看引用该方法的方法为init
        回头看StrutsPrepareAndExecuteFilter中初始化dispatcher对象的方法initDispatcher
                其中调用了dispatcher.init();方法来配置dispatcher
        由此可以知道struts在启动时加载了struts-default.xml,struts-plugin.xml,struts.xml配置文件
# 拦截器
    struts-core-2.3.1.1.jar包中的
        struts-default.xml文件中
                定义了32个interceptor（拦截器）
                        i18n    # 国际化
            token  # 表单重复提交
            validation  # 验证
            params  # 参数拦截器,向Action类中注入参数
            cookie
        interceptor-tack    # 拦截栈
                # 拦截栈中的拦截器的先后顺序有影响
                basicStack
            defaultStack    # 每个http请求都会经过该拦截栈
                            ## 其中的18个拦截器, &lt;default-interceptor-ref&gt;中定义
    原理
            拦截器仿照过滤器建立，内部实现原理是完全相同的
    执行流程
            拦截器构构造函数 -&gt; action构造函数 -&gt; 拦截器1 in -&gt; 拦截器2 in -&gt; demo -&gt; 拦截器2 out -&gt; 拦截器1 out
        exception拦截器最先进，最后出
    自定义拦截器
        1.定义Action类，继承Interceptor接口，重写生命周期方法
            public LoginInterceptor() {
            }
            public void destroy() {
            }
            public void init() {
            }
            public String intercept(ActionInvocation invocation)  {
            }
        2.配置struts.xml文件
            1&gt; 定义拦截器、拦截器栈
                &lt;interceptors&gt;
                    &lt;interceptor name=&quot;loginInterceptor&quot; class=&quot;interceptor.LoginInterceptor&quot;/&gt;
                    &lt;interceptor name=&quot;roleInterceptor&quot; class=&quot;interceptor.RoleInterceptor&quot;/&gt;
                    &lt;interceptor-stack name=&quot;crmStack&quot;&gt;
                        &lt;interceptor-ref name=&quot;loginInterceptor&quot;&gt;&lt;/interceptor-ref&gt;
                        &lt;interceptor-ref name=&quot;roleInterceptor&quot;&gt;&lt;/interceptor-ref&gt;
                    &lt;/interceptor-stack&gt;
                &lt;/interceptors&gt;
            2&gt; &lt;action&gt;标签中声明用到的拦截器或拦截器栈
                    &lt;interceptor-ref name=&quot;loginInterceptor&quot; /&gt;                # 此时默认的defaultStack拦截器栈会被替代掉
    自定义方法过滤拦截器
        # MethodFilterInterceptor继承AbstractInterceptor继承Interceptor，前两个是struts自己实现的自己的包装类
        ## 原理：自己实现intercept方法，实现对方法名的过滤。如果符合通过条件，则执行自己的doIntercept方法。所以要求用户重写doIntercept方法实现业务逻辑
        &lt;interceptor name=&quot;aloginInterceptor&quot; class=&quot;cn.it.shop.interceptor.AloginInterceptor&quot;&gt;
            &lt;param name=&quot;excludeMethods&quot;&gt;*$&lt;/param&gt;                # 除了*$匹配的方法都执行此拦截器
                    ## includeMethods为包含匹配的方法执行拦截器
        &lt;/interceptor&gt;
    生命周期
        部署时初始化，每次符合&lt;action&gt;的请求时，执行拦截器
    拦截器Action 类
        o-&gt; 继承Interceptor 接口
        o-&gt; 重写生命周期方法
            String intercept(ActionInvocation invocation)方法中调用
                invocation.invoke() 放行
                invocation.getAction()得到当前的Action类
                invocation.getStack()得到值栈中的栈
                    # invocation用于调试18个拦截器
    具体拦截器
        struts-default.xml 文件中定义了32种拦截器
                alias
        autowiring
        chain
        conversionError
        cookie
        clearSession
        createSession
        debugging
        execAndWait
        exception
        fileUpload                                # 只用来验证已经注入的文件是否合格，合格则通过，不合格则不执行action类中对应请求的方法
        i18n
        logger
        modelDriven                                # 用于检查action类是否实现ModelDriven&lt;T&gt;接口，然后调用getModel()方法注入得到的对象到栈的项端。
        scopedModelDriven
        params                                        # 注入参数用，包括注入文件（级联注入文件的ContentType与FileName）
        actionMappingParams
        prepare
        staticParams
        scope
        servletConfig                                # 向自定义的实现RequestAware等接口的Action类（一般是BaseAction类）中注入request等相应的map对象
        timer
        token                                                # 防止重复提交
        tokenSession
        validation                                # 验证
        workflow
        store
        checkbox
        profiling
        roles
        annotationWorkflow
        multiselect
    数据传递
        o-&gt; 拦截器不会向其它拦截器中注入参数，所以自定义拦截器中了参数要从request中获取
        o-&gt; 如果想 显式的引用了自己的拦截栈，默认的拦截栈就不引用了，要自己引用，其中的注入参数拦截器向action类中注入参数
    技巧
        &lt;interceptor-stack name=&quot;defaultStack&quot;&gt;    # 对defaultStack进行替换，在它前面添加自定义的拦截器
        &lt;interceptor-ref name=&quot;aloginInterceptor&quot;/&gt;
        &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;
    拦截器中的ActionInvocation对象
        可以得到ActionContext

# 文件处理
## 上传
    struts2文件上传步骤
        1.编写jsp文件
                1&gt; post方式提交
                2&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot;/&gt; 要添加name属性
                3&gt; post表单上传的编码方式是enctype=&quot;multipart/formdata&quot;
        2.创建Action类，不必继承任何类(但是如果不继承ActionSupport类的话，拦截器将不会返回提示消息)
                1&gt; 定义参数        # 如果不接收上传文件名字符串数组而从文件对象中获取文件名的话，得到的文件名将会是乱码
                        private File[] image;                                                # 字段名
                        private String[] imageContentType;                        # 文件类型
                        private String[] imageFileName;                                # 文件名
                        private String uploadPath;
                                        # 前三个参数可以不是数组，在 struts-default.xml配置文件fileUpload拦截器对应的源码中可以找到定义规则：
                                                &lt;li&gt;[File Name] : File - the actual File&lt;/li&gt;
                                                &lt;p/&gt; &lt;li&gt;[FileName]ContentType : String - the content type of the file&lt;/li&gt;
                                                &lt;p/&gt;&lt;li&gt;[File Name]FileName : String - the actual name of the file uploaded(not the HTML name)&lt;/li&gt;
                                        # uploadPath是我们自定义的配置文件中注入过来的文件存储位置

                2&gt; 写execute方法保存文件到路径，返回成功消息
        3.Action类的配置文件，include到src/struts.xml文件中
                        1&gt; &lt;action&gt;标签中配置name=&quot;input&quot;的标签&lt;result&gt;来返回出错消息
                        2&gt; &lt;action&gt;标签中用param标签注入文件存储路径：uploadPath 底层执行setUploadPath()方法
                        3&gt; &lt;action&gt;标签中通过&lt;interceptor-ref name=&quot;fileUpload&quot;&gt;标签对上传文件进行参数上的限定
                                1&gt; &lt;param name=&quot;maximumSize&quot;&gt; 单个文件的最大尺寸(字节)
                                2&gt; &lt;param name=&quot;allowedExtensions&quot;&gt; 文件扩展名
                                3&gt; &lt;param name=&quot;allowedTypes&quot;&gt; 文件实际类型，如image/jpeg，可从tomcat配置文件web.xml中查找
        4.配置返回消息的信息
                ：src/struts.properties文件中
                        struts.custom.i18n.resources=struts                # 解锁自/org/apache/struts2/default.properties总配置文件
                                        # 加载自己，=后面是参照src/目录的相对路径 ，省略掉.properties扩展名
                        struts.multipart.maxSize=2097152                #  解锁自/org/apache/struts2/default.properties总配置文件
                                        # 设置上传文件总量的大小
                        struts.messages.error.file.too.large=\u6587\u4EF6\u592A\u5927\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                        struts.messages.error.content.type.not.allowed=\u6587\u4EF6\u7C7B\u578B\u4E0D\u6B63\u786E\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                        struts.messages.error.file.extension.not.allowed=\u6269\u5C55\u540D\u4E0D\u6B63\u786E\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                                        # 覆盖/org/apache/struts2/default.properties总配置文件的响应消息,=后面是中文的unicode编码的iso8859-1的表示形式，通过视图可以直接配置，也可以用java/bin目录下的native2ascii.exe工具进行转码

    多文件上传
        出现有多个文件共同上传时，文件拦截器会出现一错全错的情况，这时我们利用struts的一个
                小bug---文件拦截不成功也调用action类的setXxx方法传入文件，从set函数中对文件进行筛选和转存
                这时文件拦截器已经形同虚设，一点作用也不起了。

    原理过程
        1.上传请求经过struts2的过滤器匹配扩展名
        2.按src/struts.xml文件中声明的配置包映射的名称空间映射到配置包
        3.根据action标签的name属性匹配名称空间与扩展名之间的“文件名”,映射到该action标签
                1&gt; 经过多层拦截器
                2&gt; 用param标签注入文件存储路径
                3&gt; 通过&lt;interceptor-ref name=&quot;fileUpload&quot;&gt;标签对上传文件进行参数上的限定
                2&gt; 执行action标签对应类的方法，该方法返回的返回的字符串进行响应

    默认配置
        1.defaultStack拦截栈中的fileUpload拦截器进行处理
        2.default.properties配置文件中 对multipart的上传方式进行了配置
                struts.multipart.parser=jakarta                  # struts使用了第三方的jakerta来给上传文件解码
                struts.multipart.saveDir=                      # 缓存文件的临时目录，不填默认是
                                                                                        ## work/catalina/localhost/web工程名/upload_.....00000..tmp
                struts.multipart.maxSize=2097152      # 默认支持的上传文件的大小 (字节，2m)，是总大小
        3.多数服务器自己删除缓存文件
## 下载
    用传递类型为stream 来返回要下载的文件
    写法
        &lt;result name=&quot;success&quot; type=&quot;stream&quot;&gt;
            &lt;!-- 下载文件的类型 --&gt;
            &lt;param name=&quot;contentType&quot;&gt;image/pjpeg&lt;/param&gt;
            &lt;!-- byte[]的大小，单位字节 --&gt;
            &lt;param name=&quot;bufferSize&quot;&gt;2048&lt;/param&gt;
            &lt;!-- 设置下载响应头，${uuidFileName}是一个OGNL表达式，不是EL表达式 --&gt;
            &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${uuidFileName}&lt;/param&gt;
            &lt;!-- 框架调用getXxx()方法，来获取InputStream流对象 --&gt;
            &lt;param name=&quot;inputName&quot;&gt;imageStream&lt;/param&gt;
        &lt;/result&gt;
            # 与其它同样，要注入的参数从stream类型对应的类中可以进行查看
    显示与下载的编码问题
        o-&gt; 设置tomcat/conf/server.xml
            &lt;Connector port=&quot;8080&quot; .. URIEncoding=&quot;utf-8&quot;/&gt;
        o-&gt; 提交下载请求用post方式，struts框架自动给post请求编码解码


  数据
  #


  日志
  #

scribe
    facebook出品
    特点
        支持nfs存储
    结构
        scribe agent
            向scribe发送数据
        scribe
            接收数据，不同topic 的数据发送给不同的store中
        存储系统(store)
            file, buffer, network, bucket, null, thriftfile, multi
chukwa
    # apache出品，hadoop系列产品
flume
    cloudera出品
    特点
        可靠性(节点故障时，日志传送到其他节点)
            三种级别
                end-to-end 发送前写磁盘，成功时删除
                store on failure 失败返回时写磁盘
                best effort 不确认数据是否成功
        可扩展性
            agent collector storage三层架构，每层可扩展。
                agent: 将数据源数据发送给collector
                collector: 将多个agent数据汇总后, 加载到storage中
                storge: 存储系统, 可以是file, hdfs, hive, hbase等
            agent collector 由master统一
logstash
    # 分布式日志收集，需结合kafka


  爬虫
  #

cheerio
    # node解析html，如jquery
scrapy-redis
    # python 分布式爬虫框架
phantomjs
    # js浏览器模拟框架


  分析
  #

pandas
    # python数据分析


  计算
  #

druid
    # apache
    特点
        分布式, 扩展性强
        高可用，可回滚
        内存, 时序数据库
        亚秒级OLAP,  实时分析
        多租户
spark
stream
hadoop


  搜索
  #

分类
    垂直搜索引擎
        针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。
    通用搜索引擎
        通过关键字的方式实现的，是语义上的搜索，返回的结果倾向于知识成果，比如文章，论文，新闻等
        通用搜索引擎的信息量大、查询不准确、深度不够
        通用搜索引擎的海量信息无序化

部分
    １.索引
    ２.分词
    ３.搜索

compass
    # 基于lucene
nutch
    # 基于lucene
sunspot
    # 基于Rsolr，以dsl结构用ruby调solr
sphinx
    # 基于sql的全文检索引擎


  lucene
  #

# 原理
    block k-d tree
    倒排索引
        词典
            排序数组
                # 为了二分查找
                # 实现简单，性能差
            哈希表
                # 性能好，占内存大
            跳跃表
                # 内存小且可调节, 模糊查询不好
            B/B&#43;树
                # 磁盘索引 ，更新方便，检索慢
            trie树
                # 效率与字符串长度有关，只适合做英文词典
            dat
                # 可做中文词典，内存占用小
            fst
                # 共享前缀，内存占用小，要求输入有序，不易更新
                内存存前缀索引、磁盘存后缀词块
        倒排表
        正向文件
            # 行式存储，原始文档
        doc-values
            # 列式存储，文档号到值的映射
    文件指纹

# 概念
    index
        # 一个倒排表，对应一个目录
    segment
        # index的存储单元，包含多个文档
    document
        # 创建单位
    field
        # 文档里的键值对
    term
        # 分词后的字符串
    analyzer
        tokenizer
            # 切分文本到索引单元
        tokenfilter
            # 对token预处理
# 常识
    特性
        索引
        高亮
        命中率排序
        分词
    与数据库的区别：数据库注重存储、全文检索注重查询
    其它搜索：多媒体搜索
    索引库(文件夹 或 内存中)：
        只存储了商品的基本信息
         索引库与数据库定时同步
        索引库 -&gt; document -&gt; field                # field是键值对,值只能存数据
                同步
        IndexWriter:addDocumnet(),delteDocument(),updateDocument()
                查询
                        IndexSearch:search(),get()
        Field的内部结构
                    # 不存不索引会报错
        Store:控制此Field字段是否存储到索引库中
        Index:是否建立索引（索引不区分大小写,过滤词不创建索引）
            NO:不建立索引，可以通过field的key查到，但是不能通过关键字查询到
            NOT_ANALYZED:建立索引，但是不分词
            ANALYZEd:建立索引又分词
# 使用到的对象
    Directory
    Analyzer
        TokenStream tokenStream = analyzer.tokenStream(&quot;eldName&quot;,new StringReader(&quot;测试字符串&quot;))
        while(tokenStream.incrementToken()){
                TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class);
                System.out.println(termAttribute.term());
        }                # 使用分词器测试分词
    Document
        add(Field)
        document = indexSearcher.doc(ScoreDoc)
        get(String)                # 通过key查找value
    IndexWriter
        IndexWriter(directory,analyzer,MaxFieldLength.LIMITED);       # LIMITED限定Field的数量(源码中规定默认值)
        addDocument(Document)
        commit()
        close()                        # 自带commit()
        rollback()
    IndexSearcher
    QueryParser
        QueryParser(Version.LUCENE_30,&quot;name&quot;,analyzer)
    Query
        query = parser.parse(用户传递的字符串);
        query = parser.parseMultiField(String [], 用户传递的字符串);
    TopDocs
        topDocs = indexSearcher.search(query, 10);                # 10是期望的结果数
                                                                                                        ## 最终查询到的结果数是：期望结果数与实际结果数的最小值
        totalHits                # 命中的结果数
    ScoreDoc
        ScoreDoc [] scoreDocs = topDocs.scoreDocs;
        scoreDoc.score                # 命中率积分
        scoreDoc.doc                # 命中文档编号，该编号由lucene自动生成
    Term                # 索引项
        Term(&quot;field中的key&quot;,&quot;field中value解析出的关键字&quot;)
# 索引的结构
    Term(&quot;key&quot;,&quot;value&quot;)[0,3,4]                        # key 为对应的field中的&quot;key&quot;,value对应的是解析field的&quot;value&quot;出的关键字
                                                                                ## []中的内容为匹配的文档编号，该编号为系统自动生成的
# 注意
    lucene创建索引时field的key都可以重复，没有主键方面的限制。但是实际应用时要求我们为document有唯一的标识“主键”field,便于对每个document进行更新与删除
# 使用
    包：IKAnalyzer,lucence-analyzer(英文分词，不需要),memory,core,highlighter
    工具：lukeAll 用来查看索引库
    添加、查询、删除、修改
    抽取配置类（构造方法私有化）
        Configuration
            维护了directory与analyzer
        DocumentUtil
            goodsToDocument(Goods)
            documentToGoods(Document)
        LuceneUtil
            维护了indexWriter与indexSearcher
            注意
                    1.indexWriter在static代码块中初始化
                    2.getIndexWriter
        LuceneService
            用indexWriter与indexSearcher处理业务逻辑
            添加
                indexWriter.addDocument(Document)
                indexWriter.rollback()
            删除
                indexWriter.deleteDocument(Term)
                indexWriter.optimize()                # 删除document的时候同步索引库，没有设置的话只是删除document，但是索引中还是可以查到
            更新
                indexWriter.updateDocument(Term,Document)
                indexWriter.optimize()                # 更新是先删除再添加（所以如果updateDocument(Term,Document)中匹配多个Document时，会出现删除了多个Document,而添加了一个Document的情况）
            查询
                QueryParser parser = new QueryParser(Version.LUCENE_30, &quot;field中的key&quot;, analyzer);
                Query query = IKQueryParser.parseMultiField(new String[]{&quot;name&quot;,&quot;remark&quot;}, &quot;ee&quot;);                # 多字段查询，IKAnalyzer特有
                    #　多字段查询到的第二个字段的结果，在转换高管时（调用getBestFragment时）只会对该方法指定的一个字段进行匹配，如果该字段不匹配时（但是第二个字段匹配），则会返回空。
                    ## 针对这一个bug,在getBestFragment处理匹配的结果返回空时，不使用空而直接返回没有高亮的字符串即可。
                parser.parse(用户传递的字符串);
                TopDocs topDocs = indexSearcher.search(query, 3);        # 3是期望结果数
                ScoreDoc [] scoreDocs = topDocs.scoreDocs;
                Document document = indexSearcher.doc(scoreDoc.doc);                scoreDoc.doc得到文档编号
                分页查询：
                    传递当前页码与一页记录数
                    利用topDocs.totalHits得到总记录数
                    查询本页与前面所有页的期望数据量，然后只截取本页的文档编号，得到document并返回数据

# 分词器
    IKAnalyzer
        配置文件
            src/IKAnalyzer.cfg.xml中配置
                &lt;properties&gt;
                    &lt;entry key=&quot;ext_dict&quot;&gt;/mydict.dic&lt;/entry&gt;                 # 配置自己的字典（不分词）
                    &lt;entry key=&quot;ext_stopwords&quot;&gt;/ext_stopword.dic&lt;/entry&gt;                 # 配置跳过的字
                &lt;/properties&gt;
        Query query = IKQueryParser.parse(&quot;name&quot;,name);                # IKAnalyzer特有
# 排序
    Directory directory = FSDirectory.open(new File(&quot;d:/lucene&quot;));
    IndexSearcher indexSearcher = new IndexSearcher(directory);
    Query query = IKQueryParser.parse(&quot;name&quot;,&quot;cc&quot;);
    Sort sort = new Sort(new SortField(&quot;id&quot;, SortField.INT,true));                # 这里可以排序多个字段
        # 参数1：&quot;id&quot;是排序的field字段,参数2：是字段内容的类型,参数3 true代表降序排列
        ## 此时命中率不再计算（因为不按命中率排序）
        ## 排序的field必须建立索引
    indexSearcher.search(query, null,10,sort);
高亮
    导入包:highlight与memory
    Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(&quot;&lt;font color=&#39;red&#39;&quot;,&quot;&lt;/font&gt;&quot;),new QueryScorer(query));
    highlighter.setTextFragmenter(new SimpleFragmenter(10));                # 限制字符长度
    ..
    String result = highlighter.getBastFragment(analyzer,&quot;name&quot;,doc.get(&quot;name&quot;));
        # 返回高亮处理字符串
        ## 参数1：解析用户输入词的分词器,参数2：是要查询的field的key(没有用)，参数3：field的value


  solr
  #

介绍
    基于lucene
    搜索服务器，http请求提交和返回xml
功能
    丰富了查询语言
    实现可配置、可扩展
    优化了性能
    提供了管理界面
    缓存功能
    垂直搜索
    高亮
    data schema定义字段


  elasticsearch
  #

介绍
    基于lucene
性能
    第一次查秒级响应(5-10秒)，放到文件系统缓存(filesystem cache)
    再查命令缓存毫秒级响应                              # 热点数据要预热
    文件系统缓存(内存中分配)和数据量同样大，才有效率        # 冷热分离

    分页，会查前面所有数据                              # 用scroll api, 快照 &#43; 游标


  权限
  #


  shiro
  #

功能
    认证
    授权
    加密
    会话管理
    Web集成
    缓存
组件
    Subject     # 当前用户,绑定到SecurityManager
    SecurityManager     # 门面模式，管理组件
    Realms      # 连接认证数据(用户、角色、权限)
    Authenticator   # 认证principals和credentials
    Authorizer  # 校验权限
    SessionManager      # 异构客户端
控制方式
    url
    注解
    代码
    页面标签
模块
    Authenticator
        # SecurityManager继承Authenticator
        public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  throws AuthenticationException;
    permission
        概念
            subject
            resource
            permission
            role
                隐式角色
                显示角色
        配置
            shiro.ini
                [users]
                zhang=123, role1, role2                # 用户名=密码, 角色1, 角色2
        判断角色
            o-&gt;
                subject.hasRole(&quot;admin&quot;);
            o-&gt;
                @RequiresRoles(&quot;admin&quot;)
                @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)
                    # 表示当前Subject需要角色admin和user。
            o-&gt;
                &lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;/shiro:hasRole&gt;
        权限注解
            @RequiresAuthentication
                # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。
            @RequiresUser
                # 表示当前Subject已经身份验证或者通过记住我登录的。
            @RequiresGuest
                # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。
            @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)
                # 表示当前Subject需要权限user:a或user:b。
    credential
        散列
            String str = &quot;hello&quot;;
            String salt = &quot;123&quot;;
            //内部使用MessageDigest
            String simpleHash
        密码生成工具
            //输入明文密码得到密文密码
            String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;
            //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）
            boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);
    filter
        NameableFilter                        ＃根据名字找到相应的拦截器实例
        OncePerRequestFilter                # 控制开启、关闭拦截器实例
        ShiroFilter                        # 安全控制
        AdviceFilter                        # aop
            preHandle                        # 前置增强
            postHandle                        # 后置增强
            afterCompletion                # 后置最终增强(异常也执行，相当于finally的概念)
        PathMatchingFilter                # 匹配请求路径
        AccessControlFilter                # 允许或拒绝访问，拒绝时如何处理
    jsp标签
        &lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;

        &lt;shiro:guest&gt;
        欢迎游客访问，&lt;a href=&quot;${pageContext.request.contextPath}/login.jsp&quot;&gt;登录&lt;/a&gt;
        &lt;/shiro:guest&gt;

        &lt;shiro:user&gt;
        欢迎[&lt;shiro:principal/&gt;]登录，&lt;a href=&quot;${pageContext.request.contextPath}/logout&quot;&gt;退出&lt;/a&gt;
        &lt;/shiro:user&gt;
            # 用户已经身份验证/记住我登录后显示相应的信息。

        &lt;shiro:authenticated&gt;
            用户[&lt;shiro:principal/&gt;]已身份验证通过
        &lt;/shiro:authenticated&gt;
            # 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。

        &lt;shiro:notAuthenticated&gt;
            未身份验证（包括记住我）
        &lt;/shiro:notAuthenticated&gt;
            # 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证。

        &lt;shiro: principal/&gt;
            # 显示用户身份信息，默认调用Subject.getPrincipal()获取
            &lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;
            &lt;shiro:principal property=&quot;username&quot;/&gt;

        &lt;shiro:hasRole name=&quot;admin&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有角色admin&lt;br/&gt;
        &lt;/shiro:hasRole&gt;

        &lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt;
        &lt;/shiro:hasAnyRoles&gt;

        &lt;shiro:lacksRole name=&quot;abc&quot;&gt;
            用户[&lt;shiro:principal/&gt;]没有角色abc&lt;br/&gt;
        &lt;/shiro:lacksRole&gt;
                        # 如果当前Subject没有角色将显示body体内容。

        &lt;shiro:hasPermission name=&quot;user:create&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt;
        &lt;/shiro:hasPermission&gt;

        &lt;shiro:lacksPermission name=&quot;org:create&quot;&gt;
            用户[&lt;shiro:principal/&gt;]没有权限org:create&lt;br/&gt;
        &lt;/shiro:lacksPermission&gt;
    session
        得到会话
            login(&quot;classpath:shiro.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);
            Subject subject = SecurityUtils.getSubject();
            Session session = subject.getSession();
        api
            Session
                getId()
                getHost()                # 调用HostAuthenticationToken.getHost(), 得到主机地址
                getTimeout()
                setTimeout(1000)
                getStartTimestamp()
                setLastAccessTime()
                touch()                        # 更新会话最后访问时间
                stop()                        # 销毁会话, Subject.logout()与HttpSession.invalidate()会自动调用该api
                setAttribute(&quot;key&quot;, &quot;123&quot;)
                getAttribute(&quot;key&quot;)
                removeAttribute(&quot;key&quot;)
            SecurityManager
                Session start(SessionContext context)
                Session getSession(SessionKey key) throws SessionException
            WebSessionManager
                boolean isServletContainerSessions();                # 是否使用Servlet容器的会话
            ValidatingSessionManager
                void validateSessions();                                # 验证所有会话是否过期
    cache
        接口
            Cach&lt;K, V&gt;
            CacheManager
            CacheManagerAware
        ini配置
            userRealm.cachingEnabled                        # 启用缓存，默认false
            userRealm.authenticationCachingEnabled        # 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false
            userRealm.authenticationCacheName                # 缓存AuthenticationInfo信息的缓存名称
            userRealm. authorizationCachingEnabled        # 启用授权缓存，即缓存AuthorizationInfo信息，默认false
            userRealm. authorizationCacheName                # 缓存AuthorizationInfo信息的缓存名称
            securityManager.realms=$userRealm

            cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager
            cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml
            securityManager.cacheManager=$cacheManager

            sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager
            securityManager.sessionManager=$sessionManager
    rememberme
    ssl
        o-&gt; keytool -genkey -keystore &quot;D:\localhost.keystore&quot; -alias localhost -keyalg RSA
            # jdk自带的生成证书工具(包含证书/公钥/私钥）
        o-&gt; 设置tomcat server.xml
            &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;
            maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
            clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;
            keystoreFile=&quot;D:\localhost.keystore&quot; keystorePass=&quot;123456&quot;/&gt;
        o-&gt;
    jasig cas
api
    Subject: 主体, 如用户
    SecurityManager: 安全管理器, 管理subject
    Realm: 权限数据域

    授权
        对象流程
            Subject.isPermitted -&gt; SecurityManager -&gt; Authorizer
        对象
            ModularRealmAuthorizer        # 多realm授权
            PermissionResolver                # 解析权限字符串到Permission实例
            RolePermissionResolver                # 从角色得到权限集合
配置
    参数
        filterChainDefinitions
            rest：比如/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user：method] ,其中method为post，get，delete等。

            port：比如/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal：//serverName：8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。

            perms：比如/admins/user/**=perms[user：add：*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，比如/admins/user/**=perms[&quot;user：add：*,user：modify：*&quot;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。

            roles：比如/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，比如/admins/user/**=roles[&quot;admin,guest&quot;],每个参数通过才算通过，相当于hasAllRoles()方法。

            anon：比如/admins/**=anon 没有参数，表示可以匿名使用。

            authc：比如/admins/user/**=authc表示需要认证才能使用，没有参数

            authcBasic：比如/admins/user/**=authcBasic没有参数表示httpBasic认证

            ssl：比如/admins/user/**=ssl没有参数，表示安全的url请求，协议为https

            user：比如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查
                    # remember me可登录


  分布式
  #


  redisson
  #

介绍
    使用redis外部存储，实现分布式功能
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://ukeate.com/docs/middleware/library/">
  <meta property="og:site_name" content="ukeate的笔记">
  <meta property="og:title" content="小功能">
  <meta property="og:description" content="名词 # dom 文档对象模型 dao 数据访问对象 ucs unicode character set utf ucs Transformation Format bmp Basic Multilingual plane bom Byte Order Mark asp Active Server Pages iis Internet Information services validate code 验证码 tld tag library description jsp java server page xsd XML Schemas Definition suffix 后缀 ide Integrated Development Environment RIA Rich internet Applications 富互联网应用（富客户端）C/S架构是胖客户端，B/S架构是瘦客户端。比如 flash就是ria(其它如js, SilverLight，unity3d，flash3d,adobe air,HTML5/css3，adobe Flex等) JPA Java Persistence API java持久层api JDBC Java DataBase Connectivity DHTML DynamicHTML cvs Concurrent Version System svn subversion uml UnifiedModelingLanguage AJAX Asynchronous JavaScript and XML bnf 命令书写格式规范: 巴科斯范式 desc description capacity 容量 component 组件 association 联合 aggregation 聚合 composition 组合 alpha 开端 inherit 继承 dhtml dynamic html ,是 html css 客户端script 不是规范，是现有技术、标准的整合运用 css Cascading Style Sheet 级联样式表 associated 交互的 perspective 视图 adapter 适配器 jit just in time (compilation) webdav Web-based Distributed Authoring and Versioning Web 分布式创作和版本管理 (WebDAV) 扩展了 HTTP/1.1 协议，允许客户端发布、锁定和管理 Web 上的资源 CMS Content Management System 内容管理系统 它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。 constraint 约束 JSON javascript object notation(标记) OGNL Object-Graph Navigation Language 对象图导航语言 jmf java media frame java 媒体框架 是一个jar 包 dwr Direct Web Remoting 是一个ajax框架。它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数，就像它就在浏览器里一样。 CXF apache的 Celtix &#43; XFire,用于实现 web services的发布的使用 oa Office Automation 办公自动化 dml data manipulation language 数据操作语言 ddl data definition language 数据定义语言 dcl data control language 数据控制语言 ioc inversion of control 控制反转（spring） di dependence injection 依赖注入 （spring） crud 增加(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete) ssh Secure Shell,由IETF制定，为建立在应用层和传输层基础上的安全协议。 pojo pure old java object oop object oriented programming aop aspect oriented programming 面向切面编程 hdfs Hierarchical Data Format 层次型资料格式（分布式存储） ftp File Transfer Protocol ssl Secure Sockets Layer 安全套接层。端口40 tls Transport Layer Security 传输层安全(ssl的继任者) https Hypertext Transfer Protocol Secure 应用ssl作为应用层子层对数据进行压缩与解压。端口443 jsf JavaServer Faces 是sun开发的web框架，相当于ssh(spring &#43; struts &#43; hibernate) sns Social Network Services 社会性网络服务 uml Unified modeling language 统一建模语言 jta java transaction api (hibernate中) java事务处理api asm Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。 汇编语言(Assembly Language)的扩展名 jsr Java Specification Requests 是Java规范请求，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。jsr303:基于注解的java bean 验证 dto data transfer object 数据传输对象 antlr another tool for language recognition 一个开源的语法分析器 soap simple object access protocol 简单对象访问协议 uefi unified extensible firmware interface 统一可扩展固件接口 sso single sign on 单点登录 erp enterprise resource plan 企业资源计划 sap Systems Applications and Products in Data Procession 企业系列软件(全世界排名第一的erp软件) ssi Server Side Include 服务器端嵌入 jmx Java Management Extensions java管理扩展，是一个为应用程序、设备、系统等植入管理功能的框架。 jaas Java Authentication Authorization Service Java验证和授权API jca(J2C， J2CA) Java Connector Architecture java连接器架构 jms Java Message Service java消息服务，用于在两个应用程序之间，或分布式系统中发送消息 jaf JavaBeans Activation Framework JAF是一个专用的数据处理框架，它用于封装数据，并为应用程序提供访问和操作数据的接口。JAF的主要作用在于让java应用程序知道如何对一个数据源进行查看、编辑和打印等操作。 jta Java Transaction API Java事务API,和jts为J2EE平台提供了分布式事务服务 jts Java Transaction Service java事务服务 scm Supply chain management 一种集成的管理思想和方法，执行供应商到最终用户的物流计划控制职能 ctr click-through-rate 网络广告 ioc/di inversion of control/ dependency injection o2o online to offline 网站提供平台, 用户线下交易 cas central authentication service 单点登录 foobar FTP Operation Over Big Address Records(RFC1545文档)ftp命令列表 modular 模块化 enumeration 计数 navigate 导航 fragment 碎片 posix 可移植的 intersection 截断 categories 类别 encounter 遭遇 recursion 递归 evaluate 评价 indent 缩进 collation 校对 schema 模式、图表 generate 生成 Presentation 描述 hierarchical 垂直分层 stereotype 策略 numerous 许多 KISS keep it simple, stupid cross-origin 跨域 CORS Cross-Origin Resourse Sharing NIH not invented here 自己造轮子 mis management information system crm customer relationship management erp enterprise resource planning webRTC web Real-Time Communication 库 # 日志 # log4j # java logback # log4j后续版本 slf4j # java log4js # js 格式|模板 # moment # js格式化时间 iconv # nodejs调用c&#43;&#43; libiconv库来转码 iconv-lite # nodejs实现的转码，比调用c&#43;&#43; 的iconv更高效 poi # java 文件处理 jFreeChart # java图表库 jackson # java json序列化 json-smart # java json xstream # java xml序列化 pango2 # 国际化模板 snakeyaml # java yaml js-beautify # js, html格式化 xmlbeans # java xml joda-time # java日期 dom4j # java dom 生成|压缩|加密|计算特征 # simhash # google 文档hash pygments # python 生成高亮html mako # python 模板 jinja2 # python 模板 freemarker # java 模板 proguard # java 混淆 snappy # google java 压缩 jbcrypt # java加密, scrypt更强 客户端|邮件 # javamail # java mail nodemailer # node mail mailapi # java mail c3p0 # java rds 连接池 dbcp # java rds 连接池 druid # java rds 连接池。可监控sql执行性能，记sql日志 jdbc # java rds client dbutil hibernate ef # .net orm NHibernate # .net orm peewee # python orm node-mysql mongoose httpClient # java http request # js http superagent # js http mybatis hsqldb # java内置, 单文件/内存数据库 mqttv # java mqtt客户端 libthrift # java thrift kafka-clients 领域语言 # lex # 生成词法分析程序 yacc # 生成自底向上语法分析程序 antlr 图形 # ccap # 基于c&#43;&#43;的图形CImg库，就是一个CImg.h文件 canvas # node canvas tesseract # node 验证码 运维控制 # later # nodejs corntab glob # nodejs 匹配获得文件 rd # node 遍历文件 commander # node制作命令 mkdirp # node 递归makedir fs-extra # node扩展fs包 testcontainers # java, 运行docker jOptSimple # java, 命令解析 协议 # spring-websocket # java httpcore-nio # java grpc-context # java 高可用 | 性能 # retry # js retry ehcache # 缓存 tagg # node线程池 cluster # node单机集群 fiber # node协程 driud # 连接池，阿里开源 akka # # scala并发、分布式、容错工具 使用 system = ActorSystem.create(&#34;hello&#34;) system.actorOf() ## 前端 ### dwr 介绍 java函数通过ajax映射到前端js调用 使用 ajax框架 1.导入jar包 dwr.jar 2.web-inf/下的配置文件 web.xml文件 &lt;servlet&gt; &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;servlet-class&gt;org.directwebremoting.servlet.DwrServlet&lt;/servlet-class&gt; # 固定写法 &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;scriptCompressed&lt;/param-name&gt; # 允许在javascript中执行 &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; # web工程启动时加载 &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt; &lt;url-pattern&gt;/dwr/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; dwr.xml文件 &lt;dwr&gt; &lt;allow&gt; &lt;create creator=&#34;new&#34; javascript=&#34;DWRUserAccess&#34;&gt; # 生成js文件的名（页面中引用） &lt;param name=&#34;class&#34; value=&#34;outrun.dwr.DWRUserAccess&#34; /&gt; # 曝露的类 &lt;/create&gt; &lt;convert converter=&#34;bean&#34; match=&#34;outrun.dwr.User&#34; /&gt; # 注册实体类，可以在js中进行实例化 &lt;/allow&gt; &lt;/dwr&gt; 3.写outrun.dwr.DWRUserAccess中的方法 4.页面调用 test.html &lt;script src=&#34;/outrun/dwr/engine.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;/outrun/dwr/util.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;/outrun/dwr/interface/DWRUserAccess.js&#34;&gt;&lt;/script&gt; &lt;SCRIPT LANGUAGE=&#34;JavaScript&#34;&gt; DWRUserAccess.方法(参数,执行完运行的js函数) # 参数可以是一个map,如 var userMap = {}; userMap.id = regForm.id.value; userMap.password = regForm.password.value; userMap.name = regForm.name.value; userMap.email = regForm.email.value; DWRUserAccess.save(userMap, saveFun); # 其中的regForm是页面中的表单（的name属性,dom支持直接使用名字引用表单） &lt;/SCRIPT&gt; 开发 # 脚手架 # spring boot # drapWizard # # java，类spring boot 写法 # traits-decorator # js mixin q # js 流程控制 co # js generator to async async # js 流程控制 thunkify # js函数Thunk化, 确保回调调用一次 step # async轻量库 wind # js定义的宏 streamline # 基于源代码编译来实现流程控制简化 eventproxy # js event回调 spring # java ioc guice # google的java ioc轻量框架 castle # .net ioc spring.net # .net ioc anko # go 代码解释器 antlr # java dsl aopalliance # java aop ejb # 特点 分布式，j2ee一部分 组成 会话bean(session) 实体bean(entity) 消息驱动bean(message driven) 语言增强 # guava # # google工具集 maven &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;/dependency&gt; 组件 o-&gt; 增强 Optional # null处理 Preconditions # 准入检查 Ordering Throwables o-&gt; 集合 Multiset # 存重复元素 Multimap # 多值 BiMap # 双向映射 Table # 两键一值 Range # 连续值 o-&gt; 字符串 Joiner Spilter CharMatcher CaseFormat o-&gt; 类型 Objects Bytes Shorts Ints Longs Floats Doubles Chars Booleans o-&gt; 数学 IntMath LongMath BigIntegerMath o-&gt; 高可用 LoadingCache # 堆内缓存 接口 # luavit # lua实现, 类node scotty # haskell webapi # .net meteor.js # 基于node.js &#43; mongodb的网站开发平台，把这个基础构架延伸到浏览器端, 本地和远程数据通过DDP(Distributed Data Protocol)协议传输 restify # 基于nodejs的rest应用框架，去掉express中的 template, render等功能, 提供DTrace功能，方便调试 ssh # java spring site # spring整合 tapestry # 基于servlet的mvc框架 jersey # java restful服务 naga # java nio echo # go beego # go gorilla # go gin # go，类express iris # go, fasthttp的一种实现 tornado # python nio web.py twisted # event driven flask django bottle # python wsgi rails # ruby的web mvc开发框架 ror # ror(ruby on rails) sinatra # 微型web grape # 运行在rack或rails/sinatra配合使用的restful风格的ruby微框架 yii # php laravel # php codelgniter # php RESTful # connect # 介绍 nodejs处理http中req、res的中间件框架 中间件分类 pre-request用来改写request原始数据 request/response功能各异 post-response全局异常处理，改写response数据等 内置中间件介绍 logger csrf compress # gzip压缩 basicAuth # basic认证 body parser # 请求内容解析 json urlencoded # application/x-www-form-urlencode请求解析 multipart # multipart/form-data请求解析 timeout cookieParser session cookieSession methodOverride # http伪造 responseTime # 计算响应时间 staticCache # 缓存 directory # 目录列表 vhost # 虚拟二级域名映射 favicon limit # 请求内容大小限制 query # url解析 errorHandler # 错误处理 使用 var connect = require(&#39;connect&#39;); var app = connect() .use(connect.logger(&#39;dev&#39;)) .use(function(req, res){ res.end(&#39;hello world\n&#39;); }) .listen(3000); express # 安装 npm install -g express-generator npm install express -d # g代表安装到NODE_PATH的lib里面, d代表关联套件一起安装 cookie-parser 使用 var cookieParser = require(&#39;cookie-parser&#39;); app.use(cookieParser()); JSON.stringify(req.cookies); req.cookies.yourCookie cookie-session 使用 var cookieSession = require(&#39;cookie-session&#39;); app.use(cookieSession()) req.session = null express-session options可选参数 name # 表示cookie中保存session的字段名称，默认为connect.sid store # session的存储方式，默认存放在内存中，也有redis、mongodb、等模块支持 secret # 设置secrect来计算hash放在cookie中产生signedCookie，来防篡改 genid # 规定产生一个新的session_id时所用的函数，默认用uid2这个包 rolling # 每个请求都重新设置一个cookie，默认为false resave # 即使session没有被修改，也保存session的值 使用 var session = require(&#39;express-session&#39;); app.use(session(options)); connect-redis 使用 var express = require(&#39;express&#39;); var session = require(&#39;express-session&#39;); var redisStore = require(&#39;connect-redis&#39;)(session); app.use(session({ store: new redisStore(), secret: &#39;somesecrettoken&#39; })); serve-static # 静态文件 passport 介绍 登录验证中间件 支持connect express sails等web框架 支持Basic, Digest, OAuth(1.0和2.0的三种实现), Bearer等 安装 npm i passport npm i passport-local o-&gt; 配置 var express = require(&#39;express&#39;); var cookieParser = require(&#39;cookie-parser&#39;); var session = require(&#39;express-session&#39;); var flash = require(&#39;express-flash&#39;); var passport = require(&#39;passport&#39;); ... app.use(cookieParser()); app.use(session({...})); app.use(passport.initialize()); app.use(passport.session()); app.use(flash()) passport.serializeUser(function (user, done) { done(null, user.id) }) passport.deserializeUser(function (id, done) { User.findById(id, function (err, user) { done(err, user) }) }) app.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;, { # passport.authenticate是个登录中间件，通过就走后面回调，否则返回401 # local是自定义的名称 successRedirect: &#39;/&#39;, failureRedirect: &#39;/login&#39;, failureFlash: true, }, function (req, res) { res.redirect(&#39;/users/&#39; &#43; req.user.username) })) app.post(&#39;/login&#39;, passport.authenticate(&#39;local&#39;, function(err, user, info) { if (err) return next(err) if (!user) { req.flash(&#39;errors&#39;, {msg: info.message}) return res.redirect(&#39;/login&#39;) } req.logIn(user, function (err) {}) })(req, res, next)) app.get(&#39;/logout&#39;, function(req, res) { req.logout() res.redirect(&#39;/&#39;) }) app.get(&#39;/user&#39;, isAuthenticated, getUser) var isAuthenticated = function (req, res, next) { if (req.isAuthenticated()) { return next() } res.redirect(&#39;/login&#39;) } o-&gt; local验证 var LocalStrategy = require(&#39;passport-local&#39;).Strategy passport.use(new LocalStrategy( function(username, password, done) { User.findOne({username: username}, function(err, user) { if (err) {return done (err)} if (!user) {return done(null, false, {message: &#39;no user&#39;})} if (!user.validPassword(password)) {...} return done(null, user) }) } )) o-&gt; usernameField passport.use(new LocalStrategy({ usernameField: &#39;email&#39;, passwordField: &#39;passwd&#39; }, function (username, password, done) {...} )) o-&gt; OAuth 介绍 第三方登录协议 三个步骤 1. 获取未授权的request token 2. 获取用户授权的request token 3. 用授权的request token换取access token 使用 网页上申请开发github应用 npm install passport-github # 安装passport的github扩展 // app.js passport.use(new GithubStrategy({ // 增加github认证策略 clientID: &#39;XXXX&#39;, clientSecret: &#39;YYYY&#39;, // 已从github上申请 callbackURL: &#39;http://localhost:3000/auth/github/callback&#39; }, function(accessToken, refreshToken, profile, done){ done(null, profile); })); // 定义路由 app.all(&#39;/github&#39;, isLoggedIn); app.get(&#39;/github&#39;, user.github); app.get(&#39;/auth/github&#39;, passport.authenticate(&#39;github&#39;, {scope: &#39;email&#39;})); app.get(&#39;/auth/github/callback&#39;, passport.authenticate(&#39;github&#39;, { successRedirect: &#39;/github&#39;, failureRedirect: &#39;/&#39; })); kraken 介绍 基于express之上的基于设置结构化代码工具 功能 post请求_csrf验证 基本用法 &#39;use strict&#39; var express = require(&#39;express&#39;), kraken = require(&#39;kraken-js&#39;); var app = express(); app.use(kraken()); app.listen(8000); koa # 介绍 express原班人马打造的，更小，更健壮，更有表现力的web框架 免除重复繁琐的回调函数嵌套，提高错误处理效率 不绑定任何中间件，只是提供一个轻量优雅的函数库 &gt;=node0.11.16 配置 app.name # 应用名称 app.env # 执行环境，默认是NODE_ENV 或 &#39;development&#39; app.proxy # 决定哪些proxy header被加到信任列表中 app.subdomainOffset # 被忽略的.subdomains列表 app.jsonSpaces # 输出json时是否填充空格 app.outputErrors # 是否输出错误堆栈(err.stack)到stderr(app.env是&#39;test&#39;时，此值为false) 使用 $ npm install koa $ node --harmony app.js # 必需使用harmony模式运行程序 var koa = require(&#39;koa&#39;); var app = koa(); app.use(function *(){ this.body = &#39;Hello World&#39;; }); # function* 声明的generator function支持yield ## yield是ES6定义的新语法 app.listen(3000); 使用(downstream &amp; upstream) var koa = require(&#39;koa&#39;); var app = koa(); // x-response-time app.use(function *(next){ // (1) 进入路由 var start = new Date; yield next; // (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间 var ms = new Date - start; this.set(&#39;X-Response-Time&#39;, ms &#43; &#39;ms&#39;); // (6) 返回 this.body }); // logger app.use(function *(next){ // (2) 进入 logger 中间件 var start = new Date; yield next; // (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间 var ms = new Date - start; console.log(&#39;%s %s - %s&#39;, this.method, this.url, ms); }); // response app.use(function *(){ // (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream this.body = &#39;Hello World&#39;; }); app.listen(3000); this request header headers url accepts response header headers status cookies set(&#39;name&#39;, &#39;tobi&#39;, {signed: true}) signed expires path domain secure httpOnly get type length path method state throw assert app use listen callback keys context db 中间件 koa-router trie-router route basic-auth etag compose static static-cache session compress csrf logger mount send error 实时 # sockjs # node websock postal # nodejs 在内存上构建的发布订阅框架 pusher # 发布订阅模式socketio框架 juggernaut # 基于socketio datachannel.io # 基于socket.io和html5 webRTC的实时聊天室框架 faye-websocket-node # 扩展faye项目开发的websocket的一个实现, 非常简单，而且不依赖其他库 websocket-node # 一个简单的websocket库，支持draft-10及之前的各种版本, 支持同样是node的c/s交互模式 ejabberd # 基于erlang/OTP 的xmpp im 开源框架 singalR # .net sock服务 nsq # go openfire # java, 性能较差, 最多单机10w并发 webrtc # c&#43;&#43;实现的web视频聊天 socket.io # # 介绍 socket.io: 基于任何浏览器, mobile设备的&#34;webSocket&#34; # 安装 npm install socket.io # 使用 var socketIo = require(&#39;socket.io&#39;); socketIo.listen(app).on(&#39;connection&#39;, function (socket) { # require(&#39;socket.io&#39;)(app); ## var io = require(&#39;socket.io&#39;)(80); socket.emit(&#39;news&#39;, { hello: &#39;world&#39; }); socket.on(&#39;my other event&#39;, function (data) { console.log(data); }); }); # api server io.on(&#39;connection&#39;, function(socket){}); io.on(&#39;disconnect&#39;, function(){}); socket.on(&#39;message&#39;, function(msg){}); client-js socket = io.connect(url); socket.on(&#39;&#39;, function(json){}); socket.send(json); io on(&#39;connection&#39;, function(socket){}); # disconnect socket on(&#39;disconnect&#39;, function(){ }); socket.on(&#39;say to someone&#39;, function(id, msg){ socket.broadcast.to(id).emit(&#39;my message&#39;, msg); }); # Socket#id为内部指定的 遍历用户 var roster = io.sockets.clients(&#39;chatroom&#39;); roster.forEach(function(client){ console.log(&#39;Username: &#39; &#43; client.nickname); }); // 1.0之前版本可用 # 方案 namespace server var nsp = io.of(&#39;/my-namespace&#39;); Onsp.emit(&#39;hi&#39;, &#39;everyone!&#39;); # ns广播 client var socket = io(&#39;/my-namespace&#39;); room server socket.join(&#39;some room&#39;); io.to(&#39;some room&#39;).emit(&#39;some event&#39;): # room广播 socket.leave(&#39;some room&#39;); # 子模块 socket.io-redis 介绍 用于从外部发消息，与socket.io-emitter一起使用 使用 var io = require(&#39;socket.io&#39;)(3000); var redis = require(&#39;socket.io-redis&#39;); io.adapter(redis({ host: &#39;localhost&#39;, port: 6379 })); socket.io-emitter 介绍 用于从外部发消息，与socket.io-redis一起使用 使用 var io = require(&#39;socket.io-emitter&#39;)(); io.emit(&#39;time&#39;, new Date); socket.io-client 介绍 用于创建客户端来连接socket.io 使用 var iocl = require(&#39;socket.io-client&#39;); var socket = iocl.connect(&#39;127.0.0.1:5555&#39;); socket.on(&#39;connect&#39;, function(){ }); 展示 # titles # java apache的标签库 spring mvc # struts2 # # 基础 介绍 struts1和WebWork的发展 引入值栈的概念 # 一次请求的参数和处理数据放在一个map结构中 原理 基于拦截器, 解耦servlet, 再提供自己的拦截器(interceptor)操作数据, 反射调用业务类 FilterDispatcher通过配置文件来映射设置请求地址与处理类 ActionMapper判断请求是否struts处理 ActionProxy扩展实现方式(如web service) ConfigurationManager对应struts.xml配置文件 ActionInvocation执行Action与拦截器 Action处理请求，封装数据 # Action是非单例的，效率低 过滤器与拦截器 过滤器基于回调，拦截器基于反射 过滤器依赖servlet, 拦截器在struts中处理action # 思想 Action类中的无侵入设计（新技术中不出现旧技术）：map代替了作用域 ActionContext actionContext = actionContext.getContext() actionContext.getApplication() actionContext.getSession() 好处 map是java中的api，不出现旧技术 测试方便（ servlet不能测试，只能发布测试） # 注意：Action类中用到作用域map的方法也不能测试 # 结构 apps: 例子程序 docs:帮助文件 lib:程序包 src:源码 # 使用 要求 jdk5 jsp2 servlet api2.4 导入核心的8个包 struts2-core-2.3.1.1.jar # struts的过滤器 xwork-core-2.3.1.1.jar # 验证工具 freemarker-2.3.18.jar # 标签 javassist-3.11.0.GA.jar # 动态代理 commons-fileupload-1.2.2.jar commons-io-2.0.1.jar # 文件处理 commons-lang-2.5.jar # 基础包 ognl-3.0.3.jar # 表达式语言 web.xml文件中配置过滤器 &lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 写jsp页面，get或post路径为struts2的名称空间、扩展名，被配置的struts2过滤器处理 写Action类（继承ActionSupport类） 配置src/struts.xml文件与src/struts.properties文件，映射类、方法等到请求路径，映射返回字符串到任何方式 # 核心包：8个 struts2-core-2.3.1.1.jar # struts的过滤器 xwork-core-2.3.1.1.jar # 验证工具 freemarker-2.3.18.jar # 标签 javassist-3.11.0.GA.jar # 动态代理 commons-fileupload-1.2.2.jar commons-io-2.0.1.jar # 文件处理 commons-lang-2.5.jar # 基础包 ognl-3.0.3.jar # 表达式语言 # 配置 struts2以包的形式管理action 包名必须唯一，包里的每个action唯一 使用步骤 导入lib包 写jsp 编写Action方法 web.xml中配置 &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;url-pattern&gt;/* ../xx_struts.xml中配置请求响应 src/struts.xml 中引入配置文件 &lt;include file=&#34;cn/itcast/javaee/cal/cal_struts.xml&#34;/&gt; 配置文件（配置包）路径 重要路径：4个 1./struts-default.xml[框架] # 是框架自带的abstract包（包括上传，下载，验证等），继承它以后可以用其中的功能 2./org/apache/struts2/default.properties[框架] 3.src/struts.xml # 必有 4.src/struts.properties # 可选 验证返回消息的配置文件 struts2-core-2.3.1.1.jar包中的 /org/apache/struts2/struts-messages.properties文件 xml 中配置的简化 * o-&gt; 只能在name 中写*_* 等 o-&gt; 引用第一个* 用{1} 引用第二个用{2} 以此类推 类路径 com.opensymphony.xwork2.ActionSupport 默认关联到的类 处理请求的扩展名配置 # 扩展名配置只有一个会生效 1./org/apache/struts2/default.properties struts.action.extension=action,, # 框架中初始的默认扩展名，最后的&#39;,&#39;代表了无扩展名 2.src/struts.xml中 &lt;constant name=&#34;struts.action.extension&#34; value=&#34;do,,&#34;&gt; # 必需配置 3.src/struts.properties中 struts.action.extension=xx,yy # 选择配置，优先级高 默认配置 struts2内置了请求字符串与基本类型的相互转换，不用手工转换 /org/apache/struts2/default.properties文件中 struts.i18n.encoding=UTF-8 # post方式请求响应的编码方式 ## get方式的没有默认值，需要自己转码 struts.action.extension=action,, # 框架中初始的默认扩展名,最后的&#39;,&#39;代表了无扩展名 每个&lt;package&gt;标签中配置 &lt;interceptor-ref name=&#34;defaultStack&#34;&gt;&lt;/interceptor-ref&gt; 为默认的拦截器 src/struts.xml配置文件 src/struts.properties配置文件 # 原理流程 请求/qq.action -&gt; StrutsPreparedAndExecuteFilter（核心过滤器）-&gt; 匹配扩展名 -&gt; 匹配命名空间 #（ 全限定名：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.class） -&gt; src/struts.xml -&gt; name class method -&gt; name type 内容 -&gt; 响应 -&gt; 拦截器 -&gt; ConfigAction类 # 1.部署时读取src/struts.xml和src/struts.properties文件，形成JavaBean对象 # 两个文件同时存在时src/struts.properties文件为准 ## 2.请求/*路径时，StrutsPreparedAndExecuteFilter过滤 ## 3.获取JavaBean中的actionName ,actionClass, actionMethod, 执行方法 ## 4.执行的返回值与resultName, resultType, resultContent进行比较 ## 5.按resultType类型返回resultContent（路径和内容） # 缺点 8个jar包，慢，servlet 快 配置繁琐 # 编码 struts2默认编码方式:utf-8 返回的图片相对路径中有中文时设置tomcat tomcat/conf/server.xml &lt;Connector port=&#34;8080&#34; .. URIEncoding=&#34;utf-8&#34;/&gt; 这时点击下载的请求路径中有中文时在以post方式提交 ,struts自动转码。若以get方式提交，需要在Action类的相应的get方法中转换url编码（iso8859-1）到u8 原理 改了tomcat的内部编码以后，struts中的编码是u8，放在session 中，jsp支持u8,解释后发送的html中的编码没问题，查看没问题。 下载post发送请求，浏览器请求的是url编码的u8,struts中也是u8执行下载 如果不改编码，struts 中是u8,如果以List方式放入session的话,session存储的是u8 如果直接放入数据的话,session中存储的是8859-1,jsp取出数据需要转码为u8并设置自己的编码是u8,再发送给浏览器。 浏览器这时获取图片正常,post方式提交的是u8,经过tomcat转换为8859-1,struts中自动转换编码到u8 如果是以get方式提交请求，get中的中文在浏览器时进行url编码到8859-1,经过tomcat，再到struts,struts不对get方式的请自动进行转码 向action类中注入参数时是8859-1编码,需要手动在action类中的属性的get方法中进行8859-1到u8的转码操作 # 内置对象 struts中的6个内置对象 # request请求进入struts中时创建，request请求结束时销毁。 requestMap sessionMap applicationMap parameters attr # page -&gt; request -&gt; session -&gt; application 的顺序查找 valueStack # 定义实例变量，直接放入valueStack的 list（栈） 中,map（值）很少向内存储数据 # 定义的实例变量必须提供相应的get方法,否则ognl标签中取其数据时没有方法调用，就得不到它的值 # list 中的值优先访问 ，但是map 中的值起决定作用 # map中存放着一个大map,其中注入了所有页面的请求信息 # requestMap sessionMap applicationMap 并不是真正的域对象，但最后通过拦截器放入到域对象中 # 异常处理 配置src/strut.xml 文件 &lt;global-results&gt; 全局结果（用来跳转全局异常等） &lt;global-exception-mappings&gt; 全局异常 &lt;exception-mapping result=&#34;nullJsp&#34; exception=&#34;java.lang.NullPointerException&#34; /&gt; # &lt;action&gt;标签中的局部异常 ## &lt;action&gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&#34;nullJsp&#34;的字符串交给本&lt;action&gt;标签中相应的&lt;result&gt;标签来处理 处理机制 o-&gt; 多个异常时走子异常，父异常被忽略 o-&gt; 先处理小范围异常，大范围忽略 o-&gt; 如果异常没有处理，抛出到web服务器处理,web.xml的&lt;error-page&gt;&lt;error-code&gt;&lt;location&gt; 全局异常 xml文件中 &lt;global-results&gt; &lt;result name=&#34;error&#34;&gt; /error.jsp &lt;/result&gt; &lt;/global-results&gt; &lt;global-exception-mappings&gt; &lt;exception-mapping result=&#34;error&#34; exception=&#34;java.lang.Exception&#34;/&gt; &lt;/global-exception-mappings&gt; error.jsp页面中 &lt;%@ taglib prefix=&#34;s&#34; uri=&#34;/struts-tags&#34; %&gt; 异常信息：&lt;s:property value=&#34;exception.message&#34;/&gt;&lt;br/&gt; 详细信息：&lt;s:property value=&#34;exceptionStack&#34;/&gt;&lt;br/&gt; # 转递方式 chain # action类之间转发 dispatcher # 转发到jsp freemarker httpheader redirect # 重定向到页面 redirectAction # action 类之间重定向 stream # 返回 InputStream流 velocity xslt plainText # Action类 注意 1.所有Action类都要继承ActionSupport类，否则execute方法返回的字符串不会回到struts拦截器再根据xml文件的配置进行转发 2.action类是非单例的。 # 所有多实例的对象全部是因为有私有属性，否则全部应该是单例的 3.action类放在栈的顶端，用于注入数据 传统方式得到request,response,servletContext,pageContext ServletActionContext.getPageContext() HttpServletRequest request = ServletActionContext.getRequest() ServletActionContext.getResponse() ServletActionContext.getServletContext(); 优势 实现与servlet的解耦 验证 验证分类 前台验证：javascript等 后台验证：服务器 struts2验证 后台验证 1.代码式验证 2.声明式验证:xml文件 ActionContext类 调用方法 ActionContext actionContext = ActionContext.getContext(); 得到内置对象 # 这几种得到作用域的方法均可以得到作用域中原有的值，也可以放入值 request actionContext.put(&#34;&#34;,&#34;&#34;); application Map&lt;String,Object&gt; applicationMap = actionContext.getApplication(); session Map&lt;String,Object&gt; sessionMap = actionContext.getSession(); # 或 actionContext.get(&#34;session&#34;)得到，因为actionContext中存储着大map parameters Map&lt;String,Object&gt; parametersMap = actionContext.getParameters(); valueStack ValueStack valueStack = actionContext.getValueStack() valueStack.getRoot() # 得到当前值栈的顺序 参数 1.action类中可以直接创建属性与其get方法得到客户端get方法或post表单请求的参数(由struts2自动注入) 2.action类中可以创建 JavaBean的属性来接收struts注入的参数，这时用户请求的参数名字要写成JavaBean名.JavaBean中的属性名（这样struts2会自动调用JavaBean的set方法来注入其中相应的参数 ） ## BaseAction 作用 权限管理 存放常驻内存数据 抽取常用的方法 # web.xml配置 &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.FilterDispatcher &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.action.extension&lt;/param-name&gt; &lt;param-value&gt;do&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/filter-mapping&gt; # 设置全局过滤器，并且修改过滤扩展名 # default.properties src/struts.properties配置文件 struts.custom.i18n.resources=struts # 使自己的普通配置生效。如：/org/apache/struts2/struts-messages.properties文件的 ## struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} &#34;{1}&#34; &#34;{2}&#34; {3} 属性，&#34;{1}&#34; &#34;{2}&#34; &#34;{3}&#34;是显示消息的占位符 ## struts.action.extension=action,,可以不配置 # 由于只加载properties文件，所以省略.properties ## =后面的是相对于src目录的文件 # ognl标签 注意 # jquery中不能定位ognl标签，而要用标签自己生成的id定位（看源码得到） 使用： &lt;%@ taglib uri=&#34;/struts-tags&#34; prefix=&#34;s&#34; %&gt; tld映射文件路径 struts2-core-2.3.1.1.jar包中 /META-INF/struts-tags.tld &#39;#&#39;出现的地方 o-&gt; 除ValueStack 之外的所有struts内置对象的取值前面都要加 o-&gt; 取JavaBean中的属性时要加 &#39;#&#39;，如&#34;#user.username&#34;,ValueStack中也不例外 o-&gt; 构造Map对象，Map：#{&#39;male&#39;:&#39;[男]&#39;,&#39;female&#39;:&#39;[女]&#39;}，构造radio和select标签，如 # &lt;s:radio list=&#34;#{&#39;male&#39;:&#39;aa&#39;,&#39;bb&#39;:&#39;cc&#39;}&#34; name=&#34;gender2&#34; /&gt; o-&gt; 迭代数组或list集合 集合的投影：userList.{username} 集合的过滤：userList.{?#this.age&gt;22} 主题与模板 主题：为多个模板提供风格 struts2-core-2.3.1.1.jar包中 template中的四个主题 archive # 其中是.vm文件，其它是.ftl文件。vm与ftl是两种视图技术 ajax # 除此之外其它都不支持ajax simple xhtml xhtml # 默认主题,default.properties配置文件中定义 css_xhtml simple 修改主题 1.struts.properties 中修改 struts.ui.theme=simple # 针对当前webapp 2.&lt;s:form theme=&#34;xhtml&#34;&gt; # 只针对当前表单 3.&lt;s:textfield name=&#34;username&#34; theme=&#34;simple&#34;&gt; # 修改某个标签的属性 模板：为标签提供样式 做模板的技术freemarker ognl标签的优点：自动排版、验证数据回显、国际化 所有标签： 逻辑标签 对 Map 集合的迭代： &lt;s:iterator value=&#34;#session.fileMap&#34; var=&#34;entry&#34; status=&#34;stat&#34;&gt; &lt;s:property value=&#34;#entry.key&#34;/&gt; &lt;s:if test=&#34;#stat.count%4==0&#34;&gt;&lt;/s:if&gt; &lt;/s:iterator&gt; 对 List 集合的迭代 List&lt;User&gt; userList 普通迭代 &lt;s:iterator var=&#34;user&#34; value=&#34;userList&#34;&gt; # 投影语法List&lt;user&gt;中的所有username &lt;s:property value=&#34;#user.username&#34;/&gt; 投影语法 &lt;s:iterator var=&#34;username&#34; value=&#34;userList.{username}&#34;&gt; &lt;s:property/&gt; # 这里不用写属性value=&#34;username&#34;就可以对page域中的username进行显示 过滤语法 &lt;s:iterator var=&#34;user&#34; value=&#34;userList.{?#this.age&gt;9}&#34;&gt; # this代表当前被迭代的元素 ?#是所有 ^#是第一个 $#是最后一个 ?#...[0]按标记取 &lt;s:property value=&#34;#user.username&#34; /&gt; 显示标签（UI标签） 普通字符串中使用ognl jsp中用%{} xml中用${} 例如 jsp中：&lt;s:textfield label=&#34;%{#attr.testValueStack}&#34;/&gt; xml中：&lt;param name=&#34;min&#34;&gt;4000&lt;/param&gt; &lt;message&gt;${min}&lt;/message&gt; 普通信息 &lt;s:text name=&#34;&#34;/&gt; 输出值 迭代器中 &lt;s:property/&gt; # 直接输出被迭代的内容（简单） &lt;s:property value=&#34;aa&#34;/&gt; &lt;s:property value=&#34;#aa&#34;/&gt; 普通 &lt;s:property value=&#34;username&#34;/&gt; # 输出标签,得到valueStack中属性 &lt;s:property value=&#34;#request.name&#34;/&gt; # 得到request域对象中的值 # request #session #application #parameters #attr # &#39;#attr&#39;优先级：page,request,valueStack,session,application 显示验证拦截器的验证信息集合中的数据： &lt;s:fielderror/&gt; # 显示所有错误信息 &lt;s:fielderror fieldName=&#34;&#34;/&gt; # 显示验证返回的错误信息 单选 &lt;s:radio list=&#34;#{&#39;male&#39;:&#39;男&#39;,&#39;female&#39;:&#39;女&#39;}&#34; name=&#34;gender2&#34; value=&#39;男&#39;&gt; # 自动加class id &lt;label for=&#34;gender2male&#34;&gt;等 # list键值对中male是实际值,男是显示值 # name是&lt;input radio &gt;的name属性 # value中是选中的项 多选 &lt;s:select multiple=&#34;true&#34; list=&#34;#{&#39;bj&#39;:&#39;北京&#39;,&#39;sh&#39;:&#39;上海&#39;,&#39;gz&#39;:&#39;广州&#39;}&#34; name=&#34;select1&#34; value=&#34;{&#39;sh&#39;,&#39;bj&#39;}&#34;/&gt; 表单 # 在ognl的标签中， struts的验证消息自动回显，不用加&lt;s:fielderror/&gt;标签 &lt;s:form action=&#34;&#34;&gt; # 默认中加上了 method=&#34;post&#34; action中加上了当前网站了contextPath路径 &lt;s:textfield label=&#34;用户名&#34; name=&#34;username&#34; /&gt; &lt;s:password label=&#34;密码&#34; name=&#34;password&#34; /&gt; &lt;s:submit value=&#34;登录&#34; /&gt; 国际化 # 国际化一般放在整个网站的最后写 ##　伪国际化：将不同语言的页面放在不同文件夹中分别访问 # 国际化是通过i18n拦截器实现的 1.创建国际化信息文件 message_zh_CH.properties # 基名_语言名_国家名.properties username=xxx password=xxxx submit=xx message_en_US.properties .. message.properties # 默认的显示语言 # 找伊拉克没有的话找本地区语言，本地语言没有的话找其它(默认的或美国等) 2.struts.properties中引入国际化配置的属性文件 struts.custom,i18n.resources=struts2/tag/i18n/message # 从src文件夹路径开始，只写基名 3.验证消息国际化 message.properties文件中配置属性validationRequiredUsername=用户名错误 validation.xml文件中 &lt;message key=&#34;validationRequiredUsername&#34;&gt;&lt;/message&gt; 4.jsp文件中用key属性代替 label属性(或其它在页面上显示信息的属性),key中写国际化信息文件中的key &lt;s:form action=&#34;taglogin&#34;&gt; &lt;s:textfield key=&#34;username&#34; name=&#34;username&#34; /&gt; &lt;s:password key=&#34;password&#34; name=&#34;password&#34; /&gt; &lt;s:submit key=&#34;submit&#34;/&gt; &lt;/s:form&gt; 5.普通信息的国际化 message.properties中配置属性 normalMessage:普通信息 jsp中&lt;s:text name=&#34;normalMessage&#34;/&gt; 6.测试 intername选项 -- 语言 改地区访问 xml文件中的ognl标签 o-&gt; ${aa} 1.调用转到该标签类的getAa()方法得到aa的值替换${aa} 2.本标签中name=&#34;aa&#34;的标签的文本节点的内容 o-&gt; {1}{2}{3}..{n} 匹配本标签中name=&#34;*a*&#34; 中的第n个‘*’,用于通配传递过来的参数的一部分的值 # ognl表达式 ognl 开源，java写的免费标签,是struts2特有的 xml文件中 ${Xxx} 取值栈中栈中的东西，如action类中的属性 ${#Xxx} 取值栈中值的东西，如request,session域中的数据（其实就是老师说的内置对象【valueStack就是值栈】） jsp文件中 &lt;s:iterator value=&#34;#session.fileMap&#34; var=&#34;entry&#34; status=&#34;stat&#34;&gt; &lt;s:property value=&#34;#entry.key&#34;/&gt; &lt;s:if test=&#34;#stat.count%4==0&#34;&gt;&lt;/s:if&gt; &lt;/s:iterator&gt; # strut.xml配置 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;!DOCTYPE struts PUBLIC &#34;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&#34; &#34;http://struts.apache.org/dtds/struts-2.0.dtd&#34;&gt; &lt;struts&gt; &lt;constant name=&#34;&#34; value=&#34;&#34;&gt;&lt;/constant&gt; &lt;include file=&#34;&#34;&gt;&lt;/include&gt; &lt;package name=&#34;&#34;&gt; &lt;interceptors&gt; &lt;interceptor name=&#34;&#34; class=&#34;&#34;&gt;&lt;/interceptor&gt; &lt;interceptor-stack name=&#34;&#34;&gt; &lt;interceptor-ref name=&#34;&#34;&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;default-interceptor-ref name=&#34;&#34;&gt;&lt;/default-interceptor-ref&gt; &lt;global-results&gt; &lt;result name=&#34;&#34;&gt;&lt;/result&gt; &lt;/global-results&gt; &lt;global-exception-mappings&gt; &lt;exception-mapping result=&#34;&#34; exception=&#34;&#34;/&gt; &lt;/global-exception-mappings&gt; &lt;action name=&#34;&#34;&gt; &lt;param name=&#34;&#34;&gt;&lt;/param&gt; &lt;result&gt;&lt;/result&gt; &lt;result name=&#34;input&#34;&gt;&lt;/result&gt; &lt;exception-mapping result=&#34;&#34; exception=&#34;&#34;/&gt; &lt;interceptor-ref name=&#34;&#34;&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 设置 &lt;constant name=&#34;struts.devMode&#34; value=&#34;true&#34;/&gt; # 开启debug模式 # debug模式，不用重启调试(添加新的方法要重启，方法中改代码不用重启) &lt;constant name=&#34;struts.i18n.encoding&#34; value=&#34;utf-8&#34;/&gt; # 配置struts的编码 &lt;constant name=&#34;struts.configuration.xml.reload&#34; value=&#34;true&#34;/&gt; # 配置本属性，可以使得改动struts配置文件不用重启应用服务器 &lt;constant name=&#34;struts.multipart.saveDir&#34; value=&#34;/upload&#34;/&gt; # 配置上传存储路径 &lt;constant name=&#34;struts.action.extension&#34; value=&#34;action,do&#34; /&gt; # 配置过滤路径 详细解释 o-&gt; 存放路径src/ o-&gt; 可以在struts-2.3.15.1的src\apps\blank\src\main\resources\struts.xml中参考配置文件 o-&gt; &lt;include file=&#34;struts2/cal/cal_struts.xml&#34;/&gt;标签包含其它路径的xml配置文件 #　被include的文件不能再include其它文件 o-&gt; &lt;constant name=&#34;struts.action.extension&#34; value=&#34;do,,&#34;&gt; 默认值 default.properties中配置了默扩展名：struts.action.extension=action,, # 配置匹配到框架处理的扩展名，空逗号代表匹配没有扩展名 o-&gt; &lt;package name=&#34;xxPackage&#34; extends=&#34;struts-default&#34; namespace=&#34;/xx/&#34;&gt; 默认值 namespace=&#34;/&#34; extends=&#34;struts-default&#34; # 不可省略 # name是包的唯一标识，不可以写路径 ## namespace 访问路径如/xx/a.do会匹配到该包执行其中的映射，按照域命名空间链的方式匹配，如： /xx/yy/a.do也会匹配到该包，但是它优先匹配到/xx/yy的命名空间 /a.do 不会匹配到该包 注意：匹配/sys/*的名称空间是/sys 而非 /sys/ ## struts的包有抽象包，普通包两种，通过继承可以加入包内容，相当于复制、粘贴 ## 继承的包是struts-default，其路径是/struts-default.xml ## ，它定义了核心的bean和拦截器 o-&gt; &lt;interceptors&gt; &lt;interceptor name=&#34;&#34; class=&#34;&#34;/&gt; &lt;interceptor-stack name=&#34;&#34;&gt; &lt;interceptor-ref name=&#34;/&#34;&gt; # 定义拦截器、定义拦截器栈（加入拦截器） ## 拦截器栈中可以加栈 o-&gt; &lt;default-interceptor-ref name=&#34;&#34;&gt; 默认拦截器（可以用于验证用户登录） o-&gt; &lt;global-results&gt; 全局结果（用来跳转全局异常等） o-&gt; &lt;global-exception-mappings&gt; 全局异常 o-&gt; &lt;action name=&#34;&#34; class=&#34;&#34; method=&#34;&#34;&gt; 默认值 class=&#34;com.opensymphony.xwork2.ActionSupport&#34; method=&#34;execute&#34; # name=&#34;aa&#34;时 .../aa.do的请求匹配到该方法执行 ## class 是类字节码路径，method是其中的方法名 o-&gt; &lt;param name=&#34;aaa&#34;&gt;bbb&lt;/param&gt; 调用 &lt;action&gt;标签中对象的实例的方法：setAaa(&#34;bbb&#34;); o-&gt; &lt;result name=&#34;&#34; type=&#34;&#34;&gt;/ok.jsp 默认值 name=&#34;success&#34; type=&#34;dispatcher&#34; # name=&#34;success&#34;时，映射的method返回&#34;success&#34;时进入该result处理 ## type是返回方式 ，如dispatcher redirect等 type的返回类型 dispatcher : 转发到jsp页面 redirect : 重定向到 jsp html 等页面 chain : Action 类之间的转发 redirectAction : Action 类之间的重定向 stream : 以 inputStream 的数据类型返回 stream的参数 # 可以从struts-default.xml文件中对应的stream参数对应的类的源码中查看其中的set方法找到要写参数的名称 &lt;param name=&#34;contentType&#34;&gt;image/pjpeg&lt;/param&gt; # 下载文件的类型 另外如text/html; charset=utf-8返回给ajax异步数据 &lt;param name=&#34;bufferSize&#34;&gt;2048&lt;/param&gt; # 缓冲byte[]的大小，单位字节 &lt;param name=&#34;contentDisposition&#34;&gt;attachment;filename=${uuidFileName}&lt;/param&gt; # 设置下载响应头，只的下载时才设置。${uuidFileName}是一个OGNL表达式 &lt;param name=&#34;inputName&#34;&gt;imageStream&lt;/param&gt; # 框架调用传递给result标签结果字符串的对象中的getImageStream()方法，来获取InputStream流对象 # 返回stream类型不指定返回的路径 ## 标签间的内容：/ok.jsp 是响应的路径 o-&gt; &lt;result name=&#34;input&#34; type=&#34;&#34;&gt;/ok.jsp type中的参数 # 可以从struts-default.xml配置文件中查到 dispatcher # 转发 redirect # 重定向 chain # Action类之间转发，需要加参数，参数的名字 ## ：struts-default.xml文件中找到&#34;chain&#34;对应的类，按快捷键ctrl &#43; shift &#43; T 关联类的源码文件，查找set方法改名即可 &lt;param name=&#34;actionName&#34;&gt;to&lt;/param&gt; # action标签的 name属性值 &lt;param name=&#34;namespace&#34;&gt;/&lt;/param&gt; # action的名称空间 redirectAction # Action类之间重定向 # 各种拦截器不通过时默认的返回input，同时向request作用域中加入了相关错误信息供struts2的jsp标签进行显示 ## 处理 返回值是input的返回信息跳转，就是处理拦截器拦截后的信息跳转 o-&gt; &lt;exception-mapping result=&#34;nullJsp&#34; exception=&#34;java.lang.NullPointerException&#34; /&gt; # &lt;action&gt;标签中的局部异常 ## &lt;action&gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&#34;nullJsp&#34;的字符串交给本&lt;action&gt;标签中相应的&lt;result&gt;标签来处理 o-&gt; &lt;interceptor-ref name=&#34;loginInterceptor&#34;/&gt; 默认值 name=&#34;defaultStack&#34; # 指定在本&lt;action&gt;标签中使用的拦截器或拦截器栈 ## 当指定了拦截器或拦截器栈以后，默认的defaultStack将会没有,此时defaultStack中的18个拦截器将不再执行 使用：OGNL对象图导航语言对标签中的路径进行动态设置 # 验证 struts2验证 1.代码式: validate(),validateXxx()方法 # 单个验证与全部验证都存在时先单个验证，再全部验证，验证信息都加入验证信息集合 2.声明式: Action类名-validation.xml Action类名-&lt;action标签的name属性&gt;-validation.xml # 单个验证与全部验证都存在时先全部验证，再单个验证，验证信息都加入验证信息集合 # 先声明验证，后代码验证 参数驱动 1.属性驱动: action中用属性收集表单参数 2.模型驱动: javaBean收集参数 代码式（属性驱动）： 步骤 1.需要验证的Action类 继承 ActionSupport 类 # ActionSupport 类 实现了Validateable接口，该接口是验证接口 2.写验证方法 1&gt; public void validate() # 方法重写（通用验证方法，本类中的所有其它方法执行前都执行） 2&gt; public void validateXxxMethod() # 或者自定义专用验证方法 xxxMethod为要验证的方法名，首字母要大写 # 注意，通用、专用验证方法同时存在时，先执行专用验证方法，再执行通用验证方法 ## ，但是通用验证方法的错误消息无法加入到返回的错误集合中 3&gt; this.addFieldError(&#34;password&#34;,&#34;密码必填&#34;); # 验证方法中添加错误信息到错误信息集合 ## addFieldError(&#34;&#34;,&#34;&#34;)是从ActionSupport父类中继承的方法 3.jsp文件中通过验证标签： &lt;%@ taglib uri=&#34;/struts-tags&#34; prefix=&#34;s&#34;%&gt; &lt;s:fielderror/&gt; # 显示所有错误信息 &lt;s:fielderror fieldName=&#34;password&#34;/&gt; 显示验证出错信息 4.xml配置 &lt;!-- 验证错误信息处理 --&gt; &lt;result name=&#34;input&#34; type=&#34;dispatcher&#34;&gt; /error.jsp &lt;/result&gt; # 写在需要验证的方法对应的标签中，验证错误时验证方法会优先返回&#34;input&#34;字符串 声明式（属性驱动）： 1.验证Action类继承ActionSupport 2.验证Action类目录下配置文件 Action类名-validation.xml Action类名-&lt;action标签的name属性&gt;-validation.xml # 放入此名字的配置文件就相当于加了验证，不需要做其它事情 ## ，相当于分别向Actioin类中加入了validate()validateXxx()方法进行了相应验证 文件内容 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;!DOCTYPE validators PUBLIC &#34;-//Apache Struts//XWork Validator 1.0.3//EN&#34; &#34;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&#34;&gt; &lt;validators&gt; &lt;field name=&#34;username&#34;&gt; # 要验证的属性 &lt;field-validator type=&#34;requiredstring&#34;&gt; &lt;message&gt;用户名必填&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;field-validator type=&#34;regex&#34;&gt; &lt;param name=&#34;expression&#34;&gt;^[\u3447-\uFA29]&#43;$&lt;/param&gt; &lt;message&gt;UserAction2-validation==&gt;必须写中文&lt;/message&gt; &lt;/field-validator&gt; &lt;/validators&gt; # xml文件的头在 xwork-core-2.3.1.1.jar包的 xwork-validator-1.0.3.dtd中复制 ## 关联约束在 \struts-2.3.15.1\src\xwork-core\src\main\resources\xwork-validator-1.0.3.dtd文件 ## &lt;field-validator type=&#34;&#34;&gt;的约束类型在xwork-core-2.3.1.1.jar包的 /com/opensymphony/xwork2/validator/validators/default.xml文件中 # 16个规则 ## type=&#34;regex&#34;相当于调用了default.xml文件中配置的 ## RegexFieldValidator类的 setExpression方法 3.jsp文件中通过验证标签（同上） 4.xml配置（同上） # 出错信息 1.验证文件名写错，无提示，不验证 2.&lt;field-validator type=&#34;&#34;&gt;写错，有明显提示 2.&lt;field name=&#34;salaryy&#34;&gt;写错，获取的salaryy为空。 声明式（模型驱动） 1.创建bean对象，bean对象中封装属性 2.验证Action类继承ActionSupport类，声明bean对象实例 3.action类同目录 中 ：Action类名-&lt;action标签的name属性&gt;-validation.xml # &lt;field-validator type=&#34;visitor&#34;&gt; # bean类同目录中：bean类名-validation.xml配置验证文件 4.jsp文件请求参数改为：action类中bean对象名.bean对象封装的属性名。用&lt;s:fielderror/&gt;标签得到返回的错误信息 5.xml配置（同上） 原理 StrutsPreparedAndExecuteFilter 1.注入参数 setUsername() setPassword() 2.验证方法：validate()或validateXxx() 验证配置文件中验证：Action类名-validation.xml 3.转发：根据验证成功或失败返回消息 验证集合无错误消息成功Action --&gt; execute或同签名的方法 验证集合有错误消息失败&lt;result name = &#34;input&#34; type=&#34;dispatcher&#34; register.jsp/login.jsp # 过滤器 StrutsPrepareAndExecuteFilter 中查看Dispathcer类，从中找到配置struts-default.xml,struts-plugin.xml,struts.xml值的属性DEFAULT_CONFIGURATION_PATHS 查找引用该属性的方法为init_TraditionalXmlConfigurations 查看引用该方法的方法为init 回头看StrutsPrepareAndExecuteFilter中初始化dispatcher对象的方法initDispatcher 其中调用了dispatcher.init();方法来配置dispatcher 由此可以知道struts在启动时加载了struts-default.xml,struts-plugin.xml,struts.xml配置文件 # 拦截器 struts-core-2.3.1.1.jar包中的 struts-default.xml文件中 定义了32个interceptor（拦截器） i18n # 国际化 token # 表单重复提交 validation # 验证 params # 参数拦截器,向Action类中注入参数 cookie interceptor-tack # 拦截栈 # 拦截栈中的拦截器的先后顺序有影响 basicStack defaultStack # 每个http请求都会经过该拦截栈 ## 其中的18个拦截器, &lt;default-interceptor-ref&gt;中定义 原理 拦截器仿照过滤器建立，内部实现原理是完全相同的 执行流程 拦截器构构造函数 -&gt; action构造函数 -&gt; 拦截器1 in -&gt; 拦截器2 in -&gt; demo -&gt; 拦截器2 out -&gt; 拦截器1 out exception拦截器最先进，最后出 自定义拦截器 1.定义Action类，继承Interceptor接口，重写生命周期方法 public LoginInterceptor() { } public void destroy() { } public void init() { } public String intercept(ActionInvocation invocation) { } 2.配置struts.xml文件 1&gt; 定义拦截器、拦截器栈 &lt;interceptors&gt; &lt;interceptor name=&#34;loginInterceptor&#34; class=&#34;interceptor.LoginInterceptor&#34;/&gt; &lt;interceptor name=&#34;roleInterceptor&#34; class=&#34;interceptor.RoleInterceptor&#34;/&gt; &lt;interceptor-stack name=&#34;crmStack&#34;&gt; &lt;interceptor-ref name=&#34;loginInterceptor&#34;&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=&#34;roleInterceptor&#34;&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; 2&gt; &lt;action&gt;标签中声明用到的拦截器或拦截器栈 &lt;interceptor-ref name=&#34;loginInterceptor&#34; /&gt; # 此时默认的defaultStack拦截器栈会被替代掉 自定义方法过滤拦截器 # MethodFilterInterceptor继承AbstractInterceptor继承Interceptor，前两个是struts自己实现的自己的包装类 ## 原理：自己实现intercept方法，实现对方法名的过滤。如果符合通过条件，则执行自己的doIntercept方法。所以要求用户重写doIntercept方法实现业务逻辑 &lt;interceptor name=&#34;aloginInterceptor&#34; class=&#34;cn.it.shop.interceptor.AloginInterceptor&#34;&gt; &lt;param name=&#34;excludeMethods&#34;&gt;*$&lt;/param&gt; # 除了*$匹配的方法都执行此拦截器 ## includeMethods为包含匹配的方法执行拦截器 &lt;/interceptor&gt; 生命周期 部署时初始化，每次符合&lt;action&gt;的请求时，执行拦截器 拦截器Action 类 o-&gt; 继承Interceptor 接口 o-&gt; 重写生命周期方法 String intercept(ActionInvocation invocation)方法中调用 invocation.invoke() 放行 invocation.getAction()得到当前的Action类 invocation.getStack()得到值栈中的栈 # invocation用于调试18个拦截器 具体拦截器 struts-default.xml 文件中定义了32种拦截器 alias autowiring chain conversionError cookie clearSession createSession debugging execAndWait exception fileUpload # 只用来验证已经注入的文件是否合格，合格则通过，不合格则不执行action类中对应请求的方法 i18n logger modelDriven # 用于检查action类是否实现ModelDriven&lt;T&gt;接口，然后调用getModel()方法注入得到的对象到栈的项端。 scopedModelDriven params # 注入参数用，包括注入文件（级联注入文件的ContentType与FileName） actionMappingParams prepare staticParams scope servletConfig # 向自定义的实现RequestAware等接口的Action类（一般是BaseAction类）中注入request等相应的map对象 timer token # 防止重复提交 tokenSession validation # 验证 workflow store checkbox profiling roles annotationWorkflow multiselect 数据传递 o-&gt; 拦截器不会向其它拦截器中注入参数，所以自定义拦截器中了参数要从request中获取 o-&gt; 如果想 显式的引用了自己的拦截栈，默认的拦截栈就不引用了，要自己引用，其中的注入参数拦截器向action类中注入参数 技巧 &lt;interceptor-stack name=&#34;defaultStack&#34;&gt; # 对defaultStack进行替换，在它前面添加自定义的拦截器 &lt;interceptor-ref name=&#34;aloginInterceptor&#34;/&gt; &lt;interceptor-ref name=&#34;defaultStack&#34;/&gt; 拦截器中的ActionInvocation对象 可以得到ActionContext # 文件处理 ## 上传 struts2文件上传步骤 1.编写jsp文件 1&gt; post方式提交 2&gt; &lt;input type=&#34;file&#34; name=&#34;file1&#34;/&gt; 要添加name属性 3&gt; post表单上传的编码方式是enctype=&#34;multipart/formdata&#34; 2.创建Action类，不必继承任何类(但是如果不继承ActionSupport类的话，拦截器将不会返回提示消息) 1&gt; 定义参数 # 如果不接收上传文件名字符串数组而从文件对象中获取文件名的话，得到的文件名将会是乱码 private File[] image; # 字段名 private String[] imageContentType; # 文件类型 private String[] imageFileName; # 文件名 private String uploadPath; # 前三个参数可以不是数组，在 struts-default.xml配置文件fileUpload拦截器对应的源码中可以找到定义规则： &lt;li&gt;[File Name] : File - the actual File&lt;/li&gt; &lt;p/&gt; &lt;li&gt;[FileName]ContentType : String - the content type of the file&lt;/li&gt; &lt;p/&gt;&lt;li&gt;[File Name]FileName : String - the actual name of the file uploaded(not the HTML name)&lt;/li&gt; # uploadPath是我们自定义的配置文件中注入过来的文件存储位置 2&gt; 写execute方法保存文件到路径，返回成功消息 3.Action类的配置文件，include到src/struts.xml文件中 1&gt; &lt;action&gt;标签中配置name=&#34;input&#34;的标签&lt;result&gt;来返回出错消息 2&gt; &lt;action&gt;标签中用param标签注入文件存储路径：uploadPath 底层执行setUploadPath()方法 3&gt; &lt;action&gt;标签中通过&lt;interceptor-ref name=&#34;fileUpload&#34;&gt;标签对上传文件进行参数上的限定 1&gt; &lt;param name=&#34;maximumSize&#34;&gt; 单个文件的最大尺寸(字节) 2&gt; &lt;param name=&#34;allowedExtensions&#34;&gt; 文件扩展名 3&gt; &lt;param name=&#34;allowedTypes&#34;&gt; 文件实际类型，如image/jpeg，可从tomcat配置文件web.xml中查找 4.配置返回消息的信息 ：src/struts.properties文件中 struts.custom.i18n.resources=struts # 解锁自/org/apache/struts2/default.properties总配置文件 # 加载自己，=后面是参照src/目录的相对路径 ，省略掉.properties扩展名 struts.multipart.maxSize=2097152 # 解锁自/org/apache/struts2/default.properties总配置文件 # 设置上传文件总量的大小 struts.messages.error.file.too.large=\u6587\u4EF6\u592A\u5927\: {0} &#34;{1}&#34; &#34;{2}&#34; {3} struts.messages.error.content.type.not.allowed=\u6587\u4EF6\u7C7B\u578B\u4E0D\u6B63\u786E\: {0} &#34;{1}&#34; &#34;{2}&#34; {3} struts.messages.error.file.extension.not.allowed=\u6269\u5C55\u540D\u4E0D\u6B63\u786E\: {0} &#34;{1}&#34; &#34;{2}&#34; {3} # 覆盖/org/apache/struts2/default.properties总配置文件的响应消息,=后面是中文的unicode编码的iso8859-1的表示形式，通过视图可以直接配置，也可以用java/bin目录下的native2ascii.exe工具进行转码 多文件上传 出现有多个文件共同上传时，文件拦截器会出现一错全错的情况，这时我们利用struts的一个 小bug---文件拦截不成功也调用action类的setXxx方法传入文件，从set函数中对文件进行筛选和转存 这时文件拦截器已经形同虚设，一点作用也不起了。 原理过程 1.上传请求经过struts2的过滤器匹配扩展名 2.按src/struts.xml文件中声明的配置包映射的名称空间映射到配置包 3.根据action标签的name属性匹配名称空间与扩展名之间的“文件名”,映射到该action标签 1&gt; 经过多层拦截器 2&gt; 用param标签注入文件存储路径 3&gt; 通过&lt;interceptor-ref name=&#34;fileUpload&#34;&gt;标签对上传文件进行参数上的限定 2&gt; 执行action标签对应类的方法，该方法返回的返回的字符串进行响应 默认配置 1.defaultStack拦截栈中的fileUpload拦截器进行处理 2.default.properties配置文件中 对multipart的上传方式进行了配置 struts.multipart.parser=jakarta # struts使用了第三方的jakerta来给上传文件解码 struts.multipart.saveDir= # 缓存文件的临时目录，不填默认是 ## work/catalina/localhost/web工程名/upload_.....00000..tmp struts.multipart.maxSize=2097152 # 默认支持的上传文件的大小 (字节，2m)，是总大小 3.多数服务器自己删除缓存文件 ## 下载 用传递类型为stream 来返回要下载的文件 写法 &lt;result name=&#34;success&#34; type=&#34;stream&#34;&gt; &lt;!-- 下载文件的类型 --&gt; &lt;param name=&#34;contentType&#34;&gt;image/pjpeg&lt;/param&gt; &lt;!-- byte[]的大小，单位字节 --&gt; &lt;param name=&#34;bufferSize&#34;&gt;2048&lt;/param&gt; &lt;!-- 设置下载响应头，${uuidFileName}是一个OGNL表达式，不是EL表达式 --&gt; &lt;param name=&#34;contentDisposition&#34;&gt;attachment;filename=${uuidFileName}&lt;/param&gt; &lt;!-- 框架调用getXxx()方法，来获取InputStream流对象 --&gt; &lt;param name=&#34;inputName&#34;&gt;imageStream&lt;/param&gt; &lt;/result&gt; # 与其它同样，要注入的参数从stream类型对应的类中可以进行查看 显示与下载的编码问题 o-&gt; 设置tomcat/conf/server.xml &lt;Connector port=&#34;8080&#34; .. URIEncoding=&#34;utf-8&#34;/&gt; o-&gt; 提交下载请求用post方式，struts框架自动给post请求编码解码 数据 # 日志 # scribe facebook出品 特点 支持nfs存储 结构 scribe agent 向scribe发送数据 scribe 接收数据，不同topic 的数据发送给不同的store中 存储系统(store) file, buffer, network, bucket, null, thriftfile, multi chukwa # apache出品，hadoop系列产品 flume cloudera出品 特点 可靠性(节点故障时，日志传送到其他节点) 三种级别 end-to-end 发送前写磁盘，成功时删除 store on failure 失败返回时写磁盘 best effort 不确认数据是否成功 可扩展性 agent collector storage三层架构，每层可扩展。 agent: 将数据源数据发送给collector collector: 将多个agent数据汇总后, 加载到storage中 storge: 存储系统, 可以是file, hdfs, hive, hbase等 agent collector 由master统一 logstash # 分布式日志收集，需结合kafka 爬虫 # cheerio # node解析html，如jquery scrapy-redis # python 分布式爬虫框架 phantomjs # js浏览器模拟框架 分析 # pandas # python数据分析 计算 # druid # apache 特点 分布式, 扩展性强 高可用，可回滚 内存, 时序数据库 亚秒级OLAP, 实时分析 多租户 spark stream hadoop 搜索 # 分类 垂直搜索引擎 针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。 通用搜索引擎 通过关键字的方式实现的，是语义上的搜索，返回的结果倾向于知识成果，比如文章，论文，新闻等 通用搜索引擎的信息量大、查询不准确、深度不够 通用搜索引擎的海量信息无序化 部分 １.索引 ２.分词 ３.搜索 compass # 基于lucene nutch # 基于lucene sunspot # 基于Rsolr，以dsl结构用ruby调solr sphinx # 基于sql的全文检索引擎 lucene # # 原理 block k-d tree 倒排索引 词典 排序数组 # 为了二分查找 # 实现简单，性能差 哈希表 # 性能好，占内存大 跳跃表 # 内存小且可调节, 模糊查询不好 B/B&#43;树 # 磁盘索引 ，更新方便，检索慢 trie树 # 效率与字符串长度有关，只适合做英文词典 dat # 可做中文词典，内存占用小 fst # 共享前缀，内存占用小，要求输入有序，不易更新 内存存前缀索引、磁盘存后缀词块 倒排表 正向文件 # 行式存储，原始文档 doc-values # 列式存储，文档号到值的映射 文件指纹 # 概念 index # 一个倒排表，对应一个目录 segment # index的存储单元，包含多个文档 document # 创建单位 field # 文档里的键值对 term # 分词后的字符串 analyzer tokenizer # 切分文本到索引单元 tokenfilter # 对token预处理 # 常识 特性 索引 高亮 命中率排序 分词 与数据库的区别：数据库注重存储、全文检索注重查询 其它搜索：多媒体搜索 索引库(文件夹 或 内存中)： 只存储了商品的基本信息 索引库与数据库定时同步 索引库 -&gt; document -&gt; field # field是键值对,值只能存数据 同步 IndexWriter:addDocumnet(),delteDocument(),updateDocument() 查询 IndexSearch:search(),get() Field的内部结构 # 不存不索引会报错 Store:控制此Field字段是否存储到索引库中 Index:是否建立索引（索引不区分大小写,过滤词不创建索引） NO:不建立索引，可以通过field的key查到，但是不能通过关键字查询到 NOT_ANALYZED:建立索引，但是不分词 ANALYZEd:建立索引又分词 # 使用到的对象 Directory Analyzer TokenStream tokenStream = analyzer.tokenStream(&#34;eldName&#34;,new StringReader(&#34;测试字符串&#34;)) while(tokenStream.incrementToken()){ TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class); System.out.println(termAttribute.term()); } # 使用分词器测试分词 Document add(Field) document = indexSearcher.doc(ScoreDoc) get(String) # 通过key查找value IndexWriter IndexWriter(directory,analyzer,MaxFieldLength.LIMITED); # LIMITED限定Field的数量(源码中规定默认值) addDocument(Document) commit() close() # 自带commit() rollback() IndexSearcher QueryParser QueryParser(Version.LUCENE_30,&#34;name&#34;,analyzer) Query query = parser.parse(用户传递的字符串); query = parser.parseMultiField(String [], 用户传递的字符串); TopDocs topDocs = indexSearcher.search(query, 10); # 10是期望的结果数 ## 最终查询到的结果数是：期望结果数与实际结果数的最小值 totalHits # 命中的结果数 ScoreDoc ScoreDoc [] scoreDocs = topDocs.scoreDocs; scoreDoc.score # 命中率积分 scoreDoc.doc # 命中文档编号，该编号由lucene自动生成 Term # 索引项 Term(&#34;field中的key&#34;,&#34;field中value解析出的关键字&#34;) # 索引的结构 Term(&#34;key&#34;,&#34;value&#34;)[0,3,4] # key 为对应的field中的&#34;key&#34;,value对应的是解析field的&#34;value&#34;出的关键字 ## []中的内容为匹配的文档编号，该编号为系统自动生成的 # 注意 lucene创建索引时field的key都可以重复，没有主键方面的限制。但是实际应用时要求我们为document有唯一的标识“主键”field,便于对每个document进行更新与删除 # 使用 包：IKAnalyzer,lucence-analyzer(英文分词，不需要),memory,core,highlighter 工具：lukeAll 用来查看索引库 添加、查询、删除、修改 抽取配置类（构造方法私有化） Configuration 维护了directory与analyzer DocumentUtil goodsToDocument(Goods) documentToGoods(Document) LuceneUtil 维护了indexWriter与indexSearcher 注意 1.indexWriter在static代码块中初始化 2.getIndexWriter LuceneService 用indexWriter与indexSearcher处理业务逻辑 添加 indexWriter.addDocument(Document) indexWriter.rollback() 删除 indexWriter.deleteDocument(Term) indexWriter.optimize() # 删除document的时候同步索引库，没有设置的话只是删除document，但是索引中还是可以查到 更新 indexWriter.updateDocument(Term,Document) indexWriter.optimize() # 更新是先删除再添加（所以如果updateDocument(Term,Document)中匹配多个Document时，会出现删除了多个Document,而添加了一个Document的情况） 查询 QueryParser parser = new QueryParser(Version.LUCENE_30, &#34;field中的key&#34;, analyzer); Query query = IKQueryParser.parseMultiField(new String[]{&#34;name&#34;,&#34;remark&#34;}, &#34;ee&#34;); # 多字段查询，IKAnalyzer特有 #　多字段查询到的第二个字段的结果，在转换高管时（调用getBestFragment时）只会对该方法指定的一个字段进行匹配，如果该字段不匹配时（但是第二个字段匹配），则会返回空。 ## 针对这一个bug,在getBestFragment处理匹配的结果返回空时，不使用空而直接返回没有高亮的字符串即可。 parser.parse(用户传递的字符串); TopDocs topDocs = indexSearcher.search(query, 3); # 3是期望结果数 ScoreDoc [] scoreDocs = topDocs.scoreDocs; Document document = indexSearcher.doc(scoreDoc.doc); scoreDoc.doc得到文档编号 分页查询： 传递当前页码与一页记录数 利用topDocs.totalHits得到总记录数 查询本页与前面所有页的期望数据量，然后只截取本页的文档编号，得到document并返回数据 # 分词器 IKAnalyzer 配置文件 src/IKAnalyzer.cfg.xml中配置 &lt;properties&gt; &lt;entry key=&#34;ext_dict&#34;&gt;/mydict.dic&lt;/entry&gt; # 配置自己的字典（不分词） &lt;entry key=&#34;ext_stopwords&#34;&gt;/ext_stopword.dic&lt;/entry&gt; # 配置跳过的字 &lt;/properties&gt; Query query = IKQueryParser.parse(&#34;name&#34;,name); # IKAnalyzer特有 # 排序 Directory directory = FSDirectory.open(new File(&#34;d:/lucene&#34;)); IndexSearcher indexSearcher = new IndexSearcher(directory); Query query = IKQueryParser.parse(&#34;name&#34;,&#34;cc&#34;); Sort sort = new Sort(new SortField(&#34;id&#34;, SortField.INT,true)); # 这里可以排序多个字段 # 参数1：&#34;id&#34;是排序的field字段,参数2：是字段内容的类型,参数3 true代表降序排列 ## 此时命中率不再计算（因为不按命中率排序） ## 排序的field必须建立索引 indexSearcher.search(query, null,10,sort); 高亮 导入包:highlight与memory Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(&#34;&lt;font color=&#39;red&#39;&#34;,&#34;&lt;/font&gt;&#34;),new QueryScorer(query)); highlighter.setTextFragmenter(new SimpleFragmenter(10)); # 限制字符长度 .. String result = highlighter.getBastFragment(analyzer,&#34;name&#34;,doc.get(&#34;name&#34;)); # 返回高亮处理字符串 ## 参数1：解析用户输入词的分词器,参数2：是要查询的field的key(没有用)，参数3：field的value solr # 介绍 基于lucene 搜索服务器，http请求提交和返回xml 功能 丰富了查询语言 实现可配置、可扩展 优化了性能 提供了管理界面 缓存功能 垂直搜索 高亮 data schema定义字段 elasticsearch # 介绍 基于lucene 性能 第一次查秒级响应(5-10秒)，放到文件系统缓存(filesystem cache) 再查命令缓存毫秒级响应 # 热点数据要预热 文件系统缓存(内存中分配)和数据量同样大，才有效率 # 冷热分离 分页，会查前面所有数据 # 用scroll api, 快照 &#43; 游标 权限 # shiro # 功能 认证 授权 加密 会话管理 Web集成 缓存 组件 Subject # 当前用户,绑定到SecurityManager SecurityManager # 门面模式，管理组件 Realms # 连接认证数据(用户、角色、权限) Authenticator # 认证principals和credentials Authorizer # 校验权限 SessionManager # 异构客户端 控制方式 url 注解 代码 页面标签 模块 Authenticator # SecurityManager继承Authenticator public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException; permission 概念 subject resource permission role 隐式角色 显示角色 配置 shiro.ini [users] zhang=123, role1, role2 # 用户名=密码, 角色1, 角色2 判断角色 o-&gt; subject.hasRole(&#34;admin&#34;); o-&gt; @RequiresRoles(&#34;admin&#34;) @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND) # 表示当前Subject需要角色admin和user。 o-&gt; &lt;shiro:hasRole name=&#34;admin&#34;&gt;&lt;/shiro:hasRole&gt; 权限注解 @RequiresAuthentication # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。 @RequiresUser # 表示当前Subject已经身份验证或者通过记住我登录的。 @RequiresGuest # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。 @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR) # 表示当前Subject需要权限user:a或user:b。 credential 散列 String str = &#34;hello&#34;; String salt = &#34;123&#34;; //内部使用MessageDigest String simpleHash 密码生成工具 //输入明文密码得到密文密码 String encryptPassword(Object plaintextPassword) throws IllegalArgumentException; //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密） boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info); filter NameableFilter ＃根据名字找到相应的拦截器实例 OncePerRequestFilter # 控制开启、关闭拦截器实例 ShiroFilter # 安全控制 AdviceFilter # aop preHandle # 前置增强 postHandle # 后置增强 afterCompletion # 后置最终增强(异常也执行，相当于finally的概念) PathMatchingFilter # 匹配请求路径 AccessControlFilter # 允许或拒绝访问，拒绝时如何处理 jsp标签 &lt;%@taglib prefix=&#34;shiro&#34; uri=&#34;http://shiro.apache.org/tags&#34; %&gt; &lt;shiro:guest&gt; 欢迎游客访问，&lt;a href=&#34;${pageContext.request.contextPath}/login.jsp&#34;&gt;登录&lt;/a&gt; &lt;/shiro:guest&gt; &lt;shiro:user&gt; 欢迎[&lt;shiro:principal/&gt;]登录，&lt;a href=&#34;${pageContext.request.contextPath}/logout&#34;&gt;退出&lt;/a&gt; &lt;/shiro:user&gt; # 用户已经身份验证/记住我登录后显示相应的信息。 &lt;shiro:authenticated&gt; 用户[&lt;shiro:principal/&gt;]已身份验证通过 &lt;/shiro:authenticated&gt; # 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。 &lt;shiro:notAuthenticated&gt; 未身份验证（包括记住我） &lt;/shiro:notAuthenticated&gt; # 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证。 &lt;shiro: principal/&gt; # 显示用户身份信息，默认调用Subject.getPrincipal()获取 &lt;shiro:principal type=&#34;java.lang.String&#34;/&gt; &lt;shiro:principal property=&#34;username&#34;/&gt; &lt;shiro:hasRole name=&#34;admin&#34;&gt; 用户[&lt;shiro:principal/&gt;]拥有角色admin&lt;br/&gt; &lt;/shiro:hasRole&gt; &lt;shiro:hasAnyRoles name=&#34;admin,user&#34;&gt; 用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt; &lt;/shiro:hasAnyRoles&gt; &lt;shiro:lacksRole name=&#34;abc&#34;&gt; 用户[&lt;shiro:principal/&gt;]没有角色abc&lt;br/&gt; &lt;/shiro:lacksRole&gt; # 如果当前Subject没有角色将显示body体内容。 &lt;shiro:hasPermission name=&#34;user:create&#34;&gt; 用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt; &lt;/shiro:hasPermission&gt; &lt;shiro:lacksPermission name=&#34;org:create&#34;&gt; 用户[&lt;shiro:principal/&gt;]没有权限org:create&lt;br/&gt; &lt;/shiro:lacksPermission&gt; session 得到会话 login(&#34;classpath:shiro.ini&#34;, &#34;zhang&#34;, &#34;123&#34;); Subject subject = SecurityUtils.getSubject(); Session session = subject.getSession(); api Session getId() getHost() # 调用HostAuthenticationToken.getHost(), 得到主机地址 getTimeout() setTimeout(1000) getStartTimestamp() setLastAccessTime() touch() # 更新会话最后访问时间 stop() # 销毁会话, Subject.logout()与HttpSession.invalidate()会自动调用该api setAttribute(&#34;key&#34;, &#34;123&#34;) getAttribute(&#34;key&#34;) removeAttribute(&#34;key&#34;) SecurityManager Session start(SessionContext context) Session getSession(SessionKey key) throws SessionException WebSessionManager boolean isServletContainerSessions(); # 是否使用Servlet容器的会话 ValidatingSessionManager void validateSessions(); # 验证所有会话是否过期 cache 接口 Cach&lt;K, V&gt; CacheManager CacheManagerAware ini配置 userRealm.cachingEnabled # 启用缓存，默认false userRealm.authenticationCachingEnabled # 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false userRealm.authenticationCacheName # 缓存AuthenticationInfo信息的缓存名称 userRealm. authorizationCachingEnabled # 启用授权缓存，即缓存AuthorizationInfo信息，默认false userRealm. authorizationCacheName # 缓存AuthorizationInfo信息的缓存名称 securityManager.realms=$userRealm cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml securityManager.cacheManager=$cacheManager sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager securityManager.sessionManager=$sessionManager rememberme ssl o-&gt; keytool -genkey -keystore &#34;D:\localhost.keystore&#34; -alias localhost -keyalg RSA # jdk自带的生成证书工具(包含证书/公钥/私钥） o-&gt; 设置tomcat server.xml &lt;Connector port=&#34;8443&#34; protocol=&#34;HTTP/1.1&#34; SSLEnabled=&#34;true&#34; maxThreads=&#34;150&#34; scheme=&#34;https&#34; secure=&#34;true&#34; clientAuth=&#34;false&#34; sslProtocol=&#34;TLS&#34; keystoreFile=&#34;D:\localhost.keystore&#34; keystorePass=&#34;123456&#34;/&gt; o-&gt; jasig cas api Subject: 主体, 如用户 SecurityManager: 安全管理器, 管理subject Realm: 权限数据域 授权 对象流程 Subject.isPermitted -&gt; SecurityManager -&gt; Authorizer 对象 ModularRealmAuthorizer # 多realm授权 PermissionResolver # 解析权限字符串到Permission实例 RolePermissionResolver # 从角色得到权限集合 配置 参数 filterChainDefinitions rest：比如/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user：method] ,其中method为post，get，delete等。 port：比如/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal：//serverName：8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。 perms：比如/admins/user/**=perms[user：add：*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，比如/admins/user/**=perms[&#34;user：add：*,user：modify：*&#34;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。 roles：比如/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，比如/admins/user/**=roles[&#34;admin,guest&#34;],每个参数通过才算通过，相当于hasAllRoles()方法。 anon：比如/admins/**=anon 没有参数，表示可以匿名使用。 authc：比如/admins/user/**=authc表示需要认证才能使用，没有参数 authcBasic：比如/admins/user/**=authcBasic没有参数表示httpBasic认证 ssl：比如/admins/user/**=ssl没有参数，表示安全的url请求，协议为https user：比如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查 # remember me可登录 分布式 # redisson # 介绍 使用redis外部存储，实现分布式功能">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
<title>小功能 | ukeate的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://ukeate.com/docs/middleware/library/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.9c0ada5eb908c1277caca665a80faefc6f92c8415f2bcc0dc34ec2b4a7732607.js" integrity="sha256-nAraXrkIwSd8rKZlqA&#43;u/G&#43;SyEFfK8wNw07CtKdzJgc=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="https://ukeate.com/docs/middleware/library/index.xml" title="ukeate的笔记" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span>ukeate的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>







  
<ul>
  
  <li>
    <a href="/posts/"  >
        Blog
      </a>
  </li>
  
</ul>










  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/" class="">程序语言</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/principle/" class="">程序语言原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/haskell/" class="">Haskell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/elixir/" class="">Elixir</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/clojure/" class="">Clojure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/js/" class="">JS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/java_reactive/" class="">Java响应式编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/javaweb/" class="">JavaWeb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/juc/" class="">Java并发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/jvm/" class="">JVM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/collection/" class="">Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/spring/" class="">Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/" class="">Markup Language</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/html/" class="">Html</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/css/" class="">Css</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/" class="">基本功</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/speach/" class="">演说</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/body/" class="">身体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/" class="">Computer</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/principle/" class="">支撑-原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/performance/" class="">Performance</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/" class="">算法</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/thought/" class="">算法思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/data_structure/" class="">数据结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/math/" class="">数学</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/" class="">架构</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/" class="">代码</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/security/" class="">Security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/design_mode/" class="">Java设计模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/" class="">工程设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/ddd/" class="">工程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/frontend/" class="">前端</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>战略性技术</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/" class="">AI</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/map/" class="">知识图谱</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/framework/" class="">Framework</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/media/" class="">媒体</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/middle_platform/" class="">中台</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/block_chain/" class="">Block Chain</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Cloud</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/" class="">Datalake</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/ecology/" class="">Ecology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/edge/" class="">Edge</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/" class="">Manage</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/" class="">组织</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/people/" class="">人员</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/" class="">Method</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/product_plan/" class="">产品规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/code_plan/" class="">代码规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/ops_plan/" class="">运维规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/advice_plan/" class="">咨询规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/architect/" class="">服务治理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/project_plan/" class="">项目规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/test_plan/" class="">测试规划</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/summary/" class="">这些年我做过的技术</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/" class="">工具</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/" class="">运维</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/monitor/" class="">Monitor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/docker/" class="">Docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/k8s/" class="">Kubernetes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/enterprise_system/" class="">企业级系统</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/" class="">Develop</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/eclipse/" class="">Eclipse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/vim/" class="">VIM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/apple/" class="">Apple</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/jetbrains/" class="">Jetbrains</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/" class="">Linux</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_program/" class="">LinuxProgram</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/scene/" class="">LinuxScene</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_tool/" class="">LinuxTool</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/framework/" class="">Framework</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/physics/" class="">实物工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/" class="">测试</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/debug/" class="">程序调试</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/" class="">数据库</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mongodb/" class="">Mongodb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/postgresql/" class="">Postgre SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/oracle/" class="">Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/" class="">中间件</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/" class="">支撑-分布式</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/spring_cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/" class="">前端</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/bootstrap/" class="">Bootstrap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/threejs/" class="">Threejs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/angular/" class="">Angular</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/jquery/" class="">Jquery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/react/" class="">React</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/" class="active">小功能</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/hibernate/" class="">Hibernate</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Container</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nginx/" class="">Nginx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nodejs/" class="">Nodejs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/" class="">Cache</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/ops/" class="">Ops</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/work_code/" class="">Work Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/template/" class="">模板配置</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/soft_arch/" class="">软考架构师</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/misc/" class="">杂项</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>小功能</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#名词">名词</a></li>
    <li><a href="#库">库</a>
      <ul>
        <li><a href="#日志">日志</a></li>
        <li><a href="#格式模板">格式|模板</a></li>
        <li><a href="#生成压缩加密计算特征">生成|压缩|加密|计算特征</a></li>
        <li><a href="#客户端邮件">客户端|邮件</a></li>
        <li><a href="#领域语言">领域语言</a></li>
        <li><a href="#图形">图形</a></li>
        <li><a href="#运维控制">运维控制</a></li>
        <li><a href="#协议">协议</a></li>
        <li><a href="#高可用--性能">高可用 | 性能</a>
          <ul>
            <li><a href="#akka">akka</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#开发">开发</a>
      <ul>
        <li><a href="#脚手架">脚手架</a>
          <ul>
            <li><a href="#spring-boot">spring boot</a></li>
            <li><a href="#drapwizard">drapWizard</a></li>
          </ul>
        </li>
        <li><a href="#写法">写法</a>
          <ul>
            <li><a href="#ejb">ejb</a></li>
          </ul>
        </li>
        <li><a href="#语言增强">语言增强</a>
          <ul>
            <li><a href="#guava">guava</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#接口">接口</a>
      <ul>
        <li><a href="#restful">RESTful</a>
          <ul>
            <li><a href="#connect">connect</a></li>
            <li><a href="#express">express</a></li>
            <li><a href="#koa">koa</a></li>
          </ul>
        </li>
        <li><a href="#实时">实时</a>
          <ul>
            <li><a href="#socketio">socket.io</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#展示">展示</a>
      <ul>
        <li><a href="#spring-mvc">spring mvc</a></li>
        <li><a href="#struts2">struts2</a></li>
      </ul>
    </li>
    <li><a href="#数据">数据</a>
      <ul>
        <li><a href="#日志-1">日志</a></li>
        <li><a href="#爬虫">爬虫</a></li>
        <li><a href="#分析">分析</a></li>
        <li><a href="#计算">计算</a></li>
      </ul>
    </li>
    <li><a href="#搜索">搜索</a>
      <ul>
        <li><a href="#lucene">lucene</a></li>
        <li><a href="#solr">solr</a></li>
        <li><a href="#elasticsearch">elasticsearch</a></li>
      </ul>
    </li>
    <li><a href="#权限">权限</a>
      <ul>
        <li><a href="#shiro">shiro</a></li>
      </ul>
    </li>
    <li><a href="#分布式">分布式</a>
      <ul>
        <li><a href="#redisson">redisson</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="名词">
  名词
  <a class="anchor" href="#%e5%90%8d%e8%af%8d">#</a>
</h1>
<pre><code>dom                文档对象模型
dao                数据访问对象
ucs                unicode character set
utf                ucs Transformation Format
bmp                Basic Multilingual plane
bom                Byte Order Mark
asp                Active Server Pages
iis                Internet Information services
validate code                 验证码
tld                 tag library description
jsp                 java server page
xsd                XML Schemas Definition
suffix              后缀
ide                Integrated Development Environment
RIA                Rich internet Applications                富互联网应用（富客户端）C/S架构是胖客户端，B/S架构是瘦客户端。比如 flash就是ria(其它如js, SilverLight，unity3d，flash3d,adobe air,HTML5/css3，adobe Flex等)
JPA                Java Persistence API                        java持久层api
JDBC                Java DataBase Connectivity
DHTML                DynamicHTML
cvs                Concurrent Version System
svn                subversion
uml                UnifiedModelingLanguage
AJAX            Asynchronous JavaScript and XML
bnf                命令书写格式规范: 巴科斯范式
desc            description
capacity        容量
component       组件
association         联合
aggregation         聚合
composition         组合
alpha           开端
inherit         继承
dhtml           dynamic html ,是 html css 客户端script                        不是规范，是现有技术、标准的整合运用
css             Cascading Style Sheet   级联样式表
associated                交互的
perspective                视图
adapter         适配器
jit             just in time (compilation)
webdav          Web-based Distributed Authoring and Versioning        Web 分布式创作和版本管理 (WebDAV) 扩展了 HTTP/1.1 协议，允许客户端发布、锁定和管理 Web 上的资源
CMS             Content Management System        内容管理系统        它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。
constraint      约束
JSON            javascript object notation(标记)
OGNL            Object-Graph Navigation Language 对象图导航语言
jmf               java media frame java 媒体框架 是一个jar 包
dwr                Direct Web Remoting 是一个ajax框架。它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数，就像它就在浏览器里一样。
CXF                 apache的 Celtix + XFire,用于实现 web services的发布的使用
oa                Office Automation 办公自动化
dml                data manipulation language        数据操作语言
ddl                data definition language        数据定义语言
dcl                data control language                数据控制语言
ioc                inversion of control        控制反转（spring）
di                 dependence injection        依赖注入 （spring）
crud               增加(Create)、查询(Retrieve)（重新得到数据）、更新(Update)和删除(Delete)
ssh                Secure Shell,由IETF制定，为建立在应用层和传输层基础上的安全协议。
pojo                pure old java object
oop                object oriented programming
aop                aspect oriented programming                面向切面编程
hdfs                Hierarchical Data Format        层次型资料格式（分布式存储）
ftp                File Transfer Protocol
ssl                Secure Sockets Layer 安全套接层。端口40
tls                Transport Layer Security 传输层安全(ssl的继任者)
https            Hypertext Transfer Protocol Secure 应用ssl作为应用层子层对数据进行压缩与解压。端口443
jsf                JavaServer Faces 是sun开发的web框架，相当于ssh(spring + struts + hibernate)
sns                Social Network Services        社会性网络服务
uml                Unified modeling language 统一建模语言
jta                java transaction api (hibernate中) java事务处理api
asm                Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。
                    汇编语言(Assembly Language)的扩展名
jsr                Java Specification Requests 是Java规范请求，是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。jsr303:基于注解的java bean 验证
dto                data transfer object 数据传输对象
antlr             another tool for language recognition        一个开源的语法分析器
soap              simple object access protocol 简单对象访问协议
uefi              unified extensible firmware interface 统一可扩展固件接口
sso                single sign on 单点登录
erp                enterprise resource plan 企业资源计划
sap                Systems Applications and Products in Data Procession 企业系列软件(全世界排名第一的erp软件)
ssi                Server Side Include 服务器端嵌入
jmx                Java Management Extensions java管理扩展，是一个为应用程序、设备、系统等植入管理功能的框架。
jaas                Java Authentication Authorization Service Java验证和授权API
jca(J2C， J2CA)        Java Connector Architecture java连接器架构
jms                    Java Message Service java消息服务，用于在两个应用程序之间，或分布式系统中发送消息
jaf                    JavaBeans Activation Framework JAF是一个专用的数据处理框架，它用于封装数据，并为应用程序提供访问和操作数据的接口。JAF的主要作用在于让java应用程序知道如何对一个数据源进行查看、编辑和打印等操作。
jta                    Java Transaction API Java事务API,和jts为J2EE平台提供了分布式事务服务
jts                    Java Transaction Service java事务服务
scm                    Supply chain management 一种集成的管理思想和方法，执行供应商到最终用户的物流计划控制职能
ctr                    click-through-rate 网络广告
ioc/di                    inversion of control/ dependency injection
o2o                    online to offline 网站提供平台, 用户线下交易
cas                    central authentication service 单点登录
foobar                FTP Operation Over Big Address Records(RFC1545文档)ftp命令列表
modular              模块化
enumeration         计数
navigate            导航
fragment             碎片
posix                可移植的
intersection        截断
categories          类别
encounter           遭遇
recursion           递归
evaluate            评价
indent                缩进
collation         校对
schema              模式、图表
generate            生成
Presentation         描述
hierarchical         垂直分层
stereotype         策略
numerous            许多
KISS                keep it simple, stupid
cross-origin         跨域
CORS             Cross-Origin Resourse Sharing
NIH             not invented here 自己造轮子
mis                 management information system
crm                 customer relationship management
erp             enterprise resource planning
webRTC          web Real-Time Communication
</code></pre>
<h1 id="库">
  库
  <a class="anchor" href="#%e5%ba%93">#</a>
</h1>
<h2 id="日志">
  日志
  <a class="anchor" href="#%e6%97%a5%e5%bf%97">#</a>
</h2>
<pre><code>log4j
    # java
logback
    # log4j后续版本
slf4j
    # java
log4js
    # js
</code></pre>
<h2 id="格式模板">
  格式|模板
  <a class="anchor" href="#%e6%a0%bc%e5%bc%8f%e6%a8%a1%e6%9d%bf">#</a>
</h2>
<pre><code>moment
    # js格式化时间
iconv
    # nodejs调用c++ libiconv库来转码
iconv-lite
    # nodejs实现的转码，比调用c++ 的iconv更高效
poi
    # java 文件处理
jFreeChart
    # java图表库
jackson
    # java json序列化
json-smart
    # java json
xstream
    # java xml序列化
pango2
    # 国际化模板
snakeyaml
    # java yaml
js-beautify
    # js, html格式化
xmlbeans
    # java xml
joda-time
    # java日期
dom4j
    # java dom 
</code></pre>
<h2 id="生成压缩加密计算特征">
  生成|压缩|加密|计算特征
  <a class="anchor" href="#%e7%94%9f%e6%88%90%e5%8e%8b%e7%bc%a9%e5%8a%a0%e5%af%86%e8%ae%a1%e7%ae%97%e7%89%b9%e5%be%81">#</a>
</h2>
<pre><code>simhash
    # google 文档hash
pygments
    # python 生成高亮html
mako
    # python 模板
jinja2
    # python 模板
freemarker
    # java 模板
proguard
    # java 混淆
snappy
    # google java 压缩
jbcrypt
    # java加密, scrypt更强
</code></pre>
<h2 id="客户端邮件">
  客户端|邮件
  <a class="anchor" href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e9%82%ae%e4%bb%b6">#</a>
</h2>
<pre><code>javamail
    # java mail
nodemailer
    # node mail
mailapi
    # java mail
c3p0
    # java rds 连接池
dbcp
    # java rds 连接池
druid
    # java rds 连接池。可监控sql执行性能，记sql日志
jdbc
    # java rds client
dbutil
hibernate
ef
    # .net orm
NHibernate
    # .net orm
peewee
    # python orm
node-mysql
mongoose
httpClient
    # java http
request
    # js http
superagent
    # js http
mybatis
hsqldb
    # java内置, 单文件/内存数据库
mqttv
    # java mqtt客户端
libthrift
    # java thrift
kafka-clients
</code></pre>
<h2 id="领域语言">
  领域语言
  <a class="anchor" href="#%e9%a2%86%e5%9f%9f%e8%af%ad%e8%a8%80">#</a>
</h2>
<pre><code>lex
    # 生成词法分析程序
yacc
    # 生成自底向上语法分析程序
antlr
</code></pre>
<h2 id="图形">
  图形
  <a class="anchor" href="#%e5%9b%be%e5%bd%a2">#</a>
</h2>
<pre><code>ccap
    # 基于c++的图形CImg库，就是一个CImg.h文件
canvas
    # node canvas
tesseract
    # node 验证码
</code></pre>
<h2 id="运维控制">
  运维控制
  <a class="anchor" href="#%e8%bf%90%e7%bb%b4%e6%8e%a7%e5%88%b6">#</a>
</h2>
<pre><code>later
    # nodejs corntab
glob
    # nodejs 匹配获得文件
rd
    # node 遍历文件
commander
    # node制作命令
mkdirp
    # node 递归makedir
fs-extra
    # node扩展fs包
testcontainers
    # java, 运行docker
jOptSimple
    # java, 命令解析
</code></pre>
<h2 id="协议">
  协议
  <a class="anchor" href="#%e5%8d%8f%e8%ae%ae">#</a>
</h2>
<pre><code>spring-websocket
    # java
httpcore-nio
    # java
grpc-context
    # java
</code></pre>
<h2 id="高可用--性能">
  高可用 | 性能
  <a class="anchor" href="#%e9%ab%98%e5%8f%af%e7%94%a8--%e6%80%a7%e8%83%bd">#</a>
</h2>
<pre><code>retry
    # js retry
ehcache
    # 缓存
tagg
    # node线程池
cluster
    # node单机集群
fiber
    # node协程
driud
    # 连接池，阿里开源
</code></pre>
<h3 id="akka">
  akka
  <a class="anchor" href="#akka">#</a>
</h3>
<pre><code># scala并发、分布式、容错工具
使用
    system = ActorSystem.create(&quot;hello&quot;)
    system.actorOf() ## 前端 ### dwr
介绍
    java函数通过ajax映射到前端js调用
使用
    ajax框架
    1.导入jar包 dwr.jar
    2.web-inf/下的配置文件
        web.xml文件
            &lt;servlet&gt;
                &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt;
                &lt;servlet-class&gt;org.directwebremoting.servlet.DwrServlet&lt;/servlet-class&gt;
                        # 固定写法
                &lt;init-param&gt;
                        &lt;param-name&gt;debug&lt;/param-name&gt;
                        &lt;param-value&gt;true&lt;/param-value&gt;
                &lt;/init-param&gt;
                &lt;init-param&gt;
                        &lt;param-name&gt;scriptCompressed&lt;/param-name&gt;        # 允许在javascript中执行
                        &lt;param-value&gt;false&lt;/param-value&gt;
                &lt;/init-param&gt;
                &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;        # web工程启动时加载
            &lt;/servlet&gt;
            &lt;servlet-mapping&gt;
                &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt;
                &lt;url-pattern&gt;/dwr/*&lt;/url-pattern&gt;
            &lt;/servlet-mapping&gt;
        dwr.xml文件
            &lt;dwr&gt;
                &lt;allow&gt;
                    &lt;create creator=&quot;new&quot; javascript=&quot;DWRUserAccess&quot;&gt;        # 生成js文件的名（页面中引用）
                            &lt;param name=&quot;class&quot; value=&quot;outrun.dwr.DWRUserAccess&quot; /&gt;                # 曝露的类
                    &lt;/create&gt;
                    &lt;convert converter=&quot;bean&quot; match=&quot;outrun.dwr.User&quot; /&gt;        # 注册实体类，可以在js中进行实例化
                &lt;/allow&gt;
            &lt;/dwr&gt;
    3.写outrun.dwr.DWRUserAccess中的方法
    4.页面调用
        test.html
            &lt;script src=&quot;/outrun/dwr/engine.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;/outrun/dwr/util.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;/outrun/dwr/interface/DWRUserAccess.js&quot;&gt;&lt;/script&gt;
            &lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;
                DWRUserAccess.方法(参数,执行完运行的js函数)
                    # 参数可以是一个map,如
                        var userMap = {};
                        userMap.id = regForm.id.value;
                        userMap.password = regForm.password.value;
                        userMap.name = regForm.name.value;
                        userMap.email = regForm.email.value;
                        DWRUserAccess.save(userMap, saveFun);
                                # 其中的regForm是页面中的表单（的name属性,dom支持直接使用名字引用表单）
            &lt;/SCRIPT&gt;
</code></pre>
<h1 id="开发">
  开发
  <a class="anchor" href="#%e5%bc%80%e5%8f%91">#</a>
</h1>
<h2 id="脚手架">
  脚手架
  <a class="anchor" href="#%e8%84%9a%e6%89%8b%e6%9e%b6">#</a>
</h2>
<h3 id="spring-boot">
  spring boot
  <a class="anchor" href="#spring-boot">#</a>
</h3>
<h3 id="drapwizard">
  drapWizard
  <a class="anchor" href="#drapwizard">#</a>
</h3>
<pre><code># java，类spring boot
</code></pre>
<h2 id="写法">
  写法
  <a class="anchor" href="#%e5%86%99%e6%b3%95">#</a>
</h2>
<pre><code>traits-decorator
    # js mixin
q
    # js 流程控制
co
    # js generator to async
async
    # js 流程控制
thunkify
    # js函数Thunk化, 确保回调调用一次
step
    # async轻量库
wind
    # js定义的宏
streamline
    # 基于源代码编译来实现流程控制简化
eventproxy
    # js event回调
spring
    # java ioc
guice
# google的java ioc轻量框架
castle
    # .net ioc
spring.net
    # .net ioc
anko
    # go 代码解释器
antlr
    # java dsl
aopalliance
    # java aop
</code></pre>
<h3 id="ejb">
  ejb
  <a class="anchor" href="#ejb">#</a>
</h3>
<pre><code>特点
    分布式，j2ee一部分

组成
    会话bean(session)
    实体bean(entity)
    消息驱动bean(message driven)
</code></pre>
<h2 id="语言增强">
  语言增强
  <a class="anchor" href="#%e8%af%ad%e8%a8%80%e5%a2%9e%e5%bc%ba">#</a>
</h2>
<h3 id="guava">
  guava
  <a class="anchor" href="#guava">#</a>
</h3>
<pre><code># google工具集
maven
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
        &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;/dependency&gt;
组件
    o-&gt; 增强
    Optional                            # null处理
    Preconditions                       # 准入检查
    Ordering
    Throwables

    o-&gt; 集合
    Multiset                            # 存重复元素
    Multimap                            # 多值
    BiMap                               # 双向映射
    Table                               # 两键一值
    Range                               # 连续值
    
    o-&gt; 字符串
    Joiner
    Spilter
    CharMatcher
    CaseFormat

    o-&gt; 类型
    Objects
    Bytes
    Shorts
    Ints
    Longs
    Floats
    Doubles
    Chars
    Booleans

    o-&gt; 数学
    IntMath
    LongMath
    BigIntegerMath

    o-&gt; 高可用
    LoadingCache                        # 堆内缓存
</code></pre>
<h1 id="接口">
  接口
  <a class="anchor" href="#%e6%8e%a5%e5%8f%a3">#</a>
</h1>
<pre><code>luavit
    # lua实现, 类node
scotty
    # haskell
webapi
    # .net
meteor.js
    # 基于node.js + mongodb的网站开发平台，把这个基础构架延伸到浏览器端, 本地和远程数据通过DDP(Distributed Data Protocol)协议传输
restify
    # 基于nodejs的rest应用框架，去掉express中的 template, render等功能, 提供DTrace功能，方便调试
ssh
    # java
spring site
    # spring整合
tapestry
    # 基于servlet的mvc框架
jersey
    # java restful服务
naga
    # java nio
echo
    # go
beego
    # go
gorilla
    # go
gin
    # go，类express
iris
    # go, fasthttp的一种实现
tornado
    # python nio
web.py
twisted
    # event driven
flask
django
bottle
    # python wsgi
rails
    # ruby的web mvc开发框架
ror
    # ror(ruby on rails)
sinatra
    # 微型web
grape
    # 运行在rack或rails/sinatra配合使用的restful风格的ruby微框架
yii
    # php
laravel
    # php
codelgniter
    # php
</code></pre>
<h2 id="restful">
  RESTful
  <a class="anchor" href="#restful">#</a>
</h2>
<h3 id="connect">
  connect
  <a class="anchor" href="#connect">#</a>
</h3>
<pre><code>介绍
    nodejs处理http中req、res的中间件框架
    中间件分类
        pre-request用来改写request原始数据
        request/response功能各异
        post-response全局异常处理，改写response数据等
内置中间件介绍
    logger
    csrf
    compress             # gzip压缩
    basicAuth            # basic认证
    body parser          # 请求内容解析
    json
    urlencoded           # application/x-www-form-urlencode请求解析
    multipart            # multipart/form-data请求解析
    timeout
    cookieParser
    session
    cookieSession
    methodOverride       # http伪造
    responseTime         # 计算响应时间
    staticCache          # 缓存
    directory            # 目录列表
    vhost                # 虚拟二级域名映射
    favicon
    limit                # 请求内容大小限制
    query                # url解析
    errorHandler         # 错误处理
使用
    var connect = require('connect');
    var app = connect()
        .use(connect.logger('dev'))
        .use(function(req, res){
            res.end('hello world\n');
        })
        .listen(3000);
</code></pre>
<h3 id="express">
  express
  <a class="anchor" href="#express">#</a>
</h3>
<pre><code>安装
    npm install -g express-generator
    npm install express -d                        # g代表安装到NODE_PATH的lib里面, d代表关联套件一起安装
cookie-parser
    使用
        var cookieParser = require('cookie-parser');
        app.use(cookieParser());

        JSON.stringify(req.cookies);
        req.cookies.yourCookie
cookie-session
    使用
        var cookieSession = require('cookie-session');
        app.use(cookieSession())
        req.session = null

express-session
    options可选参数
        name                        # 表示cookie中保存session的字段名称，默认为connect.sid
        store                        # session的存储方式，默认存放在内存中，也有redis、mongodb、等模块支持
        secret                        # 设置secrect来计算hash放在cookie中产生signedCookie，来防篡改
        genid                        # 规定产生一个新的session_id时所用的函数，默认用uid2这个包
        rolling                        # 每个请求都重新设置一个cookie，默认为false
        resave                        # 即使session没有被修改，也保存session的值
    使用
        var session = require('express-session');
        app.use(session(options));

connect-redis
    使用
        var express = require('express');
        var session = require('express-session');
        var redisStore = require('connect-redis')(session);

        app.use(session({
            store: new redisStore(),
            secret: 'somesecrettoken'
        }));
serve-static
    # 静态文件
passport
    介绍
        登录验证中间件
        支持connect express sails等web框架
        支持Basic, Digest, OAuth(1.0和2.0的三种实现), Bearer等
    安装
        npm i passport
        npm i passport-local
    o-&gt; 配置
    var express = require('express');
    var cookieParser = require('cookie-parser');
    var session = require('express-session');
    var flash = require('express-flash');
    var passport = require('passport');

    ...

    app.use(cookieParser());
    app.use(session({...}));
    app.use(passport.initialize());
    app.use(passport.session());
    app.use(flash())

    passport.serializeUser(function (user, done) {
            done(null, user.id)
    })
    passport.deserializeUser(function (id, done) {
            User.findById(id, function (err, user) {
                    done(err, user)
            })
    })

    app.post('/login', passport.authenticate('local', {
            # passport.authenticate是个登录中间件，通过就走后面回调，否则返回401
            # local是自定义的名称
            successRedirect: '/',
            failureRedirect: '/login',
            failureFlash: true,
    }, function (req, res) {
            res.redirect('/users/' + req.user.username)
    }))

    app.post('/login', passport.authenticate('local', function(err, user, info) {
            if (err) return next(err)
            if (!user) {
                    req.flash('errors', {msg: info.message})
                    return res.redirect('/login')
            }
            req.logIn(user, function (err) {})
    })(req, res, next))
    app.get('/logout', function(req, res) {
            req.logout()
            res.redirect('/')
    })
    app.get('/user', isAuthenticated, getUser)
    var isAuthenticated = function (req, res, next) {
            if (req.isAuthenticated()) {
                    return next()
            }
            res.redirect('/login')
    }


    o-&gt; local验证
    var LocalStrategy = require('passport-local').Strategy
    passport.use(new LocalStrategy(
            function(username, password, done) {
                    User.findOne({username: username}, function(err, user) {
                            if (err) {return done (err)}
                            if (!user) {return done(null, false, {message: 'no user'})}
                            if (!user.validPassword(password)) {...}
                            return done(null, user)
                    })
            }
    ))

    o-&gt; usernameField
    passport.use(new LocalStrategy({
            usernameField: 'email',
            passwordField: 'passwd'
    }, function (username, password, done) {...}
    ))

    o-&gt; OAuth
    介绍
        第三方登录协议
        三个步骤
            1. 获取未授权的request token
            2. 获取用户授权的request token
            3. 用授权的request token换取access token
    使用
        网页上申请开发github应用
        npm install passport-github
            # 安装passport的github扩展
        // app.js
        passport.use(new GithubStrategy({        // 增加github认证策略
            clientID: 'XXXX',
            clientSecret: 'YYYY',        // 已从github上申请
            callbackURL: 'http://localhost:3000/auth/github/callback'
        }, function(accessToken, refreshToken, profile, done){
            done(null, profile);
        }));
        // 定义路由
        app.all('/github', isLoggedIn);
        app.get('/github', user.github);
        app.get('/auth/github', passport.authenticate('github', {scope: 'email'}));
        app.get('/auth/github/callback', passport.authenticate('github', {
            successRedirect: '/github',
            failureRedirect: '/'
        }));
kraken
    介绍
        基于express之上的基于设置结构化代码工具
    功能
        post请求_csrf验证

    基本用法
        'use strict'
        var express = require('express'),
            kraken = require('kraken-js');
        var app = express();
        app.use(kraken());
        app.listen(8000);
</code></pre>
<h3 id="koa">
  koa
  <a class="anchor" href="#koa">#</a>
</h3>
<pre><code>介绍
    express原班人马打造的，更小，更健壮，更有表现力的web框架
    免除重复繁琐的回调函数嵌套，提高错误处理效率
    不绑定任何中间件，只是提供一个轻量优雅的函数库
    &gt;=node0.11.16
配置
    app.name              # 应用名称
    app.env                  # 执行环境，默认是NODE_ENV 或 'development'
    app.proxy              # 决定哪些proxy header被加到信任列表中
    app.subdomainOffset      # 被忽略的.subdomains列表
    app.jsonSpaces          # 输出json时是否填充空格
    app.outputErrors        # 是否输出错误堆栈(err.stack)到stderr(app.env是'test'时，此值为false)

使用
    $ npm install koa
    $ node --harmony app.js                        # 必需使用harmony模式运行程序
    var koa = require('koa');
    var app = koa();
    app.use(function *(){
        this.body = 'Hello World';
    });        # function*  声明的generator function支持yield
               ## yield是ES6定义的新语法
    app.listen(3000);
使用(downstream &amp; upstream)
    var koa = require('koa');
    var app = koa();

    // x-response-time
    app.use(function *(next){
    // (1) 进入路由
    var start = new Date;
    yield next;
    // (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间
    var ms = new Date - start;
    this.set('X-Response-Time', ms + 'ms');
    // (6) 返回 this.body
    });

    // logger
    app.use(function *(next){
    // (2) 进入 logger 中间件
    var start = new Date;
    yield next;
    // (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间
    var ms = new Date - start;
    console.log('%s %s - %s', this.method, this.url, ms);
    });

    // response
    app.use(function *(){
    // (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream
    this.body = 'Hello World';
    });

    app.listen(3000);

    this
        request
            header
            headers
            url
            accepts
        response
            header
            headers
            status
        cookies
            set('name', 'tobi', {signed: true})
                signed
                expires
                path
                domain
                secure
                httpOnly
            get
        type
        length
        path
        method
        state
        throw
        assert
    app
        use
        listen
        callback
        keys
        context
            db
中间件
    koa-router
    trie-router
    route
    basic-auth
    etag
    compose
    static
    static-cache
    session
    compress
    csrf
    logger
    mount
    send
    error
</code></pre>
<h2 id="实时">
  实时
  <a class="anchor" href="#%e5%ae%9e%e6%97%b6">#</a>
</h2>
<pre><code>sockjs
        # node websock
postal
        # nodejs 在内存上构建的发布订阅框架
pusher
        # 发布订阅模式socketio框架
juggernaut
        # 基于socketio
datachannel.io
        # 基于socket.io和html5 webRTC的实时聊天室框架
faye-websocket-node
        # 扩展faye项目开发的websocket的一个实现, 非常简单，而且不依赖其他库
websocket-node
        # 一个简单的websocket库，支持draft-10及之前的各种版本, 支持同样是node的c/s交互模式
ejabberd
        # 基于erlang/OTP 的xmpp im 开源框架
singalR
        # .net sock服务
nsq
        # go
openfire
        # java, 性能较差, 最多单机10w并发
webrtc
        # c++实现的web视频聊天
</code></pre>
<h3 id="socketio">
  socket.io
  <a class="anchor" href="#socketio">#</a>
</h3>
<pre><code># 介绍
    socket.io: 基于任何浏览器, mobile设备的&quot;webSocket&quot;
# 安装
        npm install socket.io
# 使用
        var socketIo = require('socket.io');
        socketIo.listen(app).on('connection', function (socket) {                # require('socket.io')(app);
                                                                        ## var io = require('socket.io')(80);
        socket.emit('news', { hello: 'world' });
        socket.on('my other event', function (data) {
                console.log(data);
        });
        });
# api
    server
            io.on('connection', function(socket){});
            io.on('disconnect', function(){});
            socket.on('message', function(msg){});
    client-js
            socket = io.connect(url);
            socket.on('', function(json){});
            socket.send(json);
    io
            on('connection', function(socket){});
                    # disconnect
    socket
            on('disconnect', function(){ });
            socket.on('say to someone', function(id, msg){
                    socket.broadcast.to(id).emit('my message', msg);
            });
                    # Socket#id为内部指定的
    遍历用户
            var roster = io.sockets.clients('chatroom');
            roster.forEach(function(client){
                    console.log('Username: ' + client.nickname);
            });                        // 1.0之前版本可用
# 方案
    namespace
            server
                    var nsp = io.of('/my-namespace');
                    Onsp.emit('hi', 'everyone!');                # ns广播
            client
                    var socket = io('/my-namespace');
    room
            server
                    socket.join('some room');
                    io.to('some room').emit('some event'):        # room广播
                    socket.leave('some room');
# 子模块
    socket.io-redis
        介绍
                用于从外部发消息，与socket.io-emitter一起使用
        使用
                var io = require('socket.io')(3000);
                var redis = require('socket.io-redis');
                io.adapter(redis({ host: 'localhost', port: 6379 }));
    socket.io-emitter
        介绍
                用于从外部发消息，与socket.io-redis一起使用
        使用
                var io = require('socket.io-emitter')();
                io.emit('time', new Date);
    socket.io-client
        介绍
                用于创建客户端来连接socket.io
        使用
                var iocl = require('socket.io-client');
                var socket = iocl.connect('127.0.0.1:5555');
                socket.on('connect', function(){

                });
</code></pre>
<h1 id="展示">
  展示
  <a class="anchor" href="#%e5%b1%95%e7%a4%ba">#</a>
</h1>
<pre><code>titles
    # java apache的标签库
</code></pre>
<h2 id="spring-mvc">
  spring mvc
  <a class="anchor" href="#spring-mvc">#</a>
</h2>
<h2 id="struts2">
  struts2
  <a class="anchor" href="#struts2">#</a>
</h2>
<pre><code># 基础
    介绍
        struts1和WebWork的发展
        引入值栈的概念     # 一次请求的参数和处理数据放在一个map结构中
    原理
        基于拦截器, 解耦servlet, 再提供自己的拦截器(interceptor)操作数据, 反射调用业务类
        FilterDispatcher通过配置文件来映射设置请求地址与处理类
            ActionMapper判断请求是否struts处理
            ActionProxy扩展实现方式(如web service)
            ConfigurationManager对应struts.xml配置文件
            ActionInvocation执行Action与拦截器
            Action处理请求，封装数据
                # Action是非单例的，效率低
    过滤器与拦截器
        过滤器基于回调，拦截器基于反射
        过滤器依赖servlet, 拦截器在struts中处理action

# 思想
    Action类中的无侵入设计（新技术中不出现旧技术）：map代替了作用域
        ActionContext actionContext = actionContext.getContext()
        actionContext.getApplication()
        actionContext.getSession()

        好处
            map是java中的api，不出现旧技术
            测试方便（ servlet不能测试，只能发布测试）
                # 注意：Action类中用到作用域map的方法也不能测试


# 结构
    apps: 例子程序
    docs:帮助文件
    lib:程序包
    src:源码
# 使用
    要求
        jdk5
        jsp2
        servlet api2.4

    导入核心的8个包
        struts2-core-2.3.1.1.jar        # struts的过滤器
        xwork-core-2.3.1.1.jar                # 验证工具
        freemarker-2.3.18.jar                # 标签
        javassist-3.11.0.GA.jar                # 动态代理
        commons-fileupload-1.2.2.jar
        commons-io-2.0.1.jar                # 文件处理
        commons-lang-2.5.jar                # 基础包
        ognl-3.0.3.jar                                # 表达式语言
    web.xml文件中配置过滤器
        &lt;filter&gt;
            &lt;filter-name&gt;struts&lt;/filter-name&gt;
            &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
        &lt;/filter&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;struts&lt;/filter-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;/filter-mapping&gt;
    写jsp页面，get或post路径为struts2的名称空间、扩展名，被配置的struts2过滤器处理
    写Action类（继承ActionSupport类）
    配置src/struts.xml文件与src/struts.properties文件，映射类、方法等到请求路径，映射返回字符串到任何方式


# 核心包：8个
    struts2-core-2.3.1.1.jar        # struts的过滤器
    xwork-core-2.3.1.1.jar                # 验证工具
    freemarker-2.3.18.jar                # 标签
    javassist-3.11.0.GA.jar                # 动态代理
    commons-fileupload-1.2.2.jar
    commons-io-2.0.1.jar                # 文件处理
    commons-lang-2.5.jar                # 基础包
    ognl-3.0.3.jar                                # 表达式语言

# 配置
    struts2以包的形式管理action 包名必须唯一，包里的每个action唯一
    使用步骤
        导入lib包
        写jsp
        编写Action方法
        web.xml中配置
            &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter
            &lt;url-pattern&gt;/*
        ../xx_struts.xml中配置请求响应
        src/struts.xml 中引入配置文件
            &lt;include file=&quot;cn/itcast/javaee/cal/cal_struts.xml&quot;/&gt;

    配置文件（配置包）路径
        重要路径：4个
            1./struts-default.xml[框架]
                # 是框架自带的abstract包（包括上传，下载，验证等），继承它以后可以用其中的功能
            2./org/apache/struts2/default.properties[框架]
            3.src/struts.xml # 必有
            4.src/struts.properties # 可选
        验证返回消息的配置文件
            struts2-core-2.3.1.1.jar包中的
                /org/apache/struts2/struts-messages.properties文件

    xml 中配置的简化
        *
            o-&gt; 只能在name 中写*_* 等
            o-&gt; 引用第一个* 用{1}        引用第二个用{2} 以此类推


    类路径
        com.opensymphony.xwork2.ActionSupport  默认关联到的类

    处理请求的扩展名配置
        # 扩展名配置只有一个会生效
        1./org/apache/struts2/default.properties
                struts.action.extension=action,,
                # 框架中初始的默认扩展名，最后的','代表了无扩展名
        2.src/struts.xml中
                &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do,,&quot;&gt;
                        # 必需配置
        3.src/struts.properties中
                        struts.action.extension=xx,yy
                        # 选择配置，优先级高

    默认配置
        struts2内置了请求字符串与基本类型的相互转换，不用手工转换

        /org/apache/struts2/default.properties文件中
                struts.i18n.encoding=UTF-8        # post方式请求响应的编码方式
                                                                        ## get方式的没有默认值，需要自己转码
                struts.action.extension=action,,  # 框架中初始的默认扩展名,最后的','代表了无扩展名

        每个&lt;package&gt;标签中配置
        &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; 为默认的拦截器

    src/struts.xml配置文件

    src/struts.properties配置文件

# 原理流程
    请求/qq.action -&gt; StrutsPreparedAndExecuteFilter（核心过滤器）-&gt; 匹配扩展名 -&gt; 匹配命名空间
        #（ 全限定名：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.class）
            -&gt; src/struts.xml                -&gt; name
                class
                method
            -&gt; name
                type
                内容
            -&gt; 响应
            -&gt; 拦截器 -&gt; ConfigAction类

        # 1.部署时读取src/struts.xml和src/struts.properties文件，形成JavaBean对象
                # 两个文件同时存在时src/struts.properties文件为准
        ## 2.请求/*路径时，StrutsPreparedAndExecuteFilter过滤
        ## 3.获取JavaBean中的actionName ,actionClass, actionMethod, 执行方法
        ## 4.执行的返回值与resultName, resultType, resultContent进行比较
        ## 5.按resultType类型返回resultContent（路径和内容）

# 缺点
    8个jar包，慢，servlet 快
    配置繁琐
# 编码
    struts2默认编码方式:utf-8

    返回的图片相对路径中有中文时设置tomcat
        tomcat/conf/server.xml
            &lt;Connector port=&quot;8080&quot; .. URIEncoding=&quot;utf-8&quot;/&gt;

        这时点击下载的请求路径中有中文时在以post方式提交 ,struts自动转码。若以get方式提交，需要在Action类的相应的get方法中转换url编码（iso8859-1）到u8

        原理
                改了tomcat的内部编码以后，struts中的编码是u8，放在session 中，jsp支持u8,解释后发送的html中的编码没问题，查看没问题。
                下载post发送请求，浏览器请求的是url编码的u8,struts中也是u8执行下载

                如果不改编码，struts 中是u8,如果以List方式放入session的话,session存储的是u8
                如果直接放入数据的话,session中存储的是8859-1,jsp取出数据需要转码为u8并设置自己的编码是u8,再发送给浏览器。
                浏览器这时获取图片正常,post方式提交的是u8,经过tomcat转换为8859-1,struts中自动转换编码到u8
                如果是以get方式提交请求，get中的中文在浏览器时进行url编码到8859-1,经过tomcat，再到struts,struts不对get方式的请自动进行转码
                向action类中注入参数时是8859-1编码,需要手动在action类中的属性的get方法中进行8859-1到u8的转码操作
# 内置对象
    struts中的6个内置对象
        # request请求进入struts中时创建，request请求结束时销毁。
        requestMap
        sessionMap
        applicationMap
        parameters
        attr                        # page -&gt; request -&gt; session -&gt; application 的顺序查找
        valueStack                # 定义实例变量，直接放入valueStack的 list（栈） 中,map（值）很少向内存储数据
            # 定义的实例变量必须提供相应的get方法,否则ognl标签中取其数据时没有方法调用，就得不到它的值
            # list 中的值优先访问 ，但是map 中的值起决定作用
            # map中存放着一个大map,其中注入了所有页面的请求信息
                # requestMap sessionMap applicationMap 并不是真正的域对象，但最后通过拦截器放入到域对象中

# 异常处理
    配置src/strut.xml 文件
        &lt;global-results&gt; 全局结果（用来跳转全局异常等）
        &lt;global-exception-mappings&gt; 全局异常
        &lt;exception-mapping result=&quot;nullJsp&quot;        exception=&quot;java.lang.NullPointerException&quot; /&gt;
            # &lt;action&gt;标签中的局部异常
            ## &lt;action&gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&quot;nullJsp&quot;的字符串交给本&lt;action&gt;标签中相应的&lt;result&gt;标签来处理


    处理机制
        o-&gt; 多个异常时走子异常，父异常被忽略
        o-&gt; 先处理小范围异常，大范围忽略
        o-&gt;  如果异常没有处理，抛出到web服务器处理,web.xml的&lt;error-page&gt;&lt;error-code&gt;&lt;location&gt;
    全局异常
        xml文件中
            &lt;global-results&gt;
                &lt;result name=&quot;error&quot;&gt;
                    /error.jsp
                &lt;/result&gt;
            &lt;/global-results&gt;
            &lt;global-exception-mappings&gt;
                &lt;exception-mapping result=&quot;error&quot; exception=&quot;java.lang.Exception&quot;/&gt;
            &lt;/global-exception-mappings&gt;
        error.jsp页面中
            &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;
            异常信息：&lt;s:property value=&quot;exception.message&quot;/&gt;&lt;br/&gt;
            详细信息：&lt;s:property value=&quot;exceptionStack&quot;/&gt;&lt;br/&gt;


# 转递方式
    chain                        # action类之间转发
    dispatcher                # 转发到jsp
    freemarker
    httpheader
    redirect                # 重定向到页面
    redirectAction        # action 类之间重定向
    stream                        # 返回 InputStream流
    velocity
    xslt
    plainText
# Action类
    注意
        1.所有Action类都要继承ActionSupport类，否则execute方法返回的字符串不会回到struts拦截器再根据xml文件的配置进行转发
        2.action类是非单例的。        # 所有多实例的对象全部是因为有私有属性，否则全部应该是单例的
        3.action类放在栈的顶端，用于注入数据

    传统方式得到request,response,servletContext,pageContext
        ServletActionContext.getPageContext()
        HttpServletRequest request = ServletActionContext.getRequest()
        ServletActionContext.getResponse()
        ServletActionContext.getServletContext();

    优势
        实现与servlet的解耦

    验证
        验证分类
                前台验证：javascript等
                后台验证：服务器
        struts2验证
                    后台验证
            1.代码式验证
            2.声明式验证:xml文件

    ActionContext类
        调用方法
        ActionContext actionContext = ActionContext.getContext();
        得到内置对象        # 这几种得到作用域的方法均可以得到作用域中原有的值，也可以放入值
        request
                actionContext.put(&quot;&quot;,&quot;&quot;);
        application
                Map&lt;String,Object&gt; applicationMap = actionContext.getApplication();
        session
                Map&lt;String,Object&gt; sessionMap = actionContext.getSession();
                        # 或 actionContext.get(&quot;session&quot;)得到，因为actionContext中存储着大map
        parameters
                Map&lt;String,Object&gt; parametersMap = actionContext.getParameters();
        valueStack
                ValueStack valueStack = actionContext.getValueStack()
                valueStack.getRoot()                        # 得到当前值栈的顺序

    参数
        1.action类中可以直接创建属性与其get方法得到客户端get方法或post表单请求的参数(由struts2自动注入)
        2.action类中可以创建 JavaBean的属性来接收struts注入的参数，这时用户请求的参数名字要写成JavaBean名.JavaBean中的属性名（这样struts2会自动调用JavaBean的set方法来注入其中相应的参数 ）
## BaseAction
    作用
        权限管理
        存放常驻内存数据
        抽取常用的方法
# web.xml配置
    &lt;filter&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;filter-class&gt; org.apache.struts2.dispatcher.FilterDispatcher &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;struts.action.extension&lt;/param-name&gt;
            &lt;param-value&gt;do&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;url-pattern&gt;*.json&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
        # 设置全局过滤器，并且修改过滤扩展名
# default.properties
    src/struts.properties配置文件
        struts.custom.i18n.resources=struts    # 使自己的普通配置生效。如：/org/apache/struts2/struts-messages.properties文件的
            ## struts.messages.error.content.type.not.allowed=Content-Type not allowed: {0} &quot;{1}&quot; &quot;{2}&quot; {3}  属性，&quot;{1}&quot; &quot;{2}&quot; &quot;{3}&quot;是显示消息的占位符
            ## struts.action.extension=action,,可以不配置
            # 由于只加载properties文件，所以省略.properties
            ## =后面的是相对于src目录的文件
# ognl标签
    注意
        # jquery中不能定位ognl标签，而要用标签自己生成的id定位（看源码得到）
    使用：
        &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt;
        tld映射文件路径
            struts2-core-2.3.1.1.jar包中
            /META-INF/struts-tags.tld

    '#'出现的地方
        o-&gt; 除ValueStack 之外的所有struts内置对象的取值前面都要加
        o-&gt; 取JavaBean中的属性时要加 '#'，如&quot;#user.username&quot;,ValueStack中也不例外
        o-&gt; 构造Map对象，Map：#{'male':'[男]','female':'[女]'}，构造radio和select标签，如
                        # &lt;s:radio list=&quot;#{'male':'aa','bb':'cc'}&quot; name=&quot;gender2&quot; /&gt;
        o-&gt; 迭代数组或list集合
            集合的投影：userList.{username}
            集合的过滤：userList.{?#this.age&gt;22}

    主题与模板
        主题：为多个模板提供风格
            struts2-core-2.3.1.1.jar包中
                template中的四个主题
                    archive                # 其中是.vm文件，其它是.ftl文件。vm与ftl是两种视图技术
                        ajax        # 除此之外其它都不支持ajax
                        simple
                        xhtml
                    xhtml                # 默认主题,default.properties配置文件中定义
                    css_xhtml
                    simple
            修改主题
                1.struts.properties 中修改
                    struts.ui.theme=simple          # 针对当前webapp
                2.&lt;s:form theme=&quot;xhtml&quot;&gt;            # 只针对当前表单
                3.&lt;s:textfield name=&quot;username&quot; theme=&quot;simple&quot;&gt;  # 修改某个标签的属性
        模板：为标签提供样式
                做模板的技术freemarker

    ognl标签的优点：自动排版、验证数据回显、国际化

    所有标签：
        逻辑标签
            对 Map 集合的迭代：
                &lt;s:iterator value=&quot;#session.fileMap&quot; var=&quot;entry&quot; status=&quot;stat&quot;&gt;
                    &lt;s:property value=&quot;#entry.key&quot;/&gt;
                &lt;s:if test=&quot;#stat.count%4==0&quot;&gt;&lt;/s:if&gt;
                &lt;/s:iterator&gt;
            对 List 集合的迭代  List&lt;User&gt; userList
                普通迭代
                    &lt;s:iterator var=&quot;user&quot; value=&quot;userList&quot;&gt;      # 投影语法List&lt;user&gt;中的所有username
                    &lt;s:property value=&quot;#user.username&quot;/&gt;
                        投影语法
                    &lt;s:iterator var=&quot;username&quot; value=&quot;userList.{username}&quot;&gt;
                    &lt;s:property/&gt;                        # 这里不用写属性value=&quot;username&quot;就可以对page域中的username进行显示
                过滤语法
                    &lt;s:iterator var=&quot;user&quot; value=&quot;userList.{?#this.age&gt;9}&quot;&gt;
                        # this代表当前被迭代的元素 ?#是所有 ^#是第一个 $#是最后一个  ?#...[0]按标记取
                    &lt;s:property value=&quot;#user.username&quot; /&gt;
        显示标签（UI标签）
            普通字符串中使用ognl
                jsp中用%{}      xml中用${}
                例如
                jsp中：&lt;s:textfield label=&quot;%{#attr.testValueStack}&quot;/&gt;
                xml中：&lt;param name=&quot;min&quot;&gt;4000&lt;/param&gt;
                                            &lt;message&gt;${min}&lt;/message&gt;
            普通信息
                &lt;s:text name=&quot;&quot;/&gt;
            输出值
                迭代器中
                        &lt;s:property/&gt;        # 直接输出被迭代的内容（简单）
                        &lt;s:property value=&quot;aa&quot;/&gt;
                        &lt;s:property value=&quot;#aa&quot;/&gt;
                普通
                        &lt;s:property value=&quot;username&quot;/&gt;      # 输出标签,得到valueStack中属性
                        &lt;s:property value=&quot;#request.name&quot;/&gt;                # 得到request域对象中的值
                                # request #session #application #parameters #attr
                                # '#attr'优先级：page,request,valueStack,session,application
            显示验证拦截器的验证信息集合中的数据：
                &lt;s:fielderror/&gt;                                                        # 显示所有错误信息
                &lt;s:fielderror fieldName=&quot;&quot;/&gt;                        # 显示验证返回的错误信息
            单选
                &lt;s:radio list=&quot;#{'male':'男','female':'女'}&quot; name=&quot;gender2&quot; value='男'&gt;
                                # 自动加class id &lt;label for=&quot;gender2male&quot;&gt;等
                                # list键值对中male是实际值,男是显示值
                                # name是&lt;input radio &gt;的name属性
                                # value中是选中的项
            多选
                &lt;s:select multiple=&quot;true&quot; list=&quot;#{'bj':'北京','sh':'上海','gz':'广州'}&quot; name=&quot;select1&quot; value=&quot;{'sh','bj'}&quot;/&gt;
            表单                        # 在ognl的标签中， struts的验证消息自动回显，不用加&lt;s:fielderror/&gt;标签
                &lt;s:form action=&quot;&quot;&gt;                # 默认中加上了 method=&quot;post&quot; action中加上了当前网站了contextPath路径
                        &lt;s:textfield label=&quot;用户名&quot; name=&quot;username&quot; /&gt;
                        &lt;s:password label=&quot;密码&quot; name=&quot;password&quot; /&gt;
                        &lt;s:submit value=&quot;登录&quot; /&gt;
            国际化                # 国际化一般放在整个网站的最后写
                                ##　伪国际化：将不同语言的页面放在不同文件夹中分别访问
                        # 国际化是通过i18n拦截器实现的
                1.创建国际化信息文件
                        message_zh_CH.properties      # 基名_语言名_国家名.properties
                                username=xxx
                                password=xxxx
                                submit=xx
                        message_en_US.properties
                        ..
                        message.properties                # 默认的显示语言
                                # 找伊拉克没有的话找本地区语言，本地语言没有的话找其它(默认的或美国等)
                2.struts.properties中引入国际化配置的属性文件
                        struts.custom,i18n.resources=struts2/tag/i18n/message        # 从src文件夹路径开始，只写基名
                3.验证消息国际化
                        message.properties文件中配置属性validationRequiredUsername=用户名错误
                        validation.xml文件中
                        &lt;message key=&quot;validationRequiredUsername&quot;&gt;&lt;/message&gt;
                4.jsp文件中用key属性代替 label属性(或其它在页面上显示信息的属性),key中写国际化信息文件中的key
                        &lt;s:form action=&quot;taglogin&quot;&gt;
                                &lt;s:textfield key=&quot;username&quot; name=&quot;username&quot; /&gt;
                                &lt;s:password key=&quot;password&quot; name=&quot;password&quot; /&gt;
                                &lt;s:submit key=&quot;submit&quot;/&gt;
                        &lt;/s:form&gt;
                5.普通信息的国际化
                        message.properties中配置属性 normalMessage:普通信息
                        jsp中&lt;s:text name=&quot;normalMessage&quot;/&gt;
                6.测试
                        intername选项 -- 语言 改地区访问

    xml文件中的ognl标签
            o-&gt; ${aa}
                    1.调用转到该标签类的getAa()方法得到aa的值替换${aa}
                    2.本标签中name=&quot;aa&quot;的标签的文本节点的内容
            o-&gt; {1}{2}{3}..{n}
                    匹配本标签中name=&quot;*a*&quot; 中的第n个‘*’,用于通配传递过来的参数的一部分的值
# ognl表达式
    ognl 开源，java写的免费标签,是struts2特有的

    xml文件中
        ${Xxx}                取值栈中栈中的东西，如action类中的属性
        ${#Xxx}                取值栈中值的东西，如request,session域中的数据（其实就是老师说的内置对象【valueStack就是值栈】）

    jsp文件中
        &lt;s:iterator value=&quot;#session.fileMap&quot; var=&quot;entry&quot; status=&quot;stat&quot;&gt;
            &lt;s:property value=&quot;#entry.key&quot;/&gt;
            &lt;s:if test=&quot;#stat.count%4==0&quot;&gt;&lt;/s:if&gt;
        &lt;/s:iterator&gt;
# strut.xml配置
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE struts PUBLIC
            &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;
            &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;

    &lt;struts&gt;
        &lt;constant name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constant&gt;
        &lt;include file=&quot;&quot;&gt;&lt;/include&gt;
        &lt;package name=&quot;&quot;&gt;
                &lt;interceptors&gt;
                        &lt;interceptor name=&quot;&quot; class=&quot;&quot;&gt;&lt;/interceptor&gt;
                        &lt;interceptor-stack name=&quot;&quot;&gt;
                                &lt;interceptor-ref name=&quot;&quot;&gt;&lt;/interceptor-ref&gt;
                        &lt;/interceptor-stack&gt;
                &lt;/interceptors&gt;
                &lt;default-interceptor-ref name=&quot;&quot;&gt;&lt;/default-interceptor-ref&gt;
                &lt;global-results&gt;
                        &lt;result name=&quot;&quot;&gt;&lt;/result&gt;
                &lt;/global-results&gt;
                &lt;global-exception-mappings&gt;
                        &lt;exception-mapping result=&quot;&quot; exception=&quot;&quot;/&gt;
                &lt;/global-exception-mappings&gt;
                &lt;action name=&quot;&quot;&gt;
                        &lt;param name=&quot;&quot;&gt;&lt;/param&gt;
                        &lt;result&gt;&lt;/result&gt;
                        &lt;result name=&quot;input&quot;&gt;&lt;/result&gt;
                        &lt;exception-mapping result=&quot;&quot; exception=&quot;&quot;/&gt;
                        &lt;interceptor-ref name=&quot;&quot;&gt;&lt;/interceptor-ref&gt;
                &lt;/action&gt;
        &lt;/package&gt;
    &lt;/struts&gt;

    设置
        &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;/&gt;                # 开启debug模式
                                                                # debug模式，不用重启调试(添加新的方法要重启，方法中改代码不用重启)
        &lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;utf-8&quot;/&gt;
                                                                # 配置struts的编码
        &lt;constant name=&quot;struts.configuration.xml.reload&quot; value=&quot;true&quot;/&gt;
                                                                # 配置本属性，可以使得改动struts配置文件不用重启应用服务器
        &lt;constant name=&quot;struts.multipart.saveDir&quot; value=&quot;/upload&quot;/&gt;
                                                                # 配置上传存储路径
        &lt;constant name=&quot;struts.action.extension&quot; value=&quot;action,do&quot; /&gt;
                                                                    # 配置过滤路径
    详细解释
        o-&gt; 存放路径src/
        o-&gt; 可以在struts-2.3.15.1的src\apps\blank\src\main\resources\struts.xml中参考配置文件
        o-&gt; &lt;include file=&quot;struts2/cal/cal_struts.xml&quot;/&gt;标签包含其它路径的xml配置文件
                        #　被include的文件不能再include其它文件
        o-&gt; &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do,,&quot;&gt;
                默认值
                        default.properties中配置了默扩展名：struts.action.extension=action,,
                # 配置匹配到框架处理的扩展名，空逗号代表匹配没有扩展名
        o-&gt; &lt;package name=&quot;xxPackage&quot; extends=&quot;struts-default&quot; namespace=&quot;/xx/&quot;&gt;
                默认值
                        namespace=&quot;/&quot;
                        extends=&quot;struts-default&quot;        # 不可省略
                # name是包的唯一标识，不可以写路径
                ## namespace 访问路径如/xx/a.do会匹配到该包执行其中的映射，按照域命名空间链的方式匹配，如：
                                                        /xx/yy/a.do也会匹配到该包，但是它优先匹配到/xx/yy的命名空间
                                                        /a.do 不会匹配到该包
                        注意：匹配/sys/*的名称空间是/sys 而非 /sys/
                ## struts的包有抽象包，普通包两种，通过继承可以加入包内容，相当于复制、粘贴
                ## 继承的包是struts-default，其路径是/struts-default.xml
                ## ，它定义了核心的bean和拦截器
        o-&gt; &lt;interceptors&gt;
                        &lt;interceptor name=&quot;&quot; class=&quot;&quot;/&gt;
                        &lt;interceptor-stack name=&quot;&quot;&gt;
                                &lt;interceptor-ref name=&quot;/&quot;&gt;
                                # 定义拦截器、定义拦截器栈（加入拦截器）
                                ## 拦截器栈中可以加栈
        o-&gt; &lt;default-interceptor-ref name=&quot;&quot;&gt; 默认拦截器（可以用于验证用户登录）
        o-&gt; &lt;global-results&gt; 全局结果（用来跳转全局异常等）
        o-&gt; &lt;global-exception-mappings&gt; 全局异常
        o-&gt; &lt;action name=&quot;&quot; class=&quot;&quot; method=&quot;&quot;&gt;
                默认值
                        class=&quot;com.opensymphony.xwork2.ActionSupport&quot;
                        method=&quot;execute&quot;
                # name=&quot;aa&quot;时 .../aa.do的请求匹配到该方法执行
                ## class 是类字节码路径，method是其中的方法名
        o-&gt; &lt;param name=&quot;aaa&quot;&gt;bbb&lt;/param&gt;
                调用 &lt;action&gt;标签中对象的实例的方法：setAaa(&quot;bbb&quot;);
        o-&gt; &lt;result name=&quot;&quot; type=&quot;&quot;&gt;/ok.jsp
                默认值
                        name=&quot;success&quot;
                        type=&quot;dispatcher&quot;
                # name=&quot;success&quot;时，映射的method返回&quot;success&quot;时进入该result处理
                ## type是返回方式 ，如dispatcher redirect等
                        type的返回类型
                                dispatcher : 转发到jsp页面
                                redirect : 重定向到 jsp html 等页面
                                chain : Action 类之间的转发
                                redirectAction : Action 类之间的重定向
                                stream : 以 inputStream 的数据类型返回
                                        stream的参数                        # 可以从struts-default.xml文件中对应的stream参数对应的类的源码中查看其中的set方法找到要写参数的名称
                                                &lt;param name=&quot;contentType&quot;&gt;image/pjpeg&lt;/param&gt;                # 下载文件的类型                  另外如text/html; charset=utf-8返回给ajax异步数据
                                                &lt;param name=&quot;bufferSize&quot;&gt;2048&lt;/param&gt;                # 缓冲byte[]的大小，单位字节
                                                &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${uuidFileName}&lt;/param&gt;                # 设置下载响应头，只的下载时才设置。${uuidFileName}是一个OGNL表达式
                                                &lt;param name=&quot;inputName&quot;&gt;imageStream&lt;/param&gt;        # 框架调用传递给result标签结果字符串的对象中的getImageStream()方法，来获取InputStream流对象
                                                # 返回stream类型不指定返回的路径
                ## 标签间的内容：/ok.jsp 是响应的路径
        o-&gt; &lt;result name=&quot;input&quot; type=&quot;&quot;&gt;/ok.jsp
                type中的参数                        # 可以从struts-default.xml配置文件中查到
                        dispatcher        # 转发
                        redirect        # 重定向
                        chain                # Action类之间转发，需要加参数，参数的名字
                                                ## ：struts-default.xml文件中找到&quot;chain&quot;对应的类，按快捷键ctrl + shift + T 关联类的源码文件，查找set方法改名即可
                                &lt;param name=&quot;actionName&quot;&gt;to&lt;/param&gt;
                                        # action标签的 name属性值
                                &lt;param name=&quot;namespace&quot;&gt;/&lt;/param&gt;
                                        # action的名称空间
                        redirectAction                # Action类之间重定向

                # 各种拦截器不通过时默认的返回input，同时向request作用域中加入了相关错误信息供struts2的jsp标签进行显示
                ## 处理 返回值是input的返回信息跳转，就是处理拦截器拦截后的信息跳转
        o-&gt; &lt;exception-mapping result=&quot;nullJsp&quot;        exception=&quot;java.lang.NullPointerException&quot; /&gt;
                # &lt;action&gt;标签中的局部异常
                ## &lt;action&gt;捕获标签中的实例运行抛出的异常,然后改为 返回执行结果为&quot;nullJsp&quot;的字符串交给本&lt;action&gt;标签中相应的&lt;result&gt;标签来处理
        o-&gt; &lt;interceptor-ref name=&quot;loginInterceptor&quot;/&gt;
                默认值
                        name=&quot;defaultStack&quot;
                # 指定在本&lt;action&gt;标签中使用的拦截器或拦截器栈
                ## 当指定了拦截器或拦截器栈以后，默认的defaultStack将会没有,此时defaultStack中的18个拦截器将不再执行

    使用：OGNL对象图导航语言对标签中的路径进行动态设置

# 验证
    struts2验证
        1.代码式: validate(),validateXxx()方法
                        # 单个验证与全部验证都存在时先单个验证，再全部验证，验证信息都加入验证信息集合
        2.声明式: Action类名-validation.xml
                                Action类名-&lt;action标签的name属性&gt;-validation.xml
                            # 单个验证与全部验证都存在时先全部验证，再单个验证，验证信息都加入验证信息集合
                    # 先声明验证，后代码验证
    参数驱动
        1.属性驱动: action中用属性收集表单参数
        2.模型驱动: javaBean收集参数

    代码式（属性驱动）：
        步骤
        1.需要验证的Action类  继承 ActionSupport 类
                        # ActionSupport 类 实现了Validateable接口，该接口是验证接口

        2.写验证方法
                1&gt; public void validate()
                                # 方法重写（通用验证方法，本类中的所有其它方法执行前都执行）

                2&gt; public void validateXxxMethod()
                                # 或者自定义专用验证方法 xxxMethod为要验证的方法名，首字母要大写

                        # 注意，通用、专用验证方法同时存在时，先执行专用验证方法，再执行通用验证方法
                        ## ，但是通用验证方法的错误消息无法加入到返回的错误集合中

                3&gt; this.addFieldError(&quot;password&quot;,&quot;密码必填&quot;);

                        # 验证方法中添加错误信息到错误信息集合
                        ## addFieldError(&quot;&quot;,&quot;&quot;)是从ActionSupport父类中继承的方法

        3.jsp文件中通过验证标签：
                        &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot;%&gt;
                        &lt;s:fielderror/&gt;                # 显示所有错误信息
                        &lt;s:fielderror fieldName=&quot;password&quot;/&gt;
                显示验证出错信息

        4.xml配置
            &lt;!-- 验证错误信息处理 --&gt;
                &lt;result name=&quot;input&quot; type=&quot;dispatcher&quot;&gt;
                        /error.jsp
                &lt;/result&gt;
                        # 写在需要验证的方法对应的标签中，验证错误时验证方法会优先返回&quot;input&quot;字符串


    声明式（属性驱动）：
        1.验证Action类继承ActionSupport
        2.验证Action类目录下配置文件
            Action类名-validation.xml
            Action类名-&lt;action标签的name属性&gt;-validation.xml
                # 放入此名字的配置文件就相当于加了验证，不需要做其它事情
                ## ，相当于分别向Actioin类中加入了validate()validateXxx()方法进行了相应验证
                文件内容
                &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
                    &lt;!DOCTYPE validators PUBLIC
                    &quot;-//Apache Struts//XWork Validator 1.0.3//EN&quot;
                    &quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&quot;&gt;
                    &lt;validators&gt;
                            &lt;field name=&quot;username&quot;&gt;                # 要验证的属性
                                    &lt;field-validator type=&quot;requiredstring&quot;&gt;
                                            &lt;message&gt;用户名必填&lt;/message&gt;
                                    &lt;/field-validator&gt;
                            &lt;/field&gt;
                            &lt;field-validator type=&quot;regex&quot;&gt;
                                    &lt;param name=&quot;expression&quot;&gt;^[\u3447-\uFA29]+$&lt;/param&gt;
                                    &lt;message&gt;UserAction2-validation==&gt;必须写中文&lt;/message&gt;
                            &lt;/field-validator&gt;
                    &lt;/validators&gt;

                            # xml文件的头在 xwork-core-2.3.1.1.jar包的
                                    xwork-validator-1.0.3.dtd中复制
                            ## 关联约束在
                                    \struts-2.3.15.1\src\xwork-core\src\main\resources\xwork-validator-1.0.3.dtd文件
                            ## &lt;field-validator type=&quot;&quot;&gt;的约束类型在xwork-core-2.3.1.1.jar包的
                                            /com/opensymphony/xwork2/validator/validators/default.xml文件中
                                                    # 16个规则
                                                    ## type=&quot;regex&quot;相当于调用了default.xml文件中配置的
                                                        ## RegexFieldValidator类的 setExpression方法
        3.jsp文件中通过验证标签（同上）
        4.xml配置（同上）
            # 出错信息
                1.验证文件名写错，无提示，不验证
                2.&lt;field-validator type=&quot;&quot;&gt;写错，有明显提示
                2.&lt;field name=&quot;salaryy&quot;&gt;写错，获取的salaryy为空。

    声明式（模型驱动）
            1.创建bean对象，bean对象中封装属性
            2.验证Action类继承ActionSupport类，声明bean对象实例
            3.action类同目录 中  ：Action类名-&lt;action标签的name属性&gt;-validation.xml
                            # &lt;field-validator type=&quot;visitor&quot;&gt;
                    # bean类同目录中：bean类名-validation.xml配置验证文件
            4.jsp文件请求参数改为：action类中bean对象名.bean对象封装的属性名。用&lt;s:fielderror/&gt;标签得到返回的错误信息
            5.xml配置（同上）

    原理
    StrutsPreparedAndExecuteFilter
        1.注入参数
                setUsername()
            setPassword()
        2.验证方法：validate()或validateXxx()
                        验证配置文件中验证：Action类名-validation.xml
        3.转发：根据验证成功或失败返回消息
                        验证集合无错误消息成功Action --&gt; execute或同签名的方法
                        验证集合有错误消息失败&lt;result name = &quot;input&quot; type=&quot;dispatcher&quot;
                                            register.jsp/login.jsp
# 过滤器
    StrutsPrepareAndExecuteFilter
        中查看Dispathcer类，从中找到配置struts-default.xml,struts-plugin.xml,struts.xml值的属性DEFAULT_CONFIGURATION_PATHS
        查找引用该属性的方法为init_TraditionalXmlConfigurations
        查看引用该方法的方法为init
        回头看StrutsPrepareAndExecuteFilter中初始化dispatcher对象的方法initDispatcher
                其中调用了dispatcher.init();方法来配置dispatcher
        由此可以知道struts在启动时加载了struts-default.xml,struts-plugin.xml,struts.xml配置文件
# 拦截器
    struts-core-2.3.1.1.jar包中的
        struts-default.xml文件中
                定义了32个interceptor（拦截器）
                        i18n    # 国际化
            token  # 表单重复提交
            validation  # 验证
            params  # 参数拦截器,向Action类中注入参数
            cookie
        interceptor-tack    # 拦截栈
                # 拦截栈中的拦截器的先后顺序有影响
                basicStack
            defaultStack    # 每个http请求都会经过该拦截栈
                            ## 其中的18个拦截器, &lt;default-interceptor-ref&gt;中定义
    原理
            拦截器仿照过滤器建立，内部实现原理是完全相同的
    执行流程
            拦截器构构造函数 -&gt; action构造函数 -&gt; 拦截器1 in -&gt; 拦截器2 in -&gt; demo -&gt; 拦截器2 out -&gt; 拦截器1 out
        exception拦截器最先进，最后出
    自定义拦截器
        1.定义Action类，继承Interceptor接口，重写生命周期方法
            public LoginInterceptor() {
            }
            public void destroy() {
            }
            public void init() {
            }
            public String intercept(ActionInvocation invocation)  {
            }
        2.配置struts.xml文件
            1&gt; 定义拦截器、拦截器栈
                &lt;interceptors&gt;
                    &lt;interceptor name=&quot;loginInterceptor&quot; class=&quot;interceptor.LoginInterceptor&quot;/&gt;
                    &lt;interceptor name=&quot;roleInterceptor&quot; class=&quot;interceptor.RoleInterceptor&quot;/&gt;
                    &lt;interceptor-stack name=&quot;crmStack&quot;&gt;
                        &lt;interceptor-ref name=&quot;loginInterceptor&quot;&gt;&lt;/interceptor-ref&gt;
                        &lt;interceptor-ref name=&quot;roleInterceptor&quot;&gt;&lt;/interceptor-ref&gt;
                    &lt;/interceptor-stack&gt;
                &lt;/interceptors&gt;
            2&gt; &lt;action&gt;标签中声明用到的拦截器或拦截器栈
                    &lt;interceptor-ref name=&quot;loginInterceptor&quot; /&gt;                # 此时默认的defaultStack拦截器栈会被替代掉
    自定义方法过滤拦截器
        # MethodFilterInterceptor继承AbstractInterceptor继承Interceptor，前两个是struts自己实现的自己的包装类
        ## 原理：自己实现intercept方法，实现对方法名的过滤。如果符合通过条件，则执行自己的doIntercept方法。所以要求用户重写doIntercept方法实现业务逻辑
        &lt;interceptor name=&quot;aloginInterceptor&quot; class=&quot;cn.it.shop.interceptor.AloginInterceptor&quot;&gt;
            &lt;param name=&quot;excludeMethods&quot;&gt;*$&lt;/param&gt;                # 除了*$匹配的方法都执行此拦截器
                    ## includeMethods为包含匹配的方法执行拦截器
        &lt;/interceptor&gt;
    生命周期
        部署时初始化，每次符合&lt;action&gt;的请求时，执行拦截器
    拦截器Action 类
        o-&gt; 继承Interceptor 接口
        o-&gt; 重写生命周期方法
            String intercept(ActionInvocation invocation)方法中调用
                invocation.invoke() 放行
                invocation.getAction()得到当前的Action类
                invocation.getStack()得到值栈中的栈
                    # invocation用于调试18个拦截器
    具体拦截器
        struts-default.xml 文件中定义了32种拦截器
                alias
        autowiring
        chain
        conversionError
        cookie
        clearSession
        createSession
        debugging
        execAndWait
        exception
        fileUpload                                # 只用来验证已经注入的文件是否合格，合格则通过，不合格则不执行action类中对应请求的方法
        i18n
        logger
        modelDriven                                # 用于检查action类是否实现ModelDriven&lt;T&gt;接口，然后调用getModel()方法注入得到的对象到栈的项端。
        scopedModelDriven
        params                                        # 注入参数用，包括注入文件（级联注入文件的ContentType与FileName）
        actionMappingParams
        prepare
        staticParams
        scope
        servletConfig                                # 向自定义的实现RequestAware等接口的Action类（一般是BaseAction类）中注入request等相应的map对象
        timer
        token                                                # 防止重复提交
        tokenSession
        validation                                # 验证
        workflow
        store
        checkbox
        profiling
        roles
        annotationWorkflow
        multiselect
    数据传递
        o-&gt; 拦截器不会向其它拦截器中注入参数，所以自定义拦截器中了参数要从request中获取
        o-&gt; 如果想 显式的引用了自己的拦截栈，默认的拦截栈就不引用了，要自己引用，其中的注入参数拦截器向action类中注入参数
    技巧
        &lt;interceptor-stack name=&quot;defaultStack&quot;&gt;    # 对defaultStack进行替换，在它前面添加自定义的拦截器
        &lt;interceptor-ref name=&quot;aloginInterceptor&quot;/&gt;
        &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;
    拦截器中的ActionInvocation对象
        可以得到ActionContext

# 文件处理
## 上传
    struts2文件上传步骤
        1.编写jsp文件
                1&gt; post方式提交
                2&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot;/&gt; 要添加name属性
                3&gt; post表单上传的编码方式是enctype=&quot;multipart/formdata&quot;
        2.创建Action类，不必继承任何类(但是如果不继承ActionSupport类的话，拦截器将不会返回提示消息)
                1&gt; 定义参数        # 如果不接收上传文件名字符串数组而从文件对象中获取文件名的话，得到的文件名将会是乱码
                        private File[] image;                                                # 字段名
                        private String[] imageContentType;                        # 文件类型
                        private String[] imageFileName;                                # 文件名
                        private String uploadPath;
                                        # 前三个参数可以不是数组，在 struts-default.xml配置文件fileUpload拦截器对应的源码中可以找到定义规则：
                                                &lt;li&gt;[File Name] : File - the actual File&lt;/li&gt;
                                                &lt;p/&gt; &lt;li&gt;[FileName]ContentType : String - the content type of the file&lt;/li&gt;
                                                &lt;p/&gt;&lt;li&gt;[File Name]FileName : String - the actual name of the file uploaded(not the HTML name)&lt;/li&gt;
                                        # uploadPath是我们自定义的配置文件中注入过来的文件存储位置

                2&gt; 写execute方法保存文件到路径，返回成功消息
        3.Action类的配置文件，include到src/struts.xml文件中
                        1&gt; &lt;action&gt;标签中配置name=&quot;input&quot;的标签&lt;result&gt;来返回出错消息
                        2&gt; &lt;action&gt;标签中用param标签注入文件存储路径：uploadPath 底层执行setUploadPath()方法
                        3&gt; &lt;action&gt;标签中通过&lt;interceptor-ref name=&quot;fileUpload&quot;&gt;标签对上传文件进行参数上的限定
                                1&gt; &lt;param name=&quot;maximumSize&quot;&gt; 单个文件的最大尺寸(字节)
                                2&gt; &lt;param name=&quot;allowedExtensions&quot;&gt; 文件扩展名
                                3&gt; &lt;param name=&quot;allowedTypes&quot;&gt; 文件实际类型，如image/jpeg，可从tomcat配置文件web.xml中查找
        4.配置返回消息的信息
                ：src/struts.properties文件中
                        struts.custom.i18n.resources=struts                # 解锁自/org/apache/struts2/default.properties总配置文件
                                        # 加载自己，=后面是参照src/目录的相对路径 ，省略掉.properties扩展名
                        struts.multipart.maxSize=2097152                #  解锁自/org/apache/struts2/default.properties总配置文件
                                        # 设置上传文件总量的大小
                        struts.messages.error.file.too.large=\u6587\u4EF6\u592A\u5927\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                        struts.messages.error.content.type.not.allowed=\u6587\u4EF6\u7C7B\u578B\u4E0D\u6B63\u786E\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                        struts.messages.error.file.extension.not.allowed=\u6269\u5C55\u540D\u4E0D\u6B63\u786E\: {0} &quot;{1}&quot; &quot;{2}&quot; {3}
                                        # 覆盖/org/apache/struts2/default.properties总配置文件的响应消息,=后面是中文的unicode编码的iso8859-1的表示形式，通过视图可以直接配置，也可以用java/bin目录下的native2ascii.exe工具进行转码

    多文件上传
        出现有多个文件共同上传时，文件拦截器会出现一错全错的情况，这时我们利用struts的一个
                小bug---文件拦截不成功也调用action类的setXxx方法传入文件，从set函数中对文件进行筛选和转存
                这时文件拦截器已经形同虚设，一点作用也不起了。

    原理过程
        1.上传请求经过struts2的过滤器匹配扩展名
        2.按src/struts.xml文件中声明的配置包映射的名称空间映射到配置包
        3.根据action标签的name属性匹配名称空间与扩展名之间的“文件名”,映射到该action标签
                1&gt; 经过多层拦截器
                2&gt; 用param标签注入文件存储路径
                3&gt; 通过&lt;interceptor-ref name=&quot;fileUpload&quot;&gt;标签对上传文件进行参数上的限定
                2&gt; 执行action标签对应类的方法，该方法返回的返回的字符串进行响应

    默认配置
        1.defaultStack拦截栈中的fileUpload拦截器进行处理
        2.default.properties配置文件中 对multipart的上传方式进行了配置
                struts.multipart.parser=jakarta                  # struts使用了第三方的jakerta来给上传文件解码
                struts.multipart.saveDir=                      # 缓存文件的临时目录，不填默认是
                                                                                        ## work/catalina/localhost/web工程名/upload_.....00000..tmp
                struts.multipart.maxSize=2097152      # 默认支持的上传文件的大小 (字节，2m)，是总大小
        3.多数服务器自己删除缓存文件
## 下载
    用传递类型为stream 来返回要下载的文件
    写法
        &lt;result name=&quot;success&quot; type=&quot;stream&quot;&gt;
            &lt;!-- 下载文件的类型 --&gt;
            &lt;param name=&quot;contentType&quot;&gt;image/pjpeg&lt;/param&gt;
            &lt;!-- byte[]的大小，单位字节 --&gt;
            &lt;param name=&quot;bufferSize&quot;&gt;2048&lt;/param&gt;
            &lt;!-- 设置下载响应头，${uuidFileName}是一个OGNL表达式，不是EL表达式 --&gt;
            &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${uuidFileName}&lt;/param&gt;
            &lt;!-- 框架调用getXxx()方法，来获取InputStream流对象 --&gt;
            &lt;param name=&quot;inputName&quot;&gt;imageStream&lt;/param&gt;
        &lt;/result&gt;
            # 与其它同样，要注入的参数从stream类型对应的类中可以进行查看
    显示与下载的编码问题
        o-&gt; 设置tomcat/conf/server.xml
            &lt;Connector port=&quot;8080&quot; .. URIEncoding=&quot;utf-8&quot;/&gt;
        o-&gt; 提交下载请求用post方式，struts框架自动给post请求编码解码
</code></pre>
<h1 id="数据">
  数据
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae">#</a>
</h1>
<h2 id="日志-1">
  日志
  <a class="anchor" href="#%e6%97%a5%e5%bf%97-1">#</a>
</h2>
<pre><code>scribe
    facebook出品
    特点
        支持nfs存储
    结构
        scribe agent
            向scribe发送数据
        scribe
            接收数据，不同topic 的数据发送给不同的store中
        存储系统(store)
            file, buffer, network, bucket, null, thriftfile, multi
chukwa
    # apache出品，hadoop系列产品
flume
    cloudera出品
    特点
        可靠性(节点故障时，日志传送到其他节点)
            三种级别
                end-to-end 发送前写磁盘，成功时删除
                store on failure 失败返回时写磁盘
                best effort 不确认数据是否成功
        可扩展性
            agent collector storage三层架构，每层可扩展。
                agent: 将数据源数据发送给collector
                collector: 将多个agent数据汇总后, 加载到storage中
                storge: 存储系统, 可以是file, hdfs, hive, hbase等
            agent collector 由master统一
logstash
    # 分布式日志收集，需结合kafka
</code></pre>
<h2 id="爬虫">
  爬虫
  <a class="anchor" href="#%e7%88%ac%e8%99%ab">#</a>
</h2>
<pre><code>cheerio
    # node解析html，如jquery
scrapy-redis
    # python 分布式爬虫框架
phantomjs
    # js浏览器模拟框架
</code></pre>
<h2 id="分析">
  分析
  <a class="anchor" href="#%e5%88%86%e6%9e%90">#</a>
</h2>
<pre><code>pandas
    # python数据分析
</code></pre>
<h2 id="计算">
  计算
  <a class="anchor" href="#%e8%ae%a1%e7%ae%97">#</a>
</h2>
<pre><code>druid
    # apache
    特点
        分布式, 扩展性强
        高可用，可回滚
        内存, 时序数据库
        亚秒级OLAP,  实时分析
        多租户
spark
stream
hadoop
</code></pre>
<h1 id="搜索">
  搜索
  <a class="anchor" href="#%e6%90%9c%e7%b4%a2">#</a>
</h1>
<pre><code>分类
    垂直搜索引擎
        针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。
    通用搜索引擎
        通过关键字的方式实现的，是语义上的搜索，返回的结果倾向于知识成果，比如文章，论文，新闻等
        通用搜索引擎的信息量大、查询不准确、深度不够
        通用搜索引擎的海量信息无序化

部分
    １.索引
    ２.分词
    ３.搜索

compass
    # 基于lucene
nutch
    # 基于lucene
sunspot
    # 基于Rsolr，以dsl结构用ruby调solr
sphinx
    # 基于sql的全文检索引擎
</code></pre>
<h2 id="lucene">
  lucene
  <a class="anchor" href="#lucene">#</a>
</h2>
<pre><code># 原理
    block k-d tree
    倒排索引
        词典
            排序数组
                # 为了二分查找
                # 实现简单，性能差
            哈希表
                # 性能好，占内存大
            跳跃表
                # 内存小且可调节, 模糊查询不好
            B/B+树
                # 磁盘索引 ，更新方便，检索慢
            trie树
                # 效率与字符串长度有关，只适合做英文词典
            dat
                # 可做中文词典，内存占用小
            fst
                # 共享前缀，内存占用小，要求输入有序，不易更新
                内存存前缀索引、磁盘存后缀词块
        倒排表
        正向文件
            # 行式存储，原始文档
        doc-values
            # 列式存储，文档号到值的映射
    文件指纹

# 概念
    index
        # 一个倒排表，对应一个目录
    segment
        # index的存储单元，包含多个文档
    document
        # 创建单位
    field
        # 文档里的键值对
    term
        # 分词后的字符串
    analyzer
        tokenizer
            # 切分文本到索引单元
        tokenfilter
            # 对token预处理
# 常识
    特性
        索引
        高亮
        命中率排序
        分词
    与数据库的区别：数据库注重存储、全文检索注重查询
    其它搜索：多媒体搜索
    索引库(文件夹 或 内存中)：
        只存储了商品的基本信息
         索引库与数据库定时同步
        索引库 -&gt; document -&gt; field                # field是键值对,值只能存数据
                同步
        IndexWriter:addDocumnet(),delteDocument(),updateDocument()
                查询
                        IndexSearch:search(),get()
        Field的内部结构
                    # 不存不索引会报错
        Store:控制此Field字段是否存储到索引库中
        Index:是否建立索引（索引不区分大小写,过滤词不创建索引）
            NO:不建立索引，可以通过field的key查到，但是不能通过关键字查询到
            NOT_ANALYZED:建立索引，但是不分词
            ANALYZEd:建立索引又分词
# 使用到的对象
    Directory
    Analyzer
        TokenStream tokenStream = analyzer.tokenStream(&quot;eldName&quot;,new StringReader(&quot;测试字符串&quot;))
        while(tokenStream.incrementToken()){
                TermAttribute termAttribute = tokenStream.getAttribute(TermAttribute.class);
                System.out.println(termAttribute.term());
        }                # 使用分词器测试分词
    Document
        add(Field)
        document = indexSearcher.doc(ScoreDoc)
        get(String)                # 通过key查找value
    IndexWriter
        IndexWriter(directory,analyzer,MaxFieldLength.LIMITED);       # LIMITED限定Field的数量(源码中规定默认值)
        addDocument(Document)
        commit()
        close()                        # 自带commit()
        rollback()
    IndexSearcher
    QueryParser
        QueryParser(Version.LUCENE_30,&quot;name&quot;,analyzer)
    Query
        query = parser.parse(用户传递的字符串);
        query = parser.parseMultiField(String [], 用户传递的字符串);
    TopDocs
        topDocs = indexSearcher.search(query, 10);                # 10是期望的结果数
                                                                                                        ## 最终查询到的结果数是：期望结果数与实际结果数的最小值
        totalHits                # 命中的结果数
    ScoreDoc
        ScoreDoc [] scoreDocs = topDocs.scoreDocs;
        scoreDoc.score                # 命中率积分
        scoreDoc.doc                # 命中文档编号，该编号由lucene自动生成
    Term                # 索引项
        Term(&quot;field中的key&quot;,&quot;field中value解析出的关键字&quot;)
# 索引的结构
    Term(&quot;key&quot;,&quot;value&quot;)[0,3,4]                        # key 为对应的field中的&quot;key&quot;,value对应的是解析field的&quot;value&quot;出的关键字
                                                                                ## []中的内容为匹配的文档编号，该编号为系统自动生成的
# 注意
    lucene创建索引时field的key都可以重复，没有主键方面的限制。但是实际应用时要求我们为document有唯一的标识“主键”field,便于对每个document进行更新与删除
# 使用
    包：IKAnalyzer,lucence-analyzer(英文分词，不需要),memory,core,highlighter
    工具：lukeAll 用来查看索引库
    添加、查询、删除、修改
    抽取配置类（构造方法私有化）
        Configuration
            维护了directory与analyzer
        DocumentUtil
            goodsToDocument(Goods)
            documentToGoods(Document)
        LuceneUtil
            维护了indexWriter与indexSearcher
            注意
                    1.indexWriter在static代码块中初始化
                    2.getIndexWriter
        LuceneService
            用indexWriter与indexSearcher处理业务逻辑
            添加
                indexWriter.addDocument(Document)
                indexWriter.rollback()
            删除
                indexWriter.deleteDocument(Term)
                indexWriter.optimize()                # 删除document的时候同步索引库，没有设置的话只是删除document，但是索引中还是可以查到
            更新
                indexWriter.updateDocument(Term,Document)
                indexWriter.optimize()                # 更新是先删除再添加（所以如果updateDocument(Term,Document)中匹配多个Document时，会出现删除了多个Document,而添加了一个Document的情况）
            查询
                QueryParser parser = new QueryParser(Version.LUCENE_30, &quot;field中的key&quot;, analyzer);
                Query query = IKQueryParser.parseMultiField(new String[]{&quot;name&quot;,&quot;remark&quot;}, &quot;ee&quot;);                # 多字段查询，IKAnalyzer特有
                    #　多字段查询到的第二个字段的结果，在转换高管时（调用getBestFragment时）只会对该方法指定的一个字段进行匹配，如果该字段不匹配时（但是第二个字段匹配），则会返回空。
                    ## 针对这一个bug,在getBestFragment处理匹配的结果返回空时，不使用空而直接返回没有高亮的字符串即可。
                parser.parse(用户传递的字符串);
                TopDocs topDocs = indexSearcher.search(query, 3);        # 3是期望结果数
                ScoreDoc [] scoreDocs = topDocs.scoreDocs;
                Document document = indexSearcher.doc(scoreDoc.doc);                scoreDoc.doc得到文档编号
                分页查询：
                    传递当前页码与一页记录数
                    利用topDocs.totalHits得到总记录数
                    查询本页与前面所有页的期望数据量，然后只截取本页的文档编号，得到document并返回数据

# 分词器
    IKAnalyzer
        配置文件
            src/IKAnalyzer.cfg.xml中配置
                &lt;properties&gt;
                    &lt;entry key=&quot;ext_dict&quot;&gt;/mydict.dic&lt;/entry&gt;                 # 配置自己的字典（不分词）
                    &lt;entry key=&quot;ext_stopwords&quot;&gt;/ext_stopword.dic&lt;/entry&gt;                 # 配置跳过的字
                &lt;/properties&gt;
        Query query = IKQueryParser.parse(&quot;name&quot;,name);                # IKAnalyzer特有
# 排序
    Directory directory = FSDirectory.open(new File(&quot;d:/lucene&quot;));
    IndexSearcher indexSearcher = new IndexSearcher(directory);
    Query query = IKQueryParser.parse(&quot;name&quot;,&quot;cc&quot;);
    Sort sort = new Sort(new SortField(&quot;id&quot;, SortField.INT,true));                # 这里可以排序多个字段
        # 参数1：&quot;id&quot;是排序的field字段,参数2：是字段内容的类型,参数3 true代表降序排列
        ## 此时命中率不再计算（因为不按命中率排序）
        ## 排序的field必须建立索引
    indexSearcher.search(query, null,10,sort);
高亮
    导入包:highlight与memory
    Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(&quot;&lt;font color='red'&quot;,&quot;&lt;/font&gt;&quot;),new QueryScorer(query));
    highlighter.setTextFragmenter(new SimpleFragmenter(10));                # 限制字符长度
    ..
    String result = highlighter.getBastFragment(analyzer,&quot;name&quot;,doc.get(&quot;name&quot;));
        # 返回高亮处理字符串
        ## 参数1：解析用户输入词的分词器,参数2：是要查询的field的key(没有用)，参数3：field的value
</code></pre>
<h2 id="solr">
  solr
  <a class="anchor" href="#solr">#</a>
</h2>
<pre><code>介绍
    基于lucene
    搜索服务器，http请求提交和返回xml
功能
    丰富了查询语言
    实现可配置、可扩展
    优化了性能
    提供了管理界面
    缓存功能
    垂直搜索
    高亮
    data schema定义字段
</code></pre>
<h2 id="elasticsearch">
  elasticsearch
  <a class="anchor" href="#elasticsearch">#</a>
</h2>
<pre><code>介绍
    基于lucene
性能
    第一次查秒级响应(5-10秒)，放到文件系统缓存(filesystem cache)
    再查命令缓存毫秒级响应                              # 热点数据要预热
    文件系统缓存(内存中分配)和数据量同样大，才有效率        # 冷热分离

    分页，会查前面所有数据                              # 用scroll api, 快照 + 游标
</code></pre>
<h1 id="权限">
  权限
  <a class="anchor" href="#%e6%9d%83%e9%99%90">#</a>
</h1>
<h2 id="shiro">
  shiro
  <a class="anchor" href="#shiro">#</a>
</h2>
<pre><code>功能
    认证
    授权
    加密
    会话管理
    Web集成
    缓存
组件
    Subject     # 当前用户,绑定到SecurityManager
    SecurityManager     # 门面模式，管理组件
    Realms      # 连接认证数据(用户、角色、权限)
    Authenticator   # 认证principals和credentials
    Authorizer  # 校验权限
    SessionManager      # 异构客户端
控制方式
    url
    注解
    代码
    页面标签
模块
    Authenticator
        # SecurityManager继承Authenticator
        public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)  throws AuthenticationException;
    permission
        概念
            subject
            resource
            permission
            role
                隐式角色
                显示角色
        配置
            shiro.ini
                [users]
                zhang=123, role1, role2                # 用户名=密码, 角色1, 角色2
        判断角色
            o-&gt;
                subject.hasRole(&quot;admin&quot;);
            o-&gt;
                @RequiresRoles(&quot;admin&quot;)
                @RequiresRoles(value={“admin”, “user”}, logical= Logical.AND)
                    # 表示当前Subject需要角色admin和user。
            o-&gt;
                &lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;/shiro:hasRole&gt;
        权限注解
            @RequiresAuthentication
                # 表示当前Subject已经通过login进行了身份验证；即Subject. isAuthenticated()返回true。
            @RequiresUser
                # 表示当前Subject已经身份验证或者通过记住我登录的。
            @RequiresGuest
                # 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。
            @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)
                # 表示当前Subject需要权限user:a或user:b。
    credential
        散列
            String str = &quot;hello&quot;;
            String salt = &quot;123&quot;;
            //内部使用MessageDigest
            String simpleHash
        密码生成工具
            //输入明文密码得到密文密码
            String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;
            //匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）
            boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);
    filter
        NameableFilter                        ＃根据名字找到相应的拦截器实例
        OncePerRequestFilter                # 控制开启、关闭拦截器实例
        ShiroFilter                        # 安全控制
        AdviceFilter                        # aop
            preHandle                        # 前置增强
            postHandle                        # 后置增强
            afterCompletion                # 后置最终增强(异常也执行，相当于finally的概念)
        PathMatchingFilter                # 匹配请求路径
        AccessControlFilter                # 允许或拒绝访问，拒绝时如何处理
    jsp标签
        &lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;

        &lt;shiro:guest&gt;
        欢迎游客访问，&lt;a href=&quot;${pageContext.request.contextPath}/login.jsp&quot;&gt;登录&lt;/a&gt;
        &lt;/shiro:guest&gt;

        &lt;shiro:user&gt;
        欢迎[&lt;shiro:principal/&gt;]登录，&lt;a href=&quot;${pageContext.request.contextPath}/logout&quot;&gt;退出&lt;/a&gt;
        &lt;/shiro:user&gt;
            # 用户已经身份验证/记住我登录后显示相应的信息。

        &lt;shiro:authenticated&gt;
            用户[&lt;shiro:principal/&gt;]已身份验证通过
        &lt;/shiro:authenticated&gt;
            # 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的。

        &lt;shiro:notAuthenticated&gt;
            未身份验证（包括记住我）
        &lt;/shiro:notAuthenticated&gt;
            # 用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证。

        &lt;shiro: principal/&gt;
            # 显示用户身份信息，默认调用Subject.getPrincipal()获取
            &lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;
            &lt;shiro:principal property=&quot;username&quot;/&gt;

        &lt;shiro:hasRole name=&quot;admin&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有角色admin&lt;br/&gt;
        &lt;/shiro:hasRole&gt;

        &lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt;
        &lt;/shiro:hasAnyRoles&gt;

        &lt;shiro:lacksRole name=&quot;abc&quot;&gt;
            用户[&lt;shiro:principal/&gt;]没有角色abc&lt;br/&gt;
        &lt;/shiro:lacksRole&gt;
                        # 如果当前Subject没有角色将显示body体内容。

        &lt;shiro:hasPermission name=&quot;user:create&quot;&gt;
            用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt;
        &lt;/shiro:hasPermission&gt;

        &lt;shiro:lacksPermission name=&quot;org:create&quot;&gt;
            用户[&lt;shiro:principal/&gt;]没有权限org:create&lt;br/&gt;
        &lt;/shiro:lacksPermission&gt;
    session
        得到会话
            login(&quot;classpath:shiro.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);
            Subject subject = SecurityUtils.getSubject();
            Session session = subject.getSession();
        api
            Session
                getId()
                getHost()                # 调用HostAuthenticationToken.getHost(), 得到主机地址
                getTimeout()
                setTimeout(1000)
                getStartTimestamp()
                setLastAccessTime()
                touch()                        # 更新会话最后访问时间
                stop()                        # 销毁会话, Subject.logout()与HttpSession.invalidate()会自动调用该api
                setAttribute(&quot;key&quot;, &quot;123&quot;)
                getAttribute(&quot;key&quot;)
                removeAttribute(&quot;key&quot;)
            SecurityManager
                Session start(SessionContext context)
                Session getSession(SessionKey key) throws SessionException
            WebSessionManager
                boolean isServletContainerSessions();                # 是否使用Servlet容器的会话
            ValidatingSessionManager
                void validateSessions();                                # 验证所有会话是否过期
    cache
        接口
            Cach&lt;K, V&gt;
            CacheManager
            CacheManagerAware
        ini配置
            userRealm.cachingEnabled                        # 启用缓存，默认false
            userRealm.authenticationCachingEnabled        # 启用身份验证缓存，即缓存AuthenticationInfo信息，默认false
            userRealm.authenticationCacheName                # 缓存AuthenticationInfo信息的缓存名称
            userRealm. authorizationCachingEnabled        # 启用授权缓存，即缓存AuthorizationInfo信息，默认false
            userRealm. authorizationCacheName                # 缓存AuthorizationInfo信息的缓存名称
            securityManager.realms=$userRealm

            cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager
            cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml
            securityManager.cacheManager=$cacheManager

            sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager
            securityManager.sessionManager=$sessionManager
    rememberme
    ssl
        o-&gt; keytool -genkey -keystore &quot;D:\localhost.keystore&quot; -alias localhost -keyalg RSA
            # jdk自带的生成证书工具(包含证书/公钥/私钥）
        o-&gt; 设置tomcat server.xml
            &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;
            maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
            clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;
            keystoreFile=&quot;D:\localhost.keystore&quot; keystorePass=&quot;123456&quot;/&gt;
        o-&gt;
    jasig cas
api
    Subject: 主体, 如用户
    SecurityManager: 安全管理器, 管理subject
    Realm: 权限数据域

    授权
        对象流程
            Subject.isPermitted -&gt; SecurityManager -&gt; Authorizer
        对象
            ModularRealmAuthorizer        # 多realm授权
            PermissionResolver                # 解析权限字符串到Permission实例
            RolePermissionResolver                # 从角色得到权限集合
配置
    参数
        filterChainDefinitions
            rest：比如/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user：method] ,其中method为post，get，delete等。

            port：比如/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal：//serverName：8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。

            perms：比如/admins/user/**=perms[user：add：*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，比如/admins/user/**=perms[&quot;user：add：*,user：modify：*&quot;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。

            roles：比如/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，比如/admins/user/**=roles[&quot;admin,guest&quot;],每个参数通过才算通过，相当于hasAllRoles()方法。

            anon：比如/admins/**=anon 没有参数，表示可以匿名使用。

            authc：比如/admins/user/**=authc表示需要认证才能使用，没有参数

            authcBasic：比如/admins/user/**=authcBasic没有参数表示httpBasic认证

            ssl：比如/admins/user/**=ssl没有参数，表示安全的url请求，协议为https

            user：比如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查
                    # remember me可登录
</code></pre>
<h1 id="分布式">
  分布式
  <a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f">#</a>
</h1>
<h2 id="redisson">
  redisson
  <a class="anchor" href="#redisson">#</a>
</h2>
<pre><code>介绍
    使用redis外部存储，实现分布式功能
</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/ukeate/hugo-blog/commit/4e2d4ce41dcdff2166865f0c41222259f2d436cd" title='Last modified by outrun | Jan 1, 2025' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="" />
      <span>Jan 1, 2025</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/ukeate/hugo-blog/blob/master//content/docs/middleware/library/_index.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#名词">名词</a></li>
    <li><a href="#库">库</a>
      <ul>
        <li><a href="#日志">日志</a></li>
        <li><a href="#格式模板">格式|模板</a></li>
        <li><a href="#生成压缩加密计算特征">生成|压缩|加密|计算特征</a></li>
        <li><a href="#客户端邮件">客户端|邮件</a></li>
        <li><a href="#领域语言">领域语言</a></li>
        <li><a href="#图形">图形</a></li>
        <li><a href="#运维控制">运维控制</a></li>
        <li><a href="#协议">协议</a></li>
        <li><a href="#高可用--性能">高可用 | 性能</a>
          <ul>
            <li><a href="#akka">akka</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#开发">开发</a>
      <ul>
        <li><a href="#脚手架">脚手架</a>
          <ul>
            <li><a href="#spring-boot">spring boot</a></li>
            <li><a href="#drapwizard">drapWizard</a></li>
          </ul>
        </li>
        <li><a href="#写法">写法</a>
          <ul>
            <li><a href="#ejb">ejb</a></li>
          </ul>
        </li>
        <li><a href="#语言增强">语言增强</a>
          <ul>
            <li><a href="#guava">guava</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#接口">接口</a>
      <ul>
        <li><a href="#restful">RESTful</a>
          <ul>
            <li><a href="#connect">connect</a></li>
            <li><a href="#express">express</a></li>
            <li><a href="#koa">koa</a></li>
          </ul>
        </li>
        <li><a href="#实时">实时</a>
          <ul>
            <li><a href="#socketio">socket.io</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#展示">展示</a>
      <ul>
        <li><a href="#spring-mvc">spring mvc</a></li>
        <li><a href="#struts2">struts2</a></li>
      </ul>
    </li>
    <li><a href="#数据">数据</a>
      <ul>
        <li><a href="#日志-1">日志</a></li>
        <li><a href="#爬虫">爬虫</a></li>
        <li><a href="#分析">分析</a></li>
        <li><a href="#计算">计算</a></li>
      </ul>
    </li>
    <li><a href="#搜索">搜索</a>
      <ul>
        <li><a href="#lucene">lucene</a></li>
        <li><a href="#solr">solr</a></li>
        <li><a href="#elasticsearch">elasticsearch</a></li>
      </ul>
    </li>
    <li><a href="#权限">权限</a>
      <ul>
        <li><a href="#shiro">shiro</a></li>
      </ul>
    </li>
    <li><a href="#分布式">分布式</a>
      <ul>
        <li><a href="#redisson">redisson</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












