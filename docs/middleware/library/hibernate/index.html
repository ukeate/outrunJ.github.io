<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  基础
  #

优点
    完全面向对象编程思想，无sql
    减少代码
    控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率
    hibernate具有独立性（访问层随时可以更换）
特性
    不写hbm.xml映射文件，而是基于注解的验证
    对象、集合、属性的延迟加载
        dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常
目录
    .                                        # hibernate程序包
    documentation                # 文档
    lib                                        # 所有依赖包
    project                                # 源码文件
加载顺序
    后面的覆盖前面的
    hibernate.properties中的配置被覆盖
        # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置   hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准）
开发流程
    加载配置: jdbc参数，数据库方言，hbm映射
    创建SessionFactory    # 内有连接池
    创建session
    事务处理
    关闭session
    关闭连接池
对象状态
    𣊬时态     # 没有OID(持久化标识), 没有关联session
    持久态     # 有OID, 与session关联, 事务未提交
    脱管态     # 有OID, 没有关联session
缓存机制
    一级缓存(session)
        事务级，事务结束缓存失效    # 请求同一对象，取得同一实例
        总是打开
    二级缓存
        SessionFactory级别，session共享
        缓存散装持久化实例, 有不同缓存策略
        先设置策略，再设置过期时间与cache提供器
    优点
        提高速度、减小压力
        缓存失效时，不立即查找，而是合并sql查找
查询方式
    HQL
    QBC(命名查询)
    SQL
get与load
    get立即加载，load延时加载
    get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库
        # 代理对象只存id
    get没有时返回null, load抛异常
检索策略            # 取关联对象
    立即检索        # 一次全加载, select多
    延迟检索        # 访问游离状态代理类，需要在持久化状态时已被初始化
    迫切左外连接检索 # 用外连接取代select，全加载


  优化
  #

数据库设计调整
HQL优化
api正确使用
配置参数          # 日志、查询缓存，fetch_size, batch_size等
映射文件优化      # id生成策略，二级缓存，延迟加载，关联优化
一级缓存管理, 二级缓存策略
事务控制策略


  基本概念
  #

o-&gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题
o-&gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想)
    DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准
    它们的区别在于
        hibernate中不写sql语句
        ibatis中写少量sql语句
        DBUtils中写sql语句
    它们的另一个相同点是
         底层全都是jdbc
o-&gt; 结构对应 javabean中的 类，对象，属性
         数据库中的            表，记录，字段
o-&gt; hql        hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用
o-&gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean


  使用
  #

1.导入核心包(10 &#43; 1个)
    hibernate3.jar                                # 核心包
    c3p0-0.9.1.jar
    antlr-2.7.6.jar                                # 转换hql到sql
    commons-collections-3.1.jar        # apache的集合增强包
    dom4j-1.6.1.jar
    javassist-3.9.0.GA.jar                # 动态代理
    jta-1.1.jar                                        # java transaction api        处理事务用
    slf4j-api-1.5.8.jar
    log4j.jar
    slf4j-log4j12.jar                        # 三个日志
    &#43;
    mysql-connector-java-5.1.7.bin.jar
        
2.建立目录
    hibernate.dao
            demo.java
    hibernate.db
            xx.sql
    hibernate.domain
            xx.java
    hibernate.util
            HibernateUtil.java
3.创建映射文件
    xx.java文件的同目录下，创建
            xx.hbm.xml
4.创建配置文件
    src/hibernate.cfg.xml        (可变)
    src/hibernate.properties
5.写提供hibernate session的工具类
    HibernateUtil
6.demo中用hibernate session创建事务进行数据库操作
    demo.java


  session
  #

查询不需要事务，其它都需要事务

流程
    Session session = HibernateUtil.getSession();
    Transaction t = session.getTransaction();
    t.begin();
    session.update(hero);
    session.delete(hero);
    t.comment();
    
批量
    t.begin();
    session.save(hero);
    t.commit();
    session.clear();
    
    查询
    Query query = session.createQuery(hql);
    List&lt;Hero&gt; heroList = query.list();
    
    查询2
    Query query = session.createQuery(hql);
    query.setString(0,name);                // hql中参数从0开始
    query.setString(1,des);
    Hero hero = (Hero) query.uniqueResult();        // 只有一个结果时使用
    
    修改
    Query query = session.createQuery(hql);
    int i = query.executeUpdate();

结尾
    }catch(Exception e){
            e.printStackTrace();
            t.rollback();
    }finally{
            HibernateUtil.closeSession(); // session.close();
    }
        
session
    元素的状态
        # oid: object id,hibernate 的id值唯一并且与表中的数据一一对应
        ## hibernate中分辨数据只看oid
        临时（new），无oid,不在session中.生成sql语句
            持久化（persistence object）：session.save(hero),有oid,在session中;(saveOrUpdate(hero))
            游离：session.evict(hero),有oid,不在session中,session.update(hero)重新持久化
            删除：sesssion.delete(hero),有oid,不在session中,不可恢复,提交后可修改数据库
                # 隐含将po对象转成持久化状态，并生成delete语句。提交后成delete状态，执行语句
                ## 临时、持久、游离都可以调用
                ## 临时调用delete时会删除数据库中相应id的值 ，危险
    函数
        get 与 load
            session.get(hero.class,1),从数据库得到持久状态对象
                与数据库交互
                查到时返回po
                查不到时返回null
            session.load(hero.class,1)
                不与数据库交互,返回自己创建的po(只有id)
            访问非id值的时候，与数据库交互
        session.clear() # session中的引用变量清空
        session.close() # clear() &#43; 关闭session对象，回收资源，但session非空
        session.isOpen()
        session.flush() # 对session中的更改部分生成相应的sql语句,只在session中，不访问数据库
        session.update()    # 只是将游离重新持久化,不产生sql语句。（执行更新语句时加上它增加可读性）
                                                ## update()方法执行时会检验一级缓存（session）中是否有 oid相同的po
                                                ## ,同时会连接数据库，查询一级缓存中po与数据库中记录的一一对应关系
        session.commit()    # flush() &#43; 提交事务


  hibernate.cfg.xml
  #

必要性
        必须配置

目录与文件名
        任意，建议 src/hibernate.cfg.xml

源码中的案例文件：
        \project\tutorials\web\src\main\resources\hibernate.cfg.xml
        \project\etc\hibernate.cfg.xml
约束文件位置
        hibernate3.jar/org/hibernate/hibernate-configuration-3.0.dtd
数据库连接属性与方言属性的属性名和值可以查找
        \project\etc\hibernate.properties                # 由于xml文件中配置要覆盖的是hibernate.properties文件中的属性
                                                                                        ## 所以属性内容从hibernate.properties文件的属性中查找
        方言类的位置是：hibernate3.jar/org.hibernate/dialect/中查找到相应的类，
                这是最终的路径，（oracle的通用方言类的类路径 可以用这种方法找到，hibernate.properties配置文件中没有写）
        
加载
        该配置文件属于纯人为配置，需要在Configuration类的实例中调用addResource(&quot;&quot;)方法加载
        addResource()方法中的参数是本配置文件相对于src/目录的全限定名
        
作用
        1.映射数据库
        2.配置 类-表映射 资源xml文件的路径
        
内容
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;
&lt;hibernate-configuration&gt;
        &lt;session-factory&gt;
                &lt;!-- 配置访问数据库需要的属性 --&gt;
                &lt;property name=&quot;connection.driver_class&quot;&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;
                &lt;property name=&quot;connection.url&quot;&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/property&gt;
                &lt;property name=&quot;connection.username&quot;&gt;scott&lt;/property&gt;
                &lt;property name=&quot;connection.password&quot;&gt;tiger&lt;/property&gt;
                &lt;!-- 配置方言 通知hibernate访问哪种数据库的语法结构--&gt;
                &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt;
                &lt;!-- 类表映射文件 --&gt;
                &lt;mapping resource=&quot;hibernate/domain/Hero.hbm.xml&quot;/&gt;
        &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;


  hibernate.properties
  #

必要性
        不必须配置
位置：
        该文件的位置在src/目录下是不可以改变的，是hibernate加载配置的入口 

源码中的参考文件：
        /project/etc/hibernate.properties
                # oracle的通用驱动可以从hibernate3.jar/org.hibernate/dialect包中查找
        
作用
        1.配置连接的数据库，更换数据库只需要更改配置文件即可
        2.配置数据库方言
        3.其它控制开关

方言的作用
        更换数据库访问形式，实现通用性

内容
        hibernate.dialect org.hibernate.dialect.MySQLDialect
        hibernate.connection.driver_class com.mysql.jdbc.Driver
        hibernate.connection.url jdbc:mysql:///outrun
        hibernate.connection.username outrun
        hibernate.connection.password asdf
        hibernate.show_sql true                # 开关：显示实际操作数据库的sql语句
自动创建表
    hibernate.hbm2ddl.auto=create      # 每次都创建
    hibernate.hbm2ddl.auto=update      # 没有时再创建(有但是结构不同时会按照酌情增加列字段)
                                                                            ## 当更新或插入记录不满足条件时会出错
缓存
        hibernate.cache.provider_class                # 开启二级缓存中的普通区           
        hibernate.cache.use_query_cache                # 开启二级缓存中的查询区


  HibernateUtil
  #

目的
        对SessionFactory返回Session的方式进行了重构，通过调用该静态工具方法
        实现只有一个SessionFactory实例，由它产生和销毁很多Session的工厂机制。

缓存
        SessionFactory 是二级缓存
        Session 是一级缓存
                # 查询时，先在二级缓存中查找，没有数据时查找一级缓存，最后查询数据库
                # 缓存中的数据会用镜像联系着数据库，如果数据库有更新，缓存中的数据会自动更新

SessionFactory对象与Session对象
        SessionFactory:只创建一次，重量级对象，线程安全，可以共享，实例变量，开始时创建 
        Session:创建多次，轻量级对象，线程不安全，不可以共享，局部变量，临时创建 
        

实现代码
/**
* 提供hibernate session 
* 并且用threadLocal跟踪实现无参删除
* 
* @author Administrator
*
*/
public final class HibernateUtil {
        // 单例的SessionFactory工厂 
        private static SessionFactory sessionFactory;
        // 单例的ThreadLocal&lt;Session&gt;实例，但是每个调用者都有自己独有的方法？
        private static ThreadLocal&lt;Session&gt; threadLocal;
        /**
        * 解析配置文件（properties,xml）到hibernate 的配置JavaBean,常驻内存
        * 
        */
        static{
                // 在这里加载了hibernate.properties配置文件（这里可以配置数据库），执行其它配置
                // 相当于jdbc中的DriverManager类（如果配置了数据库，相当于也注册了连接数据库的类文件 【Class.forName(&quot;..Driver&quot;)语句 ..Driver 新建实例的时候自动向DriverManager注册自己】）
                Configuration config = new Configuration();
                // 这里写xml配置文件对于src/目录的相对路径,加载映射用xml文件
                config.addResource(&quot;hibernate.hbm.xml&quot;);
                // 加载src/目录下的hibernate.cfg.xml配置文件
                config.configure();                # configure(&quot;classpath:hibernate.cfg.xml&quot;);
                                                                        1.configure方法中可以加路径
                                                                        2.classpath:代表src/目录
                // 导入org.hibernate.SessionFactory类而非org.hibernate.classic.SessionFactory类
                sessionFactory = config.buildSessionFactory();
        }
        /**
        * 从单例工厂中得到被跟踪定位(每个调用者)的Session对象,没有就创建
        * 
        * @return
        */
        public static Session getSession(){
                /* 根据不同的调用者返回跟踪的不同的Session对象,如果是第一次调用，就创建新的session，绑定到单例的ThreadLocal对象中记录，返回给调用者
                * 如果不是第一次调用 ，也能返回让其得到原来为它创建的Session对象 
                */ 
                Session session = threadLocal.get();
                if(session == null){
                        session = sessionFactory.openSession();
                        threadLocal.set(session);
                }
                return session;
        }
        /**
        * 删除调用者在ThreadLocal实例中的跟踪记录，并且关闭该Session实例
        * 
        */
        public static void closeSession(){
                
                Session session = threadLocal.get();
                if(session != null){
                        session.close();
                        threadLocal.remove();
                }
        }
}


  hql
  #

hql特性
    1.hql是hibernate专用，有专用的技术转换hql到sql,但降低效率
    2.hql完全面向对象,只出现类，属性，操作符和关键字,例如sum(),order by
            而sql是面向关系的语言
使用语句
        Query query = session.createQuery(hql);
        Customer c = (Customer)query.uniqueResult();        # 只返回一条结果
        List&lt;Customer&gt; list = query.list();                        # 返回多条结果

常用 api
        session.createQuery()
        session.getNamedQuery()                # 从映射文件中加载&lt;query&gt;标签配置的与&lt;class&gt;标签同级的hql语句
        query.setString(&quot;&quot;,&quot;&quot;)
        Object o = query.uniqueResult();
        List list = query.list();
        分页
                query.setFirstResult(0);        # 开始标号
                setMaxResults(3);              # 最多显示的条数
        
query语句                习惯用别名替代类名
                # from后面出现的是类名，where中比较的是对象属性（已经在映射文件中映射到了表名与字段名）
        占位符
                冒号占位符
                        &quot;from Customer c where c.name = :cname&quot;
                        query.setString(&quot;cname&quot;,&quot;司马懿&quot;);
                问号占位符
                        &quot;from Customer c where c.name = ?&quot;
                        query.setString(0,&quot;司马懿&quot;);
        映射文件中分离hql语句
                        # &lt;query&gt;标签与&lt;class&gt;标签同级
                &lt;Query name=&quot;findCustomerByAge&quot;&gt;
        &lt;![CDATA[
            from Customer c where c.age &lt; ? 
        ]]&gt;
        Query query = session.getNamedQuery(&quot;findCustomerByAge&quot;);
        query.setInteger(0,60);
        查询
                &quot;from Customer where id = 1&quot;
            &quot;from Customer as c where c.name = &#39;司马懿&#39; &quot;
            &quot;from java.lang.Object&quot;    # 映射中没有，写类的全称。查找 src/hibernate.cfg.xml中加载到内存中的映射的类对应的表中的所有记录
            &quot;from Order o order by o.price desc&quot;
                投影查询
                        1.&quot;select c.name,c.age from Customer c &quot;
                        List&lt;Object[]&gt; list = query.list();        # Object[]中存储的是查询的select 语句中的数值
                        for(Object [] o : list){
                System.out.println(o[0]);
                System.out.println(o[1]);
            }
            2.&quot;select count(o), sum(o.price),min(o.price) from Order o&quot;                # count()中的是表类名，统计实例数，查询Order表记录对象的个数 
            3.&quot;select o.customer.id from Order o&quot;
用到过的hql
        级联抓取
                FROM Role r LEFT JOIN FETCH r.privilegeSet WHERE r.id = :id
        级联抓取顶级权限表（去重复）
                SELECT DISTINCT p FROM Privilege p LEFT JOIN FETCH p.childrenSet WHERE p.parent IS NULL
        级联抓取角色        
                FROM Account a LEFT JOIN FETCH a.roleSet WHERE a.id = :id
        三级级联抓取                # 对抓取的集合也可以直接抓取下一层
                FROM Account a LEFT JOIN FETCH a.roleSet r LEFT JOIN FETCH r.privilegeSet WHERE a.login = :login AND a.pass = :pass


  案例
  #

编码
    hibernate用用户操作系统的编码作为自己的编码

    mysql5.5中设置编码：根目录下my文件 default-character-set=gbk


  查询
  #

hibernate的查询方式
    1.session.get(字节码,1)
    2.session.load(字节码,1)
    3.HQL查询session.createQuery()        session.getNamedQuery()        # 后面是从配置文件中载入hql语句
    4.对象导航，如多表映射中
            # 以对象的形式操作数据库中的表，如
                ## p是person表的一个对象，c是card（身份证表）表的一个对象，p通过配置外键时定义的属性card得到自己的身份证表对象
                ## 1.从表对象中：Card c = p.getCard();
                ## 2.从hql语句中：select o.customer.id,o.customer.name,sum(o.price) from Order o group by o.customer.id
        5.createSQLQuery原生sql语句查询：        # 不要用，用了以后 hibernate跨平台的特性就没有了
                String sql = &quot;select {a.*} from sysgroup {a} where department regexp ?&quot;;
                Query query = session.createSQLQuery(sql).addEntity(&quot;a&quot;,SysGroup.class);
                        # addEntity将表的别名与类字节码关联起来（否则返回的表字段数据是Object类型,jsp页面读取时会出错）
连接查询的hql语法
                # 只能连接有外键关系的表类，用表类中的关系类来表示第二张表，不能用笛卡尔积查询
                ## 也就是说只能查一个表类
                注意
                        hql连接查询的语法中用where替代了sql语法中的on
                        外连接与 sql不同，只能查询与一个表类有关系的外连接表（from语句后面不能写两个表类）
        内连接
            from Customer c join c.orderSet o where c.id = o.customer.id
        外连接                # 这里与 sql不同，只能查询与一个表类有关系的外连接表
            select c.name,count(o.orderno) from Customer c left join c.orderSet o group by c.name;
        自连接
            select a.name, b.name from emp a, emp b where a.mgr=b.id;


  多表映射
  #

主控方                # 就是只有主控方的操作成立，非主控方的改变忽略
        inverse=&quot;true&quot;
                # false:主表管理，主表插入成功后，再发送n条更新语句来更新外键
        ## true:从表管理，自己插入时加上：自己javabean中存放的外键关联
            # 所以购物项中要关联购物车，由于购物车中已经一对多购物项，所以形成了双向关联
        有该属性的标签
                &lt;set&gt;
        缺少主控方出现的问题
                双向一对多中
                        1.hibernate生成的sql语句产生重复
                        2.主键冲突                # 插入操作时，由于“一”表级联插入“多”表，“多”表也要插入自己，它们的主键是相同的，会引起主键冲突

级联                # 数据库只有级联删除
        cascade=&quot;save-update&quot;  # 插入和更新
                        # 一般使用save-update，因为表一般软删除，（更新也没有，因为主键不更新，但是hibernate没有单save）
    cascade=&quot;delete&quot;;  # 删除订单，级联删上层客户
    cascade=&quot;none&quot;  # 什么都不做（默认）
    cascade=&quot;all&quot;  # save-update &#43; delete
        有级联属性的标签
                class标签下的
                        &lt;set&gt;
                        &lt;one-to-one&gt;
                        &lt;many-to-one&gt;
        注意
                级联插入的子表的id内容要为空，否则会变成级联更新                # 这里和单个数据插入时设置对象的id属性不起作用【只有hibernate的主键增长策略起作用】是不同的
                
单向一对多                        # 集合映射的一种
        “一”的类中
                private Set&lt;Order&gt; orderSet = new LinkedHashSet&lt;Order&gt;();
        映射xml文件中
                &lt;!-- set标签用于映射单向一对多 
                    name表示单方的关联属性
                    table表示多方对应表的名字
                    key-column表示多方对应表的外健
                    one-to-many-class表示单方关联属性中的每个元素的类型
                --&gt;
                &lt;set name=&quot;orderSet&quot; table=&quot;ORDERS&quot; cascade=&quot;all&quot;&gt;
                        &lt;key column=&quot;CUSTOMERS_ID&quot;/&gt;
                        &lt;one-to-many class=&quot;Order&quot;/&gt;
                &lt;/set&gt;
单向多对一                        # 常用
        映射xml文件中
                &lt;!--
                many-to-one映射多方的关联属性
                name表示多方的关联属性名
                column表示多方对应表的外健(存储关联类对应表的主键)
                cascade 级联
                lazy表示“一”的类数据是否在一开始的时候就查询                # 如果lazy=&quot;proxy&quot;【相当于懒加载】，action类中加载“一”方数据时会出错，因为调用service类结束后线程中的session销毁,延迟加载找不到session会失败
                fetch表示抓取策略
                                # 这里产生了hibernate的n&#43;1问题：一条查询语句查出&quot;一&quot;的集合，n条查询语句查出集合中每个元素的一
                        join代表用join语句查询(一条语句),但是hibernate在多对一的时候不支持fetch=&quot;join&quot;
                        默认是select，每次查询用一条select语句（多条语句）
                                解决：自己写新的查询方法查询,执行hql如：FROM Category c LEFT JOIN FETCH c.account
                --&gt;
                &lt;many-to-one 
                        name=&quot;customer&quot; 
                        column=&quot;CUSTOMERS_ID&quot; 
                        cascade=&quot;all&quot;
                /&gt;
        
双向一对多  # 双向映射就存在主控方的问题  
                ##　主表从表（外键【可以为空】）        
                ## 集合映射的应用
        1.同时配置单向一对多与单向多对一
        2.在&quot;一&quot;表中配置inverse=&quot;true&quot;,反转权力，“多”表为主控方
双向一对一      # 主表从表（从表id既是主键又是外键）
                ## 双方都是主控方 
    1.两表都配置&lt;one-to-one/&gt;
    2.主表配置cascade
        3.从表中constrained=true属性（主键是否同时为外键约束）
        
多对多（单向左到右，单向右到左，双向）                # 集合映射的应用
                                                                ## 多对多关系中一定要有主控方，否则主键冲突问题
        1.创建中间表  
                        # 中间表可以没有自己的JavaBean类文件对应，这时默认有联合主键（联合主键分别是保存的两个外键）
                students_id
                teachers_id 
                        # student_id 与 teachers_id为联合主键
            ## sql语句是primary key(student_id,teacher_id);
                创建中间表原因：
                        之所以中间表是因为两边的表中主键唯一，所以不能在一个记录中对对应另一个表的多个记录
                        中间表相当于把多对多分成两个一对多。
        2.表对象类中都有对方表的set集合 
        3.映射xml中      # 可以用inverse,cascade
                                ##  cascade=&quot;none&quot;时,middle表中的记录也会被删除
                ## 不配置主控方的话一边更新另一边，另一边也更新自己，会出错
        &lt;set table=&quot;MIDDLES&quot; name=&quot;teacherSet&quot;&gt;
            &lt;key columnet=&quot;STUDENTS_ID&quot;/&gt; 
            &lt;many-to-many class=&quot;Teacher&quot; column=&quot;TEACHERS_ID&quot;/&gt;
        4.dao中
                在cascade=&quot;all&quot;的配置下实现只删除老师与middle表中的教学关系          # 手工解除关系
                        # 不手工解除关系的话， 表记录对象：Teacher t1
                                ，t1删除时,级联删除middle表中数据，middle表中对应了学生的外键
                                ，由于多对一级联，会删除学生，由于该学生的主键可能会被middle表中的其它记录作为外键引用，所以不能删除，删除时会出错。 
                
                查询1号老师对应的学生,并解除关系 
                        Teacher t1
                        for(Student s: t1.getStudentSet()){
                            s.getTeacherSet().remove(t1);
                        }
                        1号老师解除关系
                        t1.setStudentSet(null);
                        session.delete(t1);


  缓存
  #

缓存        
        1.一级缓存(session)中的数据是独享的，二级缓存(sessionFactory)中的数据是共享的
        2.一级缓存中的数据改变时会更新二级缓存(如果二级缓存设置为read-only时，会更新出错)
        3.二级缓存默认不能存po(持久化对象) ，只存放连接数据库的信息和映射文件 
                # 这时查询数据时的顺序是 一级缓存 -&gt; 数据库
                
启用二级缓存                # 开启的二级缓存中可以保存po
                                ## 二级缓存的两个空间：普通缓存区(get、load)、查询缓存区(query对象查询)
        普通缓存区
        hibernate.properties文件中配置
            hibernate.cache.provider_class 
                    org.hibernate.cache.HashtableCacheProvider                # 只能内存缓存
                    org.hibernate.cache.EhCacheProvider                                # 也能磁盘缓存ehcache的jar包中ehcache-failsafe.xml配置文件中可以查到默认缓存配置
                                                                            # 可以在hibernate的中文官方教程中查到缓存策略提供商的类
                                                                            ## hibernate3.2之前缓存类jar包是集成的，默认是EhCache
                                                                            ## hibernate3.2之后缓存类jar包要自己导入
                                                                            ## ...Provider类并不是实现类，而是桥接类
            cache.use_second_level_cache
                    true                                                # 开启二级缓存（默认是true,但是没有配置缓存提供商之前不开启）
        hibernate.cfg.xml文件中配置使用二级缓存的类              # 可以设置&lt;cache&gt;的标签&lt;class&gt;&lt;set&gt;
                                                                                        ## 设置&lt;set&gt;时，set对应表类的也要设置&lt;cache&gt;标签
                &lt;class-cache usage=&quot;read-write&quot; class=&quot;pojo.Goods&quot; /&gt;
                usage属性
                        read-only：二级缓存只读(只是不能进行修改，但是从表中读取数据时一级缓存可以向二级缓存中放入数据)
                        read-write:可读写
        查询缓存区（hql语句）：默认不开启
                        # 因为hql命中率低(要求hql语句相同才行，模糊查询每次基本不同),每次查找会到缓存，找不到再到数据库，查询完数据再存入缓存，效率低
            ## 不配置的话查询还会存到缓存，但只提供get使用，hql自己不用
                1.首先开启普通缓存区（设置了表类可以缓存）
                2.在query对象中开启查询缓存区
                        query.setCacheable(true);
        查询顺序：一级缓存 -&gt; 二级缓存 -&gt; 数据库

缓存提供商配置
        ehcache缓存提供商
                创建src/ehcache.xml配置文件，使用ehcache缓存时会自动加载其中的配置
                        &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;        # 设置缓存目录，java.io.tmpdir指操作系统的临时目录
                        diskPersistent
                        diskExpiryThreadIntervalSeconds                # 这两个集群中使用，上面是是否集群持久化，下面是设置持久化时间
                        maxElementsInMemory                                        # 内存支持最大对象数目(溢出的对象会存到硬盘中)
                        overflowToDisk                                                # 内在到最大数目时是否缓存到硬盘
                        eternal                                                                # 缓存是否永久有效，如果为true，则timeToIdleSeconds与timeToLiveSeconds不起作用
                        timeToLiveSeconds                                        # 内存中缓存最大存活时间，服务器启动的时间加入其中
                        timeToIdleSeconds                                        # 缓存不被访问时最大存活时间
                        memoryStoreEvictionPolicy                        # 内存中对象的替换算法FIFO(先进先出first in first out) 
                                                                                                ## LRU(最近最未使用算法,最久没有被访问的对象踢出) 
                                                                                                ## LFU(最少未被使用算法,考虑了对象的访问频率,踢出最近最少被访问的对象)      
                                                                                                ## 是windows自己的替换算法
清空缓存
        一级缓存：session.clear();
        二级缓存：sessionFactory.close();


  集合映射
  #

作用
        集合包含于表类中，对应其一个属性，相当于该类对应表的一个子表
        每种集合对应一张表，内容对应记录。
        把java类中经常使用的数据结构对应到表中

使用
        javaBean（User）中
                private Set&lt;String&gt; telSet = new LinkedHashSet&lt;String&gt;();
                private List&lt;String&gt; cityList = new ArrayList&lt;String&gt;();
                private Map&lt;String,String&gt; telCityMap = new LinkedHashMap&lt;String,String&gt;();
        xml文件中
                &lt;set name=&quot;telSet&quot; table=&quot;TELS&quot;&gt;
            &lt;key column=&quot;USERS_ID&quot;/&gt;        # 外键列：集合所创建的表的外键列名
            &lt;element column=&quot;TEL&quot; type=&quot;string&quot;/&gt;      # 内容列：这里必需要有type 
                    # set中也可以把&lt;element&gt;标签换成&lt;one-to-many class=&quot;Order&quot;/&gt;标签来对应JaveBean作为值，这就是一对多的映射
        &lt;list name table&gt;
            &lt;key column/&gt;
            &lt;list-index column=&quot;IDX&quot;/&gt;      # 索引列：表中的索引号列(对应在list中的索引)
            &lt;element column type/&gt;
        &lt;map name table&gt;
            &lt;key&gt;
            &lt;map-key type column&gt;                        # map对应key的列
            &lt;element column type&gt;
        dao中使用
                user.getTelSet().add(&quot;131&quot;);


  检索策略
  #

hibernate检索的两种类型
        立刻检索:session.get,query.list        &lt;class lazy=&quot;true&quot;&gt;标签中类的检索策略，get方法与list都不遵循
        延迟检索:session.load      # 初始时是代理对象,使用时查询  只有load方法遵循&lt;class lazy=&quot;true&quot;&gt;标签中类的检索策略
            检索方法是load时
                lazy属性出现在&lt;class&gt;与&lt;set&gt;标签中,两个标签中lazy属性的含义是不同的，两个lazy属性都是对load方法执行时是否查询数据库进行设置。
                        # &lt;class&gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中除了set集合之外的所有属性
                        ## &lt;set&gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中set集合的数据
                        ## &lt;class&gt;中默认lazy属性的值为true
                        ## &lt;set&gt;中默认lazy属性的值为true
                true true 时    查类时没有查集合
                false true 时    查类时没有查集合
                false false 时    查类时查集合
                true false 时    查类时没有查集合


  经验
  #

删除的两种方法 
        session.delete(session.get(Category.class,id));    # 先查询再删除，效率低
    session.createQuery(&quot;delete Categroy c where c.id=:id&quot;).setInteger(&quot;id&quot;,id).executeUpdate();
                    # 执行hql语句，效率高
                    
hibernate注解
        hibernate3.6支持注解
                javaee5不支持，默认关闭
                javaee6支持，默认开启，此时不加载注解配置文件会报错，所以要关掉
                        hibernate.cfg.xml中
                        &lt;property name=&quot;javax.persistence.validation.mode&quot;&gt;none&lt;/property&gt;
                        
DB Browser反射编译表的生成映射文件和类的时候，会生成项目目录下hibernate.reveng.xml的临时配置文件，可以删掉

映射文件class属性
        dynamic-update=&quot;true&quot;                # 动态更新，只有对相同的session有效，而且性能不好
                                                                ## 用字段设置中的update=&quot;false&quot;（对象中有字段值时更新，没有时不更新）属性来设置动态更新
映射文件set标签属性
        Order-by=&quot;id&quot;                                # set中级联对象按照&quot;id&quot;属性进行排序


  c3p0
  #

c3p0并不是hibernate默认的连接池（默认的是hibernate自带的连接池算法）
        配置c3p0以后自动关闭Hibernate自带的连接池，而使用c3p0连接池


hibernate.cfg.xml文件中
        &lt;!-- 最大连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;20&lt;/property&gt; 
        &lt;!-- 最小连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;5&lt;/property&gt; 
        &lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;120&lt;/property&gt; 
        &lt;!-- 最大的PreparedStatement的数量 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;100&lt;/property&gt; 
        &lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--&gt; 
        &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;120&lt;/property&gt; 
        &lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;2&lt;/property&gt; 
        &lt;!-- 每次都验证连接是否可用 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/property&gt; 
hibernate.properties文件中
        hibernate.c3p0.min_size=5 
        hibernate.c3p0.max_size=20 
        hibernate.c3p0.timeout=1800 
        hibernate.c3p0.max_statements=50 


  映射
  #

hbm.xml
    位置与名称：
            domain.xx.java 文件同级目录 xx.hbm.xml

    约束文件位置
            hibernate3.jar/org/hibernate/hibernate-mapping-3.0.dtd
            从其中复制约束头
            
    源码中的案例文件
            \project\tutorials\中搜索 hbm.xml

    类-表映射的特点
            1.映射JavaBean到表字段（动态占位符），可以使用面向对象的hql语名生成sql语句
            2.session中保存类对象，缓存查询过的表的内容
            3.在映射关系的xml文件中可以设置主键的改变方式（这样以后dao类中设置的主键内容被配置文件中的设置覆盖）
            
    主键
            表中的主键
                    自然主键：有业务逻辑含义的字段（如name）（多个自然主键：联合主键）
                    代理主键
            hibernate中id的增加类型
                    increment  整型,不依赖数据库自增,多线程不安全
                uuid        缺点：占空间
                identity    整型，依赖数据库自增,线程安全
                sequence    专用于oracle数据库,要用特定名字的序列，create sequence hibernate_sequence;线程安全
                native(重点)    根据情况判断是identity或sequence
                assigned    自然主键：&lt;id name=&quot;name&quot; column=&quot;name&quot;&gt;,线程不安全
                composite-id    多个自然主键,表的javaBean必须实现序列化(1.对象序列化到硬盘、数据库【其它JavaBean有id属性，hibernate自动实现序列化】2.线程间传递数据)
                    &lt;composite-id&gt;&lt;key-property name=&quot;firstname&quot; column=&quot;firstname&quot;/&gt;&lt;key-property name=&quot;firstname&quot; column=&quot;lastname&quot;/&gt;

    持久化对象的两种类型
            实体型：具有id属性的类，映射成一条含有id主键的完整记录
            值类型或组件：与上面相反(被实体型包含)，如
                            # 包含以后会把组件的属性添加到实体类属性的后面，一起当作一张表，仅此而已
            # Address   
                province
                city
                area
            映射组件型属性
            1.类中引用组件：private Address address
            2.映射 &lt;component name=&quot;address&quot; class=&quot;Address&quot;&gt;&lt;property name column/&gt;
            3.dao中    star.setAdrress(address);
    内容
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE hibernate-mapping PUBLIC 
        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;        
    &lt;hibernate-mapping package=&quot;hibernate.domain&quot;&gt;
            &lt;class name=&quot;Hero&quot; table=&quot;heros&quot; dynamic-insert=&quot;true&quot;&gt;
                                    # 设置动态插入为true:如果是null的值，不再插入
                                    ## 如果不设定动态插入，会插入数据库null值，数据库中设定的默认值不会起作用
                    &lt;!-- hibernate通过自己内部的类型type=&quot;&quot;,来转换java类型与sql类型之间的转换，一般不必写，自动反射 --&gt;
                    &lt;!-- id 是指主键，property是属性 --&gt;
                    &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;
                            &lt;!-- hibernate内部的主键生成器 --&gt;
                            &lt;generator class=&quot;increment&quot;/&gt;
                    &lt;/id&gt;
                    &lt;property name=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;gender&quot; column=&quot;gender&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;des&quot; column=&quot;des&quot;&gt;&lt;/property&gt;
            &lt;/class&gt;
    &lt;/hibernate-mapping&gt;
javaBean
    实现序列化接口
            在有名为id属性的JavaBean中，hibernate会自动实现序列化接口
            没有名为id属性的JavaBean中，需要我们自己实现序列化接口

    public class Hero implements java.io.Serializable{
                private Integer id;
                private String name;
                private String gender;
                private Integer age;
                private Date birthday;
                private String des;
    }
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://ukeate.com/docs/middleware/library/hibernate/">
  <meta property="og:site_name" content="ukeate的笔记">
  <meta property="og:title" content="ukeate的笔记">
  <meta property="og:description" content="基础 # 优点 完全面向对象编程思想，无sql 减少代码 控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率 hibernate具有独立性（访问层随时可以更换） 特性 不写hbm.xml映射文件，而是基于注解的验证 对象、集合、属性的延迟加载 dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常 目录 . # hibernate程序包 documentation # 文档 lib # 所有依赖包 project # 源码文件 加载顺序 后面的覆盖前面的 hibernate.properties中的配置被覆盖 # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置 hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准） 开发流程 加载配置: jdbc参数，数据库方言，hbm映射 创建SessionFactory # 内有连接池 创建session 事务处理 关闭session 关闭连接池 对象状态 𣊬时态 # 没有OID(持久化标识), 没有关联session 持久态 # 有OID, 与session关联, 事务未提交 脱管态 # 有OID, 没有关联session 缓存机制 一级缓存(session) 事务级，事务结束缓存失效 # 请求同一对象，取得同一实例 总是打开 二级缓存 SessionFactory级别，session共享 缓存散装持久化实例, 有不同缓存策略 先设置策略，再设置过期时间与cache提供器 优点 提高速度、减小压力 缓存失效时，不立即查找，而是合并sql查找 查询方式 HQL QBC(命名查询) SQL get与load get立即加载，load延时加载 get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库 # 代理对象只存id get没有时返回null, load抛异常 检索策略 # 取关联对象 立即检索 # 一次全加载, select多 延迟检索 # 访问游离状态代理类，需要在持久化状态时已被初始化 迫切左外连接检索 # 用外连接取代select，全加载 优化 # 数据库设计调整 HQL优化 api正确使用 配置参数 # 日志、查询缓存，fetch_size, batch_size等 映射文件优化 # id生成策略，二级缓存，延迟加载，关联优化 一级缓存管理, 二级缓存策略 事务控制策略 基本概念 # o-&gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题 o-&gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想) DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准 它们的区别在于 hibernate中不写sql语句 ibatis中写少量sql语句 DBUtils中写sql语句 它们的另一个相同点是 底层全都是jdbc o-&gt; 结构对应 javabean中的 类，对象，属性 数据库中的 表，记录，字段 o-&gt; hql hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用 o-&gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean 使用 # 1.导入核心包(10 &#43; 1个) hibernate3.jar # 核心包 c3p0-0.9.1.jar antlr-2.7.6.jar # 转换hql到sql commons-collections-3.1.jar # apache的集合增强包 dom4j-1.6.1.jar javassist-3.9.0.GA.jar # 动态代理 jta-1.1.jar # java transaction api 处理事务用 slf4j-api-1.5.8.jar log4j.jar slf4j-log4j12.jar # 三个日志 &#43; mysql-connector-java-5.1.7.bin.jar 2.建立目录 hibernate.dao demo.java hibernate.db xx.sql hibernate.domain xx.java hibernate.util HibernateUtil.java 3.创建映射文件 xx.java文件的同目录下，创建 xx.hbm.xml 4.创建配置文件 src/hibernate.cfg.xml (可变) src/hibernate.properties 5.写提供hibernate session的工具类 HibernateUtil 6.demo中用hibernate session创建事务进行数据库操作 demo.java session # 查询不需要事务，其它都需要事务 流程 Session session = HibernateUtil.getSession(); Transaction t = session.getTransaction(); t.begin(); session.update(hero); session.delete(hero); t.comment(); 批量 t.begin(); session.save(hero); t.commit(); session.clear(); 查询 Query query = session.createQuery(hql); List&lt;Hero&gt; heroList = query.list(); 查询2 Query query = session.createQuery(hql); query.setString(0,name); // hql中参数从0开始 query.setString(1,des); Hero hero = (Hero) query.uniqueResult(); // 只有一个结果时使用 修改 Query query = session.createQuery(hql); int i = query.executeUpdate(); 结尾 }catch(Exception e){ e.printStackTrace(); t.rollback(); }finally{ HibernateUtil.closeSession(); // session.close(); } session 元素的状态 # oid: object id,hibernate 的id值唯一并且与表中的数据一一对应 ## hibernate中分辨数据只看oid 临时（new），无oid,不在session中.生成sql语句 持久化（persistence object）：session.save(hero),有oid,在session中;(saveOrUpdate(hero)) 游离：session.evict(hero),有oid,不在session中,session.update(hero)重新持久化 删除：sesssion.delete(hero),有oid,不在session中,不可恢复,提交后可修改数据库 # 隐含将po对象转成持久化状态，并生成delete语句。提交后成delete状态，执行语句 ## 临时、持久、游离都可以调用 ## 临时调用delete时会删除数据库中相应id的值 ，危险 函数 get 与 load session.get(hero.class,1),从数据库得到持久状态对象 与数据库交互 查到时返回po 查不到时返回null session.load(hero.class,1) 不与数据库交互,返回自己创建的po(只有id) 访问非id值的时候，与数据库交互 session.clear() # session中的引用变量清空 session.close() # clear() &#43; 关闭session对象，回收资源，但session非空 session.isOpen() session.flush() # 对session中的更改部分生成相应的sql语句,只在session中，不访问数据库 session.update() # 只是将游离重新持久化,不产生sql语句。（执行更新语句时加上它增加可读性） ## update()方法执行时会检验一级缓存（session）中是否有 oid相同的po ## ,同时会连接数据库，查询一级缓存中po与数据库中记录的一一对应关系 session.commit() # flush() &#43; 提交事务 hibernate.cfg.xml # 必要性 必须配置 目录与文件名 任意，建议 src/hibernate.cfg.xml 源码中的案例文件： \project\tutorials\web\src\main\resources\hibernate.cfg.xml \project\etc\hibernate.cfg.xml 约束文件位置 hibernate3.jar/org/hibernate/hibernate-configuration-3.0.dtd 数据库连接属性与方言属性的属性名和值可以查找 \project\etc\hibernate.properties # 由于xml文件中配置要覆盖的是hibernate.properties文件中的属性 ## 所以属性内容从hibernate.properties文件的属性中查找 方言类的位置是：hibernate3.jar/org.hibernate/dialect/中查找到相应的类， 这是最终的路径，（oracle的通用方言类的类路径 可以用这种方法找到，hibernate.properties配置文件中没有写） 加载 该配置文件属于纯人为配置，需要在Configuration类的实例中调用addResource(&#34;&#34;)方法加载 addResource()方法中的参数是本配置文件相对于src/目录的全限定名 作用 1.映射数据库 2.配置 类-表映射 资源xml文件的路径 内容 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &#34;-//Hibernate/Hibernate Configuration DTD 3.0//EN&#34; &#34;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&#34;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 配置访问数据库需要的属性 --&gt; &lt;property name=&#34;connection.driver_class&#34;&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt; &lt;property name=&#34;connection.url&#34;&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/property&gt; &lt;property name=&#34;connection.username&#34;&gt;scott&lt;/property&gt; &lt;property name=&#34;connection.password&#34;&gt;tiger&lt;/property&gt; &lt;!-- 配置方言 通知hibernate访问哪种数据库的语法结构--&gt; &lt;property name=&#34;dialect&#34;&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt; &lt;!-- 类表映射文件 --&gt; &lt;mapping resource=&#34;hibernate/domain/Hero.hbm.xml&#34;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; hibernate.properties # 必要性 不必须配置 位置： 该文件的位置在src/目录下是不可以改变的，是hibernate加载配置的入口 源码中的参考文件： /project/etc/hibernate.properties # oracle的通用驱动可以从hibernate3.jar/org.hibernate/dialect包中查找 作用 1.配置连接的数据库，更换数据库只需要更改配置文件即可 2.配置数据库方言 3.其它控制开关 方言的作用 更换数据库访问形式，实现通用性 内容 hibernate.dialect org.hibernate.dialect.MySQLDialect hibernate.connection.driver_class com.mysql.jdbc.Driver hibernate.connection.url jdbc:mysql:///outrun hibernate.connection.username outrun hibernate.connection.password asdf hibernate.show_sql true # 开关：显示实际操作数据库的sql语句 自动创建表 hibernate.hbm2ddl.auto=create # 每次都创建 hibernate.hbm2ddl.auto=update # 没有时再创建(有但是结构不同时会按照酌情增加列字段) ## 当更新或插入记录不满足条件时会出错 缓存 hibernate.cache.provider_class # 开启二级缓存中的普通区 hibernate.cache.use_query_cache # 开启二级缓存中的查询区 HibernateUtil # 目的 对SessionFactory返回Session的方式进行了重构，通过调用该静态工具方法 实现只有一个SessionFactory实例，由它产生和销毁很多Session的工厂机制。 缓存 SessionFactory 是二级缓存 Session 是一级缓存 # 查询时，先在二级缓存中查找，没有数据时查找一级缓存，最后查询数据库 # 缓存中的数据会用镜像联系着数据库，如果数据库有更新，缓存中的数据会自动更新 SessionFactory对象与Session对象 SessionFactory:只创建一次，重量级对象，线程安全，可以共享，实例变量，开始时创建 Session:创建多次，轻量级对象，线程不安全，不可以共享，局部变量，临时创建 实现代码 /** * 提供hibernate session * 并且用threadLocal跟踪实现无参删除 * * @author Administrator * */ public final class HibernateUtil { // 单例的SessionFactory工厂 private static SessionFactory sessionFactory; // 单例的ThreadLocal&lt;Session&gt;实例，但是每个调用者都有自己独有的方法？ private static ThreadLocal&lt;Session&gt; threadLocal; /** * 解析配置文件（properties,xml）到hibernate 的配置JavaBean,常驻内存 * */ static{ // 在这里加载了hibernate.properties配置文件（这里可以配置数据库），执行其它配置 // 相当于jdbc中的DriverManager类（如果配置了数据库，相当于也注册了连接数据库的类文件 【Class.forName(&#34;..Driver&#34;)语句 ..Driver 新建实例的时候自动向DriverManager注册自己】） Configuration config = new Configuration(); // 这里写xml配置文件对于src/目录的相对路径,加载映射用xml文件 config.addResource(&#34;hibernate.hbm.xml&#34;); // 加载src/目录下的hibernate.cfg.xml配置文件 config.configure(); # configure(&#34;classpath:hibernate.cfg.xml&#34;); 1.configure方法中可以加路径 2.classpath:代表src/目录 // 导入org.hibernate.SessionFactory类而非org.hibernate.classic.SessionFactory类 sessionFactory = config.buildSessionFactory(); } /** * 从单例工厂中得到被跟踪定位(每个调用者)的Session对象,没有就创建 * * @return */ public static Session getSession(){ /* 根据不同的调用者返回跟踪的不同的Session对象,如果是第一次调用，就创建新的session，绑定到单例的ThreadLocal对象中记录，返回给调用者 * 如果不是第一次调用 ，也能返回让其得到原来为它创建的Session对象 */ Session session = threadLocal.get(); if(session == null){ session = sessionFactory.openSession(); threadLocal.set(session); } return session; } /** * 删除调用者在ThreadLocal实例中的跟踪记录，并且关闭该Session实例 * */ public static void closeSession(){ Session session = threadLocal.get(); if(session != null){ session.close(); threadLocal.remove(); } } } hql # hql特性 1.hql是hibernate专用，有专用的技术转换hql到sql,但降低效率 2.hql完全面向对象,只出现类，属性，操作符和关键字,例如sum(),order by 而sql是面向关系的语言 使用语句 Query query = session.createQuery(hql); Customer c = (Customer)query.uniqueResult(); # 只返回一条结果 List&lt;Customer&gt; list = query.list(); # 返回多条结果 常用 api session.createQuery() session.getNamedQuery() # 从映射文件中加载&lt;query&gt;标签配置的与&lt;class&gt;标签同级的hql语句 query.setString(&#34;&#34;,&#34;&#34;) Object o = query.uniqueResult(); List list = query.list(); 分页 query.setFirstResult(0); # 开始标号 setMaxResults(3); # 最多显示的条数 query语句 习惯用别名替代类名 # from后面出现的是类名，where中比较的是对象属性（已经在映射文件中映射到了表名与字段名） 占位符 冒号占位符 &#34;from Customer c where c.name = :cname&#34; query.setString(&#34;cname&#34;,&#34;司马懿&#34;); 问号占位符 &#34;from Customer c where c.name = ?&#34; query.setString(0,&#34;司马懿&#34;); 映射文件中分离hql语句 # &lt;query&gt;标签与&lt;class&gt;标签同级 &lt;Query name=&#34;findCustomerByAge&#34;&gt; &lt;![CDATA[ from Customer c where c.age &lt; ? ]]&gt; Query query = session.getNamedQuery(&#34;findCustomerByAge&#34;); query.setInteger(0,60); 查询 &#34;from Customer where id = 1&#34; &#34;from Customer as c where c.name = &#39;司马懿&#39; &#34; &#34;from java.lang.Object&#34; # 映射中没有，写类的全称。查找 src/hibernate.cfg.xml中加载到内存中的映射的类对应的表中的所有记录 &#34;from Order o order by o.price desc&#34; 投影查询 1.&#34;select c.name,c.age from Customer c &#34; List&lt;Object[]&gt; list = query.list(); # Object[]中存储的是查询的select 语句中的数值 for(Object [] o : list){ System.out.println(o[0]); System.out.println(o[1]); } 2.&#34;select count(o), sum(o.price),min(o.price) from Order o&#34; # count()中的是表类名，统计实例数，查询Order表记录对象的个数 3.&#34;select o.customer.id from Order o&#34; 用到过的hql 级联抓取 FROM Role r LEFT JOIN FETCH r.privilegeSet WHERE r.id = :id 级联抓取顶级权限表（去重复） SELECT DISTINCT p FROM Privilege p LEFT JOIN FETCH p.childrenSet WHERE p.parent IS NULL 级联抓取角色 FROM Account a LEFT JOIN FETCH a.roleSet WHERE a.id = :id 三级级联抓取 # 对抓取的集合也可以直接抓取下一层 FROM Account a LEFT JOIN FETCH a.roleSet r LEFT JOIN FETCH r.privilegeSet WHERE a.login = :login AND a.pass = :pass 案例 # 编码 hibernate用用户操作系统的编码作为自己的编码 mysql5.5中设置编码：根目录下my文件 default-character-set=gbk 查询 # hibernate的查询方式 1.session.get(字节码,1) 2.session.load(字节码,1) 3.HQL查询session.createQuery() session.getNamedQuery() # 后面是从配置文件中载入hql语句 4.对象导航，如多表映射中 # 以对象的形式操作数据库中的表，如 ## p是person表的一个对象，c是card（身份证表）表的一个对象，p通过配置外键时定义的属性card得到自己的身份证表对象 ## 1.从表对象中：Card c = p.getCard(); ## 2.从hql语句中：select o.customer.id,o.customer.name,sum(o.price) from Order o group by o.customer.id 5.createSQLQuery原生sql语句查询： # 不要用，用了以后 hibernate跨平台的特性就没有了 String sql = &#34;select {a.*} from sysgroup {a} where department regexp ?&#34;; Query query = session.createSQLQuery(sql).addEntity(&#34;a&#34;,SysGroup.class); # addEntity将表的别名与类字节码关联起来（否则返回的表字段数据是Object类型,jsp页面读取时会出错） 连接查询的hql语法 # 只能连接有外键关系的表类，用表类中的关系类来表示第二张表，不能用笛卡尔积查询 ## 也就是说只能查一个表类 注意 hql连接查询的语法中用where替代了sql语法中的on 外连接与 sql不同，只能查询与一个表类有关系的外连接表（from语句后面不能写两个表类） 内连接 from Customer c join c.orderSet o where c.id = o.customer.id 外连接 # 这里与 sql不同，只能查询与一个表类有关系的外连接表 select c.name,count(o.orderno) from Customer c left join c.orderSet o group by c.name; 自连接 select a.name, b.name from emp a, emp b where a.mgr=b.id; 多表映射 # 主控方 # 就是只有主控方的操作成立，非主控方的改变忽略 inverse=&#34;true&#34; # false:主表管理，主表插入成功后，再发送n条更新语句来更新外键 ## true:从表管理，自己插入时加上：自己javabean中存放的外键关联 # 所以购物项中要关联购物车，由于购物车中已经一对多购物项，所以形成了双向关联 有该属性的标签 &lt;set&gt; 缺少主控方出现的问题 双向一对多中 1.hibernate生成的sql语句产生重复 2.主键冲突 # 插入操作时，由于“一”表级联插入“多”表，“多”表也要插入自己，它们的主键是相同的，会引起主键冲突 级联 # 数据库只有级联删除 cascade=&#34;save-update&#34; # 插入和更新 # 一般使用save-update，因为表一般软删除，（更新也没有，因为主键不更新，但是hibernate没有单save） cascade=&#34;delete&#34;; # 删除订单，级联删上层客户 cascade=&#34;none&#34; # 什么都不做（默认） cascade=&#34;all&#34; # save-update &#43; delete 有级联属性的标签 class标签下的 &lt;set&gt; &lt;one-to-one&gt; &lt;many-to-one&gt; 注意 级联插入的子表的id内容要为空，否则会变成级联更新 # 这里和单个数据插入时设置对象的id属性不起作用【只有hibernate的主键增长策略起作用】是不同的 单向一对多 # 集合映射的一种 “一”的类中 private Set&lt;Order&gt; orderSet = new LinkedHashSet&lt;Order&gt;(); 映射xml文件中 &lt;!-- set标签用于映射单向一对多 name表示单方的关联属性 table表示多方对应表的名字 key-column表示多方对应表的外健 one-to-many-class表示单方关联属性中的每个元素的类型 --&gt; &lt;set name=&#34;orderSet&#34; table=&#34;ORDERS&#34; cascade=&#34;all&#34;&gt; &lt;key column=&#34;CUSTOMERS_ID&#34;/&gt; &lt;one-to-many class=&#34;Order&#34;/&gt; &lt;/set&gt; 单向多对一 # 常用 映射xml文件中 &lt;!-- many-to-one映射多方的关联属性 name表示多方的关联属性名 column表示多方对应表的外健(存储关联类对应表的主键) cascade 级联 lazy表示“一”的类数据是否在一开始的时候就查询 # 如果lazy=&#34;proxy&#34;【相当于懒加载】，action类中加载“一”方数据时会出错，因为调用service类结束后线程中的session销毁,延迟加载找不到session会失败 fetch表示抓取策略 # 这里产生了hibernate的n&#43;1问题：一条查询语句查出&#34;一&#34;的集合，n条查询语句查出集合中每个元素的一 join代表用join语句查询(一条语句),但是hibernate在多对一的时候不支持fetch=&#34;join&#34; 默认是select，每次查询用一条select语句（多条语句） 解决：自己写新的查询方法查询,执行hql如：FROM Category c LEFT JOIN FETCH c.account --&gt; &lt;many-to-one name=&#34;customer&#34; column=&#34;CUSTOMERS_ID&#34; cascade=&#34;all&#34; /&gt; 双向一对多 # 双向映射就存在主控方的问题 ##　主表从表（外键【可以为空】） ## 集合映射的应用 1.同时配置单向一对多与单向多对一 2.在&#34;一&#34;表中配置inverse=&#34;true&#34;,反转权力，“多”表为主控方 双向一对一 # 主表从表（从表id既是主键又是外键） ## 双方都是主控方 1.两表都配置&lt;one-to-one/&gt; 2.主表配置cascade 3.从表中constrained=true属性（主键是否同时为外键约束） 多对多（单向左到右，单向右到左，双向） # 集合映射的应用 ## 多对多关系中一定要有主控方，否则主键冲突问题 1.创建中间表 # 中间表可以没有自己的JavaBean类文件对应，这时默认有联合主键（联合主键分别是保存的两个外键） students_id teachers_id # student_id 与 teachers_id为联合主键 ## sql语句是primary key(student_id,teacher_id); 创建中间表原因： 之所以中间表是因为两边的表中主键唯一，所以不能在一个记录中对对应另一个表的多个记录 中间表相当于把多对多分成两个一对多。 2.表对象类中都有对方表的set集合 3.映射xml中 # 可以用inverse,cascade ## cascade=&#34;none&#34;时,middle表中的记录也会被删除 ## 不配置主控方的话一边更新另一边，另一边也更新自己，会出错 &lt;set table=&#34;MIDDLES&#34; name=&#34;teacherSet&#34;&gt; &lt;key columnet=&#34;STUDENTS_ID&#34;/&gt; &lt;many-to-many class=&#34;Teacher&#34; column=&#34;TEACHERS_ID&#34;/&gt; 4.dao中 在cascade=&#34;all&#34;的配置下实现只删除老师与middle表中的教学关系 # 手工解除关系 # 不手工解除关系的话， 表记录对象：Teacher t1 ，t1删除时,级联删除middle表中数据，middle表中对应了学生的外键 ，由于多对一级联，会删除学生，由于该学生的主键可能会被middle表中的其它记录作为外键引用，所以不能删除，删除时会出错。 查询1号老师对应的学生,并解除关系 Teacher t1 for(Student s: t1.getStudentSet()){ s.getTeacherSet().remove(t1); } 1号老师解除关系 t1.setStudentSet(null); session.delete(t1); 缓存 # 缓存 1.一级缓存(session)中的数据是独享的，二级缓存(sessionFactory)中的数据是共享的 2.一级缓存中的数据改变时会更新二级缓存(如果二级缓存设置为read-only时，会更新出错) 3.二级缓存默认不能存po(持久化对象) ，只存放连接数据库的信息和映射文件 # 这时查询数据时的顺序是 一级缓存 -&gt; 数据库 启用二级缓存 # 开启的二级缓存中可以保存po ## 二级缓存的两个空间：普通缓存区(get、load)、查询缓存区(query对象查询) 普通缓存区 hibernate.properties文件中配置 hibernate.cache.provider_class org.hibernate.cache.HashtableCacheProvider # 只能内存缓存 org.hibernate.cache.EhCacheProvider # 也能磁盘缓存ehcache的jar包中ehcache-failsafe.xml配置文件中可以查到默认缓存配置 # 可以在hibernate的中文官方教程中查到缓存策略提供商的类 ## hibernate3.2之前缓存类jar包是集成的，默认是EhCache ## hibernate3.2之后缓存类jar包要自己导入 ## ...Provider类并不是实现类，而是桥接类 cache.use_second_level_cache true # 开启二级缓存（默认是true,但是没有配置缓存提供商之前不开启） hibernate.cfg.xml文件中配置使用二级缓存的类 # 可以设置&lt;cache&gt;的标签&lt;class&gt;&lt;set&gt; ## 设置&lt;set&gt;时，set对应表类的也要设置&lt;cache&gt;标签 &lt;class-cache usage=&#34;read-write&#34; class=&#34;pojo.Goods&#34; /&gt; usage属性 read-only：二级缓存只读(只是不能进行修改，但是从表中读取数据时一级缓存可以向二级缓存中放入数据) read-write:可读写 查询缓存区（hql语句）：默认不开启 # 因为hql命中率低(要求hql语句相同才行，模糊查询每次基本不同),每次查找会到缓存，找不到再到数据库，查询完数据再存入缓存，效率低 ## 不配置的话查询还会存到缓存，但只提供get使用，hql自己不用 1.首先开启普通缓存区（设置了表类可以缓存） 2.在query对象中开启查询缓存区 query.setCacheable(true); 查询顺序：一级缓存 -&gt; 二级缓存 -&gt; 数据库 缓存提供商配置 ehcache缓存提供商 创建src/ehcache.xml配置文件，使用ehcache缓存时会自动加载其中的配置 &lt;diskStore path=&#34;java.io.tmpdir&#34;/&gt; # 设置缓存目录，java.io.tmpdir指操作系统的临时目录 diskPersistent diskExpiryThreadIntervalSeconds # 这两个集群中使用，上面是是否集群持久化，下面是设置持久化时间 maxElementsInMemory # 内存支持最大对象数目(溢出的对象会存到硬盘中) overflowToDisk # 内在到最大数目时是否缓存到硬盘 eternal # 缓存是否永久有效，如果为true，则timeToIdleSeconds与timeToLiveSeconds不起作用 timeToLiveSeconds # 内存中缓存最大存活时间，服务器启动的时间加入其中 timeToIdleSeconds # 缓存不被访问时最大存活时间 memoryStoreEvictionPolicy # 内存中对象的替换算法FIFO(先进先出first in first out) ## LRU(最近最未使用算法,最久没有被访问的对象踢出) ## LFU(最少未被使用算法,考虑了对象的访问频率,踢出最近最少被访问的对象) ## 是windows自己的替换算法 清空缓存 一级缓存：session.clear(); 二级缓存：sessionFactory.close(); 集合映射 # 作用 集合包含于表类中，对应其一个属性，相当于该类对应表的一个子表 每种集合对应一张表，内容对应记录。 把java类中经常使用的数据结构对应到表中 使用 javaBean（User）中 private Set&lt;String&gt; telSet = new LinkedHashSet&lt;String&gt;(); private List&lt;String&gt; cityList = new ArrayList&lt;String&gt;(); private Map&lt;String,String&gt; telCityMap = new LinkedHashMap&lt;String,String&gt;(); xml文件中 &lt;set name=&#34;telSet&#34; table=&#34;TELS&#34;&gt; &lt;key column=&#34;USERS_ID&#34;/&gt; # 外键列：集合所创建的表的外键列名 &lt;element column=&#34;TEL&#34; type=&#34;string&#34;/&gt; # 内容列：这里必需要有type # set中也可以把&lt;element&gt;标签换成&lt;one-to-many class=&#34;Order&#34;/&gt;标签来对应JaveBean作为值，这就是一对多的映射 &lt;list name table&gt; &lt;key column/&gt; &lt;list-index column=&#34;IDX&#34;/&gt; # 索引列：表中的索引号列(对应在list中的索引) &lt;element column type/&gt; &lt;map name table&gt; &lt;key&gt; &lt;map-key type column&gt; # map对应key的列 &lt;element column type&gt; dao中使用 user.getTelSet().add(&#34;131&#34;); 检索策略 # hibernate检索的两种类型 立刻检索:session.get,query.list &lt;class lazy=&#34;true&#34;&gt;标签中类的检索策略，get方法与list都不遵循 延迟检索:session.load # 初始时是代理对象,使用时查询 只有load方法遵循&lt;class lazy=&#34;true&#34;&gt;标签中类的检索策略 检索方法是load时 lazy属性出现在&lt;class&gt;与&lt;set&gt;标签中,两个标签中lazy属性的含义是不同的，两个lazy属性都是对load方法执行时是否查询数据库进行设置。 # &lt;class&gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中除了set集合之外的所有属性 ## &lt;set&gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中set集合的数据 ## &lt;class&gt;中默认lazy属性的值为true ## &lt;set&gt;中默认lazy属性的值为true true true 时 查类时没有查集合 false true 时 查类时没有查集合 false false 时 查类时查集合 true false 时 查类时没有查集合 经验 # 删除的两种方法 session.delete(session.get(Category.class,id)); # 先查询再删除，效率低 session.createQuery(&#34;delete Categroy c where c.id=:id&#34;).setInteger(&#34;id&#34;,id).executeUpdate(); # 执行hql语句，效率高 hibernate注解 hibernate3.6支持注解 javaee5不支持，默认关闭 javaee6支持，默认开启，此时不加载注解配置文件会报错，所以要关掉 hibernate.cfg.xml中 &lt;property name=&#34;javax.persistence.validation.mode&#34;&gt;none&lt;/property&gt; DB Browser反射编译表的生成映射文件和类的时候，会生成项目目录下hibernate.reveng.xml的临时配置文件，可以删掉 映射文件class属性 dynamic-update=&#34;true&#34; # 动态更新，只有对相同的session有效，而且性能不好 ## 用字段设置中的update=&#34;false&#34;（对象中有字段值时更新，没有时不更新）属性来设置动态更新 映射文件set标签属性 Order-by=&#34;id&#34; # set中级联对象按照&#34;id&#34;属性进行排序 c3p0 # c3p0并不是hibernate默认的连接池（默认的是hibernate自带的连接池算法） 配置c3p0以后自动关闭Hibernate自带的连接池，而使用c3p0连接池 hibernate.cfg.xml文件中 &lt;!-- 最大连接数 --&gt; &lt;property name=&#34;hibernate.c3p0.max_size&#34;&gt;20&lt;/property&gt; &lt;!-- 最小连接数 --&gt; &lt;property name=&#34;hibernate.c3p0.min_size&#34;&gt;5&lt;/property&gt; &lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&gt; &lt;property name=&#34;hibernate.c3p0.timeout&#34;&gt;120&lt;/property&gt; &lt;!-- 最大的PreparedStatement的数量 --&gt; &lt;property name=&#34;hibernate.c3p0.max_statements&#34;&gt;100&lt;/property&gt; &lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--&gt; &lt;property name=&#34;hibernate.c3p0.idle_test_period&#34;&gt;120&lt;/property&gt; &lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&gt; &lt;property name=&#34;hibernate.c3p0.acquire_increment&#34;&gt;2&lt;/property&gt; &lt;!-- 每次都验证连接是否可用 --&gt; &lt;property name=&#34;hibernate.c3p0.validate&#34;&gt;true&lt;/property&gt; hibernate.properties文件中 hibernate.c3p0.min_size=5 hibernate.c3p0.max_size=20 hibernate.c3p0.timeout=1800 hibernate.c3p0.max_statements=50 映射 # hbm.xml 位置与名称： domain.xx.java 文件同级目录 xx.hbm.xml 约束文件位置 hibernate3.jar/org/hibernate/hibernate-mapping-3.0.dtd 从其中复制约束头 源码中的案例文件 \project\tutorials\中搜索 hbm.xml 类-表映射的特点 1.映射JavaBean到表字段（动态占位符），可以使用面向对象的hql语名生成sql语句 2.session中保存类对象，缓存查询过的表的内容 3.在映射关系的xml文件中可以设置主键的改变方式（这样以后dao类中设置的主键内容被配置文件中的设置覆盖） 主键 表中的主键 自然主键：有业务逻辑含义的字段（如name）（多个自然主键：联合主键） 代理主键 hibernate中id的增加类型 increment 整型,不依赖数据库自增,多线程不安全 uuid 缺点：占空间 identity 整型，依赖数据库自增,线程安全 sequence 专用于oracle数据库,要用特定名字的序列，create sequence hibernate_sequence;线程安全 native(重点) 根据情况判断是identity或sequence assigned 自然主键：&lt;id name=&#34;name&#34; column=&#34;name&#34;&gt;,线程不安全 composite-id 多个自然主键,表的javaBean必须实现序列化(1.对象序列化到硬盘、数据库【其它JavaBean有id属性，hibernate自动实现序列化】2.线程间传递数据) &lt;composite-id&gt;&lt;key-property name=&#34;firstname&#34; column=&#34;firstname&#34;/&gt;&lt;key-property name=&#34;firstname&#34; column=&#34;lastname&#34;/&gt; 持久化对象的两种类型 实体型：具有id属性的类，映射成一条含有id主键的完整记录 值类型或组件：与上面相反(被实体型包含)，如 # 包含以后会把组件的属性添加到实体类属性的后面，一起当作一张表，仅此而已 # Address province city area 映射组件型属性 1.类中引用组件：private Address address 2.映射 &lt;component name=&#34;address&#34; class=&#34;Address&#34;&gt;&lt;property name column/&gt; 3.dao中 star.setAdrress(address); 内容 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &#34;-//Hibernate/Hibernate Mapping DTD 3.0//EN&#34; &#34;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&#34;&gt; &lt;hibernate-mapping package=&#34;hibernate.domain&#34;&gt; &lt;class name=&#34;Hero&#34; table=&#34;heros&#34; dynamic-insert=&#34;true&#34;&gt; # 设置动态插入为true:如果是null的值，不再插入 ## 如果不设定动态插入，会插入数据库null值，数据库中设定的默认值不会起作用 &lt;!-- hibernate通过自己内部的类型type=&#34;&#34;,来转换java类型与sql类型之间的转换，一般不必写，自动反射 --&gt; &lt;!-- id 是指主键，property是属性 --&gt; &lt;id name=&#34;id&#34; column=&#34;id&#34;&gt; &lt;!-- hibernate内部的主键生成器 --&gt; &lt;generator class=&#34;increment&#34;/&gt; &lt;/id&gt; &lt;property name=&#34;name&#34; column=&#34;name&#34;&gt;&lt;/property&gt; &lt;property name=&#34;gender&#34; column=&#34;gender&#34;&gt;&lt;/property&gt; &lt;property name=&#34;age&#34; column=&#34;age&#34;&gt;&lt;/property&gt; &lt;property name=&#34;birthday&#34; column=&#34;birthday&#34;&gt;&lt;/property&gt; &lt;property name=&#34;des&#34; column=&#34;des&#34;&gt;&lt;/property&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; javaBean 实现序列化接口 在有名为id属性的JavaBean中，hibernate会自动实现序列化接口 没有名为id属性的JavaBean中，需要我们自己实现序列化接口 public class Hero implements java.io.Serializable{ private Integer id; private String name; private String gender; private Integer age; private Date birthday; private String des; }">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:modified_time" content="2021-09-22T21:45:53+08:00">
<title>Hibernate | ukeate的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://ukeate.com/docs/middleware/library/hibernate/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.583fa0f4b9042b18aff2c52da52cf49a4f5a6745f9e09453d85a938cfec8ee01.js" integrity="sha256-WD&#43;g9LkEKxiv8sUtpSz0mk9aZ0X54JRT2FqTjP7I7gE=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span>ukeate的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>







  
<ul>
  
  <li>
    <a href="/posts/"  >
        Blog
      </a>
  </li>
  
</ul>










  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/" class="">基本功</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/speach/" class="">演说</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/body/" class="">身体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/" class="">Computer</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/principle/" class="">支撑-原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/performance/" class="">Performance</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/" class="">算法</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/thought/" class="">算法思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/data_structure/" class="">数据结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/math/" class="">数学</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/" class="">架构</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/" class="">代码</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/security/" class="">Security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/design_mode/" class="">Java设计模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/" class="">工程设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/ddd/" class="">工程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/frontend/" class="">前端</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>战略性技术</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/" class="">AI</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/map/" class="">知识图谱</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/framework/" class="">Framework</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/media/" class="">媒体</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/middle_platform/" class="">中台</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/block_chain/" class="">Block Chain</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Cloud</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/" class="">Datalake</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/ecology/" class="">Ecology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/edge/" class="">Edge</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/" class="">Manage</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/" class="">组织</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/people/" class="">人员</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/" class="">Method</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/product_plan/" class="">产品规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/code_plan/" class="">代码规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/ops_plan/" class="">运维规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/advice_plan/" class="">咨询规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/architect/" class="">服务治理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/project_plan/" class="">项目规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/test_plan/" class="">测试规划</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/summary/" class="">这些年我做过的技术</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/" class="">程序语言</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/principle/" class="">程序语言原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/haskell/" class="">Haskell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/elixir/" class="">Elixir</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/clojure/" class="">Clojure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/js/" class="">JS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/java_reactive/" class="">Java响应式编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/javaweb/" class="">JavaWeb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/juc/" class="">Java并发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/jvm/" class="">JVM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/collection/" class="">Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/spring/" class="">Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/" class="">Markup Language</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/html/" class="">Html</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/css/" class="">Css</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/" class="">工具</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/" class="">运维</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/monitor/" class="">Monitor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/docker/" class="">Docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/k8s/" class="">Kubernetes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/enterprise_system/" class="">企业级系统</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/" class="">Develop</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/eclipse/" class="">Eclipse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/vim/" class="">VIM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/apple/" class="">Apple</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/jetbrains/" class="">Jetbrains</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/" class="">Linux</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_program/" class="">LinuxProgram</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/scene/" class="">LinuxScene</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_tool/" class="">LinuxTool</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/framework/" class="">Framework</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/physics/" class="">实物工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/" class="">测试</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/debug/" class="">程序调试</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/" class="">数据库</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mongodb/" class="">Mongodb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/postgresql/" class="">Postgre SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/oracle/" class="">Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/" class="">中间件</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/" class="">支撑-分布式</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/spring_cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/" class="">前端</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/bootstrap/" class="">Bootstrap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/threejs/" class="">Threejs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/angular/" class="">Angular</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/jquery/" class="">Jquery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/react/" class="">React</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/" class="">小功能</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/hibernate/" class="active">Hibernate</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Container</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nginx/" class="">Nginx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nodejs/" class="">Nodejs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/" class="">Cache</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/ops/" class="">Ops</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/work_code/" class="">Work Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/template/" class="">模板配置</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/soft_arch/" class="">软考架构师</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/misc/" class="">杂项</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Hibernate</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a></li>
    <li><a href="#优化">优化</a></li>
    <li><a href="#基本概念">基本概念</a></li>
    <li><a href="#使用">使用</a></li>
    <li><a href="#session">session</a></li>
    <li><a href="#hibernatecfgxml">hibernate.cfg.xml</a></li>
    <li><a href="#hibernateproperties">hibernate.properties</a></li>
    <li><a href="#hibernateutil">HibernateUtil</a></li>
    <li><a href="#hql">hql</a></li>
    <li><a href="#案例">案例</a></li>
    <li><a href="#查询">查询</a></li>
    <li><a href="#多表映射">多表映射</a></li>
    <li><a href="#缓存">缓存</a></li>
    <li><a href="#集合映射">集合映射</a></li>
    <li><a href="#检索策略">检索策略</a></li>
    <li><a href="#经验">经验</a></li>
    <li><a href="#c3p0">c3p0</a></li>
    <li><a href="#映射">映射</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>优点
    完全面向对象编程思想，无sql
    减少代码
    控制数据库访问，降低访问数据库的频率（第一次访问后，数据存储在内存的缓存中），提升效率
    hibernate具有独立性（访问层随时可以更换）
特性
    不写hbm.xml映射文件，而是基于注解的验证
    对象、集合、属性的延迟加载
        dao层之外使用延迟对象时，由于连接已关闭, 会报Nosession异常
目录
    .                                        # hibernate程序包
    documentation                # 文档
    lib                                        # 所有依赖包
    project                                # 源码文件
加载顺序
    后面的覆盖前面的
    hibernate.properties中的配置被覆盖
        # 因为该文件中的配置在new Configuration() 的时候就加载，而之后的xml配置文件是调用configuration.addResource()的方法加载的，新加载的配置覆盖了原来的配置   hibernate3.6之后可以基于注解对javaBean的数据进行验证（jsr303标准）
开发流程
    加载配置: jdbc参数，数据库方言，hbm映射
    创建SessionFactory    # 内有连接池
    创建session
    事务处理
    关闭session
    关闭连接池
对象状态
    𣊬时态     # 没有OID(持久化标识), 没有关联session
    持久态     # 有OID, 与session关联, 事务未提交
    脱管态     # 有OID, 没有关联session
缓存机制
    一级缓存(session)
        事务级，事务结束缓存失效    # 请求同一对象，取得同一实例
        总是打开
    二级缓存
        SessionFactory级别，session共享
        缓存散装持久化实例, 有不同缓存策略
        先设置策略，再设置过期时间与cache提供器
    优点
        提高速度、减小压力
        缓存失效时，不立即查找，而是合并sql查找
查询方式
    HQL
    QBC(命名查询)
    SQL
get与load
    get立即加载，load延时加载
    get先查一级缓存，再查二级缓存，再查数据库, load查一级缓存，没有时创建代理对象，需要时再查二级缓存和数据库
        # 代理对象只存id
    get没有时返回null, load抛异常
检索策略            # 取关联对象
    立即检索        # 一次全加载, select多
    延迟检索        # 访问游离状态代理类，需要在持久化状态时已被初始化
    迫切左外连接检索 # 用外连接取代select，全加载
</code></pre>
<h1 id="优化">
  优化
  <a class="anchor" href="#%e4%bc%98%e5%8c%96">#</a>
</h1>
<pre><code>数据库设计调整
HQL优化
api正确使用
配置参数          # 日志、查询缓存，fetch_size, batch_size等
映射文件优化      # id生成策略，二级缓存，延迟加载，关联优化
一级缓存管理, 二级缓存策略
事务控制策略
</code></pre>
<h1 id="基本概念">
  基本概念
  <a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#</a>
</h1>
<pre><code>o-&gt; hibernate 相当于dao层，层次划分中是访问层，解决增、删、改、查、批处理五个问题
o-&gt; hibernate实现orm(对象关系映射标准，完全面向对象编程思想)
    DBUtils与i/mybatis 与hibernate 是同样的，同样实现的是orm标准
    它们的区别在于
        hibernate中不写sql语句
        ibatis中写少量sql语句
        DBUtils中写sql语句
    它们的另一个相同点是
         底层全都是jdbc
o-&gt; 结构对应 javabean中的 类，对象，属性
         数据库中的            表，记录，字段
o-&gt; hql        hibernate query language，hibernate自己的sql语言，需要使用antlr jar包中的方法内部转换成sql语言才能使用
o-&gt; 正向工程：JavaBean生成表，反向工程：表生成JavaBean
</code></pre>
<h1 id="使用">
  使用
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8">#</a>
</h1>
<pre><code>1.导入核心包(10 + 1个)
    hibernate3.jar                                # 核心包
    c3p0-0.9.1.jar
    antlr-2.7.6.jar                                # 转换hql到sql
    commons-collections-3.1.jar        # apache的集合增强包
    dom4j-1.6.1.jar
    javassist-3.9.0.GA.jar                # 动态代理
    jta-1.1.jar                                        # java transaction api        处理事务用
    slf4j-api-1.5.8.jar
    log4j.jar
    slf4j-log4j12.jar                        # 三个日志
    +
    mysql-connector-java-5.1.7.bin.jar
        
2.建立目录
    hibernate.dao
            demo.java
    hibernate.db
            xx.sql
    hibernate.domain
            xx.java
    hibernate.util
            HibernateUtil.java
3.创建映射文件
    xx.java文件的同目录下，创建
            xx.hbm.xml
4.创建配置文件
    src/hibernate.cfg.xml        (可变)
    src/hibernate.properties
5.写提供hibernate session的工具类
    HibernateUtil
6.demo中用hibernate session创建事务进行数据库操作
    demo.java
</code></pre>
<h1 id="session">
  session
  <a class="anchor" href="#session">#</a>
</h1>
<pre><code>查询不需要事务，其它都需要事务

流程
    Session session = HibernateUtil.getSession();
    Transaction t = session.getTransaction();
    t.begin();
    session.update(hero);
    session.delete(hero);
    t.comment();
    
批量
    t.begin();
    session.save(hero);
    t.commit();
    session.clear();
    
    查询
    Query query = session.createQuery(hql);
    List&lt;Hero&gt; heroList = query.list();
    
    查询2
    Query query = session.createQuery(hql);
    query.setString(0,name);                // hql中参数从0开始
    query.setString(1,des);
    Hero hero = (Hero) query.uniqueResult();        // 只有一个结果时使用
    
    修改
    Query query = session.createQuery(hql);
    int i = query.executeUpdate();

结尾
    }catch(Exception e){
            e.printStackTrace();
            t.rollback();
    }finally{
            HibernateUtil.closeSession(); // session.close();
    }
        
session
    元素的状态
        # oid: object id,hibernate 的id值唯一并且与表中的数据一一对应
        ## hibernate中分辨数据只看oid
        临时（new），无oid,不在session中.生成sql语句
            持久化（persistence object）：session.save(hero),有oid,在session中;(saveOrUpdate(hero))
            游离：session.evict(hero),有oid,不在session中,session.update(hero)重新持久化
            删除：sesssion.delete(hero),有oid,不在session中,不可恢复,提交后可修改数据库
                # 隐含将po对象转成持久化状态，并生成delete语句。提交后成delete状态，执行语句
                ## 临时、持久、游离都可以调用
                ## 临时调用delete时会删除数据库中相应id的值 ，危险
    函数
        get 与 load
            session.get(hero.class,1),从数据库得到持久状态对象
                与数据库交互
                查到时返回po
                查不到时返回null
            session.load(hero.class,1)
                不与数据库交互,返回自己创建的po(只有id)
            访问非id值的时候，与数据库交互
        session.clear() # session中的引用变量清空
        session.close() # clear() + 关闭session对象，回收资源，但session非空
        session.isOpen()
        session.flush() # 对session中的更改部分生成相应的sql语句,只在session中，不访问数据库
        session.update()    # 只是将游离重新持久化,不产生sql语句。（执行更新语句时加上它增加可读性）
                                                ## update()方法执行时会检验一级缓存（session）中是否有 oid相同的po
                                                ## ,同时会连接数据库，查询一级缓存中po与数据库中记录的一一对应关系
        session.commit()    # flush() + 提交事务
</code></pre>
<h1 id="hibernatecfgxml">
  hibernate.cfg.xml
  <a class="anchor" href="#hibernatecfgxml">#</a>
</h1>
<pre><code>必要性
        必须配置

目录与文件名
        任意，建议 src/hibernate.cfg.xml

源码中的案例文件：
        \project\tutorials\web\src\main\resources\hibernate.cfg.xml
        \project\etc\hibernate.cfg.xml
约束文件位置
        hibernate3.jar/org/hibernate/hibernate-configuration-3.0.dtd
数据库连接属性与方言属性的属性名和值可以查找
        \project\etc\hibernate.properties                # 由于xml文件中配置要覆盖的是hibernate.properties文件中的属性
                                                                                        ## 所以属性内容从hibernate.properties文件的属性中查找
        方言类的位置是：hibernate3.jar/org.hibernate/dialect/中查找到相应的类，
                这是最终的路径，（oracle的通用方言类的类路径 可以用这种方法找到，hibernate.properties配置文件中没有写）
        
加载
        该配置文件属于纯人为配置，需要在Configuration类的实例中调用addResource(&quot;&quot;)方法加载
        addResource()方法中的参数是本配置文件相对于src/目录的全限定名
        
作用
        1.映射数据库
        2.配置 类-表映射 资源xml文件的路径
        
内容
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE hibernate-configuration PUBLIC
        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;&gt;
&lt;hibernate-configuration&gt;
        &lt;session-factory&gt;
                &lt;!-- 配置访问数据库需要的属性 --&gt;
                &lt;property name=&quot;connection.driver_class&quot;&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;
                &lt;property name=&quot;connection.url&quot;&gt;jdbc:oracle:thin:@localhost:1521:orcl&lt;/property&gt;
                &lt;property name=&quot;connection.username&quot;&gt;scott&lt;/property&gt;
                &lt;property name=&quot;connection.password&quot;&gt;tiger&lt;/property&gt;
                &lt;!-- 配置方言 通知hibernate访问哪种数据库的语法结构--&gt;
                &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt;
                &lt;!-- 类表映射文件 --&gt;
                &lt;mapping resource=&quot;hibernate/domain/Hero.hbm.xml&quot;/&gt;
        &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>
<h1 id="hibernateproperties">
  hibernate.properties
  <a class="anchor" href="#hibernateproperties">#</a>
</h1>
<pre><code>必要性
        不必须配置
位置：
        该文件的位置在src/目录下是不可以改变的，是hibernate加载配置的入口 

源码中的参考文件：
        /project/etc/hibernate.properties
                # oracle的通用驱动可以从hibernate3.jar/org.hibernate/dialect包中查找
        
作用
        1.配置连接的数据库，更换数据库只需要更改配置文件即可
        2.配置数据库方言
        3.其它控制开关

方言的作用
        更换数据库访问形式，实现通用性

内容
        hibernate.dialect org.hibernate.dialect.MySQLDialect
        hibernate.connection.driver_class com.mysql.jdbc.Driver
        hibernate.connection.url jdbc:mysql:///outrun
        hibernate.connection.username outrun
        hibernate.connection.password asdf
        hibernate.show_sql true                # 开关：显示实际操作数据库的sql语句
自动创建表
    hibernate.hbm2ddl.auto=create      # 每次都创建
    hibernate.hbm2ddl.auto=update      # 没有时再创建(有但是结构不同时会按照酌情增加列字段)
                                                                            ## 当更新或插入记录不满足条件时会出错
缓存
        hibernate.cache.provider_class                # 开启二级缓存中的普通区           
        hibernate.cache.use_query_cache                # 开启二级缓存中的查询区
</code></pre>
<h1 id="hibernateutil">
  HibernateUtil
  <a class="anchor" href="#hibernateutil">#</a>
</h1>
<pre><code>目的
        对SessionFactory返回Session的方式进行了重构，通过调用该静态工具方法
        实现只有一个SessionFactory实例，由它产生和销毁很多Session的工厂机制。

缓存
        SessionFactory 是二级缓存
        Session 是一级缓存
                # 查询时，先在二级缓存中查找，没有数据时查找一级缓存，最后查询数据库
                # 缓存中的数据会用镜像联系着数据库，如果数据库有更新，缓存中的数据会自动更新

SessionFactory对象与Session对象
        SessionFactory:只创建一次，重量级对象，线程安全，可以共享，实例变量，开始时创建 
        Session:创建多次，轻量级对象，线程不安全，不可以共享，局部变量，临时创建 
        

实现代码
/**
* 提供hibernate session 
* 并且用threadLocal跟踪实现无参删除
* 
* @author Administrator
*
*/
public final class HibernateUtil {
        // 单例的SessionFactory工厂 
        private static SessionFactory sessionFactory;
        // 单例的ThreadLocal&lt;Session&gt;实例，但是每个调用者都有自己独有的方法？
        private static ThreadLocal&lt;Session&gt; threadLocal;
        /**
        * 解析配置文件（properties,xml）到hibernate 的配置JavaBean,常驻内存
        * 
        */
        static{
                // 在这里加载了hibernate.properties配置文件（这里可以配置数据库），执行其它配置
                // 相当于jdbc中的DriverManager类（如果配置了数据库，相当于也注册了连接数据库的类文件 【Class.forName(&quot;..Driver&quot;)语句 ..Driver 新建实例的时候自动向DriverManager注册自己】）
                Configuration config = new Configuration();
                // 这里写xml配置文件对于src/目录的相对路径,加载映射用xml文件
                config.addResource(&quot;hibernate.hbm.xml&quot;);
                // 加载src/目录下的hibernate.cfg.xml配置文件
                config.configure();                # configure(&quot;classpath:hibernate.cfg.xml&quot;);
                                                                        1.configure方法中可以加路径
                                                                        2.classpath:代表src/目录
                // 导入org.hibernate.SessionFactory类而非org.hibernate.classic.SessionFactory类
                sessionFactory = config.buildSessionFactory();
        }
        /**
        * 从单例工厂中得到被跟踪定位(每个调用者)的Session对象,没有就创建
        * 
        * @return
        */
        public static Session getSession(){
                /* 根据不同的调用者返回跟踪的不同的Session对象,如果是第一次调用，就创建新的session，绑定到单例的ThreadLocal对象中记录，返回给调用者
                * 如果不是第一次调用 ，也能返回让其得到原来为它创建的Session对象 
                */ 
                Session session = threadLocal.get();
                if(session == null){
                        session = sessionFactory.openSession();
                        threadLocal.set(session);
                }
                return session;
        }
        /**
        * 删除调用者在ThreadLocal实例中的跟踪记录，并且关闭该Session实例
        * 
        */
        public static void closeSession(){
                
                Session session = threadLocal.get();
                if(session != null){
                        session.close();
                        threadLocal.remove();
                }
        }
}
</code></pre>
<h1 id="hql">
  hql
  <a class="anchor" href="#hql">#</a>
</h1>
<pre><code>hql特性
    1.hql是hibernate专用，有专用的技术转换hql到sql,但降低效率
    2.hql完全面向对象,只出现类，属性，操作符和关键字,例如sum(),order by
            而sql是面向关系的语言
使用语句
        Query query = session.createQuery(hql);
        Customer c = (Customer)query.uniqueResult();        # 只返回一条结果
        List&lt;Customer&gt; list = query.list();                        # 返回多条结果

常用 api
        session.createQuery()
        session.getNamedQuery()                # 从映射文件中加载&lt;query&gt;标签配置的与&lt;class&gt;标签同级的hql语句
        query.setString(&quot;&quot;,&quot;&quot;)
        Object o = query.uniqueResult();
        List list = query.list();
        分页
                query.setFirstResult(0);        # 开始标号
                setMaxResults(3);              # 最多显示的条数
        
query语句                习惯用别名替代类名
                # from后面出现的是类名，where中比较的是对象属性（已经在映射文件中映射到了表名与字段名）
        占位符
                冒号占位符
                        &quot;from Customer c where c.name = :cname&quot;
                        query.setString(&quot;cname&quot;,&quot;司马懿&quot;);
                问号占位符
                        &quot;from Customer c where c.name = ?&quot;
                        query.setString(0,&quot;司马懿&quot;);
        映射文件中分离hql语句
                        # &lt;query&gt;标签与&lt;class&gt;标签同级
                &lt;Query name=&quot;findCustomerByAge&quot;&gt;
        &lt;![CDATA[
            from Customer c where c.age &lt; ? 
        ]]&gt;
        Query query = session.getNamedQuery(&quot;findCustomerByAge&quot;);
        query.setInteger(0,60);
        查询
                &quot;from Customer where id = 1&quot;
            &quot;from Customer as c where c.name = '司马懿' &quot;
            &quot;from java.lang.Object&quot;    # 映射中没有，写类的全称。查找 src/hibernate.cfg.xml中加载到内存中的映射的类对应的表中的所有记录
            &quot;from Order o order by o.price desc&quot;
                投影查询
                        1.&quot;select c.name,c.age from Customer c &quot;
                        List&lt;Object[]&gt; list = query.list();        # Object[]中存储的是查询的select 语句中的数值
                        for(Object [] o : list){
                System.out.println(o[0]);
                System.out.println(o[1]);
            }
            2.&quot;select count(o), sum(o.price),min(o.price) from Order o&quot;                # count()中的是表类名，统计实例数，查询Order表记录对象的个数 
            3.&quot;select o.customer.id from Order o&quot;
用到过的hql
        级联抓取
                FROM Role r LEFT JOIN FETCH r.privilegeSet WHERE r.id = :id
        级联抓取顶级权限表（去重复）
                SELECT DISTINCT p FROM Privilege p LEFT JOIN FETCH p.childrenSet WHERE p.parent IS NULL
        级联抓取角色        
                FROM Account a LEFT JOIN FETCH a.roleSet WHERE a.id = :id
        三级级联抓取                # 对抓取的集合也可以直接抓取下一层
                FROM Account a LEFT JOIN FETCH a.roleSet r LEFT JOIN FETCH r.privilegeSet WHERE a.login = :login AND a.pass = :pass
</code></pre>
<h1 id="案例">
  案例
  <a class="anchor" href="#%e6%a1%88%e4%be%8b">#</a>
</h1>
<pre><code>编码
    hibernate用用户操作系统的编码作为自己的编码

    mysql5.5中设置编码：根目录下my文件 default-character-set=gbk
</code></pre>
<h1 id="查询">
  查询
  <a class="anchor" href="#%e6%9f%a5%e8%af%a2">#</a>
</h1>
<pre><code>hibernate的查询方式
    1.session.get(字节码,1)
    2.session.load(字节码,1)
    3.HQL查询session.createQuery()        session.getNamedQuery()        # 后面是从配置文件中载入hql语句
    4.对象导航，如多表映射中
            # 以对象的形式操作数据库中的表，如
                ## p是person表的一个对象，c是card（身份证表）表的一个对象，p通过配置外键时定义的属性card得到自己的身份证表对象
                ## 1.从表对象中：Card c = p.getCard();
                ## 2.从hql语句中：select o.customer.id,o.customer.name,sum(o.price) from Order o group by o.customer.id
        5.createSQLQuery原生sql语句查询：        # 不要用，用了以后 hibernate跨平台的特性就没有了
                String sql = &quot;select {a.*} from sysgroup {a} where department regexp ?&quot;;
                Query query = session.createSQLQuery(sql).addEntity(&quot;a&quot;,SysGroup.class);
                        # addEntity将表的别名与类字节码关联起来（否则返回的表字段数据是Object类型,jsp页面读取时会出错）
连接查询的hql语法
                # 只能连接有外键关系的表类，用表类中的关系类来表示第二张表，不能用笛卡尔积查询
                ## 也就是说只能查一个表类
                注意
                        hql连接查询的语法中用where替代了sql语法中的on
                        外连接与 sql不同，只能查询与一个表类有关系的外连接表（from语句后面不能写两个表类）
        内连接
            from Customer c join c.orderSet o where c.id = o.customer.id
        外连接                # 这里与 sql不同，只能查询与一个表类有关系的外连接表
            select c.name,count(o.orderno) from Customer c left join c.orderSet o group by c.name;
        自连接
            select a.name, b.name from emp a, emp b where a.mgr=b.id;
</code></pre>
<h1 id="多表映射">
  多表映射
  <a class="anchor" href="#%e5%a4%9a%e8%a1%a8%e6%98%a0%e5%b0%84">#</a>
</h1>
<pre><code>主控方                # 就是只有主控方的操作成立，非主控方的改变忽略
        inverse=&quot;true&quot;
                # false:主表管理，主表插入成功后，再发送n条更新语句来更新外键
        ## true:从表管理，自己插入时加上：自己javabean中存放的外键关联
            # 所以购物项中要关联购物车，由于购物车中已经一对多购物项，所以形成了双向关联
        有该属性的标签
                &lt;set&gt;
        缺少主控方出现的问题
                双向一对多中
                        1.hibernate生成的sql语句产生重复
                        2.主键冲突                # 插入操作时，由于“一”表级联插入“多”表，“多”表也要插入自己，它们的主键是相同的，会引起主键冲突

级联                # 数据库只有级联删除
        cascade=&quot;save-update&quot;  # 插入和更新
                        # 一般使用save-update，因为表一般软删除，（更新也没有，因为主键不更新，但是hibernate没有单save）
    cascade=&quot;delete&quot;;  # 删除订单，级联删上层客户
    cascade=&quot;none&quot;  # 什么都不做（默认）
    cascade=&quot;all&quot;  # save-update + delete
        有级联属性的标签
                class标签下的
                        &lt;set&gt;
                        &lt;one-to-one&gt;
                        &lt;many-to-one&gt;
        注意
                级联插入的子表的id内容要为空，否则会变成级联更新                # 这里和单个数据插入时设置对象的id属性不起作用【只有hibernate的主键增长策略起作用】是不同的
                
单向一对多                        # 集合映射的一种
        “一”的类中
                private Set&lt;Order&gt; orderSet = new LinkedHashSet&lt;Order&gt;();
        映射xml文件中
                &lt;!-- set标签用于映射单向一对多 
                    name表示单方的关联属性
                    table表示多方对应表的名字
                    key-column表示多方对应表的外健
                    one-to-many-class表示单方关联属性中的每个元素的类型
                --&gt;
                &lt;set name=&quot;orderSet&quot; table=&quot;ORDERS&quot; cascade=&quot;all&quot;&gt;
                        &lt;key column=&quot;CUSTOMERS_ID&quot;/&gt;
                        &lt;one-to-many class=&quot;Order&quot;/&gt;
                &lt;/set&gt;
单向多对一                        # 常用
        映射xml文件中
                &lt;!--
                many-to-one映射多方的关联属性
                name表示多方的关联属性名
                column表示多方对应表的外健(存储关联类对应表的主键)
                cascade 级联
                lazy表示“一”的类数据是否在一开始的时候就查询                # 如果lazy=&quot;proxy&quot;【相当于懒加载】，action类中加载“一”方数据时会出错，因为调用service类结束后线程中的session销毁,延迟加载找不到session会失败
                fetch表示抓取策略
                                # 这里产生了hibernate的n+1问题：一条查询语句查出&quot;一&quot;的集合，n条查询语句查出集合中每个元素的一
                        join代表用join语句查询(一条语句),但是hibernate在多对一的时候不支持fetch=&quot;join&quot;
                        默认是select，每次查询用一条select语句（多条语句）
                                解决：自己写新的查询方法查询,执行hql如：FROM Category c LEFT JOIN FETCH c.account
                --&gt;
                &lt;many-to-one 
                        name=&quot;customer&quot; 
                        column=&quot;CUSTOMERS_ID&quot; 
                        cascade=&quot;all&quot;
                /&gt;
        
双向一对多  # 双向映射就存在主控方的问题  
                ##　主表从表（外键【可以为空】）        
                ## 集合映射的应用
        1.同时配置单向一对多与单向多对一
        2.在&quot;一&quot;表中配置inverse=&quot;true&quot;,反转权力，“多”表为主控方
双向一对一      # 主表从表（从表id既是主键又是外键）
                ## 双方都是主控方 
    1.两表都配置&lt;one-to-one/&gt;
    2.主表配置cascade
        3.从表中constrained=true属性（主键是否同时为外键约束）
        
多对多（单向左到右，单向右到左，双向）                # 集合映射的应用
                                                                ## 多对多关系中一定要有主控方，否则主键冲突问题
        1.创建中间表  
                        # 中间表可以没有自己的JavaBean类文件对应，这时默认有联合主键（联合主键分别是保存的两个外键）
                students_id
                teachers_id 
                        # student_id 与 teachers_id为联合主键
            ## sql语句是primary key(student_id,teacher_id);
                创建中间表原因：
                        之所以中间表是因为两边的表中主键唯一，所以不能在一个记录中对对应另一个表的多个记录
                        中间表相当于把多对多分成两个一对多。
        2.表对象类中都有对方表的set集合 
        3.映射xml中      # 可以用inverse,cascade
                                ##  cascade=&quot;none&quot;时,middle表中的记录也会被删除
                ## 不配置主控方的话一边更新另一边，另一边也更新自己，会出错
        &lt;set table=&quot;MIDDLES&quot; name=&quot;teacherSet&quot;&gt;
            &lt;key columnet=&quot;STUDENTS_ID&quot;/&gt; 
            &lt;many-to-many class=&quot;Teacher&quot; column=&quot;TEACHERS_ID&quot;/&gt;
        4.dao中
                在cascade=&quot;all&quot;的配置下实现只删除老师与middle表中的教学关系          # 手工解除关系
                        # 不手工解除关系的话， 表记录对象：Teacher t1
                                ，t1删除时,级联删除middle表中数据，middle表中对应了学生的外键
                                ，由于多对一级联，会删除学生，由于该学生的主键可能会被middle表中的其它记录作为外键引用，所以不能删除，删除时会出错。 
                
                查询1号老师对应的学生,并解除关系 
                        Teacher t1
                        for(Student s: t1.getStudentSet()){
                            s.getTeacherSet().remove(t1);
                        }
                        1号老师解除关系
                        t1.setStudentSet(null);
                        session.delete(t1);
</code></pre>
<h1 id="缓存">
  缓存
  <a class="anchor" href="#%e7%bc%93%e5%ad%98">#</a>
</h1>
<pre><code>缓存        
        1.一级缓存(session)中的数据是独享的，二级缓存(sessionFactory)中的数据是共享的
        2.一级缓存中的数据改变时会更新二级缓存(如果二级缓存设置为read-only时，会更新出错)
        3.二级缓存默认不能存po(持久化对象) ，只存放连接数据库的信息和映射文件 
                # 这时查询数据时的顺序是 一级缓存 -&gt; 数据库
                
启用二级缓存                # 开启的二级缓存中可以保存po
                                ## 二级缓存的两个空间：普通缓存区(get、load)、查询缓存区(query对象查询)
        普通缓存区
        hibernate.properties文件中配置
            hibernate.cache.provider_class 
                    org.hibernate.cache.HashtableCacheProvider                # 只能内存缓存
                    org.hibernate.cache.EhCacheProvider                                # 也能磁盘缓存ehcache的jar包中ehcache-failsafe.xml配置文件中可以查到默认缓存配置
                                                                            # 可以在hibernate的中文官方教程中查到缓存策略提供商的类
                                                                            ## hibernate3.2之前缓存类jar包是集成的，默认是EhCache
                                                                            ## hibernate3.2之后缓存类jar包要自己导入
                                                                            ## ...Provider类并不是实现类，而是桥接类
            cache.use_second_level_cache
                    true                                                # 开启二级缓存（默认是true,但是没有配置缓存提供商之前不开启）
        hibernate.cfg.xml文件中配置使用二级缓存的类              # 可以设置&lt;cache&gt;的标签&lt;class&gt;&lt;set&gt;
                                                                                        ## 设置&lt;set&gt;时，set对应表类的也要设置&lt;cache&gt;标签
                &lt;class-cache usage=&quot;read-write&quot; class=&quot;pojo.Goods&quot; /&gt;
                usage属性
                        read-only：二级缓存只读(只是不能进行修改，但是从表中读取数据时一级缓存可以向二级缓存中放入数据)
                        read-write:可读写
        查询缓存区（hql语句）：默认不开启
                        # 因为hql命中率低(要求hql语句相同才行，模糊查询每次基本不同),每次查找会到缓存，找不到再到数据库，查询完数据再存入缓存，效率低
            ## 不配置的话查询还会存到缓存，但只提供get使用，hql自己不用
                1.首先开启普通缓存区（设置了表类可以缓存）
                2.在query对象中开启查询缓存区
                        query.setCacheable(true);
        查询顺序：一级缓存 -&gt; 二级缓存 -&gt; 数据库

缓存提供商配置
        ehcache缓存提供商
                创建src/ehcache.xml配置文件，使用ehcache缓存时会自动加载其中的配置
                        &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;        # 设置缓存目录，java.io.tmpdir指操作系统的临时目录
                        diskPersistent
                        diskExpiryThreadIntervalSeconds                # 这两个集群中使用，上面是是否集群持久化，下面是设置持久化时间
                        maxElementsInMemory                                        # 内存支持最大对象数目(溢出的对象会存到硬盘中)
                        overflowToDisk                                                # 内在到最大数目时是否缓存到硬盘
                        eternal                                                                # 缓存是否永久有效，如果为true，则timeToIdleSeconds与timeToLiveSeconds不起作用
                        timeToLiveSeconds                                        # 内存中缓存最大存活时间，服务器启动的时间加入其中
                        timeToIdleSeconds                                        # 缓存不被访问时最大存活时间
                        memoryStoreEvictionPolicy                        # 内存中对象的替换算法FIFO(先进先出first in first out) 
                                                                                                ## LRU(最近最未使用算法,最久没有被访问的对象踢出) 
                                                                                                ## LFU(最少未被使用算法,考虑了对象的访问频率,踢出最近最少被访问的对象)      
                                                                                                ## 是windows自己的替换算法
清空缓存
        一级缓存：session.clear();
        二级缓存：sessionFactory.close();
</code></pre>
<h1 id="集合映射">
  集合映射
  <a class="anchor" href="#%e9%9b%86%e5%90%88%e6%98%a0%e5%b0%84">#</a>
</h1>
<pre><code>作用
        集合包含于表类中，对应其一个属性，相当于该类对应表的一个子表
        每种集合对应一张表，内容对应记录。
        把java类中经常使用的数据结构对应到表中

使用
        javaBean（User）中
                private Set&lt;String&gt; telSet = new LinkedHashSet&lt;String&gt;();
                private List&lt;String&gt; cityList = new ArrayList&lt;String&gt;();
                private Map&lt;String,String&gt; telCityMap = new LinkedHashMap&lt;String,String&gt;();
        xml文件中
                &lt;set name=&quot;telSet&quot; table=&quot;TELS&quot;&gt;
            &lt;key column=&quot;USERS_ID&quot;/&gt;        # 外键列：集合所创建的表的外键列名
            &lt;element column=&quot;TEL&quot; type=&quot;string&quot;/&gt;      # 内容列：这里必需要有type 
                    # set中也可以把&lt;element&gt;标签换成&lt;one-to-many class=&quot;Order&quot;/&gt;标签来对应JaveBean作为值，这就是一对多的映射
        &lt;list name table&gt;
            &lt;key column/&gt;
            &lt;list-index column=&quot;IDX&quot;/&gt;      # 索引列：表中的索引号列(对应在list中的索引)
            &lt;element column type/&gt;
        &lt;map name table&gt;
            &lt;key&gt;
            &lt;map-key type column&gt;                        # map对应key的列
            &lt;element column type&gt;
        dao中使用
                user.getTelSet().add(&quot;131&quot;);
</code></pre>
<h1 id="检索策略">
  检索策略
  <a class="anchor" href="#%e6%a3%80%e7%b4%a2%e7%ad%96%e7%95%a5">#</a>
</h1>
<pre><code>hibernate检索的两种类型
        立刻检索:session.get,query.list        &lt;class lazy=&quot;true&quot;&gt;标签中类的检索策略，get方法与list都不遵循
        延迟检索:session.load      # 初始时是代理对象,使用时查询  只有load方法遵循&lt;class lazy=&quot;true&quot;&gt;标签中类的检索策略
            检索方法是load时
                lazy属性出现在&lt;class&gt;与&lt;set&gt;标签中,两个标签中lazy属性的含义是不同的，两个lazy属性都是对load方法执行时是否查询数据库进行设置。
                        # &lt;class&gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中除了set集合之外的所有属性
                        ## &lt;set&gt;标签中lazy的含义是执行load方法时是否懒于查询数据库中set集合的数据
                        ## &lt;class&gt;中默认lazy属性的值为true
                        ## &lt;set&gt;中默认lazy属性的值为true
                true true 时    查类时没有查集合
                false true 时    查类时没有查集合
                false false 时    查类时查集合
                true false 时    查类时没有查集合
</code></pre>
<h1 id="经验">
  经验
  <a class="anchor" href="#%e7%bb%8f%e9%aa%8c">#</a>
</h1>
<pre><code>删除的两种方法 
        session.delete(session.get(Category.class,id));    # 先查询再删除，效率低
    session.createQuery(&quot;delete Categroy c where c.id=:id&quot;).setInteger(&quot;id&quot;,id).executeUpdate();
                    # 执行hql语句，效率高
                    
hibernate注解
        hibernate3.6支持注解
                javaee5不支持，默认关闭
                javaee6支持，默认开启，此时不加载注解配置文件会报错，所以要关掉
                        hibernate.cfg.xml中
                        &lt;property name=&quot;javax.persistence.validation.mode&quot;&gt;none&lt;/property&gt;
                        
DB Browser反射编译表的生成映射文件和类的时候，会生成项目目录下hibernate.reveng.xml的临时配置文件，可以删掉

映射文件class属性
        dynamic-update=&quot;true&quot;                # 动态更新，只有对相同的session有效，而且性能不好
                                                                ## 用字段设置中的update=&quot;false&quot;（对象中有字段值时更新，没有时不更新）属性来设置动态更新
映射文件set标签属性
        Order-by=&quot;id&quot;                                # set中级联对象按照&quot;id&quot;属性进行排序
</code></pre>
<h1 id="c3p0">
  c3p0
  <a class="anchor" href="#c3p0">#</a>
</h1>
<pre><code>c3p0并不是hibernate默认的连接池（默认的是hibernate自带的连接池算法）
        配置c3p0以后自动关闭Hibernate自带的连接池，而使用c3p0连接池


hibernate.cfg.xml文件中
        &lt;!-- 最大连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;20&lt;/property&gt; 
        &lt;!-- 最小连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;5&lt;/property&gt; 
        &lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;120&lt;/property&gt; 
        &lt;!-- 最大的PreparedStatement的数量 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;100&lt;/property&gt; 
        &lt;!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒--&gt; 
        &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;120&lt;/property&gt; 
        &lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;2&lt;/property&gt; 
        &lt;!-- 每次都验证连接是否可用 --&gt; 
        &lt;property name=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/property&gt; 
hibernate.properties文件中
        hibernate.c3p0.min_size=5 
        hibernate.c3p0.max_size=20 
        hibernate.c3p0.timeout=1800 
        hibernate.c3p0.max_statements=50 
</code></pre>
<h1 id="映射">
  映射
  <a class="anchor" href="#%e6%98%a0%e5%b0%84">#</a>
</h1>
<pre><code>hbm.xml
    位置与名称：
            domain.xx.java 文件同级目录 xx.hbm.xml

    约束文件位置
            hibernate3.jar/org/hibernate/hibernate-mapping-3.0.dtd
            从其中复制约束头
            
    源码中的案例文件
            \project\tutorials\中搜索 hbm.xml

    类-表映射的特点
            1.映射JavaBean到表字段（动态占位符），可以使用面向对象的hql语名生成sql语句
            2.session中保存类对象，缓存查询过的表的内容
            3.在映射关系的xml文件中可以设置主键的改变方式（这样以后dao类中设置的主键内容被配置文件中的设置覆盖）
            
    主键
            表中的主键
                    自然主键：有业务逻辑含义的字段（如name）（多个自然主键：联合主键）
                    代理主键
            hibernate中id的增加类型
                    increment  整型,不依赖数据库自增,多线程不安全
                uuid        缺点：占空间
                identity    整型，依赖数据库自增,线程安全
                sequence    专用于oracle数据库,要用特定名字的序列，create sequence hibernate_sequence;线程安全
                native(重点)    根据情况判断是identity或sequence
                assigned    自然主键：&lt;id name=&quot;name&quot; column=&quot;name&quot;&gt;,线程不安全
                composite-id    多个自然主键,表的javaBean必须实现序列化(1.对象序列化到硬盘、数据库【其它JavaBean有id属性，hibernate自动实现序列化】2.线程间传递数据)
                    &lt;composite-id&gt;&lt;key-property name=&quot;firstname&quot; column=&quot;firstname&quot;/&gt;&lt;key-property name=&quot;firstname&quot; column=&quot;lastname&quot;/&gt;

    持久化对象的两种类型
            实体型：具有id属性的类，映射成一条含有id主键的完整记录
            值类型或组件：与上面相反(被实体型包含)，如
                            # 包含以后会把组件的属性添加到实体类属性的后面，一起当作一张表，仅此而已
            # Address   
                province
                city
                area
            映射组件型属性
            1.类中引用组件：private Address address
            2.映射 &lt;component name=&quot;address&quot; class=&quot;Address&quot;&gt;&lt;property name column/&gt;
            3.dao中    star.setAdrress(address);
    内容
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE hibernate-mapping PUBLIC 
        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
        &quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;        
    &lt;hibernate-mapping package=&quot;hibernate.domain&quot;&gt;
            &lt;class name=&quot;Hero&quot; table=&quot;heros&quot; dynamic-insert=&quot;true&quot;&gt;
                                    # 设置动态插入为true:如果是null的值，不再插入
                                    ## 如果不设定动态插入，会插入数据库null值，数据库中设定的默认值不会起作用
                    &lt;!-- hibernate通过自己内部的类型type=&quot;&quot;,来转换java类型与sql类型之间的转换，一般不必写，自动反射 --&gt;
                    &lt;!-- id 是指主键，property是属性 --&gt;
                    &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;
                            &lt;!-- hibernate内部的主键生成器 --&gt;
                            &lt;generator class=&quot;increment&quot;/&gt;
                    &lt;/id&gt;
                    &lt;property name=&quot;name&quot; column=&quot;name&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;gender&quot; column=&quot;gender&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/property&gt;
                    &lt;property name=&quot;des&quot; column=&quot;des&quot;&gt;&lt;/property&gt;
            &lt;/class&gt;
    &lt;/hibernate-mapping&gt;
javaBean
    实现序列化接口
            在有名为id属性的JavaBean中，hibernate会自动实现序列化接口
            没有名为id属性的JavaBean中，需要我们自己实现序列化接口

    public class Hero implements java.io.Serializable{
                private Integer id;
                private String name;
                private String gender;
                private Integer age;
                private Date birthday;
                private String des;
    }
</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/commit/e291a00972b570fc85fd45722f3a423fe96dd780" title='Last modified by outrunJ | Sep 22, 2021' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="" />
      <span>Sep 22, 2021</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/tree/master/content/content/docs/middleware/library/hibernate.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a></li>
    <li><a href="#优化">优化</a></li>
    <li><a href="#基本概念">基本概念</a></li>
    <li><a href="#使用">使用</a></li>
    <li><a href="#session">session</a></li>
    <li><a href="#hibernatecfgxml">hibernate.cfg.xml</a></li>
    <li><a href="#hibernateproperties">hibernate.properties</a></li>
    <li><a href="#hibernateutil">HibernateUtil</a></li>
    <li><a href="#hql">hql</a></li>
    <li><a href="#案例">案例</a></li>
    <li><a href="#查询">查询</a></li>
    <li><a href="#多表映射">多表映射</a></li>
    <li><a href="#缓存">缓存</a></li>
    <li><a href="#集合映射">集合映射</a></li>
    <li><a href="#检索策略">检索策略</a></li>
    <li><a href="#经验">经验</a></li>
    <li><a href="#c3p0">c3p0</a></li>
    <li><a href="#映射">映射</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












