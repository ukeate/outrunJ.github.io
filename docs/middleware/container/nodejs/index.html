<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  基础
  #

特点
    commonJS规范
    javascript书写(v8引擎)
        js设计之初就可以运行在后端
        v8
            成熟的事件驱动模式
            没有i/o库, 没有历史包袱
            v8性能好
    单线程
        不用在意多线程状态同步(没有死锁, 没有上下文切换)
        无法利用多核, 错误时应用退出，计算密集时无法调度   # child_process解决
    事件驱动(event-driven), 回调
        event loop
            [while(true)] -&gt; watcher -&gt; handles
            watcher产生事件后, event loop取到并执行其handle(回调函数)
            event loop每一周询问多个watcher是否有事件
            event loop中没有watcher时进程退出
        http模块就是启动了一个watcher,所以执行后进程不结束
            其它watcher有 timer, fs, udp/req, process
        不同操作系统中event driven的实现:
            windows: IOCP
            Linux: epoll
            Mac:kqueue
    非阻塞io(non-blocking i/o model)
        io与数据处理分离（所以必须异步）
        线程池结合event-driven实现
    异步io
        go语言有协程(coroutine)而node.js没有，协程可以同步式编程
            # 有第三方协程模块
        promise(commonJs的规范, 其实现有whenJs, Q)
            # 书写难度降低
        eventProxy      # 朴灵
        async/step
commonJS
    模块
        var math = require(&#39;math&#39;)  # 缓存优先，核心模块优先。依次找.js, .node, .json
        exports.add = function(){}
    二进制
    Buffer
    字符集编码
    I/O流
    进程环境
    文件
    套接字
    单元测试
    web网关
    包管理
        package.json
        bin
        lib
        doc
        test
实现技术
    libev的windows与linux接口实现
    c&#43;&#43;扩展
事件循环    # 生产者消费者模型
    执行一次称为Tick
    询问观察者(文件、网络等)是否有待处理事件, 有关联回调执行回调
        # 观察者先idle, 再io, 再check
        通过请求对象实现，绑定回调、运行参数、执行标志
层次
    javascript
    v8
    node
    libuv
    *nix/ windows                # 分别编译
应用
    I/O密集服务
    cpu密集用c/c&#43;&#43;扩展，用子进程


  工具
  #

node --v8-options | grep harmony
    # 查看支持的es6特性
npm
    介绍
        cnpm是一个alibaba开发维护的，提供私有npm注册服务
    -v      # 版本
    install     # 安装，会执行package.json中scripts的勾子命令
        -g
    uninstall
    config
        list    # 查看项目的默认设置。registry属性指向npm官方资源位置
        set registry http://192.168.1.20:7001
            # 设置源
    test        # package.json中scripts的test

    o-&gt; 搭建cnpm服务器
        git clone https://github.com/cnpm/cnpmjs.org.git
        cd cnpmjs.org
        npm install npm -g
            # 升级npm的版本
        npm install
        创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码
        config/index.js中注释bindingHost来对外网开放
        node --harmony_generators dispatch.js
            # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问
    o-&gt; 使用私有库
        npm install ape-algorithm --registry=http://192.168.1.20:7001
            # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份

    设置
         ~/.npmrc
            registry=http://192.168.1.20:7001
                # 淘宝翻墙库 https://registry.npm.taobao.org/
n
node-gyp    # 编译c/c&#43;&#43;模块
nvm
cnpm
    介绍
        cnpm是一个alibaba开发维护的，提供私有npm注册服务
    安装
        npm install cnpm
            # 可以像使用npm一样使用
        cnpm sync gulp
            # npm 中发布的包在cnpm中有延时，可以用这个命令来手动同步
    搭建cnpm服务器
        git clone https://github.com/cnpm/cnpmjs.org.git
        cd cnpmjs.org
        npm install npm -g
            # 升级npm的版本
        npm install
        创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码
        config/index.js中注释bindingHost来对外网开放
        node --harmony_generators dispatch.js
            # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问
    使用私有库
        npm install ape-algorithm --registry=http://192.168.1.20:7001
            # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份
    项目设置私有库
        npm config list
            # 查看项目的默认设置。registry属性指向npm官方资源位置
        npm config set registry http://192.168.1.20:7001
    用户设置私有库
        // ~/.npmrc
        registry=http://192.168.1.20:7001
            # 另外，淘宝翻墙库 https://registry.npm.taobao.org/
调试
    o-&gt; 代码中插入断点
        debugger;
    o-&gt; 以debug模式运行
        # debug模式运行时, help查看可用命令
        node debug app.js


  配置
  #

package.json
    name                # 包名
    description         # 简介
    version             # 版本
    keywords            # 搜索关键词
    maintainers         # 维护者
    contributors        # 代码贡献者
    bugs                # 反馈bug的地址
    licenses            # 许可证
    repositories        # 托管代码地址
    dependencies        # 依赖包
    homepage            # 该包网站
    os                  # 操作系统支持列表
    cpu                 # cpu架构支持列表
    engine              # 支持的js引擎, 如ejs
    builtin             # 内建在底层系统的哪些组件上
    directories         # 目录说明
    implements          # 实现了commonJS哪些规范
    scripts             # 脚本命令
        preinstall
        install
        uninstall
        test
    author              # 包作者
    bin                 # 全局安装时，命令安装的位置
    main                # require()包时入口，默认找index
    devDependencies     # 开发时需要的依赖

    o-&gt;
    {
        &quot;name&quot;: &quot;test&quot;,
        &quot;version&quot;: &quot;0.1.0&quot;,
        &quot;keywords&quot;: [&quot;a&quot;, &quot;b&quot;],                     # npm search时用
        &quot;description&quot;: &quot;A testing package&quot;,
        &quot;os&quot;: [&quot;linux&quot;, &quot;darwin&quot;],
        &quot;author&quot;: &quot;outrun&lt;outrun@mail.com&gt;&quot;,
        &quot;dependencies&quot;: {
            &quot;express&quot;: &quot;^1.0.0&quot;,
            &quot;redis&quot;: &quot;&gt;= 0.6.7&quot;
        },
        &quot;devDependencies&quot;: {
            &quot;grunt&quot;: &quot;^0.4.5&quot;
        },
        &quot;main&quot;: &quot;index&quot;,
        &quot;bin&quot;: {
            &quot;test&quot;: &quot;./bin/test.js&quot;
        },
        &quot;scripts&quot;: {
            &quot;start&quot;: &quot;node server.js&quot;,
            &quot;test&quot;: &quot;vows test/*.js&quot;,               # &quot;grunt test&quot; &quot;mocha test&quot; &quot;make test&quot; &quot;make test-all&quot;
            &quot;preinstall&quot;: &quot;./configure&quot;,
            &quot;install&quot;: &quot;make &amp;&amp; make install&quot;,
            &quot;uninstall&quot;: &quot;&quot;
        },
        &quot;engines&quot;: {
            &quot;node&quot;: &quot;5.0.0&quot;
        }
    }


  api
  #


  异步api
  #

I/O操作api
setTimeout() setInterval()
    定时器插入观察者的红黑树中, tick时迭代定时器，如果超时就形成事件
        # 如果前一个tick耗时大，定时会拖后
        # 比较浪费性能
process.nextTick()
    回调放入队列，下tick全部执行, 位于idle观察者
setImmediate()
    回调放入链表, 每tick执行一个，位于check观察者，晚于idle


  宿主对象
  #

global      #全局对象
    root    # 指向自己
    BLOBAL # 指向自己

    setTimeout()
    setInterval()
    clearTimeout()
    clearInterval()
process     #当前进程
    argv    # 获得命令行参数数组
        title       # node
        version     # v0.12.2
    事件
        process.on(&quot;uncaughtException&quot;,function(e){
            console.log(&quot;error:&quot;&#43;e);
        });
buffer
    特点
        node中buffer不属于v8, 使用c&#43;&#43;扩展编写。所以可以使用高于1.4g的内存
        一个元素一字节
        8kb之内为小对象，slab机制分配内存, 先申请后分配。大于8kb的创建SlowBuffer对象
        pool的实现方式
    字符编码类型
        # 默认编码UTF-8, 一个buffer只能有一个编码
        ascii
        utf-8
        utf-16le/ucs-2
        base64
        binary
        hex

    length

    write()
        # write(str, [offset], [length], [encoding])
    toString()
        # toString([encoding], [start], [end])
    isEncoding()
        # 指定编码是否支持转换
    copy()
        # 复制自身到另一个buffer的某位置
        buf.copy(buffer, 0)
    concat()  #静态方法
        concat(chunks, size)
            # chunks中为buffer数组, size为总大小
    使用
        new Buffer(100)
        new Buffer(&#39;a&#39;, &#39;UTF-8&#39;)
console     #控制台
    log(&#39;&#39;,obj)
        console.log(&#39;[%s] listening on http://127.0.0.1:%d&#39;, app.setting.env, port)
module
    Module.exports真正的接口，导出的是一个类型
    exports是Module.exports的包装，导出的是Object类型的对象
promise     # 0.11.x后加入的全局对象
    使用
        # 复制
        var jadeTemplate = new Promise(function(resolve, reject) {
        fs.readFile(path.join(__dirname, &#39;views/article.jade&#39;), function(err, data) {
            if (err) {
            reject(err.message);
            } else {
            resolve(data.toString());
            }
        });
        });

        var localData = new Promise(function(resolve, reject) {
        fs.readFile(path.join(__dirname, &#39;static/shuffle.json&#39;), function(err, data) {
            if (err) {
            reject(err.message);
            } else {
            resolve(JSON.parse(data.toString()));
            }
        });
        });

        Promise
        .all([jadeTemplate, localData])
        .then(function(value) {
            console.log(jade.compile(value[0])(value[1]));
        });


  内置lib
  #


  http
  #

介绍
    继承自net模块
    EventEmitter实例
事件
    服务端
        connection
        request
        close
        checkContinue
            # 发送较大数据时，先发送Expect: 100-continue请求头，此时触发
        connect
        upgrade
            # 要求升级连接协议时
        clientError
            # 客户端触发error事件时触发
    客户端
        response
        socket
            # 建立连接时触发
        connect
            # 响应200时触发
        upgrade
        continue

globalAgent     # 重用http长连接，实际是个连接池，默认有5个并发
    sockets
        # 连接数
    requests
        # 处于等待状态的请求数

createServer(onRequest).listen(8888, func);                # 创建服务器并启动
    request
        req.setEncoding(&quot;utf8&quot;)
        var postData = &quot;&quot;;
        req.addListener(&quot;data&quot;, function(postDataChunk){
            postData &#43;= postDataChunk;
        });
        req.addListener(&quot;end&quot;, function(){
            route(handle, pathname, res, postData);
        });                                # 拼接post请求数据
        req.rawBody
            # post来的原生数据
        req.destroy()
            # 放弃请求，停止招收

    response
        res.setHeader(&#39;WWW-Authenticate&#39;, &#39;Basic realm=\&quot;Tomcat Manager Application\&quot;&#39;)
        res.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
            # 调用setHeader多次，调用writeHead后才写入
        res.write(&quot;&quot;);
        res.write(file,?&quot;binary&quot;);?
        res.end();
request(options, fn)        # 发起客户端请求
    # options中有 host, hostname, port, localAddress(使用本地的哪个网卡), socketPath(本地套接字文件路径), method, path, headers, auth(被计算成请求头的Authorization部分), agent(并发连接数，默认5)


  https
  #

介绍
    nodejs
    申请ca证书
    访问端口为443
使用
    express -e nodejs-https
    cd nodejs-https &amp;&amp; npm install
    git --version
    openssl version -a
    openssl genrsa -out privatekey.pem 1024
        # 生成证书文件
    openssl req -new -key privatekey.pem -out certrequest.csr
        # 通过私钥生成CSR证书签名
    openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem
        # 通过私钥和证书签名生成证书文件
        ## 这时生成了三个文件: certificate.pem, certrequest.csr, privatekey.pem
        ### 分别是: 证书文件, CSR证书签名, 私钥
        ## 由于证书是自己创建的，没有经过第三方机构验证，用户访问时会出现警告提示
    服务器
        var https = require(&#39;https&#39;)
            , fs = require(&#39;fs&#39;);
        var options = {
            key: fs.readFileSync(&#39;./privatekey.pem&#39;),
            cert: fs.readFileSync(&#39;./certificate.pem&#39;)
        };
        https.createServer(options, app).listen(3011, function(){
            console.log(&#39;Https server listening on port: &#39; &#43; 3011);
        });
    客户端
        var options = {
            hostname: &#39;localhost&#39;,
            port: 8000,
            path: &#39;/&#39;,
            method: &#39;GET&#39;,
            key: fs.readFileSync(&#39;./keys/client.key&#39;),
            cert: fs.readFileSync(&#39;./keys/client.crt&#39;),
            ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]
                # 设置rejectUnauthorized: false 来忽略ca验证
        }
        options.agent = new https.Agent(options)

        var req = https.request(options, function (res) {
            res.setEncoding(&#39;utf-8&#39;)
            res.on(&#39;data&#39;, function (d) {
                console.log(d)
            })
        })
        req.end()

        req.on(&#39;error&#39;, function(e){
            console.log(e)
        })


  net
  #

介绍
    处理tcp请求
    socket是EventEmitter的Stream实例
注意
    默认开启Nagle, 会合并小数据成一个数据包延迟发送
        socket.setNoDelay(true)关闭Nagle
    并不是每次write都触发data事件, 关掉Nagle后，可能接收到多个小数据包后触发一次data

服务器事件
    listening
    connection
    close
    error
连接事件
    data
    end
    connect
    drain
        # 任意一端调用write时触发
    error
    close
    timeout

o-&gt; 基本服务
# telnet来测试
var net = require(&#39;net&#39;)

var server = net.createServer(function (socket) {
    socket.on(&#39;data&#39;, function (data) {
        socket.write(&#39;a&#39;)
    })

    socket.on(&#39;end&#39;, function () {
        console.log(&#39;disconnected.&#39;)
    })

    socket.write(&#39;welcome&#39;)
})

server.listen(8124, function () {
    console.log(&#39;server bound&#39;)
})

o-&gt; 基本服务2
var server = net.createServer()
server.on(&#39;connection&#39;, function (socket) {})
server.listen(8124)

o-&gt; 监听
server.listen(&#39;/tmp/echo.sock&#39;)
    # nc -U /tmp/echo.sock 来测试

o-&gt; 客户端
var client = net.connect({port: 8124}, function () {
    console.log(&#39;client connected&#39;)
    client.write(&#39;a&#39;)
})

client.on(&#39;data&#39;, function (data) {
    console.log(data.toString())
    client.end()
})

client.on(&#39;end&#39;, function() {
    console.log(&#39;disconnected.&#39;)
})

o-&gt; 客户端
var client = net.connect({path: &#39;/tmp/echo.sock&#39;})

o-&gt; 管道
var server = net.createServer(function (socket) {
    socket.write(&#39;a&#39;)
    socket.pipe(socket)
})


  dgram
  #

介绍
    处理udp
    socket是EventEmitter实例

o-&gt; 服务
var dgram = require(&#39;dgram&#39;)

var server = dgram.createSocket(&#39;udp4&#39;)

server.on(&#39;message&#39;, function (msg, rinfo) {
    console.log(msg &#43; &#39;from&#39; &#43; rinfo.address &#43; &#39;:&#39; &#43;)
})

server.on(&#39;listening&#39;, function () {
    var address = server.address()
    console.log(&#39;listening &#39; &#43; address.address &#43; &#39;:&#39; &#43; address.port)
})

server.bind(41234)

o-&gt; 客户端
var message = new Buffer(&#39;a&#39;)
var client = dgram.createSocket(&#39;udp4&#39;)
client.send(message, 0, message.length, 41234, &#39;localhost&#39;, function (err, bytes) {
    client.close()
})


  events
  #

介绍
    几乎所有对象的父类
使用
    var events = require(&#39;events&#39;)
        , util = require(&#39;util&#39;);
    function Obj(){events.EventEmitter.cal(this);}
    util.inherits(Obj, events.EventEmitter);
        # Obj.prototype.__proto__ = events.EventEmitter.prototype;
    Obj.prototype.write = function (data) {this.emit(&#39;data&#39;, data);};

    var obj = new Obj();
    obj.on(&#39;data&#39;, function (data) {console.log(&#39;Received data&#39;, data);})
        # obj.once
    obj.write(&#39;hello&#39;);

setMaxListeners(0)
    # 侦听器过多不警告


  path
  #


  os
  #

方法
    totalmem
    freemem


  fs
  #

fs.readFile(&quot;tmp/test.png&quot;, &quot;binary&quot;, function(error, file){
});
fs.writeFile(&#39;target.png&#39;, &#39;binary&#39;, function(err){
})
fs.exists(filePath, function(exists){
        if(exists){}
})
fs.unlink(filePath, function(err){
})
fs.renameSync(files.upload.path,?&quot;/tmp/test.png&quot;);                # 写入文件(阻塞)

o-&gt; 流读写
var reader = fs.createReadStream(&#39;in.txt&#39;)
        # 第二个参数为设置, highWaterMark: 每次读取的size, encoding: 编码
var writer = fs.createWriteStream(&#39;out.txt&#39;)
reader.on(&#39;data&#39;, function (chunk) {
        writer.write(chunk)
})
reader.on(&#39;end&#39;, function() {
        writer.end()
})

var reader = fs.createReadStream(&#39;in.txt&#39;)
var writer = fs.createWriteStream(&#39;out.txt&#39;)
reader.pipe(writer)


  sys
  #


  process
  #

argv
    # 启动时参数
pid
    # 当前进程的pid

once()
    once(&#39;SIGINT&#39;, function () {})
        # ctrl &#43; c
memoryUsage()
    # 查看v8内存使用量
    # 其中rrs是resident set size, 是常驻内存的部分，其他在swap或文件系统中
kill()
    # process.kill(pid[, signal])
on()
    # 事件触发

o-&gt;
process.on(&#39;SIGTERM&#39;, function () {
    console.log(&#39;Got a SIGTERM, exiting...&#39;)
    process.exit(1)
})

o-&gt;
process.on(&#39;uncaughtException&#39;, function () {
    logger.error(err)
    process.send({act: &#39;suicide&#39;})
        # 向主进程发送信号
    worker.close(function () {
        process.exit(1)
    })

    setTimeout(function () {
        # 长连接断开需要时间较久, 超时自动退出
        process.exit(1)
    }, 5000)
})


  module
  #

exports
parent


  stream
  #

介绍
    继承EventEmitter, 处理文件之类的流


  tls
  #

介绍
    建立在tls/ssl上的加密tcp
    使用openssl来构建证书和测试

o-&gt; 服务器
var tls = require(&#39;tls&#39;)
var fs = require(&#39;fs&#39;)

var options = {
        key: fs.readFileSync(&#39;./keys/server.key&#39;),
        cert: fs.readFileSync(&#39;./keys/server.crt&#39;),
        requestCert: true,
        ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]
}

var server = tls.createServer(options, function (stream) {
        console.log(&#39;server connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;)
        stream.write(&#39;welcome!\n&#39;)
        stream.setEncoding(&#39;utf8&#39;)
        stream.pipe(stream)
})
server.listen(8000, function () {
        console.log(&#39;server bound&#39;)
})

o-&gt; 客户端
var options = {
        key: fs.readFileSync(&#39;./keys/client.key&#39;),
        cert: fs.readFileSync(&#39;./keys/client.crt&#39;),
        ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)]
}

var stream = tls.connect(8000, options, function () {
        console.log(&#39;client connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;)
                # 证书是否通过
        process.stdin.pipe(stream)
})

stream.setEncoding(&#39;utf8&#39;)
stream.on(&#39;data&#39;, function (data) {
        console.log(data)
})
stream.on(&#39;end&#39;, function () {
        server.close()
})


  child_process
  #

介绍
    可以创建新的node进程
spawn(command[, args][a options])
    # command执行的命令
    # args参数列表
    options 环境变量对象, 包括7个属性
        cwd 子进程当前工作目录
        env 环境变量键值对
        stdio 子进程stdio配置
        customFds 子进程stdio使用的文件标示符
        detached 进程组的主控制
        uid 用户进程id
        进程组id

    var du = child.spawn(&#39;du&#39;, [&#39;-sh&#39;, &#39;/disk1&#39;]);
    du.stdout.on(&#39;data&#39;, function(data){})
    du.stderr.on(&#39;data&#39;, function(data){})
    du.on(&#39;exit&#39;, function(code){})
exec(&#39;&#39;)
    # 对spawn的友好封装, 增加了shell命令解析
    child.exec(&#39;cat *.js | ws&#39;, function(error, stdout, stderr){})
execFile(command[, args])
    # 执行可执行文件，不解析args,防止了exec参数注入的风险
    child.execFile(&#39;/bin/ls&#39;, [&#39;-l&#39;, &#39;.&#39;], function(err, result){})
fork()
    # 同spawn, 但建立ipc(进程通信, inter-process communication)
    var n = child.fork(&#39;./son.js&#39;);
    n.on(&#39;message&#39;, function(){
        console.log(&#39;Main listen: &#39;, m);
    });
    n.send({hello: &#39;i am parent&#39;});
    // son.js
    process.on(&#39;message&#39;, function(m){
        console.log(&#39;Son listen: &#39;, m);
    });
    process.send({hello: &#39;i am child&#39;});
子进程对象
    send()
        # 发送消息和句柄，句柄可以是
        ## net.Socket, net.Server, net.Native(c&#43;&#43;层面的tcp套接字或IPC管道), dgram.Socket, dgram.Native
    kill()
        # 向子进程发送SIGTERM信号
    事件
        message
        error
        exit
        close
        disconnect

o-&gt; cpu核数worker
    o-&gt; master.js
    var fork = require(&#39;child_process&#39;).fork
    var cpus = require(&#39;os&#39;).cpus()
    for (var i = 0; i &lt; cpus.length; i&#43;&#43;){
        fork(&#39;./worker.js&#39;)
    }

    o-&gt; worker.js
    var http = require(&#39;http&#39;)
    http.createServer(function(req, res){...}).listen(Math.round((1&#43;Math.random()) * 1000), &#39;127.0.0.1&#39;)

o-&gt; spawn
var spawn = require(&#39;child_process&#39;).spawn
free = spawn(&#39;free&#39;, [&#39;-m&#39;])
free.stdout.on(&#39;data&#39;, function (data) {})
free.stderr.on(&#39;data&#39;, function (data) {})
free.on(&#39;exit&#39;, function (code, signal) {})

o-&gt; fork
    # 需要至少30ms, 10M启动一个v8实例
var fork = require(&#39;child_process&#39;).fork
var cpus = require(&#39;os&#39;).cpus()
for (var i = 0; i &lt; cpus.length; i&#43;&#43;) {
        fork(&#39;./worker.js&#39;)
}

o-&gt; 通信
    # 只有子进程是node进程时才可以通信
var cp = require(&#39;child_process&#39;)
var n = cp.fork(__dirname &#43; &#39;/sub.js&#39;)

n.on(&#39;message&#39;, function (m) {
    console.log(&#39;PARENT got message: &#39;, m)
})
n.send({a: 1})

process.on(&#39;message&#39;, function (m) {
    console.log(&#39;CHILD got message:&#39;, m)
})
process.send({b: 2})

o-&gt; 句柄通信
    # 节省了代理建立socket浪费的文件描述符
var child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;)
var server = require(&#39;net&#39;).createServer()
server.on(&#39;connection&#39;, function (socket) {
    socket.end(&#39;handled by parent \n&#39;)
})
server.listen(1337, function () {
    child.send(&#39;server&#39;, server)
})
// child.js
process.on(&#39;message&#39;, function (m, server) {
    if (m === &#39;server&#39;) {
        server.on(&#39;connection&#39;, function (socket) {
            socket.end(&#39;handled by child \n&#39;)
        })
    }
})

o-&gt; 句柄负载http
    # 对描述符是抢占式的
var cp = require(&#39;child_process&#39;)
var child1 = cp.fork(&#39;child.js&#39;)
var child2 = cp.fork(&#39;child.js&#39;)

var server = require(&#39;net&#39;).createServer()
server.listen(1337, function () {
    child1.send(&#39;server&#39;, server)
    child2.send(&#39;server&#39;, server)
    server.close()
})
// child.js
var http = require(&#39;http&#39;)
var server = http.createServer(function (req, res) {
    res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;})
    res.end(&#39;handled by child, pid is &#39; &#43; process.pid &#43; &#39;\n&#39;)
})
process.on(&#39;message&#39;, function (m, tcp) {
    if (m === &#39;server&#39;) {
        tcp.on(&#39;connection&#39;, function (socket) {
            server.emit(&#39;connection&#39;, socket)
        })
    }
})


  cluster
  #

介绍
    child_process和net模块的组合
        cluster启动时，内部启动tcp服务器
        fork()时，将tcp服务器socket文件描述符发给worker, 实现共享端口
isWorker
    判断process.env是否值为NODE_UNIQUE_ID
isMaster
    判断cluster.isWorker
事件
    fork            # fork时
    online          # 工作进程创建好后
    listening       # 工作进程调listen()后
    disconnect      # 主进程和工作进程IPC通道断开后
    exit            # 所有工作进程退出后
    setup           # cluster.setupMaster()执行后

o-&gt; cpu核数worker
var cluster = require(&#39;cluster&#39;)
cluster.setupMaster({
    exec: &quot;worker.js&quot;
})

var cpus = require(&#39;os&#39;).cpus()
for (var i = 0; i &lt; cpus.length; i&#43;&#43;) {
    cluster.fork()
}


  domain
  #

介绍
    用于异步异常捕获
    绑定方式
        隐式绑定: 把domain上下文中定义的变量，自动绑定到domain对象
        显式绑定: 把不是domain上下文中定义的变量，以代码的方式绑定到domain对象
members     # 已加入domain对象的域定时器和事件发射器的数组

create()                # 返回一个domain对象
run(fn)                 # 在domain上下文中执行一个函数，并隐式绑定所有事件、定时器和低级请求
add(emitter)            # 显式的增加事件
remove(emitter)         # 删除事件
bind(callback)          # 以return为封闭callback函数　
intercept(callback)     # 同bind, 但返回第一个参数
enter()                 # 进入一个异步调用的上下文，绑定到domain
exit()                  # 退出当前的domain, 切换到不同的链的异步调用的上下文中，对应domain.enter()
dispose()               # 释放一个domain对象，让node进程回收这部分资源
使用
    var domain = require(&#39;domain&#39;);
    function async_error(){
        setTimeout(function(){
            var r = Math.random() * 10;
            console.log(&#39;random num is &#39; &#43; r);
            if(r &gt; 5)
                throw new Error(&#39;Error: random num &#39; &#43; r &#43; &#39; &gt; 5&#39;);
        }, 10);
    }
    var d = domain.create();
    d.on(&#39;error&#39;, function(err){
        console.log(err);
    });
    setInterval(function(){
        d.run(async_err);
    }, 1000);
未绑定不捕获
    代码
        var domain = require(&#39;domain&#39;);
        var EventEmitter = require(&#39;events&#39;).EventEmitter;

        var e = new EventEmitter();

        var timer = setTimeout(function(){
            e.emit(&#39;data&#39;);
        }, 10);

        function next(){
            e.once(&#39;data&#39;, function(){
                throw new Error(&#39;Receive data error!&#39;);
            });
        }

        var d = domain.create();
        d.on(&#39;error&#39;, function(err){
            console.log(err);
        });
        d.run(next);
    原因
        timer和e两个关键对象在初始化时都没有在domain范围内。当next函数中抛出异常时, 没有处于domain的包裹中

    修改
        ...
        d.add(e);
        d.add(timer);
        d.run(next);


  外部lib
  #


  url
  #

parse()
    pathname

    url.parse(req.url)
    url.parse(req.url, true) 会parse出query对象


  querystring
  #

parse()
    querystring.parse(url.parse(req.url).query)


  crypto
  #

介绍
    加密并生成各种散列
    利用openssl库来实现，提供openssl中一系列哈希方法，包括hmac, cipher, decipher, 签名和验证等方法的封装
使用
    var crypto = require(&#39;crypto&#39;);
    console.log(crypto.getHashes());                                    # 打印支持的所有hasp算法


  node-gyp
  #

编译C&#43;&#43;模块的编译工具


  util
  #

使用
    var util = require(&#39;util&#39;);
方法
    inherits(Sub, Base)                # 对象间原型继承，Sub 仅继承Base原型中定义 的函数
    inspect(obj)                # 任意对象转换为字符串
    log(string)                        # 带时间戳的log
    format(&#39;%s:%s&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)                // &#39;a:b c&#39;
        # format(&#39;%s:%s&#39;, &#39;a&#39;)                // &#39;a:%s&#39;
        # format(1, 2, 3)                        // &#39;1 2 3&#39;
    is系列
        isArray(obj)
        isRegExp(obj)
        isDate(obj)
        isError(obj)
        isBoolean(obj)
        isNull(obj)
        isNullOrUndefined(obj)
        isNumber(obj)
        isString(obj)
        isSymbol(obj)
        isUndefined(obj)
        isObject(obj)
        isFunction(obj)
        isPrimitive(obj)
            # 是否基本类型
        isBuffer(obj)
        deprecate(foo, &#39;foo() is deprecated, use bar() instead&#39;);
            # 标记为过时, 调用foo()时显示后面的话


  zlib
  #

介绍
    提供压缩方法，如gzip


  全局属性
  #

介绍
    并非挂在global下的属性，但可以直接使用

__dirname
    # 在任何模块内获取当前模块文件的绝对路径
__filename
    # 当前在执行的js文件路径


  方案
  #

异常捕获
    process.on(&quot;uncaughtException&quot;,function(e){
        logger.error(&quot;error:&quot;&#43;e);
    });
    process.on(&#39;unhandledRejection&#39;, function (err, p) {
        console.error(err.stack)
    });
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://ukeate.com/docs/middleware/container/nodejs/">
  <meta property="og:site_name" content="ukeate的笔记">
  <meta property="og:title" content="Nodejs">
  <meta property="og:description" content="基础 # 特点 commonJS规范 javascript书写(v8引擎) js设计之初就可以运行在后端 v8 成熟的事件驱动模式 没有i/o库, 没有历史包袱 v8性能好 单线程 不用在意多线程状态同步(没有死锁, 没有上下文切换) 无法利用多核, 错误时应用退出，计算密集时无法调度 # child_process解决 事件驱动(event-driven), 回调 event loop [while(true)] -&gt; watcher -&gt; handles watcher产生事件后, event loop取到并执行其handle(回调函数) event loop每一周询问多个watcher是否有事件 event loop中没有watcher时进程退出 http模块就是启动了一个watcher,所以执行后进程不结束 其它watcher有 timer, fs, udp/req, process 不同操作系统中event driven的实现: windows: IOCP Linux: epoll Mac:kqueue 非阻塞io(non-blocking i/o model) io与数据处理分离（所以必须异步） 线程池结合event-driven实现 异步io go语言有协程(coroutine)而node.js没有，协程可以同步式编程 # 有第三方协程模块 promise(commonJs的规范, 其实现有whenJs, Q) # 书写难度降低 eventProxy # 朴灵 async/step commonJS 模块 var math = require(&#39;math&#39;) # 缓存优先，核心模块优先。依次找.js, .node, .json exports.add = function(){} 二进制 Buffer 字符集编码 I/O流 进程环境 文件 套接字 单元测试 web网关 包管理 package.json bin lib doc test 实现技术 libev的windows与linux接口实现 c&#43;&#43;扩展 事件循环 # 生产者消费者模型 执行一次称为Tick 询问观察者(文件、网络等)是否有待处理事件, 有关联回调执行回调 # 观察者先idle, 再io, 再check 通过请求对象实现，绑定回调、运行参数、执行标志 层次 javascript v8 node libuv *nix/ windows # 分别编译 应用 I/O密集服务 cpu密集用c/c&#43;&#43;扩展，用子进程 工具 # node --v8-options | grep harmony # 查看支持的es6特性 npm 介绍 cnpm是一个alibaba开发维护的，提供私有npm注册服务 -v # 版本 install # 安装，会执行package.json中scripts的勾子命令 -g uninstall config list # 查看项目的默认设置。registry属性指向npm官方资源位置 set registry http://192.168.1.20:7001 # 设置源 test # package.json中scripts的test o-&gt; 搭建cnpm服务器 git clone https://github.com/cnpm/cnpmjs.org.git cd cnpmjs.org npm install npm -g # 升级npm的版本 npm install 创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码 config/index.js中注释bindingHost来对外网开放 node --harmony_generators dispatch.js # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问 o-&gt; 使用私有库 npm install ape-algorithm --registry=http://192.168.1.20:7001 # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份 设置 ~/.npmrc registry=http://192.168.1.20:7001 # 淘宝翻墙库 https://registry.npm.taobao.org/ n node-gyp # 编译c/c&#43;&#43;模块 nvm cnpm 介绍 cnpm是一个alibaba开发维护的，提供私有npm注册服务 安装 npm install cnpm # 可以像使用npm一样使用 cnpm sync gulp # npm 中发布的包在cnpm中有延时，可以用这个命令来手动同步 搭建cnpm服务器 git clone https://github.com/cnpm/cnpmjs.org.git cd cnpmjs.org npm install npm -g # 升级npm的版本 npm install 创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码 config/index.js中注释bindingHost来对外网开放 node --harmony_generators dispatch.js # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问 使用私有库 npm install ape-algorithm --registry=http://192.168.1.20:7001 # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份 项目设置私有库 npm config list # 查看项目的默认设置。registry属性指向npm官方资源位置 npm config set registry http://192.168.1.20:7001 用户设置私有库 // ~/.npmrc registry=http://192.168.1.20:7001 # 另外，淘宝翻墙库 https://registry.npm.taobao.org/ 调试 o-&gt; 代码中插入断点 debugger; o-&gt; 以debug模式运行 # debug模式运行时, help查看可用命令 node debug app.js 配置 # package.json name # 包名 description # 简介 version # 版本 keywords # 搜索关键词 maintainers # 维护者 contributors # 代码贡献者 bugs # 反馈bug的地址 licenses # 许可证 repositories # 托管代码地址 dependencies # 依赖包 homepage # 该包网站 os # 操作系统支持列表 cpu # cpu架构支持列表 engine # 支持的js引擎, 如ejs builtin # 内建在底层系统的哪些组件上 directories # 目录说明 implements # 实现了commonJS哪些规范 scripts # 脚本命令 preinstall install uninstall test author # 包作者 bin # 全局安装时，命令安装的位置 main # require()包时入口，默认找index devDependencies # 开发时需要的依赖 o-&gt; { &#34;name&#34;: &#34;test&#34;, &#34;version&#34;: &#34;0.1.0&#34;, &#34;keywords&#34;: [&#34;a&#34;, &#34;b&#34;], # npm search时用 &#34;description&#34;: &#34;A testing package&#34;, &#34;os&#34;: [&#34;linux&#34;, &#34;darwin&#34;], &#34;author&#34;: &#34;outrun&lt;outrun@mail.com&gt;&#34;, &#34;dependencies&#34;: { &#34;express&#34;: &#34;^1.0.0&#34;, &#34;redis&#34;: &#34;&gt;= 0.6.7&#34; }, &#34;devDependencies&#34;: { &#34;grunt&#34;: &#34;^0.4.5&#34; }, &#34;main&#34;: &#34;index&#34;, &#34;bin&#34;: { &#34;test&#34;: &#34;./bin/test.js&#34; }, &#34;scripts&#34;: { &#34;start&#34;: &#34;node server.js&#34;, &#34;test&#34;: &#34;vows test/*.js&#34;, # &#34;grunt test&#34; &#34;mocha test&#34; &#34;make test&#34; &#34;make test-all&#34; &#34;preinstall&#34;: &#34;./configure&#34;, &#34;install&#34;: &#34;make &amp;&amp; make install&#34;, &#34;uninstall&#34;: &#34;&#34; }, &#34;engines&#34;: { &#34;node&#34;: &#34;5.0.0&#34; } } api # 异步api # I/O操作api setTimeout() setInterval() 定时器插入观察者的红黑树中, tick时迭代定时器，如果超时就形成事件 # 如果前一个tick耗时大，定时会拖后 # 比较浪费性能 process.nextTick() 回调放入队列，下tick全部执行, 位于idle观察者 setImmediate() 回调放入链表, 每tick执行一个，位于check观察者，晚于idle 宿主对象 # global #全局对象 root # 指向自己 BLOBAL # 指向自己 setTimeout() setInterval() clearTimeout() clearInterval() process #当前进程 argv # 获得命令行参数数组 title # node version # v0.12.2 事件 process.on(&#34;uncaughtException&#34;,function(e){ console.log(&#34;error:&#34;&#43;e); }); buffer 特点 node中buffer不属于v8, 使用c&#43;&#43;扩展编写。所以可以使用高于1.4g的内存 一个元素一字节 8kb之内为小对象，slab机制分配内存, 先申请后分配。大于8kb的创建SlowBuffer对象 pool的实现方式 字符编码类型 # 默认编码UTF-8, 一个buffer只能有一个编码 ascii utf-8 utf-16le/ucs-2 base64 binary hex length write() # write(str, [offset], [length], [encoding]) toString() # toString([encoding], [start], [end]) isEncoding() # 指定编码是否支持转换 copy() # 复制自身到另一个buffer的某位置 buf.copy(buffer, 0) concat() #静态方法 concat(chunks, size) # chunks中为buffer数组, size为总大小 使用 new Buffer(100) new Buffer(&#39;a&#39;, &#39;UTF-8&#39;) console #控制台 log(&#39;&#39;,obj) console.log(&#39;[%s] listening on http://127.0.0.1:%d&#39;, app.setting.env, port) module Module.exports真正的接口，导出的是一个类型 exports是Module.exports的包装，导出的是Object类型的对象 promise # 0.11.x后加入的全局对象 使用 # 复制 var jadeTemplate = new Promise(function(resolve, reject) { fs.readFile(path.join(__dirname, &#39;views/article.jade&#39;), function(err, data) { if (err) { reject(err.message); } else { resolve(data.toString()); } }); }); var localData = new Promise(function(resolve, reject) { fs.readFile(path.join(__dirname, &#39;static/shuffle.json&#39;), function(err, data) { if (err) { reject(err.message); } else { resolve(JSON.parse(data.toString())); } }); }); Promise .all([jadeTemplate, localData]) .then(function(value) { console.log(jade.compile(value[0])(value[1])); }); 内置lib # http # 介绍 继承自net模块 EventEmitter实例 事件 服务端 connection request close checkContinue # 发送较大数据时，先发送Expect: 100-continue请求头，此时触发 connect upgrade # 要求升级连接协议时 clientError # 客户端触发error事件时触发 客户端 response socket # 建立连接时触发 connect # 响应200时触发 upgrade continue globalAgent # 重用http长连接，实际是个连接池，默认有5个并发 sockets # 连接数 requests # 处于等待状态的请求数 createServer(onRequest).listen(8888, func); # 创建服务器并启动 request req.setEncoding(&#34;utf8&#34;) var postData = &#34;&#34;; req.addListener(&#34;data&#34;, function(postDataChunk){ postData &#43;= postDataChunk; }); req.addListener(&#34;end&#34;, function(){ route(handle, pathname, res, postData); }); # 拼接post请求数据 req.rawBody # post来的原生数据 req.destroy() # 放弃请求，停止招收 response res.setHeader(&#39;WWW-Authenticate&#39;, &#39;Basic realm=\&#34;Tomcat Manager Application\&#34;&#39;) res.writeHead(200, {&#34;Content-Type&#34;: &#34;text/html&#34;}); # 调用setHeader多次，调用writeHead后才写入 res.write(&#34;&#34;); res.write(file,?&#34;binary&#34;);? res.end(); request(options, fn) # 发起客户端请求 # options中有 host, hostname, port, localAddress(使用本地的哪个网卡), socketPath(本地套接字文件路径), method, path, headers, auth(被计算成请求头的Authorization部分), agent(并发连接数，默认5) https # 介绍 nodejs 申请ca证书 访问端口为443 使用 express -e nodejs-https cd nodejs-https &amp;&amp; npm install git --version openssl version -a openssl genrsa -out privatekey.pem 1024 # 生成证书文件 openssl req -new -key privatekey.pem -out certrequest.csr # 通过私钥生成CSR证书签名 openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem # 通过私钥和证书签名生成证书文件 ## 这时生成了三个文件: certificate.pem, certrequest.csr, privatekey.pem ### 分别是: 证书文件, CSR证书签名, 私钥 ## 由于证书是自己创建的，没有经过第三方机构验证，用户访问时会出现警告提示 服务器 var https = require(&#39;https&#39;) , fs = require(&#39;fs&#39;); var options = { key: fs.readFileSync(&#39;./privatekey.pem&#39;), cert: fs.readFileSync(&#39;./certificate.pem&#39;) }; https.createServer(options, app).listen(3011, function(){ console.log(&#39;Https server listening on port: &#39; &#43; 3011); }); 客户端 var options = { hostname: &#39;localhost&#39;, port: 8000, path: &#39;/&#39;, method: &#39;GET&#39;, key: fs.readFileSync(&#39;./keys/client.key&#39;), cert: fs.readFileSync(&#39;./keys/client.crt&#39;), ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)] # 设置rejectUnauthorized: false 来忽略ca验证 } options.agent = new https.Agent(options) var req = https.request(options, function (res) { res.setEncoding(&#39;utf-8&#39;) res.on(&#39;data&#39;, function (d) { console.log(d) }) }) req.end() req.on(&#39;error&#39;, function(e){ console.log(e) }) net # 介绍 处理tcp请求 socket是EventEmitter的Stream实例 注意 默认开启Nagle, 会合并小数据成一个数据包延迟发送 socket.setNoDelay(true)关闭Nagle 并不是每次write都触发data事件, 关掉Nagle后，可能接收到多个小数据包后触发一次data 服务器事件 listening connection close error 连接事件 data end connect drain # 任意一端调用write时触发 error close timeout o-&gt; 基本服务 # telnet来测试 var net = require(&#39;net&#39;) var server = net.createServer(function (socket) { socket.on(&#39;data&#39;, function (data) { socket.write(&#39;a&#39;) }) socket.on(&#39;end&#39;, function () { console.log(&#39;disconnected.&#39;) }) socket.write(&#39;welcome&#39;) }) server.listen(8124, function () { console.log(&#39;server bound&#39;) }) o-&gt; 基本服务2 var server = net.createServer() server.on(&#39;connection&#39;, function (socket) {}) server.listen(8124) o-&gt; 监听 server.listen(&#39;/tmp/echo.sock&#39;) # nc -U /tmp/echo.sock 来测试 o-&gt; 客户端 var client = net.connect({port: 8124}, function () { console.log(&#39;client connected&#39;) client.write(&#39;a&#39;) }) client.on(&#39;data&#39;, function (data) { console.log(data.toString()) client.end() }) client.on(&#39;end&#39;, function() { console.log(&#39;disconnected.&#39;) }) o-&gt; 客户端 var client = net.connect({path: &#39;/tmp/echo.sock&#39;}) o-&gt; 管道 var server = net.createServer(function (socket) { socket.write(&#39;a&#39;) socket.pipe(socket) }) dgram # 介绍 处理udp socket是EventEmitter实例 o-&gt; 服务 var dgram = require(&#39;dgram&#39;) var server = dgram.createSocket(&#39;udp4&#39;) server.on(&#39;message&#39;, function (msg, rinfo) { console.log(msg &#43; &#39;from&#39; &#43; rinfo.address &#43; &#39;:&#39; &#43;) }) server.on(&#39;listening&#39;, function () { var address = server.address() console.log(&#39;listening &#39; &#43; address.address &#43; &#39;:&#39; &#43; address.port) }) server.bind(41234) o-&gt; 客户端 var message = new Buffer(&#39;a&#39;) var client = dgram.createSocket(&#39;udp4&#39;) client.send(message, 0, message.length, 41234, &#39;localhost&#39;, function (err, bytes) { client.close() }) events # 介绍 几乎所有对象的父类 使用 var events = require(&#39;events&#39;) , util = require(&#39;util&#39;); function Obj(){events.EventEmitter.cal(this);} util.inherits(Obj, events.EventEmitter); # Obj.prototype.__proto__ = events.EventEmitter.prototype; Obj.prototype.write = function (data) {this.emit(&#39;data&#39;, data);}; var obj = new Obj(); obj.on(&#39;data&#39;, function (data) {console.log(&#39;Received data&#39;, data);}) # obj.once obj.write(&#39;hello&#39;); setMaxListeners(0) # 侦听器过多不警告 path # os # 方法 totalmem freemem fs # fs.readFile(&#34;tmp/test.png&#34;, &#34;binary&#34;, function(error, file){ }); fs.writeFile(&#39;target.png&#39;, &#39;binary&#39;, function(err){ }) fs.exists(filePath, function(exists){ if(exists){} }) fs.unlink(filePath, function(err){ }) fs.renameSync(files.upload.path,?&#34;/tmp/test.png&#34;); # 写入文件(阻塞) o-&gt; 流读写 var reader = fs.createReadStream(&#39;in.txt&#39;) # 第二个参数为设置, highWaterMark: 每次读取的size, encoding: 编码 var writer = fs.createWriteStream(&#39;out.txt&#39;) reader.on(&#39;data&#39;, function (chunk) { writer.write(chunk) }) reader.on(&#39;end&#39;, function() { writer.end() }) var reader = fs.createReadStream(&#39;in.txt&#39;) var writer = fs.createWriteStream(&#39;out.txt&#39;) reader.pipe(writer) sys # process # argv # 启动时参数 pid # 当前进程的pid once() once(&#39;SIGINT&#39;, function () {}) # ctrl &#43; c memoryUsage() # 查看v8内存使用量 # 其中rrs是resident set size, 是常驻内存的部分，其他在swap或文件系统中 kill() # process.kill(pid[, signal]) on() # 事件触发 o-&gt; process.on(&#39;SIGTERM&#39;, function () { console.log(&#39;Got a SIGTERM, exiting...&#39;) process.exit(1) }) o-&gt; process.on(&#39;uncaughtException&#39;, function () { logger.error(err) process.send({act: &#39;suicide&#39;}) # 向主进程发送信号 worker.close(function () { process.exit(1) }) setTimeout(function () { # 长连接断开需要时间较久, 超时自动退出 process.exit(1) }, 5000) }) module # exports parent stream # 介绍 继承EventEmitter, 处理文件之类的流 tls # 介绍 建立在tls/ssl上的加密tcp 使用openssl来构建证书和测试 o-&gt; 服务器 var tls = require(&#39;tls&#39;) var fs = require(&#39;fs&#39;) var options = { key: fs.readFileSync(&#39;./keys/server.key&#39;), cert: fs.readFileSync(&#39;./keys/server.crt&#39;), requestCert: true, ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)] } var server = tls.createServer(options, function (stream) { console.log(&#39;server connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;) stream.write(&#39;welcome!\n&#39;) stream.setEncoding(&#39;utf8&#39;) stream.pipe(stream) }) server.listen(8000, function () { console.log(&#39;server bound&#39;) }) o-&gt; 客户端 var options = { key: fs.readFileSync(&#39;./keys/client.key&#39;), cert: fs.readFileSync(&#39;./keys/client.crt&#39;), ca: [fs.readFileSync(&#39;./keys/ca.crt&#39;)] } var stream = tls.connect(8000, options, function () { console.log(&#39;client connected&#39;, stream.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;) # 证书是否通过 process.stdin.pipe(stream) }) stream.setEncoding(&#39;utf8&#39;) stream.on(&#39;data&#39;, function (data) { console.log(data) }) stream.on(&#39;end&#39;, function () { server.close() }) child_process # 介绍 可以创建新的node进程 spawn(command[, args][a options]) # command执行的命令 # args参数列表 options 环境变量对象, 包括7个属性 cwd 子进程当前工作目录 env 环境变量键值对 stdio 子进程stdio配置 customFds 子进程stdio使用的文件标示符 detached 进程组的主控制 uid 用户进程id 进程组id var du = child.spawn(&#39;du&#39;, [&#39;-sh&#39;, &#39;/disk1&#39;]); du.stdout.on(&#39;data&#39;, function(data){}) du.stderr.on(&#39;data&#39;, function(data){}) du.on(&#39;exit&#39;, function(code){}) exec(&#39;&#39;) # 对spawn的友好封装, 增加了shell命令解析 child.exec(&#39;cat *.js | ws&#39;, function(error, stdout, stderr){}) execFile(command[, args]) # 执行可执行文件，不解析args,防止了exec参数注入的风险 child.execFile(&#39;/bin/ls&#39;, [&#39;-l&#39;, &#39;.&#39;], function(err, result){}) fork() # 同spawn, 但建立ipc(进程通信, inter-process communication) var n = child.fork(&#39;./son.js&#39;); n.on(&#39;message&#39;, function(){ console.log(&#39;Main listen: &#39;, m); }); n.send({hello: &#39;i am parent&#39;}); // son.js process.on(&#39;message&#39;, function(m){ console.log(&#39;Son listen: &#39;, m); }); process.send({hello: &#39;i am child&#39;}); 子进程对象 send() # 发送消息和句柄，句柄可以是 ## net.Socket, net.Server, net.Native(c&#43;&#43;层面的tcp套接字或IPC管道), dgram.Socket, dgram.Native kill() # 向子进程发送SIGTERM信号 事件 message error exit close disconnect o-&gt; cpu核数worker o-&gt; master.js var fork = require(&#39;child_process&#39;).fork var cpus = require(&#39;os&#39;).cpus() for (var i = 0; i &lt; cpus.length; i&#43;&#43;){ fork(&#39;./worker.js&#39;) } o-&gt; worker.js var http = require(&#39;http&#39;) http.createServer(function(req, res){...}).listen(Math.round((1&#43;Math.random()) * 1000), &#39;127.0.0.1&#39;) o-&gt; spawn var spawn = require(&#39;child_process&#39;).spawn free = spawn(&#39;free&#39;, [&#39;-m&#39;]) free.stdout.on(&#39;data&#39;, function (data) {}) free.stderr.on(&#39;data&#39;, function (data) {}) free.on(&#39;exit&#39;, function (code, signal) {}) o-&gt; fork # 需要至少30ms, 10M启动一个v8实例 var fork = require(&#39;child_process&#39;).fork var cpus = require(&#39;os&#39;).cpus() for (var i = 0; i &lt; cpus.length; i&#43;&#43;) { fork(&#39;./worker.js&#39;) } o-&gt; 通信 # 只有子进程是node进程时才可以通信 var cp = require(&#39;child_process&#39;) var n = cp.fork(__dirname &#43; &#39;/sub.js&#39;) n.on(&#39;message&#39;, function (m) { console.log(&#39;PARENT got message: &#39;, m) }) n.send({a: 1}) process.on(&#39;message&#39;, function (m) { console.log(&#39;CHILD got message:&#39;, m) }) process.send({b: 2}) o-&gt; 句柄通信 # 节省了代理建立socket浪费的文件描述符 var child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;) var server = require(&#39;net&#39;).createServer() server.on(&#39;connection&#39;, function (socket) { socket.end(&#39;handled by parent \n&#39;) }) server.listen(1337, function () { child.send(&#39;server&#39;, server) }) // child.js process.on(&#39;message&#39;, function (m, server) { if (m === &#39;server&#39;) { server.on(&#39;connection&#39;, function (socket) { socket.end(&#39;handled by child \n&#39;) }) } }) o-&gt; 句柄负载http # 对描述符是抢占式的 var cp = require(&#39;child_process&#39;) var child1 = cp.fork(&#39;child.js&#39;) var child2 = cp.fork(&#39;child.js&#39;) var server = require(&#39;net&#39;).createServer() server.listen(1337, function () { child1.send(&#39;server&#39;, server) child2.send(&#39;server&#39;, server) server.close() }) // child.js var http = require(&#39;http&#39;) var server = http.createServer(function (req, res) { res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;}) res.end(&#39;handled by child, pid is &#39; &#43; process.pid &#43; &#39;\n&#39;) }) process.on(&#39;message&#39;, function (m, tcp) { if (m === &#39;server&#39;) { tcp.on(&#39;connection&#39;, function (socket) { server.emit(&#39;connection&#39;, socket) }) } }) cluster # 介绍 child_process和net模块的组合 cluster启动时，内部启动tcp服务器 fork()时，将tcp服务器socket文件描述符发给worker, 实现共享端口 isWorker 判断process.env是否值为NODE_UNIQUE_ID isMaster 判断cluster.isWorker 事件 fork # fork时 online # 工作进程创建好后 listening # 工作进程调listen()后 disconnect # 主进程和工作进程IPC通道断开后 exit # 所有工作进程退出后 setup # cluster.setupMaster()执行后 o-&gt; cpu核数worker var cluster = require(&#39;cluster&#39;) cluster.setupMaster({ exec: &#34;worker.js&#34; }) var cpus = require(&#39;os&#39;).cpus() for (var i = 0; i &lt; cpus.length; i&#43;&#43;) { cluster.fork() } domain # 介绍 用于异步异常捕获 绑定方式 隐式绑定: 把domain上下文中定义的变量，自动绑定到domain对象 显式绑定: 把不是domain上下文中定义的变量，以代码的方式绑定到domain对象 members # 已加入domain对象的域定时器和事件发射器的数组 create() # 返回一个domain对象 run(fn) # 在domain上下文中执行一个函数，并隐式绑定所有事件、定时器和低级请求 add(emitter) # 显式的增加事件 remove(emitter) # 删除事件 bind(callback) # 以return为封闭callback函数　intercept(callback) # 同bind, 但返回第一个参数 enter() # 进入一个异步调用的上下文，绑定到domain exit() # 退出当前的domain, 切换到不同的链的异步调用的上下文中，对应domain.enter() dispose() # 释放一个domain对象，让node进程回收这部分资源 使用 var domain = require(&#39;domain&#39;); function async_error(){ setTimeout(function(){ var r = Math.random() * 10; console.log(&#39;random num is &#39; &#43; r); if(r &gt; 5) throw new Error(&#39;Error: random num &#39; &#43; r &#43; &#39; &gt; 5&#39;); }, 10); } var d = domain.create(); d.on(&#39;error&#39;, function(err){ console.log(err); }); setInterval(function(){ d.run(async_err); }, 1000); 未绑定不捕获 代码 var domain = require(&#39;domain&#39;); var EventEmitter = require(&#39;events&#39;).EventEmitter; var e = new EventEmitter(); var timer = setTimeout(function(){ e.emit(&#39;data&#39;); }, 10); function next(){ e.once(&#39;data&#39;, function(){ throw new Error(&#39;Receive data error!&#39;); }); } var d = domain.create(); d.on(&#39;error&#39;, function(err){ console.log(err); }); d.run(next); 原因 timer和e两个关键对象在初始化时都没有在domain范围内。当next函数中抛出异常时, 没有处于domain的包裹中 修改 ... d.add(e); d.add(timer); d.run(next); 外部lib # url # parse() pathname url.parse(req.url) url.parse(req.url, true) 会parse出query对象 querystring # parse() querystring.parse(url.parse(req.url).query) crypto # 介绍 加密并生成各种散列 利用openssl库来实现，提供openssl中一系列哈希方法，包括hmac, cipher, decipher, 签名和验证等方法的封装 使用 var crypto = require(&#39;crypto&#39;); console.log(crypto.getHashes()); # 打印支持的所有hasp算法 node-gyp # 编译C&#43;&#43;模块的编译工具 util # 使用 var util = require(&#39;util&#39;); 方法 inherits(Sub, Base) # 对象间原型继承，Sub 仅继承Base原型中定义 的函数 inspect(obj) # 任意对象转换为字符串 log(string) # 带时间戳的log format(&#39;%s:%s&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;) // &#39;a:b c&#39; # format(&#39;%s:%s&#39;, &#39;a&#39;) // &#39;a:%s&#39; # format(1, 2, 3) // &#39;1 2 3&#39; is系列 isArray(obj) isRegExp(obj) isDate(obj) isError(obj) isBoolean(obj) isNull(obj) isNullOrUndefined(obj) isNumber(obj) isString(obj) isSymbol(obj) isUndefined(obj) isObject(obj) isFunction(obj) isPrimitive(obj) # 是否基本类型 isBuffer(obj) deprecate(foo, &#39;foo() is deprecated, use bar() instead&#39;); # 标记为过时, 调用foo()时显示后面的话 zlib # 介绍 提供压缩方法，如gzip 全局属性 # 介绍 并非挂在global下的属性，但可以直接使用 __dirname # 在任何模块内获取当前模块文件的绝对路径 __filename # 当前在执行的js文件路径 方案 # 异常捕获 process.on(&#34;uncaughtException&#34;,function(e){ logger.error(&#34;error:&#34;&#43;e); }); process.on(&#39;unhandledRejection&#39;, function (err, p) { console.error(err.stack) });">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2018-10-11T10:33:48+08:00">
    <meta property="article:modified_time" content="2022-04-23T22:18:41+08:00">
<title>Nodejs | ukeate的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://ukeate.com/docs/middleware/container/nodejs/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.583fa0f4b9042b18aff2c52da52cf49a4f5a6745f9e09453d85a938cfec8ee01.js" integrity="sha256-WD&#43;g9LkEKxiv8sUtpSz0mk9aZ0X54JRT2FqTjP7I7gE=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span>ukeate的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>







  
<ul>
  
  <li>
    <a href="/posts/"  >
        Blog
      </a>
  </li>
  
</ul>










  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/" class="">基本功</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/speach/" class="">演说</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/body/" class="">身体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/" class="">Computer</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/principle/" class="">支撑-原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/performance/" class="">Performance</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/" class="">算法</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/thought/" class="">算法思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/data_structure/" class="">数据结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/math/" class="">数学</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/" class="">架构</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/" class="">代码</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/security/" class="">Security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/design_mode/" class="">Java设计模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/" class="">工程设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/ddd/" class="">工程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/frontend/" class="">前端</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>战略性技术</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/" class="">AI</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/map/" class="">知识图谱</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/framework/" class="">Framework</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/media/" class="">媒体</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/middle_platform/" class="">中台</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/block_chain/" class="">Block Chain</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Cloud</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/" class="">Datalake</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/ecology/" class="">Ecology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/edge/" class="">Edge</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/" class="">Manage</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/" class="">组织</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/people/" class="">人员</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/" class="">Method</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/product_plan/" class="">产品规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/code_plan/" class="">代码规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/ops_plan/" class="">运维规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/advice_plan/" class="">咨询规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/architect/" class="">服务治理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/project_plan/" class="">项目规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/test_plan/" class="">测试规划</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/summary/" class="">这些年我做过的技术</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/" class="">程序语言</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/principle/" class="">程序语言原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/haskell/" class="">Haskell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/elixir/" class="">Elixir</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/clojure/" class="">Clojure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/js/" class="">JS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/java_reactive/" class="">Java响应式编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/javaweb/" class="">JavaWeb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/juc/" class="">Java并发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/jvm/" class="">JVM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/collection/" class="">Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/spring/" class="">Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/" class="">Markup Language</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/html/" class="">Html</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/css/" class="">Css</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/" class="">工具</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/" class="">运维</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/monitor/" class="">Monitor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/docker/" class="">Docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/k8s/" class="">Kubernetes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/enterprise_system/" class="">企业级系统</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/" class="">Develop</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/eclipse/" class="">Eclipse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/vim/" class="">VIM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/apple/" class="">Apple</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/jetbrains/" class="">Jetbrains</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/" class="">Linux</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_program/" class="">LinuxProgram</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/scene/" class="">LinuxScene</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_tool/" class="">LinuxTool</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/framework/" class="">Framework</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/physics/" class="">实物工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/" class="">测试</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/debug/" class="">程序调试</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/" class="">数据库</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mongodb/" class="">Mongodb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/postgresql/" class="">Postgre SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/oracle/" class="">Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/" class="">中间件</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/" class="">支撑-分布式</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/spring_cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/" class="">前端</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/bootstrap/" class="">Bootstrap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/threejs/" class="">Threejs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/angular/" class="">Angular</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/jquery/" class="">Jquery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/react/" class="">React</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/" class="">小功能</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/hibernate/" class="">Hibernate</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Container</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nginx/" class="">Nginx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nodejs/" class="active">Nodejs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/" class="">Cache</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/ops/" class="">Ops</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/work_code/" class="">Work Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/template/" class="">模板配置</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/soft_arch/" class="">软考架构师</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/misc/" class="">杂项</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Nodejs</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a></li>
    <li><a href="#工具">工具</a></li>
    <li><a href="#配置">配置</a></li>
    <li><a href="#api">api</a>
      <ul>
        <li><a href="#异步api">异步api</a></li>
        <li><a href="#宿主对象">宿主对象</a></li>
        <li><a href="#内置lib">内置lib</a>
          <ul>
            <li><a href="#http">http</a></li>
            <li><a href="#https">https</a></li>
            <li><a href="#net">net</a></li>
            <li><a href="#dgram">dgram</a></li>
            <li><a href="#events">events</a></li>
            <li><a href="#path">path</a></li>
            <li><a href="#os">os</a></li>
            <li><a href="#fs">fs</a></li>
            <li><a href="#sys">sys</a></li>
            <li><a href="#process">process</a></li>
            <li><a href="#module">module</a></li>
            <li><a href="#stream">stream</a></li>
            <li><a href="#tls">tls</a></li>
            <li><a href="#child_process">child_process</a></li>
            <li><a href="#cluster">cluster</a></li>
            <li><a href="#domain">domain</a></li>
          </ul>
        </li>
        <li><a href="#外部lib">外部lib</a>
          <ul>
            <li><a href="#url">url</a></li>
            <li><a href="#querystring">querystring</a></li>
            <li><a href="#crypto">crypto</a></li>
            <li><a href="#node-gyp">node-gyp</a></li>
            <li><a href="#util">util</a></li>
            <li><a href="#zlib">zlib</a></li>
          </ul>
        </li>
        <li><a href="#全局属性">全局属性</a></li>
      </ul>
    </li>
    <li><a href="#方案">方案</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>特点
    commonJS规范
    javascript书写(v8引擎)
        js设计之初就可以运行在后端
        v8
            成熟的事件驱动模式
            没有i/o库, 没有历史包袱
            v8性能好
    单线程
        不用在意多线程状态同步(没有死锁, 没有上下文切换)
        无法利用多核, 错误时应用退出，计算密集时无法调度   # child_process解决
    事件驱动(event-driven), 回调
        event loop
            [while(true)] -&gt; watcher -&gt; handles
            watcher产生事件后, event loop取到并执行其handle(回调函数)
            event loop每一周询问多个watcher是否有事件
            event loop中没有watcher时进程退出
        http模块就是启动了一个watcher,所以执行后进程不结束
            其它watcher有 timer, fs, udp/req, process
        不同操作系统中event driven的实现:
            windows: IOCP
            Linux: epoll
            Mac:kqueue
    非阻塞io(non-blocking i/o model)
        io与数据处理分离（所以必须异步）
        线程池结合event-driven实现
    异步io
        go语言有协程(coroutine)而node.js没有，协程可以同步式编程
            # 有第三方协程模块
        promise(commonJs的规范, 其实现有whenJs, Q)
            # 书写难度降低
        eventProxy      # 朴灵
        async/step
commonJS
    模块
        var math = require('math')  # 缓存优先，核心模块优先。依次找.js, .node, .json
        exports.add = function(){}
    二进制
    Buffer
    字符集编码
    I/O流
    进程环境
    文件
    套接字
    单元测试
    web网关
    包管理
        package.json
        bin
        lib
        doc
        test
实现技术
    libev的windows与linux接口实现
    c++扩展
事件循环    # 生产者消费者模型
    执行一次称为Tick
    询问观察者(文件、网络等)是否有待处理事件, 有关联回调执行回调
        # 观察者先idle, 再io, 再check
        通过请求对象实现，绑定回调、运行参数、执行标志
层次
    javascript
    v8
    node
    libuv
    *nix/ windows                # 分别编译
应用
    I/O密集服务
    cpu密集用c/c++扩展，用子进程
</code></pre>
<h1 id="工具">
  工具
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7">#</a>
</h1>
<pre><code>node --v8-options | grep harmony
    # 查看支持的es6特性
npm
    介绍
        cnpm是一个alibaba开发维护的，提供私有npm注册服务
    -v      # 版本
    install     # 安装，会执行package.json中scripts的勾子命令
        -g
    uninstall
    config
        list    # 查看项目的默认设置。registry属性指向npm官方资源位置
        set registry http://192.168.1.20:7001
            # 设置源
    test        # package.json中scripts的test

    o-&gt; 搭建cnpm服务器
        git clone https://github.com/cnpm/cnpmjs.org.git
        cd cnpmjs.org
        npm install npm -g
            # 升级npm的版本
        npm install
        创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码
        config/index.js中注释bindingHost来对外网开放
        node --harmony_generators dispatch.js
            # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问
    o-&gt; 使用私有库
        npm install ape-algorithm --registry=http://192.168.1.20:7001
            # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份

    设置
         ~/.npmrc
            registry=http://192.168.1.20:7001
                # 淘宝翻墙库 https://registry.npm.taobao.org/
n
node-gyp    # 编译c/c++模块
nvm
cnpm
    介绍
        cnpm是一个alibaba开发维护的，提供私有npm注册服务
    安装
        npm install cnpm
            # 可以像使用npm一样使用
        cnpm sync gulp
            # npm 中发布的包在cnpm中有延时，可以用这个命令来手动同步
    搭建cnpm服务器
        git clone https://github.com/cnpm/cnpmjs.org.git
        cd cnpmjs.org
        npm install npm -g
            # 升级npm的版本
        npm install
        创建mysql数据库，并在config/index.js中修改mysql数据库的用户名和密码
        config/index.js中注释bindingHost来对外网开放
        node --harmony_generators dispatch.js
            # 启动了两个端口, 7001用于npm注册服务, 7002用于web访问
    使用私有库
        npm install ape-algorithm --registry=http://192.168.1.20:7001
            # 如果私有库中没有，cnpm会到npm中同步一个到cnpm, 再传给客户端一份
    项目设置私有库
        npm config list
            # 查看项目的默认设置。registry属性指向npm官方资源位置
        npm config set registry http://192.168.1.20:7001
    用户设置私有库
        // ~/.npmrc
        registry=http://192.168.1.20:7001
            # 另外，淘宝翻墙库 https://registry.npm.taobao.org/
调试
    o-&gt; 代码中插入断点
        debugger;
    o-&gt; 以debug模式运行
        # debug模式运行时, help查看可用命令
        node debug app.js
</code></pre>
<h1 id="配置">
  配置
  <a class="anchor" href="#%e9%85%8d%e7%bd%ae">#</a>
</h1>
<pre><code>package.json
    name                # 包名
    description         # 简介
    version             # 版本
    keywords            # 搜索关键词
    maintainers         # 维护者
    contributors        # 代码贡献者
    bugs                # 反馈bug的地址
    licenses            # 许可证
    repositories        # 托管代码地址
    dependencies        # 依赖包
    homepage            # 该包网站
    os                  # 操作系统支持列表
    cpu                 # cpu架构支持列表
    engine              # 支持的js引擎, 如ejs
    builtin             # 内建在底层系统的哪些组件上
    directories         # 目录说明
    implements          # 实现了commonJS哪些规范
    scripts             # 脚本命令
        preinstall
        install
        uninstall
        test
    author              # 包作者
    bin                 # 全局安装时，命令安装的位置
    main                # require()包时入口，默认找index
    devDependencies     # 开发时需要的依赖

    o-&gt;
    {
        &quot;name&quot;: &quot;test&quot;,
        &quot;version&quot;: &quot;0.1.0&quot;,
        &quot;keywords&quot;: [&quot;a&quot;, &quot;b&quot;],                     # npm search时用
        &quot;description&quot;: &quot;A testing package&quot;,
        &quot;os&quot;: [&quot;linux&quot;, &quot;darwin&quot;],
        &quot;author&quot;: &quot;outrun&lt;outrun@mail.com&gt;&quot;,
        &quot;dependencies&quot;: {
            &quot;express&quot;: &quot;^1.0.0&quot;,
            &quot;redis&quot;: &quot;&gt;= 0.6.7&quot;
        },
        &quot;devDependencies&quot;: {
            &quot;grunt&quot;: &quot;^0.4.5&quot;
        },
        &quot;main&quot;: &quot;index&quot;,
        &quot;bin&quot;: {
            &quot;test&quot;: &quot;./bin/test.js&quot;
        },
        &quot;scripts&quot;: {
            &quot;start&quot;: &quot;node server.js&quot;,
            &quot;test&quot;: &quot;vows test/*.js&quot;,               # &quot;grunt test&quot; &quot;mocha test&quot; &quot;make test&quot; &quot;make test-all&quot;
            &quot;preinstall&quot;: &quot;./configure&quot;,
            &quot;install&quot;: &quot;make &amp;&amp; make install&quot;,
            &quot;uninstall&quot;: &quot;&quot;
        },
        &quot;engines&quot;: {
            &quot;node&quot;: &quot;5.0.0&quot;
        }
    }
</code></pre>
<h1 id="api">
  api
  <a class="anchor" href="#api">#</a>
</h1>
<h2 id="异步api">
  异步api
  <a class="anchor" href="#%e5%bc%82%e6%ad%a5api">#</a>
</h2>
<pre><code>I/O操作api
setTimeout() setInterval()
    定时器插入观察者的红黑树中, tick时迭代定时器，如果超时就形成事件
        # 如果前一个tick耗时大，定时会拖后
        # 比较浪费性能
process.nextTick()
    回调放入队列，下tick全部执行, 位于idle观察者
setImmediate()
    回调放入链表, 每tick执行一个，位于check观察者，晚于idle
</code></pre>
<h2 id="宿主对象">
  宿主对象
  <a class="anchor" href="#%e5%ae%bf%e4%b8%bb%e5%af%b9%e8%b1%a1">#</a>
</h2>
<pre><code>global      #全局对象
    root    # 指向自己
    BLOBAL # 指向自己

    setTimeout()
    setInterval()
    clearTimeout()
    clearInterval()
process     #当前进程
    argv    # 获得命令行参数数组
        title       # node
        version     # v0.12.2
    事件
        process.on(&quot;uncaughtException&quot;,function(e){
            console.log(&quot;error:&quot;+e);
        });
buffer
    特点
        node中buffer不属于v8, 使用c++扩展编写。所以可以使用高于1.4g的内存
        一个元素一字节
        8kb之内为小对象，slab机制分配内存, 先申请后分配。大于8kb的创建SlowBuffer对象
        pool的实现方式
    字符编码类型
        # 默认编码UTF-8, 一个buffer只能有一个编码
        ascii
        utf-8
        utf-16le/ucs-2
        base64
        binary
        hex

    length

    write()
        # write(str, [offset], [length], [encoding])
    toString()
        # toString([encoding], [start], [end])
    isEncoding()
        # 指定编码是否支持转换
    copy()
        # 复制自身到另一个buffer的某位置
        buf.copy(buffer, 0)
    concat()  #静态方法
        concat(chunks, size)
            # chunks中为buffer数组, size为总大小
    使用
        new Buffer(100)
        new Buffer('a', 'UTF-8')
console     #控制台
    log('',obj)
        console.log('[%s] listening on http://127.0.0.1:%d', app.setting.env, port)
module
    Module.exports真正的接口，导出的是一个类型
    exports是Module.exports的包装，导出的是Object类型的对象
promise     # 0.11.x后加入的全局对象
    使用
        # 复制
        var jadeTemplate = new Promise(function(resolve, reject) {
        fs.readFile(path.join(__dirname, 'views/article.jade'), function(err, data) {
            if (err) {
            reject(err.message);
            } else {
            resolve(data.toString());
            }
        });
        });

        var localData = new Promise(function(resolve, reject) {
        fs.readFile(path.join(__dirname, 'static/shuffle.json'), function(err, data) {
            if (err) {
            reject(err.message);
            } else {
            resolve(JSON.parse(data.toString()));
            }
        });
        });

        Promise
        .all([jadeTemplate, localData])
        .then(function(value) {
            console.log(jade.compile(value[0])(value[1]));
        });
</code></pre>
<h2 id="内置lib">
  内置lib
  <a class="anchor" href="#%e5%86%85%e7%bd%aelib">#</a>
</h2>
<h3 id="http">
  http
  <a class="anchor" href="#http">#</a>
</h3>
<pre><code>介绍
    继承自net模块
    EventEmitter实例
事件
    服务端
        connection
        request
        close
        checkContinue
            # 发送较大数据时，先发送Expect: 100-continue请求头，此时触发
        connect
        upgrade
            # 要求升级连接协议时
        clientError
            # 客户端触发error事件时触发
    客户端
        response
        socket
            # 建立连接时触发
        connect
            # 响应200时触发
        upgrade
        continue

globalAgent     # 重用http长连接，实际是个连接池，默认有5个并发
    sockets
        # 连接数
    requests
        # 处于等待状态的请求数

createServer(onRequest).listen(8888, func);                # 创建服务器并启动
    request
        req.setEncoding(&quot;utf8&quot;)
        var postData = &quot;&quot;;
        req.addListener(&quot;data&quot;, function(postDataChunk){
            postData += postDataChunk;
        });
        req.addListener(&quot;end&quot;, function(){
            route(handle, pathname, res, postData);
        });                                # 拼接post请求数据
        req.rawBody
            # post来的原生数据
        req.destroy()
            # 放弃请求，停止招收

    response
        res.setHeader('WWW-Authenticate', 'Basic realm=\&quot;Tomcat Manager Application\&quot;')
        res.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
            # 调用setHeader多次，调用writeHead后才写入
        res.write(&quot;&quot;);
        res.write(file,?&quot;binary&quot;);?
        res.end();
request(options, fn)        # 发起客户端请求
    # options中有 host, hostname, port, localAddress(使用本地的哪个网卡), socketPath(本地套接字文件路径), method, path, headers, auth(被计算成请求头的Authorization部分), agent(并发连接数，默认5)
</code></pre>
<h3 id="https">
  https
  <a class="anchor" href="#https">#</a>
</h3>
<pre><code>介绍
    nodejs
    申请ca证书
    访问端口为443
使用
    express -e nodejs-https
    cd nodejs-https &amp;&amp; npm install
    git --version
    openssl version -a
    openssl genrsa -out privatekey.pem 1024
        # 生成证书文件
    openssl req -new -key privatekey.pem -out certrequest.csr
        # 通过私钥生成CSR证书签名
    openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem
        # 通过私钥和证书签名生成证书文件
        ## 这时生成了三个文件: certificate.pem, certrequest.csr, privatekey.pem
        ### 分别是: 证书文件, CSR证书签名, 私钥
        ## 由于证书是自己创建的，没有经过第三方机构验证，用户访问时会出现警告提示
    服务器
        var https = require('https')
            , fs = require('fs');
        var options = {
            key: fs.readFileSync('./privatekey.pem'),
            cert: fs.readFileSync('./certificate.pem')
        };
        https.createServer(options, app).listen(3011, function(){
            console.log('Https server listening on port: ' + 3011);
        });
    客户端
        var options = {
            hostname: 'localhost',
            port: 8000,
            path: '/',
            method: 'GET',
            key: fs.readFileSync('./keys/client.key'),
            cert: fs.readFileSync('./keys/client.crt'),
            ca: [fs.readFileSync('./keys/ca.crt')]
                # 设置rejectUnauthorized: false 来忽略ca验证
        }
        options.agent = new https.Agent(options)

        var req = https.request(options, function (res) {
            res.setEncoding('utf-8')
            res.on('data', function (d) {
                console.log(d)
            })
        })
        req.end()

        req.on('error', function(e){
            console.log(e)
        })
</code></pre>
<h3 id="net">
  net
  <a class="anchor" href="#net">#</a>
</h3>
<pre><code>介绍
    处理tcp请求
    socket是EventEmitter的Stream实例
注意
    默认开启Nagle, 会合并小数据成一个数据包延迟发送
        socket.setNoDelay(true)关闭Nagle
    并不是每次write都触发data事件, 关掉Nagle后，可能接收到多个小数据包后触发一次data

服务器事件
    listening
    connection
    close
    error
连接事件
    data
    end
    connect
    drain
        # 任意一端调用write时触发
    error
    close
    timeout

o-&gt; 基本服务
# telnet来测试
var net = require('net')

var server = net.createServer(function (socket) {
    socket.on('data', function (data) {
        socket.write('a')
    })

    socket.on('end', function () {
        console.log('disconnected.')
    })

    socket.write('welcome')
})

server.listen(8124, function () {
    console.log('server bound')
})

o-&gt; 基本服务2
var server = net.createServer()
server.on('connection', function (socket) {})
server.listen(8124)

o-&gt; 监听
server.listen('/tmp/echo.sock')
    # nc -U /tmp/echo.sock 来测试

o-&gt; 客户端
var client = net.connect({port: 8124}, function () {
    console.log('client connected')
    client.write('a')
})

client.on('data', function (data) {
    console.log(data.toString())
    client.end()
})

client.on('end', function() {
    console.log('disconnected.')
})

o-&gt; 客户端
var client = net.connect({path: '/tmp/echo.sock'})

o-&gt; 管道
var server = net.createServer(function (socket) {
    socket.write('a')
    socket.pipe(socket)
})
</code></pre>
<h3 id="dgram">
  dgram
  <a class="anchor" href="#dgram">#</a>
</h3>
<pre><code>介绍
    处理udp
    socket是EventEmitter实例

o-&gt; 服务
var dgram = require('dgram')

var server = dgram.createSocket('udp4')

server.on('message', function (msg, rinfo) {
    console.log(msg + 'from' + rinfo.address + ':' +)
})

server.on('listening', function () {
    var address = server.address()
    console.log('listening ' + address.address + ':' + address.port)
})

server.bind(41234)

o-&gt; 客户端
var message = new Buffer('a')
var client = dgram.createSocket('udp4')
client.send(message, 0, message.length, 41234, 'localhost', function (err, bytes) {
    client.close()
})
</code></pre>
<h3 id="events">
  events
  <a class="anchor" href="#events">#</a>
</h3>
<pre><code>介绍
    几乎所有对象的父类
使用
    var events = require('events')
        , util = require('util');
    function Obj(){events.EventEmitter.cal(this);}
    util.inherits(Obj, events.EventEmitter);
        # Obj.prototype.__proto__ = events.EventEmitter.prototype;
    Obj.prototype.write = function (data) {this.emit('data', data);};

    var obj = new Obj();
    obj.on('data', function (data) {console.log('Received data', data);})
        # obj.once
    obj.write('hello');

setMaxListeners(0)
    # 侦听器过多不警告
</code></pre>
<h3 id="path">
  path
  <a class="anchor" href="#path">#</a>
</h3>
<h3 id="os">
  os
  <a class="anchor" href="#os">#</a>
</h3>
<pre><code>方法
    totalmem
    freemem
</code></pre>
<h3 id="fs">
  fs
  <a class="anchor" href="#fs">#</a>
</h3>
<pre><code>fs.readFile(&quot;tmp/test.png&quot;, &quot;binary&quot;, function(error, file){
});
fs.writeFile('target.png', 'binary', function(err){
})
fs.exists(filePath, function(exists){
        if(exists){}
})
fs.unlink(filePath, function(err){
})
fs.renameSync(files.upload.path,?&quot;/tmp/test.png&quot;);                # 写入文件(阻塞)

o-&gt; 流读写
var reader = fs.createReadStream('in.txt')
        # 第二个参数为设置, highWaterMark: 每次读取的size, encoding: 编码
var writer = fs.createWriteStream('out.txt')
reader.on('data', function (chunk) {
        writer.write(chunk)
})
reader.on('end', function() {
        writer.end()
})

var reader = fs.createReadStream('in.txt')
var writer = fs.createWriteStream('out.txt')
reader.pipe(writer)
</code></pre>
<h3 id="sys">
  sys
  <a class="anchor" href="#sys">#</a>
</h3>
<h3 id="process">
  process
  <a class="anchor" href="#process">#</a>
</h3>
<pre><code>argv
    # 启动时参数
pid
    # 当前进程的pid

once()
    once('SIGINT', function () {})
        # ctrl + c
memoryUsage()
    # 查看v8内存使用量
    # 其中rrs是resident set size, 是常驻内存的部分，其他在swap或文件系统中
kill()
    # process.kill(pid[, signal])
on()
    # 事件触发

o-&gt;
process.on('SIGTERM', function () {
    console.log('Got a SIGTERM, exiting...')
    process.exit(1)
})

o-&gt;
process.on('uncaughtException', function () {
    logger.error(err)
    process.send({act: 'suicide'})
        # 向主进程发送信号
    worker.close(function () {
        process.exit(1)
    })

    setTimeout(function () {
        # 长连接断开需要时间较久, 超时自动退出
        process.exit(1)
    }, 5000)
})
</code></pre>
<h3 id="module">
  module
  <a class="anchor" href="#module">#</a>
</h3>
<pre><code>exports
parent
</code></pre>
<h3 id="stream">
  stream
  <a class="anchor" href="#stream">#</a>
</h3>
<pre><code>介绍
    继承EventEmitter, 处理文件之类的流
</code></pre>
<h3 id="tls">
  tls
  <a class="anchor" href="#tls">#</a>
</h3>
<pre><code>介绍
    建立在tls/ssl上的加密tcp
    使用openssl来构建证书和测试

o-&gt; 服务器
var tls = require('tls')
var fs = require('fs')

var options = {
        key: fs.readFileSync('./keys/server.key'),
        cert: fs.readFileSync('./keys/server.crt'),
        requestCert: true,
        ca: [fs.readFileSync('./keys/ca.crt')]
}

var server = tls.createServer(options, function (stream) {
        console.log('server connected', stream.authorized ? 'authorized' : 'unauthorized')
        stream.write('welcome!\n')
        stream.setEncoding('utf8')
        stream.pipe(stream)
})
server.listen(8000, function () {
        console.log('server bound')
})

o-&gt; 客户端
var options = {
        key: fs.readFileSync('./keys/client.key'),
        cert: fs.readFileSync('./keys/client.crt'),
        ca: [fs.readFileSync('./keys/ca.crt')]
}

var stream = tls.connect(8000, options, function () {
        console.log('client connected', stream.authorized ? 'authorized' : 'unauthorized')
                # 证书是否通过
        process.stdin.pipe(stream)
})

stream.setEncoding('utf8')
stream.on('data', function (data) {
        console.log(data)
})
stream.on('end', function () {
        server.close()
})
</code></pre>
<h3 id="child_process">
  child_process
  <a class="anchor" href="#child_process">#</a>
</h3>
<pre><code>介绍
    可以创建新的node进程
spawn(command[, args][a options])
    # command执行的命令
    # args参数列表
    options 环境变量对象, 包括7个属性
        cwd 子进程当前工作目录
        env 环境变量键值对
        stdio 子进程stdio配置
        customFds 子进程stdio使用的文件标示符
        detached 进程组的主控制
        uid 用户进程id
        进程组id

    var du = child.spawn('du', ['-sh', '/disk1']);
    du.stdout.on('data', function(data){})
    du.stderr.on('data', function(data){})
    du.on('exit', function(code){})
exec('')
    # 对spawn的友好封装, 增加了shell命令解析
    child.exec('cat *.js | ws', function(error, stdout, stderr){})
execFile(command[, args])
    # 执行可执行文件，不解析args,防止了exec参数注入的风险
    child.execFile('/bin/ls', ['-l', '.'], function(err, result){})
fork()
    # 同spawn, 但建立ipc(进程通信, inter-process communication)
    var n = child.fork('./son.js');
    n.on('message', function(){
        console.log('Main listen: ', m);
    });
    n.send({hello: 'i am parent'});
    // son.js
    process.on('message', function(m){
        console.log('Son listen: ', m);
    });
    process.send({hello: 'i am child'});
子进程对象
    send()
        # 发送消息和句柄，句柄可以是
        ## net.Socket, net.Server, net.Native(c++层面的tcp套接字或IPC管道), dgram.Socket, dgram.Native
    kill()
        # 向子进程发送SIGTERM信号
    事件
        message
        error
        exit
        close
        disconnect

o-&gt; cpu核数worker
    o-&gt; master.js
    var fork = require('child_process').fork
    var cpus = require('os').cpus()
    for (var i = 0; i &lt; cpus.length; i++){
        fork('./worker.js')
    }

    o-&gt; worker.js
    var http = require('http')
    http.createServer(function(req, res){...}).listen(Math.round((1+Math.random()) * 1000), '127.0.0.1')

o-&gt; spawn
var spawn = require('child_process').spawn
free = spawn('free', ['-m'])
free.stdout.on('data', function (data) {})
free.stderr.on('data', function (data) {})
free.on('exit', function (code, signal) {})

o-&gt; fork
    # 需要至少30ms, 10M启动一个v8实例
var fork = require('child_process').fork
var cpus = require('os').cpus()
for (var i = 0; i &lt; cpus.length; i++) {
        fork('./worker.js')
}

o-&gt; 通信
    # 只有子进程是node进程时才可以通信
var cp = require('child_process')
var n = cp.fork(__dirname + '/sub.js')

n.on('message', function (m) {
    console.log('PARENT got message: ', m)
})
n.send({a: 1})

process.on('message', function (m) {
    console.log('CHILD got message:', m)
})
process.send({b: 2})

o-&gt; 句柄通信
    # 节省了代理建立socket浪费的文件描述符
var child = require('child_process').fork('child.js')
var server = require('net').createServer()
server.on('connection', function (socket) {
    socket.end('handled by parent \n')
})
server.listen(1337, function () {
    child.send('server', server)
})
// child.js
process.on('message', function (m, server) {
    if (m === 'server') {
        server.on('connection', function (socket) {
            socket.end('handled by child \n')
        })
    }
})

o-&gt; 句柄负载http
    # 对描述符是抢占式的
var cp = require('child_process')
var child1 = cp.fork('child.js')
var child2 = cp.fork('child.js')

var server = require('net').createServer()
server.listen(1337, function () {
    child1.send('server', server)
    child2.send('server', server)
    server.close()
})
// child.js
var http = require('http')
var server = http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'})
    res.end('handled by child, pid is ' + process.pid + '\n')
})
process.on('message', function (m, tcp) {
    if (m === 'server') {
        tcp.on('connection', function (socket) {
            server.emit('connection', socket)
        })
    }
})
</code></pre>
<h3 id="cluster">
  cluster
  <a class="anchor" href="#cluster">#</a>
</h3>
<pre><code>介绍
    child_process和net模块的组合
        cluster启动时，内部启动tcp服务器
        fork()时，将tcp服务器socket文件描述符发给worker, 实现共享端口
isWorker
    判断process.env是否值为NODE_UNIQUE_ID
isMaster
    判断cluster.isWorker
事件
    fork            # fork时
    online          # 工作进程创建好后
    listening       # 工作进程调listen()后
    disconnect      # 主进程和工作进程IPC通道断开后
    exit            # 所有工作进程退出后
    setup           # cluster.setupMaster()执行后

o-&gt; cpu核数worker
var cluster = require('cluster')
cluster.setupMaster({
    exec: &quot;worker.js&quot;
})

var cpus = require('os').cpus()
for (var i = 0; i &lt; cpus.length; i++) {
    cluster.fork()
}
</code></pre>
<h3 id="domain">
  domain
  <a class="anchor" href="#domain">#</a>
</h3>
<pre><code>介绍
    用于异步异常捕获
    绑定方式
        隐式绑定: 把domain上下文中定义的变量，自动绑定到domain对象
        显式绑定: 把不是domain上下文中定义的变量，以代码的方式绑定到domain对象
members     # 已加入domain对象的域定时器和事件发射器的数组

create()                # 返回一个domain对象
run(fn)                 # 在domain上下文中执行一个函数，并隐式绑定所有事件、定时器和低级请求
add(emitter)            # 显式的增加事件
remove(emitter)         # 删除事件
bind(callback)          # 以return为封闭callback函数　
intercept(callback)     # 同bind, 但返回第一个参数
enter()                 # 进入一个异步调用的上下文，绑定到domain
exit()                  # 退出当前的domain, 切换到不同的链的异步调用的上下文中，对应domain.enter()
dispose()               # 释放一个domain对象，让node进程回收这部分资源
使用
    var domain = require('domain');
    function async_error(){
        setTimeout(function(){
            var r = Math.random() * 10;
            console.log('random num is ' + r);
            if(r &gt; 5)
                throw new Error('Error: random num ' + r + ' &gt; 5');
        }, 10);
    }
    var d = domain.create();
    d.on('error', function(err){
        console.log(err);
    });
    setInterval(function(){
        d.run(async_err);
    }, 1000);
未绑定不捕获
    代码
        var domain = require('domain');
        var EventEmitter = require('events').EventEmitter;

        var e = new EventEmitter();

        var timer = setTimeout(function(){
            e.emit('data');
        }, 10);

        function next(){
            e.once('data', function(){
                throw new Error('Receive data error!');
            });
        }

        var d = domain.create();
        d.on('error', function(err){
            console.log(err);
        });
        d.run(next);
    原因
        timer和e两个关键对象在初始化时都没有在domain范围内。当next函数中抛出异常时, 没有处于domain的包裹中

    修改
        ...
        d.add(e);
        d.add(timer);
        d.run(next);
</code></pre>
<h2 id="外部lib">
  外部lib
  <a class="anchor" href="#%e5%a4%96%e9%83%a8lib">#</a>
</h2>
<h3 id="url">
  url
  <a class="anchor" href="#url">#</a>
</h3>
<pre><code>parse()
    pathname

    url.parse(req.url)
    url.parse(req.url, true) 会parse出query对象
</code></pre>
<h3 id="querystring">
  querystring
  <a class="anchor" href="#querystring">#</a>
</h3>
<pre><code>parse()
    querystring.parse(url.parse(req.url).query)
</code></pre>
<h3 id="crypto">
  crypto
  <a class="anchor" href="#crypto">#</a>
</h3>
<pre><code>介绍
    加密并生成各种散列
    利用openssl库来实现，提供openssl中一系列哈希方法，包括hmac, cipher, decipher, 签名和验证等方法的封装
使用
    var crypto = require('crypto');
    console.log(crypto.getHashes());                                    # 打印支持的所有hasp算法
</code></pre>
<h3 id="node-gyp">
  node-gyp
  <a class="anchor" href="#node-gyp">#</a>
</h3>
<pre><code>编译C++模块的编译工具
</code></pre>
<h3 id="util">
  util
  <a class="anchor" href="#util">#</a>
</h3>
<pre><code>使用
    var util = require('util');
方法
    inherits(Sub, Base)                # 对象间原型继承，Sub 仅继承Base原型中定义 的函数
    inspect(obj)                # 任意对象转换为字符串
    log(string)                        # 带时间戳的log
    format('%s:%s', 'a', 'b', 'c')                // 'a:b c'
        # format('%s:%s', 'a')                // 'a:%s'
        # format(1, 2, 3)                        // '1 2 3'
    is系列
        isArray(obj)
        isRegExp(obj)
        isDate(obj)
        isError(obj)
        isBoolean(obj)
        isNull(obj)
        isNullOrUndefined(obj)
        isNumber(obj)
        isString(obj)
        isSymbol(obj)
        isUndefined(obj)
        isObject(obj)
        isFunction(obj)
        isPrimitive(obj)
            # 是否基本类型
        isBuffer(obj)
        deprecate(foo, 'foo() is deprecated, use bar() instead');
            # 标记为过时, 调用foo()时显示后面的话
</code></pre>
<h3 id="zlib">
  zlib
  <a class="anchor" href="#zlib">#</a>
</h3>
<pre><code>介绍
    提供压缩方法，如gzip
</code></pre>
<h2 id="全局属性">
  全局属性
  <a class="anchor" href="#%e5%85%a8%e5%b1%80%e5%b1%9e%e6%80%a7">#</a>
</h2>
<pre><code>介绍
    并非挂在global下的属性，但可以直接使用

__dirname
    # 在任何模块内获取当前模块文件的绝对路径
__filename
    # 当前在执行的js文件路径
</code></pre>
<h1 id="方案">
  方案
  <a class="anchor" href="#%e6%96%b9%e6%a1%88">#</a>
</h1>
<pre><code>异常捕获
    process.on(&quot;uncaughtException&quot;,function(e){
        logger.error(&quot;error:&quot;+e);
    });
    process.on('unhandledRejection', function (err, p) {
        console.error(err.stack)
    });
</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/ukeate/hugo-blog/commit/9d2ea756f7e5d3ffd8c443f52554888da5999c1a" title='Last modified by outrunJ | Apr 23, 2022' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="" />
      <span>Apr 23, 2022</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/ukeate/hugo-blog/blob/master//content/docs/middleware/container/nodejs.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a></li>
    <li><a href="#工具">工具</a></li>
    <li><a href="#配置">配置</a></li>
    <li><a href="#api">api</a>
      <ul>
        <li><a href="#异步api">异步api</a></li>
        <li><a href="#宿主对象">宿主对象</a></li>
        <li><a href="#内置lib">内置lib</a>
          <ul>
            <li><a href="#http">http</a></li>
            <li><a href="#https">https</a></li>
            <li><a href="#net">net</a></li>
            <li><a href="#dgram">dgram</a></li>
            <li><a href="#events">events</a></li>
            <li><a href="#path">path</a></li>
            <li><a href="#os">os</a></li>
            <li><a href="#fs">fs</a></li>
            <li><a href="#sys">sys</a></li>
            <li><a href="#process">process</a></li>
            <li><a href="#module">module</a></li>
            <li><a href="#stream">stream</a></li>
            <li><a href="#tls">tls</a></li>
            <li><a href="#child_process">child_process</a></li>
            <li><a href="#cluster">cluster</a></li>
            <li><a href="#domain">domain</a></li>
          </ul>
        </li>
        <li><a href="#外部lib">外部lib</a>
          <ul>
            <li><a href="#url">url</a></li>
            <li><a href="#querystring">querystring</a></li>
            <li><a href="#crypto">crypto</a></li>
            <li><a href="#node-gyp">node-gyp</a></li>
            <li><a href="#util">util</a></li>
            <li><a href="#zlib">zlib</a></li>
          </ul>
        </li>
        <li><a href="#全局属性">全局属性</a></li>
      </ul>
    </li>
    <li><a href="#方案">方案</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












