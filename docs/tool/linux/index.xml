<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ukeate的笔记</title>
    <link>https://ukeate.com/docs/tool/linux/</link>
    <description>Recent content on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://ukeate.com/docs/tool/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LinuxProgram</title>
      <link>https://ukeate.com/docs/tool/linux/linux_program/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://ukeate.com/docs/tool/linux/linux_program/</guid>
      <description>&lt;h1 id=&#34;系统编程&#34;&gt;&#xA;  系统编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;进程通信&#34;&gt;&#xA;  进程通信&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;对象&#xA;    ipc&#xA;种类&#xA;    消息队列&#xA;    共享内存&#xA;    信号量&#xA;消息队列&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;错误处理&#34;&gt;&#xA;  错误处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;curedump机制, 产生core文件&#xA;命令&#xA;    ulimit&#xA;目录&#xA;    /proc/[pid]/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;fork&#34;&gt;&#xA;  fork&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#fork&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    子线程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;epoll&#34;&gt;&#xA;  epoll&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#epoll&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    多路复用io接口，提高大量并发连接中只有少量活跃情况下系统cpu利用率&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;signals&#34;&gt;&#xA;  signals&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#signals&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    unix系统中出错时显示的错误码（通常是拼在最后）&#xA;    http://people.cs.pitt.edu/~alanjawi/cs449/code/shell/UnixSignals.htm&#xA;SIGHUP&#x9;1&#x9;Exit&#x9;Hangup&#xA;SIGINT&#x9;2&#x9;Exit&#x9;Interrupt&#xA;SIGQUIT&#x9;3&#x9;Core&#x9;Quit&#xA;SIGILL&#x9;4&#x9;Core&#x9;Illegal Instruction&#xA;SIGTRAP&#x9;5&#x9;Core&#x9;Trace/Breakpoint Trap&#xA;SIGABRT&#x9;6&#x9;Core&#x9;Abort&#xA;SIGEMT&#x9;7&#x9;Core&#x9;Emulation Trap&#xA;SIGFPE&#x9;8&#x9;Core&#x9;Arithmetic Exception&#xA;SIGKILL&#x9;9&#x9;Exit&#x9;Killed&#xA;SIGBUS&#x9;10&#x9;Core&#x9;Bus Error&#xA;SIGSEGV&#x9;11&#x9;Core&#x9;Segmentation Fault&#xA;SIGSYS&#x9;12&#x9;Core&#x9;Bad System Call&#xA;SIGPIPE&#x9;13&#x9;Exit&#x9;Broken Pipe&#xA;SIGALRM&#x9;14&#x9;Exit&#x9;Alarm Clock&#xA;SIGTERM&#x9;15&#x9;Exit&#x9;Terminated&#xA;SIGUSR1&#x9;16&#x9;Exit&#x9;User Signal 1&#xA;SIGUSR2&#x9;17&#x9;Exit&#x9;User Signal 2&#xA;SIGCHLD&#x9;18&#x9;Ignore&#x9;Child Status&#xA;SIGPWR&#x9;19&#x9;Ignore&#x9;Power Fail/Restart&#xA;SIGWINCH&#x9;20&#x9;Ignore&#x9;Window Size Change&#xA;SIGURG&#x9;21&#x9;Ignore&#x9;Urgent Socket Condition&#xA;SIGPOLL&#x9;22&#x9;Ignore&#x9;Socket I/O Possible&#xA;SIGSTOP&#x9;23&#x9;Stop&#x9;Stopped (signal)&#xA;SIGTSTP&#x9;24&#x9;Stop&#x9;Stopped (user)&#xA;SIGCONT&#x9;25&#x9;Ignore&#x9;Continued&#xA;SIGTTIN&#x9;26&#x9;Stop&#x9;Stopped (tty input)&#xA;SIGTTOU&#x9;27&#x9;Stop&#x9;Stopped (tty output)&#xA;SIGVTALRM&#x9;28&#x9;Exit&#x9;Virtual Timer Expired&#xA;SIGPROF&#x9;29&#x9;Exit&#x9;Profiling Timer Expired&#xA;SIGXCPU&#x9;30&#x9;Core&#x9;CPU time limit exceeded&#xA;SIGXFSZ&#x9;31&#x9;Core&#x9;File size limit exceeded&#xA;SIGWAITING&#x9;32&#x9;Ignore&#x9;All LWPs blocked&#xA;SIGLWP&#x9;33&#x9;Ignore&#x9;Virtual Interprocessor Interrupt for Threads Library&#xA;SIGAIO&#x9;34&#x9;Ignore&#x9;Asynchronous I/O&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pf-kernel&#34;&gt;&#xA;  pf-kernel&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pf-kernel&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    是linux kernel 的fork, pf代表post-factum, 是作者的nickname&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;libev&#34;&gt;&#xA;  libev&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#libev&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;libevent&#xA;    介绍&#xA;        是linux kernel 的fork, pf代表post-factum, 是作者的nickname&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>LinuxScene</title>
      <link>https://ukeate.com/docs/tool/linux/scene/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://ukeate.com/docs/tool/linux/scene/</guid>
      <description>&lt;h1 id=&#34;场景&#34;&gt;&#xA;  场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;路由&#34;&gt;&#xA;  路由&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b7%af%e7%94%b1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;查路由表&#xA;    ip ro&#xA;    route -n&#xA;改路由&#xA;    route del -net 192.168.0.0 netmask 255.255.255.0 gw 10.146.81.117&#xA;转发&#xA;    ip ro ad 192.168.0.0/24 via [主机ip]&#xA;    主机配置&#xA;        echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward&#xA;        # etc/sysctl.conf&#xA;            net.ipv4.ip_forward = 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;高并发&#34;&gt;&#xA;  高并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%ab%98%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;查看当前TCP连接的状态和对应的连接数量：&#xA;    netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;&#xA;        # TIME_WAIT占用端口会影响后继新连接&#xA;初步优化（提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN攻击。）&#xA;    /etc/sysctl.conf&#xA;        net.ipv4.tcp_syncookies = 1&#xA;            # 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；&#xA;        net.ipv4.tcp_tw_reuse = 1&#xA;            # 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；&#xA;        net.ipv4.tcp_tw_recycle = 1&#xA;            # 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；&#xA;        net.ipv4.tcp_fin_timeout = 30&#xA;            # 修改系統默认的 TIMEOUT 时间。&#xA;    sysctl -p       # 生效&#xA;大流量下的优化&#xA;    # 如果你的连接数本身就很多，我们可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力&#xA;    /etc/sysctl.conf&#xA;    net.ipv4.tcp_keepalive_time = 1200&#xA;        # 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。&#xA;    net.ipv4.ip_local_port_range = 10000 65000&#xA;        # 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）&#xA;    net.ipv4.tcp_max_syn_backlog = 8192&#xA;        # 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。&#xA;    net.ipv4.tcp_max_tw_buckets = 6000&#xA;        # 表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默 认为180000，改为6000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。&#xA;其它参数说明&#xA;    net.ipv4.tcp_max_syn_backlog = 65536&#xA;        # 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。&#xA;    net.core.netdev_max_backlog = 32768&#xA;        # 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。&#xA;    net.core.somaxconn = 32768&#xA;        # web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。&#xA;    net.core.wmem_default = 8388608&#xA;    net.core.rmem_default = 8388608&#xA;    net.core.rmem_max = 16777216           #最大socket读buffer,可参考的优化值:873200&#xA;    net.core.wmem_max = 16777216           #最大socket写buffer,可参考的优化值:873200&#xA;    net.ipv4.tcp_timestsmps = 0&#xA;        # 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。&#xA;    net.ipv4.tcp_synack_retries = 2&#xA;        # 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。&#xA;    net.ipv4.tcp_syn_retries = 2&#xA;        # 在内核放弃建立连接之前发送SYN包的数量。&#xA;    #net.ipv4.tcp_tw_len = 1&#xA;    net.ipv4.tcp_tw_reuse = 1&#xA;        # 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。&#xA;    net.ipv4.tcp_wmem = 8192 436600 873200&#xA;        # TCP写buffer,可参考的优化值: 8192 436600 873200&#xA;    net.ipv4.tcp_rmem  = 32768 436600 873200&#xA;        # TCP读buffer,可参考的优化值: 32768 436600 873200&#xA;    net.ipv4.tcp_mem = 94500000 91500000 92700000&#xA;        # net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。&#xA;        # net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。&#xA;        # net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。&#xA;        # 上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864&#xA;    net.ipv4.tcp_max_orphans = 3276800&#xA;        # 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。&#xA;        # 如果超过这个数字，连接将即刻被复位并打印出警告信息。&#xA;        # 这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，&#xA;        # 更应该增加这个值(如果增加了内存之后)。&#xA;    net.ipv4.tcp_fin_timeout = 30&#xA;        #如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。&#xA;&#xA;    sysctl -w fs.file-max=12000000&#xA;    sysctl -w fs.nr_open=11000000&#xA;&#xA;    /etc/security/limits.conf&#xA;        nofile=10000000         # 文件句柄数&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>LinuxTool</title>
      <link>https://ukeate.com/docs/tool/linux/linux_tool/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://ukeate.com/docs/tool/linux/linux_tool/</guid>
      <description>&lt;h1 id=&#34;辅助&#34;&gt;&#xA;  辅助&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%85%e5%8a%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;快捷键&#34;&gt;&#xA;  快捷键&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e6%8d%b7%e9%94%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ctrl alt f1/f2/...      # 终端切换&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;帮助&#34;&gt;&#xA;  帮助&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%ae%e5%8a%a9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;man&#xA;    -f                  # 简要介绍&#xA;    -k                  # 通配搜索&#xA;whatis                  # man -f&#xA;apropos                 # man -k&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;命令行&#34;&gt;&#xA;  命令行&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4%e8%a1%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;clear&#xA;pwd                     # 当前路径&#xA;bash&#xA;    -c                  # 执行命令字符串&#xA;    set -o              # 设置快捷键模式，默认emacs&#xA;&#xA;    快捷键&#xA;        &amp;lt;Tab&amp;gt; bash补全&#xA;        &amp;lt;C-c&amp;gt; 中断&#xA;        &amp;lt;C-d&amp;gt; eof&#xA;        &amp;lt;C-tab&amp;gt; ls&#xA;        &amp;lt;C-l&amp;gt; clean&#xA;        &amp;lt;C-a&amp;gt; 移到行首&#xA;        &amp;lt;C-e&amp;gt; 移到行尾&#xA;        &amp;lt;C-u&amp;gt; 删除到行首&#xA;        &amp;lt;C-k&amp;gt; 删除到行尾&#xA;        &amp;lt;C-p&amp;gt; 上一个命令&#xA;        &amp;lt;C-n&amp;gt; 下一个命令&#xA;        &amp;lt;C-r&amp;gt; 查看历史      # &amp;lt;C-s&amp;gt; 向前查看历史&#xA;        &amp;lt;C-s&amp;gt; 冻结&#xA;        &amp;lt;C-q&amp;gt; 解冻&#xA;        &amp;lt;C-t&amp;gt; 交换字符&#xA;        &amp;lt;C-w&amp;gt; 删word&#xA;        &amp;lt;C-z&amp;gt; 暂停到后台&#xA;        &amp;lt;C-\&amp;gt; 中断&#xA;        &amp;lt;C-/&amp;gt; 撤消&#xA;        &amp;lt;C-_&amp;gt; 删除一行&#xA;        &amp;lt;M-r&amp;gt; 取消历史变更&#xA;    场景&#xA;        禁用&amp;lt;C-s&amp;gt;&amp;lt;C-q&amp;gt;, 以使&amp;lt;C-s&amp;gt;变为向前查看历史&#xA;            stty -ixon -ixoff&#xA;            stty STOP ^w            # 把原&amp;lt;C-s&amp;gt;改成&amp;lt;C-w&amp;gt;&#xA;zsh&#xA;fish&#xA;tmux&#xA;    session&#xA;    window&#xA;    pane&#xA;    ~/.tmux.conf&#xA;&#xA;    快捷键prefix &amp;lt;C-b&amp;gt;&#xA;&#xA;    系统&#xA;        prefix&#xA;            ?        # 帮助&#xA;            :        # 命令模式&#xA;            [        # 复制模式&#xA;        tmux&#xA;            kill-server&#xA;            source a&#xA;    session&#xA;        prefix&#xA;            d        # 脱离&#xA;            D        # 选择脱离&#xA;            r        # 重绘&#xA;            s        # 选择&#xA;            ~        # 信息历史&#xA;&#xA;        tmux&#xA;            ls&#xA;            attach a&#xA;                # 返回session&#xA;                -t name&#xA;            rename-session a&#xA;            switch -t a&#xA;    window&#xA;        prefix&#xA;            c        # 新建&#xA;            &amp;amp;        # 关闭&#xA;            ,        # 命名&#xA;            .        # 编号&#xA;            w        # 选择&#xA;            [0-9]        # 切换&#xA;            n        # 向后切换&#xA;            p        # 向前切换&#xA;            l        # 置换&#xA;            f        # 所有window查找&#xA;    pane&#xA;        prefix&#xA;            &amp;quot;            # 横分&#xA;            %            # 竖分&#xA;            x            # 关闭&#xA;            !            # 移到新window&#xA;            方向          # 切换&#xA;            o            # 切换到下一个&#xA;            &amp;lt;C-o&amp;gt;        # 向下旋转&#xA;            &amp;lt;M-o&amp;gt;        # 向上旋转&#xA;            {            # 向前置换&#xA;            }            # 向后转换&#xA;            &amp;lt;C-方向&amp;gt;      # 调整size&#xA;            &amp;lt;M-方向&amp;gt;      # 5倍调整size&#xA;            空格          # 切换布局&#xA;            &amp;lt;M-[0-5]&amp;gt;    # 选择布局&#xA;            q            # 显示编号&#xA;&#xA;    内置命令&#xA;        source-file a&#xA;screen&#xA;    -ls                 # 查看所有session&#xA;    -r                  # 进入id&#xA;echo&#xA;watch -n 1 -d netstat  -ant         # 监视&#xA;forturn                 # 随机名言&#xA;toilet                  # 彩虹字&#xA;cowsay                  # 牛说&#xA;source                  # 当前shell执行&#xA;figlet                  # 大写字&#xA;sl                      # 火车&#xA;cal 9 1752              # 打印日历&#xA;date +%Y/%m/%d/%H:%M&#xA;bc&#xA;maxima                  # 符号计算&#xA;factor                  # 分解质因数&#xA;expect                  # 为运行的脚本预填表单&#xA;    o-&amp;gt; 结束&#xA;    #!/usr/bin/expect&#xA;&#xA;    spawn ssh outrun@192.168.1.103&#xA;    expect &amp;quot;*password&amp;quot;&#xA;    send &amp;quot;asdf\n&amp;quot;&#xA;    expect eof&#xA;&#xA;    o-&amp;gt; 交互&#xA;    #!/usr/bin/expect -f&#xA;    spawn sudo /usr/local/mysql/bin/mysqld_safe --user=mysql&#xA;    expect &amp;quot;*password:*&amp;quot;&#xA;    send -- &amp;quot;asdf&amp;quot;&#xA;    send -- &amp;quot;\n&amp;quot;&#xA;&#xA;    interact            # interact留下交互, exit退出&#xA;&#xA;    o-&amp;gt; 后台执行        # 不要expect eof&#xA;    if [fork]!=0 exit&#xA;    disconnect&#xA;script/scriptreply      # 终端录制&#xA;    script -t 2&amp;gt;timing.log -a output.log&#xA;    scriptreply timing.log output.log&#xA;jobs                    # 后台作业&#xA;fg                      # 后台作业调度到前台&#xA;bg                      # 继续执行后台作业&#xA;nohup&#xA;    nohup *** &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;文字处理&#34;&gt;&#xA;  文字处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e5%ad%97%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uniq                    # 删除重复列&#xA;cat file1 file2         # 上下拼接&#xA;paste file1 file2       # 左右拼接&#xA;    -d &#39;-&#39;              # 加分隔符&#xA;tac                     # 倒转行显示&#xA;wc                      # 统计行, 单词, 字符&#xA;grep&#xA;    -v grep         # 过滤掉grep&#xA;    常用&#xA;        grep -nr --exclude-dir={.git, res, bin} &#39;a&#39; .&#xA;            # 递归查找&#xA;xargs&#xA;    -d &amp;quot;\t&amp;quot;         # 定义分隔符&#xA;    -t              # -t打印执行的命令&#xA;    -L 1            # 1行执行一次&#xA;    -n 1            # 一次使用1项&#xA;    -I arg1 sh -c &#39;echo arg1; mkdir arg1&#39;       &#xA;        # 执行多命令&#xA;    --max-procs 0   # 并行执行，不限数量&#xA;    常用&#xA;        代码行数&#xA;            find -name &amp;quot;*.go&amp;quot; -or -name &amp;quot;*.py&amp;quot; |xargs grep -v &amp;quot;^$&amp;quot; |wc -l&#xA;        复制最近修改的文件&#xA;            ls -rt | tail -4 | xargs -i cp -r {} ~/sdb/work/ryxWork/架构/&#xA;awk&#xA;    awk &#39;{print $1}&#39;&#xA;    awk &#39;{cmd=&amp;quot;kubectl delete pvc &amp;quot;$1;system(cmd)}&#39;&#xA;        # 按行执行命令&#xA;sed&#xA;    sed -i &#39;1i\new line&#39;&#xA;        # 第一行前插入&#xA;    常用&#xA;        替换文本&#xA;            sed -i &amp;quot;s/a/b/g&amp;quot; `grep -rl &amp;quot;a&amp;quot; ./`&#xA;sort&#xA;    -r                  # reverse&#xA;    -n                  # 显示行号&#xA;more&#xA;less&#xA;iconv&#xA;    -l                  # 列出已知的编码&#xA;    -f gbk -t utf-8 -c orig.txt -o tgt.txt      # 转码&#xA;head -2&#xA;tail -2&#xA;    -f&#xA;paste file1 file2       # 合并两个文件或两栏内容&#xA;    -d &#39;+&#39;              # 分隔符&#xA;nano&#xA;strings                 # 打印可打印字符&#xA;jq . a.json             # 验证json格式&#xA;pv -qL 10               # 文件缓慢显示&#xA;aview                   # 图片文件化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;媒体处理&#34;&gt;&#xA;  媒体处理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%aa%92%e4%bd%93%e5%a4%84%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;convert                 # 转换图片&#xA;    convert a.jpg a.png # 转格式&#xA;&#xA;    -resize 1024x768&#xA;        convert -resize a.jpg a1.jpg&#xA;    -sample 50%x50%     # 缩略图&#xA;    -rotate 270         # 顺时针旋转270度&#xA;    -flip               # 左右翻转&#xA;    -paint 4            # 旋转角度&#xA;&#xA;    -draw               # 加文字&#xA;        convert -fill black -pointsize 60 -font helvetica -draw &#39;text 10,80 &amp;quot;A&amp;quot; ‘  a.jpg  a1.jpg&#xA;            # 用黑色, 60磅, helvetica字体, 在位置10,80 写A&#xA;    -raise 5x5          # 右下增加&#xA;    +raise 5x5          # 左上增加&#xA;    -bordercolor red -border 5x5                # 红色边框&#xA;    -mattecolor black -frame 5x5                # 黑色边框&#xA;&#xA;    -noise 3            # 油画&#xA;    -monochrome         # 噪声&#xA;    -blur 80            # 高斯模糊&#xA;    -flop               # 底片&#xA;    -negate             # 黑白&#xA;    -charcoal 2         # 炭笔&#xA;    -spread 30          # 漩涡&#xA;    -swirl 67           # 凸起&#xA;ffmpeg&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;系统&#34;&gt;&#xA;  系统&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;启动与任务&#34;&gt;&#xA;  启动与任务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%af%e5%8a%a8%e4%b8%8e%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;grub&#xA;    /etc/default/grub       # 设置文件&#xA;    grub2-mkconfig -o /boot/grub2/grub.cfg      # 使设置生效，update-grub 是debian下做的包装&#xA;upstart                     # 状态 waiting, starting, pre-start, spawned, post-start,running,pre-stop, stopping, killed, post-stop&#xA;systemv&#xA;systemd&#xA;systemctl&#xA;    status&#xA;    daemon-reload           # 修改service文件后重载&#xA;    systemctl list-units                        # list known units&#xA;    systemctl list-unit-files                   # 已知的services&#xA;    systemctl list-sockets                      # list socket units ordered by the listening address&#xA;    systemctl enable NAME                       # 设置开机启动, 生成service脚本命令&#xA;    systemctl disable NAME&#xA;    systemctl start NAME&#xA;    systemctl stop NAME&#xA;    systemctl restart NAME&#xA;    systemctl reload NAME&#xA;service&#xA;    service start&#xA;    service restart&#xA;    service stop&#xA;    service status&#xA;    service --status-all&#xA;chkconfig iptables on/off   # 设置服务启动&#xA;    --level 2345 iptables off                   # 查看各level服务状态&#xA;    --list iptables&#xA;at                      # 某时间运行一次&#xA;osmo                    # 计划任务软件&#xA;reap                    # 用于定时删除目录中文件，并打印日志&#xA;    -h                  # 打印帮助信息&#xA;    -t                  # 后台运行, 并设置时间间隔&#xA;    -s                  # single 单次运行&#xA;cron&#xA;    介绍&#xA;        crond服务在systemd中被timer取代&#xA;&#xA;    使用&#xA;        $ service crond start&#xA;        $ service crond stop&#xA;        $ service crond restart&#xA;        $ service crond reload                      # 重载配置&#xA;        $ crontab crontest.cron                     # 添加定时任务。打印的文件在用户根目录下&#xA;        $ crontab -l                                # 列出用户目前的crontab&#xA;        $ crontab -u                                # 设定某个用户的cron服务&#xA;        $ crontab -r                                # 删除某个用户的cron服务&#xA;        $ crontab -e                                # 编辑某个用户的cron服务&#xA;            # crontab -u root -l   查看root的设置&#xA;&#xA;        /etc/crontab                                # 系统配置文件&#xA;        /etc/cron.hourly&#xA;        /etc/cron.daily&#xA;        /etc/cron.weekly&#xA;        /etc/cron.monthly                           # 每小时、天、周、月执行的脚本&#xA;&#xA;        定时格式&#xA;            M H D m d cmd&#xA;                M: 分钟（0-59）每分钟用*或者 */1表示&#xA;                H: 小时（0-23）&#xA;                D: 天（1-31）&#xA;                m: 月（1-12）&#xA;                d: 一星期内的天（0~6，0为星期天）&#xA;                cmd: 如 ~/a.sh&#xA;    例子&#xA;        crontest.cron文件中&#xA;            15,30,45,59 * * * * echo &amp;quot;aa..........&amp;quot; &amp;gt;&amp;gt; aa.txt&#xA;                # 每15分钟执行一次打印&#xA;        0 */2 * * * date                            # 每两个小时&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;日志&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;dmesg                   # 启动日志&#xA;rsyslog                 # 日志管理, syslog的实现, 在systemd中被systemd-journal取代&#xA;mcelog                  # machine check exception log&#xA;journalctl              # 日志查看&#xA;    -x                  # 显示解释&#xA;    -e                  # 显示到底部&#xA;    -u                  # 指定unit名, 如kubelet&#xA;    --no-pager          # 不输出到管道来分页&#xA;    -f                  # 追加显示&#xA;    -q                  # 只显示warn以上信息&#xA;    --user-unit         # 指定用户&#xA;    --since &amp;quot;2018-03-26&amp;quot; &#xA;    --until &amp;quot;2018-03-26 03:00&amp;quot;&#xA;    场景&#xA;        journalctl -f --user-unit onedrive&#xA;        journalctl -xefu kubelet --no-pager&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;电源&#34;&gt;&#xA;  电源&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%b5%e6%ba%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;poweroff                # 立即关机&#xA;shutdown -h now&#xA;    -h                  # 关机&#xA;    -r                  # 重启&#xA;pm-suspend              # 挂起电脑&#xA;halt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;用户&#34;&gt;&#xA;  用户&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%a8%e6%88%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;w                       # 在线用户名, 终端号, 登录时间, 空闲时间, 终端连接所有进程时间, 当前进程时间, 当前命令&#xA;id outrun               # 用户信息&#xA;su&#xA;    常用&#xA;        切换登录&#xA;            sudo -i su outrun&#xA;sudo&#xA;id                      # 用户信息, 所在组&#xA;passwd                  # 修改密码&#xA;useradd outrun          # 创建用户&#xA;    -g outrun           # 指定组&#xA;    -r                  # 是系统用户&#xA;    -d /home/outrun     # 指定登录目录&#xA;    -u 544              # 指定id&#xA;userdel -r user1        # 完全删除用户&#xA;groups user1            # 查看组&#xA;groupadd ftp            # 创建组&#xA;usermod                 # 修改用户状态&#xA;    -a -G root outrun   # 加入组&#xA;    -l newuser user1    # 改名&#xA;    -L user1            # 锁定&#xA;    -U user1            # 解锁&#xA;    -d /home/ftp ftp    # 改登录目录&#xA;        -u 123 outrun       # 修改id&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内核&#34;&gt;&#xA;  内核&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e6%a0%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uname -a                # 查看版本&#xA;modprobe vboxdrv                    # 内核&#xA;lsmod                               # 显示当前系统加载的模块，如systemctl中start了的模块&#xA;dkms&#xA;    status&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;env                     # 查看所有环境变量&#xA;envsubst                # 编译文件中环境变量&#xA;    envsubst &#39;${THREAD_NUM}&#39; &amp;lt; decoder.conf.template &amp;gt; decoder.conf&#xA;getent                  # 查看系统数据库中数据&#xA;    group docker        # 查看docker用户组&#xA;ulimit -s unlimited     # 限制shell启动资源, 不限制堆栈大小&#xA;    -a 显示各种限制&#xA;    -u 10000 最大用户数&#xA;    -n 102400 文件句柄数&#xA;    -d unlimited 数据段长度&#xA;    -m unlimited 内存大小&#xA;    -t unlimited cpu时间&#xA;    -v unlimited 虚拟内存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;系统设备&#34;&gt;&#xA;  系统设备&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e8%ae%be%e5%a4%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;接口查看&#34;&gt;&#xA;  接口查看&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3%e6%9f%a5%e7%9c%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;lspci&#xA;lsusb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;显示器&#34;&gt;&#xA;  显示器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%be%e7%a4%ba%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;xrandr&#xA;    # 多显示器布局&#xA;    -q                         # 列出所有屏幕&#xA;    --verbose                   # 列出所有屏幕详情&#xA;    --output eDP1               # 指定屏幕&#xA;    --off                       # 禁用屏幕&#xA;    --primary                   # 指定主显示器&#xA;    --mode                      # 分辨率&#xA;    --pos                       # 指定屏幕在背景板的位置, 根据各屏幕分辨率、位置算&#xA;    --rotate                    # 旋转屏幕&#xA;        normal&#xA;        left&#xA;        right&#xA;        inverted&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;声卡&#34;&gt;&#xA;  声卡&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a3%b0%e5%8d%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;amixer set Master 100%  # 调节音量&#xA;alsamixer               # 调节声音&#xA;alsactl                 # 设置alsamixer&#xA;    store                      # 保存&#xA;    restore                    # 加载&#xA;aplay -l&#xA;    /etc/asound.conf&#xA;        defaults.pcm.card 1&#xA;        defaults.pcm.device 1&#xA;        defaults.ctl.card 1&#xA;pactl&#xA;    场景&#xA;        默认声卡&#xA;            pactl list short sources&#xA;            pactl list short sinks&#xA;            pactl set-default-source alsa_input.pci-0000_00_1b.0.analog-stereo&#xA;            pactl set-default-sink alsa_output.pci-0000_00_1b.0.analog-stereo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;系统监控&#34;&gt;&#xA;  系统监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;综合监控&#34;&gt;&#xA;  综合监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%bc%e5%90%88%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;uptime                  # 当前时间, 运行时间, 用户数, 系统负载&#xA;tload                   # 系统负载图(用字符画)&#xA;top&#xA;    top -d 1 -p pid [,pid ...]&#xA;htop&#xA;    按键&#xA;        h               # 帮助&#xA;atop&#xA;btop&#xA;nmon&#xA;glances&#xA;netdata&#xA;vmstat                  # 获得有关进程、swap、内存、cpu等系统信息&#xA;dstat                   # 定时收集系统信息&#xA;sar                     # 全面的系统活动情况&#xA;    -u 3 5              # 查CPU负载, 3秒一次共5次 &#xA;    -d                  # 磁盘&#xA;    -r                  # 内存&#xA;    -W                  # SWAP&#xA;    -n DEV              # 网络接口&#xA;    -n SOCK             # socket连接信息&#xA;    -n TCP              # TCP连接&#xA;    -b                  # I/O速率&#xA;    -q                  # 平均负载&#xA;lxtask                  # GUI监控CPU、内存&#xA;sysdig&#xA;    sysdig&#xA;        -c&#xA;            topprocs_cpu            # 进程cpu top&#xA;                evt.cpu=0           # 只统计cpu0&#xA;            topprocs_net            # 进程带宽 top&#xA;            topprocs_file           # 进程硬盘i/o top&#xA;            topfiles_bytes          # 文件读写 top&#xA;                proc.name=httpd     # 指定进程名&#xA;            topfiles_time           # 文件时间 top&#xA;            topprocs_errors         # 进程error top&#xA;            topfiles_errors         # 文件error top&#xA;            topscalls_time          # 系统调用时间 top&#xA;            topscalls &amp;quot;evt.failed=true&amp;quot;                 # 系统调用出错 top&#xA;            topconns                # 网络连接 top&#xA;            fdcount_by&#xA;                proc.name &amp;quot;fd.type=file&amp;quot;                # 进程文件描述符&#xA;            fdbytes_by&#xA;                fd.directory &amp;quot;fd.type=file&amp;quot;             # 目录读写 top&#xA;                fd.filename &amp;quot;fd.directory=/tmp/&amp;quot;        # /tmp目录文件 读写top&#xA;                fd.type             # fd type i/o&#xA;            echo_fds &amp;quot;fd.filename=passwd&amp;quot;               # 所有名为passwd文件的i/o&#xA;            stdout&#xA;                proc.name=bash      # 进程标准输出&#xA;            fileslower 1            # 文件i/o 大于1ms&#xA;            spy_users               # 命令执行情况&#xA;&#xA;        -A                          # 只显示可读数据&#xA;        -s 4096                     # 指定 data buffer 字节&#xA;        -r trace.scap               #  指定trace file&#xA;        -pc                         # 详情&#xA;    csysdig                         # 交互式工具&#xA;        -vcontainers                # 容器资源&#xA;        -pc                         # 详情&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;slabtop                 # 内核片缓存信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  CPU&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;powertop                # intel开发，找到高功率进程&#xA;mpstat                  # cpu统计信息&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;进程&#34;&gt;&#xA;  进程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pidstat -p 434  # 进程使用资源的情况&#xA;    -u 1        # CPU&#xA;    -r 1        # 内存&#xA;    -d 1        # 磁盘&#xA;    -w          # 上下文切换&#xA;ps&#xA;    aux                 # 用在unix style中, BSD格式显示&#xA;    ef                  # 用在system v style中, 标准格式显示&#xA;pstree                  # 进程关系&#xA;pwdx [pid]              # 查看进程工作目录&#xA;    ll /proc/[pid]/cwd&#xA;pmap [pid]              # 进程&#xA;&#xA;kill 1024&#xA;    -9&#xA;        # 3 QUIT 退出(同ctrl + \)&#xA;        # 1 HUP 终端断线&#xA;        # 2 INT 中断(同ctrl + c)&#xA;        # 9 KILL 强制终止&#xA;        # 15 TERM 终止&#xA;        # 18 CONT 继续(与STOP相反, 同fg/bg)&#xA;        # 19 STOP 暂停(同ctrl + z)&#xA;    -l                  # 列出所有信号名称和编号&#xA;    常用&#xA;        删除名字的进程&#xA;            ps -ef|grep -v &amp;quot;grep&amp;quot;|grep aurora/app.js |awk &#39;{print $2}&#39;| xargs kill -9&#xA;pkill Xorg              # kill 所有包含&#xA;killall Xorg            # kill 所有包含&#xA;xkill                   # 运行后 在xwindow点击kill窗口&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;网络&#34;&gt;&#xA;  网络&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;配置-1&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;hostname&#xA;nmtui                   # 设置网卡&#xA;nmcli                       # 设置网络连接&#xA;    sudo nmcli c mod &#39;Wired connection 1&#39; ipv4.never-default false&#xA;        # 解决manual ip不能设置路由的问题&#xA;wpa_supplicant&#xA;iwlist                  # 列出无线网&#xA;iwconfig                # 无线网卡设置&#xA;wifi-menu&#xA;pppoe                   # 宽带&#xA;ifconfig&#xA;    打开, 关闭网卡&#xA;        ifconfig eth0 up&#xA;        ifconfig eth0 down&#xA;    临时修改ip&#xA;        ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up&#xA;            # up表示立即激活&#xA;    临时mac&#xA;        ifconfig enp0s20u6u3 hw ether 00:50:56:c0:00:02&#xA;    虚拟网卡&#xA;        ifconfig wlp7s0:1 ip netmask&#xA;            # 共用一个ip&#xA;netctl                  # 配置网卡服务&#xA;route                   &#xA;    -n                  # 查看路由表 &#xA;    //添加到主机的路由&#xA;    route add –host 192.168.168.110 dev eth0&#xA;    route add –host 192.168.168.119 gw 192.168.168.1&#xA;    //添加到网络的路由&#xA;    route add –net IP netmask MASK eth0&#xA;    route add –net IP netmask MASK gw IP&#xA;    route add –net IP/24 eth1&#xA;    //添加默认网关&#xA;    route add default gw IP&#xA;    //删除路由&#xA;    route del –host 192.168.168.110 dev eth0&#xA;arp -n                  # 显示局域网 ip mac表&#xA;    -s ip mac           # 设置ip mac表&#xA;ip                      # 网卡与ip信息&#xA;    添加路由&#xA;        ip route add 10.146.81.0/24 via 10.146.81.29&#xA;    配置ip段互斥的宿主机转发&#xA;        服务器&#xA;            ip link set up dev tun0&#xA;            sysctl net.ipv4.ip_forward=1&#xA;            /etc/sysctl.d/30-ipforward.conf&#xA;                net.ipv4.ip_forward=1&#xA;                net.ipv6.conf.default.forwarding=1&#xA;                net.ipv6.conf.all.forwarding=1&#xA;        客户端&#xA;            ip addr add 192.168.123.201/24 dev eth0             # 要转发的网段&#xA;            ip link set up dev eth0&#xA;            ip route add default via 192.168.123.100 dev eth0   # 服务器ip&#xA;hostapd                 # 无线热点&#xA;    yum install hostapd&#xA;    vi /etc/hostapd/hostapd.conf&#xA;        wpa_passphrase=asdfasdf&#xA;        ssid=myflowers&#xA;        interface=p3p1&#xA;&#xA;    yum install dhcp&#xA;    vi /etc/dhcp/dhcpd.conf&#xA;        option domain-name-servers 192.168.0.1,8.8.8.8;         # 自己的dns提供商&#xA;        option routers 192.168.0.42;    # 本机ip&#xA;        option domain-name &amp;quot;mydhcp&amp;quot;;&#xA;        option domain-name-servers 192.168.0.1;&#xA;        log-facility local7;&#xA;        subnet 192.168.0.0 netmask 255.255.255.0 {&#xA;            range  192.168.0.160 192.168.0.170;&#xA;            option broadcast-address 192.168.0.255;&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;测试工具&#34;&gt;&#xA;  测试工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ab                      # 压测&#xA;    ab -c 10 -n 100 https://www.baidu.com/&#xA;        # 10并发100次, url结尾要有/&#xA;mtr                     # myTrace, 合并ping与traceroute，默认发送ICMP包, 做持续探测, 避免节点波动的影响&#xA;traceroute              # 做一次探测, 默认UDP包, 发包TTL值逐渐增大&#xA;    -I                  # 使用ICMP包&#xA;ping&#xA;telnet&#xA;nslookup                    # 查域名ip&#xA;dig                     # 域名解析&#xA;nmblookup -A ip             # 查ip域名&#xA;nmap&#xA;    -sP ip/24           # 查看网内所有ip&#xA;    -p1-65535           # 扫描所有端口&#xA;    常用&#xA;        nmap 192.168.100.1/24 -p1-65535&#xA;nc                      # netcat, 功能全面&#xA;    -U a.sock           # 指定socket&#xA;    -v                  # 显示详情&#xA;    -z                  # 只测试连通&#xA;    -u                  # 使用udp&#xA;&#xA;    o-&amp;gt; 测试udp端口&#xA;    nc -vzu 127.0.0.1 1194&#xA;    o-&amp;gt; 文件传输&#xA;    nc -l -p 9999 | tar xf -&#xA;    tar cf - $(find . -name &amp;quot;*&amp;quot;) | nc -v 10.99.11.44 9999&#xA;rinetd                  # TCP端口转发&#xA;    rinetd.conf&#xA;        0.0.0.0 80 192.168.1.2 80    &#xA;    rinetd -c /etc/rinetd.conf&#xA;simplehttp&#xA;    python -m SimpleHTTPServer 8080&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;请求工具&#34;&gt;&#xA;  请求工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%b7%e6%b1%82%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;curl&#xA;    curl -v             # 详细头信息&#xA;    curl -H &amp;quot;Cookie: foo=bar; baz=val&amp;quot;          # 发送cookie&#xA;    curl -X post -k http://localhost:9090/a -H &amp;quot;Content-Type: text/plain&amp;quot; -d &#39;{&amp;quot;name&amp;quot;: &amp;quot;a&amp;quot;}&#39;&#xA;        # post请求&#xA;    curl -O http://104.223.142.166/isu80        # 抓文件&#xA;wget&#xA;    -i filelist.txt         # 下载一个文件中的所有url&#xA;    -x  # 强制创建目录&#xA;    -P  # 目录prefix&#xA;    -r  # 递归下载&#xA;    -l  # 最大递归深度, inf或0代表无限制&#xA;    -k  # 修改链接，指向本地文件&#xA;    -p  # 下载所有用于显示页面的资源, 如图片&#xA;    -L  # 只跟踪relative链接&#xA;    -N  # 只获取比本地新的文件&#xA;    -np # 不追踪父目录&#xA;    -m  # 缩写-N -r -l inf --no-remove-listing&#xA;    --no-remove-listing         # 不删除listing文件&#xA;&#xA;    常用&#xA;        爬网站&#xA;            wget -x -P curSite -r -l 100 -k -L -np http://nodeapi.ucdok.com/api/&#xA;            带cookie&#xA;                wget --post-data=&amp;quot;username=u1&amp;amp;password=asdf&amp;quot; --save-cookies=cookie --keep-session-cookies &amp;quot;http://www.abc.com/logging.php&amp;quot;&#xA;                wget -x -P curSite -r -l 1 -k -L -np --load-cookies=cookie --keep-session-cookies &amp;quot;https://www.abc.com/display/1&amp;quot;&#xA;ssh&#xA;    ssh 10.1.10.2 -L 9901:localhost:5901&#xA;        # 用ssh建tunnel访问内部端口&#xA;    ssh -t -L 5900:localhost:5900 remote_host &#39;x11vnc -localhost -display :0&#39;&#xA;        # 本机执行命令并端口映射&#xA;sshpass&#xA;    sshpass -p asdf ssh root@47.74.230.238&#xA;sshfs -o allow_other root@ip:~ /mnt                 # 挂载远程目录&#xA;scp a.txt root@ip:~&#xA;w3m                     # 命令行浏览器&#xA;vnc                     # 远程桌面&#xA;    Virtual Network Computing&#xA;    相关文章&#xA;        linux 自带远程桌面--VNC服务配置说明&#xA;    安装&#xA;        yum install vnc*&#xA;&#xA;        yum install *vnc-server*&#xA;    启动&#xA;        vncserver :1&#xA;    登录&#xA;        vncviewer        # fedora 下gnome自带的vncviewer名为:Remote Desktop Viewer&#xA;            输入192.168.0.62:1                      # 实际端口号为5901, 如果服务号为2则为5902&#xA;        或者浏览器java-plugin&#xA;            localhost:5801                          # 需要安装java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;监控&#34;&gt;&#xA;  监控&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e6%8e%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;iftop -n                # 流量监控&#xA;ntop                    # 流量监控, web界面&#xA;    # localhost:3000&#xA;    -W 3001&#xA;                        # Loss%丢包率, Snt每秒包数, Last最近一次延迟, Avg平均值, Best最小值, Worst最大值, StDev标准差&#xA;    -u                  # 使用udp包&#xA;    --no-dns            # 不对ip做域名反解析&#xA;    -4                  # 只用ipv4&#xA;    -6                  # 只用ipv6&#xA;    结果&#xA;        1,2,3,4 本地网络&#xA;        5,6 运营商骨干网络&#xA;        7,8,9,10 目标服务器本地网络&#xA;            8 链路负载均衡&#xA;tcpdump&#xA;    -v                          # verbose输出&#xA;    -vvv            # 最详细输出&#xA;    -n                          # 网络地址显示数字&#xA;    -nn                         # ip和端口显示&#xA;    -i                          # 指定网卡&#xA;    -c 100                      # 100条后退出&#xA;    -w file1                    # 保存到文件&#xA;    -r file1 tcp                # 从文件读取，指定tcp协议&#xA;    -G 5 -w /opt/capfile-%Y_%m%d_%H%M_%S        # 滚动日志&#xA;    greater 200                 # 报文字节大于200&#xA;    host 192.168.0.1            # 包含ip&#xA;    port 80                     # 包含端口&#xA;    port !80&#xA;    dst host 192.168.0.1        # 目标ip&#xA;    dst port 80                 # 目标端口&#xA;    src host&#xA;    src port&#xA;    net 192.168.0.1/32          # 包含网段&#xA;    udp/tcp/icmp/igmp/arp       # 指定协议&#xA;    ip                          # ip协议&#xA;    ip proto ospf               # 类型为ospf的ip包&#xA;    ip[9]=6                     # ip包头第10字节为6（tcp协议）&#xA;    ether multicast                             # 二层类型为多播&#xA;    ether src host 00:0c:29:9a:1f:4e            # 二层mac&#xA;    常用&#xA;        tcpdump -i eth0 -vnn \(src host 8.8.8.8 and port 80 \) or \(src host 10.10.10.10 and dst port 443\)&#xA;        tcpdump -n tcp port 8383 -i lo and src host 183.14.132.117&#xA;iotop                   # 实时监视io&#xA;    p                   # 显示pid&#xA;    o                   # 只显示活跃&#xA;iostat                  # 负载情况&#xA;lsof -i:8080            # 列出当前系统打开的文件，必须root运行才准确&#xA;    -i                  # 端口&#xA;    -P                  # 显示端口号而非名称&#xA;    -n                  # 显示ip而非域名&#xA;    -i -n -P            # 查看进程句柄数&#xA;nicstat                 # 网络流量统计&#xA;netstat&#xA;    -a                  # 显示所有&#xA;    -n                  # 显示数字，而不是别名&#xA;    -t                  # 仅显示tcp&#xA;    -u                  # 仅显示udp&#xA;    -p                  # 显示建立链接的程序名&#xA;    -l                  # 仅列出listen的服务&#xA;    -o                  # 显示timer, 如keepalive&#xA;    -antpu              # 端口&#xA;tapestat                # 磁带驱动器信息&#xA;ss                      # 端口，性能高&#xA;    -l                  # listening&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;防火墙&#34;&gt;&#xA;  防火墙&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e7%81%ab%e5%a2%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;getenforce              # 查看selinux状态&#xA;sestatus -v             # 查看selinux状态&#xA;setenforce 0            # 临时关闭selinux&#xA;    1                   # 启用&#xA;ufw                     # ubuntu, 简化防火墙&#xA;iptables [-t 表] -命令 匹配 操作&#xA;    参数&#xA;        -t                  # 要操作的匹配表&#xA;        命令&#xA;            -P                  # 策略, INPUT等&#xA;            -A                  # append, 添加&#xA;            -I 1                # 在第2条前添加&#xA;            -D 1                # delete, 删除&#xA;            -R 1                # 替换&#xA;&#xA;            -L                  # list 显示&#xA;            -n                  # 端口以数字显示&#xA;            -v                  # verbose, 显示更多信息&#xA;            -F                  # flush&#xA;            -X                  # 清除自定chain&#xA;            -Z                  # 清除统计数&#xA;        规则&#xA;            -p                  # 协议&#xA;            -i                  # 指定网卡流入&#xA;            -o                  # 指定网卡流出&#xA;            -s                  # 来源ip, !表示排除&#xA;            -d                  # 目标ip&#xA;            --sport             # 源端口&#xA;            --dport             # 目标端口&#xA;            -m                  # 使用模块, 会根据-p选择模块&#xA;        动作&#xA;            -j                  # 跳转&#xA;                ACCEPT&#xA;    四表(table)&#xA;        raw             # 跟踪&#xA;        mangle          # 标记&#xA;        nat             # 修改ip、port&#xA;        filter          # 过滤, 默认&#xA;    五链(chain)&#xA;        PREROUTING&#xA;        FORWORD         # INPUT前转发到POSTROUTING&#xA;        INPUT&#xA;        OUTPUT&#xA;        POSTROUTING &#xA;    策略(policy)&#xA;        ACCEPT          # 通过&#xA;        REJECT          # 拒绝，返回数据&#xA;            返回数据包&#xA;                ICMP port-unreachable&#xA;                ICMP echo-reply&#xA;                tcp-reset&#xA;            iptables -A  INPUT -p TCP --dport 22 -j REJECT --reject-with ICMP echo-reply&#xA;        DROP            # 丢弃&#xA;        REDIRECT        # 导向端口(PNAT)&#xA;            iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT--to-ports 8081&#xA;        MASQUERADE      # 改写来源ip为本机ip, 可指定目标端口范围&#xA;            iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 21000-31000&#xA;        LOG             # 日志, 记在/var/log&#xA;            iptables -A INPUT -p tcp -j LOG --log-prefix &amp;quot;input packet&amp;quot;&#xA;        ULOG&#xA;        SNAT            # 改写源地址, 只适用POSTROUTING&#xA;            iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 192.168.10.15-192.168.10.160:2100-3200&#xA;        DNAT            # 改写目标地址, 只适用POSTROUTING&#xA;            iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination 192.168.10.1-192.168.10.10:80-100&#xA;        TOS&#xA;        MIRROR          # 对调源ip与目标ip后返回&#xA;        QUEUE           # 封包入队列待处理，实现功能如：计算联机费用&#xA;        RETURN          # 退出当前规则链, 返回主规则链&#xA;        TTL&#xA;        MARK            # 对包做标记数字&#xA;            iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 22&#xA;    规则(rule)          # 自定义的条件&#xA;    配置文件&#xA;        /etc/sysconfig/iptables&#xA;        /usr/libexec/iptables/iptables.init&#xA;            save&#xA;        rules.v4        # 自定义配置&#xA;            *filter&#xA;            :INPUT ACCEPT [186:19951]&#xA;            :FORWARD ACCEPT [0:0]&#xA;            :OUTPUT ACCEPT [71:11164]&#xA;            -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT&#xA;            -A INPUT -p tcp -m tcp --dport 23 -j ACCEPT&#xA;            -A INPUT -p tcp -m tcp --dport 24 -j ACCEPT&#xA;            COMMIT&#xA;    命令&#xA;        systemctl enable iptables.service&#xA;        service iptables save&#xA;        service iptables restart&#xA;        iptables-restore &amp;lt; rules.v4&#xA;            # 导入配置&#xA;    案例&#xA;        关iptables&#xA;            service iptables stop&#xA;            chkconfig iptables off&#xA;        查看&#xA;            iptables -L -n -v --line-numbers&#xA;        查nat表&#xA;            iptables -t nat -L&#xA;        flush, 生效&#xA;            iptables -F&#xA;        service命令&#xA;            service iptables save&#xA;            service iptables stop&#xA;            service iptables start&#xA;            service iptables restart&#xA;        开机启动&#xA;            /etc/network/if-pre-up.d/iptables&#xA;                iptables-restore &amp;lt; rules.v4&#xA;&#xA;        插入规则&#xA;            iptables -I INPUT 2 -s 202.54.1.2 -j DROP&#xA;        删除规则&#xA;            iptables -D INPUT 4&#xA;        开放所有input/output&#xA;            iptables -P INPUT ACCEPT&#xA;            iptables -P OUTPUT ACCEPT&#xA;        开放input/output tcp 22&#xA;            iptables -A INPUT -p tcp --dport 22 -j ACCEPT&#xA;            iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT&#xA;        vpn转发&#xA;            iptables -t nat -A POSTROUTING -s 192.168.252.0/24 -j SNAT --to-source 10.171.83.146&#xA;        屏蔽私有地址&#xA;            iptables -A INPUT -i eth1 -s 192.168.0.0/24 -j DROP&#xA;            iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP&#xA;        屏蔽ip&#xA;            iptables -A INPUT -s 1.2.3.4 -j DROP&#xA;            iptables -A INPUT -s 192.168.0.0/24 -j DROP&#xA;            iptables -A OUTPUT -d 192.168.1.0/24 -j DROP&#xA;            iptables -A OUTPUT -o eth1 -d 192.168.1.0/24 -j DROP&#xA;        屏蔽端口&#xA;            iptables -A INPUT -p tcp -s 1.2.3.4 --dport 80 -j DROP&#xA;            iptables -A INPUT -i eth1 -p tcp -s 192.168.1.0/24 --dport 80 -j DROP&#xA;        记录并屏蔽&#xA;            iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j LOG --log-prefix &amp;quot;IP_SPOOF A: &amp;quot;&#xA;            iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP&#xA;        mac屏蔽&#xA;            iptables -A INPUT -m mac --mac-source 00:0F:EA:91:04:08 -j DROP&#xA;            # *only accept traffic for TCP port # 8080 from mac 00:0F:EA:91:04:07 * ##&#xA;            iptables -A INPUT -p tcp --destination-port 22 -m mac --mac-source 00:0F:EA:91:04:07 -j ACCEPT&#xA;        屏蔽icmp&#xA;            iptables -A INPUT -p icmp --icmp-type echo-request -j DROP&#xA;            iptables -A INPUT -i eth1 -p icmp --icmp-type echo-request -j DROP&#xA;        开启范围端口&#xA;            iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 7000:7010 -j ACCEPT&#xA;        开启范围ip&#xA;            iptables -A INPUT -p tcp --destination-port 80 -m iprange --src-range 192.168.1.100-192.168.1.200 -j ACCEPT&#xA;        nat&#xA;            iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 123.4.5.100&#xA;                # 改写来自192.168.1.0/24的包, 源ip为123.4.5.100&#xA;            iptables -t nat -A PREROUTING -s 192.168.1.0/24 -i eth1 -j DNAT --to 123.4.5.100&#xA;                # 改写来自192.168.1.0/24的包, 目标ip为123.4.5.100&#xA;            iptables -t nat -A POSTROUTING -s 172.27.0.0/16 -d 10.0.0.1 -p tcp --dport 80 -j SNAT --to-source MASQUERADE&#xA;                # 改写来自172.27.0.0/16去向10.0.0.1:80的tcp包, 源ip为本机ip&#xA;            iptables -t nat -A PREROUTING -d 192.168.1.1 -p tcp --dport 80 -j DNAT --to-destination 10.0.0.1&#xA;                # 改写去向192.168.1.1:80的tcp包, 目标ip为10.0.0.1&#xA;&#xA;firewall&#xA;    systemctl start firewalld&#xA;&#xA;    o-&amp;gt; ftp&#xA;    firewall-cmd --zone=public --add-port=20/tcp --permanent&#xA;    firewall-cmd --zone=public --add-port=21/tcp --permanent&#xA;    firewall-cmd --permanent --add-port=1000-2000/tcp&#xA;    firewall-cmd --complete-reload&#xA;&#xA;    o-&amp;gt; 8080&#xA;    firewall-cmd --query-port=8080/tcp&#xA;        --add-port=8080/tcp --permanent --zone=public&#xA;        --reload&#xA;        --get_active-zones&#xA;        --list-all&#xA;        --set-default-zone=public&#xA;    o-&amp;gt;&#xA;    firewall-cmd --permanent --remove-port=8080/tcp&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储&#34;&gt;&#xA;  存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;硬盘&#34;&gt;&#xA;  硬盘&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a1%ac%e7%9b%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;fdisk -l&#xA;cfdisk&#xA;sfdisk&#xA;parted&#xA;mkfs&#xA;mkswap&#xA;&#xA;testdisk /dev/sdb1&#xA;e2fsck -a /dev/sdb1         # 修复ext2&#xA;ntfsfix -d -b /dev/sdb1     # 修复ntfs坏扇区和脏标记&#xA;fsck /dev/sda1              # 检查并修复&#xA;&#xA;udisks --detach 设备编号     # 移除磁盘&#xA;&#xA;mount  /dev/sdb1 /mnt&#xA;    -o acl                  # 打开acl功能&#xA;    -o loop x.iso           # 挂载文件&#xA;    -o iocharset=utf8       # 指定编码&#xA;    -t vfat                 # 指定类型&#xA;umount&#xA;    -n                      # 执行umount却不写入&#xA;    -l                      # lazy&#xA;    -f                      # force&#xA;&#xA;df -h                       # 已挂载分区列表&#xA;    -T                      # 查看分区类型&#xA;blktrace                    # 磁盘访问情况&#xA;lsblk                       # 查看挂载的分区&#xA;lvs&#xA;    LVM逻辑卷的创建流程如下：&#xA;        将一个磁盘或分区格式化为物理卷：pvcreate /dev/sdb1&#xA;        将物理卷添加到一个卷组中：vgcreate linuxcast-vg /dev/sdb1 /dev/sdb2&#xA;        基于卷组创建一个逻辑卷mylv：lvcreate -L 10G -n mylv  linuxcast-vg&#xA;        格式化逻辑卷：mkfs.ext4 /dev/linuxcast-vg/mylv&#xA;        挂载使用：mount /dev/linuxcast-vg/mylv  /mnt&#xA;    逻辑卷查看命令：&#xA;    pvdisplay&#xA;    pvs&#xA;    vgdisplay&#xA;    vgs&#xA;    lvdisplay&#xA;    lvs&#xA;    删除一个逻辑卷：&#xA;    lvremove /dev/linuxcast-vg/mylv&#xA;    删除一个卷组：&#xA;    vgremove linuxcast-vg&#xA;    删除一个物理卷：&#xA;    pvremove /dev/sda1&#xA;nfsiostat               # nfs驱动器信息&#xA;cifsiostat              # CIFS信息&#xA;growpart                # 磁盘热扩容&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;文件操作&#34;&gt;&#xA;  文件操作&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;fuser                   # 查看文件被谁使用&#xA;    -u                  # 列出使用者用户名&#xA;    -uk                 # 终止文件的所有进程&#xA;    -n tcp 8080         # 列出端口的进程号&#xA;ldd /bin/ls             # 查看可执行文件动态引用模块&#xA;rename &#39;s/\.bak$//&#39; *.bak           # 重命名&#xA;rm -rf&#xA;touch&#xA;    -t 0712250000 file              # 修改文件时间戳(YYMMDDhhmm)&#xA;ls *[0-9]*&#xA;    -t                  # 时间排序&#xA;    -R                  # 递归显示文件&#xA;    -l                  # 详情&#xA;    -S                  # 按大小排列&#xA;    -r                  # reverse&#xA;    -h                  # 自动大小单位&#xA;    -F                  # 加后缀标识类型&#xA;    -Z                  # 显示文selinux状态&#xA;tree&#xA;mkdir&#xA;rmdir&#xA;cd&#xA;    ~&#xA;    -&#xA;cp&#xA;    -r                  # 递归&#xA;    -p                  # 带权限复制&#xA;    -d                  # 保留链接&#xA;    -a                  # -dpr&#xA;mv&#xA;whereis&#xA;which&#xA;find .&#xA;    maxdepth 1&#xA;    -name &amp;quot;*.go&amp;quot;&#xA;    -type f&#xA;    -atime +100         # 100天未使用过的执行文件&#xA;    -mtime -10          # 10天内创建或修改的文件&#xA;    -exec chmod +x      # 对找到的文件执行命令&#xA;    -xdev               # 忽略块设备&#xA;file                    # 探测文件类型&#xA;    file 可执行文件     # 可查看是否静态编译&#xA;ln&#xA;du -d 1 -h&#xA;    -s                  # 只返回汇总情况&#xA;    -k                  # 统一单位&#xA;tar xf&#xA;    cfzv x.tar.gz x     # 压缩&#xA;    xfzv x.tar.gz       # 解压&#xA;    --exclude=/proc&#xA;gzip x                  # 压缩&#xA;    -d x                # 解压&#xA;unzip&#xA;    常用&#xA;        unzip中转码&#xA;            unzip -P “$(echo 中文 | iconv -f utf-8 -t gbk)”&#xA;unzip-beta              # 解压并转码中文&#xA;diff        # 改变以匹配第二个文件&#xA;    diff -y a b&#xA;    diff dir1 dir2&#xA;&#xA;    diff -uN a b &amp;gt; b.patch&#xA;    patch -p0 &amp;lt; b.patch&#xA;    patch -RE -p0 &amp;lt; b.patch&#xA;&#xA;    diff -uNra a b &amp;gt; b.patch&#xA;    cd a&#xA;    patch -p1  &amp;lt; ../b.patch&#xA;    patch -RE -p1 &amp;lt; ../b.patch&#xA;rsync -av --exclude=.git --exclude=logs/* ./* 192.168.0.14:/data/app/ext-marketing/&#xA;vimdiff a b&#xA;&#xA;mucommander             # 跨平台文件管理软件&#xA;shred                   # 文件粉碎&#xA;rclone                  # 云存储同步&#xA;    config              # 配置向导&#xA;    ls [name]:          # 显示文件&#xA;    lsd [name]:         # 显示文件夹&#xA;    copy a [name]:a     # 上传&#xA;    cleanup             # 只保留最新版本&#xA;    sync                # 本地向远程同步&#xA;    mount               # 双向一致同步&#xA;        fusermount -u /path/to/local/mount&#xA;            # umount&#xA;rclone-browser          # rclone GUI&#xA;onedrive&#xA;    onedrive --resync&#xA;    常用命令&#xA;        systemctl --user enable onedrive&#xA;        systemctl --user start onedrive&#xA;        journalctl --user-unit onedrive -f&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;权限&#34;&gt;&#xA;  权限&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;chmod ugo+rwx           # u拥有者, g群组, o其他人, +添加, -删除, r读、w写、x执行&#xA;    chmod a+rwx         # a指所有人&#xA;chattr +i file          # 改变属性&#xA;lsattr file&#xA;chown -R outrun:outrun .&#xA;chgrp -R outrun .&#xA;getfacl                 # 查看一个文件的ACL设置&#xA;setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ...&#xA;    -b                  # 去掉所有acl设置&#xA;    -m u:sudo:rwx   filename    # 配置用户权限&#xA;    -m g:sudo:r-x  filename     # 配置组的权限&#xA;    -x u:user1 filename         # 删除一个ACL设置&#xA;    -d -m g:sudo:rwx            # 指定default&#xA;chcon                   # 修改文件安全上下文&#xA;    -R                  # 递归&#xA;    -t                  # type&#xA;    -u                  # user&#xA;    -r                  # role&#xA;    --reference         # 参照更新&#xA;    chcon -R -t mysqld_db_t /data&#xA;    chcon -R --reference=/var/lib/mysql /data&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;功能软件&#34;&gt;&#xA;  功能软件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%9f%e8%83%bd%e8%bd%af%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;包管理&#34;&gt;&#xA;  包管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8c%85%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;snap&#xA;    list                    # 列已安装&#xA;    info                    # 查看仓库所有版本&#xA;    find                    # 搜索&#xA;    install&#xA;    remove&#xA;    refresh                 # 更新&#xA;        refresh all&#xA;    revert                  # 还原到上个版本&#xA;        --revision          # 指定版本&#xA;    run                     # 运行命令&#xA;    start                   # 运行service&#xA;        --enable            # 开机启动&#xA;    stop                    # 停止service&#xA;    save                    # 存配置快照&#xA;    saved                   # 列出所有快照&#xA;rpm                         # 源 rpm fusion&#xA;    -i 安装&#xA;    -e 卸载&#xA;    -qa 查看安装的包名&#xA;    -ql 包名, 查看安装的文件&#xA;    -qc 包名, 查看软件的配置文件&#xA;pacman&#xA;    命令 pacman&amp;lt;操作&amp;gt; [选项] [目标]&#xA;        操作&#xA;            -Q                      # 查询&#xA;            -S                      # 安装&#xA;            -R                      # 删除&#xA;            -D                      # 数据库&#xA;            -F                      # 文件&#xA;        选项&#xA;        选项-S, -R, -U&#xA;            -s&#xA;        选项-S, -U&#xA;        选项-Q&#xA;            -s                      # 搜索&#xA;            -e                      # 明确指定的&#xA;            -n                      # 本地的&#xA;            -q                      # 静默&#xA;            -i                      # 详情, 两个i显示备份文件和修改状态, 显示依赖&#xA;            -l                      # 列出文件&#xA;            -o                      # 显示拥有此文件的包名&#xA;        选项-R&#xA;            -s                      # 递归&#xA;            -c                      # 级联依赖此包的包&#xA;            -n                      # 不记录备份信息&#xA;        选项-S&#xA;            -s                      # 搜索&#xA;            -y                      # 刷新, 两个y强制升级所有包数据库&#xA;            -q                      # 静默&#xA;            -u                      # 系统升级&#xA;            -c                      # 清理, 一个c清理未安装包, 两个c清理所有cache&#xA;        选项-D&#xA;        选项-F&#xA;        目标&#xA;&#xA;    常用&#xA;        -Qeq | pacman -S -                  # 重新安装所有包&#xA;        -S $(pacman -Qnq)                   # 重新安装所有包&#xA;        -Ss ^ibus-*                         # 通配search&#xA;        -S $(pacman -Ssq fcitx*)            # 通配安装&#xA;        -R $(pacman -Qsq fcitx)             # 通配删除&#xA;        -Rcns plasma                        # 删除plasma&#xA;        -Rns                                # 删依赖并删配置&#xA;        -Scc                                # 清除缓存&#xA;        -Qii zsh                            # 包信息&#xA;        -Ql zsh                             # 查看安装的文件&#xA;        -Qo /bin/zsh                        # 查看文件属于的包&#xA;        -Qdt                                # 查孤儿包 &#xA;&#xA;    源&#xA;        mirrors.163.com&#xA;apt&#xA;    源&#xA;        阿里云mirror: https://developer.aliyun.com/mirror&#xA;        ubuntu&#xA;            sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list &#xA;downgrade                               # 用于给pacman安装过后软件降级&#xA;yum&#xA;    list                                # 列出所有包&#xA;        updates                         # 列可更新的包&#xA;        installed                       # 列已安装&#xA;        extras                          # 已安装但不在yum repository的包&#xA;    search&#xA;    install&#xA;    remove&#xA;    info                                # 包详情&#xA;        updates&#xA;        installed&#xA;        extras&#xA;    provides                            # 包文件&#xA;    whatprovides &#39;bin/isstat&#39;           # 查看命令属性哪个包&#xA;    history&#xA;        list&#xA;        redo 序号                        # 重新做序号&#xA;        undo 序号                        # 恢复历史中执行的动作&#xA;    groups list                         # 查看安装的组&#xA;&#xA;&#xA;    设置代理&#xA;        /etc/yum.conf&#xA;        proxy=http://XXX.XXX.XXX.XXX：XXXX&#xA;        或&#xA;        proxy=FTP://XXX.XXX.XXX.XXX:XXXX&#xA;        proxy_username=你的用户名&#xA;        proxy_password=你的用户名的密码&#xA;    编译用包&#xA;        build-essential                     # yum中基本编译依赖包&#xA;        yum install make cmake apr* autoconf automake curl-devel gcc gcc-c++ zlib-devel openssl openssl-devel pcre-devel gd  kernel keyutils  patch  perl kernel-headers compat* mpfr cpp glibc libgomp libstdc++-devel ppl cloog-ppl keyutils-libs-devel libcom_err-devel libsepol-devel libselinux-devel krb5-devel zlib-devel libXpm* freetype libjpeg* libpng* php-common php-gd ncurses* libtool* libxml2 libxml2-devel patch freetype-devel ncurses-devel libmcrypt libtool flex pkgconfig libevent glib libgnomeui-devel&#xA;dpkg                        # 管理deb包程序&#xA;    -i                      # 安装&#xA;    -r                      # 删除&#xA;pkgfile                     # 查看命令所需的包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;编译&#34;&gt;&#xA;  编译&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%af%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;:() { :|:&amp;amp; };:              # fork bombmake&#xA;make&#xA;    注意&#xA;        缩进只能用tab&#xA;    命令&#xA;        make&#xA;        make install&#xA;        make glide&#xA;    条目里执行shell&#xA;        @echo $(shell $(SHELL_PATH))&#xA;&#xA;    o-&amp;gt;&#xA;    TESTS = test/*.js&#xA;    REPORTER = spec&#xA;    TIMEOUT = 10000&#xA;    MOCHA_OPTS =&#xA;&#xA;    test:&#xA;        @NODE_ENV=test ./node_modules/mocha/bin/mocha \&#xA;            --reporter $(REPORTER) \&#xA;            --timeout $(TIMEOUT) \&#xA;            $(MOCHA_OPTS)&#xA;            $(TESTS)&#xA;&#xA;    test-cov&#xA;        @$(MAKE) test MOCHA_OPTS=&#39;--require blanket&#39; REPORTER=html-cov &amp;gt; coverage.html&#xA;&#xA;    test-all: test test-cov&#xA;&#xA;    .PHONY: test&#xA;&#xA;    o-&amp;gt;&#xA;    TESTS = $(shell ls -S `find test -type f -name &amp;quot;*.js&amp;quot; -print`)&#xA;    TESTTIMEOUT = 5000&#xA;    MOCHA_OPTS =&#xA;    REPORTER = spec&#xA;&#xA;    install:&#xA;        @$PYTHON=`which python2.6` NODE_ENV=test npm install&#xA;&#xA;    test:&#xA;        @NODE_ENV=test ./node_modules/mocha/bin/mocha \&#xA;            --reporter $(REPORTER) \&#xA;            --timeout $(TIMEOUT) \&#xA;            $(MOCHA_OPTS) \&#xA;            $(TESTS)&#xA;&#xA;    test-cov:&#xA;        @$(MAKE) test REPORTER=dot&#xA;        @$(MAKE) test MOCHA_OPTS=&#39;--require blanket&#39; REPORTER=html-cov &amp;gt; coverage.html&#xA;        @$(MAKE) test MOCHA_OPTS=&#39;--require blanket&#39; REPORTER=travis-cov&#xA;&#xA;    reinstall: clean&#xA;        @$(MAKE) install&#xA;&#xA;    clean:&#xA;        @rm -rf ./node_modules&#xA;&#xA;    build:&#xA;        @./bin/combo views .&#xA;&#xA;    .PHONY: test test-cov clean install reinstall&#xA;cmake&#xA;makepkg                 # 创建软件包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;调试&#34;&gt;&#xA;  调试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b0%83%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;perf                    # 性能调优&#xA;strace                  # 跟踪系统调用&#xA;itrace                  # linux系统编程中跟踪进程的库函数调用&#xA;    -S ./hello          # 跟踪所有系统调用&#xA;dtrace                  # 应用程序动态跟踪&#xA;bpftrace                # btrace2.0&#xA;gdb&#xA;SystemTap               # 内核动态探针&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;图形程序&#34;&gt;&#xA;  图形程序&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be%e5%bd%a2%e7%a8%8b%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;桌面&#34;&gt;&#xA;  桌面&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%8c%e9%9d%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;kde&#xA;xfce&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;gnome&#34;&gt;&#xA;  gnome&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gnome&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;启动&#xA;    .xinitrc&#xA;        exec gnome-session&#xA;    startx&#xA;gnome3应用程序列表&#xA;    /usr/share/applications&#xA;取消ctrl+alt+down/up&#xA;    gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-down &amp;quot;[&#39;&#39;]&amp;quot;&#xA;    gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-up &amp;quot;[&#39;&#39;]&amp;quot;&#xA;gnome-shell&#xA;    alt + f2后输入lg&#xA;gnome terminate&#xA;    ctrl + shift + c/v                  # 复制/粘贴&#xA;    ctrl + shift + t/n                  # 打开新标签/新窗口&#xA;    ctrl + w 或 alt + backspace          # 删除最后的word&#xA;    ctrl + shift + w/q                  # 关闭当前term/所有term&#xA;    ctrl + shift + f/g/h                # 搜索/搜索下一个/搜索上一个&#xA;    ctrl + pageUp/pageDown              # 切换标签&#xA;    ctrl + shift + pageUp/pageDown      # 移动标签&#xA;    alt + 1/2/3/..../0                  # 切换到第1/2/3/....../10个标签&#xA;系统快捷键&#xA;    右键快捷键&#xA;        shift + f10&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;i3&#34;&gt;&#xA;  i3&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#i3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;启动&#xA;    .xinitrc&#xA;        exec i3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;awesome&#34;&gt;&#xA;  awesome&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#awesome&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;启动&#xA;    .xinitrc&#xA;        exec /usr/bin/awesome &amp;gt;&amp;gt; ~/.cache/awesome/stdout 2&amp;gt;&amp;gt; ~/.cache/awesome/stderr&#xA;命令&#xA;    awesome&#xA;    awesome-client&#xA;配置&#xA;    配置模板&#xA;        /etc/xdg/awesome/rc.lua&#xA;    .config/awesome/rc.lua&#xA;        Variable definitions            # 可定义布局优先级&#xA;        Menu                            # 右键菜单&#xA;        Wibar                           # 生成screen, 设壁纸&#xA;        Mounse bindings                 # 鼠标键绑定函数&#xA;        Key bindings                    # 快捷键&#xA;        Rules                           # client规则, 如在哪个screen显示&#xA;        Signals                         # client启动信号触发动作&#xA;        自定义&#xA;    API&#xA;        文档地址&#xA;            https://awesomewm.org/apidoc/&#xA;        快捷键简写&#xA;            modkey                      # win键&#xA;            Mod1                        # alt&#xA;        gears                           # 工具组件&#xA;        wibox                           # wibar&#xA;            widget&#xA;            layout&#xA;        beautiful                       # theme&#xA;            init(gears.filesystem.get_configuration_dir() .. &amp;quot;/themes/default/theme.lua&amp;quot;)&#xA;                # 主题&#xA;            useless_gap = 5             # 窗口间隔&#xA;            theme.lua文件&#xA;                theme.wallpaper = &amp;quot;~/.config/awesome/themes/awesome-wallpaper.png&amp;quot;&#xA;                    # 背景&#xA;&#xA;        naughty&#xA;            notify({ preset = naughty.config.presets.critical, title = &amp;quot;Oops, there were errors during startup!&amp;quot;, text = awesome.startup_errors })&#xA;        menubar&#xA;            menu_gen&#xA;        hotkeys_popup&#xA;        awful&#xA;            layout&#xA;            tag({ &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;9&amp;quot; }, s, awful.layout.layouts[1])&#xA;            key({ modkey }, &amp;quot;F12&amp;quot;, function () awful.spawn{ &amp;quot;xlock&amp;quot; } end)&#xA;                # 快捷键&#xA;                awful.key({ &amp;quot;Mod1&amp;quot; }, &amp;quot;Escape&amp;quot;, function () awful.menu.menu_keys.down = { &amp;quot;Down&amp;quot;, &amp;quot;Alt_L&amp;quot; } awful.menu.clients({theme = { width = 250 }}, { keygrabber=true, coords={x=525, y=330} }) end),&#xA;            widget&#xA;            rules&#xA;            spawn(&amp;quot;firefox&amp;quot;, { tag = mouse.screen.selected_tag })&#xA;            util.spawn_with_shell(&amp;quot;~/.config/awesome/autorun.sh&amp;quot;)&#xA;                # 随桌面启动脚本&#xA;    autorun.sh&#xA;        #!/usr/bin/env bash&#xA;&#xA;        # nothing to use&#xA;        function run {&#xA;            if ! pgrep $1 ; then&#xA;                $@&amp;amp;&#xA;            fi&#xA;        }&#xA;&#xA;        if randr | grep -q &#39;eDP1 connected&#39; ; then&#xA;            run xrandr --output VIRTUAL1 --off --output eDP1 --mode 1920x1080 --pos 0x720 --rotate normal --output DP1 --off --output DP2-1 --mode 2560x1080 --pos 3360x720 --rotate normal --output DP2-2 --off --output DP2-3 --off --output HDMI2 --off --output HDMI1 --primary --mode 2560x1440 --pos 1920x0 --rotate left --output DP2 --off&#xA;        fi&#xA;&#xA;        run ibus-daemon -d -x&#xA;        run nm-applet&#xA;插件&#xA;    revelation          # 全局client&#xA;    shifty              # 动态tag&#xA;    naughty             # 通知&#xA;    vicious             # widgets&#xA;    obvious             # widgets&#xA;    bashets             # widgets&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;小程序&#34;&gt;&#xA;  小程序&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%8f%e7%a8%8b%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;cmatrix                 # 终端黑客帝国&#xA;screenfetch&#xA;import                  # 截图&#xA;    import a.png        # 选取区域&#xA;    -pause 3 -frame a.png                       # 截窗口, 延迟3秒(为了选定)&#xA;xgamma -gamma .75       # 调整屏幕色值&#xA;display                 # 显示图片&#xA;    display *.png       # 幻灯片&#xA;    -delay 5            # 5百分之秒切换&#xA;&#xA;    快捷键&#xA;        空格            # 下一张&#xA;        退格            # 上一张&#xA;        h               # 水平翻转&#xA;        v               # 垂直翻转&#xA;        /               # 顺时针翻转90度&#xA;        \               # 逆时针旋转90度&#xA;        &amp;gt;               # 放大&#xA;        &amp;lt;               # 缩小&#xA;        f7              # 模糊&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;任务栏&#34;&gt;&#xA;  任务栏&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%bb%e5%8a%a1%e6%a0%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;nm-applet&#xA;    # 联网&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;输入法&#34;&gt;&#xA;  输入法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%93%e5%85%a5%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;fcitx&#xA;ibus&#xA;ibus-daemon -d -x -r        # ibus后台运行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模拟&#34;&gt;&#xA;  模拟&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e6%8b%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;wine&#xA;winetricks                  # 安装wine的各种依赖&#xA;cabextract                  # microsoft cabinet获取工具&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;资源管理&#34;&gt;&#xA;  资源管理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;nautilus&#xA;    快捷键&#xA;        &amp;lt;Ctrl+L&amp;gt;            # 路径编辑&#xA;        &amp;lt;Ctrl+W&amp;gt;            # 关闭tab&#xA;        &amp;lt;Ctrl+Shift+W&amp;gt;      # 关闭所有tab&#xA;        &amp;lt;Ctrl+T&amp;gt;            # 新建tab&#xA;        &amp;lt;F9&amp;gt;                # 侧边栏&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
