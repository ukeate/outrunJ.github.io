<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>代码 on outrun的笔记</title>
    <link>https://runout.run/docs/architect/code/</link>
    <description>Recent content in 代码 on outrun的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 01 Aug 2022 13:53:50 +0800</lastBuildDate>
    <atom:link href="https://runout.run/docs/architect/code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Security</title>
      <link>https://runout.run/docs/architect/code/security/</link>
      <pubDate>Thu, 11 Oct 2018 18:47:57 +0800</pubDate>
      <guid>https://runout.run/docs/architect/code/security/</guid>
      <description>&lt;h1 id=&#34;服务器&#34;&gt;&#xA;  服务器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;木马&#34;&gt;&#xA;  木马&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%a8%e9%a9%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;自变异木马&#xA;    改变自身hash或将自身大量复制到不同目录, 后台运行，躲避清理&#xA;    自删除&#xA;    伪装成系统程序或绑定系统程序&#xA;检查&#xA;    可疑进程&#xA;    定时任务&#xA;    启动项&#xA;        /etc/init.d或service --status-all&#xA;        systemctl list-unit-files | grep enabled&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;经验&#34;&gt;&#xA;  经验&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%8f%e9%aa%8c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;libudev.so                      # 自变异，/bin/下生成随机名称命令, 启动后可远程执行命令，在/etc/init.d下创建自启动项，在/etc/crontab中添加定时任务&#xA;    chmod 0000 /lib/libudev.so &amp;amp;&amp;amp; rm -rf /lib/libudev.so &amp;amp;&amp;amp; chattr +i /lib/&#xA;    /etc/init.d下随机名称文件删除, /etc/rc{0,1,2,3,4,5,6,S}.d中的软链删除&#xA;    /etc/crontab/gcc.sh删除&#xA;    sed &#39;/gcc.sh/d&#39; /etc/crontab &amp;amp;&amp;amp; chmod 0000 /etc/crontab &amp;amp;&amp;amp; chattr +i /etc/crontab 删除定时任务&#xA;    重启&#xA;    chattr -i /lib /etc/crontab 恢复可写&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;ddos&#34;&gt;&#xA;  DDoS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ddos&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;防范方法&#34;&gt;&#xA;  防范方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e8%8c%83%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;漏洞扫描&#34;&gt;&#xA;  漏洞扫描&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%bc%8f%e6%b4%9e%e6%89%ab%e6%8f%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;DVWA&#xA;    # Damn Vulnerable Web Application，PHP + MySQL模拟Web漏洞&#xA;W3af&#xA;    # Web应用扫描, Python实现&#xA;OpenVAS&#xA;    # 扫描主机漏洞&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;网络隔离&#34;&gt;&#xA;  网络隔离&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c%e9%9a%94%e7%a6%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;内外网分离&#xA;登录跳板机&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;web安全&#34;&gt;&#xA;  Web安全&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;xss&#34;&gt;&#xA;  XSS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xss&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 向网页注入代码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;csrf&#34;&gt;&#xA;  CSRF&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#csrf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Cross-Site Request Forgery, 跨站请求伪造&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sql注入&#34;&gt;&#xA;  SQL注入&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sql%e6%b3%a8%e5%85%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;hash-dos&#34;&gt;&#xA;  Hash Dos&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hash-dos&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;上传大Json Object, 利用Hash算法的伪随机性，制造Value不同但Hash碰撞的数据，耗尽CPU&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;上传文件脚本&#34;&gt;&#xA;  上传文件脚本&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6%e8%84%9a%e6%9c%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;伪造Content-Type上传静态资源，再URL访问执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;防范方法-1&#34;&gt;&#xA;  防范方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e8%8c%83%e6%96%b9%e6%b3%95-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;验证码&#34;&gt;&#xA;  验证码&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%aa%8c%e8%af%81%e7%a0%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;根据滑动响应时间、拖拽速度、时间、位置、轨迹、重试次数来评估风险&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;信息存储&#34;&gt;&#xA;  信息存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%a1%e6%81%af%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;密码非明文保存，加salt&#xA;身份证号、手机号加&amp;quot;*&amp;quot;&#xA;联系方式显示与否用户自己配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;加密&#34;&gt;&#xA;  加密&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a0%e5%af%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;对称加密&#xA;    DES             # 56位秘钥，已被AES取代&#xA;    3DES            # 做3次DES&#xA;    AES             # 128、192、256位秘钥&#xA;    Blowfish        # 1到448位变长秘钥&#xA;非对称加密&#xA;    RSA             #&#xA;    DSA             # 性能快于RSA，只能数字签名&#xA;    ECDSA           # 螺旋曲线加密算法&#xA;    ECC             # 256位ECC秘钥相当于3072位RSA秘钥&#xA;哈希算法&#xA;    MD5             # 不再安全&#xA;    SHA-1           # 不再安全&#xA;    SHA-256&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;授权认证&#34;&gt;&#xA;  授权、认证&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%88%e6%9d%83%e8%ae%a4%e8%af%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;RBAC、ABAC&#xA;SSO&#xA;OAuth2.0&#xA;OIDC&#xA;    # OpenId Connect，OAuth2上构建的身份认证&#xA;SAML&#xA;    # Security Assertion Markup Language&#xA;    用于SSO，XML格式&#xA;    定义了三个角色：委托人、身份提供者(IDP)、服务提供者(SP)。用户SP做访问控制&#xA;2FA&#xA;    # Two-factor authentication, 双因素认证&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;代码安全&#34;&gt;&#xA;  代码安全&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%a0%81%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;java反序列化漏洞&#34;&gt;&#xA;  Java反序列化漏洞&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;用户输入直接反序列化，可利用Apache Commons Collections执行任意代码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据安全&#34;&gt;&#xA;  数据安全&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ae%89%e5%85%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数据备份&#34;&gt;&#xA;  数据备份&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%a4%87%e4%bb%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h1 id=&#34;问题定义与排查方法&#34;&gt;&#xA;  问题定义与排查方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e5%ae%9a%e4%b9%89%e4%b8%8e%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;线上故障等级&#xA;&#x9;P0 致命问题&#xA;&#x9;P1 严重问题&#xA;&#x9;P2 一般问题&#xA;&#x9;P3 轻微问题&#xA;线上故障分类&#xA;&#x9;外部依赖类&#xA;&#x9;运营质量类&#xA;&#x9;需求质量类&#xA;&#x9;系统质量类&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;混沌工程&#34;&gt;&#xA;  混沌工程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%b7%e6%b2%8c%e5%b7%a5%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;混沌工程画像&#xA;&#x9;ApplicationData&#xA;&#x9;&#x9;进程Hang、Kill，启动异常，心跳异常，环境错误，包错误或损坏，配置错误、误删、获取超时&#xA;&#x9;Data&#xA;&#x9;&#x9;系统单点，异步阻塞同步，依赖超时，依赖异常，业务线程池满，监控错误，OOM&#xA;&#x9;Runtime&#xA;&#x9;&#x9;负载均衡失效，缓存热点，缓存限流&#xA;&#x9;Middleware&#xA;&#x9;&#x9;数据库热点，数据库宕机，数据同步延迟，数据库主备延迟，数据库连接满，数据库热点&#xA;&#x9;OS&#xA;&#x9;&#x9;CPU抢占，内存抢占，内存错乱，上下文切换&#xA;&#x9;Virtualization&#xA;&#x9;&#x9;服务器宕机、假死，断电，超卖，混部&#xA;&#x9;Storage&#xA;&#x9;&#x9;磁盘满、慢、坏，不可写，不可读&#xA;&#x9;Networking&#xA;&#x9;&#x9;网络抖动、丢包、超时，网卡满，断网&#xA;工具&#xA;&#x9;ChaosBlade&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;java&#34;&gt;&#xA;  Java&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Idea Debugger&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;redis&#34;&gt;&#xA;  Redis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;mysql&#34;&gt;&#xA;  MySQL&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Using intersect&#xA;&#x9;多余查询条件虽然命中索引，但会产生多余的索引查询使SQL变慢，应该使用唯一的单值索引&#xA;force index指定期望的索引&#xA;用count(*)不要count(1)&#xA;use filesort可能会文件排序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;trace&#34;&gt;&#xA;  Trace&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#trace&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Pinpoint记录&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;各开源协议&#34;&gt;&#xA;  各开源协议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%84%e5%bc%80%e6%ba%90%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;GPL&#xA;    介绍&#xA;        GNU General Public License，GNU发布的通用协议，共3个版本，最新为GPLv3，Linux使用此协议&#xA;    特点&#xA;        发布的软件使用GPL的软件, 也要GPL&#xA;LGPL&#xA;    介绍&#xA;        GNU Lesser General Public License，OpenOffice使用此协议&#xA;    特点&#xA;        类库引用可不开源，有代码修改要使用LGPL开源&#xA;AGPL&#xA;    介绍&#xA;        Affero General Public License。类似的协议有CPAL、OSL&#xA;    特点&#xA;        除发布的软件，提供服务的软件，也要AGPL&#xA;BSD&#xA;    介绍&#xA;        Berkly Software Distribution&#xA;    特点&#xA;        可以自由修改，修改可再次闭源发布。只需要BSD许可协议文件，但不能使用原作者名义宣传&#xA;MPL&#xA;    介绍&#xA;        The Mozilla Public License&#xA;    特点&#xA;        可与其它授权的文件混合使用，新增代码可使用其它方式授权或闭源&#xA;        使用MPL的部分，对MPL修改的部分，要MPL&#xA;MIT&#xA;    介绍&#xA;        近1/3的开源 软件使用。如ssh, JQuery, Putty，XWindow&#xA;    特点&#xA;        类似BSD，可使用原作者名义推广&#xA;Apache2.0&#xA;    介绍&#xA;        软件有Android, Apache Web Server, Swift&#xA;    特点&#xA;        类似BSD，被修改的原始文件要著名版权&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Java设计模式</title>
      <link>https://runout.run/docs/architect/code/design_mode/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/architect/code/design_mode/</guid>
      <description>&lt;h1 id=&#34;六个原则&#34;&gt;&#xA;  六个原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ad%e4%b8%aa%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;单一职责原则(SRP, Single Responsibility Principle)&#xA;    一个类只做一件事，应该只有一个引起它修改的原因&#xA;开闭原则(OCP, Open-Close Principle)&#xA;    对修改封闭，对扩展开放&#xA;里氏替换原则(LSP, the Liskov Substitution Principle)&#xA;    子类可以完全替换父类。也就是继承只扩展新功能&#xA;依赖倒置原则(DIP, the Dependency Inversion Principle)&#xA;    细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定&#xA;接口隔离原则(ISP, the Interface Segregation Principle)&#xA;    客户端不依赖它不需要的接口。冗余依赖应该将接口拆分&#xA;迪米特法则（最少知道原则）(LoD, Law of Demeter)&#xA;    一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;构建型&#34;&gt;&#xA;  构建型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e5%bb%ba%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;工厂方法factory-method&#34;&gt;&#xA;  工厂方法(Factory Method)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95factory-method&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 简单工厂, 根据参数创建不同的类&#xA;# 静态工厂，单例工厂&#xA;public interface Sender{&#xA;    public void Send();&#xA;}&#xA;public class MySender implements Sender{&#xA;    @Override&#xA;    public void Send(){}&#xA;}&#xA;public SenderFactory {&#xA;    public static Sender produceStatic() {&#xA;        return new MySender();&#xA;    }&#xA;    public Sender produce(){&#xA;        return new MySender();&#xA;    }&#xA;    public Sender produce(int i){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&#xA;# 工厂子类继承工厂接口, 不同产品对应不同工厂&#xA;public interface AbstractFactory {&#xA;    public MySender produce();&#xA;}&#xA;public class MyFactory implements AbstractFactory {&#xA;    @Override&#xA;    public MySender produce(){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;抽象工厂abstract-factory&#34;&gt;&#xA;  抽象工厂(Abstract Factory)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82abstract-factory&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 生产抽象产品&#xA;public interface AbstractFactory {&#xA;    public Sender produce();&#xA;}&#xA;public class MyFactory implements AbstractFactory {&#xA;    @Override&#xA;    public Sender produce(){&#xA;        return new MySender();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;单例singleton&#34;&gt;&#xA;  单例(Singleton)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e4%be%8bsingleton&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;确保只有一个实例&#xA;    # 大多有资源管理器的功能&#xA;    # 反射机制会使所有单例失效：私有构造方法可以被访问&#xA;应用&#xA;    线程池&#xA;    缓存&#xA;    日志对象&#xA;    对话框&#xA;    打印机&#xA;    显卡驱动程序&#xA;o-&amp;gt; 饿汉&#xA;public class Singleton {&#xA;    public static Singleton instance = new Singleton();&#xA;    private Singleton(){}&#xA;    public static Singleton getInstance(){&#xA;        return instance;&#xA;    }&#xA;}&#xA;o-&amp;gt; 懒汉式&#xA;public class Singleton {&#xA;    private static Singleton single=null;&#xA;    private Singleton() {}&#xA;    public synchronized  static Singleton getInstance() {&#xA;        if (single == null) {&#xA;            single = new Singleton();&#xA;        }&#xA;        return single;&#xA;    }&#xA;}&#xA;o-&amp;gt; 懒汉，双重检测(DCL)&#xA;    # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。&#xA;    # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized&#xA;public class Singleton {&#xA;    private static volatile Singleton singleton = null;&#xA;        # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。&#xA;    private Singleton(){}&#xA;    public static Singleton getInstance(){&#xA;        if (singleton == null) {&#xA;            // t1,t2并发进入&#xA;            synchronized (Singleton.class) {&#xA;                // t1释放后，t2进入&#xA;                if (singleton == null) {&#xA;                    singleton = new Singleton();&#xA;                }&#xA;            }&#xA;        }&#xA;        return singleton;&#xA;    }&#xA;}&#xA;o-&amp;gt; map注册&#xA;    # 学Spring，将类名注册&#xA;public class Singleton {&#xA;    private static Map&amp;lt;String,Singleton&amp;gt; map = new HashMap&amp;lt;String,Singleton&amp;gt;();&#xA;    static{&#xA;        Singleton single = new Singleton();&#xA;        map.put(single.getClass().getName(), single);&#xA;    }&#xA;    protected Singleton(){}&#xA;    public static Singleton getInstance(String name) {&#xA;        if(name == null) {&#xA;            name = Singleton.class.getName();&#xA;        }&#xA;        if(map.get(name) == null) {&#xA;            map.put(name, (Singleton) Class.forName(name).newInstance());&#xA;        }&#xA;        return map.get(name);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;建造者builder&#34;&gt;&#xA;  建造者(Builder)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bb%ba%e9%80%a0%e8%80%85builder&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 提供工厂方法，建造内部复合对象&#xA;o-&amp;gt;&#xA;public class Builder {&#xA;    private List&amp;lt;Sender&amp;gt; list = new ArrayList&amp;lt;Sender&amp;gt;();&#xA;    public void produceMailSender() {&#xA;        list.add(new MailSender())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;原型prototype&#34;&gt;&#xA;  原型(Prototype)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%9e%8bprototype&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 复制原型来创建新对象&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;结构型&#34;&gt;&#xA;  结构型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%84%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;适配器adapter&#34;&gt;&#xA;  适配器(Adapter)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%82%e9%85%8d%e5%99%a8adapter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 用来匹配接口&#xA;o-&amp;gt; 类&#xA;public class Source(){&#xA;    public void method1(){}&#xA;}&#xA;public interface Targetable {&#xA;    public void method1()&#xA;    public void method2()&#xA;}&#xA;public class Adapter extends Source implements Targetable {&#xA;    @Override&#xA;    public void method2(){}&#xA;}&#xA;o-&amp;gt; 对象&#xA;public class Wrapper implements Targetable {&#xA;    private Source source;&#xA;    public Wrapper(Source source){&#xA;        super();&#xA;        this.source = source;&#xA;    }&#xA;    @Override&#xA;    public void method1(){&#xA;        source.method1()&#xA;    }&#xA;    @Override&#xA;    public void method2(){}&#xA;}&#xA;o-&amp;gt; 接口&#xA;public abstract class AbstractTarget implements Targetable {&#xA;    @Override&#xA;    public void method1(){}&#xA;}&#xA;public class Adapter extends AbstractTarget {&#xA;    @Override&#xA;    public method2(){}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;桥接bridge&#34;&gt;&#xA;  桥接(Bridge)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%a5%e6%8e%a5bridge&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 分离抽象和具体(两个维度发展)分别继承，抽象聚合(桥接)具体&#xA;public abstract class Gift {&#xA;    GiftImpl impl;&#xA;}&#xA;public class Flower extends GiftImpl {}&#xA;public class WarmGift extends Gift {&#xA;    public WarmGift(GiftImpl impl) {&#xA;        this.impl = impl;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;组合composite&#34;&gt;&#xA;  组合(Composite)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e5%90%88composite&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 树状结构&#xA;abstract class Node{}&#xA;class LeafNode extends Node{}&#xA;class BranchNode extends Node{&#xA;    List&amp;lt;Node&amp;gt; nodes = new ArrayList&amp;lt;&amp;gt;();&#xA;}&#xA;&#xA;tree(Node b, int depth) {&#xA;    b.print();&#xA;    if (b instanceof BranchNode) {&#xA;        for (Node n : ((BranchNode)b).nodes){&#xA;            tree(n, depth+1)&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;装饰decorator&#34;&gt;&#xA;  装饰(Decorator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a3%85%e9%a5%b0decorator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 持有被装饰实例，实现同一接口&#xA;public interface Sourceable {&#xA;    public void method();&#xA;}&#xA;public class Source implements Sourceable {&#xA;    @Override&#xA;    public void method(){}&#xA;}&#xA;public class Decorator implements Sourceable {&#xA;    private Sourceable source;&#xA;    public Decorator(Sourceable source) {&#xA;        super();&#xA;        this.source = source;&#xA;    }&#xA;    @Override&#xA;    public void method() {&#xA;        source.method();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;门面facade&#34;&gt;&#xA;  门面(Facade)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%a8%e9%9d%a2facade&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 对外接待&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中介者mediator&#34;&gt;&#xA;  中介者(Mediator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e4%bb%8b%e8%80%85mediator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 内部都只关联它，如mq&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;享元flyweight&#34;&gt;&#xA;  享元(Flyweight)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%ab%e5%85%83flyweight&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 共享元数据&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;代理&#34;&gt;&#xA;  代理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 静态代理，实现同装饰&#xA;class TankTimeProxy implements Movable {&#xA;    Movable m;&#xA;    @Override&#xA;    public void move(){&#xA;        m.move();&#xA;    }&#xA;}&#xA;&#xA;# 动态代理，Proxy调asm生成代理类&#xA;Tank tank = new Tank();&#xA;Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader()), &#xA;    new Class[]{Movable.class},&#xA;    new Hander(tank)&#xA;);&#xA;class Handler implements InvocationHandler {&#xA;    Tank tank;&#xA;    @Override&#xA;    public Object invoke(Object proxy, Method method, Object[] args) {&#xA;        return method.invoke(tank, args);&#xA;    }&#xA;}&#xA;&#xA;// 动态代理, CGLIB调asm，由于是继承，所以final类不能代理&#xA;Enhancer enhancer = new Enhancer();&#xA;enhancer.setSuperclass(Tank.class);&#xA;enhancer.setCallback(new TimeMethodInterceptor());&#xA;Tank tank = (Tank)enhancer.create();&#xA;tank.move();&#xA;class TimeMethodInterceptor implements MethodInterceptor {&#xA;    @Override&#xA;    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) {&#xA;        return methodProxy.invokeSuper(o, objects);&#xA;    }&#xA;}&#xA;&#xA;// Spring AOP: aspect指定代理类, pointcut指定被代理方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;行为型&#34;&gt;&#xA;  行为型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%8c%e4%b8%ba%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;观察者&#34;&gt;&#xA;  观察者&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%82%e5%af%9f%e8%80%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Observer, 对象变化，对观察者广播&#xA;public interface Observer {&#xA;    public void update();&#xA;}&#xA;public class Observer1 implements Observer {&#xA;    @Override&#xA;    public void update(){}&#xA;}&#xA;public interface Subject{&#xA;    public void add(Observer observer);&#xA;    public void del(Observer observer);&#xA;    public void notifyObservers();&#xA;    public void operate()&#xA;}&#xA;public abstract class AbstractSubject implements Subject {&#xA;    private Vector&amp;lt;Observer&amp;gt; vector = new Vector&amp;lt;Observer&amp;gt;();&#xA;    @Override&#xA;    public void add(Observer observer) {&#xA;        vector.add(observer);&#xA;    }&#xA;    @Override&#xA;    public void del(Observer observer) {&#xA;        vector.remove(observer);&#xA;    }&#xA;    @Override&#xA;    public void notifyObservers(){&#xA;        Enumeration&amp;lt;Observer&amp;gt; enumo = vector.elements();&#xA;        while (enumo.hasMoreElements()) {&#xA;            enumo.nextElement().update();&#xA;        }&#xA;    }&#xA;}&#xA;public class MySubject extends AbstractSubject {&#xA;    @Override&#xA;    public void operate() {&#xA;        notifyObservers();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模板方法templatemethod&#34;&gt;&#xA;  模板方法(TemplateMethod)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95templatemethod&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 钩子函数&#xA;abstract class F {&#xA;    public void m() {&#xA;        op1();&#xA;    }&#xA;    abstract void op1();&#xA;}&#xA;class C1 extends F {&#xA;    @Override&#xA;    void op1(){}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;状态state&#34;&gt;&#xA;  状态(State)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8a%b6%e6%80%81state&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 状态便于扩展, 方法不便扩展。如果相反用switch&#xA;public class MM {&#xA;    MMState state;&#xA;    public void smile(){&#xA;        state.smile();&#xA;    }&#xA;}&#xA;public abstract class MMState {&#xA;    abstract void smile();&#xA;}&#xA;public class MMHappyState extends MMState {&#xA;    @Override&#xA;    void smile(){}&#xA;}&#xA;&#xA;# FSM例子，线程状态&#xA;public class Thread_ {&#xA;    ThreadState_ state;&#xA;    void move(Action a) { state.move(a);}&#xA;}&#xA;abstract class ThreadState_ {&#xA;    abstract void move(Action a);&#xA;}&#xA;public class NewState extends ThreadState_ {&#xA;    private Thread_ t;&#xA;    @Override&#xA;    void move(Action a) {&#xA;        if (&amp;quot;start&amp;quot;.equals(a.msg)) {&#xA;            t.state = new RunningState(t);&#xA;        }&#xA;    }&#xA;}&#xA;public class Action {&#xA;    String msg;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;迭代器iterator&#34;&gt;&#xA;  迭代器(Iterator)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e5%99%a8iterator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;public interface Iterator&amp;lt;E&amp;gt; {&#xA;    boolean hasNext();&#xA;    E next();&#xA;}&#xA;public interface Collection&amp;lt;E&amp;gt; {&#xA;    Iterator&amp;lt;E&amp;gt; iterator();&#xA;}&#xA;class List&amp;lt;E&amp;gt; implements Collection&amp;lt;E&amp;gt; {&#xA;    private class Itr&amp;lt;E&amp;gt; implements Iterator&amp;lt;E&amp;gt; {&#xA;        @Override&#xA;        public boolean hasNext(){}&#xA;        @Override&#xA;        public E next(){}&#xA;    }&#xA;    @Override&#xA;    public Iterator iterator(){&#xA;        return new Itr();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;策略&#34;&gt;&#xA;  策略&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ad%96%e7%95%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# strategy, 封装多个算法类, 更换策略，调用方式一致&#xA;o-&amp;gt;&#xA;public interface ICalculator {&#xA;    public int calculate(String exp);&#xA;}&#xA;public class Minus extends AbstractCaculator implements ICalculator {&#xA;    @Override&#xA;    public int calculate(String exp) {&#xA;        int arrayInt[] = split(exp, &amp;quot;-&amp;quot;);&#xA;        return arrayInt[0] - arrayInt[1];&#xA;    }&#xA;}&#xA;public class AbstractCalculator {&#xA;    public int[] split(String exp, String opt) {&#xA;        String[] array = exp.split(opt);&#xA;        int arrayInt[] = new int[2];&#xA;        arrayInt[0] = Integer.parseInt(array[0]);&#xA;        arrayInt[1] = Integer.parseInt(array[1]);&#xA;        return arrayInt;&#xA;    }&#xA;}&#xA;Icalculator cal = new Minus();&#xA;cal.calculate(exp);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;备忘录memento&#34;&gt;&#xA;  备忘录(Memento)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%87%e5%bf%98%e5%bd%95memento&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 快照&#xA;# Java序列化, ProtoBuf库&#xA;class C implements Serializable {&#xA;    private transient List&amp;lt;Object&amp;gt; list;&#xA;}&#xA;ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&amp;quot;&amp;quot;)));&#xA;oos.writeObject(o1)&#xA;oos.writeObject(o2)&#xA;ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&amp;quot;&amp;quot;)));&#xA;o1 = ois.readObject();&#xA;o2 = ois.readObject();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;命令command&#34;&gt;&#xA;  命令(Command)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4command&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 别名Action或Transaction&#xA;# 配合组合实现宏命令, 配合责任链实现undo，配合备忘录实现事务回滚&#xA;abstract class Command {&#xA;    abstract void do();&#xA;    abstract void undo();&#xA;}&#xA;class InsertCommand extends Command {}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;责任链chain-of-responsibility&#34;&gt;&#xA;  责任链(Chain of Responsibility)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%a3%e4%bb%bb%e9%93%bechain-of-responsibility&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;interface Filter {&#xA;    boolean doFilter(Msg m);&#xA;}&#xA;class HTMLFilter implements Filter {}&#xA;class FilterChain implements Filter{&#xA;    List&amp;lt;Filter&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;();&#xA;    public boolean doFilter(Msg msg){&#xA;        for (Filter f : filters) {&#xA;            if (!f.doFilter(msg)) {&#xA;                return false;&#xA;            }&#xA;        }&#xA;        return true;&#xA;    }&#xA;    public FilterChain add(Filter f) {&#xA;        filters.add(f);&#xA;        return this;&#xA;    }&#xA;}&#xA;FilterChain fc = new FilterChain();&#xA;FilterChain fc2 = new FilterChain();&#xA;Filter f = new Filter();&#xA;fc.add(f).add(fc2);&#xA;&#xA;# ServletFilter&#xA;Filter1 implements Filter {&#xA;    void doFilter(req, resp, chain) {&#xA;        chain.doFilter(req, resp);&#xA;    }&#xA;}&#xA;FilterChain implements Filter {&#xA;    List&amp;lt;Filter&amp;gt; filters;&#xA;    int curIndex = 0;&#xA;    void doFilter(req, resp){&#xA;        curIndex++;&#xA;        if (curIndex &amp;lt; filters.size()) {&#xA;            filters[curIndex].doFilter(req, resp, this);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;访问者visitor&#34;&gt;&#xA;  访问者(Visitor)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%bf%e9%97%ae%e8%80%85visitor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 内部结构不变，访问方式扩展&#xA;interface Visitor {&#xA;    void visitCpu(CPU cpu);&#xA;} &#xA;class Visitor1 implements Visitor {&#xA;    double price = 0.0;&#xA;    @Override&#xA;    void visitCpu(CPU cpu) {&#xA;        price += cpu.getPrice() * 0.9;&#xA;    }&#xA;}&#xA;class Computer {&#xA;    Part cpu;&#xA;    void accept(Visitor v) {&#xA;        this.cpu.accept(v);&#xA;    }&#xA;}&#xA;abstract class Part {&#xA;    abstract void accept(Visitor v);&#xA;    abstract double getPrice();&#xA;}&#xA;class CPU extends Part {&#xA;    @Override&#xA;    void accept(Visitor v){&#xA;        v.visitCpu(this);&#xA;    }&#xA;}&#xA;&#xA;Visitor p = new Visitor1();&#xA;new Computer().accept(p);&#xA;p.price;&#xA;&#xA;# Java类AST编译器Visitor, ASM&#xA;// 打印&#xA;class ClassPrinter extends ClassVisitor {&#xA;    @Override&#xA;    MethodVisitor visitMethod(){&#xA;        print(name + &amp;quot;()&amp;quot;);&#xA;        retrun null;&#xA;    }&#xA;}&#xA;ClassPrinter cp = new ClassPrinter();&#xA;ClassReader cr = new ClassReader(&amp;quot;java.lang.Runnable&amp;quot;);&#xA;cr.accept(cp, 0);&#xA;&#xA;// 生成类&#xA;ClassWriter cw = new ClassWriter(0);&#xA;cw.visitMethod(ACC_PULIC + ACC_ABSTRACT, &amp;quot;compareTo&amp;quot;, &amp;quot;(Ljava/lang/Object;)I&amp;quot;, null, null).visitEnd();&#xA;cw.visitEnd();&#xA;MyClassLoader cl = new MyClassLoader();&#xA;byte[] b = cw.toByteArray();&#xA;Class c = cl.defineClass(&amp;quot;pkg.Comparable&amp;quot;, b, 0, b.length);&#xA;&#xA;// 代理类&#xA;ClassReader cr = new ClassReader();&#xA;ClassWriter cw = new ClassWriter(0);&#xA;ClassVisitor cv = new ClassVisitor(ASM4, cw) {&#xA;    @Override&#xA;    public MethodVisitor visitMethod() {&#xA;        MethodVisitor mv = super.visitMethod(); &#xA;        return new MethodVisitor(ASM4, mv) {&#xA;            @Override&#xA;            public void visitCode(){&#xA;                visitMethodInsn(INVOKESTATIC, &amp;quot;TimeProxy&amp;quot;, &amp;quot;before&amp;quot;, &amp;quot;()v&amp;quot;, false);&#xA;                super.visitCode();&#xA;            }&#xA;        }&#xA;    }&#xA;};&#xA;cr.accept(cv, 0);&#xA;cw.toByteArray();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;解释器intepreter&#34;&gt;&#xA;  解释器(Intepreter)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e9%87%8a%e5%99%a8intepreter&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 解释出AST&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;其它补充&#34;&gt;&#xA;  其它补充&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b6%e5%ae%83%e8%a1%a5%e5%85%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;元素模式&#xA;    # 抽象各模式成元素，简化表示&#xA;actor&#xA;    # 消息通信&#xA;reactor&#xA;    # 事件轮循，注册回调，如libevent&#xA;proactor&#xA;    # 注册事件回调，os通知触发回调&#xA;惰性求值&#xA;    链式定义(配方)，后自动触发(js tick调度)终止操作&#xA;dsl测试(如jasmine.js)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
