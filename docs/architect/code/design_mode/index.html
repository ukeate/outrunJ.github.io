<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  六个原则
  #

单一职责原则(SRP, Single Responsibility Principle)
    一个类只做一件事，应该只有一个引起它修改的原因
开闭原则(OCP, Open-Close Principle)
    对修改封闭，对扩展开放
里氏替换原则(LSP, the Liskov Substitution Principle)
    子类可以完全替换父类。也就是继承只扩展新功能
依赖倒置原则(DIP, the Dependency Inversion Principle)
    细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定
接口隔离原则(ISP, the Interface Segregation Principle)
    客户端不依赖它不需要的接口。冗余依赖应该将接口拆分
迪米特法则（最少知道原则）(LoD, Law of Demeter)
    一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话


  构建型
  #


  工厂方法(Factory Method)
  #

# 简单工厂, 根据参数创建不同的类
# 静态工厂，单例工厂
public interface Sender{
    public void Send();
}
public class MySender implements Sender{
    @Override
    public void Send(){}
}
public SenderFactory {
    public static Sender produceStatic() {
        return new MySender();
    }
    public Sender produce(){
        return new MySender();
    }
    public Sender produce(int i){
        return new MySender();
    }
}

# 工厂子类继承工厂接口, 不同产品对应不同工厂
public interface AbstractFactory {
    public MySender produce();
}
public class MyFactory implements AbstractFactory {
    @Override
    public MySender produce(){
        return new MySender();
    }
}


  抽象工厂(Abstract Factory)
  #

# 生产抽象产品
public interface AbstractFactory {
    public Sender produce();
}
public class MyFactory implements AbstractFactory {
    @Override
    public Sender produce(){
        return new MySender();
    }
}


  单例(Singleton)
  #

确保只有一个实例
    # 大多有资源管理器的功能
    # 反射机制会使所有单例失效：私有构造方法可以被访问
应用
    线程池
    缓存
    日志对象
    对话框
    打印机
    显卡驱动程序
o-&gt; 饿汉
public class Singleton {
    public static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return instance;
    }
}
o-&gt; 懒汉式
public class Singleton {
    private static Singleton single=null;
    private Singleton() {}
    public synchronized  static Singleton getInstance() {
        if (single == null) {
            single = new Singleton();
        }
        return single;
    }
}
o-&gt; 懒汉，双重检测(DCL)
    # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。
    # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized
public class Singleton {
    private static volatile Singleton singleton = null;
        # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。
    private Singleton(){}
    public static Singleton getInstance(){
        if (singleton == null) {
            // t1,t2并发进入
            synchronized (Singleton.class) {
                // t1释放后，t2进入
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
o-&gt; map注册
    # 学Spring，将类名注册
public class Singleton {
    private static Map&lt;String,Singleton&gt; map = new HashMap&lt;String,Singleton&gt;();
    static{
        Singleton single = new Singleton();
        map.put(single.getClass().getName(), single);
    }
    protected Singleton(){}
    public static Singleton getInstance(String name) {
        if(name == null) {
            name = Singleton.class.getName();
        }
        if(map.get(name) == null) {
            map.put(name, (Singleton) Class.forName(name).newInstance());
        }
        return map.get(name);
    }
}


  建造者(Builder)
  #

# 提供工厂方法，建造内部复合对象
o-&gt;
public class Builder {
    private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;();
    public void produceMailSender() {
        list.add(new MailSender())
    }
}


  原型(Prototype)
  #

# 复制原型来创建新对象


  结构型
  #


  适配器(Adapter)
  #

# 用来匹配接口
o-&gt; 类
public class Source(){
    public void method1(){}
}
public interface Targetable {
    public void method1()
    public void method2()
}
public class Adapter extends Source implements Targetable {
    @Override
    public void method2(){}
}
o-&gt; 对象
public class Wrapper implements Targetable {
    private Source source;
    public Wrapper(Source source){
        super();
        this.source = source;
    }
    @Override
    public void method1(){
        source.method1()
    }
    @Override
    public void method2(){}
}
o-&gt; 接口
public abstract class AbstractTarget implements Targetable {
    @Override
    public void method1(){}
}
public class Adapter extends AbstractTarget {
    @Override
    public method2(){}
}


  桥接(Bridge)
  #

# 分离抽象和具体(两个维度发展)分别继承，抽象聚合(桥接)具体
public abstract class Gift {
    GiftImpl impl;
}
public class Flower extends GiftImpl {}
public class WarmGift extends Gift {
    public WarmGift(GiftImpl impl) {
        this.impl = impl;
    }
}


  组合(Composite)
  #

# 树状结构
abstract class Node{}
class LeafNode extends Node{}
class BranchNode extends Node{
    List&lt;Node&gt; nodes = new ArrayList&lt;&gt;();
}

tree(Node b, int depth) {
    b.print();
    if (b instanceof BranchNode) {
        for (Node n : ((BranchNode)b).nodes){
            tree(n, depth&#43;1)
        }
    }
}


  装饰(Decorator)
  #

# 持有被装饰实例，实现同一接口
public interface Sourceable {
    public void method();
}
public class Source implements Sourceable {
    @Override
    public void method(){}
}
public class Decorator implements Sourceable {
    private Sourceable source;
    public Decorator(Sourceable source) {
        super();
        this.source = source;
    }
    @Override
    public void method() {
        source.method();
    }
}


  门面(Facade)
  #

# 对外接待


  中介者(Mediator)
  #

# 内部都只关联它，如mq


  享元(Flyweight)
  #

# 共享元数据


  代理
  #

# 静态代理，实现同装饰
class TankTimeProxy implements Movable {
    Movable m;
    @Override
    public void move(){
        m.move();
    }
}

# 动态代理，Proxy调asm生成代理类
Tank tank = new Tank();
Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader()), 
    new Class[]{Movable.class},
    new Hander(tank)
);
class Handler implements InvocationHandler {
    Tank tank;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        return method.invoke(tank, args);
    }
}

// 动态代理, CGLIB调asm，由于是继承，所以final类不能代理
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(Tank.class);
enhancer.setCallback(new TimeMethodInterceptor());
Tank tank = (Tank)enhancer.create();
tank.move();
class TimeMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) {
        return methodProxy.invokeSuper(o, objects);
    }
}

// Spring AOP: aspect指定代理类, pointcut指定被代理方法


  行为型
  #


  观察者
  #

# Observer, 对象变化，对观察者广播
public interface Observer {
    public void update();
}
public class Observer1 implements Observer {
    @Override
    public void update(){}
}
public interface Subject{
    public void add(Observer observer);
    public void del(Observer observer);
    public void notifyObservers();
    public void operate()
}
public abstract class AbstractSubject implements Subject {
    private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;();
    @Override
    public void add(Observer observer) {
        vector.add(observer);
    }
    @Override
    public void del(Observer observer) {
        vector.remove(observer);
    }
    @Override
    public void notifyObservers(){
        Enumeration&lt;Observer&gt; enumo = vector.elements();
        while (enumo.hasMoreElements()) {
            enumo.nextElement().update();
        }
    }
}
public class MySubject extends AbstractSubject {
    @Override
    public void operate() {
        notifyObservers();
    }
}


  模板方法(TemplateMethod)
  #

# 钩子函数
abstract class F {
    public void m() {
        op1();
    }
    abstract void op1();
}
class C1 extends F {
    @Override
    void op1(){}
}


  状态(State)
  #

# 状态便于扩展, 方法不便扩展。如果相反用switch
public class MM {
    MMState state;
    public void smile(){
        state.smile();
    }
}
public abstract class MMState {
    abstract void smile();
}
public class MMHappyState extends MMState {
    @Override
    void smile(){}
}

# FSM例子，线程状态
public class Thread_ {
    ThreadState_ state;
    void move(Action a) { state.move(a);}
}
abstract class ThreadState_ {
    abstract void move(Action a);
}
public class NewState extends ThreadState_ {
    private Thread_ t;
    @Override
    void move(Action a) {
        if (&quot;start&quot;.equals(a.msg)) {
            t.state = new RunningState(t);
        }
    }
}
public class Action {
    String msg;
}


  迭代器(Iterator)
  #

public interface Iterator&lt;E&gt; {
    boolean hasNext();
    E next();
}
public interface Collection&lt;E&gt; {
    Iterator&lt;E&gt; iterator();
}
class List&lt;E&gt; implements Collection&lt;E&gt; {
    private class Itr&lt;E&gt; implements Iterator&lt;E&gt; {
        @Override
        public boolean hasNext(){}
        @Override
        public E next(){}
    }
    @Override
    public Iterator iterator(){
        return new Itr();
    }
}


  策略
  #

# strategy, 封装多个算法类, 更换策略，调用方式一致
o-&gt;
public interface ICalculator {
    public int calculate(String exp);
}
public class Minus extends AbstractCaculator implements ICalculator {
    @Override
    public int calculate(String exp) {
        int arrayInt[] = split(exp, &quot;-&quot;);
        return arrayInt[0] - arrayInt[1];
    }
}
public class AbstractCalculator {
    public int[] split(String exp, String opt) {
        String[] array = exp.split(opt);
        int arrayInt[] = new int[2];
        arrayInt[0] = Integer.parseInt(array[0]);
        arrayInt[1] = Integer.parseInt(array[1]);
        return arrayInt;
    }
}
Icalculator cal = new Minus();
cal.calculate(exp);


  备忘录(Memento)
  #

# 快照
# Java序列化, ProtoBuf库
class C implements Serializable {
    private transient List&lt;Object&gt; list;
}
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;&quot;)));
oos.writeObject(o1)
oos.writeObject(o2)
ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;&quot;)));
o1 = ois.readObject();
o2 = ois.readObject();


  命令(Command)
  #

# 别名Action或Transaction
# 配合组合实现宏命令, 配合责任链实现undo，配合备忘录实现事务回滚
abstract class Command {
    abstract void do();
    abstract void undo();
}
class InsertCommand extends Command {}


  责任链(Chain of Responsibility)
  #

interface Filter {
    boolean doFilter(Msg m);
}
class HTMLFilter implements Filter {}
class FilterChain implements Filter{
    List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();
    public boolean doFilter(Msg msg){
        for (Filter f : filters) {
            if (!f.doFilter(msg)) {
                return false;
            }
        }
        return true;
    }
    public FilterChain add(Filter f) {
        filters.add(f);
        return this;
    }
}
FilterChain fc = new FilterChain();
FilterChain fc2 = new FilterChain();
Filter f = new Filter();
fc.add(f).add(fc2);

# ServletFilter
Filter1 implements Filter {
    void doFilter(req, resp, chain) {
        chain.doFilter(req, resp);
    }
}
FilterChain implements Filter {
    List&lt;Filter&gt; filters;
    int curIndex = 0;
    void doFilter(req, resp){
        curIndex&#43;&#43;;
        if (curIndex &lt; filters.size()) {
            filters[curIndex].doFilter(req, resp, this);
        }
    }
}


  访问者(Visitor)
  #

# 内部结构不变，访问方式扩展
interface Visitor {
    void visitCpu(CPU cpu);
} 
class Visitor1 implements Visitor {
    double price = 0.0;
    @Override
    void visitCpu(CPU cpu) {
        price &#43;= cpu.getPrice() * 0.9;
    }
}
class Computer {
    Part cpu;
    void accept(Visitor v) {
        this.cpu.accept(v);
    }
}
abstract class Part {
    abstract void accept(Visitor v);
    abstract double getPrice();
}
class CPU extends Part {
    @Override
    void accept(Visitor v){
        v.visitCpu(this);
    }
}

Visitor p = new Visitor1();
new Computer().accept(p);
p.price;

# Java类AST编译器Visitor, ASM
// 打印
class ClassPrinter extends ClassVisitor {
    @Override
    MethodVisitor visitMethod(){
        print(name &#43; &quot;()&quot;);
        retrun null;
    }
}
ClassPrinter cp = new ClassPrinter();
ClassReader cr = new ClassReader(&quot;java.lang.Runnable&quot;);
cr.accept(cp, 0);

// 生成类
ClassWriter cw = new ClassWriter(0);
cw.visitMethod(ACC_PULIC &#43; ACC_ABSTRACT, &quot;compareTo&quot;, &quot;(Ljava/lang/Object;)I&quot;, null, null).visitEnd();
cw.visitEnd();
MyClassLoader cl = new MyClassLoader();
byte[] b = cw.toByteArray();
Class c = cl.defineClass(&quot;pkg.Comparable&quot;, b, 0, b.length);

// 代理类
ClassReader cr = new ClassReader();
ClassWriter cw = new ClassWriter(0);
ClassVisitor cv = new ClassVisitor(ASM4, cw) {
    @Override
    public MethodVisitor visitMethod() {
        MethodVisitor mv = super.visitMethod(); 
        return new MethodVisitor(ASM4, mv) {
            @Override
            public void visitCode(){
                visitMethodInsn(INVOKESTATIC, &quot;TimeProxy&quot;, &quot;before&quot;, &quot;()v&quot;, false);
                super.visitCode();
            }
        }
    }
};
cr.accept(cv, 0);
cw.toByteArray();


  解释器(Intepreter)
  #

# 解释出AST


  其它补充
  #

元素模式
    # 抽象各模式成元素，简化表示
actor
    # 消息通信
reactor
    # 事件轮循，注册回调，如libevent
proactor
    # 注册事件回调，os通知触发回调
惰性求值
    链式定义(配方)，后自动触发(js tick调度)终止操作
dsl测试(如jasmine.js)
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://runout.run/docs/architect/code/design_mode/">
  <meta property="og:site_name" content="outrun的笔记">
  <meta property="og:title" content="Java设计模式">
  <meta property="og:description" content="六个原则 # 单一职责原则(SRP, Single Responsibility Principle) 一个类只做一件事，应该只有一个引起它修改的原因 开闭原则(OCP, Open-Close Principle) 对修改封闭，对扩展开放 里氏替换原则(LSP, the Liskov Substitution Principle) 子类可以完全替换父类。也就是继承只扩展新功能 依赖倒置原则(DIP, the Dependency Inversion Principle) 细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定 接口隔离原则(ISP, the Interface Segregation Principle) 客户端不依赖它不需要的接口。冗余依赖应该将接口拆分 迪米特法则（最少知道原则）(LoD, Law of Demeter) 一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话 构建型 # 工厂方法(Factory Method) # # 简单工厂, 根据参数创建不同的类 # 静态工厂，单例工厂 public interface Sender{ public void Send(); } public class MySender implements Sender{ @Override public void Send(){} } public SenderFactory { public static Sender produceStatic() { return new MySender(); } public Sender produce(){ return new MySender(); } public Sender produce(int i){ return new MySender(); } } # 工厂子类继承工厂接口, 不同产品对应不同工厂 public interface AbstractFactory { public MySender produce(); } public class MyFactory implements AbstractFactory { @Override public MySender produce(){ return new MySender(); } } 抽象工厂(Abstract Factory) # # 生产抽象产品 public interface AbstractFactory { public Sender produce(); } public class MyFactory implements AbstractFactory { @Override public Sender produce(){ return new MySender(); } } 单例(Singleton) # 确保只有一个实例 # 大多有资源管理器的功能 # 反射机制会使所有单例失效：私有构造方法可以被访问 应用 线程池 缓存 日志对象 对话框 打印机 显卡驱动程序 o-&gt; 饿汉 public class Singleton { public static Singleton instance = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return instance; } } o-&gt; 懒汉式 public class Singleton { private static Singleton single=null; private Singleton() {} public synchronized static Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; } } o-&gt; 懒汉，双重检测(DCL) # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。 # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized public class Singleton { private static volatile Singleton singleton = null; # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。 private Singleton(){} public static Singleton getInstance(){ if (singleton == null) { // t1,t2并发进入 synchronized (Singleton.class) { // t1释放后，t2进入 if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } o-&gt; map注册 # 学Spring，将类名注册 public class Singleton { private static Map&lt;String,Singleton&gt; map = new HashMap&lt;String,Singleton&gt;(); static{ Singleton single = new Singleton(); map.put(single.getClass().getName(), single); } protected Singleton(){} public static Singleton getInstance(String name) { if(name == null) { name = Singleton.class.getName(); } if(map.get(name) == null) { map.put(name, (Singleton) Class.forName(name).newInstance()); } return map.get(name); } } 建造者(Builder) # # 提供工厂方法，建造内部复合对象 o-&gt; public class Builder { private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender() { list.add(new MailSender()) } } 原型(Prototype) # # 复制原型来创建新对象 结构型 # 适配器(Adapter) # # 用来匹配接口 o-&gt; 类 public class Source(){ public void method1(){} } public interface Targetable { public void method1() public void method2() } public class Adapter extends Source implements Targetable { @Override public void method2(){} } o-&gt; 对象 public class Wrapper implements Targetable { private Source source; public Wrapper(Source source){ super(); this.source = source; } @Override public void method1(){ source.method1() } @Override public void method2(){} } o-&gt; 接口 public abstract class AbstractTarget implements Targetable { @Override public void method1(){} } public class Adapter extends AbstractTarget { @Override public method2(){} } 桥接(Bridge) # # 分离抽象和具体(两个维度发展)分别继承，抽象聚合(桥接)具体 public abstract class Gift { GiftImpl impl; } public class Flower extends GiftImpl {} public class WarmGift extends Gift { public WarmGift(GiftImpl impl) { this.impl = impl; } } 组合(Composite) # # 树状结构 abstract class Node{} class LeafNode extends Node{} class BranchNode extends Node{ List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); } tree(Node b, int depth) { b.print(); if (b instanceof BranchNode) { for (Node n : ((BranchNode)b).nodes){ tree(n, depth&#43;1) } } } 装饰(Decorator) # # 持有被装饰实例，实现同一接口 public interface Sourceable { public void method(); } public class Source implements Sourceable { @Override public void method(){} } public class Decorator implements Sourceable { private Sourceable source; public Decorator(Sourceable source) { super(); this.source = source; } @Override public void method() { source.method(); } } 门面(Facade) # # 对外接待 中介者(Mediator) # # 内部都只关联它，如mq 享元(Flyweight) # # 共享元数据 代理 # # 静态代理，实现同装饰 class TankTimeProxy implements Movable { Movable m; @Override public void move(){ m.move(); } } # 动态代理，Proxy调asm生成代理类 Tank tank = new Tank(); Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader()), new Class[]{Movable.class}, new Hander(tank) ); class Handler implements InvocationHandler { Tank tank; @Override public Object invoke(Object proxy, Method method, Object[] args) { return method.invoke(tank, args); } } // 动态代理, CGLIB调asm，由于是继承，所以final类不能代理 Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(Tank.class); enhancer.setCallback(new TimeMethodInterceptor()); Tank tank = (Tank)enhancer.create(); tank.move(); class TimeMethodInterceptor implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) { return methodProxy.invokeSuper(o, objects); } } // Spring AOP: aspect指定代理类, pointcut指定被代理方法 行为型 # 观察者 # # Observer, 对象变化，对观察者广播 public interface Observer { public void update(); } public class Observer1 implements Observer { @Override public void update(){} } public interface Subject{ public void add(Observer observer); public void del(Observer observer); public void notifyObservers(); public void operate() } public abstract class AbstractSubject implements Subject { private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) { vector.add(observer); } @Override public void del(Observer observer) { vector.remove(observer); } @Override public void notifyObservers(){ Enumeration&lt;Observer&gt; enumo = vector.elements(); while (enumo.hasMoreElements()) { enumo.nextElement().update(); } } } public class MySubject extends AbstractSubject { @Override public void operate() { notifyObservers(); } } 模板方法(TemplateMethod) # # 钩子函数 abstract class F { public void m() { op1(); } abstract void op1(); } class C1 extends F { @Override void op1(){} } 状态(State) # # 状态便于扩展, 方法不便扩展。如果相反用switch public class MM { MMState state; public void smile(){ state.smile(); } } public abstract class MMState { abstract void smile(); } public class MMHappyState extends MMState { @Override void smile(){} } # FSM例子，线程状态 public class Thread_ { ThreadState_ state; void move(Action a) { state.move(a);} } abstract class ThreadState_ { abstract void move(Action a); } public class NewState extends ThreadState_ { private Thread_ t; @Override void move(Action a) { if (&#34;start&#34;.equals(a.msg)) { t.state = new RunningState(t); } } } public class Action { String msg; } 迭代器(Iterator) # public interface Iterator&lt;E&gt; { boolean hasNext(); E next(); } public interface Collection&lt;E&gt; { Iterator&lt;E&gt; iterator(); } class List&lt;E&gt; implements Collection&lt;E&gt; { private class Itr&lt;E&gt; implements Iterator&lt;E&gt; { @Override public boolean hasNext(){} @Override public E next(){} } @Override public Iterator iterator(){ return new Itr(); } } 策略 # # strategy, 封装多个算法类, 更换策略，调用方式一致 o-&gt; public interface ICalculator { public int calculate(String exp); } public class Minus extends AbstractCaculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp, &#34;-&#34;); return arrayInt[0] - arrayInt[1]; } } public class AbstractCalculator { public int[] split(String exp, String opt) { String[] array = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; } } Icalculator cal = new Minus(); cal.calculate(exp); 备忘录(Memento) # # 快照 # Java序列化, ProtoBuf库 class C implements Serializable { private transient List&lt;Object&gt; list; } ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&#34;&#34;))); oos.writeObject(o1) oos.writeObject(o2) ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&#34;&#34;))); o1 = ois.readObject(); o2 = ois.readObject(); 命令(Command) # # 别名Action或Transaction # 配合组合实现宏命令, 配合责任链实现undo，配合备忘录实现事务回滚 abstract class Command { abstract void do(); abstract void undo(); } class InsertCommand extends Command {} 责任链(Chain of Responsibility) # interface Filter { boolean doFilter(Msg m); } class HTMLFilter implements Filter {} class FilterChain implements Filter{ List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); public boolean doFilter(Msg msg){ for (Filter f : filters) { if (!f.doFilter(msg)) { return false; } } return true; } public FilterChain add(Filter f) { filters.add(f); return this; } } FilterChain fc = new FilterChain(); FilterChain fc2 = new FilterChain(); Filter f = new Filter(); fc.add(f).add(fc2); # ServletFilter Filter1 implements Filter { void doFilter(req, resp, chain) { chain.doFilter(req, resp); } } FilterChain implements Filter { List&lt;Filter&gt; filters; int curIndex = 0; void doFilter(req, resp){ curIndex&#43;&#43;; if (curIndex &lt; filters.size()) { filters[curIndex].doFilter(req, resp, this); } } } 访问者(Visitor) # # 内部结构不变，访问方式扩展 interface Visitor { void visitCpu(CPU cpu); } class Visitor1 implements Visitor { double price = 0.0; @Override void visitCpu(CPU cpu) { price &#43;= cpu.getPrice() * 0.9; } } class Computer { Part cpu; void accept(Visitor v) { this.cpu.accept(v); } } abstract class Part { abstract void accept(Visitor v); abstract double getPrice(); } class CPU extends Part { @Override void accept(Visitor v){ v.visitCpu(this); } } Visitor p = new Visitor1(); new Computer().accept(p); p.price; # Java类AST编译器Visitor, ASM // 打印 class ClassPrinter extends ClassVisitor { @Override MethodVisitor visitMethod(){ print(name &#43; &#34;()&#34;); retrun null; } } ClassPrinter cp = new ClassPrinter(); ClassReader cr = new ClassReader(&#34;java.lang.Runnable&#34;); cr.accept(cp, 0); // 生成类 ClassWriter cw = new ClassWriter(0); cw.visitMethod(ACC_PULIC &#43; ACC_ABSTRACT, &#34;compareTo&#34;, &#34;(Ljava/lang/Object;)I&#34;, null, null).visitEnd(); cw.visitEnd(); MyClassLoader cl = new MyClassLoader(); byte[] b = cw.toByteArray(); Class c = cl.defineClass(&#34;pkg.Comparable&#34;, b, 0, b.length); // 代理类 ClassReader cr = new ClassReader(); ClassWriter cw = new ClassWriter(0); ClassVisitor cv = new ClassVisitor(ASM4, cw) { @Override public MethodVisitor visitMethod() { MethodVisitor mv = super.visitMethod(); return new MethodVisitor(ASM4, mv) { @Override public void visitCode(){ visitMethodInsn(INVOKESTATIC, &#34;TimeProxy&#34;, &#34;before&#34;, &#34;()v&#34;, false); super.visitCode(); } } } }; cr.accept(cv, 0); cw.toByteArray(); 解释器(Intepreter) # # 解释出AST 其它补充 # 元素模式 # 抽象各模式成元素，简化表示 actor # 消息通信 reactor # 事件轮循，注册回调，如libevent proactor # 注册事件回调，os通知触发回调 惰性求值 链式定义(配方)，后自动触发(js tick调度)终止操作 dsl测试(如jasmine.js)">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2018-10-09T08:48:07+08:00">
    <meta property="article:modified_time" content="2022-08-01T13:53:50+08:00">
<title>Java设计模式 | outrun的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://runout.run/docs/architect/code/design_mode/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.82b3d863368d576b09dc9142a93468d8170f7706990cff55b58bfe72c4930b4b.js" integrity="sha256-grPYYzaNV2sJ3JFCqTRo2BcPdwaZDP9VtYv&#43;csSTC0s=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span>outrun的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-28d9e6987399d0da843d24373bb5310b" class="toggle" checked />
    <label for="section-28d9e6987399d0da843d24373bb5310b" class="flex justify-between">
      <a href="/docs/architect/" class="">架构</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/" class="">代码</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/security/" class="">Security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/design_mode/" class="active">Java设计模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/" class="">工程设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/ddd/" class="">工程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/frontend/" class="">前端</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>战略性技术</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/" class="">AI</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/map/" class="">知识图谱</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/framework/" class="">Framework</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/media/" class="">媒体</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/middle_platform/" class="">中台</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/block_chain/" class="">Block Chain</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Cloud</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/" class="">Datalake</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/ecology/" class="">Ecology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/edge/" class="">Edge</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/" class="">Manage</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/" class="">组织</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/people/" class="">人员</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/" class="">Method</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/product_plan/" class="">产品规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/code_plan/" class="">代码规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/ops_plan/" class="">运维规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/advice_plan/" class="">咨询规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/architect/" class="">服务治理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/project_plan/" class="">项目规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/test_plan/" class="">测试规划</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/summary/" class="">这些年我做过的技术</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-669f1276b655f93b7e7c5d3bcda5ec19" class="toggle"  />
    <label for="section-669f1276b655f93b7e7c5d3bcda5ec19" class="flex justify-between">
      <a href="/docs/misc/" class="">杂项</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ad4b307ab1b99c68532f747347427ad2" class="toggle"  />
    <label for="section-ad4b307ab1b99c68532f747347427ad2" class="flex justify-between">
      <a href="/docs/middleware/" class="">中间件</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/" class="">支撑-分布式</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/spring_cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/" class="">前端</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/bootstrap/" class="">Bootstrap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/threejs/" class="">Threejs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/angular/" class="">Angular</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/jquery/" class="">Jquery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/react/" class="">React</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/" class="">小功能</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/hibernate/" class="">Hibernate</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Container</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nginx/" class="">Nginx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nodejs/" class="">Nodejs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9d4b4d3532e4d7688278a56c3607ee43" class="toggle"  />
    <label for="section-9d4b4d3532e4d7688278a56c3607ee43" class="flex justify-between">
      <a href="/docs/cache/" class="">Cache</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/ops/" class="">Ops</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/work_code/" class="">Work Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/template/" class="">模板配置</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/soft_arch/" class="">软考架构师</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-75015a3dca1e5254e5fd64787822da31" class="toggle"  />
    <label for="section-75015a3dca1e5254e5fd64787822da31" class="flex justify-between">
      <a href="/docs/basic/" class="">基本功</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/speach/" class="">演说</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/body/" class="">身体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/" class="">Computer</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/principle/" class="">支撑-原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/performance/" class="">Performance</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/" class="">算法</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/thought/" class="">算法思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/data_structure/" class="">数据结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/math/" class="">数学</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-57edaab097f41efb493c8fe5461c9d46" class="toggle"  />
    <label for="section-57edaab097f41efb493c8fe5461c9d46" class="flex justify-between">
      <a href="/docs/tool/" class="">工具</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/" class="">运维</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/monitor/" class="">Monitor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/docker/" class="">Docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/k8s/" class="">Kubernetes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/enterprise_system/" class="">企业级系统</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/" class="">Develop</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/eclipse/" class="">Eclipse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/vim/" class="">VIM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/apple/" class="">Apple</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/jetbrains/" class="">Jetbrains</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/" class="">Linux</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_program/" class="">LinuxProgram</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/scene/" class="">LinuxScene</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_tool/" class="">LinuxTool</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/framework/" class="">Framework</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/physics/" class="">实物工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/" class="">测试</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/debug/" class="">程序调试</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-42c70ef47fd41d9af53858047493d78c" class="toggle"  />
    <label for="section-42c70ef47fd41d9af53858047493d78c" class="flex justify-between">
      <a href="/docs/db/" class="">数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mongodb/" class="">Mongodb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/postgresql/" class="">Postgre SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/oracle/" class="">Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2c3dac8cc024b2be2734e956eea228c9" class="toggle"  />
    <label for="section-2c3dac8cc024b2be2734e956eea228c9" class="flex justify-between">
      <a href="/docs/pl/" class="">程序语言</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/principle/" class="">程序语言原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/haskell/" class="">Haskell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/elixir/" class="">Elixir</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/clojure/" class="">Clojure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/js/" class="">JS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/java_reactive/" class="">Java响应式编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/javaweb/" class="">JavaWeb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/juc/" class="">Java并发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/jvm/" class="">JVM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/collection/" class="">Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/spring/" class="">Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/" class="">Markup Language</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/html/" class="">Html</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/css/" class="">Css</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Java设计模式</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#六个原则">六个原则</a></li>
    <li><a href="#构建型">构建型</a>
      <ul>
        <li><a href="#工厂方法factory-method">工厂方法(Factory Method)</a></li>
        <li><a href="#抽象工厂abstract-factory">抽象工厂(Abstract Factory)</a></li>
        <li><a href="#单例singleton">单例(Singleton)</a></li>
        <li><a href="#建造者builder">建造者(Builder)</a></li>
        <li><a href="#原型prototype">原型(Prototype)</a></li>
      </ul>
    </li>
    <li><a href="#结构型">结构型</a>
      <ul>
        <li><a href="#适配器adapter">适配器(Adapter)</a></li>
        <li><a href="#桥接bridge">桥接(Bridge)</a></li>
        <li><a href="#组合composite">组合(Composite)</a></li>
        <li><a href="#装饰decorator">装饰(Decorator)</a></li>
        <li><a href="#门面facade">门面(Facade)</a></li>
        <li><a href="#中介者mediator">中介者(Mediator)</a></li>
        <li><a href="#享元flyweight">享元(Flyweight)</a></li>
        <li><a href="#代理">代理</a></li>
      </ul>
    </li>
    <li><a href="#行为型">行为型</a>
      <ul>
        <li><a href="#观察者">观察者</a></li>
        <li><a href="#模板方法templatemethod">模板方法(TemplateMethod)</a></li>
        <li><a href="#状态state">状态(State)</a></li>
        <li><a href="#迭代器iterator">迭代器(Iterator)</a></li>
        <li><a href="#策略">策略</a></li>
        <li><a href="#备忘录memento">备忘录(Memento)</a></li>
        <li><a href="#命令command">命令(Command)</a></li>
        <li><a href="#责任链chain-of-responsibility">责任链(Chain of Responsibility)</a></li>
        <li><a href="#访问者visitor">访问者(Visitor)</a></li>
        <li><a href="#解释器intepreter">解释器(Intepreter)</a></li>
      </ul>
    </li>
    <li><a href="#其它补充">其它补充</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="六个原则">
  六个原则
  <a class="anchor" href="#%e5%85%ad%e4%b8%aa%e5%8e%9f%e5%88%99">#</a>
</h1>
<pre><code>单一职责原则(SRP, Single Responsibility Principle)
    一个类只做一件事，应该只有一个引起它修改的原因
开闭原则(OCP, Open-Close Principle)
    对修改封闭，对扩展开放
里氏替换原则(LSP, the Liskov Substitution Principle)
    子类可以完全替换父类。也就是继承只扩展新功能
依赖倒置原则(DIP, the Dependency Inversion Principle)
    细节依赖于抽象,抽象不依赖于细节。抽象放在高层，并保持稳定
接口隔离原则(ISP, the Interface Segregation Principle)
    客户端不依赖它不需要的接口。冗余依赖应该将接口拆分
迪米特法则（最少知道原则）(LoD, Law of Demeter)
    一个类不应该知道自己操作的细节。只和朋友谈话，不和朋友的朋友谈话
</code></pre>
<h1 id="构建型">
  构建型
  <a class="anchor" href="#%e6%9e%84%e5%bb%ba%e5%9e%8b">#</a>
</h1>
<h2 id="工厂方法factory-method">
  工厂方法(Factory Method)
  <a class="anchor" href="#%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95factory-method">#</a>
</h2>
<pre><code># 简单工厂, 根据参数创建不同的类
# 静态工厂，单例工厂
public interface Sender{
    public void Send();
}
public class MySender implements Sender{
    @Override
    public void Send(){}
}
public SenderFactory {
    public static Sender produceStatic() {
        return new MySender();
    }
    public Sender produce(){
        return new MySender();
    }
    public Sender produce(int i){
        return new MySender();
    }
}

# 工厂子类继承工厂接口, 不同产品对应不同工厂
public interface AbstractFactory {
    public MySender produce();
}
public class MyFactory implements AbstractFactory {
    @Override
    public MySender produce(){
        return new MySender();
    }
}
</code></pre>
<h2 id="抽象工厂abstract-factory">
  抽象工厂(Abstract Factory)
  <a class="anchor" href="#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82abstract-factory">#</a>
</h2>
<pre><code># 生产抽象产品
public interface AbstractFactory {
    public Sender produce();
}
public class MyFactory implements AbstractFactory {
    @Override
    public Sender produce(){
        return new MySender();
    }
}
</code></pre>
<h2 id="单例singleton">
  单例(Singleton)
  <a class="anchor" href="#%e5%8d%95%e4%be%8bsingleton">#</a>
</h2>
<pre><code>确保只有一个实例
    # 大多有资源管理器的功能
    # 反射机制会使所有单例失效：私有构造方法可以被访问
应用
    线程池
    缓存
    日志对象
    对话框
    打印机
    显卡驱动程序
o-&gt; 饿汉
public class Singleton {
    public static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return instance;
    }
}
o-&gt; 懒汉式
public class Singleton {
    private static Singleton single=null;
    private Singleton() {}
    public synchronized  static Singleton getInstance() {
        if (single == null) {
            single = new Singleton();
        }
        return single;
    }
}
o-&gt; 懒汉，双重检测(DCL)
    # 解决问题并发创建问题。在不同jvm或多核cpu上，有无序写入bug。
    # 解决bug: 1 直接创建static属性, 2 get方法修饰synchronized
public class Singleton {
    private static volatile Singleton singleton = null;
        # volatile: t1编译singleton = new Singleton()时重排序把没初始化对象赋值给singleton时, t2判断singleton为null。
    private Singleton(){}
    public static Singleton getInstance(){
        if (singleton == null) {
            // t1,t2并发进入
            synchronized (Singleton.class) {
                // t1释放后，t2进入
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
o-&gt; map注册
    # 学Spring，将类名注册
public class Singleton {
    private static Map&lt;String,Singleton&gt; map = new HashMap&lt;String,Singleton&gt;();
    static{
        Singleton single = new Singleton();
        map.put(single.getClass().getName(), single);
    }
    protected Singleton(){}
    public static Singleton getInstance(String name) {
        if(name == null) {
            name = Singleton.class.getName();
        }
        if(map.get(name) == null) {
            map.put(name, (Singleton) Class.forName(name).newInstance());
        }
        return map.get(name);
    }
}
</code></pre>
<h2 id="建造者builder">
  建造者(Builder)
  <a class="anchor" href="#%e5%bb%ba%e9%80%a0%e8%80%85builder">#</a>
</h2>
<pre><code># 提供工厂方法，建造内部复合对象
o-&gt;
public class Builder {
    private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;();
    public void produceMailSender() {
        list.add(new MailSender())
    }
}
</code></pre>
<h2 id="原型prototype">
  原型(Prototype)
  <a class="anchor" href="#%e5%8e%9f%e5%9e%8bprototype">#</a>
</h2>
<pre><code># 复制原型来创建新对象
</code></pre>
<h1 id="结构型">
  结构型
  <a class="anchor" href="#%e7%bb%93%e6%9e%84%e5%9e%8b">#</a>
</h1>
<h2 id="适配器adapter">
  适配器(Adapter)
  <a class="anchor" href="#%e9%80%82%e9%85%8d%e5%99%a8adapter">#</a>
</h2>
<pre><code># 用来匹配接口
o-&gt; 类
public class Source(){
    public void method1(){}
}
public interface Targetable {
    public void method1()
    public void method2()
}
public class Adapter extends Source implements Targetable {
    @Override
    public void method2(){}
}
o-&gt; 对象
public class Wrapper implements Targetable {
    private Source source;
    public Wrapper(Source source){
        super();
        this.source = source;
    }
    @Override
    public void method1(){
        source.method1()
    }
    @Override
    public void method2(){}
}
o-&gt; 接口
public abstract class AbstractTarget implements Targetable {
    @Override
    public void method1(){}
}
public class Adapter extends AbstractTarget {
    @Override
    public method2(){}
}
</code></pre>
<h2 id="桥接bridge">
  桥接(Bridge)
  <a class="anchor" href="#%e6%a1%a5%e6%8e%a5bridge">#</a>
</h2>
<pre><code># 分离抽象和具体(两个维度发展)分别继承，抽象聚合(桥接)具体
public abstract class Gift {
    GiftImpl impl;
}
public class Flower extends GiftImpl {}
public class WarmGift extends Gift {
    public WarmGift(GiftImpl impl) {
        this.impl = impl;
    }
}
</code></pre>
<h2 id="组合composite">
  组合(Composite)
  <a class="anchor" href="#%e7%bb%84%e5%90%88composite">#</a>
</h2>
<pre><code># 树状结构
abstract class Node{}
class LeafNode extends Node{}
class BranchNode extends Node{
    List&lt;Node&gt; nodes = new ArrayList&lt;&gt;();
}

tree(Node b, int depth) {
    b.print();
    if (b instanceof BranchNode) {
        for (Node n : ((BranchNode)b).nodes){
            tree(n, depth+1)
        }
    }
}
</code></pre>
<h2 id="装饰decorator">
  装饰(Decorator)
  <a class="anchor" href="#%e8%a3%85%e9%a5%b0decorator">#</a>
</h2>
<pre><code># 持有被装饰实例，实现同一接口
public interface Sourceable {
    public void method();
}
public class Source implements Sourceable {
    @Override
    public void method(){}
}
public class Decorator implements Sourceable {
    private Sourceable source;
    public Decorator(Sourceable source) {
        super();
        this.source = source;
    }
    @Override
    public void method() {
        source.method();
    }
}
</code></pre>
<h2 id="门面facade">
  门面(Facade)
  <a class="anchor" href="#%e9%97%a8%e9%9d%a2facade">#</a>
</h2>
<pre><code># 对外接待
</code></pre>
<h2 id="中介者mediator">
  中介者(Mediator)
  <a class="anchor" href="#%e4%b8%ad%e4%bb%8b%e8%80%85mediator">#</a>
</h2>
<pre><code># 内部都只关联它，如mq
</code></pre>
<h2 id="享元flyweight">
  享元(Flyweight)
  <a class="anchor" href="#%e4%ba%ab%e5%85%83flyweight">#</a>
</h2>
<pre><code># 共享元数据
</code></pre>
<h2 id="代理">
  代理
  <a class="anchor" href="#%e4%bb%a3%e7%90%86">#</a>
</h2>
<pre><code># 静态代理，实现同装饰
class TankTimeProxy implements Movable {
    Movable m;
    @Override
    public void move(){
        m.move();
    }
}

# 动态代理，Proxy调asm生成代理类
Tank tank = new Tank();
Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader()), 
    new Class[]{Movable.class},
    new Hander(tank)
);
class Handler implements InvocationHandler {
    Tank tank;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        return method.invoke(tank, args);
    }
}

// 动态代理, CGLIB调asm，由于是继承，所以final类不能代理
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(Tank.class);
enhancer.setCallback(new TimeMethodInterceptor());
Tank tank = (Tank)enhancer.create();
tank.move();
class TimeMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) {
        return methodProxy.invokeSuper(o, objects);
    }
}

// Spring AOP: aspect指定代理类, pointcut指定被代理方法
</code></pre>
<h1 id="行为型">
  行为型
  <a class="anchor" href="#%e8%a1%8c%e4%b8%ba%e5%9e%8b">#</a>
</h1>
<h2 id="观察者">
  观察者
  <a class="anchor" href="#%e8%a7%82%e5%af%9f%e8%80%85">#</a>
</h2>
<pre><code># Observer, 对象变化，对观察者广播
public interface Observer {
    public void update();
}
public class Observer1 implements Observer {
    @Override
    public void update(){}
}
public interface Subject{
    public void add(Observer observer);
    public void del(Observer observer);
    public void notifyObservers();
    public void operate()
}
public abstract class AbstractSubject implements Subject {
    private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;();
    @Override
    public void add(Observer observer) {
        vector.add(observer);
    }
    @Override
    public void del(Observer observer) {
        vector.remove(observer);
    }
    @Override
    public void notifyObservers(){
        Enumeration&lt;Observer&gt; enumo = vector.elements();
        while (enumo.hasMoreElements()) {
            enumo.nextElement().update();
        }
    }
}
public class MySubject extends AbstractSubject {
    @Override
    public void operate() {
        notifyObservers();
    }
}
</code></pre>
<h2 id="模板方法templatemethod">
  模板方法(TemplateMethod)
  <a class="anchor" href="#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95templatemethod">#</a>
</h2>
<pre><code># 钩子函数
abstract class F {
    public void m() {
        op1();
    }
    abstract void op1();
}
class C1 extends F {
    @Override
    void op1(){}
}
</code></pre>
<h2 id="状态state">
  状态(State)
  <a class="anchor" href="#%e7%8a%b6%e6%80%81state">#</a>
</h2>
<pre><code># 状态便于扩展, 方法不便扩展。如果相反用switch
public class MM {
    MMState state;
    public void smile(){
        state.smile();
    }
}
public abstract class MMState {
    abstract void smile();
}
public class MMHappyState extends MMState {
    @Override
    void smile(){}
}

# FSM例子，线程状态
public class Thread_ {
    ThreadState_ state;
    void move(Action a) { state.move(a);}
}
abstract class ThreadState_ {
    abstract void move(Action a);
}
public class NewState extends ThreadState_ {
    private Thread_ t;
    @Override
    void move(Action a) {
        if (&quot;start&quot;.equals(a.msg)) {
            t.state = new RunningState(t);
        }
    }
}
public class Action {
    String msg;
}
</code></pre>
<h2 id="迭代器iterator">
  迭代器(Iterator)
  <a class="anchor" href="#%e8%bf%ad%e4%bb%a3%e5%99%a8iterator">#</a>
</h2>
<pre><code>public interface Iterator&lt;E&gt; {
    boolean hasNext();
    E next();
}
public interface Collection&lt;E&gt; {
    Iterator&lt;E&gt; iterator();
}
class List&lt;E&gt; implements Collection&lt;E&gt; {
    private class Itr&lt;E&gt; implements Iterator&lt;E&gt; {
        @Override
        public boolean hasNext(){}
        @Override
        public E next(){}
    }
    @Override
    public Iterator iterator(){
        return new Itr();
    }
}
</code></pre>
<h2 id="策略">
  策略
  <a class="anchor" href="#%e7%ad%96%e7%95%a5">#</a>
</h2>
<pre><code># strategy, 封装多个算法类, 更换策略，调用方式一致
o-&gt;
public interface ICalculator {
    public int calculate(String exp);
}
public class Minus extends AbstractCaculator implements ICalculator {
    @Override
    public int calculate(String exp) {
        int arrayInt[] = split(exp, &quot;-&quot;);
        return arrayInt[0] - arrayInt[1];
    }
}
public class AbstractCalculator {
    public int[] split(String exp, String opt) {
        String[] array = exp.split(opt);
        int arrayInt[] = new int[2];
        arrayInt[0] = Integer.parseInt(array[0]);
        arrayInt[1] = Integer.parseInt(array[1]);
        return arrayInt;
    }
}
Icalculator cal = new Minus();
cal.calculate(exp);
</code></pre>
<h2 id="备忘录memento">
  备忘录(Memento)
  <a class="anchor" href="#%e5%a4%87%e5%bf%98%e5%bd%95memento">#</a>
</h2>
<pre><code># 快照
# Java序列化, ProtoBuf库
class C implements Serializable {
    private transient List&lt;Object&gt; list;
}
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;&quot;)));
oos.writeObject(o1)
oos.writeObject(o2)
ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;&quot;)));
o1 = ois.readObject();
o2 = ois.readObject();
</code></pre>
<h2 id="命令command">
  命令(Command)
  <a class="anchor" href="#%e5%91%bd%e4%bb%a4command">#</a>
</h2>
<pre><code># 别名Action或Transaction
# 配合组合实现宏命令, 配合责任链实现undo，配合备忘录实现事务回滚
abstract class Command {
    abstract void do();
    abstract void undo();
}
class InsertCommand extends Command {}
</code></pre>
<h2 id="责任链chain-of-responsibility">
  责任链(Chain of Responsibility)
  <a class="anchor" href="#%e8%b4%a3%e4%bb%bb%e9%93%bechain-of-responsibility">#</a>
</h2>
<pre><code>interface Filter {
    boolean doFilter(Msg m);
}
class HTMLFilter implements Filter {}
class FilterChain implements Filter{
    List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();
    public boolean doFilter(Msg msg){
        for (Filter f : filters) {
            if (!f.doFilter(msg)) {
                return false;
            }
        }
        return true;
    }
    public FilterChain add(Filter f) {
        filters.add(f);
        return this;
    }
}
FilterChain fc = new FilterChain();
FilterChain fc2 = new FilterChain();
Filter f = new Filter();
fc.add(f).add(fc2);

# ServletFilter
Filter1 implements Filter {
    void doFilter(req, resp, chain) {
        chain.doFilter(req, resp);
    }
}
FilterChain implements Filter {
    List&lt;Filter&gt; filters;
    int curIndex = 0;
    void doFilter(req, resp){
        curIndex++;
        if (curIndex &lt; filters.size()) {
            filters[curIndex].doFilter(req, resp, this);
        }
    }
}
</code></pre>
<h2 id="访问者visitor">
  访问者(Visitor)
  <a class="anchor" href="#%e8%ae%bf%e9%97%ae%e8%80%85visitor">#</a>
</h2>
<pre><code># 内部结构不变，访问方式扩展
interface Visitor {
    void visitCpu(CPU cpu);
} 
class Visitor1 implements Visitor {
    double price = 0.0;
    @Override
    void visitCpu(CPU cpu) {
        price += cpu.getPrice() * 0.9;
    }
}
class Computer {
    Part cpu;
    void accept(Visitor v) {
        this.cpu.accept(v);
    }
}
abstract class Part {
    abstract void accept(Visitor v);
    abstract double getPrice();
}
class CPU extends Part {
    @Override
    void accept(Visitor v){
        v.visitCpu(this);
    }
}

Visitor p = new Visitor1();
new Computer().accept(p);
p.price;

# Java类AST编译器Visitor, ASM
// 打印
class ClassPrinter extends ClassVisitor {
    @Override
    MethodVisitor visitMethod(){
        print(name + &quot;()&quot;);
        retrun null;
    }
}
ClassPrinter cp = new ClassPrinter();
ClassReader cr = new ClassReader(&quot;java.lang.Runnable&quot;);
cr.accept(cp, 0);

// 生成类
ClassWriter cw = new ClassWriter(0);
cw.visitMethod(ACC_PULIC + ACC_ABSTRACT, &quot;compareTo&quot;, &quot;(Ljava/lang/Object;)I&quot;, null, null).visitEnd();
cw.visitEnd();
MyClassLoader cl = new MyClassLoader();
byte[] b = cw.toByteArray();
Class c = cl.defineClass(&quot;pkg.Comparable&quot;, b, 0, b.length);

// 代理类
ClassReader cr = new ClassReader();
ClassWriter cw = new ClassWriter(0);
ClassVisitor cv = new ClassVisitor(ASM4, cw) {
    @Override
    public MethodVisitor visitMethod() {
        MethodVisitor mv = super.visitMethod(); 
        return new MethodVisitor(ASM4, mv) {
            @Override
            public void visitCode(){
                visitMethodInsn(INVOKESTATIC, &quot;TimeProxy&quot;, &quot;before&quot;, &quot;()v&quot;, false);
                super.visitCode();
            }
        }
    }
};
cr.accept(cv, 0);
cw.toByteArray();
</code></pre>
<h2 id="解释器intepreter">
  解释器(Intepreter)
  <a class="anchor" href="#%e8%a7%a3%e9%87%8a%e5%99%a8intepreter">#</a>
</h2>
<pre><code># 解释出AST
</code></pre>
<h1 id="其它补充">
  其它补充
  <a class="anchor" href="#%e5%85%b6%e5%ae%83%e8%a1%a5%e5%85%85">#</a>
</h1>
<pre><code>元素模式
    # 抽象各模式成元素，简化表示
actor
    # 消息通信
reactor
    # 事件轮循，注册回调，如libevent
proactor
    # 注册事件回调，os通知触发回调
惰性求值
    链式定义(配方)，后自动触发(js tick调度)终止操作
dsl测试(如jasmine.js)
</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/commit/7a0830e2309b37cfb47cba7117b4883168023ed7" title='Last modified by outrun | Jul 31, 2022' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="" />
      <span>Jul 31, 2022</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/tree/master/content/content/docs/architect/code/design_mode.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#六个原则">六个原则</a></li>
    <li><a href="#构建型">构建型</a>
      <ul>
        <li><a href="#工厂方法factory-method">工厂方法(Factory Method)</a></li>
        <li><a href="#抽象工厂abstract-factory">抽象工厂(Abstract Factory)</a></li>
        <li><a href="#单例singleton">单例(Singleton)</a></li>
        <li><a href="#建造者builder">建造者(Builder)</a></li>
        <li><a href="#原型prototype">原型(Prototype)</a></li>
      </ul>
    </li>
    <li><a href="#结构型">结构型</a>
      <ul>
        <li><a href="#适配器adapter">适配器(Adapter)</a></li>
        <li><a href="#桥接bridge">桥接(Bridge)</a></li>
        <li><a href="#组合composite">组合(Composite)</a></li>
        <li><a href="#装饰decorator">装饰(Decorator)</a></li>
        <li><a href="#门面facade">门面(Facade)</a></li>
        <li><a href="#中介者mediator">中介者(Mediator)</a></li>
        <li><a href="#享元flyweight">享元(Flyweight)</a></li>
        <li><a href="#代理">代理</a></li>
      </ul>
    </li>
    <li><a href="#行为型">行为型</a>
      <ul>
        <li><a href="#观察者">观察者</a></li>
        <li><a href="#模板方法templatemethod">模板方法(TemplateMethod)</a></li>
        <li><a href="#状态state">状态(State)</a></li>
        <li><a href="#迭代器iterator">迭代器(Iterator)</a></li>
        <li><a href="#策略">策略</a></li>
        <li><a href="#备忘录memento">备忘录(Memento)</a></li>
        <li><a href="#命令command">命令(Command)</a></li>
        <li><a href="#责任链chain-of-responsibility">责任链(Chain of Responsibility)</a></li>
        <li><a href="#访问者visitor">访问者(Visitor)</a></li>
        <li><a href="#解释器intepreter">解释器(Intepreter)</a></li>
      </ul>
    </li>
    <li><a href="#其它补充">其它补充</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












