<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer on ukeate的笔记</title>
    <link>https://ukeate.com/docs/basic/computer/</link>
    <description>Recent content in Computer on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 01 Aug 2022 13:53:50 +0800</lastBuildDate>
    <atom:link href="https://ukeate.com/docs/basic/computer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>支撑-原理</title>
      <link>https://ukeate.com/docs/basic/computer/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:25:12 +0800</pubDate>
      <guid>https://ukeate.com/docs/basic/computer/principle/</guid>
      <description>&lt;h1 id=&#34;主机&#34;&gt;&#xA;  主机&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e6%9c%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  cpu&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    单cpu串行工作，前任务完成，后任务才开始                             # 串行不适合图形处理(多点，线，面要同时乘投影矩阵)&#xA;    cpu把大量空间和电量分配给控制器和缓存，不能集成太多计算单元&#xA;    cpu内存通过cpu总线连接, cpu总线与pci总线通过主桥(北桥)连接&#xA;        gpu在pci总线上&#xA;        控制逻辑在cpu中运行, 生成渲染数据, 到内存, 再到显存显卡计算。&#xA;        内存到显存数据传输最花费时间。&#xA;原理&#xA;    处理单元(processing unit)&#xA;        算术逻辑单元(arithmetic logic unit)&#xA;        处理寄存器(processor register)&#xA;    控制单元(control unit)&#xA;        指令寄存器(instruction register)&#xA;        程序计数器(program counter)&#xA;    指令集架构(ISA, instruction set architecture)                   # 机器码易兼容, 软件易编程, 易升级cpu&#xA;        精简指令集RISC(reduced instruction set computing)&#xA;        复杂指令集CISC(complex instruction set computer)&#xA;    时钟频率(clock speed)&#xA;    生产&#xA;        生产线散热决定生存率，决定cpu型号&#xA;    多级缓存&#xA;        L1, L2, L3, L4&#xA;    虚拟化&#xA;        虚拟机监视器(VMM, virtual machine monitors)&#xA;分类&#xA;    指令流的重数分类&#xA;        SI(single instruction stream)单指令流&#xA;        MI(multiple instruction stream)多指令流&#xA;    操作数流的重数分类&#xA;        SD(single data stream)单数据流&#xA;        MD(multiple data stream)多数据流&#xA;    SISD 串行计算机&#xA;    SIMD 阵列机(多处理单元)&#xA;    MISD 很少&#xA;    MIMD&#xA;        多处理机&#xA;        多计算机&#xA;硬件并行&#xA;    位级(bit-level): 32位, 64位计算机&#xA;    指令级(instruction-level)              # 处理器内部并行度很高&#xA;        流水线&#xA;            指令分步骤(指令流), 每步专门部件处理&#xA;            多指令流并行, 部件不空闲等待单指令流结束&#xA;            六级流水线步骤&#xA;                取指(FI), 译码(DI), 计算操作数地址(CO), 取操作数(FO), 执行指令(EI), 写操作数(WO)&#xA;        多发射(超标量)&#xA;            一时钟周期处理多指令&#xA;        超线程&#xA;            模拟多个逻辑线程&#xA;        乱序执行&#xA;        猜测执行&#xA;    数据级&#xA;        向量体系结构、图形处理器&#xA;        单指令多数据(SIMD)架构&#xA;    线程级                                 # 紧耦合硬件模型中开发数据级或任务级并行，线程间有交互&#xA;    请求级                                 # OS或程序耦合任务间并行&#xA;程序并行&#xA;    数据级(DLP, data-level parallel)&#xA;    任务级(TLP, task-level parallel)       # 多处理器, 超线程, 虽只有4个核，但可用核返回8&#xA;        内存&#xA;            共享内存模型&#xA;            分布式内存模型&#xA;        进程: 独有内存&#xA;        线程: 共享进程内存(地址空间、文件描述符)&#xA;            一个进程下的轻量进程&#xA;            POSIX线程api是对已有unix进程模型扩展, 与进程多方面类似&#xA;                自己的信号掩码&#xA;                cpu affinity(倾向在某cpu尽量长时间运行)&#xA;                cgroups&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;进程调度&#34;&gt;&#xA;  进程调度&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;等级&#xA;    高级调度(High-Level Scheduling)&#xA;        作业调度, 后备作业调入内存运行&#xA;    低级调度(Low-Level Scheduling)&#xA;        进程调度, 就绪队列中某进程获得cpu&#xA;    中级调度(Intermediate-Level Scheduling)&#xA;        虚拟存储器引入, 内外存对换区进行进程对换&#xA;&#xA;方式&#xA;    非剥夺方式&#xA;        处理机分配给某进程后一直运行下去,直到阻塞时,才分配处理机到另一个进程&#xA;    剥夺方式&#xA;        进程运行时,系统基于某种原则,剥夺分配给它的处理机.&#xA;        采用算法&#xA;            先进先出算法&#xA;                批处理系统用. 总把处理机分配给最先进队的进程, 将一直执行下去,直到阻塞&#xA;            短进程优先(SCBF  Shortest CPU Burst First)&#xA;                批处理系统用. 从就绪队列中选出下一个cpu执行期最短的进程,分配处理机&#xA;            轮转法&#xA;                分时系统中,都采用时间片轮转法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gpu&#34;&gt;&#xA;  gpu&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    gpu控制单元少, 计算单元多&#xA;    显卡在pci总线上&#xA;原理&#xA;    数据级并行&#xA;        单条指令并行应用于数据集(SIMD)&#xA;    CUDA(compute unified device architecutre)                       # nvidia推出的通用并行计算架构&#xA;        多网格(grid)组织，每网格多(512-1536)线程块&#xA;        线程块线程相同指令地址, 通过共享存储器(shared memory)和栅栏(barrier)块内通信&#xA;            不同块不通信，粗粒度并行&#xA;            同块通信，细粒度并行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    虚拟内存(virtual memory)&#xA;    页表(page table)&#xA;        控制寄存器(control register)&#xA;            CR3保存页目录表内存基地址&#xA;        4级页表(PML4)&#xA;        转换检测缓冲区(TLB, translation lookaside buffer)&#xA;dma&#xA;    # direct memory access 不依赖cpu的内存存取&#xA;栈&#xA;    申请方式: 系统自动分配&#xA;    申请响应: 栈剩余空间小于申请空间, 报overflow&#xA;    申请大小限制: 栈是向低地址扩展的连续内存，线顶地址和最大容量是系统编译时预设的，windows下为2M(或1M), 申请超过剩余空间报overflow&#xA;    申请效率: 系统分配，速度快&#xA;    存储内容: 函数调用时，函数调用语句的下一条指令的地址进栈，然后是参数(C中由右向左), 然后是局部变量。调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向开始保存的函数下一指令，继续运行&#xA;    数据结构: 满足后进先出的数据结构&#xA;堆&#xA;    申请方式: 程序手动申请&#xA;    申请响应: os有记录空闲内存地址的链表，申请时遍历链表，寻找第一个空间大于申请空间的堆结点，该结点从空闲结点删除，节点分配给程序。自动将多余部分重新放入空闲链表&#xA;    申请大小限制：堆是向高地址扩展的不连续内存，系统用链表存储空闲内存地址。受限于有效虚拟内存&#xA;    申请效率: 慢，容易产生内存碎片&#xA;    存储内容: 堆头部一个字节存放堆的大小。内容由程序员安排&#xA;    数据结构: 满足优先队列的数据结构(第1个元素有最高优先权)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;网络&#34;&gt;&#xA;  网络&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ABR(area border router)：区域边界路由器&#xA;子网隔离&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;状态&#34;&gt;&#xA;  状态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;cookie&#34;&gt;&#xA;  cookie&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cookie&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    cookie的弊端&#xA;        数据在客户端可以被修改，所以不能存重要数据&#xA;        cookie中字段太多会影响传输效率&#xA;请求头&#xA;    set-cookie&#xA;        # 规定cookie的格式为name = value&#xA;响应&#xA;    path&#xA;        # cookie发送的相对路径&#xA;    expires和maxAge&#xA;        # expires是UTC时间, maxAge是cookie多久后过期&#xA;        ## 不设置这两个时产生的是session cookie, 它是transient的，用户关闭浏览器时清除。一般用来保存session_id&#xA;    secure&#xA;        # true时, cookie在HTTP中是无效的, 在HTTPS中才有效&#xA;    httpOnly&#xA;        # 通知浏览器不允许脚本操作document.cookie。一般都应设置为true, 可以避免被xss攻击拿到cookie&#xA;签名( 信息摘要算法)&#xA;    原user=&#39;alsotang&#39;&#xA;    现user=sha1(&#39;my_secret&#39; + &#39;alsotang&#39;) === &#39;xxxx...xxx&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;session&#34;&gt;&#xA;  session&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#session&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    session通过cookie中存放session_id来实现&#xA;    可以存放在&#xA;        1. 内存&#xA;        2. cookie本身&#xA;            # 不用担心集群的状态共享问题，安全性可以遵照最佳实践来，也是有保证的，最大的弊端在于增大了数据量传输。有受到回放攻击的危险&#xA;        3. redis或memcached等缓存&#xA;            # 常用&#xA;        4. 数据库中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;osi分层&#34;&gt;&#xA;  OSI分层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#osi%e5%88%86%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;物理层&#xA;数据链路层&#xA;网络层&#xA;传输层&#xA;会话层&#xA;表示层&#xA;应用层&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数据链路层&#34;&gt;&#xA;  数据链路层&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;分层&#xA;    数据链路层分为两层&#xA;        llc上层子层                # Logical Link Control 逻辑链路控制。&#xA;        mac下层子层                # Media Access Control 介质访问控制层&#xA;&#xA;帧(frame)传输&#xA;    网络驱动程序成型帧,  网卡发送到网线上，到达目的机器，以网络驱动程序解析&#xA;协议&#xA;    以太网&#xA;    令牌环&#xA;    HDLC&#xA;    帧中继&#xA;    ISDN&#xA;    ATM&#xA;    IEEE 802.11&#xA;    FDDI&#xA;    PPP&#xA;mac&#xA;    Media Access Control&#xA;        mac帧结构&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ukeate.com/docs/architecture/mac.jpg&#34; alt=&#34;&amp;quot;&amp;quot;&#34; /&gt;&#xA;单位&#xA;字节&#xA;帧类型/长度（TYPE/LEN）：&#xA;该字段的值大于1500时，表示上层数据使用的协议类型。例如0x0806表示ARP请求或应答，0x0800表示IP协议。&#xA;该字段的值小于1500时表示以太网数据的长度，上层携带LLC-PDU。&#xA;帧校验FCS：&#xA;以太网采用32位CRC冗余校验。&#xA;llc&#xA;Logical Link Control&#xA;llc-pdu结构&#xA;&lt;img src=&#34;https://ukeate.com/docs/architecture/llc1.jpg&#34; alt=&#34;&amp;quot;&amp;quot;&#34; /&gt;&#xA;&lt;img src=&#34;https://ukeate.com/docs/architecture/llc2.jpg&#34; alt=&#34;&amp;quot;&amp;quot;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ukeate.com/docs/basic/computer/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ukeate.com/docs/basic/computer/performance/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;性能指标&#xA;    latency&#xA;    throughput&#xA;    qps = throughput / latency&#xA;性能分析&#xA;    bottle-nect(first-principle)&#xA;资源&#xA;    CPU和GPU&#xA;    内存&#xA;    磁盘&#xA;    网络&#xA;    能源&#xA;逻辑资源&#xA;    fds(文件描述符)&#xA;    sockets&#xA;    内核对象: locks&#xA;    inodes(磁盘索引节点)&#xA;    transactions&#xA;    ip addresses&#xA;    ports&#xA;    random numbers(分布式随机数)&#xA;容量&#xA;    2000前   尽量少&#xA;    200~    不到机型限制&#xA;    2017    尽量把机器用满&#xA;    以后     metrics分离, 单独规划&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;计算&#34;&gt;&#xA;  计算&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;cpu&#xA;gpu&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储&#34;&gt;&#xA;  存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;类型&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;时间&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L1 cache&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;0.5ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;branch mispredict(分支、转移)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;5ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L2 cache&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;7ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;14x L1 cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Mutex lock/unlock&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;25ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Main memory&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;100ns&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;20x L2 cache, 200x L1 cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1k字节压缩Zippy&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;3,000ns = 3us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;在1Gbps网络上发送1k字节&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;10,000ns = 10us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;SSD随机读4k&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;150,000ns = 150us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1GB/秒&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;内存顺序读1MB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;250,000ns = 250us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;同一数据中心往返&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;500,000ns = 500us&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;SSD顺序读1MB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1,000,000ns = 1000us = 1ms&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1GB/秒, 4x 内存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;磁盘搜索&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;10,000,000ns = 10,000us = 10ms&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;20x 数据中心往返&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;磁盘顺序读1MB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;20,000,000ns = 20,000us = 20ms&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;80x 内存, 20x SSD&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;发包: 美国 -&amp;gt; 荷兰 -&amp;gt; 加拿大&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;150,000,000ns = 150,000us = 150ms&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h1 id=&#34;传输&#34;&gt;&#xA;  传输&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%a0%e8%be%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;带宽&#xA;    热门并发1.5倍到2倍购买&#xA;方式&#xA;    HDD&#xA;    SSD&#xA;    ethernet&#xA;    南桥、北桥芯片&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发&#34;&gt;&#xA;  并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;并发&#xA;    jetty 2k-3k&#xA;    nginx 1w&#xA;    lvs 100w&#xA;    f5 + lvs 400w-800w&#xA;    mysql 1k&#xA;    oracle 1.5k-2k&#xA;    tomcat 1k&#xA;&#xA;1并发/10在线用户/100注册用户&#xA;&#xA;1用户/20pv&#xA;&#xA;访问时段&#xA;    8点 - 23点&#xA;    最大访问量为平均值1.7倍&#xA;&#xA;每个html页面20k, 40k/css, 50k/js. css与js会缓存&#xA;&#xA;数据库&#xA;    mongodb&#xA;        查询&#xA;            4w++/5s                # aurora测&#xA;&#xA;一个进程13M左右&#xA;    10g内存787多并发(最早的apache)&#xA;一个线程2M内存&#xA;    10g内存5120并发&#xA;&#xA;cpu一级缓存取数据: 3个时钟周期(tick)&#xA;cpu二级缓存取数据: 14 tick&#xA;内存取数据: 250 tick&#xA;磁盘取数据: 4100w tick&#xA;网络取数据: 24000w tick&#xA;&#xA;负载均衡器&#xA;    # 并发在100w - 800w&#xA;    深信服&#xA;    F5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;性能调优&#34;&gt;&#xA;  性能调优&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;影响因素&#xA;    内因&#xA;        项目设计、实现&#xA;        资源加载&#xA;        配置&#xA;    外因&#xA;        网络&#xA;        流量&#xA;        架构&#xA;        服务器配置&#xA;步骤&#xA;    分析用户习性          # 功能路径，热点&#xA;    内存瓶颈&#xA;        内部&#xA;            托管资源&#xA;                对象分配回收  # session、缓存、对象池等&#xA;            非托管资源&#xA;                数据库、文件、线程&#xA;        外部&#xA;            进程竞争&#xA;    cpu瓶颈&#xA;        cpu密集业务&#xA;            加密、解密，垃圾回收，解压缩，算术运算，过度编译&#xA;    缓存分析&#xA;        浏览器缓存       # 资源文件，过期&#xA;        代理缓存        # 地域、安全、更新&#xA;        内核缓存、IIS缓存&#xA;        数据缓存&#xA;    资源等待分析&#xA;        数据库等待&#xA;        线程锁定&#xA;        磁盘读写&#xA;    数据库瓶颈(找数据库笔记)&#xA;    http优化&#xA;        减小页面&#xA;        只传必要数据&#xA;        资源加载&#xA;架构&#xA;    去单点&#xA;    服务化&#xA;    优质业务专门机器&#xA;    广播改订阅&#xA;    换语言/框架重构&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 小米论坛&#xA;    pv 2000w&#xA;    热门并发300&#xA;    20k/页面&#xA;    300k/图片(未压缩)&#xA;    70k/无图帖子&#xA;    500k-3M/有图帖子&#xA;&#xA;    动态服务器最小带宽: 48Mbps&#xA;    静态服务器最小带宽: 1440Mbps&#xA;    实际购买带宽: 800M&#xA;    带宽费用: 8.7w/month&#xA;&#xA;o-&amp;gt; 糗事百科&#xA;    pv 1000w&#xA;    热门并发150&#xA;    10k/页面&#xA;    70k/图&#xA;    4图/页&#xA;    90k-400k/综合页&#xA;    动态服务器带宽: 12Mbps&#xA;    静态服务器带宽: 336Mbps&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具数据&#34;&gt;&#xA;  工具数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;nodejs&#xA;    虚拟机数据&#xA;        mem: 512m&#xA;        mem: 66.7%&#xA;        cpu: 1%&#xA;    执行&#xA;        5秒循环mongo数据: 17w条&#xA;    状况&#xA;        程序完全阻塞&#xA;&#xA;    并发: 300&#xA;    qps: 140&#xA;    8核全满&#xA;&#xA;    2-4G 内存 3000万并发&#xA;    5w socket                        # 系统最高65535个端口，支持这么多连接&#xA;    已实现成就&#xA;        ruby迁移到node.js有10倍的性能提升，特定情况下20倍性能提升&#xA;        5w并发/min&#xA;&#xA;&#xA;redis&#xA;    200并发, 每次3ms, 37000次/s&#xA;&#xA;mysql&#xA;    最多3.5w写入/s&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
