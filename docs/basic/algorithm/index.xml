<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on ukeate的笔记</title>
    <link>https://ukeate.com/docs/basic/algorithm/</link>
    <description>Recent content in 算法 on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://ukeate.com/docs/basic/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法思想</title>
      <link>https://ukeate.com/docs/basic/algorithm/thought/</link>
      <pubDate>Mon, 08 Oct 2018 22:21:21 +0800</pubDate>
      <guid>https://ukeate.com/docs/basic/algorithm/thought/</guid>
      <description>&lt;h1 id=&#34;口诀&#34;&gt;&#xA;  口诀&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%a3%e8%af%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;难题首选动归&#xA;受阻贪心暴力&#xA;考虑分治思想&#xA;配合排序哈希&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;递归recursion&#34;&gt;&#xA;  递归(recursion)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%92%e5%bd%92recursion&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    利用递归，把状态的管理责任推给运行时&#xA;递归转迭代&#xA;    可加上memory做优化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;分治divide-and-conquer&#34;&gt;&#xA;  分治(divide and conquer)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%b2%bbdivide-and-conquer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    广义分治法&#xA;例子&#xA;    二分检索&#xA;    找最大/最小元素&#xA;    归并分类&#xA;    快速分类&#xA;    选择问题&#xA;    斯特拉森矩阵乘法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;贪心greedy&#34;&gt;&#xA;  贪心(greedy)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b4%aa%e5%bf%83greedy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;案例&#xA;    Dijkstra最短路径&#xA;    最小生成树Prim, Kruskal&#xA;&#xA;    背包问题&#xA;    作业排序&#xA;    最优归并模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;动态规划dynamic-planning&#34;&gt;&#xA;  动态规划(dynamic planning)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92dynamic-planning&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    常用滚动数组降低空间复杂度&#xA;案例&#xA;    多段图&#xA;    结点间最短路径&#xA;    最优二叉检索树&#xA;    0/1背包问题&#xA;    可靠性设计&#xA;    货郎担问题(旅行商问题)&#xA;    流水线调度问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;检索与周游retrievaltravel&#34;&gt;&#xA;  检索与周游(retrieval/travel)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a3%80%e7%b4%a2%e4%b8%8e%e5%91%a8%e6%b8%b8retrievaltravel&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;案例&#xA;    深度优先检索&#xA;    广度优先检索&#xA;    与/或图&#xA;    对策树&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;回溯backtracking&#34;&gt;&#xA;  回溯(backtracking)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%9e%e6%ba%afbacktracking&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;案例&#xA;    8皇后问题&#xA;    图的着色&#xA;    哈密顿环&#xA;    背包问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;暴力brute-force&#34;&gt;&#xA;  暴力(brute force)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9a%b4%e5%8a%9bbrute-force&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    分支限界条件加快效率&#xA;例子&#xA;    DFS, BFS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分支-限界(branch and bound)&#xA;案例&#xA;LC检索&#xA;0/1背包问题&#xA;货郎担问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;并行parallel&#34;&gt;&#xA;  并行(parallel)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e8%a1%8cparallel&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;时间复杂度time-complexity&#34;&gt;&#xA;  时间复杂度(time complexity)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6time-complexity&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;O()表示上界(&amp;lt;=), Ω() [omega]表示下界(&amp;gt;=), Θ() [Theta] 表示上下界相同, o()表示非Θ()的O()&#xA;    N &amp;gt;= n0时, T(N) &amp;lt;= cf(N), 记为T(N) = O(f(N))&#xA;    N &amp;gt;= n0时, T(N) &amp;gt;= cg(N), 记为T(N) = Ω(g(N))&#xA;    T(N) = Θ(h(N)) 当且仅当T(N) = O(h(N)) 和 T(N) = Ω(h(N))&#xA;上界(upper bound)&#xA;下界(lower bound)&#xA;法则&#xA;    # 约定, 不存在特定的时间单位&#xA;    # 约定, 机器模型中, 1. 所有指令顺序执行。2. 任一简单的工作都恰好花费一个时间单位&#xA;    ## 假设不存在如矩阵求逆或排序这样的单位操作&#xA;    1. 如果T1(N) = O(f(N)), T2(N) = O(g(N)), 那么&#xA;        T1(N) + T2(N) = O(f(N) + g(N)), 或写成 max(O(f(N)), O(g(N)))&#xA;        T1(N) * T2(N) = O(f(N) * g(N))&#xA;    2. 如果T(N)是一个k次多项式, 则T(N) = Θ(N^k)&#xA;    3. 对任意常数k, (logk) * N = O(N)&#xA;        # 对数增长得非常缓慢&#xA;一般法则&#xA;    1. for 循环时间, 为内部语句的运行时间 * 迭代次数&#xA;    2. 嵌套for 循环, 内部语句时间 * 迭代次数n次方&#xA;    3. 顺序语句, 各语句时间求和&#xA;    4. if(S1)/else(S2), 判断的运行时间加 S1和S2中时间长者&#xA;相对增长率(relative rate of growth)&#xA;    lim(N-&amp;gt;∞)f(N)/g(N)来确定两个函数的相对增长率&#xA;        1. 极限是0, 则f(N) = o(g(N))&#xA;        2. 极限是c&amp;lt;&amp;gt;0, 则f(N) = Θ(g(N))&#xA;        3. 极限是∞, 则g(N) = o(f(N))&#xA;        4. 极限摆动，则f(N)与g(N)无关&#xA;    洛必达法则&#xA;        lim(N-&amp;gt;∞)f(N) = ∞, 且lim(N-&amp;gt;∞)g(N) = ∞ 时, lim(N-&amp;gt;∞)f(N)/g(N) = lim(N-&amp;gt;∞)f&#39;(N)/g&#39;(N)&#xA;多项式时间算法&#xA;    O(1) &amp;lt; O(logn) &amp;lt; O(n) &amp;lt; O(nlogn) &amp;lt; O(n^2) &amp;lt; O(n^3)&#xA;指数时间算法&#xA;    O(2^n) &amp;lt; O(n!) &amp;lt; O(n^n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://ukeate.com/docs/algorithm/p1.jpg&#34; alt=&#34;时间复杂度&#34; /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据结构</title>
      <link>https://ukeate.com/docs/basic/algorithm/data_structure/</link>
      <pubDate>Sun, 07 Oct 2018 13:46:46 +0800</pubDate>
      <guid>https://ukeate.com/docs/basic/algorithm/data_structure/</guid>
      <description>&lt;h1 id=&#34;线性&#34;&gt;&#xA;  线性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;列表(list)&#xA;    数组(array)&#xA;        # 相同数据类型元素的序列，下标(index)访问&#xA;        low high&#xA;        字符串&#xA;            二进制串(binary string)&#xA;                # 位串(bit string)&#xA;    链表(linked list)&#xA;        节点(node)&#xA;            指针(pointer)&#xA;        表头(header)&#xA;        单链表(singly linked list)&#xA;        双链表(doubly linked list)&#xA;    栈(stack)&#xA;        # 插入和删除只能在端部进行的列表，应用于递归&#xA;        栈顶(top)&#xA;        LIFO last-in-first-out&#xA;    队列(queue)&#xA;        队头(front)&#xA;        队尾(rear)&#xA;        入队(enqueue)&#xA;        FIFO first-in-first-out&#xA;        优先队列(priority queue)&#xA;            # 数据项多来自于全序域(常整数或实数)&#xA;            查找最大元素，删除最大元素，插入新元素&#xA;            堆(heap)实现&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;散列表&#34;&gt;&#xA;  散列表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%a3%e5%88%97%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    有序输入时，树效率低，如果不要求查找有序结果，可以用散列&#xA;概念&#xA;    hash table&#xA;    hashing(散列)&#xA;    item(项)&#xA;    key(关键字)&#xA;        # 项中某部分&#xA;    hash function(散列函数)&#xA;        # 映射函数&#xA;    collsion(冲突)&#xA;        # 多个关键字散列到同项的状况&#xA;    load factor(装填因子)&#xA;        # λ 元素个数对表长度的比，&#xA;        # 如果散列是均匀的，表示了一个项中关键字的平均长度&#xA;        # 一次成功查找要遍历约1 + (λ / 2)个链，1表示被匹配的项&#xA;    rehashing(再散列)&#xA;        一半时进行&#xA;        直到插入失败再进行&#xA;        middle-of-the-road&#xA;            # 到达某load factor时进行&#xA;    caching the hash code(闪存散列代码)&#xA;算法&#xA;    separate chaining(分离链接法)&#xA;        # 解决冲突&#xA;    probing hash table(探测散列表)&#xA;        线性探测法&#xA;            primary clustering(聚集)&#xA;                # 线性探测法中形成数据区块&#xA;        平方探测法&#xA;            secondary clustering(二次聚集)&#xA;                # 模拟结果指出，对每次查找，会引起另外的少于一半的探测&#xA;        double hashing(双散列)&#xA;            # 模拟表明, 两个散列都mod质数时，探测次数几乎和随机冲突解决方法相同&#xA;    extendible hashing(可扩散列)&#xA;        D directory(目录)&#xA;            # 一个分区中bit的个数，所以M最多2^D&#xA;        性质&#xA;            # 基于位模式(bit patterm)是均匀分布的事实, 是&amp;quot;分支系数(branch factor)&amp;quot;, N 是记录总数(随时间变化)&#xA;            树叶期望个数为(N/M)log(2)(e)&#xA;                所以平均树叶满的程度为ln2 = 0.69, 同B树&#xA;            目录期望大小为O(N^(1 + 1 / M) / M)&#xA;        叶子可以指向实际记录的链表(内存装不下太大目录时)，这样得到实际数据就需要第二次磁盘访问&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;队列&#34;&gt;&#xA;  队列&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%9f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    queue 先进先出&#xA;概念&#xA;    enqueue(入队)&#xA;    dequeue(出队)&#xA;    priority queue(优先队列)&#xA;        insert&#xA;        deleteMin&#xA;    binomial queue(二项队列)&#xA;        merge, insert, deleteMin 最坏时间为O(logN), 插入花费常数时间&#xA;        堆序树(二项树)的森林实现&#xA;        B0 = 2^0, B1 = 2^1, B2 = 2^2 ...&#xA;        Bn = B0 + B1 + ... B(n-1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;集合&#34;&gt;&#xA;  集合&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e5%90%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    set(集合)，互不相同项的无序组合(可空)&#xA;    element(元素)&#xA;    dictionary(字典)，能够查找，增加，删除元素的集合&#xA;        # 实现时要达到效率的平衡&#xA;    set union problem(集合合并问题)&#xA;        # 动态地把n个元素集合划分为一系列不相交的子集&#xA;    ADT abstract data type(抽象数据类型)&#xA;        # 由表示数据项的抽象对象集合和一系列对它的操作构成&#xA;实现&#xA;    universal set(通用集合)&#xA;        通用集合的子集，用长度为n(通用集合的长度)的位向量(bit vector)表示&#xA;            # 占用大量存储空间&#xA;    线性列表&#xA;        # 去除包含的重复元素&#xA;        # 列表是有序的，但这差别并不重要&#xA;        多重集(multiset)、包(bag)&#xA;            # 可重复项的无序组合&#xA;&#xA;表示&#xA;    S = {2, 3, 5, 7}&#xA;    S = {n: n 为小于0的质数}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;树&#34;&gt;&#xA;  树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    tree&#xA;    free tree(自由树)，连通无回路的图&#xA;    full tree(满树)，所有节点要么是树叶，要么是两个儿子&#xA;    forest(森林)，无回路但不一定连通的图&#xA;    root&#xA;    rooted tree(有根树)，确定根的树，常简称为树&#xA;    node&#xA;    ancestor(祖先)，顶点本身也作为自己的祖先&#xA;        proper ancestor(真祖先)，除了自己的祖先&#xA;    parent(父母)&#xA;    child(子女)&#xA;    sibling(兄弟)&#xA;    leaf(叶节点), 没有子女的顶点&#xA;    parental(父节点)，至少有一个子女的顶点&#xA;    descendant(子孙)，以v为祖先的所有节点，包含v&#xA;        proper descendant(真子孙)，不包含本身&#xA;    subtree(子树) &#xA;&#xA;    depth(深度)，从根到v简单路径的长度&#xA;        height depth 树中结点的最大级数&#xA;    rank(秩)&#xA;        # 子女数&#xA;    height(高度)，从根到叶节点最长简单路径的长度&#xA;        # 按树的层的数量定义时，高度增加1&#xA;    degree(度，一个节点子树的数目) &#xA;    level(root为1级, 结点为p级时，儿子在p+1级)&#xA;&#xA;    state-space tree(状态空间树)，可用于分析回溯和分支界限&#xA;    ordered tree(有序树)，有根树的每个顶点，所有子女有序&#xA;        first child-next sibling representation(先子女后兄弟表示法)&#xA;            # 子女数不定，父节点只存第一个子女，该子女存兄弟链表&#xA;            ## 以一种高效方式将有序树改造成关联二叉树&#xA;            ## 关联二叉树中，左指针表示下层，右指针表示兄弟节点&#xA;    binary tree(二叉树)，属于有序树&#xA;        left child(左子女)&#xA;        right child(右子女)&#xA;        左(右)子树&#xA;            # 二叉树可以递归定义，所有可以用递归算法&#xA;        binary search tree(二叉查找树)，父母顶点比左子树中所有数字大，右子树中小&#xA;            效率，多取决于高度&#xA;                logn &amp;lt;= h &amp;lt;= n - 1&#xA;                    # h 为高度, n为顶点数&#xA;    multiway search tree(多路查找树)&#xA;        B树, B+树, B-树&#xA;边&#xA;    树向边&#xA;    回边&#xA;    前向边&#xA;        # 顶点到非子孙&#xA;    交叉边&#xA;        # 非前三都是交叉边&#xA;性质&#xA;    |E| = |V| - 1&#xA;        # 树的边数总比顶点数小1&#xA;        # 图变树的必要不充分条件，连通图变树的必要充分条件&#xA;    任意两个顶点间总存在简单路径，任选顶点可作根&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;二叉树&#34;&gt;&#xA;  二叉树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e5%8f%89%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    binary tree&#xA;    常用顺序表或链表存储&#xA;概念&#xA;    full binary tree(满二叉树)&#xA;        # 满子节点，且子节点在同一层上&#xA;    heap(堆)&#xA;        # 根向下从大到小排序&#xA;    binary search tree(二分检索树)&#xA;        # 左子节点小于父节点小于右子节点&#xA;    left child(左子女)&#xA;    right child(右子女)&#xA;    左(右)子树&#xA;        # 二叉树可以递归定义，所有可以用递归算法&#xA;&#xA;    complete binary tree(完全二叉树)&#xA;        # 只有最大层节点不满且连续集中在左边&#xA;        高是logN&#xA;        可以用数组实现(从index = 1开始存储)&#xA;            左儿子在2i, 右儿子在2i + 1, 父亲在i / 2&#xA;    perfect binary tree(理想二叉树)&#xA;        # 满节点二叉树&#xA;    full binary tree(满二叉树)&#xA;        # 同理想二叉树&#xA;    skewed tree(斜树)        &#xA;        # 一个节点不断左斜是左斜树，相反为右斜树&#xA;    binary search tree(二叉查找树)&#xA;        # 父母顶点比左子树中所有数字大，右子树中小&#xA;    AVL tree(Adelson-Velskii-Landis tree)&#xA;        # 带有平衡条件(balance condition)的二叉查找树&#xA;        平衡条件: 左右子树最多差1&#xA;            # 节点中存储高度信息&#xA;    splay tree(伸展树)&#xA;        # 分析树的一种&#xA;&#xA;效率，多取决于高度&#xA;    logn &amp;lt;= h &amp;lt;= n - 1&#xA;        # h 为高度, n为顶点数&#xA;树转换二叉树&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;堆&#34;&gt;&#xA;  堆&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a0%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    binary heap(二叉堆、堆)&#xA;        # 一棵完全二叉树&#xA;        结构性&#xA;        heap-order property(堆序性)&#xA;            heap-order tree(堆序树)&#xA;            已证明，平均一次插入需要2.607次比较，所以上移1.607层&#xA;    d-堆&#xA;        # 二叉堆是2-堆&#xA;        deleteMin为时间为O(dlog(d)(N))&#xA;        实践中&#xA;            插入次数比deleteMin次数多(可加速)&#xA;            主存不够时如B树使用&#xA;            4-堆胜过二叉堆&#xA;    leftist heap(左式堆)&#xA;        不是理想平衡(perfectly balanced)的，实际趋向于不平衡&#xA;        具有堆序性&#xA;        npl(X) null path length 零路径长&#xA;            # X到一个不具有两个儿子节点的最短路径。到本身npl(X) = 0。npl(null) = -1&#xA;        o(N)时间处理一个merge&#xA;        定义&#xA;            堆中每个节点，左儿子的npl &amp;gt;= 右儿子的npl&#xA;        操作&#xA;            merge&#xA;            insert&#xA;            deleteMin&#xA;        性质&#xA;            左儿子npl &amp;gt;= 右儿子npl&#xA;    skew heap(斜堆)&#xA;        有堆序性&#xA;        定义&#xA;            不维护npl&#xA;            每次合并都交换左右(只有左儿子的除外)&#xA;            其它同左式堆&#xA;        性质&#xA;            任意M次连续操作, 总的最坏情况运行时间为O(MlogN), 每次摊开销为O(logN)&#xA;        操作&#xA;            merge&#xA;            insert&#xA;            deleteMin&#xA;    binomial queue(二项树)&#xA;        B(k) 由B(0), B(1), ... B(k - 1)连接根组成&#xA;        有2^k个节点, k为高度&#xA;    pairing heap(配对堆)&#xA;    fibonacci heap(斐波那契堆)&#xA;算法&#xA;    heapsort(堆排序)&#xA;    merge(合并)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;图&#34;&gt;&#xA;  图&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9b%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    graph&#xA;    vertices(结点)&#xA;    edge(边)&#xA;        # 是结点对偶的集合&#xA;    endpoint(端点)&#xA;        # 边(u, v)的端点u, v&#xA;    incident(关联)&#xA;        # u, v和边(u, v)关联&#xA;    尾(tail)头(head)&#xA;        # 边(u, v)离开u进入v, u是尾, v是头&#xA;    loop(环)&#xA;        # 连接顶点自身的边，只考虑不含圈的图&#xA;    cycle(圈)&#xA;        # 长至少1的路径&#xA;    acycle(无圈的)&#xA;    DAG(无圈图)&#xA;    adjacent(邻接)&#xA;        # (i, j)则i, j邻接&#xA;&#xA;    directed(图是有向的)&#xA;        # 对偶&amp;lt;i, j&amp;gt;与对偶&amp;lt;j, i&amp;gt;不同&#xA;    digraph(有向图)&#xA;    undirected(无向的)&#xA;        # 边表示为(i, j)&#xA;&#xA;    network(网络)&#xA;        # 边上有成本的图&#xA;    weighted graph(加权图)&#xA;        # weighted digraph(加权有向图)相同&#xA;        weight(权重)&#xA;        cost(成本)&#xA;&#xA;    度&#xA;        # 点的邻接点的数目&#xA;    出度&#xA;        # 有向图中，用该点作为第一个成分的边数目&#xA;    path(路)&#xA;        # 结点序列&#xA;        cycle(环、回路)&#xA;            # 首尾相同的简单路&#xA;        acyclicity(无环性)&#xA;&#xA;        connected(连通的)&#xA;            # 每一对结点间存在一条路&#xA;        connectivity(连通性)&#xA;        connected component(连通分量)&#xA;            # 非连通图中包含的连通部分&#xA;        underlying graph(基础图)&#xA;            # 有向图去掉方向&#xA;        strongly connected(强连通的)&#xA;            # 有向图中, 一对结点都存在互相连通的路，则两点强连能&#xA;        weakly connected(弱连通的)&#xA;            # 有向图的基础图是连通的&#xA;        strongly connected graph(强连通图)&#xA;            # 所有结点对强连通&#xA;        strongly connected components(强连通分量)&#xA;            # 极大强连通子图&#xA;    length(路的长度)&#xA;        # 路的边数&#xA;    simple path(简单路)&#xA;        # 除首尾结点外，所有结点不同的路&#xA;    directed path(有向路经)&#xA;&#xA;    complete(完全的)&#xA;        # 任意两个顶点之间都有边相连，表示为K|V|&#xA;    dense(稠密)&#xA;        # 缺少边较少&#xA;    connected(连通的)&#xA;    biconnected(双连通的)&#xA;        # 不存在割点(articulation point)&#xA;表示&#xA;    V = {a, b, c, d, e, f}, E = {(a, c), (a, d), (b, c), (b, f), (c, e), (d, e), (e, f)}&#xA;    |E|&#xA;        # 边的数量&#xA;    |V|&#xA;        # 顶点的数量&#xA;    adjacency matrix(邻接矩阵)&#xA;        # 图的顺序表示法&#xA;        无向图的邻接矩阵总是对称的&#xA;        稠密图，邻接矩阵占空间小&#xA;        weight matrix(权重矩阵)、cost matrix(成本矩阵)&#xA;    adjacency list(邻接表)&#xA;        # 图的链接表示法&#xA;        稀疏图，邻接表占空间小&#xA;公式&#xA;    0 &amp;lt;= |E| &amp;lt;= |V|(|V| - 1) / 2&#xA;        # 无圈无向图，可能包含边的数量&#xA;算法&#xA;    critical path analysis(关键路径分析法)&#xA;应用&#xA;    activity-node graph(动作节点图)&#xA;    event-node graph(事件节点图)&#xA;        slack time(松弛时间)&#xA;        critical path(关键路径)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>数学</title>
      <link>https://ukeate.com/docs/basic/algorithm/math/</link>
      <pubDate>Sun, 07 Oct 2018 12:46:46 +0800</pubDate>
      <guid>https://ukeate.com/docs/basic/algorithm/math/</guid>
      <description>&lt;h1 id=&#34;指数&#34;&gt;&#xA;  指数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;X^A * X^B = X^(A + B)&#xA;X^A / X^B = X^(A - B)&#xA;(X^A)^B = X^(A * B)&#xA;X^N + X^N = 2X^N &amp;lt;&amp;gt; X^(2N)&#xA;2^N + 2^N = 2^(N + 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;对数&#34;&gt;&#xA;  对数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;约定&#xA;    计算机科学中, log默认为log(2)&#xA;&#xA;X^A = B, log(X)(B) = A&#xA;log(A)(B) = log(C)(B)/log(C)(A)&#xA;logAB = logA + logB&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;级数&#34;&gt;&#xA;  级数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%a7%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;∑(i=0)(N)2^i = 2^(N + 1) - 1&#xA;∑(i=0)(N)A^i = (A^(N + 1) - 1) / (A - 1)&#xA;    如果0 &amp;lt; A &amp;lt; 1, 则 &amp;lt;= 1 / (1 - A)&#xA;∑(i=1)(∞)i/2^i = 2&#xA;∑(i=1)(N)i = N(N + 1) / 2 ≈ N^2 / 2&#xA;∑(i=1)(N)i^2 = N(N + 1)(2N + 1) / 6 ≈ N^3 / 3&#xA;∑(i=1)(N)i^k ≈ N^(k + 1) / |k + 1|        k &amp;lt;&amp;gt; -1&#xA;    k = -1时, Hn = ∑(i=1)(N)1 / i ≈ log(e)(N), Hn是调和级数&#xA;        该近似式误差趋向于 λ ≈ 0.57721566, 称为欧拉常数(Euler&#39;s constant)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模&#34;&gt;&#xA;  模&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;如果N整除A - B, 则称A与B模N同余, 记为A≡B(mod N)&#xA;    81≡61≡1(mod 10)&#xA;如果A≡B(mod N), 则A + C ≡ B + C(mod N)，则AD≡BD(mod N)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;证明方法&#34;&gt;&#xA;  证明方法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%81%e6%98%8e%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;归纳法&#xA;    基准情形(base case)&#xA;    归纳假设(inductive hypothesis), k成立&#xA;        证明k + 1成立&#xA;反证法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;无理数&#34;&gt;&#xA;  无理数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a0%e7%90%86%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;圆周率π，黄金分割比ψ，重力加速度g，和自然对数的底e&#xA;    # e约等于2.718281828&#xA;    # e表示基础增长率为1时连续增长的实际增长率&#xA;    ## 连续增长是自然界最广泛、增长最快的一种&#xA;    ## ，所以e也表示自然增长速度, 也是增长的极限速度&#xA;    e=lim(x→∞)(1+1/x)^x&#xA;例子&#xA;    单细胞24小时分裂一次，x天产生2^x个细胞&#xA;    加条件, 一天中新生细胞产生到一半(12小时)的时候自身可以分裂&#xA;        一天产生2.25个细胞, 1个原有，1个新生, 0.25个是新生细胞分裂的&#xA;    改条件，每8小时细胞具有分裂能力&#xA;        一天可得到2.37个细胞&#xA;    改条件，新生细胞每个细微时间都有分裂能力，一天最多可以产生的细胞&#xA;        一天可得到e个细胞&#xA;例子2&#xA;    e或e经过一定变换得到&amp;quot;自然律&amp;quot;&#xA;例子3&#xA;    螺线φkρ=αe。其中，α和k为常数，φ是极角，ρ是极径，e是自然对数的底&#xA;&#xA;pi = 3.&#xA;    14159    26535    89793    23846    26433&#xA;    83279    50288    41971    69399    37510&#xA;    58209    74944    59230    78164    06286&#xA;    20899    86280    34825    34211    70679&#xA;    82148    08651    32823    06647    09384&#xA;    46095    50582    23172    53594    08128&#xA;    48111    74502    84102    70193    85211&#xA;    05559    64462    29489    54930    38196&#xA;    44288    10975    66593    34461    28475&#xA;    64823    37867    83165    27120    19091&#xA;    45648    56692    34603    48610    45432&#xA;    66482    13393    60726    02491    41273&#xA;    72458    70066    06315    58817    48815&#xA;    20920    96282    92540    91715    36436&#xA;    78925    90360    01133    05305    48820&#xA;    46652    13841    46951    94151    16094&#xA;    33057    27036    57595    91953    09218&#xA;    61173    81932    61179    31051    18548&#xA;    07446    23799    62749    56735    18857&#xA;    52724    89122    79381    83011    94912&#xA;    98336    73362    44065    66430    86021&#xA;    39494    63952    24737    19070    21798&#xA;    60943    70277    05392    17176    29317&#xA;    67523&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;组合数学&#34;&gt;&#xA;  组合数学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    鸽巢原理、ramsey定理&#xA;    概率&#xA;        加法原理、乘法原理&#xA;        排列组合、多重集排列组合&#xA;            组合恒等式&#xA;        容斥原理&#xA;            多重集r-组合数&#xA;            mobius反演&#xA;    集合&#xA;        集合分划 stirling数&#xA;    生成函数&#xA;        组合数&#xA;        指数型&#xA;        catalan数列与stirling数列&#xA;        分拆数&#xA;    递推关系&#xA;    群&#xA;        置换群&#xA;        burnside引理&#xA;            共轭类&#xA;            不动置换类&#xA;            等价类&#xA;        polya定理&#xA;&#xA;问题&#xA;    幻方&#xA;    拉丁方&#xA;    涂色&#xA;    非降路径&#xA;    正整数分拆&#xA;        无序分拆&#xA;        ferrers图&#xA;    分配&#xA;    错位排列&#xA;    棋盘多项式与有禁区的排列&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;离散数学&#34;&gt;&#xA;  离散数学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a6%bb%e6%95%a3%e6%95%b0%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;集合&#xA;    c(0)(n) + c(1)(n) + ... + c(n)(n) = 2^n&#xA;        # 幂集&#xA;    关系r&#xA;        子关系&#xA;        逆&#xA;        自反&#xA;        对称、反对称&#xA;        传递&#xA;        乘积(合成)&#xA;        自反闭包&#xA;        等价&#xA;        部分序&#xA;    映射&#xA;        原像、映像&#xA;        满射、单射&#xA;    基数(浓度)&#xA;逻辑&#xA;    联结词&#xA;        ∨, ∧, ￢, ←, →, ↔&#xA;        =, =&amp;gt;&#xA;            # 等价，蕴涵&#xA;    原子、公式、解释&#xA;    范式&#xA;        析取范式&#xA;        合取范式&#xA;        前束范式、skolem范式&#xA;    谓词&#xA;        ∀, ∃&#xA;        谓词演算&#xA;图&#xA;    权图&#xA;        dijkstra算法&#xA;    树&#xA;        最优树&#xA;                kruskal、t*&#xA;    有向图&#xA;        euler路、euler图&#xA;    无向图&#xA;        hamilton路&#xA;    平面图&#xA;        kuratowski判定&#xA;        同胚&#xA;        平面图的euler公式&#xA;        plato体&#xA;        着色&#xA;    匹配&#xA;        二部图&#xA;        增广路&#xA;        最大匹配&#xA;    konig无限性引理&#xA;        王浩定理&#xA;    计算机表示&#xA;        邻接矩阵&#xA;        关联矩阵&#xA;        弧表表示&#xA;        邻接表表示&#xA;        星形表示&#xA;    单源最短路径&#xA;        dijkstra&#xA;        bellman - ford&#xA;    最大流问题&#xA;        增广路定理&#xA;        ford - fulkerson&#xA;        最大容量增广路算法&#xA;        dinic、dinic改进&#xA;        最短增广路算法&#xA;        一般的预流推进算法&#xA;        最高标号预流推进算法&#xA;数论&#xA;    辗转相除&#xA;    质数&#xA;    合同&#xA;        剩余类&#xA;        一次同余式&#xA;        秦九韶定理&#xA;        euler函数&#xA;        一元高次同余式&#xA;        二次剩余&#xA;            legendre符号&#xA;            euler判别法&#xA;            二次剩余互反律&#xA;    应用&#xA;        加密&#xA;群&#xA;    性质&#xA;        封闭性         # 运算结果还在群中&#xA;        结合律         # (a·b)·c = a·(b·c)&#xA;        单位元(幺元)    # e·a = a·e = a&#xA;        逆元           # a·b = b·a = e&#xA;    代数系统&#xA;    半群&#xA;        封闭性&#xA;        结合律&#xA;    幺半群&#xA;        封闭性&#xA;        结合律&#xA;        幺元&#xA;    置换群&#xA;        轮换表&#xA;        奇偶性&#xA;    子群&#xA;        循环群&#xA;        右陪集&#xA;        正规子群&#xA;        lagrange定理&#xA;    同态映射&#xA;        同构映射&#xA;        核&#xA;    环&#xA;        整数环、矩阵环、多项式环&#xA;        消去环、交换环&#xA;        整区&#xA;        域&#xA;        子环&#xA;            理想&#xA;                平凡理想&#xA;                单纯环&#xA;                极大理想&#xA;        合同关系&#xA;        环同态、同构&#xA;    应用&#xA;        计数问题&#xA;            轨道&#xA;            代表元素&#xA;            burnside引理&#xA;        纠错码&#xA;域&#xA;    素域&#xA;    多项式&#xA;        根&#xA;    有理域多项式&#xA;        eisenstein定则&#xA;    分圆多项式&#xA;    有限域&#xA;格&#xA;    x, ⊕&#xA;    对偶原理&#xA;        对偶表达式&#xA;    同态、同构&#xA;    几个分类&#xA;        有界格&#xA;        有余格&#xA;        分配格&#xA;        模格&#xA;    布尔代数&#xA;        有余分配格&#xA;        stone定理&#xA;        化简&#xA;            quine&#xA;            karnaugh图&#xA;语言&#xA;    语法&#xA;        # 任何3型语法都是2型语法...都是1型语法...都是0型语法&#xA;        g = (v, t, s, p)&#xA;            # v 字母表, t是v的一个终止符子集, s是v的一个元素初始符，p是产生式集合&#xA;        0型语法&#xA;            # 没有任何限制&#xA;        1型语法&#xA;            # 产生式如 w1 -&amp;gt; w2, w2长度大于等于w1, 或者 w1 -&amp;gt; λ&#xA;            # 可以写 lw1r -&amp;gt; lw2r , 所以上下文有关&#xA;        2型语法&#xA;            # w1 -&amp;gt; w2, w1是单个非终止符&#xA;        3型语法&#xA;            # w1 -&amp;gt; w2, w1 = a 并且w2 = ab 或者w2 = a, 其中a, b为非终止符, a是终止符，也可以是λ&#xA;            # 正则语法&#xA;    演绎树&#xA;    有输出的fsm&#xA;        mealy机&#xA;        moore&#xA;    没有输出的fsm&#xA;        kleeme闭包&#xA;        终止状态&#xA;    非确定fsm&#xA;        转换确定fsm&#xA;    语言识别&#xA;        可识别集合(stephen kleene)&#xA;        正则表达式&#xA;            kleene定理&#xA;    其它fsm&#xA;        pushdown自动机&#xA;            识别到上下文无关语法&#xA;        线性有界自动机&#xA;            识别到上下文有关语法&#xA;        turing机&#xA;            识别所有语法结构产生的语言，可实现任何算法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;随机数学&#34;&gt;&#xA;  随机数学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%8f%e6%9c%ba%e6%95%b0%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;概率&#xA;    古典概型&#xA;    几何概型&#xA;    条件概率&#xA;        全概率公式&#xA;        bayes公式&#xA;    bernoulli概型&#xA;随机变量&#xA;    离散&#xA;    连续&#xA;    分布函数&#xA;    概率密度&#xA;分布&#xA;    (0 - 1)分布&#xA;    二项分布&#xA;    poisson分布&#xA;    几何分布&#xA;        均匀分布&#xA;        指数分布&#xA;    正态分布&#xA;二维&#xA;    联合概率密度&#xA;    边缘概率分布&#xA;        边缘概率密度&#xA;    二维正态分布&#xA;    条件分布&#xA;    卷积公式&#xA;    n维&#xA;数字特征&#xA;    期望、方差&#xA;        cauchy - schwarz不等式&#xA;        标准化随机变量&#xA;        协方差&#xA;    矩&#xA;        k阶原点矩&#xA;        k阶中心矩&#xA;        k + l 阶混合原点矩&#xA;        k + l 阶混合中心矩&#xA;        协方差矩阵&#xA;            n维正态分布　&#xA;大数&#xA;    chebyshev不等式&#xA;        chebyshev定理&#xA;    bernoulli定理&#xA;    中心极限定理(levy - lindberg定理)&#xA;        de moivre - laplace 极限定理&#xA;        liapunov 定理&#xA;样本&#xA;    样本分布函数&#xA;    伽玛函数&#xA;    χ2分布&#xA;    t 分布&#xA;    f 分布&#xA;参数估计&#xA;    矩估计&#xA;    最大似然估计&#xA;    评选标准&#xA;        无偏性&#xA;        有效性&#xA;        一致性&#xA;    区间估计&#xA;        置信下限、置信上限&#xA;    正态总体参数的区间估计&#xA;    两个正态区间估计&#xA;        u估计&#xA;        t估计&#xA;        f估计&#xA;假设检验&#xA;    显性检验&#xA;    参数检验&#xA;    正态总体参数&#xA;        u检验&#xA;        t检验&#xA;        χ2检验&#xA;        f检验&#xA;        ...&#xA;    分布拟合检验&#xA;回归分析&#xA;    一元线性回归&#xA;        最小二乘&#xA;    可线性化的回归方程&#xA;        双曲线&#xA;        幂函数&#xA;        指数函数&#xA;        倒指数&#xA;        对数&#xA;        s型曲线 1 / (a + b * e ^ -x)&#xA;    多元线性回归模型&#xA;方差分析&#xA;    单因素&#xA;    双因素&#xA;    交互作用双因素&#xA;    正交试验&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
