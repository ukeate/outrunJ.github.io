<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on ukeate的笔记</title>
    <link>https://ukeate.com/docs/db/</link>
    <description>Recent content in 数据库 on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://ukeate.com/docs/db/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mongodb</title>
      <link>https://ukeate.com/docs/db/mongodb/</link>
      <pubDate>Thu, 11 Oct 2018 16:00:15 +0800</pubDate>
      <guid>https://ukeate.com/docs/db/mongodb/</guid>
      <description>&lt;h1 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    数据结构json(bson)&#xA;    易写入，易修改&#xA;    c++编写&#xA;    分布式&#xA;    介于关系数据库 和 非关系数据库之间&#xA;    查询语句强&#xA;    支持索引&#xA;    bson格式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;注意&#34;&gt;&#xA;  注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    document不能大于4Mb&#xA;    可以非安全模式异步马上成功&#xA;    每个连接用队列存储命令&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据结构定义&#34;&gt;&#xA;  数据结构定义&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    collection                                        # 表&#xA;            document                                # 记录&#xA;                    field(key, value)                # 字段(field)与值(value)&#xA;    与关系型数据库的区别&#xA;            document中的field不要key俱全或一样&#xA;            find()命令查询&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;bson的数据类型&#34;&gt;&#xA;  bson的数据类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bson%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    ＃bson 是json的扩展&#xA;     # 增加了数据类型&#xA;     # 把json数据转换成二进制码存到文件&#xA;    null&#xA;    boolean&#xA;    undefined&#xA;    数组                                # 如{gps: [20, 56]}&#xA;    32位和64位整数                # shell中不支持&#xA;                                    ## node.js python java等高级语言的驱动中支持&#xA;    64位浮点                        # shell使用的全是这种类型, 如{x:3.14}&#xA;    utf-8                                # 字符串类型&#xA;    ObjectID&#xA;    Date                                # 如{x:new Date()}&#xA;    正则                                # 如{x:/uspcat/i}&#xA;    javascript块代码                # 如{x:function(){}}&#xA;                                    ## 相当于存储过程&#xA;    内嵌文档                        # 如{x: {xx: &amp;quot;a&amp;quot;}}&#xA;    二进制                                # shell中不能使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;objectid&#34;&gt;&#xA;  ObjectId&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#objectid&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    大小&#xA;            12字节&#xA;            显示为24个十六进制字符&#xA;            # 空间换时间的思想&#xA;    细节&#xA;            前4字节是unix时间戳&#xA;            后3字节集群machine hash&#xA;            后2字节pid&#xA;            后3字节inc自增计数器, 在前面都相等时全局自增&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命名&#34;&gt;&#xA;  命名&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e5%90%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    数据库与集合名&#xA;            不能是空字符串&#xA;            特殊字符&#xA;                    &#39; (空格) , $ / \ \0&#xA;            应该全小写&#xA;            小于64字节&#xA;            数据库名不与保留库名相同，如&#xA;                    admin, local, config&#xA;    集合名&#xA;            db-text合法，但不能db.db-text得到，要db.getCollection(&amp;quot;db-text&amp;quot;).text得到&#xA;                    # db-text 会认为是减法&#xA;                    ## 数据库名可以是db-text&#xA;            可以a.b来命名来划分子集合&#xA;                    不能以system.开头命名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;collection&#xA;        增&#xA;                save&#xA;                        # 不存在时插入，存在时更新&#xA;                        # {$ref: &#39;user&#39;, $id: 1} 来保存引用&#xA;                insert&#xA;        删&#xA;                remove(&#39;id&#39;: &#39;bar&#39;)        # 删除一条数据&#xA;                                                                        #remove()删除所有数据&#xA;                drop()                                # 删除persons collection, 不释放文件空间&#xA;                dropIndexes()                        # 删除所有索引&#xA;        改&#xA;                update(finder, updater, options或upser, multi)&#xA;                        # $set&#xA;                        # {age: {$gt: 18}, $isolated : 1} $isolated事务隔离该字段到本语句执行结束, does not work with sharded clusters&#xA;                findAndModify&#xA;        查&#xA;                findOne()&#xA;                find(finder, filter)&#xA;                        # limit(3).skip(10).sort({name: -1, age: 1})&#xA;                        ## sort({$natural: 1}) 固定集合排序&#xA;                        # explain() 返回带统计信息的文档&#xA;                        ## 是否用到索引，耗时，需要扫描多少文件&#xA;                        # hint({}) 强制使用某索引查询&#xA;                        # null可以匹配null, 也可以匹配{$exists: false}        &#xA;                        # 正则可以匹配自身，也可以模式字符串&#xA;                count()                                # document的条数&#xA;                aggregate&#xA;&#xA;db&#xA;        # 默认存在的数据库admin, config, local&#xA;        sources&#xA;                # 从节点中设置的源collection&#xA;        help()&#xA;        persons.help()&#xA;                # 显示某集合的帮助&#xA;        auth(&#39;username&#39;, &#39;pwd&#39;)&#xA;                # 切换用户&#xA;        addUser()&#xA;                # addUser(&#39;admin&#39;, &#39;asdf&#39;)&#xA;                # addUser(&#39;readonly&#39;, &#39;asdf&#39;, true)&#xA;        listCommands()&#xA;        shutdownServer()&#xA;        eval()&#xA;                # 执行&#xA;        stats()                                        &#xA;                # 当前数据库的状态&#xA;                ## 包括名称，collection数，索引数等&#xA;        createCollection()&#xA;                # {&#39;user&#39;, {capped: true, size: 100, max: 10}} &#xA;                ## 创建固定集合, 100字节, 文档数上限为10&#xA;                ## 固定集合插入快，不能删除，无_id, 有尾部游标&#xA;        getCollection(&amp;quot;persons&amp;quot;).text&#xA;                # 同db.persons        &#xA;        dropDatabase()&#xA;                # 删除当前数据库        &#xA;        repairDatabase()&#xA;                # 释放空间&#xA;        serverStatus()&#xA;                # 返回数据库的metrics 数据&#xA;        serverStatus().metrics.cursor&#xA;                # 返回指针信息&#xA;        ensureIndex({x: 1, y: -1}, {name: &#39;xy&#39;})&#xA;                # 建立x的升序, y的降序联合索引&#xA;                # 只使用索引的前部, 即对x的查询可以用该索引&#xA;                # {&amp;quot;gps&amp;quot;: &#39;2d&#39;} {&#39;gps&#39;: &#39;2dsphere&#39;}&#xA;                ## 支持gps写成 [0, 0] {x: 0, y: 0} {latitude: 0, longitude: 0} 格式&#xA;                # 可以索引内嵌文档&#xA;                # {unique: true} 来建立唯一索引&#xA;                # {dropDups: true} 将唯一索引中重复的文档都删掉&#xA;        dropIndexes&#xA;        system&#xA;                indexes&#xA;                        # 保留集合，索引&#xA;                namespaces&#xA;                        # 也包含索引信息&#xA;                js&#xA;                        insert({_id: &#39;fn&#39;, value: function() {}})&#xA;                                # 用db.eval(&#39;fn()&#39;) 执行&#xA;        runCommand()&#xA;                # {&#39;dropIndexes&#39;: &#39;col&#39;, &#39;index&#39;: &#39;ind&#39;}&#xA;                # 可以返回命名执行的状态信息&#xA;                {buildInfo: 1}&#xA;                {collStats: &#39;user&#39;}&#xA;                {distinct: &#39;user&#39;, key: a, query: {b: 0}}&#xA;                {drop: &#39;user&#39;}&#xA;                {dropDatabase: 1}&#xA;                {dropIndexes: &#39;user&#39;, index: &#39;ind&#39;}&#xA;                {getLastError: 1}&#xA;                        # 上次更新的作用信息&#xA;                        {getLastError: 1, w: 3}&#xA;                                # 阻塞复制，有3个节点&#xA;                {isMaster: 1}&#xA;                {findAndModify: &#39;user&#39;, query: {a: 0}, sort: {a: 1}, update: {$set: {a: 1}}}&#xA;                {listCommands: 1}&#xA;                {listDatabases: 1}&#xA;                {ping: 1}&#xA;                {renameCollection: &#39;user&#39;, to: &#39;user1&#39;}&#xA;                {repairDatabase: 1}&#xA;                        # 修复并压缩当前数据库&#xA;                {serverStatus: 1}&#xA;                        # globalLock: 全局写入锁占用了多少时间&#xA;                        # mem: 内存映射了多少数据&#xA;                        # indexCounters: B树磁盘检索(misses)和内存检索(hits)的次数&#xA;                        # backgroundFluhing: 后台做了多少次fsync及用的时间&#xA;                        # opcounters: 每种主要操作的次数&#xA;                        # asserts: 断言的次数&#xA;                {convertToCapped: &#39;user&#39;, size: 100}&#xA;                        # 转为固定集合&#xA;                {fsync: 1, lock: 1}&#xA;                        # 缓冲写入磁盘，并加写入锁。后可以直接复制磁盘数据来备份&#xA;                        # db.$cmd.sys.unlock.findOne() 解锁&#xA;                        # db.currentOp() 查看为空时已解锁&#xA;                {resync: 1}&#xA;                        # 从节点重新同步&#xA;                {collMod: &#39;users&#39;, usePowerOf2Sizes: true}&#xA;                        # 每次增大空间总是2的倍数，适用于常写的集合&#xA;rs&#xA;        isMaster&#xA;        slaveOk&#xA;dcl&#xA;        help                                        # 显示帮助&#xA;        show dbs                                # 显示所有数据库&#xA;        use mydb                                # 选择数据库(默认为test)&#xA;                                                ## 如果没有该数据库，则创建(插入第一条数据时实际创建)&#xA;        db                                        # 显示当前数据库名&#xA;        show collections                        # 查看当前数据库的collections&#xA;        db.eval()                                # 执行shell语法字符串&#xA;&#xA;        用户管理命令&#xA;                use test                                # 选择需要添加用户的数据库&#xA;                db.addUser(&#39;name&#39;,&#39;pwd&#39;)                # 第三个参数代表是否只读 true代表是 ,  false代表否&#xA;                                                        ## db 代表本数据库，也就是test&#xA;                db.system.users.find()                        # 查看用户列表&#xA;                db.auth(&#39;name&#39;,&#39;pwd&#39;)                # 用户认证，反回１代表认证成功&#xA;                db.removeUser(&#39;name&#39;)&#xA;                show users                                # 查看所有用户&#xA;&#xA;                        # 注&#xA;                                权限生效需要mongod　以　-auth参数启动&#xA;                                admin数据库中的user是超级管理员 , 其他数据库中的user只限于本数据库&#xA;&#xA;ttl(time to live)&#xA;        # mongodb每1分钟检查一次数据删除&#xA;        db.log_events.ensureIndex({&amp;quot;createdAt&amp;quot;: 1}, {expireAfterSeconds: 3600 })&#xA;        db.log_events.insert({&#xA;                &amp;quot;createdAt&amp;quot;: new Date(),&#xA;                &amp;quot;logEvent&amp;quot;: 2,&#xA;                &amp;quot;logMessage&amp;quot;: &amp;quot;Success!&amp;quot;&#xA;        })&#xA;                # 插入的这条数据在1小时后删除&#xA;        db.log_events.ensureIndex({&amp;quot;expireAt&amp;quot;: 1}, {expireAfterSeconds: 0})        &#xA;        db.log_events.insert({&#xA;                &amp;quot;expireAt&amp;quot;: new Date(&#39;July 22, 2013 14:00:00&#39;),&#xA;                &amp;quot;logEvent&amp;quot;: 2,&#xA;                &amp;quot;logMessage&amp;quot;: &amp;quot;Success!&amp;quot;&#xA;        })&#xA;                # 插入的这条数据在July 22, 2013 14:00:00删除&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;aggregate&#34;&gt;&#xA;  aggregate&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aggregate&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;mapReduce(&#xA;        function() {emit(this.cust_id, this.amount);},&#xA;                # map&#xA;        function(key, values) {return Array.sum(values)},&#xA;                # reduce&#xA;        {&#xA;                query: {status: &#39;A&#39;},&#xA;                        # query&#xA;                out: &#39;order_totals&#39;&#xA;                        # output&#xA;        } &#xA;)&#xA;&#xA;distinct()&#xA;&#xA;count()&#xA;&#xA;group({&#xA;        key: {a: 1},&#xA;                # $keyf: function(x) {return x.category} 定义分组函数&#xA;        cond: {a: {$lt: 3}}.&#xA;        $reduce: function(cur, result) {result.count += cur.count},&#xA;        initial: {count: 0},&#xA;        finalize: function (prev) {}&#xA;})&#xA;        # 返回的文档 {retval: [], count: 0, keys: 0, ok: 0}&#xA;aggregate([&#xA;        {$redact: {$cond: {&#xA;                if: {$eq: [&#39;$level&#39;, 5]},&#xA;                then: &#39;$$PRUNE&#39;,&#xA;                else: &#39;$$DESCEND&#39;&#xA;        }}}&#xA;        {$match: {status: &#39;A&#39;}},&#xA;        {$geoNear: {...}},&#xA;        {$project: {name: {$toUpper: &#39;$_id&#39;}, _id: 0}},&#xA;        {$unwind: &#39;$sizes&#39;},&#xA;        {$group: {_id: &#39;$state&#39;, totalPop: {$sum: &#39;$pop&#39;}}},&#xA;        {$skip: 10},&#xA;        {$limit: 5},&#xA;        {$sort: {age: -1}},&#xA;        {$out: &#39;authors&#39;}&#xA;])&#xA;&#xA;例子&#xA;    o-&amp;gt; 得到tags数组的长度&#xA;    db.users.aggregate([{&#xA;            $group: {&#xA;                    _id: &#39;$username&#39;,&#xA;                    tags_count: {$first: {$size: &#39;$tags&#39;}}&#xA;            }&#xA;    }])&#xA;    db.users.aggregate([{&#xA;            $project: {&#xA;                    tags_count: {$size: &#39;$tags&#39;}&#xA;            }&#xA;    }])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;expressions&#34;&gt;&#xA;  expressions&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#expressions&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;$and&#xA;$or&#xA;$not&#xA;$setEquals&#xA;$setIntersection&#xA;$setUnion&#xA;$setDefference&#xA;$setIsSubset&#xA;$anyElementTrue&#xA;$allElementsTrue&#xA;$cmp&#xA;$eq&#xA;$gt&#xA;$gte&#xA;$lt&#xA;$lte&#xA;$ne&#xA;$add&#xA;$subtract&#xA;$multiply&#xA;$divide&#xA;$mod&#xA;$concat&#xA;$substr&#xA;$toLower&#xA;$toUpper&#xA;$strcasecmp&#xA;$meta&#xA;$size&#xA;$map&#xA;$let&#xA;$literal&#xA;$dayOfYear&#xA;$dayOfMonth&#xA;$dayOfWeek&#xA;$year&#xA;$month&#xA;$week&#xA;$hour&#xA;$minute&#xA;$second&#xA;$millisecond&#xA;$dateToString&#xA;$cond&#xA;$ifNull&#xA;$sum&#xA;$avg&#xA;$first&#xA;$last&#xA;$max&#xA;$min&#xA;$push&#xA;$addToSet&#xA;$near&#xA;$within&#xA;$box&#xA;$center&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局函数&#xA;        printjson&#xA;        connect(&#39;localhost:27017/mydb&#39;)&#xA;                # 连接另一个服务器&#xA;        runProgram&#xA;对象类型&#xA;        cursor&#xA;                hasNext()&#xA;                        # 立即返回前100个数据与4Mb数据的较小者。取数据时直接读缓存&#xA;                next()&#xA;                forEach&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;复制&#34;&gt;&#xA;  复制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%8d%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;复制&#xA;        mongod --master --oplogSize 100&#xA;        mongod --slave --source localhost:27017&#xA;                # --source指定主节点&#xA;                # --only 指定只复制特定的数据库&#xA;                # --slavedelay 主从复制时的延时&#xA;                # --fastsync 从节点是主节点快照时，加这个选项，同步速度快&#xA;                # --autoresync 重新同步&#xA;                # --oplogSize 主节点oplog的大小&#xA;        db.sources.insert({host: &#39;localhost:27017&#39;})&#xA;                # 从节点设置主节点&#xA;&#xA;副本集&#xA;        #  没有主节点，集群自己选举主节点&#xA;        # 数据太多从节点会自动停止同步&#xA;        mongod --dbpath &#39;/var/local/mongo1&#39; --port 27017 --replSet rs0&#xA;                # 三个实例replSet 名必叫 rs0&#xA;        use admin&#xA;        rs.initiate({&#xA;                _id: &#39;a&#39;,&#xA;                members: [{&#xA;                        _id: 1,&#xA;                        host: &#39;localhost1:27017&#39;&#xA;                }, {&#xA;                        _id: 2,&#xA;                        host: &#39;localhost1:27018&#39;&#xA;                }]&#xA;        })&#xA;                # 其中一台执行初始化&#xA;        rs.add(&#39;localhost:27019&#39;)&#xA;        rs.status()&#xA;        db.getMongo().setSlaveOk()&#xA;        rs.isMaster()&#xA;        rs.conf()&#xA;        db.getReplicationInfo()&#xA;        db.printReplicationInfo()&#xA;        db.printSlaveReplicationInfo()&#xA;        use local        &#xA;        db.addUser(&#39;name&#39;, &#39;pwd&#39;)&#xA;                # 复制认证时用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分片&#34;&gt;&#xA;  分片&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e7%89%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;mongods --port 3000 --configdb localhost:27017&#xA;        # 多个地址用,隔开&#xA;        # 每个片都就是副本集&#xA;mongo localhost:3000/admin&#xA;db.runCommand({addshard: &#39;localhost:27017‘, allowLocal: true})&#xA;        # 在localhost上运行时, 要设allowLocal&#xA;        # &#39;a/localhost:27017&#39; 让mongo知道这个片所在的副本集&#xA;db.runCommand({enablesharding: &#39;db1&#39;})&#xA;db.runCommand({shardcollection: &#39;db1.user&#39;, key: {_id: 1}})&#xA;db.printShardingStatus()&#xA;db.runCommand({removeshard: &#39;localhost:27017&#39;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;shell&#34;&gt;&#xA;  shell&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shell&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;mongo 127.0.0.1:27017/admin&#xA;        # 启动sell , 默认数据库为test&#xA;mongod –port 10000 –fork –logpath= logpath=/data/mongodb/log/mongodb.log -- logappend -- dbpath=/data/mongodb/data/db –config ~/.mongodb.conf &#xA;        # 启动服务 -auth开启身份验证&#xA;        # --rest 开启http管理，其端口号比mongo端口号大1000&#xA;        ## --nohttpinterface关闭http管理&#xA;        # --bindip localhost 设置只能有某ip访问&#xA;        # --noscripting 完全禁止服务端js执行&#xA;        # --repair 启动并修复&#xA;        # 不要发送SIGKILL信号关闭(kill -9), 应发送SIGINT或SIGTERM&#xA;        mongod --remove                                &#xA;                # 结束服务&#xA;        // mongodb.conf&#xA;                port = 5586&#xA;                fork = true&#xA;                logpath = mongodb.log&#xA;mongodump --host 127.0.0.1 --port 27017 --out ./dir/name&#xA;        # 备份数据库&#xA;mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径&#xA;mongorestore --host 127.0.0.1 --port 27017 --directoryperdb ./dir/name&#xA;        # mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径&#xA;        # --drop 是先删除现有的数据&#xA;mongoexport -d tank -c users -o /home/outrun/mongo&#xA;        # 导出整张表&#xA;        ## mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 -f 字段 -q 条件导出 --csv -o 文件名&#xA;        # mongoexport -d tank -c users --csv -f uid,name,sex -o tank/users.csv &#xA;        ## 导出表的部分字段&#xA;        # mongoexport -d tank -c users -q &#39;{uid:{$gt:1}}&#39; -o tank/users.json&#xA;        ## 根据条件导出数据&#xA;mongoimport -d tank -c users --upsert tank/users.dat&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsert --drop 文件名 &#xA;        ## 还原整表导出的非csv文件,  --upsert 表示插入或更新现有数据&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsertFields 字段 --drop 文件名&#xA;        ## 还原部分字段导出的文件, --upsertFields跟upsert一样&#xA;        ## 如 mongoimport -d tank -c users  --upsertFields uid,name,sex  tank/users.dat&#xA;        # mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --type 类型 --headerline --upsert --drop 文件名  &#xA;        ## 还原导出的csv文件&#xA;        ## mongoimport -d tank -c users --type csv --headerline --file tank/users.csv&#xA;mongofiles put foo.txt&#xA;        # 使用gridfs&#xA;        list&#xA;        get foo.txt&#xA;        search&#xA;                # 按文件名查找&#xA;        delete foo.txt&#xA;mongostat&#xA;        # 实时输出mongo状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;java-client&#34;&gt;&#xA;  java client&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java-client&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;1.导入mongo-java-drver-2.9.3.jar&#xA;2.api&#xA;        Mongo m = new Mongo(&amp;quot;localhost&amp;quot;, 27017);&#xA;        DB db = m.getDB(&amp;quot;mydb&amp;quot;);&#xA;        boolean auth = db.authenticate(&amp;quot;root&amp;quot;, &amp;quot;root&amp;quot;.toCharArray());&#xA;        System.out.println(&amp;quot;身份认证&amp;quot; + auth);&#xA;        // 获得所有数据库名&#xA;        for (String s : m.getDatabaseNames()) {&#xA;                System.out.println(&amp;quot;db : &amp;quot; + s);&#xA;        }&#xA;        // 删除数据库&#xA;        m.dropDatabase(&amp;quot;my_new_db&amp;quot;);&#xA;        // 获得collection列表&#xA;        Set&amp;lt;String&amp;gt; colls = db.getCollectionNames();&#xA;        for (String s : colls) {&#xA;                System.out.println(&amp;quot;collection : &amp;quot; + s);&#xA;        }&#xA;        // 获得一个collection&#xA;        DBCollection coll = db.getCollection(&amp;quot;testCollection&amp;quot;);&#xA;        // 创建document(包括内嵌文档)&#xA;        DBObject doc = new BasicDBObject().append(&amp;quot;appendField&amp;quot;, &amp;quot;appendField&amp;quot;);&#xA;        doc.put(&amp;quot;name&amp;quot;, &amp;quot;MongoDB&amp;quot;);&#xA;        doc.put(&amp;quot;type&amp;quot;, &amp;quot;database&amp;quot;);&#xA;        doc.put(&amp;quot;count&amp;quot;, 1);&#xA;        DBObject info = new BasicDBObject();&#xA;        info.put(&amp;quot;x&amp;quot;, 203);&#xA;        info.put(&amp;quot;y&amp;quot;, 102);&#xA;        doc.put(&amp;quot;info&amp;quot;, info);&#xA;        // 插入文档&#xA;        coll.insert(doc);&#xA;        // 查询文档&#xA;        DBObject doc2 = coll.findOne();&#xA;        System.out.println(doc2);&#xA;        // 统计文档数&#xA;        long count = coll.getCount();&#xA;        System.out.println(count);&#xA;        // 用游标遍历&#xA;        DBCursor cursor = coll.find();&#xA;        while (cursor.hasNext()) {&#xA;                DBObject object = cursor.next();&#xA;                System.out.println(object);&#xA;        }&#xA;        // 查询&#xA;        DBObject query = new BasicDBObject();&#xA;        query.put(&amp;quot;i&amp;quot;, 71);&#xA;        cursor = coll.find(query);&#xA;        // 条件查询&#xA;        query = new BasicDBObject();&#xA;        query.put(&amp;quot;i&amp;quot;, new BasicDBObject(&amp;quot;$gt&amp;quot;, 50)); // i&amp;gt;50&#xA;        cursor = coll.find(query);&#xA;        // 创建索引&#xA;        coll.createIndex(new BasicDBObject(&amp;quot;i&amp;quot;, 1)); // 1代表升序 , -1是降序&#xA;        // 查询索引&#xA;        List&amp;lt;DBObject&amp;gt; list = coll.getIndexInfo();&#xA;                for (DBObject index : list) {&#xA;                System.out.println(&amp;quot;索引 : &amp;quot; + index);&#xA;        }&#xA;类型&#xA;    // 自动生成的唯一ID&#xA;    ObjectId id = new ObjectId();&#xA;    System.out.println(id);&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Postgre SQL</title>
      <link>https://ukeate.com/docs/db/postgresql/</link>
      <pubDate>Thu, 11 Oct 2018 15:34:29 +0800</pubDate>
      <guid>https://ukeate.com/docs/db/postgresql/</guid>
      <description>&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;initdb                          # 初始化数据库&#xA;    --locale en_US.UTF-8 &#xA;    -D &#39;data&#39;&#xA;postgres                        # 启动数据库&#xA;    -D 目录&#xA;    -p 6543&#xA;pg_ctl start                    # 控制数据库: start, stop等&#xA;    -D data &#xA;    -l a.log &#xA;postmaster&#xA;    -D /data&#xA;psql&#xA;    -d db1&#xA;    -h localhost &#xA;    -p 5432&#xA;    -U 用户名&#xA;    -W                          # 强制要求验证密码&#xA;    -f 导入sql命令文件, 或者在末尾加 &amp;lt; a.sql 来导入&#xA;    -L 导出日志文件&#xA;&#xA;    o-&amp;gt;&#xA;    psql -U outrun -f pg.sql db1                    # 导入数据&#xA;pg_dump                         # 导出数据库&#xA;    -f                          # 指定文件&#xA;    -U                          # 用户&#xA;    -E UTF8                     # 编码&#xA;    -h localhost&#xA;    -n public                   # 指定schema&#xA;    -a                          # 只导数据，没有schema&#xA;    -F t                        # 压缩成tar&#xA;&#xA;    o-&amp;gt;&#xA;    pg_dump -U outrun -f pg.sql db1                 # 导出数据, -t tb1 导出表&#xA;pg_restore&#xA;    o-&amp;gt;&#xA;    pg_restore -U outrun -d db1 pg.tar              # 导入压缩的数据&#xA;createdb                        # 创建数据库并指定 owner&#xA;    -hlocalhost -Upostgres -O 用户名 数据库名                        &#xA;dropdb&#xA;    -U user dbname&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;特色sql&#34;&gt;&#xA;  特色sql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e8%89%b2sql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;元命令&#xA;    \?                          # postgre命令&#xA;    \h                          # sql命令&#xA;    \l                          # 列出数据库&#xA;    \q                          # 退出&#xA;    \c 数据库名                 # 切换数据库&#xA;    \d name                     # 查看序列、表、视图、索引&#xA;        \dS+                    # 详情&#xA;    \du                         # 查看角色&#xA;    \dt                         # 查看所有表&#xA;        \dtS+                   # 详情&#xA;    \ds                         # 查看序列&#xA;    \i a.sql                    # 执行sql文件&#xA;    \o a.log                    # 日志文件&#xA;    \password                   # 更换密码&#xA;    \x                          # 开启/关闭竖排显示&#xA;&#xA;    [sql] \gdesc                # 快速显示结果列名和类型&#xA;数据类型&#xA;    serial                      # 4字节，自增序列&#xA;        bigserial               # 8字节&#xA;    text default &#39;&#39;::text&#xA;    bigint default 0            # 8字节&#xA;        smallint                # 2字节&#xA;        int, integer            # 4字节&#xA;        decimal                 # 变长, 声明精度，精确&#xA;        numeric                 # 同上&#xA;        float&#xA;        real                    # 4字节，变精度，不精确&#xA;        double precision        # 8字节，变精度，不精确&#xA;&#xA;    boolean default false&#xA;    text[]                      # text数组&#xA;    date&#xA;    time&#xA;    timestamp with time zone&#xA;    interval&#xA;    &#xA;    bytea                       # 二进制&#xA;&#xA;    money&#xA;    uuid&#xA;约束&#xA;    constraint user_id primary key (id)&#xA;    constraint user_m_id unique(m_id)&#xA;    constraint fk_b_id foreign key (b_id) references tbb(id)&#xA;        MATCH SIMPLE&#xA;        ON UPDATE NO ACTION&#xA;        ON DELETE NO ACTION&#xA;dcl&#xA;    create database db1&#xA;        owner outrun&#xA;    create user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;    create role 用户名 with password &#39;密码&#39; login&#xA;        # 创建用户。role关键词可以省略&#xA;&#xA;    drop database db1&#xA;    drop table tablename;&#xA;&#xA;    alter database abc RENAME TO cba;&#xA;    alter database 数据库名 owner to 用户名&#xA;        # 更改数据库 owner&#xA;    alter table tb &#xA;        add primary key (id)&#xA;        add foreign key(b_id) references tb(id) on update cascade on delete cascade&#xA;        add column c1 text&#xA;        alter column id type int using id::integer&#xA;        rename c1 to c2&#xA;            drop constraint fk_b_id foreign key (b_id) references tbb(id)&#xA;        drop [column] name&#xA;        owner to outrun&#xA;            # 更改表 owner&#xA;    &#xA;    alter role 用户名 with login                     # 添加权限&#xA;        password &#39;asdf&#39;                             # with password &#39;asdf&#39;, 修改密码&#xA;        VALID UNTIL &#39;JUL 7 14:00:00 2012 +8&#39;        # 设置角色有效期&#xA;        login, superuser, createdb, createrole, replication, inherit&#xA;&#xA;    grant all privileges on database 数据库名 to 用户名&#xA;        # 授权数据库权限&#xA;ddl &#xA;    insert into tb(&amp;quot;desc&amp;quot;) values (&#39;a&#39;); &#xA;模糊查询&#xA;    ~                       # 匹配正则，大小写相关&#xA;        除&#39;a$&#39; &#39;^a&#39;的正则都只适合pg_trgm的gin索引&#xA;    ~*                      # 匹配正则，大小写无关&#xA;    !~                      # 不匹配该正则&#xA;    !~*&#xA;    ~ &#39;^a&#39;&#xA;        like &#39;a%&#39;&#xA;    ~ &#39;a$&#39;&#xA;    ~ &#39;ab.c&#39;&#xA;        like &#39;%ab_c%&#39;&#xA;&#xA;o-&amp;gt; 视图 &#xA;CREATE VIEW myview &#xA;AS &#xA;SELECT city, temp_lo, temp_hi, prcp, date, location &#xA;FROM weather, cities &#xA;WHERE city = name;&#xA;&#xA;o-&amp;gt; 建表&#xA;create table dwh_timestamp_meta&#xA;(&#xA;&amp;quot;id&amp;quot; serial NOT NULL,&#xA;&amp;quot;id&amp;quot; serial primary key,&#xA;&amp;quot;c_id&amp;quot; serial references cities(id),&#xA;&amp;quot;mongo_document_name&amp;quot; text default &#39;&#39;::text,&#xA;&amp;quot;last_update_time&amp;quot; bigint default 0,&#xA;&amp;quot;execute_time&amp;quot; timestamp with time zone,&#xA;constraint pk_id primary key(id)&#xA;)&#xA;with (&#xA;oids=false&#xA;);&#xA;&#xA;o-&amp;gt; 序列&#xA;create table a(&#xA;    id bigint primary key&#xA;);&#xA;create sequence a_id_seq&#xA;    start with 1&#xA;    increment by 1&#xA;    no minvalue&#xA;    no maxvalue&#xA;    cache 1;&#xA;alter table a alter column id set default nextval(&#39;a_id_seq&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据字典&#34;&gt;&#xA;  数据字典&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ad%97%e5%85%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;pg_roles                        # 角色信息&#xA;pg_database                     # 数据库信息&#xA;information_schema&#xA;    select column_name from information_schema.columns where table_schema=&#39;public&#39; and table_name=&#39;ad&#39;;&#xA;        # 表的所有列名&#xA;pg_stat_user_tables&#xA;    select relname from pg_stat_user_tables;&#xA;        # 所有表名&#xA;pg_stat_activity                # 活动状态&#xA;    SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE datname=&#39;garbage&#39; AND pid&amp;lt;&amp;gt;pg_backend_pid();&#xA;        # 查看数据库活动连接&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;数据库目录&#xA;    /usr/lib/systemd/system/postgresql.service&#xA;jdbc&#xA;    driver : org.postgresql.Driver&#xA;    url : jdbc:postgresql://localhost:5432/postgres&#xA;    初始用户名 : postgres&#xA;    初始数据库 : postgres&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储过程&#34;&gt;&#xA;  存储过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;drop function change_type1();&#xA;create or replace function change_type1()&#xA;returns int as&#xA;$body$&#xA;DECLARE&#xA;    r mongo_keys_type%rowtype;&#xA;    begin&#xA;    for r in select * from mongo_keys_type where type=&#39;number&#39;&#xA;    loop&#xA;        EXECUTE &#39;alter table &amp;quot;&#39; || r.&amp;quot;mongo_collection_name&amp;quot; || &#39;&amp;quot; alter &amp;quot;&#39; || r.&amp;quot;key&amp;quot; || &#39;&amp;quot; type decimal&#39;;&#xA;    END LOOP;&#xA;    return 0;&#xA;    end&#xA;$body$&#xA;language &#39;plpgsql&#39;;&#xA;&#xA;select change_type1()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;案例&#34;&gt;&#xA;  案例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a1%88%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;授权&#xA;    grant all privileges on database &#39;db1&#39; to &#39;outrun&#39;&#xA;    alter role &#39;outrun&#39; createdb&#xA;    alter role &#39;outrun&#39; superuser&#xA;创建用户&#xA;    create user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;    create role &#39;outrun&#39; createdb password &#39;asdf&#39; login&#xA;修改密码&#xA;    alter user &#39;outrun&#39; with password &#39;asdf&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ukeate.com/docs/db/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ukeate.com/docs/db/elasticsearch/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分布式实时lucene&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;./bin/elasticsearch&#xA;curl http://localhost:9200&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;概念存储&#34;&gt;&#xA;  概念存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e5%bf%b5%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;index&#xA;    type&#xA;        # document中加_type field实现&#xA;        # 所以不同type中的field在index要唯一，否则冲突&#xA;        # 对field排序会载入所有type的document&#xA;        document&#xA;            # 对应lucene中的key value倒排文档&#xA;            # 对就一个请求的json对象&#xA;            field&#xA;                mapping&#xA;                    # 定义type的field，映射json到document field&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;设置&#34;&gt;&#xA;  设置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;config/elasticsearch.yml&#xA;    action.auto_create_index: -l*, +z*&#xA;        # 自动创建，以z开头和非l开头的索引&#xA;    action.destructive_requires_name: true&#xA;        # 允许通配删index&#xA;    http.cors.enables: true&#xA;    http.cors.allow-origin: &amp;quot;*&amp;quot;&#xA;    cluster.name: c1&#xA;    node.name: n1&#xA;    node.master: true&#xA;    node.data: true&#xA;    transport.host: localhost&#xA;    transport.tcp.port: 9300&#xA;    network.host: 0.0.0.0&#xA;        # 修改es监听地址，别的机器也可以访问。同时设置bind_host和publish_host&#xA;        # 需要设置transport.host:localhost&#xA;    network.bind_host&#xA;        # 节点绑定ip&#xA;    network.publish_host&#xA;        # 发布地址，其它节点通过这个地址通信&#xA;    http.port: 9200&#xA;    transport.tcp.port&#xA;        # 通信端口，默认9300&#xA;    discovery.zen.minimum_master_nodes: 2&#xA;&#xA;o-&amp;gt; 可用配置&#xA;cluster.name: myES_Cluster&#xA;node.name: ESNODE_CYR&#xA;node.master: true&#xA;node.data: true&#xA;transport.host: localhost&#xA;transport.tcp.port: 9300&#xA;http.port: 9200&#xA;network.host: 0.0.0.0&#xA;discovery.zen.minimum_master_nodes: 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;接口&#34;&gt;&#xA;  接口&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;index&#34;&gt;&#xA;  index&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#index&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;get/put/delete /index1              # 创建index, get查询，delete删除&#xA;    settings&#xA;    mappings&#xA;    aliases:&#xA;put /index1/_mapping/type2&#xA;get/put /index1/type2/_mapping      # 创建type或给已有type加mappings&#xA;    properties&#xA;put /index1/_settings&#xA;get/put /index1/type1/1             # 插入doc&#xA;    name: &amp;quot;name1&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_cat&#34;&gt;&#xA;  _cat&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_cat&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;get /_cat/health?v                  # 集群健康&#xA;get /_cat/nodes?v                   # 集群节点&#xA;get /_cat/indices?v                 # 所有索引&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_cluster&#34;&gt;&#xA;  _cluster&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_cluster&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;get /_cluster/state?pretty          # 集群状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_aliases&#34;&gt;&#xA;  _aliases&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_aliases&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /_aliases                      # 索引别名&#xA;    actions:&#xA;        add:&#xA;            alias: &amp;quot;my_index&amp;quot;&#xA;            index: &amp;quot;my_index_v1&amp;quot;&#xA;        remove&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_template&#34;&gt;&#xA;  _template&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_template&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;put /_template/tpl1&#xA;    template: &amp;quot;te*&amp;quot;&#xA;        # 匹配所有re开头的index&#xA;    settings:&#xA;    mappings:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_search&#34;&gt;&#xA;  _search&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_search&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/type1/_search&#xA;    # from size实时分页&#xA;    # scroll快照分页&#xA;    ?from=0&amp;amp;size=50&#xA;    ?scroll=1m&amp;amp;size=50&#xA;        # 过期时间1分钟，每次返回50条&#xA;    ?search_type=scan&amp;amp;scroll=1m&#xA;        # scroll-scan分页不排序，更快,&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_analyze&#34;&gt;&#xA;  _analyze&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_analyze&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/_analyze&#xA;    text: &amp;quot;刘德华&amp;quot;&#xA;    analyzer: &amp;quot;analyzer1&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_close&#34;&gt;&#xA;  _close&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_close&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/_close&#xA;    # 关闭索引，此后可以改settings&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_open&#34;&gt;&#xA;  _open&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_open&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/_open&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;_cache&#34;&gt;&#xA;  _cache&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_cache&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;post /index1/type1/_cache/clear?filter_keys=k1&#xA;    # 清空query filter的缓存&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据对象&#34;&gt;&#xA;  数据对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;_search-1&#34;&gt;&#xA;  _search&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#_search-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;query&#xA;    match&#xA;        # 理解如何分词的, 会对field分词再查询&#xA;        field1:&#xA;            query: &amp;quot;a b&amp;quot;&#xA;            operator: &amp;quot;and&amp;quot;&#xA;            minimum_should_match: &amp;quot;75%&amp;quot;&#xA;                # 匹配的query分词的最低占比&#xA;    match_all&#xA;        # 默认，会查出所有文档&#xA;    multi_match&#xA;        query: &amp;quot;a b&amp;quot;&#xA;        fields: [&amp;quot;field1&amp;quot;, &amp;quot;field2&amp;quot;]&#xA;    match_phrase&#xA;        # 所有term命中，并且位置邻接&#xA;        field1: &amp;quot;a b&amp;quot;&#xA;    term&#xA;        # 确切查询&#xA;        field1: &amp;quot;value1&amp;quot;&#xA;    terms&#xA;        # 多条件and&#xA;        field1: [1,2,3]&#xA;    range&#xA;        field1:&#xA;            gt: 20&#xA;            gte:&#xA;            lt:&#xA;            lte:&#xA;    exists:&#xA;        field: &amp;quot;field1&amp;quot;&#xA;    missing:&#xA;        field: &amp;quot;field1&amp;quot;&#xA;    regexp&#xA;        postcode: &amp;quot;W[0-9].+&amp;quot;&#xA;    wildcard&#xA;        postcode: &amp;quot;W?F*HW&amp;quot;&#xA;    prefix&#xA;        # 以某些字符开头&#xA;        field1: &amp;quot;a&amp;quot;&#xA;    bool&#xA;        # 分值计算来自must和should语句, must_not不影响&#xA;        must&#xA;            match&#xA;        must_not&#xA;        should: []&#xA;        minimum_should_match: 2&#xA;    filtered&#xA;        query&#xA;        filter:&#xA;            # filter的field会缓存起来&#xA;            ## geo, and, or, not, script, numeric_range的默认不缓存&#xA;            term:&#xA;                field1: &amp;quot;a&amp;quot;&#xA;                _cache_key: &amp;quot;k1&amp;quot;&#xA;                _cache: false&#xA;            range:&#xA;                field1:&#xA;                    gte: 0&#xA;aggs&#xA;    diy1:&#xA;        avg:&#xA;            field: &amp;quot;field1&amp;quot;&#xA;    diy2:&#xA;        terms:&#xA;            # 聚合查询中的所有term&#xA;            field: &amp;quot;field1&amp;quot;&#xA;post_filter:&#xA;    # 对搜索结果进行过滤&#xA;    term:&#xA;        field1: &amp;quot;a&amp;quot;&#xA;sort: []&#xA;    # 默认升序，_score默认降序&#xA;    field1&#xA;        order: &amp;quot;desc&amp;quot;&#xA;            # asc&#xA;        mode: &amp;quot;min&amp;quot;&#xA;            # 对数组元素排序时的取值, 还有max, sum, avg, median&#xA;        missing: &amp;quot;field1&amp;quot;&#xA;    &amp;quot;_score&amp;quot;,&#xA;highlight&#xA;    pre_tags: [&amp;quot;&amp;lt;tag1&amp;gt;&amp;quot;]&#xA;    post_tags: [&amp;quot;&amp;lt;/tag1&amp;gt;&amp;quot;]&#xA;    fields:&#xA;        content: {}&#xA;simple_query_string:&#xA;    query: &amp;quot;&amp;quot;&#xA;    analyzer:&#xA;    fields: [&amp;quot;body^5&amp;quot;, &amp;quot;_all&amp;quot;]&#xA;    default_operator: &amp;quot;and&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;mappings&#34;&gt;&#xA;  mappings&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mappings&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;type1:&#xA;    dynamic: true&#xA;        # 默认true,自动给未知field建索引&#xA;        # false: 忽略未知field， strict: 未知field报错&#xA;    include_in_all: false&#xA;        # 默认不include&#xA;    _all:&#xA;        # meta field&#xA;        enabled: false&#xA;                # 关闭all作用域&#xA;        analyzer:&#xA;                # 其实是search_analyzer&#xA;        term_vector: no&#xA;                # 对field建立词频向量空间&#xA;        store: &amp;quot;false&amp;quot;&#xA;    _source:&#xA;        #  是否保存内容&#xA;        enabled: true&#xA;    properties:&#xA;        field1:&#xA;            type: “text”&#xA;                # text分词，keyword不分词，numeric, date, string&#xA;                # multi_field可定义多个field&#xA;            fields:[]&#xA;                field1:&#xA;                    type&#xA;            store: &amp;quot;yes&amp;quot;&#xA;            index: &amp;quot;not_analyzed&amp;quot;&#xA;                # analyzed&#xA;            analyzer: &amp;quot;ik_max_word&amp;quot;&#xA;            search_analyzer: &amp;quot;ik_max_word&amp;quot;&#xA;                # 默认为analyzer&#xA;            include_in_all: &amp;quot;true&amp;quot;&#xA;                # 是否加入_all作用域&#xA;            boost: 8&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;aliases&#34;&gt;&#xA;  aliases&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aliases&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;alias1:&#xA;    filter:&#xA;        term: user: &amp;quot;kimchy&amp;quot;&#xA;    routing: &amp;quot;kimchy&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;settings&#34;&gt;&#xA;  settings&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#settings&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 有些设置不能动态修改&#xA;index:&#xA;    number_of_shards: 3&#xA;    number_of_replicas: 2&#xA;    max_result_window: 10000&#xA;        # from + size的上限，默认10000&#xA;    analysis:&#xA;        tokenizer:&#xA;            # 处理原始输入&#xA;            tokenizer1&#xA;                type: &amp;quot;pinyin&amp;quot;&#xA;                pinyin_field1:&#xA;        filter:&#xA;            # tokenizer作为输入&#xA;            filter1:&#xA;                type: &amp;quot;pinyin&amp;quot;&#xA;                pinyin_field1:&#xA;        analyzer:&#xA;            # 组合tokenizer和filter&#xA;            analyzer1:&#xA;                type: &amp;quot;custom&amp;quot;&#xA;                tokenizer: &amp;quot;ik_smart&amp;quot;&#xA;                filter: [&amp;quot;filter1&amp;quot;, &amp;quot;word_delimiter&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    复制到/plugins&#xA;    场景中，指定type:&amp;quot;xx&amp;quot;使用&#xA;## ik&#xA;    介绍&#xA;        elasticsearch-analysis-ik&#xA;    安装&#xA;        mvn package&#xA;        unzip -d /elasticsearch/plugins/ik ./target/releases/elasticsearch-analysis-ik-1.8.0.zip&#xA;        重启elasticsearch&#xA;    分词器&#xA;        ik_max_word&#xA;            curl -XGET &#39;http://localhost:9200/_analyze?pretty&amp;amp;analyzer=ik_max_word&#39; -d &#39;联想是全球最大的笔记本厂商&#39;&#xA;        ik_smart&#xA;            curl -XGET &#39;http://localhost:9200/_analyze?pretty&amp;amp;analyzer=ik_smart&#39; -d &#39;联想是全球最大的笔记本厂商&#39;&#xA;    mapping type&#xA;        {&#xA;        &amp;quot;properties&amp;quot;: {&#xA;            &amp;quot;content&amp;quot;: {&#xA;            &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;,&#xA;            &amp;quot;store&amp;quot;: &amp;quot;no&amp;quot;,&#xA;            &amp;quot;term_vector&amp;quot;: &amp;quot;with_positions_offsets&amp;quot;,&#xA;            &amp;quot;analyzer&amp;quot;: &amp;quot;ik_smart&amp;quot;,&#xA;            &amp;quot;search_analyzer&amp;quot;: &amp;quot;ik_smart&amp;quot;,&#xA;            &amp;quot;include_in_all&amp;quot;: &amp;quot;true&amp;quot;,&#xA;            &amp;quot;boost&amp;quot;: 8&#xA;            }&#xA;        }&#xA;        }&#xA;## pinyin&#xA;    介绍&#xA;        elasticsearch-analysis-pinyin&#xA;&#xA;&#xA;    o-&amp;gt;&#xA;    &amp;quot;analysis&amp;quot; : {&#xA;        &amp;quot;analyzer&amp;quot; : {&#xA;            &amp;quot;pinyin_analyzer&amp;quot; : {&#xA;                &amp;quot;tokenizer&amp;quot; : &amp;quot;my_pinyin&amp;quot;,&#xA;                &amp;quot;filter&amp;quot; : &amp;quot;word_delimiter&amp;quot;&#xA;            }&#xA;        },&#xA;        &amp;quot;tokenizer&amp;quot; : {&#xA;            &amp;quot;my_pinyin&amp;quot; : {&#xA;                # 单字&#xA;                &amp;quot;type&amp;quot; : &amp;quot;pinyin&amp;quot;,&#xA;                &amp;quot;first_letter&amp;quot; : &amp;quot;none&amp;quot;,&#xA;                &amp;quot;padding_char&amp;quot; : &amp;quot; &amp;quot;&#xA;            },&#xA;            &amp;quot;my_pinyin_fisrt_letter&amp;quot; : {&#xA;                # 首字母, 如北京为bj&#xA;                &amp;quot;type&amp;quot; : &amp;quot;pinyin&amp;quot;,&#xA;                &amp;quot;first_letter&amp;quot; : true,&#xA;                &amp;quot;padding_char&amp;quot; : &amp;quot; &amp;quot;&#xA;            },&#xA;        }&#xA;    }&#xA;    o-&amp;gt; pinyin&#xA;    &amp;quot;analysis&amp;quot; : {&#xA;        &amp;quot;tokenizer&amp;quot; : {&#xA;            &amp;quot;my_pinyin&amp;quot; : {&#xA;                &amp;quot;type&amp;quot; : &amp;quot;pinyin&amp;quot;,&#xA;                &amp;quot;keep_separate_first_letter&amp;quot; : false,&#xA;                &amp;quot;keep_full_pinyin&amp;quot; : true,&#xA;                &amp;quot;keep_original&amp;quot; : true,&#xA;                &amp;quot;limit_first_letter_length&amp;quot; : 16,&#xA;                &amp;quot;lowercase&amp;quot; : true,&#xA;                &amp;quot;remove_duplicated_term&amp;quot; : true&#xA;            }&#xA;        },&#xA;        &amp;quot;analyzer&amp;quot; : {&#xA;            &amp;quot;pinyin_analyzer&amp;quot; : {&#xA;                &amp;quot;tokenizer&amp;quot; : &amp;quot;my_pinyin&amp;quot;&#xA;            }&#xA;        }&#xA;    }&#xA;    &amp;quot;properties&amp;quot;: {&#xA;        &amp;quot;name&amp;quot;: {&#xA;            &amp;quot;type&amp;quot;: &amp;quot;keyword&amp;quot;,&#xA;            &amp;quot;fields&amp;quot;: {&#xA;                &amp;quot;pinyin&amp;quot;: {&#xA;                    &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;,&#xA;                    &amp;quot;store&amp;quot;: &amp;quot;no&amp;quot;,&#xA;                    &amp;quot;term_vector&amp;quot;: &amp;quot;with_offsets&amp;quot;,&#xA;                    &amp;quot;analyzer&amp;quot;: &amp;quot;pinyin_analyzer&amp;quot;,&#xA;                    &amp;quot;boost&amp;quot;: 10&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; ik-pinyin&#xA;    &amp;quot;analysis&amp;quot;: {&#xA;        &amp;quot;filter&amp;quot;: {&#xA;            &amp;quot;pinyin1&amp;quot;: {&#xA;                &amp;quot;type&amp;quot;: &amp;quot;pinyin&amp;quot;&#xA;            }&#xA;        },&#xA;        &amp;quot;analyzer&amp;quot;: {&#xA;            &amp;quot;ik_pinyin_analyzer&amp;quot;: {&#xA;                &amp;quot;filter&amp;quot;: [&amp;quot;pinyin1&amp;quot;,&amp;quot;word_delimiter&amp;quot;],&#xA;                &amp;quot;type&amp;quot;: &amp;quot;custom&amp;quot;,&#xA;                &amp;quot;tokenizer&amp;quot;: &amp;quot;ik_smart&amp;quot;&#xA;            }&#xA;        }&#xA;    },&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;工具&#xA;kopf&#xA;bigdesk&#xA;head&#xA;使用&#xA;&lt;a href=&#34;https://github.com/mobz/elasticsearch-head&#34;&gt;https://github.com/mobz/elasticsearch-head&lt;/a&gt;&#xA;cnpm i&#xA;npm i -g grunt-cli&#xA;grunt server&#xA;curl localhost:9100&#xA;配置&#xA;Gruntfile.js&#xA;port:9100&#xA;client&#xA;olivere/elastic&#xA;Search&#xA;# SearchService&#xA;Do&#xA;Index&#xA;Query&#xA;Sort&#xA;From&#xA;Pretty&#xA;Index&#xA;# IndexService&#xA;Do&#xA;Index&#xA;Type&#xA;Id&#xA;BodyJson&#xA;Refresh&#xA;Suggest&#xA;# SuggestService&#xA;query&#xA;SimpleQueryString&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ukeate.com/docs/db/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ukeate.com/docs/db/mysql/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    c++编写&#xA;端口&#xA;    3306&#xA;命令&#xA;    mysql&#xA;        --max-relay-logs-size=300           # 中继日志大小(sql语句数)&#xA;        --relay-log-purge={0|1}             # 中继日志自动清空&#xA;        --relay-log-space-limit=0           # 限制中继日志大小,0表示无限制&#xA;&#xA;        o-&amp;gt;&#xA;        mysql -h 127.0.0.1 -u root -p&#xA;    mysqldump&#xA;        -uroot&#xA;        -p&#xA;        -h127.0.0.1&#xA;        -P3306&#xA;        --force&#xA;        --all-databases                     # 所有库&#xA;        --databases db1 db2                 # 多库&#xA;&#xA;        o-&amp;gt;&#xA;        mysqldump -uroot -p db1 tb1&amp;gt; tb1.sql&#xA;    mysqladmin -uroot -p status             # 查看当前连接数&#xA;组件&#xA;    mysql enterprise monitor documentation&#xA;    mysql enterprise monitor connector&#xA;    mysql enterprise monitor service manager&#xA;    mysql enterprise monitor agent&#xA;    mysql enterprise backup&#xA;    mysql connector&#xA;    工具&#xA;        mysql database&#xA;        mysql cluster          # 创建集群，配置复杂&#xA;        mysql cluster manager  # cluster帮助软件，配置简单&#xA;        mysql workbench        # 据库建模工具&#xA;        mysql utilities        # 提供一组命令行工具用于维护和管理 MySQL 服务器&#xA;连接参数&#xA;    root:123456@tcp(abcdefg:3306)/meiqia?&#xA;        charset=utf8mb4,utf8&amp;amp;&#xA;        characterEncoding=UTF-8&amp;amp;&#xA;        loc=UTC&amp;amp;&#xA;        interpolateParams=true&amp;amp;&#xA;        time_zone=%27%2B00%3A00%27&amp;amp;&#xA;        sql_mode=%27NO_ENGINE_SUBSTITUTION%2CSTRICT_TRANS_TABLES%27&#xA;数据类型&#xA;    int             # int(5) zerofill&#xA;    varchar(20)     # null不占空间&#xA;    decimal(10,2)   # 小数&#xA;    char(10)        # 空间已固定, 不论null与否&#xA;    date&#xA;    bool或boolean&#xA;    double&#xA;    float&#xA;    longtext&#xA;    longblob&#xA;    timestamp       # 自动在插入、修改记录时添加，用于记录更新&#xA;    enum(&#39;male&#39;,&#39;female&#39;) default male  # 枚举，只有一个&#xA;    set((&#39;football&#39;,&#39;sleep&#39;,&#39;film&#39;)     # 集合，可以多个&#xA;架构&#xA;    服务器&#xA;        连接管理与安全验证&#xA;        解析器     # 解析到缓存&#xA;            查询缓存(修改时清出缓存)，分析查询语句，生成解析树&#xA;        优化器&#xA;            查询语句优化&#xA;                选索引&#xA;                读取方式&#xA;                获取查询开销信息&#xA;                统计信息&#xA;        执行器&#xA;            执行查询语句，返回结果&#xA;            生成执行计划&#xA;    缓存&#xA;        执行计划缓存&#xA;        数据缓存&#xA;    存储引擎&#xA;        缓存管理    # 管理缓存&#xA;        锁管理      # 管理执行器&#xA;        事务管理&#xA;        文件管理&#xA;            innodb&#xA;事务&#xA;    由存储引擎决定     # 与其它数据库产品不同&#xA;    默认自动提交&#xA;        # variables autocommit, 0 off 1 on&#xA;    一些命令强制自动提交&#xA;        DLL命令&#xA;        lock tables&#xA;目录&#xA;    /var/lib/mysql              # 默认数据库&#xA;    /var/log/mariadb            # 默认日志&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;引擎&#34;&gt;&#xA;  引擎&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e6%93%8e&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;XtraDB&#xA;Memory(Heap)&#xA;    # 之前叫Heap, 存到内存&#xA;NDB&#xA;    特点&#xA;        集群设计&#xA;        share nothing, 高可用，可扩展&#xA;        存到内存, 主键查找快&#xA;        join操作在数据库层完成，不是引擎完成。需要网络开销大，查询慢&#xA;Archive&#xA;    # 适合归档数据，只支持insert和select,提供高速插入和压缩功能&#xA;Federated&#xA;    # 不存数据, 指向远程表，类似oracle的透明网关&#xA;Maria&#xA;    # 开源，用于取代M主ISAM&#xA;MyISAM&#xA;    特点&#xA;        不支持事务&#xA;        表锁&#xA;        适用联机分析(OLAP)&#xA;        不缓存数据文件，只缓存索引文件&#xA;        占较少空间保存数据与索引&#xA;    表文件&#xA;        .frm    # 存储定义&#xA;        .MYD    # MYData 存储数据&#xA;        .MYI    # MYIndex 存储索引&#xA;InnoDB&#xA;    特点&#xA;        支持事务&#xA;        行锁&#xA;        支持外键&#xA;        支持非锁定读  # 类似oracle, 默认读不产生锁&#xA;        面向联机事务(OLTP)&#xA;        数据放在一个逻辑表空间中    # 类oracle&#xA;        实现4种隔离级别&#xA;            默认可重复读repeatable, 使用next-key locking的策略避免幻读&#xA;        索引组织表(Clustered)的方式进行存储     # 类oracle&#xA;        内存池维护并发线程&#xA;    注意&#xA;        自增id最大值放在内存中，重启后会再查找。MyISAM的自增id最大值在文件中，重启不丢失。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;count(*)&#xA;count(name)                        # 不统计null，所以不推荐，会漏数据&#xA;sum(english)/count(*) as 英语平均分&#xA;avg(chinese)&#xA;max(english)&#xA;min(english)&#xA;password(&#39;jiaoningbo&#39;)&#xA;concat(&#39;jiao&#39;,&#39;ning&#39;,&#39;bo&#39;)                concat(38.8) # 连接                转换数字到字符串&#xA;cast(38.8 as char)                        # 转换数字到字符串  同 concat(38.8) 但这个更正式&#xA;strcmp(&#39;text&#39;,&#39;text2&#39;)                # 比较字符串，相同则返回0，不同则返回-1&#xA;abs(&#39;-1&#39;)                                        # 绝对值&#xA;crc32(&#39;mysql&#39;)                                # 计算循环冗余码校验值并返回一个 32比特无符号值&#xA;pi()                                                # pi&#xA;floor(1.2)                                        # 取整 返回一个bigint&#xA;mod(29,9)                                        # 取摩&#xA;is                                                        # select 1 is true,0 is false,null is unknown,null is not unknown  结果 ：1,1,1,0&#xA;coalesce(null,1)                        # 返回第一个非空值，全空则返回null&#xA;greatest(0,2,66,34)                        # 返回不定参数个数的 参数的最大值，个数为0时返回null&#xA;least(2,0)                                        # 返回不定参数个数的 参数的最小值，个数为0时返回null&#xA;1 xor 0 xor 1                                # 异或，两个1消为0&#xA;ascii(&#39;ab&#39;)                                        # 返回最左字符的ascii码&#xA;bin(13)                                                # 返二进制&#xA;bit_length(&#39;text&#39;)                        # 返回二进制长度&#xA;char_length(&#39;str&#39;)                        # 返回字符长度&#xA;left(&#39;foobar&#39;,5)                        # 截取左数前5个&#xA;right(&#39;foobar&#39;,4)                        # 截取右数前4个&#xA;locate(&#39;bar&#39;,&#39;foobar&#39;)                # 返回位置4&#xA;locate(&#39;bar&#39;,&#39;foobarbar&#39;,5)        # 返回从5开始数的子串的位置，这里是7&#xA;ltrim(str)                                        # 去左空格&#xA;rtrim(str)                                        # 去右空格&#xA;trim(str)                                        # 去空格&#xA;make_set(1|4,&#39;hello&#39;,&#39;nice&#39;,&#39;world&#39;)                # 第一位是bit,1|4 表示1+4=5 即二进制101，所以显示结果为&amp;quot;hello,world&amp;quot;, 0 输出空字符串&#xA;repeat(&#39;m&#39;,3)                                # 重复&#xA;replace(&#39;wb&#39;,&#39;w&#39;)                        # replaceAll&#xA;reverse(str)                                # 倒序&#xA;space(6)                                        # 输出6个空格&#xA;adddate(&#39;1998-01-02&#39;,31)        # 加日期  同 adddate(&#39;1998-01-02&#39;,interval 31 day)同 date_add(&#39;1998-01-02&#39;,interval 31 day)&#xA;addtime(&#39;1997-12-31 23:59:59.999999&#39;,&#39;1 1:1:1.000002&#39;)        #加时间 同 &#39;1997-12-31 23:59:59.999999&#39;,&#39;1 1:1:1.000002&#39;);&#xA;curdate()+ 3                                # 当前日期 + 3 天&#xA;date(str)                                        # 提取日期时间表达字符串中的日期部分&#xA;date(&#39;1997-11-12&#39;,&#39;1997-11-11&#39;)                # 前面减后面 得到天数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;系统库数据字典&#34;&gt;&#xA;  系统库/数据字典&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e5%ba%93%e6%95%b0%e6%8d%ae%e5%ad%97%e5%85%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;系统库&#xA;    information_schema&#xA;        # 默认内置元信息数据库&#xA;        INNODE_TRX&#xA;            # 当前开启的事务&#xA;    mysql&#xA;        # 内置安全设置数据库&#xA;    performance_schema&#xA;        # 资源消耗，资源等待等情况&#xA;    sys&#xA;        # 5.7后，数据来源performance_schema, 降低复杂度&#xA;    test&#xA;        # 5.7移除，内置测试数据库&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;触发器trigger&#34;&gt;&#xA;  触发器(trigger)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a6%e5%8f%91%e5%99%a8trigger&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;new与old&#xA;    # 指代新数据&#xA;    insert只有new是合法的；&#xA;    delete只有old才合法；&#xA;    update可同时使用。&#xA;语句&#xA;    show triggers [from schema_name];&#xA;    drop trigger [if exists] [schema_name.]trigger_name&#xA;例1&#xA;    create trigger tr1&#xA;    after                   # before, after&#xA;    insert on tb1           # insert, update, delete&#xA;    for each row&#xA;    update tb2 set field1 = field1+char_length(new.name);&#xA;        # 当更新表tb1的name字段时，更新表tb2 field1加上name的长度&#xA;例2      # UPDATE同时使用NEW和OLD&#xA;    create trigger tr1&#xA;    before update on t22&#xA;    for each row&#xA;    begin&#xA;    set @old = old.s1;&#xA;    set @new = new.s1;&#xA;    end;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储过程stored-procedure&#34;&gt;&#xA;  存储过程(stored procedure)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8bstored-procedure&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 5.0加入&#xA;结束符号(delimiter) //&#xA;语法&#xA;    create procedure 存储过程名(参数类型 参数名 参数数据类型)&#xA;    begin&#xA;            业务逻辑&#xA;    end//&#xA;&#xA;    call pro1()//&#xA;        # 执行&#xA;&#xA;    drop function pro1;&#xA;&#xA;    语句&#xA;        # 所有sql语句都是合法的&#xA;&#xA;        declare a int default 2;&#xA;&#xA;        set @name = &#39;admin&#39;;&#xA;            # @name 为局部变量        @@name 为全局变量&#xA;&#xA;        if&#xA;        then&#xA;        else&#xA;        end if;&#xA;&#xA;        case variable1&#xA;        when 0 then&#xA;        when 1 then&#xA;        else&#xA;        end case&#xA;&#xA;        while true do&#xA;        end while&#xA;&#xA;        loop_label:LOOP&#xA;        LEAVE[ITERATE] loop_label;&#xA;        end loop [end loop_label]        # iterate是迭代&#xA;&#xA;        LABEL label_name&#xA;        GOTO label_name&#xA;&#xA;        repeat until&#xA;        end repeat # 执行后检查结果&#xA;&#xA;存储过程名&#xA;    大小写不敏感&#xA;    可以包含空格，最长为64位&#xA;    最好数据库名.过程名&#xA;    不要使用内建函数名&#xA;参数类型&#xA;    IN参数    # 不修改传递进来的参数&#xA;    OUT参数   # 参数无法传进来，只修改参数&#xA;    INOUT参数 # 可读可写&#xA;&#xA;特征子句(characteristics clauses)&#xA;查看&#xA;    show procedure status;&#xA;    show create procedure proc_name;&#xA;    show create function func_name;&#xA;    &#xA;&#xA;异常&#xA;    DECLARE&#xA;    { EXIT | CONTINUE }&#xA;    HANDLER FOR&#xA;    { error-number | { SQLSTATE error-string } | condition }&#xA;    SQL statement&#xA;&#xA;    DECLARE EXIT HANDLER FOR 1216&#xA;    DECLARE CONTINUE HANDLER FOR not found        # 写在存储过程的begin后，当前程序出错后会自动触发代码 MySQL允许两种处理器，&#xA;                                                                                    ## 一种是EXIT处理，上面所用的就是这种。另一种就是我们将要演示的，CONTINUE处理，&#xA;                                                                                    ## 它跟EXIT处理类似，不同在于它执行后，原主程序仍然继续运行&#xA;    DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;23000&#39; SET @x2 = 1; # 如果下面将@x2的值赋为1就会出错&#xA;    DECLARE EXIT HANDLER FOR `Constraint Violation` ROLLBACK;        # 回滚&#xA;&#xA;    DECLARE `Constraint Violation` CONDITION FOR SQLSTATE &#39;23000&#39;;&#xA;    DECLARE EXIT HANDLER FOR `Constraint Violation` ROLLBACK;                        # 先声明条件&#xA;&#xA;游标&#xA;    declare cur_1 cursor for select s1 from t;&#xA;    open cur_1&#xA;    fetch cur_1 into a&#xA;    close cur_1&#xA;&#xA;函数&#xA;    # 与存储过程唯一不同必须有RETURN语句&#xA;    # 不能在函数中访问表&#xA;                &#xA;    function example1:&#xA;    create function myadd(num1 int, num2 int)&#xA;    returns int&#xA;    begin&#xA;    return num1 + num2;&#xA;    end//&#xA;&#xA;                &#xA;例1&#xA;    create procedure pro(in name varchar(20))&#xA;    begin&#xA;    select name;&#xA;    set name=&#39;hello world&#39;;&#xA;    select name;&#xA;    end//&#xA;&#xA;    set @name=&#39;jnb&#39;//&#xA;    call pro(@name)//&#xA;&#xA;例2      # if语句，根据输入0/1 判断 男/女&#xA;    create procedure findGender(in op int)&#xA;    begin&#xA;    declare gendar varchar(20);                                # 在函数中定义变量gendar和其类型&#xA;    if op=0 then                                                        # =表示判断&#xA;    set gendar=&#39;male&#39;;&#xA;    else set gendar=&#39;female&#39;;&#xA;    end if;&#xA;    select gendar;&#xA;    end//&#xA;&#xA;例3      # switch语句，判断星期&#xA;    create procedure findday(in day int)&#xA;    begin&#xA;    declare findday varchar(20);&#xA;    case day&#xA;    when 1 then set findday=&#39;星期一&#39;;&#xA;    when 2 then set findday=&#39;星期二&#39;;&#xA;    when 3 then set findday=&#39;星期三&#39;;&#xA;    when 4 then set findday=&#39;星期四&#39;;&#xA;    when 5 then set findday=&#39;星期五&#39;;&#xA;    when 6 then set findday=&#39;星期六&#39;;&#xA;    when 7 then set findday=&#39;星期七&#39;;&#xA;    else set findday=&#39;无效&#39;;&#xA;    end case;&#xA;    select findday;&#xA;    end//&#xA;        &#xA;例4      # while循环&#xA;    create procedure findsum(in n int)&#xA;    begin&#xA;    declare sum int default 0;&#xA;    declare i int default 0;&#xA;    while i&amp;lt;=n do&#xA;    set sum=sum+i;&#xA;    set i=i+1;&#xA;    end while;&#xA;    select sum;&#xA;    end//&#xA;        &#xA;例5      # 验证登录&#xA;    create procedure prologin(in user_name varchar(20), in user_psw varchar(100), out flag int)&#xA;    begin&#xA;    if exists(select name from users where name=user_name and psw=password(user_psw)) then&#xA;            set flag = 1;&#xA;    else&#xA;            set flag = 0;&#xA;    end if;&#xA;    end//&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; my.cnf文件&#xA;[client]&#xA;&#xA;port=3306&#xA;socket=/tmp/mysql.sock&#xA;&#xA;[mysql]&#xA;default-character-set=gbk&#xA;&#xA;[mysqld]&#xA;character-set-server=utf8&#xA;&#xA;port=3306&#xA;socket=/tmp/mysql.sock&#xA;log-bin=mysql-bin&#xA;server-id=1&#xA;skip-name-resolve&#xA;        # 远程访问时非常慢解决&#xA;innodb-flush-log-at-trx-commit=2&#xA;innodb_log_file_size=268435456&#xA;sync-binlog=1&#xA;        # 这两个配置为了使用事务的InnoDB在复制中最大的持久性和一致性&#xA;master-connect-retry=60&#xA;        # 从服务器断开重连时间&#xA;binlog-do-db=test&#xA;        # 主从都可以设置，复制的数据库&#xA;binlog-ignore-db=mysql&#xA;        # 主从都可以设置，不复制的数据库&#xA;lower_case_table_names=1&#xA;        # 设置大少写不敏感&#xA;interactive_timeout=3600&#xA;sql_mode=IGNORE_SPACE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;安全性&#34;&gt;&#xA;  安全性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e5%85%a8%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;跨域访问，使用ssh隧道加密通信&#xA;set password设置密码&#xA;用grant和revoke对用户授权&#xA;    少开权限&#xA;    只有启动mysql的用户有写权限&#xA;    只授权process和super权限给管理用户&#xA;        mysqladmin processlist 可列举当前执行的查询&#xA;        super 可切断连接，改变服务器运行参数，控制从库&#xA;    不信任dns时，权限表只设置ip&#xA;常见攻击&#xA;    防偷听&#xA;    篡改&#xA;    回放&#xA;    拒绝服务&#xA;acl控制接口权限&#xA;设置只有root可访问mysql数据库和user表&#xA;不用明文密码，密码强度高&#xA;数据库放在防火墙后，或在DMZ(demilitarized zone, 隔离区)&#xA;防火墙设置3306端口不可访问&#xA;sql预编译，避免sql注入&#xA;存数据时检查大小&#xA;以普通用户启动mysql&#xA;tcpdump检查传输数据的安全性&#xA;    tcpdump -l -i eth0 -w -src or dst port 3306 strings&#xA;max_user_connections变量限制指定帐户连接数&#xA;打开mysqld安全开关&#xA;    --local-infile=0     # 0时客户端无法使用local load data&#xA;    --skip-grant-tables     # 对用户不做访问控制&#xA;        mysqladmin flush-privileges # 运行中开启访问控制&#xA;        mysqladmin reload           # 运行中开启访问控制&#xA;    --skip-show-databases   # 禁止show databases&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;方案&#34;&gt;&#xA;  方案&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;初始化&#xA;    systemctl start mariadb&#xA;    mysql_secure_installation&#xA;    etc/my.cnf文件&#xA;        [mysqld]&#xA;        default-storage-engine = innodb&#xA;        innodb_file_per_table&#xA;        max_connections = 4096&#xA;        collation-server = utf8_general_ci&#xA;        character-set-server = utf8&#xA;        [mysql]&#xA;        default-character-set=utf8&#xA;    systemctl restart mariadb&#xA;移数据库&#xA;    同mysql版本, 新目录下替换(/var/lib/mysql/)ibdata1、数据库名目录&#xA;    error: mysqld does not have the access rights to the directory. File name ./ibdata1&#xA;        chcon -R --reference=/var/lib/mysql 新目录&#xA;        或&#xA;        chcon -R -t mysqld_db_t -u system_u -r object_r 新目录&#xA;重初始化数据库&#xA;    rm -r /var/lib/mysql/*&#xA;    mysql_install_db&#xA;    chown mysql:mysql -R /var/lib/mysql&#xA;    systemctl restart mariadb&#xA;    mysql -uroot mysql&#xA;    update user set password=password(&#39;asdf&#39;) where user=&#39;root&#39;;&#xA;    flush privileges;&#xA;授权远程登录&#xA;    GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;asdf&#39; WITH GRANT OPTION;&#xA;创建用户&#xA;    CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;&#xA;删除用户&#xA;    DROP USER &#39;username&#39;@&#39;host&#39;;&#xA;免密登录&#xA;    mysql_safe --user=mysql --skip-grant-tables --skip-networking&#xA;修改密码&#xA;    问题&#xA;        error 1045(28000) access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:no)&#xA;    不能登录时&#xA;        mysqld_safe方式&#xA;            mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;amp;&#xA;            mysql -u root mysql&#xA;            update user set password=password(&#39;newpassword&#39;) where user=&#39;root&#39;;&#xA;                    # 新版中password改为authentication_string&#xA;            flush privileges;&#xA;        mysqld_safe方式2&#xA;            创建a.sql&#xA;                update mysql.user set password=password(&#39;mysql&#39;) where user=&#39;修改用户&#39;;&#xA;                flush privileges&#xA;            mysqld_safe --defaults-file=&amp;quot;a.sql&amp;quot;&#xA;        文件方式&#xA;            使用/etc/mysql/my.cnf中[client]下的user与password&#xA;    能登录时&#xA;        mysqladmin方式&#xA;            mysqladmin -uroot -p password 新密码&#xA;        update方式&#xA;            update mysql.user set password=password(&#39;root&#39;) where user=&#39;root&#39;;&#xA;            flush privileges;&#xA;        set方式&#xA;            SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;newpassword&#39;);&#xA;            flush privileges;&#xA;编码问题&#xA;    查询&#xA;        show variables like &amp;quot;%colla%&amp;quot;       # 字符串排序规则&#xA;        show variables like &amp;quot;%char%&amp;quot;&#xA;    修改&#xA;        set character_set_client=&#39;utf8&#39;&#xA;    创建db时指定&#xA;        create database `db1` character set &#39;utf8&#39; collate &#39;utf8_general_ci&#39;&#xA;    创建表时指定&#xA;        create table (...) engine=innodb default charset=utf8&#xA;    查看db和表编码&#xA;        show database `db1`&#xA;        show create table `tb1`&#xA;    修改db和表编码&#xA;        alter database `db1` default character set utf8 collate utf8_general_ci&#xA;        alter table `tb1` default character set utf8 collate utf8_general_ci&#xA;导库&#xA;    导出&#xA;        o-&amp;gt;&#xA;        mysqldump -uroot -p db1 &amp;gt; db1.sql&#xA;        o-&amp;gt;&#xA;        mysqldump -uroot -p db1 tb1 &amp;gt; db1_tb1.sql&#xA;    导入&#xA;        o-&amp;gt;&#xA;        mysql -uroot -p db1 &amp;lt; db1.sql&#xA;        o-&amp;gt; 数据库中&#xA;        source db1.sql&#xA;主从复制&#xA;    mysql配置文件my.cnf&#xA;    [mysqld]&#xA;        log-bin=mysql-bin&#xA;        server-id=222&#xA;        log-slave-updates =1&#xA;            # m-m-s结构中第二个m配置&#xA;    主服务器授权从服务器&#xA;        GRANT REPLICATION SLAVE ON *.* to &#39;slave&#39;@&#39;%&#39; identified by &#39;asdf&#39;;&#xA;    从服务器设置主服务器&#xA;        change master to master_host=&#39;192.168.56.14&#39;, master_user=&#39;slave&#39;, master_password=&#39;asdf&#39;, master_log_file=&#39;mysql-bin.000001&#39;, master_log_pos=319;&#xA;    命令&#xA;        主服务器&#xA;            flush tables with read lock;&#xA;            grant replication slave on *.* to &#39;slave&#39;@&#39;%&#39; identified by &#39;asdf&#39;&#xA;            show master status\G&#xA;            unlock tables;&#xA;        从服务器&#xA;            stop slave&#xA;            change master to master_host=&#39;192.168.0.42&#39;, master_user=&#39;slave&#39;, master_passowrd=&#39;asdf&#39;, master_log_file=&#39;mysql-bin.000001&#39;, master_log_pos=120;&#xA;            start slave&#xA;            show slave status\G&#xA;    问题&#xA;        The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.&#xA;            # 随意修改data/auto.cnf中的uuid的值&#xA;        主A复制到主B后，主B不会把数据复制到主B的从&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ukeate.com/docs/db/oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ukeate.com/docs/db/oracle/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;安装&#xA;    运行services.msc&#xA;    找到OracleServiceORCL 服务 （最后是数据库名）改为手动&#xA;    sqlplus / as sysdba 运行oracle测试是否安装成功&#xA;    解锁scott用户&#xA;        sqlplus / as sysdba&#xA;        alter user scott account unlock;&#xA;        alter user scott identified by tiger;&#xA;启动&#xA;    OracleServiceORCL&#xA;    OracleOraDb11g_home1TNSListener&#xA;端口&#xA;    1521    # 停了以后再开会变&#xA;权限&#xA;    系统权限：创建数据库，创建用户&#xA;    对象权限：表操作&#xA;    sys create database权限&#xA;    system  没有create database权限&#xA;    scott&#xA;    hr&#xA;    角色  # 超管以角色进入，普通用户输入用户名密码&#xA;        dba&#xA;        dbaoperator&#xA;服务器的组成&#xA;    oracle数据库&#xA;        存储位置 oracle安装位置/oradata/&#xA;            每个数据库文件夹中有多个二进制文件（*.dbf）&#xA;    oracle实例(内存概念)&#xA;        一个数据库进程可以有多个实例&#xA;        一个实例可以有多个数据库进程和一个内存池(缓存)    # 不同于windows进程，每个进程对应一个用户访问&#xA;        服务名为OracleService数据库名&#xA;    集群(多实例)&#xA;        连接失败转移&#xA;        负载均衡&#xA;连接类型&#xA;    normal sysdba sysoper&#xA;分布式&#xA;认证&#xA;    开发技术认证&#xA;    Java认证&#xA;                数据库开发语言SQL和PL/SQL认证&#xA;    数据库技术认证&#xA;        OCM【大师】&#xA;        OCP【专家】&#xA;        OCA【初级】&#xA;    中间件技术认证&#xA;        OracleServer认证，WEB服务器认证&#xA;    专业领域技术认证&#xA;        ERP&#xA;        CRM&#xA;        HR&#xA;        OA&#xA;支持的事务隔离&#xA;    只支持读提交与序列化两种&#xA;版本&#xA;    8i 9i 10i   # i是internet&#xA;    11g         # 基于jdk6, g是grid网格(一个请求多个服务器运行)&#xA;    12c         # c是cloud&#xA;SQL99标准     # 不区分大小写&#xA;    PLSQL是Oracle对SQl99标准的扩展&#xA;    结构代查询语言&#xA;        DML select,insert,update,delete&#xA;        DDL create table,alter table, drop table&#xA;        DCL grant, revoke&#xA;        TCL(杜撰) commit, rollback,rollback to savepoint&#xA;加载过程&#xA;     启动oracle服务&#xA;        oradim -startup -sid 数据库名                 # 相当于windows服务中启动该服务，会从windows注册表中加载配置&#xA;        oradim -shutdown -sid orcl -shuttype srvc    # 停止oracle 服务&#xA;        普通登录&#xA;            sqlplus system/asdf                 # 从注册表中查找默认的数据库名称进行登录&#xA;            sqlplus system/asdf@orcl            # 指定数据库名登录，必须有监听的时候该命令可以执行，监听的进程是独立于oracle之外的进程&#xA;        管理员登录&#xA;            sqlplus / as sysdba                 # windows管理员的身份进行登录，不需要用户名密码，可以在配置文件中禁用它&#xA;        无连接登录&#xA;            sqlplus /nolog                      #用来设置sql/plus&#xA;    启动实例&#xA;        cmd&amp;gt; sqlplus / as sysdba                    # 连接到数据库的空闲实例&#xA;        sql&amp;gt; select status from v$instance          # 查看实例状态&#xA;        sql&amp;gt; shutdown abort                         # 立即终止当前的实例,实例结束后用户仍然登录状态，但没有连接实例&#xA;        sql&amp;gt; startup nomount                        # 启动默认实例（不加载数据库）&#xA;        sql&amp;gt; startup open                           # 启动、装载、打开默认的数据库&#xA;        cmd&amp;gt; set oracle_sid=orcl                    # 在windows下设置oracle的默认登录数据库&#xA;&#xA;        启动过程&#xA;            加载参数文件database/init数据库名&#xA;            分配sga (system global area)到内存空间，用于缓存数据库信息&#xA;            创建后台进程&#xA;    挂载数据库&#xA;        sql&amp;gt; startup mount&#xA;&#xA;        挂载过程&#xA;            装载数据库文件夹中的文件    # sga中有已经初始化了ctl文件的路径，通过ctl文件装载数据库&#xA;            ctl(从中得到数据库文件名) -&amp;gt; dbf&#xA;                    # 3种数据库文件: .ctl(控制文件) .dbf(数据库文件) .log(日志文件)&#xA;            这时，数据库还是不能访问,但是管理员可以访问（debug数据库）&#xA;    打开数据库       # 使外界可以访问&#xA;        sql&amp;gt; alter database 数据库名 open                # 数据库文件夹中记录日志&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;varchar2(7)        # 可变字符串&#xA;char                # 字符&#xA;number(precision [, scale])    # presision是有效位（从左边第一个不为0的数算起，小数点和负号不计入有效位数），scale是精确位（正数为小数的精确位，负数为整数的精确位）&#xA;constant number                # 常量&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;数据字典&#34;&gt;&#xA;  数据字典&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ad%97%e5%85%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;dual                # dual表只有一行，用于执行一些特殊操作&#xA;dba_sequences&#xA;        select SEQUENCE_OWNER,SEQUENCE_NAME from dba_sequences&#xA;                # 查询序列&#xA;dba_users&#xA;        select username,password from dba_users;&#xA;                # 查询用户和密码&#xA;tab&#xA;        select * from tab&#xA;                # 查看自己的可用表，视图，等&#xA;v$session&#xA;        select count(*) from v$session&#xA;                # 查看当前数据库的连接&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;存储过程&#34;&gt;&#xA;  存储过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;过程与函数&#xA;    返回值&#xA;        函数有且只一个返回值&#xA;        过程没有或多个返回值用(out参数)&#xA;        过程可返回函数,函数只能返回值或表对象&#xA;    过程和函数不能重名&#xA;    函数可嵌入sql执行，过程不行&#xA;语法&#xA;    IF .. THEN&#xA;            null;&#xA;    ELSIF .. THEN&#xA;            null;&#xA;    ELSE&#xA;            null;&#xA;    END IF;&#xA;&#xA;    select into给变量赋值&#xA;&#xA;    raise 异常名   # 抛异常&#xA;函数&#xA;    create or replace function calculate_score&#xA;    ( cat in varchar2&#xA;    , score in number&#xA;    , weight in number&#xA;    ) return number as&#xA;    begin&#xA;    return null;&#xA;    end calculate_score;&#xA;&#xA;&#xA;    例子1     # in参数 和返回值的函数&#xA;        create or replace function findEmpIncome(pempno in number) return number&#xA;        as&#xA;            income number(10);&#xA;        begin&#xA;            select sal*12+NVL(comm,0) into income from emp where empno = pempno;&#xA;            return income;&#xA;        end;&#xA;        /&#xA;    例子2     # in、out 参数和返回值的函数&#xA;        create or replace function findEmpNameAndSal (pempno in number, psal out number)return varchar2&#xA;        as&#xA;        pename emp.ename%type;&#xA;        begin&#xA;        select ename , sal into pename,psal from emp where empno = pempno;&#xA;        return pename;&#xA;        end;&#xA;        /&#xA;        执行&#xA;        declare&#xA;        psal emp.sal%type;&#xA;        pename emp.ename%type;&#xA;            begin&#xA;                pename := findEmpNameAndSal(7788,psal);&#xA;                dbms_output.put_line(pename||&#39;的工资是&#39;||psal);&#xA;            end;&#xA;            /&#xA;过程&#xA;    # 参数默认in&#xA;    create or replace procedure add_evaluation&#xA;    ( evaluation_id in number&#xA;    , employee_id in number&#xA;    , evaluation_date in date&#xA;    , job_id in varchar2&#xA;    , manager_id in number&#xA;    , department_id in number&#xA;    ) as            # as 变量 类型 (值范围);&#xA;    begin&#xA;    null;&#xA;    exception&#xA;        when others then&#xA;            rollback;&#xA;    end add_evaluation;&#xA;&#xA;    exec  add_evaluation&#xA;&#xA;    drop procedure add_evaluation;&#xA;&#xA;    例子1                # in 参数的使用&#xA;        create or replace procedure raiseSalary(pempno in emp.empno%type)&#xA;        as&#xA;        begin&#xA;            update emp set sal = sal * 1.1 where empno = pempno;&#xA;        end;&#xA;        /&#xA;        exec raiseSalary(7369);&#xA;    例子2                # out参数的使用                select into&#xA;        create or replace procedure findEmpNameAndSalAndJob (pempno in emp.empno%type,&#xA;        pename out emp.ename%type,&#xA;        pjob out emp.job%type,&#xA;        psal out emp.sal%type)&#xA;        as&#xA;        begin&#xA;            select ename,job,sal into pename,pjob,psal from emp where empno = pempno;&#xA;        end;&#xA;        /&#xA;        declare&#xA;            pename emp.ename%type;&#xA;            pjob  emp.job%type;&#xA;            psal  emp.sal%type;&#xA;        begin&#xA;            findEmpNameAndSalAndJob(7788,pename,pjob,psal);&#xA;            dbms_output.put_line(&#39;7788号员工的姓名是&#39;||pename||&#39;,职位是&#39;||pjob||&#39;,薪水是&#39;||psal);&#xA;        end;&#xA;        /&#xA;包&#xA;    声明&#xA;        create or replace PACKAGE emp_eval AS&#xA;        PROCEDURE eval_department(department_id IN NUMBER);&#xA;        FUNCTION calculate_score(evaluation_id IN NUMBER , performance_id IN NUMBER)&#xA;            RETURN NUMBER;&#xA;        END emp_eval;&#xA;    定义&#xA;        CREATE OR REPLACE PACKAGE BODY emp_eval AS&#xA;&#xA;        PROCEDURE eval_department(department_id IN NUMBER) AS&#xA;        BEGIN&#xA;            /* TODO implementation required */&#xA;            NULL;&#xA;        END eval_department;&#xA;&#xA;        FUNCTION calculate_score(evaluation_id IN NUMBER , performance_id IN NUMBER)&#xA;            RETURN NUMBER AS&#xA;        BEGIN&#xA;            /* TODO implementation required */&#xA;            RETURN NULL;&#xA;        END calculate_score;&#xA;&#xA;        END emp_eval;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;触发器&#34;&gt;&#xA;  触发器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a6%e5%8f%91%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    # select 没有触发器&#xA;    语句级insert / delete           # 只在语句执行时触发&#xA;    行级(for each row)update        # 每一行都执行，出错后不会继续执行并且回滚&#xA;语法&#xA;    create [or replace] trigger 触发器名&#xA;    {before|after}&#xA;    {insert|delete|update of 列名}&#xA;    on 表名&#xA;    for each row&#xA;    plsql块&#xA;&#xA;    行级触发器中&#xA;        :new 代表更新后那一行整行的值&#xA;        :old 则是旧的整行的值&#xA;        update of 列名 for each row是连起来用的。语句级触发器没有for each row&#xA;&#xA;    drop trigger 触发器名&#xA;&#xA;例子(语句级)&#xA;    # 当在休息日与非9点到17点之间的时候，禁止对emp表进行插入操作&#xA;    create or replace trigger securityTrigger&#xA;    before insert on emp&#xA;    declare&#xA;    pday varchar2(10);&#xA;    phour number(20);&#xA;    begin&#xA;    select to_char(sysdate,&#39;day&#39;) into pday from dual;&#xA;    select to_char(sysdate,&#39;hh24&#39;) into phour from dual;&#xA;    if(pday in (&#39;星期六&#39;,&#39;星期日&#39;) or (phour not between 9 and 17)) then&#xA;    raise_application_error(&#39;-20666&#39;,&#39;禁止操作&#39;);&#xA;    end if;&#xA;    end;&#xA;    /&#xA;例子(行级)：当对每一行的工资进行修改的时候，新的工资不能小于原来的工资&#xA;    create or replace trigger checkSalayTrigger&#xA;    before update of sal on emp for each row&#xA;    begin&#xA;    if :new.sal &amp;lt; :old.sal then&#xA;    raise_application_error(&#39;-20555&#39;,&#39;工资不能减少&#39;);&#xA;    end if;&#xA;    end;&#xA;    /&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数及常量&#34;&gt;&#xA;  函数及常量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%8f%8a%e5%b8%b8%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;常量&#xA;    sysdate 当前日期&#xA;&#xA;单行函数&#xA;    nvl(comm,0)                        # 替换comm列中的空值为0&#xA;    nvl2(comm,comm,0)                # 替换comm列中的空值为0，非空时为comm&#xA;    select lower(&#39;AAA&#39;) from dual;                        # 取小写&#xA;    upper(&#39;&#39;)                # 取大写&#xA;    initcap(&#39;www.itcast.cn&#39;)        # 每一段字符串的首字符大写&#xA;    concat(&#39;&#39;,&#39;&#39;)                        # 拼接字符串&#xA;    substr(&#39;itcast&#39;,1,3)        # 取第一个和第三个字符，脚标从1开始&#xA;    length(&#39;&#39;)                # 字符的长度&#xA;    lengthb(&#39;&#39;)                # 字节的长度&#xA;    instr(&#39;itcast&#39;,&#39;t&#39;)      # 查找第一个匹配字符串的位置,区分大小写&#xA;    lpad(&#39;a&#39;,10,&#39;*&#39;)                # 左填充，一直到10位,也可以截取左边的10位字节（并非字符）&#xA;    rpad(&#39;a&#39;,10,&#39;*&#39;)                # 右填充，一直到10位,也可以截取右边的10位字节（并非字符）&#xA;    trim(&#39;x&#39; from &#39;xxhelloxsx&#39;)                # 增强版trim(),去掉字符串中的所有&#39;x&#39;&#xA;    replace(&#39;hello&#39;,&#39;l&#39;,&#39;o&#39;)                # 替换字符串中的&#39;l&#39; 为 &#39;o&#39;&#xA;    round(3.45,2)                # 四舍五入，2代表小数点后的位数  -1代表个位，-2代表十位&#xA;            round(sysdate,&#39;month&#39;)      # 四舍五入到月(15号前后判断)&#xA;    round(sysdate,&#39;year&#39;)      # 四舍五入到年(6月30号前后判断)&#xA;    trunc(3.142,1)                # 截取小数点后1位&#xA;    mod(10,3)                        # 10mod3取余&#xA;    nullif(10,20)                # 比较两个数值，相同时返回空，不同时返回第一个数值&#xA;    (job,&#39;analyst&#39;,sal + 1000,&amp;quot;manager&amp;quot;,sal + 800, sal + 400) &amp;quot;新工资&amp;quot; from emp;&#xA;    decode(...)函数：例子&#xA;        select ename &amp;quot;姓名&amp;quot; , sal &amp;quot;原工资&amp;quot; , decode(job, &#39;analyst&#39;,sal + 1000, &#39;manager&#39;,sal + 800, sal + 400) &amp;quot;新工资&amp;quot; from emp;&#xA;        select ename &amp;quot;姓名&amp;quot; , sal &amp;quot;原工资&amp;quot; , case job when &#39;analyst&#39; then sal + 1000 when &#39;manager&#39; then sal + 800 else sal + 400 end &amp;quot;新工资&amp;quot; from emp&#xA;            #sql99语法&#xA;    日期函数&#xA;        sysdate +/- 1                # 增加或减少1天&#xA;        sysdate - hiredate                # 日期减日期，得到天数&#xA;        to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;)                # 格式化显示时间&#xA;        months_between(&#39;12-2月-13&#39;,sysdate)        # 日期之间的月数&#xA;        add_months(sysdate,1)                # 给当前日期增加1个月&#xA;        next_day(sysdate,&#39;星期一&#39;)        # 下一个星期一的日期&#xA;        last_day(sysdate)                        # 反回这个月的最后一天&#xA;    类型转换：&#xA;        隐式转换                # 要求 1，格式正确。2，内容合理&#xA;            字符串与Date,number相互转换&#xA;        显式转换&#xA;            到字符串：&#xA;                日期到字符串：to_char(sysdate,&#39;yyyy &amp;quot;年&amp;quot; mm &amp;quot;月&amp;quot; dd &amp;quot;日&amp;quot; day hh12:mi:ss:am&#39;)&#xA;                    # day是星期、hh12是12进制计时(hh24代表24进制计时)、am是个变量,上午时是am，下午是pm&#xA;                    ##　双引号中的内容直接显示&#xA;                货币值到字符串：to_char(1234,&#39;L9,999&#39;)&#xA;                    # L可以小写，代表当地货币，&#39;,&#39;可以省略&#xA;            字符串到Date： to_date(&#39;1980-12-17&#39;,&#39;yyyy-mm-dd&#39;)&#xA;            字符串转换到数字：        to_number(&#39;123&#39;)&#xA;多行函数    # 多行函数分为接收多个输入，返回一个输出。&#xA;           ##　多行函数本身不会统计值为null的记录&#xA;           ## 多表的多行函数的统计多会用到group by ，因为where 只是筛选出了不符合条件的部分&#xA;           ## ,剩下的部分分列在不同的表中，只有按照列名分组以后才能按列名执行多行函数&#xA;    having&#xA;    count([distinct] deptno)                # 统计deptno【不重复的】记录数&#xA;    sum(sal)                # 统计数值的和&#xA;    avg(sal)                # 统计平均值&#xA;    max(sal)                # 统计最大值，可以用在日期上&#xA;    min(sal)                # 统计最小值 ，可以用在日期上&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;游标&#34;&gt;&#xA;  游标&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b8%b8%e6%a0%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    显示&#xA;        cursor is&#xA;    隐式&#xA;        执行insert, delete, update，返回单条记录的select时，pl/sql自动定义&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;闪回技术&#34;&gt;&#xA;  闪回技术&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%aa%e5%9b%9e%e6%8a%80%e6%9c%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;可以闪回的操作&#xA;        dml &#xA;        ddl操作（回收站中存在）&#xA;&#xA;闪回记录&#xA;        1.获取当前时间与改变号&#xA;            select to_char(sysdate,&#39;yyyy-mm-dd:mi:ss&#39;) &amp;quot;系统时间&amp;quot;, timestamp_to_scn(sysdate) &amp;quot;系统改变号&amp;quot; from dual;&#xA;                    # scn 是 系统改变号，每秒钟都会变，oracle根据它来进行闪回,如1216687&#xA;    2.给普通用户授于闪回的权限&#xA;        grant flashback any table to scott;&#xA;    3.alter table emp enable row movement;      # 更改rowid号可以更改&#xA;    4.flashback table emp to SCN 1216687;      # 闪回表到时间改变号&#xA;        # 如果没有做第三步，这里会出错 ，原因是 还原表记录时，递增的rowid后面不能插入数据。在rowid之间插入数据必须改变rowid的状态为可以&#39;移动&#39;，即还原记录后面的表记录可以&#39;移动&#39;。 &#xA;&#xA;闪回表（回收站中才可以）&#xA;        1.确定回收站中有该表，可以用show recyclebin命令查看&#xA;        2.flashback table emp to before drop;&#xA;                # flachback table &amp;quot;BIN$Pu9C2euHQ96xySmn08e5aQ==$0&amp;quot; to before drop;        也是可以的&#xA;        3.如果回收站中有两个相同的表需要闪回时，设置一个表名&#xA;                flashback table emp to before drop rename to newemp;&#xA;                        # 两张同名的表首先恢复最近删除的表&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;审计&#34;&gt;&#xA;  审计&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%a1%e8%ae%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;审计（Audit)&#xA;        用于监视用户所执行的数据库操作，并且Oracle会将审计跟踪结果存放到OS文件（默认位置为$ORACLE_BASE/admin/$ORACLE_SID/adump/）&#xA;        或数据库（存储在system表空间中的SYS.AUD$表中，可通过视图dba_audit_trail查看）中。&#xA;        默认情况下审计是没有开启的。&#xA;        不管你是否打开数据库的审计功能，以下这些操作系统会强制记录：用管理员权限连接Instance；启动数据库；关闭数据库。&#xA;        &#xA;两个参数                # cmd&amp;gt; set xxx=xx&#xA;                        ## 这两个参数是static参数，需要重新启动数据库才能生效。&#xA;        Audit_sys_operations&#xA;                默认为false，当设置为true时，所有sys用户（包括以sysdba,sysoper身份登录的用户）的操作都会被记录，&#xA;                audit trail不会写在aud$表中，因为数据库还没有启动，conn / as sysdba 这样的命令是没法记录的&#xA;                windows平台记录在windows的事件管理中,unix平台记录在audit_file_dest参数指定的文件中&#xA;        Audit_trail&#xA;                None：是默认值，不做审计；&#xA;                DB：将audit trail 记录在数据库的审计相关表中，如aud$，审计的结果只有连接信息；&#xA;                DB,Extended：这样审计结果里面除了连接信息还包含了当时执行的具体语句；&#xA;                OS：将audit trail 记录在操作系统文件中，文件名由audit_file_dest参数指定；&#xA;                XML：10g里新增的。&#xA;                &#xA;审计级别&#xA;        Statement(语句)、Privilege（权限）、object（对象）。&#xA;        &#xA;        Statement        按语句来审计，比如audit table 会审计数据库中所有的create table,drop table,truncate table语句。&#xA;        Privilege        按权限来审计，当用户使用了该权限则被审计，如执行grant select any table to a，&#xA;        object                按对象审计，只审计on关键字指定对象的相关操作，如aduit alter,delete,drop,insert on cmy.t by scott; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;sqldeveloper&#xA;isqlplus&#xA;dbconsole&#xA;toad&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;sqlplus&#34;&gt;&#xA;  sqlplus&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sqlplus&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;命令&#xA;    # ;或/结束&#xA;&#xA;    /               # 执行最近一次的sql命令（不执行工具命令）&#xA;    host cls        # 清屏&#xA;    edit            # 用本地编辑器编辑&#xA;    设置显示&#xA;        column deptno format 9999       # deptno是列名,9999 代表4个数字宽度&#xA;        column ename format a8          # a8代表8个字符宽度(date也用a)&#xA;            col ename for a8            # 简写&#xA;        set pagesize 40                 # 设置一页显示40条记录&#xA;        spool d:/a.sql                  # 假脱机,开始记录控制台信息&#xA;            spool off                   # 正式保存记录信息到文件&#xA;            @ d:/a.sql                  # 从脱机文件中导入命令并执行&#xA;    监查时间&#xA;        set timing on / set timing off  # 每执行一段语句显示语句的执行时间&#xA;        set time on / set time off      # 在输入标记前面显示当前时间&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;plsql&#34;&gt;&#xA;  pl/sql&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#plsql&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;procedure language&#xA;oracle对sql99的扩展&#xA;    增加了类型定义&#xA;    判断&#xA;    循环&#xA;    指针/游标/光标&#xA;    输出语句&#xA;    异常&#xA;语法&#xA;    符号&#xA;        /   # 结束标记&#xA;        :=                # 赋值号&#xA;        &amp;amp;   # 进行定义运行时赋值&#xA;    语句&#xA;        declare    分号结束&#xA;        ;&#xA;        begin  dml语句/tcl语句,以分号结束 # 必写&#xA;        ;&#xA;        [exception]&#xA;        ;&#xA;        end;        # 必写&#xA;        /&#xA;&#xA;        set serveroutput on;        # 设置plsql的输出打开，默认是off 的&#xA;&#xA;        dbms_output.put_line(&#39;&#39;);  # 只能在 plsql 的执行语句中使用，dbms_output的输出方法,会自动换行&#xA;&#xA;        emp.ename%type;        # 同emp表中的ename的类型一样的类型&#xA;        emp_record emp%rowtype      # 匹配一行类型&#xA;            emp_record.ename输出一个字段的数据&#xA;&#xA;&#xA;        if 条件1.1 and 条件1.2 then 语句1;&#xA;        elsif 条件2 then 语句2;&#xA;        else 语句3;&#xA;        end if;&#xA;&#xA;        loop&#xA;        exit [when];&#xA;        end loop;&#xA;&#xA;        while 条件&#xA;        loop&#xA;        ;&#xA;        end loop;&#xA;&#xA;        for i in 1..3                # 不可以在循环中更改i的值&#xA;        loop&#xA;        ;&#xA;        end loop;&#xA;&#xA;    cursor      # 多行数据 ，相当于resultset&#xA;        cursor c1 查询语句&#xA;        open c1;&#xA;        loop&#xA;        fetch                        # 先判断再下移，最后一条记录打印两次&#xA;                                        ## 先下移再判断 ，正常显示&#xA;        exit when 条件;&#xA;        end loop;&#xA;        close c1;&#xA;&#xA;异常&#xA;        内置异常&#xA;        no_data_found  # 没有查到数据,游标中使用的时候异常不抛出&#xA;            select ename into pename from emp where deptno = 100;      # select into 插入的数据找不到的时候&#xA;        too_many_rows  #&#xA;        zero_divide    # 除零异常&#xA;        value_error&#xA;        timeout_on_resource&#xA;                例子&#xA;                        declare&#xA;                    i number(2) := 10;&#xA;                    s number(2);&#xA;                begin&#xA;                    s:= i/0;&#xA;                exception&#xA;                    when zero_divide then dbms_output.put_line(&#39;除0异常&#39;);&#xA;                end;&#xA;                        /&#xA;        自定义异常&#xA;                declare&#xA;                no_emp_found exception;&#xA;            begin&#xA;                if()then&#xA;                raise no_emp_found;&#xA;                end if;&#xA;            exception&#xA;                when no_emp_found then dbms_output.put_line(&#39;查无数据&#39;);&#xA;            end;&#xA;            /&#xA;        抛出异常的函数&#xA;                raise_application_error(&#39;-20666&#39;,&#39;禁止操作&#39;);&#xA;                        # begin语句中的相关地方调用此函数即可&#xA;                        # 20000-20999错误编号范围，是负数&#xA;&#xA;例1                # dbms_output.put_line(&#39;&#39;);&#xA;    declare&#xA;        mysum number(3);&#xA;    begin&#xA;        mysum := 10 + 100;      # :=就是赋值&#xA;        dbms_output.put_line(&#39;结果为&#39; || mysum);&#xA;    end;&#xA;    /&#xA;例2      # emp.ename%type&#xA;        ## select .. into ..&#xA;    declare&#xA;        x emp.ename%type;&#xA;        y emp.sal%type;&#xA;    begin&#xA;        --select ename,sal from emp where empno = 7369        # sql语句可以单独执行&#xA;        select ename,sal into x,y from emp where empno = 7369      # plsql语句只能整体执行&#xA;        dbms_output.put_line(x || &#39;是&#39; || y);&#xA;    end;&#xA;    /&#xA;例3                # emp%rowtype&#xA;    declare&#xA;        emp_record emp%rowtype;&#xA;    begin&#xA;        select * into emp_record from emp where empno = 7788;&#xA;        dbms_output.put_line(emp_record.ename || emp_record.sal);&#xA;    end;&#xA;    /&#xA;例4                        # 运行时赋值符号与if判断语句&#xA;    declare&#xA;    num number(2);&#xA;    begin&#xA;    num := &amp;amp;num;&#xA;    if num&amp;lt;5 then dbms_output.put_line(num || &#39;&amp;lt;5&#39;);&#xA;    elsif num=5 then ..&#xA;    else ..&#xA;    end if;&#xA;    end;&#xA;    /&#xA;例5                        # loop 循环&#xA;    declare&#xA;        i number(2) := 1;      # 声明的时候可以赋值&#xA;    begin&#xA;        loop&#xA;            exit when i &amp;gt; 10;&#xA;            dbms_output.put_line(i);&#xA;            i := i + 1;&#xA;        end loop;&#xA;    end;&#xA;    /&#xA;例6                        # while循环&#xA;    declare&#xA;        i number(2) := 10;&#xA;    begin&#xA;        while i &amp;lt;= 20&#xA;        loop&#xA;            dbms_output.put_line(i);&#xA;            i := i + 1;&#xA;        end loop;&#xA;    end;&#xA;    /&#xA;例7                        # for循环&#xA;    declare&#xA;        i number(2)&#xA;    begin&#xA;            loop&#xA;        for i in 20..30    # 一个一个增加,循环中不能再对i进行操作&#xA;            dbms_output.put_line(i);&#xA;        end loop;&#xA;    end;&#xA;    /&#xA;例8                        # cursor&#xA;    declare&#xA;        cursor cemp is select ename,sal from emp;&#xA;        pename emp.ename%type;&#xA;        psal emp.sal%type;&#xA;    begin&#xA;        open cemp;&#xA;        loop&#xA;            exit when cemp%notfound;&#xA;            fetch cemp into pename,psal;&#xA;            dbms_output.put_line(pename || &#39;的薪水是&#39; || psal);&#xA;        end loop;&#xA;        close cemp;&#xA;    end;&#xA;    /&#xA;例9 # 有参游标&#xA;    declare&#xA;        cursor cemp(pdeptno emp.deptno%type) is select ename,sal from emp where deptno=pdeptno;&#xA;        pename emp.ename%type;&#xA;        psal emp.sal%type;&#xA;    begin&#xA;        open cemp(&amp;amp;deptno);&#xA;        loop&#xA;            fetch cemp into pename,psal;&#xA;            exit when cemp%notfound;&#xA;            dbms_output.put_line(pename ||&#39;的薪水是&#39; || psal);&#xA;    end loop;&#xA;            close cemp;&#xA;            end;&#xA;            /&#xA;例10 # 输入&amp;amp;emptno没有的时候，输出&amp;quot;查无员工&amp;quot;                # 综合if loop 与cursor&#xA;    declare&#xA;        cursor cemp(pdeptno emp.deptno%type) is select ename,sal from emp where deptno=pdeptno;&#xA;        pename emp.ename%type;&#xA;        psal emp.sal%type;&#xA;                    pdeptno emp.deptno%type := &amp;amp;deptno;&#xA;    begin&#xA;            if pdeptno in (10,20,30) then dbms_output.put_line(&#39;输入的值正确&#39;);&#xA;        open cemp(pdeptno);&#xA;        loop&#xA;            fetch cemp into pename,psal;&#xA;            exit when cemp%notfound;&#xA;            dbms_output.put_line(pename ||&#39;的薪水是&#39; || psal);&#xA;    end loop;&#xA;            close cemp;&#xA;            else dbms_output.put_line(&#39;输入的值不正确&#39;);&#xA;            end if;&#xA;            end;&#xA;            /&#xA;&#xA;例11 # 给所有ANALYST加工资        # 综合cursor if loop ,循环之后执行了tcl 事务控制语言&#xA;    declare&#xA;        cursor cemp is select empno,ename,job,sal from emp;&#xA;        pempno emp.empno%type;&#xA;        pename emp.ename%type;&#xA;        pjob emp.job%type;&#xA;        psal emp.sal%type;&#xA;    begin&#xA;        open cemp;&#xA;        loop&#xA;            fetch cemp into pempno,pename,pjob,psal;&#xA;            exit when cemp%notfound;&#xA;            if pjob=&#39;ANALYST&#39; then&#xA;                update emp set sal = sal+1000 where empno = pempno;&#xA;            end if;&#xA;        end loop;&#xA;        commit;&#xA;        close cemp;&#xA;    end;&#xA;    /&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ukeate.com/docs/db/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ukeate.com/docs/db/redis/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;remote dictionary server&#xA;特点&#xA;    no-sql, c编写&#xA;    内存数据库       # 请求不经过parser和optimizer&#xA;    key-value&#xA;    单线程&#xA;    可持久化&#xA;&#xA;与memcache区别&#xA;    memcache全在内存，不能持久化，redis部分硬盘&#xA;    memcache类型支持简单&#xA;        # memcache类型只有字符串，append字符串, blacklist删除麻烦&#xA;    emecache多线程, redis单线程&#xA;    底层模型，与客户端通信协议不同，redis自己实现vm机制(冷热数据分离)&#xA;    value, memcache只能存1MB, redis可存1GB&#xA;    redis可设置expire, 支持排行榜, 浮点数&#xA;类型&#xA;    string&#xA;        整个或一部分操作&#xA;        整数、浮点数自增自减&#xA;    list&#xA;        两边推入或弹出&#xA;        偏移量trim&#xA;        读单个多个元素&#xA;        值查找移除元素&#xA;    set&#xA;        增删查单个元素&#xA;        单个元素是否存在&#xA;        交集、并集、差集&#xA;        随机取元素&#xA;    hash&#xA;        增删查单个键值对&#xA;        获取所有键值对&#xA;    zset&#xA;        # 有序集合, 排序根据score, score为双精度浮点数&#xA;        增删查单个元素&#xA;        根据range或成员获取元素&#xA;应用&#xA;    会话缓存(session cache)&#xA;    全面缓存(FPC)&#xA;    队列&#xA;    排行榜/计数器&#xA;    发布/订阅&#xA;命令&#xA;    文件命令&#xA;        redis-server&#xA;            # 端口为6379&#xA;            redis-server /etc/redis.conf  来加载配置文件&#xA;        redis-cli&#xA;        redis-benchmark&#xA;            # 性能测试工具&#xA;&#xA;    redis-cli命令&#xA;        ping&#xA;            # 成功时返回 PONG&#xA;        shutdown&#xA;            # 关闭redis-server服务&#xA;            -p 端口号&#xA;        quit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;功能&#34;&gt;&#xA;  功能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%9f%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;性能高     # 100k次读写/s&#xA;数据类型丰富&#xA;所有操作有原子性&#xA;支持发布/订阅，通知，key过期&#xA;&#xA;&#xA;发布订阅&#xA;        subscribe&#xA;        psubscribe&#xA;                # 订阅给定模式匹配的所有频道&#xA;        unsubscribe&#xA;        punsubscribe&#xA;        publish&#xA;&#xA;        sort&#xA;                # 列表、集合、有序集合排序，返回结果或生成存储&#xA;&#xA;过期&#xA;        persist&#xA;                # 移除键过期时间&#xA;        ttl&#xA;                # 键距离过期时间还有多少秒&#xA;        pttl&#xA;                # 多少毫秒&#xA;        expire&#xA;                # 给定键指定数秒后过期&#xA;        pexpire&#xA;                # 指定的毫秒后过期&#xA;        expireat&#xA;                # unix时间戳过期&#xA;        pexpireat&#xA;                # 毫秒unix时间戳&#xA;&#xA;事务&#xA;                # 事务期其他客户端命令阻塞&#xA;        multi&#xA;                # 创建事务队列，开始记录命令&#xA;        exec&#xA;                # 提交事务队列&#xA;        watch&#xA;                # 对键加锁&#xA;        unwatch&#xA;        discard&#xA;                # 取消事务&#xA;持久化&#xA;        bgsave&#xA;                # fork线程创建快照, windows不支持&#xA;        save&#xA;                # 停止响应创建快照&#xA;        sync&#xA;                # 向主服务器要求复制时，主服务器bgsave，非刚bgsave过&#xA;        bgrewriteaof&#xA;                # 重写aof文件使它缩小&#xA;复制&#xA;        slaveof&#xA;客户端分片&#xA;不完全事务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;性能&#34;&gt;&#xA;  性能&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;内存数据库，需要预估内存，使用key过期节约&#xA;完整重同步占资源，可以部分重同步&#xA;重启数据加载慢&#xA;&#xA;master内存快照时，save命令调rdbSave阻塞主线程&#xA;master AOF持久化，追加文件大时影响master重启恢复速度&#xA;    用slave AOF&#xA;master调用BGREWRITEAOF重写AOF文件时，cpu和内存负载高&#xA;主从复制最好同局域网&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;数据&#34;&gt;&#xA;  数据&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;set mykey somvalue&#xA;get mykey&#xA;del mykey&#xA;incr&#xA;decr&#xA;incrby&#xA;decrby&#xA;incrbyfloat&#xA;append&#xA;getrange&#xA;setrange&#xA;getbit&#xA;setbit&#xA;bitcount&#xA;        # 二进制位串位为1的数量&#xA;bitop&#xA;        # 二进制位串执行and, or, xor, not&#xA;&#xA;rpush list-key item&#xA;lpush&#xA;lrange list-key 0 -1&#xA;        # -1为结束索引&#xA;lindex list-key 1&#xA;rpop&#xA;lpop list-key&#xA;lrange&#xA;ltrim&#xA;        # 修剪&#xA;blpop&#xA;        # timeout秒内阻塞并等待弹出元素&#xA;brpop&#xA;rpoplpush&#xA;        # 一个列表中右弹元素推入另一个列表左端，最后返回这个元素&#xA;brpoplpush&#xA;&#xA;sadd set-key item&#xA;smembers set-key&#xA;sismember set-key item&#xA;srem set-key item&#xA;        # 删除，返回删除的数量&#xA;scard&#xA;        # 元素数&#xA;srandmember&#xA;        # 随机返回一个或多个元素。count正数时，返回的元素不重复, 负数时可重复&#xA;spop&#xA;        # 随机移除一个元素&#xA;smove&#xA;        # 一个集合中移除，并在一个集合中添加。返回移除的数量&#xA;sdiff&#xA;        # 差集&#xA;sdiffstore&#xA;        # 差集生成集合&#xA;sinter&#xA;        # 交集&#xA;sinterstore&#xA;sunion&#xA;        # 并集&#xA;sunionstore&#xA;&#xA;hset hash-key sub-key value&#xA;hget hash-key sub-key&#xA;hdel hash-key sub-key&#xA;hlen&#xA;hexists hash-key sub-key&#xA;hkeys hash-key&#xA;hvals&#xA;hgetall hash-key&#xA;hincrbyfloat&#xA;hincrby hash-key field -1&#xA;hmget&#xA;hmset hash-key field1 &amp;quot;foo&amp;quot; field2 &amp;quot;bar&amp;quot;&#xA;&#xA;zadd zset-key 728 member&#xA;zrange zset-key 0 -1 withscores&#xA;zrevrange zset-key 0 -1 withscores&#xA;zrangebyscore zset-key 0 800 withscores&#xA;        # 根据score范围查找&#xA;zrevrangebyscore&#xA;zrem zset-key member&#xA;zremrangebyrank&#xA;zremrangebyscore&#xA;zincrby&#xA;zinterstore sum 3 sub1 sub2 sub3&#xA;        # 生成交集, 重复值score相加, 3 指定可变参数的数量&#xA;zunionstore&#xA;        # 并集&#xA;zcard&#xA;        # 成员数量&#xA;zcount        &#xA;        # 分值之间的成员数量&#xA;zrank&#xA;        # 返回排名&#xA;zrevrank&#xA;zscore&#xA;        # 返回分值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;client&#34;&gt;&#xA;  client&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#client&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;jedis&#xA;    # java, 支持redis sharding, 即ShardedJedis结合ShardedJedisPool&#xA;&#xA;    Jedis jedis = new Jedis(&amp;quot;localhost&amp;quot;);                        # 连接redis数据库&#xA;    jedis.set(&amp;quot;name&amp;quot;, &amp;quot;aa&amp;quot;);                                                # 添加、覆盖&#xA;    jedis.append(&amp;quot;name&amp;quot;, &amp;quot;bb&amp;quot;);                                                # 追加，结果为 name=aabb&#xA;    jedis.get(&amp;quot;name&amp;quot;);                                                                # 取值&#xA;    jedis.del(&amp;quot;name&amp;quot;);                                                                # 删除&#xA;    jedis.mset(&amp;quot;name1&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;name2&amp;quot;, &amp;quot;bb&amp;quot;);                # 批量添加、覆盖&#xA;    jedis.mget(&amp;quot;name1&amp;quot;, &amp;quot;name2&amp;quot;)                                        # 批量取值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;分布式&#34;&gt;&#xA;  分布式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;redisCluster&#xA;twemProxy&#xA;    # twitter开发的redis集群代理&#xA;redisMonitor&#xA;redisSentinel&#xA;    # 主从复制，高可用&#xA;codis&#xA;    # 豌豆荚开发的redis集群代理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;持久化&#34;&gt;&#xA;  持久化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%81%e4%b9%85%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;方式&#xA;    无持久化&#xA;    RDB&#xA;        # 一段时间备份一个RDB文件，RDB文件很紧凑。用fork子进程的方式备份，恢复速度快&#xA;        # 服务器故障时，会丢当前时段数据。数据集大时，fork耗时出现停止服务(毫秒至1秒)&#xA;        point-in-time dump&#xA;            dump-to-disk二条命令&#xA;    AOF&#xA;        # 记录写操作, AOF先于RDB&#xA;        # fsync不fork在后台执行, 追加写文件，文件大时自动重写&#xA;        # AOF文件结构不紧凑，AOF速度慢于RDB(关闭fsync一样快)&#xA;        append-only文件&#xA;        fsync策略&#xA;            从不同步&#xA;            每秒同步一次      # 只丢一秒数据&#xA;            一命令同步一次&#xA;策略&#xA;配置&#xA;    save 60 1000&#xA;            # 60秒内有1000次写入时，自动save&#xA;    stop-writes-on-bgsave-error no&#xA;    rdbcompression yes&#xA;    dbfilename dump.rdb&#xA;&#xA;    appendonly no&#xA;            # 打开AOF&#xA;    appendfsync everysec&#xA;            always&#xA;                    # 每个写命令都马上同步&#xA;            everysec&#xA;                    # 每秒&#xA;            no&#xA;                    # 操作系统决定&#xA;    no-appendfsync-on-rewrite no&#xA;    auto-aof-rewrite-percentage 100&#xA;    auto-aof-rewrite-min-size 64mb&#xA;&#xA;    dir ./&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
