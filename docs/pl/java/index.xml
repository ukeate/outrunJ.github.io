<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on outrun的笔记</title>
    <link>https://runout.run/docs/pl/java/</link>
    <description>Recent content in Java on outrun的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 23 Apr 2022 22:18:41 +0800</lastBuildDate>
    <atom:link href="https://runout.run/docs/pl/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java响应式编程</title>
      <link>https://runout.run/docs/pl/java/java_reactive/</link>
      <pubDate>Thu, 11 Oct 2018 10:33:48 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/java_reactive/</guid>
      <description>&lt;h1 id=&#34;java响应式层级&#34;&gt;&#xA;  Java响应式层级&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e5%93%8d%e5%ba%94%e5%bc%8f%e5%b1%82%e7%ba%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Level 0: Thread &amp;amp; Runnable (Java 1+)&#xA;Level 1: ExecutorService, Callable, Future (Java 5+)&#xA;Level 2: ForkJoinPool (Java 7+)&#xA;Level 3: CompletableFuture (Java 8+)&#xA;Level 4: reactive streams, Flow (Java 9+)&#xA;Level 5: HTTP/2 client (Java 11+)&#xA;Level 6: Reactive libraries (RxJava, Reactor)&#xA;Level 7: Reactive services (Vert.x, Spring, Kafka)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;flow&#34;&gt;&#xA;  Flow&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#flow&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Flow.Publisher&#xA;Flow.Subscriber&#xA;Flow.Subscription&#xA;&#x9;# link publisher和subscriber&#xA;Flow.Processor&#xA;&#x9;# subscriber和publisher的act&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;reactivex&#34;&gt;&#xA;  ReactiveX&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reactivex&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Flux&#xA;Mono&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;rxjava&#34;&gt;&#xA;  RxJava&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rxjava&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;模型&#x9;&#xA;&#x9;Observable&#xA;&#x9;Subscriber&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;reactor&#34;&gt;&#xA;  Reactor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reactor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;vertx&#34;&gt;&#xA;  Vert.x&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#vertx&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;akka&#34;&gt;&#xA;  AKKA&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#akka&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>JavaWeb</title>
      <link>https://runout.run/docs/pl/java/javaweb/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/javaweb/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;分层&#xA;    视图层         jsp&#xA;    控制层         servlet&#xA;    业务层         过滤数据&#xA;    manager层     封装第三方，service能力下沉，dao中间件&#xA;    数据访问层对象  封装对象&#xA;    数据库&#xA;java web 13种技术&#xA;    JDBC        Java Database Connectivty&#xA;    JNDI        Java Name and Directory Interface&#xA;    EJB        Enterprise JavaBean&#xA;    RMI        Remote Method Invoke&#xA;    Java IDL/CORBA&#xA;    JSP        Java Server Pages&#xA;    Java Servlet&#xA;    XML        Extensible Markup Language&#xA;    JMS        Java Message Service&#xA;    JTS        Java Transaction Service&#xA;    JTA        Java Transaction Architecture&#xA;    JavaMail&#xA;    JAF        JavaBeans Activation Framework&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jsp&#34;&gt;&#xA;  jsp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层&#xA;域对象&#xA;    pageContext     # 当前页面有效&#xA;    request         # 一次请求范围&#xA;    session         # 会话&#xA;    application context     # 同一服务器&#xA;内置对象&#xA;    Request&#xA;    Response&#xA;    Session&#xA;    Out             # 输出流&#xA;    PageContext     # context&#xA;    Page            # jsp的this&#xA;    Exception       # &amp;lt;%@ page isErrorPage=&amp;quot;true&amp;quot;%&amp;gt; 时使用，显示异常信息&#xA;    Application     # 服务器&#xA;    Config          # 服务器配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp-el表达式&#34;&gt;&#xA;  jsp-el表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp-el%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;${  }&#xA;11个内置对象&#xA;    pageContext    // pageContext&#xA;    page        // map （相当于pageScope，不过写法上省略了Scope）&#xA;    requestScope    // map&#xA;    sessionScope    // map&#xA;    applicationScope    // map&#xA;    param        // map        ,用${param.name}的形式得到传递的参数&#xA;    paramValues    // map&amp;lt;String,String []&amp;gt;&#xA;    header        // map&#xA;    hearderValues    // map&amp;lt;String, String []&amp;gt;&#xA;    cookie        // map&#xA;    initParam        // map&#xA;&#xA;语法&#xA;${list[0]}&amp;lt;br&amp;gt;&#xA;    ${map.mapteststring}&amp;lt;br&amp;gt;&#xA;    ${map[mapkey]}&amp;lt;br&amp;gt;&#xA;    ${map[&#39;mapteststring&#39;]}&amp;lt;br&amp;gt;&#xA;    ${request }&#xA;    ${pageContext.request.contextPath }&amp;lt;br&amp;gt;        # el表达式中访问内置对象&#xA;    ${requestScope.aaa }                # 访问内置对象requestScope，得到request作用域中的aaa元素&#xA;    ${pageContext.servletContext.contextPath }&amp;lt;br&amp;gt;&#xA;    ${param}&amp;lt;br&amp;gt;&#xA;    ${paramValues[&#39;a&#39;] }&amp;lt;br&amp;gt;&#xA;    ${paramValues[&#39;a&#39;][0] }&#xA;    ${paramValues[&#39;a&#39;][1] }&#xA;    ${paramValues[&#39;a&#39;][2] }&amp;lt;br&amp;gt;&#xA;    ${empty novalue}&amp;lt;br&amp;gt;&#xA;    ${1&amp;gt;2?&amp;quot;yes&amp;quot; : &amp;quot;no&amp;quot;}&amp;lt;br&amp;gt;&#xA;&#xA;        #  . 与 [] 可以替换使用，但有两点需要注意&#xA;        1  .1不行，但是[1]可以&#xA;        2    1&amp;gt; map[&amp;quot;key&amp;quot;]    是取map中&amp;quot;key&amp;quot;对应的值&#xA;            2&amp;gt; map[key]是先从作用域中取得key的字符串如&amp;quot;aaa&amp;quot;,再取map中&amp;quot;aaa&amp;quot;对应的值&#xA;            3&amp;gt; .key    相当于1&amp;gt;中的介绍，是取map中&amp;quot;key&amp;quot;对应的值&#xA;            4&amp;gt; .是不能相当于2&amp;gt;中的介绍那样使用的&#xA;比较符${ }中使用&#xA;    empty&#xA;    not empty&#xA;    三元式（?:）&#xA;    简单的算术运算&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp-taglib标签库&#34;&gt;&#xA;  jsp-taglib标签库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp-taglib%e6%a0%87%e7%ad%be%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;jstl标签库1.1 或1.2&#xA;    标签库1.1中需要    jstl.jar 与 standard.jar 库&#xA;可放入域scope的类型&#xA;    page&#xA;    request&#xA;    session&#xA;    application&#xA;    functions&#xA;el表达式级使用，其它都标签级使用&#xA;functions&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;fn&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/functions&amp;quot;%&amp;gt;&#xA;    ${fn:contains(&amp;quot;gzitcast&amp;quot;, &amp;quot;itcast&amp;quot;) }  &amp;lt;br&amp;gt;&#xA;    ${fn:containsIgnoreCase(&amp;quot;gzitcast&amp;quot;, &amp;quot;ITCAST&amp;quot;) }  &amp;lt;br&amp;gt;&#xA;    ${fn:endsWith(&amp;quot;gzitcast&amp;quot;, &amp;quot;st&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:indexOf(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:join(arr, &amp;quot;-&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:length(&amp;quot;gzitcast&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:replace(&amp;quot;gzitcast&amp;quot;, &amp;quot;gz&amp;quot;, &amp;quot;广州&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:split(&amp;quot;gz,it,cast&amp;quot;, &amp;quot;,&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:startsWith(&amp;quot;gzitcsat&amp;quot;, &amp;quot;gz&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:substring(&amp;quot;gzitcsat&amp;quot;, 3, 8) } &amp;lt;br&amp;gt;&#xA;    ${fn:substringAfter(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:substringBefore(&amp;quot;gzitcsat&amp;quot;, &amp;quot;cs&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:toLowerCase(&amp;quot;gziTCsat&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:toUpperCase(&amp;quot;gziTCsat&amp;quot;) } &amp;lt;br&amp;gt;&#xA;    ${fn:trim(&amp;quot;  gzitcsat  &amp;quot;) } &amp;lt;br&amp;gt;&#xA;    &amp;lt;%-- 对字符串中进行转义处理，如：会把&amp;quot;&amp;lt;&amp;quot;替换为&amp;quot;&amp;amp;lt;&amp;quot;，把&amp;quot;&amp;gt;&amp;quot;替换为&amp;quot;&amp;amp;gt;&amp;quot; --%&amp;gt;&#xA;    ${fn:escapeXml(&amp;quot;&amp;lt;h3&amp;gt;gzitcsat&amp;lt;/h3&amp;gt;&amp;quot;) } &amp;lt;br&amp;gt;&#xA;core&#xA;    所有标签：&#xA;        out&#xA;        set&#xA;        remove&#xA;        catch&#xA;        if&#xA;        choose&#xA;        when&#xA;        otherwise&#xA;        forEach&#xA;        url&#xA;        param&#xA;        redirect&#xA;        forTokens&#xA;        import&#xA;&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/cores&amp;quot;%&amp;gt;&#xA;    &amp;lt;c:out var=&amp;quot;&amp;quot;    default=&amp;quot;&amp;quot;    escapeXml=&amp;quot;true&amp;quot;&amp;gt;    &amp;lt;%--    放过xml过滤，让它显示，默认不显示    --%&amp;gt;&#xA;    -------------------------------------&#xA;    scope方式&#xA;    &amp;lt;c:set    var=&amp;quot;&amp;quot;    value=&amp;quot;&amp;quot;    scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    target方式    &amp;lt;%--    这个放入page作用域中的map值    --%&amp;gt;&#xA;    &amp;lt;%  Map map = new HashMap();  %&amp;gt;&#xA;    &amp;lt;c:set    property=&amp;quot;key1&amp;quot;    value=&amp;quot;key1value&amp;quot;    target=&amp;quot;&amp;lt;%=map%&amp;gt;&amp;quot;&#xA;    &amp;lt;%  pageContext.setAttribute(&amp;quot;map&amp;quot;, map);  %&amp;gt;&#xA;    &amp;lt;c:out    value=&amp;quot;${map[key2]}&amp;quot;&#xA;&#xA;    -------------------------------------&#xA;    &amp;lt;c:catch var=&amp;quot;e&amp;quot;&amp;gt;&amp;lt;/c:catch&amp;gt;&#xA;    &amp;lt;c:out value=&#39;&amp;lt;%= ((Exception)pageContext.getAttribute(&amp;quot;e&amp;quot;,PageContext.PAGE_SCOPE)).getMessage() %&amp;gt;&#39;&amp;gt;&amp;lt;/c:out&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:remove    var=&amp;quot;&amp;quot;    scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:if test=&amp;quot;${not empty    }&amp;quot; scope=&amp;quot;&amp;quot;    var=&amp;quot;&amp;quot;&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;%--    if...else标签    --%&amp;gt;&#xA;    &amp;lt;c:choose&amp;gt;&#xA;    &amp;lt;c:when test=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;c:otherwise&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:forEach  begin=&amp;quot;&amp;quot;    end=&amp;quot;&amp;quot;    step=&amp;quot;&amp;quot;    items=&amp;quot;&amp;quot;    var=&amp;quot;&amp;quot;    varStatus=&amp;quot;state&amp;quot;&amp;gt;          &amp;lt;%--    varStatus中的函数有first last count begin end    --%&amp;gt;&#xA;    &amp;lt;tr bgcolor=&#39;${state.count%2 == 0? &amp;quot;red&amp;quot; : &amp;quot;pink&amp;quot;}&#39; &amp;gt;&#xA;    &amp;lt;/c:forEach&amp;gt;&#xA;&#xA;    varStatus可用的函数&#xA;        current    // 当前这次迭代的项&#xA;        index    // 索引&#xA;        count    // 计数&#xA;        first        // 第一个&#xA;        last        // 最后一个&#xA;        begin    // begin属性值&#xA;        end        // end 属性值&#xA;        step        // step属性值&#xA;    -------------------------------------&#xA;    uri 代表所有协议路径&#xA;&#xA;    &amp;lt;c:url    var=&amp;quot;itcast&amp;quot;    value=&amp;quot;http://www.itcast.cn&amp;quot;    scope=&amp;quot;page&amp;quot;    context=&amp;quot;&amp;quot;    &amp;gt;    &amp;lt;%--    context 是整个网站    --%&amp;gt;&#xA;    &amp;lt;c:param    name=&amp;quot;name&amp;quot;    value=&amp;quot;中文&amp;quot;&amp;gt;    &amp;lt;%--    这样传参数有编码    --%&amp;gt;&#xA;&#xA;    如果value值为&amp;quot;/&amp;quot; 则加入context属性提供上下文名称，如果context也被省略，就使用当前servlet的上下文名称&#xA;    -------------------------------------&#xA;    &amp;lt;c:redirect    url=&amp;quot;${itcast}&amp;quot;    context=&amp;quot;&amp;quot;    &amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:set    var=&amp;quot;name&amp;quot;    value=&amp;quot;xx,xxx,xxx,xx&amp;quot;    scope=&amp;quot;request&amp;quot;    &amp;gt;&#xA;    &amp;lt;c:forTokens    items=&amp;quot;${name}&amp;quot;    delims=&amp;quot;,&amp;quot;    begin=&amp;quot;&amp;quot;    end=&amp;quot;&amp;quot;    step=&amp;quot;1&amp;quot;    var=&amp;quot;name&amp;quot;    varStatus=&amp;quot;&amp;quot;    &amp;gt;    &amp;lt;%--切割字符串--%&amp;gt;&#xA;    -------------------------------------&#xA;    &amp;lt;c:import    url=&amp;quot;/publics/head.jsp&amp;quot;    &amp;gt;    &amp;lt;%--动态包含，引入公共文件--%&amp;gt;&amp;lt;%--网站publics文件夹--%&amp;gt;&#xA;&#xA;&#xA;sql标签库&#xA;    # 以前没有mvc模式的时候，通过页面访问数据库时用的，现在不用&#xA;    引入&#xA;        &amp;lt;%@ taglib prefix=&amp;quot;sql&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/sql&amp;quot; %&amp;gt;&#xA;    设置数据源&#xA;        &amp;lt;sql:setDataSource dataSource=”dataSource”[var=”name”]&#xA;                            [scope=”page|request|session|application”]/&amp;gt;&#xA;    jdbc连接&#xA;        &amp;lt;sql:setDataSource driver=”driverClass” url=”jdbcURL”&#xA;                user=”username”&#xA;                password=”pwd”&#xA;                [var=”name”]&#xA;                [scope=”page|request|session|application”]/&amp;gt;&#xA;&#xA;    JSTL提供了&amp;lt;sql:query&amp;gt;、&amp;lt;sql:update&amp;gt;、&amp;lt;sql:param&amp;gt;、&amp;lt;sql:dateParam&amp;gt;和&amp;lt;sql:transaction&amp;gt;这5个标签&#xA;        1.query:&#xA;        query必需指定数据源&#xA;        &amp;lt;sql:query sql=”sqlQuery” var=”name” [scope=”page|request|session|application”]&#xA;        [dataSource=”dateSource”]&#xA;        [maxRow=”maxRow”]&#xA;        [startRow=”starRow”]/&amp;gt;&#xA;        或&#xA;        &amp;lt;sql:query var=”name” [scope=”page|request|session|application”]&#xA;        [dataSource=”dateSource”]&#xA;        [maxRow=”maxRow”]    # 设定最多可以暂存数据的长度&#xA;        [startRow=”starRow”]    # 设定从哪一行开始&#xA;                &amp;gt;&#xA;                sqlQuery&#xA;                &amp;lt;/sql:query&amp;gt;&#xA;&#xA;        结果集的参数&#xA;            rowCount    # 结果集中的记录总数&#xA;            rowsByIndex    # 以数字为作索引的查询结果&#xA;            columnNames    # 字段名称数组&#xA;            Rows    # 以字段为索引查询的结果&#xA;            limitedByMaxRows    # 是否设置了maxRows属性来限制查询记录的数量&#xA;                limitedByMaxRows用来判断程序是否收到maxRows属性的限制。&#xA;                并不是说设定了maxRows属性，得到结果集的limitedByMaxRows的属性都为true，&#xA;                当取出的结果集小于maxRows时，则maxRows没有对结果集起到作用此时也为false。&#xA;                例如可以使用startRow属性限制结果集的数据量。&#xA;&#xA;        2.update:&#xA;        &amp;lt;/sql:update&amp;gt;&#xA;        &amp;lt;sql:update sql=”SQL语句” [var=”name”] [scope=”page|request|session|application”]&#xA;                [dateSource=”dateSource”]/&amp;gt;&#xA;        或&#xA;    &amp;lt;sql:update [var=”name”] [scope=”page|request|session|application”]&#xA;                [dateSource=”dateSource”]&#xA;                    &amp;gt;&#xA;                    SQL语句&#xA;        参数说明&#xA;            dataSource    # 数据源对象&#xA;            其它与query一样&#xA;&#xA;        3.param 参数设置&#xA;        &amp;lt;sql:param value=”value”/&amp;gt;&#xA;        或&#xA;        &amp;lt;sql:param&amp;gt;&#xA;            Value&#xA;            &amp;lt;/sql:param&amp;gt;&#xA;&#xA;        4.dataParam 标签    # 用于为SQL标签填充日期类型的参数值&#xA;&#xA;        参数说明&#xA;            value：java.util.Date类型的参数。&#xA;            type属性：指定填充日期的类型timestamp（全部日期和时间）、time（填充的参数为时间）、date（填充的参数为日期）。&#xA;&#xA;        5.transaction 标签&#xA;&#xA;        &amp;lt;sql:transaction [dataSource=”dataSource”]&#xA;            [isolation=”read_committed|read_uncommitted|repeatable|serializable”]&#xA;            &amp;gt;&#xA;            &amp;lt;sql:query&amp;gt;&#xA;            &amp;lt;sql:uptade&amp;gt;&#xA;        &amp;lt;/sql:transation&amp;gt;&#xA;&#xA;xml标签库&#xA;    核心操作&#xA;    out    # 主要用来取出XML中的字符串。&#xA;        属性&#xA;        select    # XPath语句&#xA;        escapeXml    # 是否转换特殊字符&#xA;&#xA;    parse    # 用来解析xml文件&#xA;        属性&#xA;        doc    # XML文件&#xA;        systemId    # XML文件的URL&#xA;        filter    # XMLFilter过滤器&#xA;        varDom    # 储存解析后的XML文件&#xA;        scopeDom    # varDom的范围&#xA;&#xA;    set    # 将从XML文件取得的内容储存至属性范围中&#xA;        属性&#xA;        select    # XPath语句&#xA;&#xA;    流程控制&#xA;    if&#xA;    choose when otherwise&#xA;        属性&#xA;        select    # XPath语句&#xA;    文件转换&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]/&amp;gt;&#xA;    或&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]&#xA;        &amp;gt;&#xA;        &amp;lt;x:param/&amp;gt;&#xA;        &amp;lt;/x:transform&amp;gt;&#xA;    或&#xA;    &amp;lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]&#xA;        [result=”result”]&#xA;        [var=”name”]&#xA;        [scope=”scopeName”]&#xA;        [xsltSystemId=”xsltsystemid”]&#xA;        &amp;gt;&#xA;&#xA;        属性&#xA;        doc    # 指定xml文件来源&#xA;        xslt    # 转化xml的样式模板&#xA;        docSystemId    # xml文件的URI&#xA;        xsltSystemId    # xslt文件的URI&#xA;        result    # 用来存储转换后的结果对象&#xA;&#xA;国际化&#xA;    &amp;lt;%@ taglib prefix=&amp;quot;fmt&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/fmt&amp;quot; %&amp;gt;&#xA;    国际化标签&#xA;    1.setLocale    # 设置一个全局的地区代码,设定的是本地的环境&#xA;        中文－大陆:&amp;lt;fmt:setLocale value=&amp;quot;zh_CN&amp;quot;/&amp;gt; &amp;lt;fmt:formatDate value=&amp;quot;${todayValue}&amp;quot;/&amp;gt;&amp;lt;br&amp;gt;&#xA;&#xA;    2.requestEncoding    # 设置统一的请求编码&#xA;        &amp;lt;fmt:requestEncoding value=&amp;quot;GB2312&amp;quot;/&amp;gt;&#xA;&#xA;    信息显示标签&#xA;    1.&amp;lt;fmt:bundle&amp;gt; 设置临时要读取的资源文件&#xA;    2.&amp;lt;fmt:message&amp;gt;  通过key取得value&#xA;    3.&amp;lt;fmt:setBundle&amp;gt;  设置一个要读取的全局的资源文件&#xA;        如&#xA;        &amp;lt;fmt:setBundle basename=&amp;quot;applicationMessage&amp;quot; var=&amp;quot;MyResourse&amp;quot;/&amp;gt;    # 绑定了名为applicationMessage_zh_CN.properties一类 的文件&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot; prefix=&amp;quot;label.&amp;quot;&amp;gt;&#xA;        &amp;lt;fmt:message key=&amp;quot;backcolor&amp;quot; bundle=&amp;quot;${applicationBundle}&amp;quot;/&amp;gt;&#xA;        &amp;lt;fmt:message key=&amp;quot;fontcolor&amp;quot; /&amp;gt;&#xA;    &amp;lt;/fmt:bundle&amp;gt;&#xA;&#xA;&#xA;    数字及日期格式化标签&#xA;    1.&amp;lt;fmt:formatDate&amp;gt;  日期的格式化&#xA;        属性&#xA;        value:格式化的日期，该属性的内容应该是 java.util.Date 类型的实例&#xA;        type:格式化的类型&#xA;        pattern:格式化模式&#xA;        timeZone:指定格式化日期的时区&#xA;    2.&amp;lt;fmt:parseDate&amp;gt;  解析日期&#xA;        属性&#xA;        value:将被解析的字符串&#xA;        type:解析格式化的类型&#xA;        pattern:解析格式化模式&#xA;        parseLocale:以本地化的形式来解析字符串，该属性的内容为 String 或 java.util.Locale 类型的实例&#xA;        timeZone:指定解析格式化日期的时区&#xA;    3.&amp;lt;fmt:formatNumber&amp;gt;  数字格式化&#xA;        属性&#xA;        value:格式化的数字,该数值可以是 String 类型或 java.lang.Number 类型的实例&#xA;        type:格式化的类型,可能值包括:currency（货币）、number（数字）和percent（百分比）&#xA;        pattern:格式化模式&#xA;        maxIntegerDigits:指定格式化结果的最大值&#xA;        minIntegerDigits:指定格式化结果的最小值&#xA;        maxFractionDigits:指定格式化结果的最大值，带小数&#xA;        minFractionDigits:指定格式化结果的最小值，带小数&#xA;        如&#xA;        &amp;lt;fmt:formatNumber value=&amp;quot;1000.888&amp;quot; type=&amp;quot;currency&amp;quot; var=&amp;quot;money&amp;quot;/&amp;gt;&#xA;&#xA;    4.&amp;lt;fmt:parseNumber&amp;gt;  解析数字&#xA;        属性&#xA;        value:将被解析的字符串&#xA;        type:解析格式化的类型&#xA;        pattern:解析格式化模式&#xA;        如&#xA;        &amp;lt;fmt:parseNumber value=&amp;quot;15%&amp;quot; type=&amp;quot;percent&amp;quot; var=&amp;quot;num&amp;quot;/&amp;gt;&#xA;    5.&amp;lt;fmt:setTimeZone&amp;gt;  标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行属性描述&#xA;        属性&#xA;        value    # 时区的设置&#xA;        var    # 用于保存时区为一个变量&#xA;    6.&amp;lt;fmt:timeZone&amp;gt;  标签将使得在其标签体内的工作可以使用该时区设置&#xA;        属性&#xA;        value    # 时区的设置&#xA;    7.&amp;lt;fmt:param&amp;gt; 标签:用于参数传递&#xA;        如：在MyResourse.properties文件中,有一个索引值如下(其中,{0}代表占位符):&#xA;        Str2=Hi,{0}&#xA;        则,使用&amp;lt;fmt:param&amp;gt;标签传入值如下:&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:message key=&amp;quot;Str2&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:param value=&amp;quot;张三&amp;quot; /&amp;gt;&#xA;            &amp;lt;/fmt:message&amp;gt;&#xA;        &amp;lt;/fmt:bundle&amp;gt;&#xA;        也可以在资源文件中指定参数的类型:&#xA;        如:在MyResourse.properties文件中,有一个索引值如下:&#xA;        Str3={0,date}&#xA;        则,使用&amp;lt;fmt:param&amp;gt;标签传入值如下:&#xA;        &amp;lt;% request.setAttribute(&amp;quot;now&amp;quot;,new Date()); %&amp;gt;&#xA;        &amp;lt;fmt:bundle basename=&amp;quot;MyResourse&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:message key=&amp;quot;Str3&amp;quot;&amp;gt;&#xA;            &amp;lt;fmt:param value=&amp;quot;${now}&amp;quot; /&amp;gt;&#xA;            &amp;lt;/fmt:message&amp;gt;&#xA;        &amp;lt;/fmt:bundle&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp动作标签&#34;&gt;&#xA;  jsp动作标签&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%8a%a8%e4%bd%9c%e6%a0%87%e7%ad%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。&#xA;&#xA;一、Include行为&#xA;&#xA;    &amp;lt;jsp:include&amp;gt;标签表示动态包含一个静态的或者动态的文件。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot; /&amp;gt;&#xA;    or&#xA;    &amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot;&amp;gt;&#xA;    &amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;&#xA;    &amp;lt;/jsp:include&amp;gt;&#xA;&#xA;    注：&#xA;    1、page=&amp;quot;path&amp;quot; 为相对路径，或者代表相对路径的表达式。&#xA;    2、flush=&amp;quot;true&amp;quot; 必须使用flush为true，它默认值是false。&#xA;    3、&amp;lt;jsp:param&amp;gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&amp;lt;jsp:param&amp;gt;来传递多个参数给动态文件。&#xA;    4、&amp;lt;jsp:include page=&amp;quot;&amp;quot; flush=&amp;quot;&amp;quot;&amp;gt; 与&amp;lt;%@ include file=&amp;quot;&amp;quot;%&amp;gt;的区别：&#xA;        &amp;lt;jsp:include &amp;gt;是动态包含&amp;lt;%@include%&amp;gt;是静态包含。&#xA;        # jsp页面是把include指令元素（&amp;lt;%@ include file=&amp;quot;&amp;quot;%&amp;gt;）所指定的页面的实际内容（也就是代码段）加入到引入它的jsp页面中,合成一个文件后被jsp容器将它转化成servlet。&#xA;        ## 可以看到这时会产生一个临时class文件和一个servlet源文件。&#xA;        ## 而动作元素（&amp;lt;jsp:include page=&amp;quot;&amp;quot;/&amp;gt;）是在请求处理阶段引入的，会被JSP容器生成两个临时class文件和两个servlet原文件。&#xA;        ## 而引入的只是servlet的输出结果，即JspWriter对象的输出结果，而不是jsp的源代码。&#xA;&#xA;二、Forward行为&#xA;&#xA;    &amp;lt;jsp:forward&amp;gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} /&amp;gt;&#xA;    or&#xA;    &amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} &amp;gt;&#xA;    &amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;……&#xA;    &amp;lt;/jsp:forward&amp;gt;&#xA;&#xA;    注：&#xA;    1、page=&amp;quot;path&amp;quot; 为一个表达式，或者一个字符串。&#xA;    2、&amp;lt;jsp:param&amp;gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&amp;lt;jsp:param&amp;gt;将多个参数发送到一个动态文件中。&#xA;&#xA;三、UseBean行为&#xA;&#xA;    &amp;lt;jsp:useBean&amp;gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;name&amp;quot; scope=&amp;quot;page | request | session | application&amp;quot; typeSpec /&amp;gt;&#xA;    其中typeSpec有以下几种可能的情况：&#xA;    class=&amp;quot;className&amp;quot; | class=&amp;quot;className&amp;quot; type=&amp;quot;typeName&amp;quot; | beanName=&amp;quot;beanName&amp;quot; type=&amp;quot;typeName&amp;quot; | type=&amp;quot;typeName&amp;quot; |&#xA;&#xA;    注：&#xA;    你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。&#xA;&#xA;四、GetProperty行为&#xA;&#xA;    &amp;lt;jsp:getProperty&amp;gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:getProperty name=&amp;quot;name&amp;quot; property=&amp;quot;propertyName&amp;quot; /&amp;gt;&#xA;&#xA;    注：&#xA;    1、在使用&amp;lt;jsp:getProperty&amp;gt;之前，必须用&amp;lt;jsp:useBean&amp;gt;来创建它。&#xA;    2、不能使用&amp;lt;jsp:getProperty&amp;gt;来检索一个已经被索引了的属性。&#xA;    3、能够和JavaBeans组件一起使用&amp;lt;jsp:getProperty&amp;gt;，但是不能与Enterprise Java Bean一起使用。&#xA;JavaScript通用库  Jsp语法&#xA;JSP的动作标签  2008-04-01 11:47:49|  分类： JSP学习 |  标签： |字号大&#xA;中&#xA;小 订阅&#xA;在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。&#xA;&#xA;一、Include行为&#xA;&#xA;&amp;lt;jsp:include&amp;gt;标签表示包含一个静态的或者动态的文件。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot; /&amp;gt;&#xA;or&#xA;&amp;lt;jsp:include page=&amp;quot;path&amp;quot; flush=&amp;quot;true&amp;quot;&amp;gt;&#xA;&amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;&#xA;&amp;lt;/jsp:include&amp;gt;&#xA;&#xA;注：&#xA;1、page=&amp;quot;path&amp;quot; 为相对路径，或者代表相对路径的表达式。&#xA;2、flush=&amp;quot;true&amp;quot; 必须使用flush为true，它默认值是false。&#xA;3、&amp;lt;jsp:param&amp;gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&amp;lt;jsp:param&amp;gt;来传递多个参数给动态文件。&#xA;&#xA;二、Forward行为&#xA;&#xA;&amp;lt;jsp:forward&amp;gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} /&amp;gt;&#xA;or&#xA;&amp;lt;jsp:forward page=&amp;quot;path&amp;quot;} &amp;gt;&#xA;&amp;lt;jsp:param name=&amp;quot;paramName&amp;quot; value=&amp;quot;paramValue&amp;quot; /&amp;gt;……&#xA;&amp;lt;/jsp:forward&amp;gt;&#xA;&#xA;注：&#xA;1、page=&amp;quot;path&amp;quot; 为一个表达式，或者一个字符串。&#xA;2、&amp;lt;jsp:param&amp;gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&amp;lt;jsp:param&amp;gt;将多个参数发送到一个动态文件中。&#xA;&#xA;三、UseBean行为&#xA;&#xA;&amp;lt;jsp:useBean&amp;gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:useBean id=&amp;quot;name&amp;quot; scope=&amp;quot;page | request | session | application&amp;quot; typeSpec /&amp;gt;&#xA;其中typeSpec有以下几种可能的情况：&#xA;class=&amp;quot;className&amp;quot; | class=&amp;quot;className&amp;quot; type=&amp;quot;typeName&amp;quot; | beanName=&amp;quot;beanName&amp;quot; type=&amp;quot;typeName&amp;quot; | type=&amp;quot;typeName&amp;quot; |&#xA;&#xA;注：&#xA;你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。&#xA;&#xA;四、GetProperty行为&#xA;&#xA;&amp;lt;jsp:getProperty&amp;gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。&#xA;&#xA;语法：&#xA;&amp;lt;jsp:getProperty name=&amp;quot;name&amp;quot; property=&amp;quot;propertyName&amp;quot; /&amp;gt;&#xA;&#xA;注：&#xA;1、在使用&amp;lt;jsp:getProperty&amp;gt;之前，必须用&amp;lt;jsp:useBean&amp;gt;来创建它。&#xA;2、不能使用&amp;lt;jsp:getProperty&amp;gt;来检索一个已经被索引了的属性。&#xA;3、能够和JavaBeans组件一起使用&amp;lt;jsp:getProperty&amp;gt;，但是不能与Enterprise Java Bean一起使用。&#xA;&#xA;五、SetProperty行为&#xA;&#xA;    &amp;lt;jsp:setProperty&amp;gt;标签表示用来设置Bean中的属性值。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;beanName&amp;quot; prop_expr /&amp;gt;&#xA;    其中prop_expr有以下几种可能的情形：&#xA;    property=&amp;quot;*&amp;quot; | property=&amp;quot;propertyName&amp;quot; | property=&amp;quot;propertyName&amp;quot; param=&amp;quot;parameterName&amp;quot; | property=&amp;quot;propertyName&amp;quot; value=&amp;quot;propertyValue&amp;quot;&#xA;&#xA;    注：&#xA;    使用 jsp:setProperty 来为一个Bean的属性赋值；可以使用两种方式来实现。&#xA;    1、在jsp:useBean后使用jsp:setProperty：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;myUser&amp;quot; … /&amp;gt;&#xA;    …&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;user&amp;quot; property=&amp;quot;user&amp;quot; … /&amp;gt;&#xA;    在这种方式中，jsp:setProperty将被执行。&#xA;    2、jsp:setProperty出现在jsp:useBean标签内：&#xA;    &amp;lt;jsp:useBean id=&amp;quot;myUser&amp;quot; … &amp;gt;&#xA;    …&#xA;    &amp;lt;jsp:setProperty name=&amp;quot;user&amp;quot; property=&amp;quot;user&amp;quot; … /&amp;gt;&#xA;    &amp;lt;/jsp:useBean&amp;gt;&#xA;    在这种方式中，jsp:setProperty只会在新的对象被实例化时才将被执行。&#xA;&#xA;    * 在&amp;lt;jsp:setProperty&amp;gt;中的name值应当和&amp;lt;jsp:useBean&amp;gt;中的id值相同。&#xA;&#xA;六、Plugin行为&#xA;&#xA;    &amp;lt;jsp:plugin&amp;gt;标签表示执行一个applet或Bean，有可能的话还要下载一个Java插件用于执行它。&#xA;&#xA;    语法：&#xA;    &amp;lt;jsp:plugin&#xA;    type=&amp;quot;bean | applet&amp;quot;&#xA;    code=&amp;quot;classFileName&amp;quot;&#xA;    codebase=&amp;quot;classFileDirectoryName&amp;quot;&#xA;    [ name=&amp;quot;instanceName&amp;quot; ]&#xA;    [ archive=&amp;quot;URIToArchive, ...&amp;quot; ]&#xA;    [ align=&amp;quot;bottom | top | middle | left | right&amp;quot; ]&#xA;    [ height=&amp;quot;displayPixels&amp;quot; ]&#xA;    [ width=&amp;quot;displayPixels&amp;quot; ]&#xA;    [ hspace=&amp;quot;leftRightPixels&amp;quot; ]&#xA;    [ vspace=&amp;quot;topBottomPixels&amp;quot; ]&#xA;    [ jreversion=&amp;quot;JREVersionNumber | 1.1&amp;quot; ]&#xA;    [ nspluginurl=&amp;quot;URLToPlugin&amp;quot; ]&#xA;    [ iepluginurl=&amp;quot;URLToPlugin&amp;quot; ] &amp;gt;&#xA;    [ &amp;lt;jsp:params&amp;gt;&#xA;    [ &amp;lt;jsp:param name=&amp;quot;parameterName&amp;quot; value=&amp;quot;{parameterValue | &amp;lt;％= expression ％&amp;gt;}&amp;quot; /&amp;gt; ]+&#xA;    &amp;lt;/jsp:params&amp;gt; ]&#xA;    [ &amp;lt;jsp:fallback&amp;gt; text message for user &amp;lt;/jsp:fallback&amp;gt; ]&#xA;    &amp;lt;/jsp:plugin&amp;gt;&#xA;&#xA;    注：&#xA;    &amp;lt;jsp:plugin&amp;gt;元素用于在浏览器中播放或显示一个对象（典型的就是applet和Bean),而这种显示需要在浏览器的java插件。&#xA;    当Jsp文件被编译，送往浏览器时，&amp;lt;jsp:plugin&amp;gt;元素将会根据浏览器的版本替换成&amp;lt;object&amp;gt;或者&amp;lt;embed&amp;gt;元素。注意，&amp;lt;object&amp;gt;用于HTML 4.0 ，&amp;lt;embed&amp;gt;用于HTML 3.2。&#xA;    一般来说，&amp;lt;jsp:plugin&amp;gt;元素会指定对象是Applet还是Bean,同样也会指定class的名字，还有位置，另外还会指定将从哪里下载这个Java插件。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp函数&#34;&gt;&#xA;  jsp函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;用response.getOutputStream返回数据（而非JspWriter）时，调用：&#xA;    # 如输出图片对象：ImageIO.write(image, &amp;quot;jpeg&amp;quot;, response.getOutputStream());&#xA;    out.clear();        # 清空 out&#xA;    out = pageContext.pushBody()    # 将图片对象的流从out输出，直到整个输出结束（接收方网页加载全部完成时）后才断开&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp基本&#34;&gt;&#xA;  jsp基本&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e5%9f%ba%e6%9c%ac&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;模板元素&#xA;脚本&#xA;&amp;lt;%    %&amp;gt;&#xA;脚本表达式&#xA;&amp;lt;%=    %&amp;gt;&#xA;注释&#xA;&amp;lt;%--    --%&amp;gt;&#xA;指令&#xA;    &amp;lt;%@ page%&amp;gt;&#xA;    language=&amp;quot;java&amp;quot;&#xA;    import=&amp;quot;java.util.*,java.io.*&amp;quot;&#xA;    contentType=&amp;quot;mineType [; charset=characterSet]&amp;quot;&#xA;    pageEncoding=&amp;quot;characterSet&amp;quot;&#xA;    session=&amp;quot;true&amp;quot;&#xA;    buffer=&amp;quot;none | 8kb | sizekb&amp;quot;&#xA;    autoFlush=&amp;quot;true&amp;quot;&#xA;    isThreadSafe=&amp;quot;true&amp;quot;&#xA;    info=&amp;quot;text&amp;quot;&#xA;    errorPage=&amp;quot;relative_url&amp;quot;&#xA;    isErrorPage=&amp;quot;true&amp;quot;&#xA;    isELIgnored=&amp;quot;true&amp;quot;&#xA;    &amp;lt;%@ include%&amp;gt;    # &amp;lt;%@ include file=&amp;quot;in.jspf&amp;quot; %&amp;gt; 是静态包含（原代码中包含），一般包含名字为*.jspf的jsp文件&#xA;    &amp;lt;%@ taglib%&amp;gt;    # 标签库&#xA;声明&#xA;    &amp;lt;%!    %&amp;gt;    # 全局声明（刷新页面仍然保存数据）&#xA;    &amp;lt;% %&amp;gt;    # 局部的声明（刷新页面不保存数据）&#xA;标签&#xA;    &amp;lt;jsp:forward page=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/jsp:forward&amp;gt;&#xA;    &amp;lt;jsp:include page=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/jsp:include&amp;gt;&#xA;内置对象 9个&#xA;    pageContext&#xA;    request&#xA;    response&#xA;    config&#xA;    session&#xA;    application&#xA;    page&#xA;    out&#xA;    exception&#xA;&#xA;    全局变量&#xA;    static final JspFactory        _jspxFactory&#xA;    static java.util.List        _jspx_dependants&#xA;    javax.el.ExpressionFactory    _el_expressionfactory&#xA;    org.apache.AnnotationProcessor    _jsp_annotationprocessor&#xA;    在_jspService中的变量&#xA;    HttpServletRequest        request&#xA;    HttpServletResponse        response&#xA;    PageContext        pageContext = null;&#xA;                pageContext = _jspxFactory.getPageContext(this,request,response,null,true,8192,ture);&#xA;    HttpSession        session = null;&#xA;                session = pageContext.getSession();&#xA;    ServletContext        application = null;&#xA;                application = pageContext.getServletContext();&#xA;    ServletConfig        config = null;&#xA;                config = pageContext.getServletConfig();&#xA;    JspWriter            out = null;&#xA;                out = pageContext.getOut();&#xA;    Object            page = this;&#xA;    JspWriter            _jspx_out = null;&#xA;                _jspx_out = out;&#xA;    PageContext        _jspx_page_context = null;&#xA;                _jspx_page_context = pageContext;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp验证码&#34;&gt;&#xA;  jsp验证码&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp%e9%aa%8c%e8%af%81%e7%a0%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;实例    # 在&amp;lt;img&amp;gt;标签的src属性中指定该jsp文件即可&#xA;&#xA;    ## out.clear();out = pageContext.pushBody();两条语句的作用是&#xA;    ## 使该验证码jsp文件的传输不会默认地在返回数据后中断，而是在&amp;lt;img&amp;gt;标签调用该jsp的页面加载结束之后再中断数据的传输&#xA;    &amp;lt;%@ page language=&amp;quot;java&amp;quot; pageEncoding=&amp;quot;UTF-8&amp;quot;%&amp;gt;&#xA;&amp;lt;%@ page contentType=&amp;quot;image/jpeg&amp;quot; import=&amp;quot;java.util.*,java.awt.*,java.awt.image.*,javax.imageio.*&amp;quot;%&amp;gt;&#xA;&amp;lt;%!&#xA;    // 声明区，定义产生颜色和验证内容的全局方法&#xA;    public Color getColor(){&#xA;&#xA;    Random random = new Random();&#xA;    int r = random.nextInt(256);&#xA;    int g = random.nextInt(256);&#xA;    int b = random.nextInt(256);&#xA;    return new Color(r,g,b);&#xA;    }&#xA;    public String getNum(){&#xA;    String str = &amp;quot;&amp;quot;;&#xA;    Random random = new Random();&#xA;    for(int i = 0; i &amp;lt; 4; i++){&#xA;        str += random.nextInt(10) + &amp;quot; &amp;quot;;&#xA;    }&#xA;    return str;&#xA;    }&#xA;%&amp;gt;&#xA;&amp;lt;%&#xA;    // 设置响应无缓存&#xA;    response.setHeader(&amp;quot;pragma&amp;quot;, &amp;quot;mo-cache&amp;quot;);&#xA;    response.setHeader(&amp;quot;cache-control&amp;quot;, &amp;quot;no-cache&amp;quot;);&#xA;    response.setDateHeader(&amp;quot;expires&amp;quot;, 0);&#xA;    // 图片对象,画笔对象&#xA;    BufferedImage image = new BufferedImage(80,30,BufferedImage.TYPE_INT_RGB);&#xA;    Graphics g = image.getGraphics();&#xA;    // 画背景&#xA;    g.setColor(new Color(200,200,200));&#xA;    g.fillRect(0, 0, 80, 30);&#xA;    // 画干扰线&#xA;    for(int i = 0; i &amp;lt; 30; i++){&#xA;    Random random = new Random();&#xA;    int x = random.nextInt(80);&#xA;    int y = random.nextInt(30);&#xA;    int xl = random.nextInt(x+10);&#xA;    int yl = random.nextInt(y+10);&#xA;    g.setColor(getColor());&#xA;    g.drawLine(x, y, x + xl, y + yl);&#xA;    }&#xA;    // 画内容&#xA;    g.setFont(new Font(&amp;quot;serif&amp;quot;, Font.BOLD,16));&#xA;    g.setColor(Color.BLACK);&#xA;    String checkNum = getNum();&#xA;    g.drawString(checkNum,15,20);&#xA;    // 放内容到session中，返回图片流&#xA;    session.setAttribute(&amp;quot;validateCode&amp;quot;, checkNum.replaceAll(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;));&#xA;    ImageIO.write(image, &amp;quot;jpeg&amp;quot;, response.getOutputStream());&#xA;    out.clear();&#xA;    out = pageContext.pushBody();    // 不按照jsp默认的getWriter()方法输出，用我们定义的流的方法进行输出&#xA;%&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;自定义标签&#34;&gt;&#xA;  自定义标签&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a0%87%e7%ad%be&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;1、JspTag 接口（标记接口，类以Serializable）&#xA;2、Tag 接口（空标签，如&amp;lt;img/&amp;gt;）&#xA;    属性：&#xA;    static int EVAL_BODY_INCLUDE        通过流执行标签体&#xA;    static int EVAL_PAGE              继续执行页面&#xA;    static int SKIP_BODY            忽略执行标签体&#xA;    static int SKIP_PAGE            忽略后面的JSP页面&#xA;    方法：&#xA;    // 生命周期方法&#xA;    int doEndTag()            当遇到标签结束的时候自动执行&#xA;    int doStartTag()            当遇到标签开始的时候自动执行&#xA;    // 实现方法&#xA;    Tag getParent()            获取当前标签的父标签处理类对象&#xA;    void release()            当事件改变的时候自动执行&#xA;    void setPageContext(PageContext pc)    设置当前的JSP上下文环境&#xA;    void setParent(Tag t)        设置当前标签的父标签对象&#xA;3、TagSupport 类（有属性的标签，如&amp;lt;img src=&amp;quot;&amp;quot;/&amp;gt;）&#xA;    实现了Tag接口并且提供处理标签属性的方法(set和get)。而且内部定义了一个PageContext变量并且已经初始化开发者可以直接使用this或者super直接方法该属性。&#xA;4、BodyTagSupport类（有属性有文本内容和标签，如&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;aaa&amp;lt;/img&amp;gt;）&#xA;    新属性&#xA;    protected  BodyContent bodyContent&#xA;    新方法&#xA;    void setBodyContent(BodyContent b)&#xA;    BodyContent getBodyContent()&#xA;&#xA;    BodyContent类&#xA;        abstract String getString()    //获取标签体&#xA;&#xA;    写Tag接口的标签库&#xA;    1、写Tag接口实现类&#xA;        写属性pageContext（getter 和setter），从setPageContext(PageContext pc)方法中获得该属性&#xA;        复写方法&#xA;    2、写tld文件，放到/META-INF文件夹中&#xA;        &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;        &amp;lt;taglib xmlns=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot;&#xA;        xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&#xA;        xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&amp;quot;&#xA;        version=&amp;quot;2.1&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;tlib-version&amp;gt;1.0&amp;lt;/tlib-version&amp;gt;&#xA;        &amp;lt;short-name&amp;gt;ouru&amp;lt;/short-name&amp;gt;    # 简称&#xA;        &amp;lt;uri&amp;gt;/outrun-tags&amp;lt;/uri&amp;gt;    # 自定义引入标签时写的路径&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;testDate&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.test.DataImplTag&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;empty&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;/taglib&amp;gt;&#xA;    3、jsp 中引用它&#xA;        &amp;lt;%@ taglib prefix=&amp;quot;ouru&amp;quot; uri=&amp;quot;/META-INF/myUtil.tld&amp;quot; %&amp;gt;&#xA;    写TagSupport接口的实现类&#xA;    pageContext已内置&#xA;    定义接收属性&#xA;    tld文件中加入attribute属性&#xA;        &amp;lt;attribute&amp;gt;        属性描述的开始&#xA;        &amp;lt;name&amp;gt;pattern&amp;lt;/name&amp;gt;    描述属性名&#xA;        &amp;lt;required&amp;gt;true&amp;lt;/required&amp;gt;    描述属性是否是必须的&#xA;        &amp;lt;rtexprvalue&amp;gt;true&amp;lt;/rtexprvalue&amp;gt;  描述属性值是否可以是输出表达式&#xA;        &amp;lt;/attribute&amp;gt;&#xA;    写BodyTagSupport接口的实现类&#xA;    BodyContent body = this.getBodyContent();&#xA;    String desc = body.getString();&#xA;&#xA;    tld 文件中&#xA;    &amp;lt;body-content&amp;gt;JSP&amp;lt;/body-content&amp;gt;    # 有标签体，可执行脚本表达式&#xA;                        ## scriptless，有标签体，不执委脚本表达式&#xA;                        ## empty,没有标签体&#xA;&#xA;Jsp2.0&#xA;    JspTag — SimpleTag — SimpleTagSupport&#xA;&#xA;    SimpleTagSupport类&#xA;    该类可以直接进行操作标签的属性和标签体。&#xA;    void doTag()                遇到标签的时候自动指定&#xA;    protected  JspFragment getJspBody()          获取标签体对象&#xA;    protected  JspContext getJspContext()      获取JSP上下文环境对象&#xA;    JspTag getParent()            获取该标签的父标签处理类对象&#xA;        JspFragment类&#xA;        该类代表的标签的标签体。&#xA;        abstract  void invoke(Writer out)    输出数据到指定的流，null输出到JSP页面&#xA;    获得标签体的方法：&#xA;        Writer writer = new StringWriter();&#xA;        JspFragment jspFragment = getJspBody();&#xA;        jspFragment.invoke(writer);&#xA;        String text = writer.toString();&#xA;    项目：实现 if else 判断&#xA;    Choose.java&#xA;        private boolean tag = true;&#xA;&#xA;        public boolean isTag() {&#xA;            return tag;&#xA;        }&#xA;&#xA;        public void setTag(boolean tag) {&#xA;            this.tag = tag;&#xA;        }&#xA;&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            getJspBody().invoke(null);&#xA;            super.doTag();&#xA;        }&#xA;    when.java 文件&#xA;        private boolean test = false;&#xA;        public boolean isTest() {&#xA;            return test;&#xA;        }&#xA;&#xA;        public void setTest(boolean test) {&#xA;            this.test = test;&#xA;        }&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            Choose parent = (Choose) getParent();&#xA;            if(isTest() &amp;amp;&amp;amp; parent.isTag()){&#xA;            // 条件成立&#xA;            getJspBody().invoke(null);&#xA;            // 设置父的tag为false&#xA;            parent.setTag(false);&#xA;            }&#xA;            super.doTag();&#xA;        }&#xA;    Otherwise.java 文件&#xA;        @Override&#xA;        public void doTag() throws JspException, IOException {&#xA;            Choose parent = (Choose) getParent();&#xA;            if(parent.isTag()){&#xA;            // 条件成立&#xA;            getJspBody().invoke(null);&#xA;            parent.setTag(false);&#xA;            }&#xA;            super.doTag();&#xA;        }&#xA;    tld文件&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;choose&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.Choose&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;    # 有标签体，可执行脚本表达式&#xA;                                ## scriptless，有标签体，不执委脚本表达式&#xA;                                ## empty,没有标签体&#xA;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;when&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.When&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;attribute&amp;gt;&#xA;        &amp;lt;name&amp;gt;test&amp;lt;/name&amp;gt;&#xA;        &amp;lt;required&amp;gt;true&amp;lt;/required&amp;gt;&#xA;        &amp;lt;rtexprvalue&amp;gt;true&amp;lt;/rtexprvalue&amp;gt;&#xA;        &amp;lt;/attribute&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;        &amp;lt;tag&amp;gt;&#xA;        &amp;lt;name&amp;gt;otherwise&amp;lt;/name&amp;gt;&#xA;        &amp;lt;tag-class&amp;gt;outrun.util.jsp.taglib.ifelse.Otherwise&amp;lt;/tag-class&amp;gt;&#xA;        &amp;lt;body-content&amp;gt;scriptless&amp;lt;/body-content&amp;gt;&#xA;        &amp;lt;/tag&amp;gt;&#xA;&#xA;&#xA;&#xA;控件标签：&#xA;自定义函数库&#xA;    1 创建函数库类&#xA;    public class MyFunctions {&#xA;    public static String formatMyName(String name) {&#xA;    return &amp;quot;your name is &amp;quot; + name;&#xA;    }&#xA;    public static int add(int a, int b) {&#xA;    return a+b;&#xA;    }&#xA;    }&#xA;&#xA;    2 在TLD文件中配置 (引用于目标1中的tld文件)&#xA;    &amp;lt;function&amp;gt;&#xA;    &amp;lt;name&amp;gt;formatMyName&amp;lt;/name&amp;gt;&#xA;    &amp;lt;function-class&amp;gt;com.taglib.MyFunctions&amp;lt;/function-class&amp;gt;&#xA;    &amp;lt;function-signature&amp;gt;java.lang.String formatMyName(java.lang.String)&amp;lt;/function-signature&amp;gt;&#xA;    &amp;lt;/function&amp;gt;&#xA;&#xA;    &amp;lt;function&amp;gt;&#xA;    &amp;lt;name&amp;gt;add&amp;lt;/name&amp;gt;&#xA;    &amp;lt;function-class&amp;gt;com.taglib.MyFunctions&amp;lt;/function-class&amp;gt;&#xA;    &amp;lt;function-signature&amp;gt;java.lang.String add(int, int)&amp;lt;/function-signature&amp;gt;&#xA;    &amp;lt;/function&amp;gt;&#xA;&#xA;    3 JSP中调用&#xA;&#xA;    ${cc:formatMyName(&amp;quot;wangfei&amp;quot;) }&#xA;    ${cc:add(12, 34) }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jdbc&#34;&gt;&#xA;  jdbc&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdbc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;流程&#xA;    Class.forName()     # 加载驱动&#xA;    DriverManager.getConnection()&#xA;    获得sql会话对象 Statement或PreparedStatement&#xA;    设置参数setXxx(), 执行sql，处理结果集&#xA;    关闭结果集、关闭会话、关闭连接&#xA;Statement&#xA;    execute&#xA;    executeQuery&#xA;    executeUpdate&#xA;    不要使用Statement&#xA;        容易sql注入&#xA;        代码可读性可维护性差&#xA;        PreparedStatement性能高，db缓存机制，相同预编译语句调用不再编译&#xA;PreparedStatement&#xA;    # 继承Statement, 预编译sql&#xA;&#xA;事务怎么写&#xA;    编程式&#xA;    声明式: 用aop注入&#xA;三种连接&#xA;    Connection&#xA;        默认自动提交&#xA;        禁止自动提交开启事务, 后调commit&#xA;    Pooled Connection&#xA;        使用完后不用关闭&#xA;    XA Connection&#xA;        分布式事务&#xA;        XAResource获得&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;i18n&#34;&gt;&#xA;  i18n&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#i18n&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;页面需要获取用户信息，从数据库中取数据显示&#xA;&#xA;java类中试用：&#xA;cn.itcast.resource包中&#xA;    hello_en_US.properties&#xA;    hello=hello&#xA;    hello_zh_CN.properties&#xA;    hello=编码后的“你好”&#xA;    Test.java&#xA;    #  获取信息&#xA;    Locale locale = locale.CHINA;&#xA;    #  加载资源&#xA;    ResourceBundle bundler = ResourceBundle.getBundle(&amp;quot;cn.itcast.resource.hello&amp;quot;,locale);&#xA;    #  取出数据&#xA;    String str = bundler.getString(&amp;quot;hello&amp;quot;);&#xA;&#xA;jsp中&#xA;&amp;lt;%&#xA;    ResourceBundle bundler = ResourceBundle.getBundle(&amp;quot;lang.properties.hello&amp;quot;, request.getLocale());&#xA;    out.write(bundler.getString(&amp;quot;title&amp;quot;));&#xA;%&amp;gt;&#xA;&amp;lt;fmt&amp;gt;标签&#xA;    &amp;lt;fmt:setLocale value=&amp;quot;${pageContext.request.locale }&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&#xA;    &amp;lt;fmt:setBundle basename=&amp;quot;lang.properties.hello&amp;quot; var=&amp;quot;bundler&amp;quot; scope=&amp;quot;page&amp;quot;/&amp;gt;&#xA;    &amp;lt;fmt:message bundle=&amp;quot;${bundler }&amp;quot; key=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;/fmt:message&amp;gt;&#xA;资源转码&#xA;    native2ascii.exe&#xA;    myeclipse properties文件编辑器&#xA;ie 中得到en_US&#xA;Locale locale&#xA;    getLanguage();&#xA;    getCountry();&#xA;    getDefault();&#xA;ResourceBundle&#xA;    读取文件cn.itcast.resource.hello省略_en_US.properties&#xA;    getString(String key)&#xA;实例1：&#xA;    创建页面&#xA;    创建资源文件&#xA;    编辑页面&#xA;    request.getLocale();&#xA;    ResourceBundle.getBundle(&amp;quot;&amp;quot;,locale);&#xA;    getString(&amp;quot;&amp;quot;)&#xA;实例2：&#xA;    编辑页面&#xA;    &amp;lt;%@ taglib%&amp;gt;&#xA;    &amp;lt;f:setLocale scope=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;f:setBundle basename=&amp;quot;&amp;quot; var=&amp;quot;&amp;quot; scope=&amp;quot;&amp;quot;&amp;gt;&#xA;    &amp;lt;f:message bundle=&amp;quot;&amp;quot; key=&amp;quot;&amp;quot; &amp;gt;&#xA;动态数据国际化&#xA;日期国际化&#xA;    SimpleDateFormat    #  继承DateFormat&#xA;    getDateTimeInstance&#xA;    getDateInstance&#xA;    getTimeInstance&#xA;&#xA;    static int FULL&#xA;    static int LONG&#xA;    static int MEDIUM&#xA;    static int SHORT&#xA;实例3：&#xA;    cn.itcast.i18n.MyDateI18n&#xA;    DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);&#xA;    String str = format.format(new Date());&#xA;    解析页面中的字符串&#xA;    FULL 和 LONG  和 MEDIUM 和 SHORT 的 区别&#xA;    DataFomat&#xA;    String format(Date date)&#xA;    Date parse(String source)&#xA;    创建static string2Date(String str)&#xA;    #  分析区域&#xA;    Locale locale = Locale.CHINA;&#xA;&#xA;    #  分析日期的风格&#xA;    int dateType = DateFormat.SHORT;&#xA;    int timeType = DateFormat.FULL;&#xA;&#xA;    #  获取对象&#xA;    DateFormat format = DateFormat.getDateTimeInstance(dateType,timeType,locale);&#xA;&#xA;    #  解析&#xA;    format.parse(str);&#xA;动态数字国际化&#xA;    java.text.*;&#xA;    Number类&#xA;    NumberFormat(普通数字，货币，百分比)&#xA;    getIntegetInstance&#xA;    getCurrencyInstance&#xA;    getPercentInstance(Locale inLocale)&#xA;&#xA;    format&#xA;    parse&#xA;    创建cn.itcast.i18n.MyNumberI18n&#xA;    #  获取对象&#xA;    #  getPercentInstance&#xA;    #  getCurrencyInstance&#xA;    NumberFormat format = NumberFormat.getIntegerInstance(Locale.CHINA);&#xA;&#xA;    #  格式化 或解析&#xA;    long num = 10000000000L;&#xA;    #  Number num = format.parse(str);&#xA;    #  double price = num.doubleValue();&#xA;    format.format(num);&#xA;动态文本国际化&#xA;    At 12:30 pm on jul 3,1998, a hurricance destroyed 99 houses and caused $1000000 of damage.&#xA;    MessageFormat&#xA;    MessageFormat(String pattern,Locale locale)&#xA;    format(String pattern,Object...arguments)&#xA;    format(Object)&#xA;    parse()&#xA;    占位&#xA;    At{0}  on {0}, a hurricance destroyed{1} houses and caused {2} of damage.&#xA;&#xA;    实例1：&#xA;    MyMessageI18n.java&#xA;    #  定义模式字符串&#xA;    String pattern&#xA;    #  定义locale对象&#xA;    MessageFormat format = new MessageFormat(pattern,Locale.CHINA);&#xA;    #  定义参数数组&#xA;    DateFormat datef = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.SHORT,Locale.US);&#xA;    Date date = datef.parse(&amp;quot;Jul 3,1998 12:30 PM&amp;quot;);&#xA;&#xA;    Integer num = new Integer(99);&#xA;&#xA;    long currency = NumberFormat.getCurrencyInstance(Locale.US).parse(&amp;quot;$1000000&amp;quot;);&#xA;    String damage = NumberFormat.getCurrencyInstance(locale).format(currency);&#xA;&#xA;    Object [] values = {date,num,damage};&#xA;    #  格式化&#xA;    String str = format.format(values);&#xA;&#xA;    分析：{索引，对象，类型}&#xA;    MessageFormat messf = new MessageFormat(&amp;quot;{0,time,short} on {0,date}, a hurricance destroyed {1} houses and caused {2,number,currency} of damage.&amp;quot;,Locale.CHINA);&#xA;&#xA;    Object [] values = {new Date(),new Integer(100),1000};&#xA;&#xA;    String str = messf.format(values);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;中间件&#34;&gt;&#xA;  中间件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e9%97%b4%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;顺序&#xA;    监听器 -&amp;gt; 过滤器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;监听器&#34;&gt;&#xA;  监听器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e5%90%ac%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    ServletContextListener&#xA;    ServletContextAttributeListener&#xA;    HttpSessionListener&#xA;    HttpSessionAttributeListener&#xA;    HttpSessionActivationListener&#xA;web.xml 注册在过滤器后面，servlet前面&#xA;    &amp;lt;listener&amp;gt;&#xA;    &amp;lt;listener-class&amp;gt;cn.listen.MyListener&amp;lt;/listener-class&amp;gt;&#xA;    &amp;lt;/listener&amp;gt;&#xA;自定义&#xA;    public class MyListener implements ServletContextListener {&#xA;        public void contextDestroyed(ServletContextEvent sce) {&#xA;            System.out.println(&amp;quot;die&amp;quot;);&#xA;        }&#xA;        public void contextInitialized(ServletContextEvent sce) {&#xA;            System.out.println(&amp;quot;init&amp;quot;);&#xA;        }&#xA;&#xA;        // 当过滤器被销毁时自动执行&#xA;        public void destroy(){&#xA;            System.out.println(&amp;quot;Filterdestroyed&amp;quot;);&#xA;        }&#xA;        // 当拦截的时候&#xA;        public void doFilter(request,response,chain){&#xA;            System.out.println(&amp;quot;doFilter&amp;quot;);&#xA;            System.out.println(&amp;quot;放行目标资源&amp;quot;);&#xA;            chain.doFilter(request,response);&#xA;            System.out.println(&amp;quot;目标已经放行&amp;quot;);&#xA;        }&#xA;        // 初始化的时候&#xA;        public void init(FilterConfig config){&#xA;            System.out.println(&amp;quot;FilterInited&amp;quot;);&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;过滤器&#34;&gt;&#xA;  过滤器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%87%e6%bb%a4%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;web.xml&#xA;    &amp;lt;filter&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;testFilter&#xA;        &amp;lt;filter-class&amp;gt;cn.itcast.filter.text.TestFilter&#xA;        &amp;lt;init-param&amp;gt;&#xA;            &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;&#xA;            &amp;lt;param-value&amp;gt;GB2312&amp;lt;/param-value&amp;gt;&#xA;        &amp;lt;/init-param&amp;gt;&#xA;    &amp;lt;/filter&amp;gt;&#xA;    &amp;lt;filter-mapping&amp;gt;&#xA;        &amp;lt;filter-name&amp;gt;testFilter&#xA;        &amp;lt;url-pattern&amp;gt;/*&#xA;    &amp;lt;/filter-mapping&amp;gt;&#xA;&#xA;api&#xA;    Filter接口&#xA;        ## 多个过滤器, 按web.xml中注册的顺序映射调用。servlet执行完后, 从后向前返回执行chain.doFilter之后的方法&#xA;        init&#xA;        destroy&#xA;        doFilter(ServletRequest request, ServletResponse response, FilterChain chain)&#xA;    FilterChain接口&#xA;        doFilter(ServletRequest request, ServletResponse response)&#xA;    FilterConfig接口&#xA;        private FilterConfig config = null;&#xA;        init()&#xA;            this.config = config;&#xA;        doFilter()&#xA;            String ip = this.config.getInitParameter(&amp;quot;ip&amp;quot;);&#xA;&#xA;映射&#xA;    1.映射的url&#xA;    2.servlet的名字&#xA;        # 通配servlet &amp;lt;url-pattern&amp;gt;/servlet/*&amp;lt;/url-pattern&amp;gt;&#xA;    3.为了映射servlet中的转发, 映射一个过滤器到某种传递方式&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;            &amp;lt;dispatcher&amp;gt;FORWARD&#xA;                # FORWARD 转发方式&#xA;                # REQUEST  请求方式&#xA;                # INCLUDE  包含方式&#xA;                # ERROR  错误页面&#xA;            &amp;lt;/dispatcher&amp;gt;&#xA;        &amp;lt;/filter-mapping&amp;gt;&#xA;设置编码&#xA;    doFilter()&#xA;        HttpServletRequest httpRequest = (HttpServletRequest) request;&#xA;        HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;        httpRequest.setCharacterEncoding(&amp;quot;utf-8&amp;quot;)&#xA;        String method = httpRequest.getMethod();&#xA;        if(&amp;quot;get&amp;quot;.equalsIgnoreCase(method)){&#xA;            chain.doFilter(new MyWapperRequest(httpRequest),response);&#xA;        }else{&#xA;            request.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);&#xA;        }&#xA;&#xA;    class MyWapperRequest extends HttpServletRequestWrapper{&#xA;        private HttpServletRequest request = null;&#xA;&#xA;        public MyWapperRequest (HttpServletRequest request){&#xA;            super(request);&#xA;            this.request = request;&#xA;        }&#xA;&#xA;        @Override&#xA;        public String getParameter(String name){&#xA;            String value = request.getParameter(name);&#xA;            String method = request.getMethod();&#xA;            if(value != null &amp;amp;&amp;amp;&amp;quot;get&amp;quot;.equalsIgnoreCase(method)){&#xA;                value = new String(value.getBytes(&amp;quot;iso8859-1&amp;quot;),request.getCharacterEncoding())&#xA;            }&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;设置缓存&#xA;    # Expires:-1&#xA;    # Cache-Control:no-cache&#xA;    # Pragma:no-cache&#xA;&#xA;    NoCacheFilter implements Filter # 设置不缓存&#xA;        doFilter()&#xA;            HttpServletResponse httpResponse = response;&#xA;            httpResponse.setHeader(&amp;quot;Expires&amp;quot;,-1 + &amp;quot;&amp;quot;);&#xA;            //  setDataHeader(&amp;quot;expires&amp;quot;,-1);&#xA;            httpResponse.setHeader(&amp;quot;cache-control&amp;quot;,&amp;quot;no-cache&amp;quot;);&#xA;            httpResponse.setHeader(&amp;quot;pragma&amp;quot;,&amp;quot;no-cache&amp;quot;);&#xA;            chain.doFilter(request,httpResponse);&#xA;&#xA;&#xA;&#xA;    CacheFilter&#xA;        # 缓存静态资源&#xA;        # web.xml中url-pattern 可以映射多个 param-name=jpg param-value=2&#xA;        private FilterConfig config = null;&#xA;&#xA;        doFilter()&#xA;            HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;            HttpServletResponse httpRequest = (HttpServletRequest) request;&#xA;&#xA;        String resource = request.getRequestURI();&#xA;        String date  = null;&#xA;        if(resource.endsWith(&amp;quot;jpg&amp;quot;)){&#xA;            date =  config.getInitParameter(&amp;quot;jpg&amp;quot;);&#xA;            httpResponse.setDateHeader(&amp;quot;expires&amp;quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);    // 换算成秒&#xA;        } else if(resource.endsWith(&amp;quot;js&amp;quot;)){&#xA;            String date  = config.getInitParameter(&amp;quot;js&amp;quot;);&#xA;            config.getInitParameter(&amp;quot;js&amp;quot;);&#xA;            httpResponse.setDateHeader(&amp;quot;expires&amp;quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);&#xA;        }&#xA;&#xA;        chain.doFilter(httpRequest,httpResponse);&#xA;&#xA;修改编码&#xA;    EncodingFilter implements Filter{&#xA;        doFilter(request,response){&#xA;            HttpServletResponse httpResponse = (HttpServletResponse) response;&#xA;            HttpServletResponse httpRequest = (HttpServletRequest) request;&#xA;            httpRequest.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);&#xA;            chain.doFilter(httpRequest,httpResponse);&#xA;        }&#xA;    }&#xA;    class EncodingRequest extends HttpServletRequestWrapper{&#xA;        private HttpServletRequest request;&#xA;        public EncodingRequest (HttpServletRequest request){&#xA;            super(request);&#xA;            this.request = request;&#xA;        }&#xA;&#xA;        @Override&#xA;        public String getParameter(String name){&#xA;            String value = request.getParameter(name)&#xA;            if(value != null &amp;amp;&amp;amp; &amp;quot;get&amp;quot;.equalsIgnoreCase(request.getMethod)){&#xA;                value = new String(value.getBytes(&amp;quot;iso8859&amp;quot;),&amp;quot;utf-8&amp;quot;);&#xA;            }&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;登录&#xA;    LoginFilter&#xA;        init(){&#xA;            this.config  = config;&#xA;        }&#xA;        private FilterConfig config = null;&#xA;        doFilter(){&#xA;            String path = this.config.getInitParameter(&amp;quot;loginPage&amp;quot;);&#xA;            HttpSession session = httpRequest.getSession(false);&#xA;&#xA;            // 判断用户请求的是否是UserServlet&#xA;            String servletName = httpRequest.getServletPath();&#xA;            servletName = substring(servletName.lastIndexOf(&amp;quot;/&amp;quot;)+1);&#xA;            if(&amp;quot;UsersServlet&amp;quot;.equals(servletName)){&#xA;            }else{ // 一般的servlet&#xA;                if(session != null){&#xA;                    // 获取登录标记&#xA;                    User user = null;&#xA;                    user = (User)session.getAttribute(&amp;quot;user&amp;quot;);&#xA;&#xA;                    // 判断&#xA;                    if(user != null){&#xA;                        // 放行资源&#xA;                        chain.doFilter(httpRequest,httpResponse);&#xA;                    }else{&#xA;                        // 页面重定向到登录页面&#xA;                        httpResponse.sendRedirect(httpRequest.getContextPath() + &amp;quot;/&amp;quot; + path);&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    web.xml&#xA;        &amp;lt;filter&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;loginFilter&#xA;            &amp;lt;filter-class&amp;gt;&#xA;            &amp;lt;init-param&amp;gt;&#xA;                &amp;lt;param-name&amp;gt;loginPage&#xA;                &amp;lt;param-value&amp;gt;&#xA;        &amp;lt;filter-mapping&amp;gt;&#xA;            &amp;lt;filter-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;/jsps/*&#xA;                &amp;lt;url-pattern&amp;gt;/servlet/*&#xA;                &amp;lt;url-pattern&amp;gt;/publics/*&#xA;            &amp;lt;filter-name&amp;gt;&#xA;                &amp;lt;url-pattern&amp;gt;/publics/head.jsp&#xA;                &amp;lt;dispatcher&amp;gt;INCLUDE&#xA;                &amp;lt;dispatcher&amp;gt;FORWARD&#xA;                &amp;lt;dispatcher&amp;gt;ERROR&#xA;                &amp;lt;dispatcher&amp;gt;REQUEST&#xA;                    # 默认是request，当加上其它参数时（如include），request会没有，所以要加两个forward,request&#xA;                    ## 是指向里面以该方法请求的时候进行过滤&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;struts2&#34;&gt;&#xA;  struts2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#struts2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Java并发</title>
      <link>https://runout.run/docs/pl/java/juc/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/juc/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;并发编程三大特性&#xA;    可见性(visibility)&#xA;        synchronized会刷新线程栈&#xA;    有序性(ordering)&#xA;    原子性(atomicity)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cpu&#34;&gt;&#xA;  CPU&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;PC寄存器(Program Counter Register, 存下一指令)&#xA;优化&#xA;    乱序读&#xA;    合并写&#xA;    乱序执行(流水线)&#xA;ALU&#xA;    访问速度&#xA;        Registers: &amp;lt; 1ns&#xA;        L1 cache(核内): 1ns&#xA;        WC(Writer Comblining) Buffer    # 合并写, 一般4个字节&#xA;        L2 cache(核内): 3ns&#xA;        L3 cache(CPU内): 15ns&#xA;        memory: 80ns&#xA;局部性原理&#xA;    空间&#xA;        按块读取(cache line)&#xA;            一次读64Bytes               # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知&#xA;            Java1.8注解@Contended       # 保证不在同一行，需要JVM参数-XX:-RestrictContended&#xA;    时间&#xA;        批量读指令&#xA;内存屏障                        # 不同CPU不一样&#xA;    Intel&#xA;        sfence                      # save, 之前写操作必须完成&#xA;        lfence                      # load, 之前读操作必须完成&#xA;        mfence                      # mix(save + load)&#xA;lock指令                            # 指令执行完之前，锁内存&#xA;    lock_add&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;cpu缓存一致性协议&#34;&gt;&#xA;  CPU缓存一致性协议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cpu%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁&#xA;状态&#xA;    MESI Cache一致性协议                    # Intel CPU，实现方式为主动监听&#xA;        Modified                            # 一行数据在CPU Modified, 其它CPU为Invalid&#xA;        Exclusive                           # 独享，其它CPU没有&#xA;        Shared                              # 别人也在读&#xA;        Invalid                             # 别人改过了&#xA;    MSI&#xA;    MOSI&#xA;缓存行                                      # 多数64字节&#xA;    伪共享                                  # 缓存行内无关数据也要同步&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;os&#34;&gt;&#xA;  OS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#os&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;进程&#xA;    # 资源分配&#xA;线程&#xA;    # 调度执行&#xA;    切换(Context Switch)&#xA;        CPU导出原线程指令和data到cache, 再导入新线程数据&#xA;    线程数&#xA;        N(threads) = N(CPU) * U(CPU) * (1 + W/C)&#xA;            # N(CPU): CPU数&#xA;            # U(CPU): 期望CPU利用率, 0到1&#xA;            # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析&#xA;        压测决定&#xA;CPU性能压榨&#xA;    单进程&#xA;    批处理&#xA;    多进程切换&#xA;    多线程进程内切换&#xA;        I/O复用&#xA;    协程(纤程、绿色线程)用户空间切换&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jvm&#34;&gt;&#xA;  JVM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;内存屏障&#34;&gt;&#xA;  内存屏障&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;LoadLoad&#xA;StoreStore&#xA;LoadStore&#xA;StoreLoad&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;乱序执行指令重排序&#34;&gt;&#xA;  乱序执行(指令重排序)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;为什么&#xA;    CPU快, 指令1阻塞时，指令2先执行&#xA;判断&#xA;    代码不影响单线程最终一致性&#xA;例子，多线程&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0, b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Long.&lt;span style=&#34;color:#a6e22e&#34;&gt;MAX_VALUE&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&amp;gt;&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                x&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                y&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                CountDownLatch latch &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; CountDownLatch(2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Thread one &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Thread other &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;countDown&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                });&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                one.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                other.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                latch.&lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;例子，类初始化指令换顺序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 8;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        T t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; T();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        汇编码&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            0 &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 变量半初始化状态为0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            3 dup&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            4 invokespecial &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;3 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T.&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;init&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            7 astore_1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;。&lt;/span&gt;线程访问时中间状态逸出&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            8 &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Thread(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;)).&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; C();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                System.&lt;span style=&#34;color:#a6e22e&#34;&gt;in&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;unsafe类&#34;&gt;&#xA;  Unsafe类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#unsafe%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 相当于指针。1.8只能根部类用, 11可以直接用&#xA;操作内存&#xA;    allocateMemory&#xA;    putXX&#xA;    freeMemory&#xA;    pageSize&#xA;生成类实例&#xA;    allocateInstance&#xA;操作类或实例&#xA;    objectFieldOffset&#xA;    getInt&#xA;    getObject&#xA;CAS&#xA;    compareAndSwapObject()          # JDK1.8&#xA;    compareAndSetObject()&#xA;    weakCompareAndSetObject()       # JDK11&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;修饰符与锁&#34;&gt;&#xA;  修饰符与锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e4%b8%8e%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;&#xA;  概念&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;锁细化                              # 少代码加轻量锁&#xA;锁粗化                              # 锁太多时，如行锁变表锁&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;synchronized&#34;&gt;&#xA;  synchronized&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;实现方式&#xA;    JVM没要求实现方式&#xA;    早期都是OS调度&#xA;    HotSpot&#xA;        在对象头(64位)上用2位实现，组合成锁的类型&#xA;        锁升级                      # 不比原子类慢，升完不降&#xA;            偏向锁, 第一个线程第一次访问只记线程id&#xA;            自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平&#xA;            重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景&#xA;原子性、可见性&#xA;可重入                              # 同一个对象同线程可重入&#xA;加锁对象&#xA;    方法锁和对象锁锁this&#xA;    static方法锁和类锁锁class类&#xA;    继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象&#xA;使用注意&#xA;    抛异常立即释放锁，但被锁数据已更新&#xA;    不能用的对象&#xA;        String常量，可能未知地方锁同一个&#xA;        Integer、Long等基本类型, 值变化会生成新对象&#xA;    synchronized的属性加final防止赋值&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;volatile&#34;&gt;&#xA;  volatile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#volatile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 用synchronized性能差不多，volatile一般不用&#xA;作用&#xA;    # 没有原子性，可能写同一值&#xA;    变量在线程见可见性&#xA;        依靠CPU缓存一致性协议&#xA;    禁止指令重排序                  # 用JVM的读写屏障&#xA;        &#xA;修饰引用类型，内部属性不监控&#xA;&#xA;DCL(Double Check Lock)单例volatile问题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; C c;    &lt;span style=&#34;color:#75715e&#34;&gt;// 禁止了创建c指令重排序&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;(){}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; C &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (C.&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// 申请内存(半初始化状态默认0)，成员变量初始化，赋值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; C();    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; c;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cas&#34;&gt;&#xA;  CAS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Compare And Set/Swap, 无锁优化, 乐观锁, 自旋&#xA;# Unsafe类支持&#xA;CPU原语&#xA;    cas(V, Expected, NewValue)&#xA;        if V == E                   # 无并发值判断问题，原语上加了屏障&#xA;        V = New&#xA;        else try again or fail&#xA;Java&#xA;    AtomicInteger&#xA;        incrementAndGet()&#xA;ABA问题&#xA;    # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据&#xA;    版本号                          # Java版本号类AtomicStampedReference&#xA;LongAdder&#xA;    LongAdder每次加数字, LongAccumulator用lambda&#xA;    分段锁(CAS)。值分开放数组里, 多线程对应一个item&#xA;性能测试&#xA;    LongAdder(713) &amp;gt; Atomic(2166) &amp;gt; Synchronized(3129)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;锁&#34;&gt;&#xA;  锁&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;aqs&#34;&gt;&#xA;  AQS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种&#xA;# 实现方式: CAS，volatile, 模板方法&#xA;类图&#xA;    AbstractQueueSynchronizer&#xA;        Sync&#xA;            NonfairSync&#xA;方法&#xA;    AbstractQueueSynchronizer&#xA;        # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待)&#xA;        Node&#xA;            volatile Node prev&#xA;            volatile Node next&#xA;            volatile Thread thread&#xA;        VarHandle&#xA;            # JDK1.9，保存引用，普通属性原子操作。&#xA;            # 相比反射，直接操作二进制码&#xA;            get()&#xA;            set()&#xA;            compareAndSet()         # 原子性&#xA;            getAndAdd()             # 原子性&#xA;            class C {&#xA;                int x = 0;&#xA;                private static VarHandle handle;&#xA;                static {&#xA;                    handle = MethodHandles.lookup().findVarHandle(C.class, &amp;quot;x&amp;quot;, int.class)&#xA;                    handle.compareAndSet(c, 0, 1);&#xA;&#xA;                }&#xA;            }&#xA;        volatile state              # 多态实现&#xA;        acquire()&#xA;        tryAcquire()                # 模板方法&#xA;        acquireQueued()             # 获得&#xA;        addWaiter(Node.EXCLUSIVE)   # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表)&#xA;        cancelAcquire()             # status CANCELLED, tail时设置null, 非tail时unpark下一节点&#xA;    NonfairSync&#xA;        nonfairTryAcquire()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reentrantlock&#34;&gt;&#xA;  ReentrantLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reentrantlock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 可重入锁，CAS实现, state记重入多少次&#xA;    new ReentrantLock(true)         # 公平锁&#xA;    tryLock(long, TimeUnit)&#xA;    lockInterruptibly()             # 响应interrupt()标记&#xA;    newCondition()                  # 多一个等待队列&#xA;&#xA;    源码&#xA;        调NonfairSync&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;countdownlatch&#34;&gt;&#xA;  CountDownLatch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#countdownlatch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 比join()灵活&#xA;    new CountDownLatch(4)&#xA;    countDown()&#xA;    await()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;cyclicbarrier&#34;&gt;&#xA;  CyclicBarrier&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cyclicbarrier&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 满了一起放行, 场景如I/O批量消费&#xA;    new CyclicBarrier(4, ()-&amp;gt;{})&#xA;    await()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;phaser&#34;&gt;&#xA;  Phaser&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#phaser&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 阶段批量执行过滤&#xA;    class MyPhaser extends Phaser {&#xA;        @Override&#xA;        protected boolean onAdvance(int phase, int registeredParties) {&#xA;            switch(phase) {&#xA;                case 0:&#xA;                    print(&amp;quot;arrived&amp;quot; + registeredParties);&#xA;                    return false;&#xA;                case 1:&#xA;                    print(&amp;quot;eated&amp;quot; + registeredParties);&#xA;                    return false;&#xA;                case 2:&#xA;                    print(&amp;quot;hugged&amp;quot; + registeredParties);&#xA;                    return true;&#xA;                default:&#xA;                    return true;&#xA;            }&#xA;        }&#xA;    }&#xA;    Person implements Runnable {&#xA;        private int i;&#xA;        public Person(int i) {&#xA;            this.i = i;&#xA;        }&#xA;        public void arrive() {&#xA;            phaser.arriveAndAwaitAdvance();&#xA;        }&#xA;        public void eat() {&#xA;            phaser.arriveAndAwaitAdvance();&#xA;        }&#xA;        public void hug() {&#xA;            if (i == 0 || i == 1) {&#xA;                phaser.arriveAndAwaitAdvance();&#xA;            } else {&#xA;                phaser.arriveAndDeregister();&#xA;            }&#xA;        }&#xA;&#xA;        @Override&#xA;        public void run() {&#xA;            arrive();&#xA;            eat();&#xA;            hug();&#xA;        }&#xA;    }&#xA;    phaser = new MyPhaser();&#xA;    phaser.bulkRegister(5);&#xA;    for (int i = 0; i &amp;lt; 5; i++) {&#xA;        new Thread(new Person(i)).start()&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;readwritelock&#34;&gt;&#xA;  ReadWriteLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readwritelock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 读锁是共享锁，不能写，悲观锁&#xA;    # 写锁是排他锁，不能读写&#xA;    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();&#xA;    Lock readLock = readWriteLock.readLock();&#xA;    Lock writeLock = readWriteLock.writeLock();&#xA;    void read(Lock lock) {&#xA;        lock.lock()&#xA;        lock.unlock()&#xA;    }&#xA;    void write(Lock lock) {&#xA;        lock.lock()&#xA;        lock.unlock()&#xA;    }&#xA;    for (int i =0; i&amp;lt;10;i++) {&#xA;        new Thread(()-&amp;gt;read(readLock)).start();&#xA;    }&#xA;    for (int i =0; i&amp;lt;2; i++) {&#xA;        new Thread(()-&amp;gt;write(writeLock)).start();&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;stampedlock&#34;&gt;&#xA;  StampedLock&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stampedlock&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 读时允许写，读完判断不一致再读一遍，乐观锁&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;semaphore&#34;&gt;&#xA;  Semaphore&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#semaphore&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 信号量, 限流同时运行, 用于线程间同步。可设置公平&#xA;    Semaphore s = new Semaphore(1, true)&#xA;    new Thread(() -&amp;gt; {&#xA;        s.acquire();&#xA;        s.release()&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;exchanger&#34;&gt;&#xA;  Exchanger&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#exchanger&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 线程间通信, 阻塞交换&#xA;    exchange()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;locksupport&#34;&gt;&#xA;  LockSupport&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#locksupport&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    # 线程间通信，非锁阻塞，指定线程唤醒&#xA;    # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1)&#xA;    Thread t = new Thread(() -&amp;gt; {&#xA;        for (int i = 0; i &amp;lt; 10; i++) {&#xA;            if (i == 5) {&#xA;                LockSupport.park();&#xA;            }&#xA;        }&#xA;    })&#xA;    t.start();&#xA;    TimeUnit.SECONDS.sleep(1);&#xA;    LockSupport.unpark(t);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;线程及线程池&#34;&gt;&#xA;  线程及线程池&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%8f%8a%e7%ba%bf%e7%a8%8b%e6%b1%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;使用注意&#34;&gt;&#xA;  使用注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;为什么不用Executors线程池&#xA;    用LinkedBlockingQueue超数量OOM&#xA;    拒绝策略&#xA;    线程命名&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类&#34;&gt;&#xA;  类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Object&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;wait&lt;/span&gt;()                              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 释放synchronized锁并加入等待队列&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;唤醒后执行需要得到synchronized锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;notify&lt;/span&gt;()                            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 只唤醒&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;不释放当前synchronized锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Thread&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentThread&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;yield&lt;/span&gt;()                      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 让出CPU, 进Ready队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        getState()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        join()                              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 等待结束&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;setDaemon&lt;/span&gt;()                         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 是否后台&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;setPriority&lt;/span&gt;(Thread.&lt;span style=&#34;color:#a6e22e&#34;&gt;NORM_PRIORITY&lt;/span&gt;)   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 优先级&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;没有用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Runnable&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Callable&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        V &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;throws&lt;/span&gt; Exception&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Future&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        get(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cancel(&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        isCanceled()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        isDone()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RunnableFuture&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FutureTask&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompletableFuture&lt;/span&gt;         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; parallel&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;supplyAsync&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;allOf&lt;/span&gt;(CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;...)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;anyOf&lt;/span&gt;(CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;...)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            T &lt;span style=&#34;color:#a6e22e&#34;&gt;join&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;thenApply&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            CompletableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Void&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;thenAccept&lt;/span&gt;(Consumer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadFactory&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Thread &lt;span style=&#34;color:#a6e22e&#34;&gt;newThread&lt;/span&gt;(Runnable)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DefaultThreadFactory&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Executor&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExecutorService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;shutdown&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            shutdownNow()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            isShutdown()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            isTerminated()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            awaitTermination(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Future &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Future &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Runnable, T)                     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 手动设个result&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;submit&lt;/span&gt;(Runnable)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; AbstractExecutorService&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                RunnableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newTaskFor&lt;/span&gt;(Runnable, T)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                RunnableFuture&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newTaskFor&lt;/span&gt;(Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                T &lt;span style=&#34;color:#a6e22e&#34;&gt;doInvokeAny&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; timed, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                submit()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                invokeAll(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 忽略CancellationException, ExecutionException&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其它异常抛出并取消未完成任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;invokeAll&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 忽略CancellationException, ExecutionException, TimeoutException&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;其它异常抛出并取消未完成任务&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;invokeAny&lt;/span&gt;(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                invokeAny(Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Callable&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ThreadPoolExecutor&lt;/span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 线程池&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;任务队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 任务顺序: 核心线程, 任务队列&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;起新线程&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;拒绝策略&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledThreadPoolExecutor&lt;/span&gt;       &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 用DelayedWorkQueue&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#a6e22e&#34;&gt;scheduleAtFixedRate&lt;/span&gt;(()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{}, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; initial, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; period, TimeUnit)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ForkJoinPool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a6e22e&#34;&gt;execute&lt;/span&gt;(ForkJoinTask)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledExecutorService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CompletionService&lt;/span&gt;                             &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 不阻塞全部任务&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;已有结果入队列&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExecutorCompletionService&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Executors&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newSingleThreadExecutor&lt;/span&gt;()                           &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 为了用任务队列和生命周期管理&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newCachedThreadPool&lt;/span&gt;()                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 超时60s, max为MAX_VALUE, 任务不堆积场景&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newFixedThreadPool&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        newScheduledThreadPool()                            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; AbstractQueuedSynchronizer&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;newWorkStealingPool&lt;/span&gt;()                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; ForkJoinPool, go的M,G,P&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; 每个线程单独队列, 尾部偷加尾部&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;创建线程&#34;&gt;&#xA;  创建线程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 继承&#xA;class MyThread extendws Thread {&#xA;    @Override&#xA;    public void run(){}&#xA;}&#xA;new MyThread().start();&#xA;&#xA;# 组合&#xA;class MyRun implements Runnable {&#xA;    @Override&#xA;    public void run(){}&#xA;}&#xA;new Thread(new MyRun()).start();&#xA;&#xA;# 返回值&#xA;class myCall implements Callable&amp;lt;String&amp;gt; {&#xA;    @Override&#xA;    public String call(){}&#xA;}&#xA;FutureTask = ft = new FutureTask&amp;lt;String&amp;gt;(new MyCall())&#xA;new Thread(ft).start();&#xA;ft.get();&#xA;&#xA;# 线程池&#xA;// execute无返回值&#xA;ExecutorService service = Executors.newCachedThreadPool()&#xA;service.execute(()-&amp;gt;{});&#xA;// submit有返回值 &#xA;Future&amp;lt;String&amp;gt; f = service.submit(new MyCall());&#xA;service.shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程状态&#34;&gt;&#xA;  线程状态&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;NEW&#xA;RUNNABLE            # 可调度&#xA;    READY&#xA;    RUNNING&#xA;WAITING             # 等待唤醒，忙等待(一直占CPU)&#xA;    o.wait()&#xA;    t.join()&#xA;    LockSupport.park()&#xA;    Lock.lock()&#xA;&#xA;    o.notify()&#xA;    o.notifyAll()&#xA;    LockSupport.unpark()&#xA;    Lock.unlock()&#xA;TIMED WAITING&#xA;    Thread.sleep(time)&#xA;    o.wait(time)&#xA;    t.join(time)&#xA;    LockSupport.parkNanos()&#xA;    LockSupport.parkUntil()&#xA;BLOCKING            # 阻塞等待（不占CPU但经过OS调度)&#xA;    synchronized&#xA;TERMINATED&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程打断&#34;&gt;&#xA;  线程打断&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%89%93%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法 &#xA;    interrupt()                 # 设置打断标记位&#xA;    isInterrupted()             # 检查标记位&#xA;    static interrupted()        # 检查当前线程标记位，并重置&#xA;检测当前线程打断标记的方法      # 抛异常并重置&#xA;    Thread.sleep()&#xA;    o.wait();&#xA;    o.join();&#xA;    ReentrantLock&#xA;        lockInterruptibly()&#xA;不检测当前线程打断标记的方法&#xA;    synchronized                # 不是代码实现检测不了&#xA;    ReentrantLock&#xA;        lock()&#xA;强制打断&#xA;    Thread&#xA;        stop()                  # 已废弃, 立即释放所有锁&#xA;        suspend()               # 已废弃，强制暂停，所有锁不释放容易死锁&#xA;        resume()                # 已废弃，强制恢复&#xA;volatile&#xA;    判断数字不准，有同步的时间延迟, interrupt()也有延迟&#xA;    也需要代码中判断, 但interrupt()有wait()等系统方法支持&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;线程间通信&#34;&gt;&#xA;  线程间通信&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;通知&#34;&gt;&#xA;  通知&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%9a%e7%9f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# synchronized wait() notify(), CountDownLatch, LockSupport&#xA;volatile List c = new ArrayList();&#xA;final Object lock = new Object();&#xA;new Thread(() -&amp;gt; {&#xA;    synchronized(lock) {&#xA;        if (c.size() != 5) {&#xA;            lock.wait();&#xA;        }&#xA;        lock.notify();              // 唤醒t1&#xA;    }&#xA;}, &amp;quot;t2&amp;quot;).start();&#xA;&#xA;TimeUnit.SECONDS.sleep(1);&#xA;&#xA;new Thread(() -&amp;gt; {&#xA;    synchronized(lock) {&#xA;        for (int i = 0; i &amp;lt; 10; i++) {&#xA;            c.add(new Object());&#xA;            if (c.size() == 5) {&#xA;                lock.notify();&#xA;                lock.wait();        // 让出sychronized锁&#xA;            }&#xA;        }&#xA;    }&#xA;}, &amp;quot;t1&amp;quot;).start();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;生产消费&#34;&gt;&#xA;  生产消费&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e4%ba%a7%e6%b6%88%e8%b4%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 优化count可以用CAS加(有ABA问题)&#xA;class MyContainer&amp;lt;T&amp;gt; {&#xA;    final private List&amp;lt;T&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&#xA;    final private int MAX = 10;&#xA;    private int count = 0;&#xA;&#xA;    public synchronized void put(T t) {&#xA;        while(list.size() == MAX) {&#xA;            this.wait();            // 期间可能有add() &#xA;        }&#xA;        list.add(t);&#xA;        count++;&#xA;        this.notifyAll();           // 应该只唤醒消费者&#xA;    }&#xA;&#xA;    public synchronized T get() {&#xA;        T t = null;&#xA;        while(list.size() == 0) {&#xA;            this.wait();&#xA;        }&#xA;        t = list.removeFirst();&#xA;        count--;&#xA;        this.notifyAll();           // 应该只唤醒生产者&#xA;        return t;&#xA;    }&#xA;}&#xA;&#xA;# 同步容器, ReentrantLock Condition&#xA;private Lock lock = new ReentrantLock();&#xA;private Condition producer = lock.newCondition();&#xA;private Condition consumer = lock.newCondition();&#xA;&#xA;public void put(T t) {&#xA;    try {&#xA;        lock.lock();&#xA;        while(list.size() == MAX) {&#xA;            producer.await();&#xA;        }&#xA;        list.add(t);&#xA;        count++;&#xA;        consumer.signalAll();&#xA;    } finally {&#xA;        lock.unlock();&#xA;    }&#xA;}&#xA;&#xA;public T get() {&#xA;    T t = null;&#xA;    try {&#xA;        lock.lock();&#xA;        while(list.size() == 0) {&#xA;            consumer.await();&#xA;        }&#xA;        t = list.removeFirst();&#xA;        count--;&#xA;        producer.signalAll();&#xA;    } finally {&#xA;        lock.unlock();&#xA;    }&#xA;    return t;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;协程&#34;&gt;&#xA;  协程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%8f%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;quasar库                            # 需要设javaagent, 每个fiber生成栈&#xA;    fiber =  new Fiber&amp;lt;Void&amp;gt;()&#xA;    fiber.start()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发api&#34;&gt;&#xA;  并发API&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;stream&#34;&gt;&#xA;  Stream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;parallelStream()                    # ForkJoinPool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;threadlocal&#34;&gt;&#xA;  ThreadLocal&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;内部类&#xA;    ThreadLocalMap&amp;lt;ThreadLocal, Object&amp;gt;&#xA;        # 存在每个线程里。场景如声明式事务拿conn&#xA;        # key是弱引用指向ThreadLocal, value是强引用。&#xA;    Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {&#xA;        Object value;&#xA;        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&#xA;            super(k);&#xA;            value = v;&#xA;        }&#xA;    }&#xA;方法&#xA;    set(T)&#xA;内存泄露问题&#xA;    ThreadLocal&amp;lt;M&amp;gt; tl = new ThreadLocal();&#xA;    tl.set(new M());&#xA;    tl = null;&#xA;        # threadLocalMap中key弱引用回收, value不回收&#xA;    tl.remove();&#xA;        # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pipedstream&#34;&gt;&#xA;  PipedStream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pipedstream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 效率不高&#xA;PipedInputStream&#xA;    connect(PipedOutputStream)&#xA;    read(byte[])&#xA;PipedOutputStream&#xA;    write(byte[])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;jmh&#34;&gt;&#xA;  JMH&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmh&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Java Microbenchmark Harness&#xA;概念&#xA;    Warmup                              # 预热&#xA;    Mesurement                          # 总执行次数&#xA;    Timeout                             # 每次执行超时时间&#xA;    Threads                             # fork线程数&#xA;    Benchmark mode                      # 模式&#xA;    Benchmark                           # 方法名&#xA;环境变量&#xA;    TEMP或TMP                           # JHM临时文件存放&#xA;使用&#xA;    @Benchmark&#xA;    @Warmup(iterations = 2, time = 3)           # 执行2次, 每次隔3秒&#xA;    @Fork(5)                                    # 多少线程&#xA;    @BenchmarkMode(Mode.Throughput)             # 显示每秒多少次&#xA;    @Measurement(iterations = 10, time = 3)     # 共测10次, 每次隔3秒&#xA;    public void testA() {&#xA;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;disruptor&#34;&gt;&#xA;  Disruptor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#disruptor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    CAS, 环形数组Buffer&#xA;        数组用sequence定位修改快,也避免了头尾加锁&#xA;        直接覆盖降低GC&#xA;            覆盖前有等待策略&#xA;    单机MQ&#xA;        发布订阅模式&#xA;        观察者模式&#xA;    EventFactory&#xA;        会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC&#xA;使用&#xA;    class MyEvent {}&#xA;    class MyEventFactory implements EventFactory&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        public MyEvent newInstance() {}&#xA;    }&#xA;    class MyEventHandler implements EventHandler&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        void onEvent(MyEvent, long sequence, boolean endOfBatch) {}&#xA;    }&#xA;    class MyExceptionHandler implements ExceptionHandler&amp;lt;MyEvent&amp;gt; {&#xA;        @Override&#xA;        void handleEventException()&#xA;        @Override&#xA;        void handleOnStartException()&#xA;        @Override&#xA;        void handleOnShutdownException()&#xA;    }&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(factory, 1024, Executors,defaultThreadFactory())&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(MyEvent::new, 1024, Executors,defaultThreadFactory())&#xA;    disruptor = new Disruptor&amp;lt;&amp;gt;(factory, 1024, Executors,defaultThreadFactory(), &#xA;        ProducerType.SINGLE, new BlockingWaitStrategy())&#xA;        # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁&#xA;    // 消费&#xA;    disruptor.handleEventsWith(handler1, handler2)&#xA;    disruptor.handleEventsWith((event,seq,end)-&amp;gt;{})&#xA;    disruptor.handleExceptionsFor(handler1).with(excptionHandler1)&#xA;&#xA;    disruptor.start()&#xA;&#xA;    // 生产&#xA;    ringBuffer = disruptor.getRingBuffer()&#xA;    sequence = ringBuffer.next()&#xA;    event = ringBuffer.get(sequence)&#xA;    event.set(&amp;quot;&amp;quot;)&#xA;    ringBuffer.publish(sequence)&#xA;    translator = new EventTranslator&amp;lt;&amp;gt;() {&#xA;        @Override&#xA;        void translateTo(event, sequence) {&#xA;            event.set(&amp;quot;&amp;quot;)&#xA;        }&#xA;    }&#xA;    ringBuffer.publishEvent(translator)&#xA;    ringBuffer.publishEvent((event,seq, &amp;quot;&amp;quot;) -&amp;gt; event.set(l), &amp;quot;&amp;quot;)&#xA;等待策略&#xA;    BlockingWaitStrategy                # 阻塞直到再次唤醒&#xA;    BusySpinWaitStrategy                # 自旋等待&#xA;    SleepingWaitStrategy                # sleep等待&#xA;    LiteBlockingWaitStrategy            # 同BlockingWaitStrategy减少加锁次数                &#xA;    LiteTimeoutBlockingWaitStrategy     # 同LiteBlockingWaitStrategy加超时            &#xA;    PhasedBackoffWaitStrategy&#xA;    TimeoutBlockingWaitStrategy         # 同BlockingWaitStrategy加超时                &#xA;    YieldingWaitStrategy                # 尝试100然后Thread.yield()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;源码分析&#34;&gt;&#xA;  源码分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;threadpoolexecutor&#34;&gt;&#xA;  ThreadPoolExecutor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadpoolexecutor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;new ThreadPoolExecutor()                    &#xA;    int corePoolSize                    # 核心线程数, 永远存活。可设置参与回收&#xA;    int maximumPoolSize                 # 最大线程数&#xA;    long keepAliveTime                  # 生存时间&#xA;    TimeUnit&#xA;    BlockingQueue&amp;lt;Runnable&amp;gt;             # 任务队列&#xA;    ThreadFactory                       # 线程工厂, 设线程名&#xA;    RejectedExecutionHandler            # 拒绝策略&#xA;        Abort                           # 抛异常&#xA;        Discard                         # 忽略掉&#xA;        DiscardOldest                   # 忽略掉排除最久的&#xA;        CallerRuns                      # 调用者线程执行, 再多就阻塞&#xA;AtomicInteger ctl&#xA;    # 高3位线程池状态，低29位线程数量&#xA;void execute()&#xA;    判断添加核心线程&#xA;    放入队列成功&#xA;        拒绝或添加非核心线程&#xA;    添加非核心线程失败&#xA;        拒绝&#xA;boolean addWorker(Runable, boolean)&#xA;    线程数量加1&#xA;    添加Worker&#xA;        加锁&#xA;        加线程&#xA;        启动&#xA;class Worker extends AbstractQueuedSynchronizer implements Runnable&#xA;    # 本身是AQS锁, 被多任务(线程)访问&#xA;    Tread thread&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;forkjoinpool&#34;&gt;&#xA;  ForkJoinPool&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#forkjoinpool&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;abstract class ForkJoinTask&#xA;    ForkJoinTask&amp;lt;V&amp;gt; fork()&#xA;    V join()&#xA;    abstract class RecursiveAction          # 无返回值&#xA;        void compute()&#xA;    abstract class RecursiveTask            # 有返回值&#xA;例子&#xA;    class MyTask extends RecursiveTask&amp;lt;Long&amp;gt; {&#xA;        int start;&#xA;        int end;&#xA;        @Override&#xA;        Long compute() {&#xA;            if (end - start &amp;lt;= MAX_NUM) {&#xA;                return sum&#xA;            }&#xA;            subTask1 = new MyTask(start, mid)&#xA;            subTask2 = new MyTask(mid, end)&#xA;            subTask1.fork()&#xA;            subTask2.fork()&#xA;            return subTask1.join() + subTask2.join();&#xA;        }&#xA;    }&#xA;    fjp = new ForkJoinPool()&#xA;    task = new MyTask(0, nums.length)&#xA;    fjp .execute(task)&#xA;    result = task.join()&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>JVM</title>
      <link>https://runout.run/docs/pl/java/jvm/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:07 +0800</pubDate>
      <guid>https://runout.run/docs/pl/java/jvm/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;定义&#xA;    JVM规范说明书, JVMS(Java Virtual Machine Specifications)&#xA;    Java语言规范, JLS(Java Language Specification)&#xA;    虚拟机&#xA;        指令集&#xA;        内存管理&#xA;过程&#xA;    x.java -&amp;gt; javac -&amp;gt; x.class -&amp;gt; ClassLoader -&amp;gt; (字节码解释器、JIT) -&amp;gt; 执行引擎&#xA;JVM语言&#xA;    Scala, Kotlin, Groovy, Clojure, jython, jruby等100多个&#xA;JVM实现&#xA;    HotSpot                 # Oracle官方, 8之后收费, OpenJDK为开源版本&#xA;    Jrockit                 # Oracle收购, 合并入HotSpot&#xA;    J9                      # IBM&#xA;    Microsoft VM&#xA;    TaobaoVM                # HotSpot深度定制&#xA;    LiquidVM                # 直接匹配专门硬件&#xA;    azul zing               # 收费，快, GC1mm, HotSpot参考写的G1&#xA;JRE, JDK&#xA;    JRE = jvm + core lib&#xA;    JDK = JRE + development kit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jvm构造&#34;&gt;&#xA;  JVM构造&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm%e6%9e%84%e9%80%a0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;指标&#34;&gt;&#xA;  指标&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e6%a0%87&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;吞吐量: 代码时间 / (代码时间 + GC时间)&#xA;响应时间: STW越短, 响应时间越好&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;指令instructions&#34;&gt;&#xA;  指令(Instructions)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%87%e4%bb%a4instructions&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;分类&#xA;    基于栈的指令类          # 简单, HotSpot&#xA;    基于寄存器的指令集      # 复杂但快, HotSpot局部变量表&#xA;8大原子操作(JSR-133已放弃这个描述，但指令没变化)&#xA;    lock                    # 主内存，标识变量线程独占&#xA;    unlock                  # 主内存，解锁独占&#xA;    read                    # 主内存，读到工作内存&#xA;    load                    # 工作内存，read后的值放入线程本地变量副本&#xA;    use                     # 工作内存，传值给执行引擎&#xA;    assign                  # 工作内存，执行引擎结果赋值给线程本地变量 &#xA;    store                   # 工作内存，存值到主内存给write备用&#xA;    write                   # 主内存，写变量值&#xA;方法指令                    # 在methods的Code中罗列&#xA;    aload_0                 # 变量表第0项入栈&#xA;    invokespecial #1        # 调private(无多态)的方法&#xA;    invokevirtual           # 调有多态可能性的方法&#xA;    invokestatic            # 调静态方法&#xA;    invokeinterface         # 调interface方法&#xA;    invokedynamic           # 1.7加入，定义类似函数指针时生成(但每个函数都创建了类)&#xA;        调用动态产生的类&#xA;            lambda&#xA;            反射&#xA;            scala等JVM语言&#xA;            CGLib ASM&#xA;        组成&#xA;            bootstrapMethod&#xA;            方法签名&#xA;        &amp;lt;1.8的bug           # 类产生于Perm Space，内存不回收&#xA;            for(;;) {I j = C::n;}&#xA;    return                  # 方法返回&#xA;    bipush 8                # byte扩展成int类型，放到方法栈中&#xA;    sipush 200              # short&#xA;    istore_1                # 出栈，放到下标为1的局部变量表&#xA;    iload_1                 # 局部变量表下标1位置值压栈&#xA;    iinc 1 by 1             # 局部变量表1位置值+1&#xA;    iadd                    # 出栈两个，相加压栈&#xA;    new                     # new对象, 地址压栈&#xA;    dup                     # 复制栈顶并压栈&#xA;    pop                     # 弹出栈顶&#xA;    if_icmpne 7             # int值比较，不等时跳到第7条指令&#xA;    mul                     # 乘法&#xA;    sub                     # 减法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;class结构&#34;&gt;&#xA;  class结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#class%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;javap -v a.class&#xA;jetbrain jclasslib&#xA;jetbrain BinEd&#xA;JBE                         # 可编辑&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;二进制&#34;&gt;&#xA;  二进制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Magic Number(4字节)&#xA;    cafe babe&#xA;Minor Version(2字节)        # 小版本&#xA;Major Version(2字节)        # 大版本&#xA;    JDK1.7是51.0&#xA;    JDK1.8是52.0&#xA;constant_pool_count(2字节)&#xA;    # 长度constant_pool_count-1的表&#xA;constant_pool               # 索引、tag、类型&#xA;    1 CONSTANT_Utf8_info                        # 存一些描述字符串&#xA;    2 标记&#xA;    3 CONSTANT_Integer_info&#xA;    4 CONSTANT_Float_info&#xA;    5 CONSTANT_Long_info&#xA;    6 CONSTANT_Double_info&#xA;    7 CONSTANT_Class_info&#xA;    8 CONSTANT_String_info&#xA;    9 CONSTANT_Fieldref_info                &#xA;    10 CONSTANT_Methodref_info                  # 方法引用&#xA;        指向CONSTANT_Class_info&#xA;        指向CONSTANT_NameAndType_info&#xA;    11 CONSTANT_InterfaceMethodref_info&#xA;    12 CONSTANT_NameAndType_info                # 方法名与类型&#xA;    15 CONSTANT_MethodHandle_info&#xA;    16 CONSTANT_MethodType_info&#xA;    18 CONSTANT_InvokeDynamic_info&#xA;access_flags(2字节)         # bitmap按位与组合&#xA;    # class的修饰符&#xA;    ACC_PUBLIC 0x0001 public&#xA;    ACC_FINAL 0x0010 final&#xA;    ACC_SUPER 0x0020 JDK1.0.2之后必须为真, 表示invokespectial用新语义&#xA;    ACC_INTERFACE 0x0200 是否接口&#xA;    ACC_ABSTRACT 0x0400 抽象类&#xA;    ACC_SYNTHETIC 0x1000 编译器自动生成&#xA;    ACC_ANNOTATION 0x2000 &#xA;    ACC_ENUM 0x2000 &#xA;this_class(2字节)&#xA;    存名字对应指向常量池序号&#xA;super_class(2字节)&#xA;    存名字对应指向常量池序号&#xA;interfaces_count(2字节)&#xA;interfaces&#xA;fields_count(2字节)&#xA;fields&#xA;    access_flags(2字节)&#xA;    name_index              # 存常量池索引&#xA;    descriptor_index&#xA;        byte B&#xA;        char C&#xA;        double D&#xA;        float F&#xA;        int I&#xA;        long L&#xA;        short S&#xA;        boolean Z&#xA;        void V&#xA;        Object Ljava/lang/Object&#xA;        数组&#xA;            一维数组 [B&#xA;            多维数组 [[C&#xA;    attributes_count        # 赋加属性&#xA;    attributes&#xA;methods_count(2字节)&#xA;methods&#xA;    access_flags(2字节)&#xA;    name_index&#xA;    descriptor_index        # 先参数列表，后返回值&#xA;        void m() -&amp;gt; ()V&#xA;        String toString() -&amp;gt; Ljava/lang/String;&#xA;    attributes_count&#xA;    attributes              # 赋加属性&#xA;        Code                # 指令列表, 一般先压栈this(aload_0)&#xA;            LineNumberTable&#xA;            LocalVariableTable&#xA;attributes_count(2字节)&#xA;attributes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;agent&#34;&gt;&#xA;  Agent&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#agent&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;例子&#xA;    打包 a.jar&#xA;        MANIFEST.MF&#xA;            Premain_Class: MyAgent&#xA;        public class MyAgent {&#xA;            public static Instrumentation inst;&#xA;            public static void premain(String agentArgs, Instrumentation _inst) {&#xA;                inst = _inst;&#xA;            } &#xA;        }&#xA;    JVM参数 -javaagent: a.jar&#xA;    使用 MyAgent.inst&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;jmmjava-memory-model&#34;&gt;&#xA;  JMM(Java Memory Model)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jmmjava-memory-model&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;内存&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;运行时区域&#34;&gt;&#xA;  运行时区域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8c%ba%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Runtime data areas&#xA;分类&#xA;    Program Counter             # 程序计数器，下一条指令位置&#xA;    Method Area                 # 方法区,线程间共享&#xA;        存储&#xA;            Class元信息&#xA;            代码编译信息, JIT编译信息&#xA;            常量池(Runtime Constant Pool)           # 常量池在运行时存放区&#xA;        版本区别&#xA;            Perm Space(&amp;lt;1.8)    # 要设定大小, 会溢出报错&#xA;                存字符串常量&#xA;                lambda生成临时类永远存在&#xA;                Full GC不清理&#xA;            Meta Space(&amp;gt;=1.8)   # 自动大小无上限&#xA;                字符串常量位于堆&#xA;                会触发Full GC&#xA;    JVM stacks                  # 线程栈 &#xA;        Frame(栈帧)             # 一个方法一个栈帧&#xA;            Local Variable Table                # 局部变量表, 方法内的局部变量，值在常量池&#xA;                默认第0个为this&#xA;            Operand Stack                       # 操作数栈&#xA;            Dynamic Linking                     # 指向调用方法的 运行时常量池的符号连接&#xA;            return address                      # 当前方法执行完的返回地址&#xA;    Native Method Stacks        # C/C++方法栈&#xA;    Direct Memory               # 直接内存&#xA;    Heap                        # 堆, 线程间共享&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;屏障&#34;&gt;&#xA;  屏障&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%8f%e9%9a%9c&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;CPU屏障&#xA;JVM规范&#xA;    LoadLoad                # 上load和下load不能重排&#xA;    StoreStore&#xA;    LoadStore&#xA;    StoreLoad               # 最强&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;对象内存存储&#34;&gt;&#xA;  对象内存存储&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%86%85%e5%ad%98%e5%ad%98%e5%82%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;普通对象&#xA;    对象头: markword 8字节&#xA;    ClassPointer            # 指向Class对象, 启用压缩4字节，不启用8字节&#xA;    实例数据&#xA;        引用类型            # 启用压缩4字节，不启用8字节&#xA;    Padding: 对齐8的倍数&#xA;数组对象&#xA;    对象头&#xA;    ClassPointer&#xA;    数组长度4字节&#xA;    数组数据&#xA;    Padding&#xA;对象头&#xA;    # 32位64位(25位没用到)，内容不同&#xA;    锁标志位2位             # 根据锁标志位判断存储内容&#xA;        01 无锁/偏向锁&#xA;        00 轻量级锁&#xA;        10 重量级锁&#xA;        11 GC标记&#xA;    是否偏向锁1位&#xA;    剩余位 &#xA;        无锁状态&#xA;            对象hashCode(25位或31位)&#xA;                没重写过时默认计算(System.identityHashCode())&#xA;                重写过的hashCode()结果不存在这里&#xA;            分代年龄&#xA;        轻量级锁&#xA;            指向栈中锁记录的指针&#xA;        重量级锁&#xA;            指向互斥量（重量级锁）的指针&#xA;        偏向锁&#xA;            线程ID 23位&#xA;            Epoch 2位&#xA;            分代年龄4位(所以分代年龄只有15)&#xA;    其它问题&#xA;        对象计算过hashCode，对象不能进入偏向锁状态(位已经被占了)&#xA;实验工具 javaagent&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;对象定位&#34;&gt;&#xA;  对象定位&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%ae%9a%e4%bd%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;句柄池                      # 指向句柄，句柄有对象指针和class指针, 三色标记GC提高效率&#xA;直接指针                    # 指向对象，对象指class, HotSpot使用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;并发&#34;&gt;&#xA;  并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;硬件层数据一致性&#34;&gt;&#xA;  硬件层数据一致性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%a1%ac%e4%bb%b6%e5%b1%82%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;硬件结构&#xA;    L0寄存器                # 1 cycles&#xA;    L1高速缓存              # 3-4 cycles, 1ns&#xA;    L2高速缓存              # 10 cycles, 3ns&#xA;    L3高速缓存              # 40-45 cycles, 15ns, 在主板&#xA;    (QPI总线传输)           # 20ns&#xA;    L4主存                  # 60-80ns&#xA;    L5磁盘&#xA;    L6远程文件存储&#xA;数据不一致                  # 从L2多CPU开始&#xA;    锁总线(bus lock)&#xA;    CPU缓存一致性协议(如intel MESI)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;volatile&#34;&gt;&#xA;  volatile&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#volatile&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;工具&#xA;    hsdis                   # HotSpot Dis Assembler, 虚拟机字节码对应汇编&#xA;bytecode&#xA;    ACC_VOLATILE&#xA;JVM&#xA;    StoreStoreBarrier&#xA;    volatile写操作          # 上边写完再写，写完下边再读，写一致&#xA;    StoreLoadBarrier&#xA;&#xA;    LoadLoadBarrier&#xA;    volatile读操作          # 上边读完再读，读完下边再写，读一致&#xA;    LoadStoreBarrier&#xA;OS&#xA;    windows&#xA;        lock&#xA;    linux&#xA;        上下屏障，最后lock&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;synchronized&#34;&gt;&#xA;  synchronized&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;bytecode&#xA;    方法修饰&#xA;        synchronized&#xA;    代码&#xA;        monitorenter&#xA;        monitorexit&#xA;JVM&#xA;    C/C++实现，会调用OS的同步机制&#xA;OS&#xA;    lock&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;happens-before原则&#34;&gt;&#xA;  happens-before原则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#happens-before%e5%8e%9f%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Java要求指令不能重排的几种情况&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;as-if-serial&#34;&gt;&#xA;  as if serial&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#as-if-serial&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 不管如何重排序，单线程执行结果不变&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;过程&#34;&gt;&#xA;  过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;编译&#34;&gt;&#xA;  编译&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%af%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;过程&#xA;    代码 -&amp;gt; bytecode -&amp;gt; JVM指令 -&amp;gt; OS指令&#xA;解释器(bytecode intepreter)&#xA;JIT(Just In-Time compiler)&#xA;混合模式&#xA;    解释器 + 热点代码编译&#xA;    热点代码检测&#xA;        方法计数器&#xA;        循环计数器&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;加载&#34;&gt;&#xA;  加载&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a0%e8%bd%bd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;HotSpot C++代码加载&#xA;    class对象加载到MethodArea&#xA;        metaspace(JDK1.8)&#xA;        permGeneration(JDK1.8之前)&#xA;class加载过程&#xA;    loading                 # 读到内存&#xA;    linking&#xA;        verification        # 校验&#xA;        preparation         # 静态变量赋默认值&#xA;        resolution          # 解析, loadClass()可指定是否解析。常量池的符号引用转换成内存地址引用&#xA;    initializing            # 静态变量赋初始值，执行静态代码&#xA;对象加载&#xA;    new过程&#xA;        class加载&#xA;        申请对象内存&#xA;        成员变量赋默认值&#xA;        调用构造方法&amp;lt;init&amp;gt;&#xA;            成员变量顺序赋初始值&#xA;            执行构造方法语句(先super)&#xA;双亲委派                &#xA;    过程&#xA;        类名一层层向上找&#xA;        找不到时，一层层找再向下委派找&#xA;        都不能加载时, 抛ClassNotFound&#xA;    为什么&#xA;        安全, 自定义类不能覆盖&#xA;        已加载不用重复加载&#xA;    父加载器&#xA;        不是类加载器的加载器&#xA;        不是父类&#xA;        是组合的parent对象&#xA;    打破&#xA;        为什么                    &#xA;            JDK1.2之前都重写loadClass()&#xA;            thread.setContextClassLoader()指定线程上下文classLoader&#xA;            热启动/热部署(OSGi tomcat)加载同一类不同版本&#xA;        做法&#xA;            重写loadClass(), new多个ClassLoader&#xA;类加载器&#xA;    Bootstrap               # 加载核心类 lib/rt.jar charset.jar等, C++实现所以get时为null&#xA;        如加载String&#xA;    Extension               # 加载扩展jar jre/lib/ext/*.jar, 由-Djava.ext.dirs指定&#xA;    App                     # 加载classpatch指定内容&#xA;    Custom ClassLoader      # 自定义ClassLoader&#xA;加载路径环境变量            # 来自Launcher源码&#xA;    Bootstrap.ClassLoader   sun.boot.class.path&#xA;    ExtensionClassLoader    java.ext.dirs&#xA;    AppClassLoader          java.class.path&#xA;API&#xA;    Class&#xA;        getClassLoader()&#xA;    ClassLoader             # findInCache() -&amp;gt; parent.loadClass() -&amp;gt; findClass()&#xA;        private final ClassLoader parent&#xA;        loadClass           # 热加载&#xA;    Launcher&#xA;        $AppClassLoader&#xA;        $ExtClassLoader&#xA;自定义类加载器&#xA;    class MyClassLoader extends ClassLoader {&#xA;        @Override&#xA;        Class findClass(String) {&#xA;            return defineClass()&#xA;        }&#xA;    }&#xA;懒加载                      # JVM未规定什么时候加载,但规定了什么时候初始化&#xA;初始化&#xA;    new getstatic putstatic invokestatic指令，访问final变量除外&#xA;    java.lang.reflect对类进行反射调用&#xA;    初始化子类时，父类首先初始化&#xA;    虚拟机启动时，被执行的主类&#xA;    动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic, REF_putstatic, REF_invokestatic的方法句柄时, 该类初始化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gc&#34;&gt;&#xA;  GC&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引用方式强软弱虚&#34;&gt;&#xA;  引用方式(强软弱虚)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e7%94%a8%e6%96%b9%e5%bc%8f%e5%bc%ba%e8%bd%af%e5%bc%b1%e8%99%9a&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;软引用&#xA;    # 内存不够用时回收，用做缓存&#xA;    # -Xms20M -Xmx20M&#xA;    SoftReference&amp;lt;byte[]&amp;gt; m = new SoftReference&amp;lt;&amp;gt;(new byte[1024*1024*10]);&#xA;    System.gc();&#xA;    m.get();&#xA;    new byte[1024*1024*15]&#xA;    m.get();&#xA;弱引用&#xA;    # 只要gc就回收，用做容器如WeakHashMap(key是弱引用), ThreadLocalMap的key&#xA;    WeakReference&amp;lt;M&amp;gt; m = new WeakReference&amp;lt;&amp;gt;(new M());&#xA;    System.gc();&#xA;    m.get();&#xA;虚引用&#xA;    # 值被回收时放入队列来通知, 用来触发回收堆外内存(用Unsafe的freeMemory())&#xA;    # 如NIO的直接内存DirectByteBuffer&#xA;    PhantomReference&amp;lt;M&amp;gt; r = new PhantomReference&amp;lt;&amp;gt;(new M(), QUEUE);&#xA;    r.get() // 自己写永远返回null                     &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;对象分配过程&#34;&gt;&#xA;  对象分配过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;向栈分配                # 不要调参数&#xA;    好处&#xA;        不必GC&#xA;    条件&#xA;        线程私有小对象&#xA;        无逃逸&#xA;        可标量替换(基本类型替换整个对象)&#xA;过大，分配到老年代&#xA;线程本地分配            # TLAB(Thread Local Allocation Buffer), 不要调参数&#xA;    好处&#xA;        为了减少线程争用&#xA;    条件&#xA;        小对象&#xA;        占用eden, 默认每个线程占1%&#xA;伊甸区&#xA;s1,s2&#xA;    次数                   # 最大15(对象头上空间决定)&#xA;        Parallel Scavenge 15&#xA;        CMS 6&#xA;        G1 15&#xA;    动态年龄&#xA;        eden + s1 复制到s2, 超过s2总内存一半时，年龄最大的对象进入老年代&#xA;    分配担保&#xA;        YGC时survivor区空间不够, 直接进入老年代&#xA;GC清除或到老年代&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;gc分代过程&#34;&gt;&#xA;  GC分代过程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gc%e5%88%86%e4%bb%a3%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;YGC -&amp;gt; s0&#xA;YGC, eden + s0 -&amp;gt; s1&#xA;    年龄足够 -&amp;gt; old&#xA;    s区装不下 -&amp;gt; old&#xA;YGC, eden + s1 -&amp;gt; s0&#xA;old满了 -&amp;gt; FGC&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;常见的回收器&#34;&gt;&#xA;  常见的回收器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%9b%9e%e6%94%b6%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    Safe Point              # STW时机&#xA;    没有无STW的回收器&#xA;分代&#xA;    Young&#xA;        Serial              # 第一个GC&#xA;            STW, 单线程串行回收&#xA;        Parallel Scavenge&#xA;            STW, 并行回收&#xA;        ParNew              # Parallel New&#xA;            增强PS, 以配合CMS并行回收, CMS到某阶段时PN运行&#xA;    Old&#xA;        Serial Old&#xA;            特点&#xA;                适用几十M&#xA;                mark-sweep-compact，单线程&#xA;        Parallel Old&#xA;            特点&#xA;                适用几个G&#xA;                mark-sweep-compact，多线程&#xA;        CMS                 # concurrent mark sweep, 1.4后期引入, JDK11取消&#xA;            特点&#xA;                适用20G&#xA;                多线程并行回收, 并发回收(GC与程序同时运行)，降低STW时间(200ms)&#xA;            不足            # 问题多，没有版本默认CMS&#xA;                浮动垃圾&#xA;                碎片多，新对象分配不下时，使用SerialOld&#xA;                    设低GC阈值回收浮动垃圾&#xA;            清理过程&#xA;                初始标记(initial mark)&#xA;                    STW, 单线程, 标记根对象&#xA;                [预标记]                        # Card Marking, 把Card标为Dirty&#xA;                并发标记(concurrent mark)&#xA;                    不STW, 多线程, 执行多次&#xA;                重新标记(remark)                # 处理并发标记过程中的变化&#xA;                    STW, 多线程, &#xA;                并发清理(concurrent sweep)      # 过程中产生的浮动垃圾, 下次回收&#xA;                    不STW, 多线程, &#xA;                [整理阶段]&#xA;            日志&#xA;                [GC(Allocation Failure)[ParNew:6144K-&amp;gt;640K(6144K)], 0.02 secs] 6585K-&amp;gt;2770K(19840K),0.02 secs][Times:user=0.02 sys=0.00, real=0.02 secs]&#xA;                    6144K-&amp;gt;640K(6144K): 回收前 回收后 总容量&#xA;                    6585K-&amp;gt;2770K(19840K): 堆回收前 回收后 总大小  &#xA;&#xA;                [GC (CMS Initial Mark)]&#xA;                    [1 CMS-initail-mark]&#xA;                [CMS-concurrent-mark-start]&#xA;                [CMS-concurrent-preclean-start]&#xA;                [GC (CMS Final Remark)]&#xA;                    [YG occupancy]              # 清理后年轻代占用及容量&#xA;                    [Rescan(parallel)]          # STW下标记存活对象&#xA;                    [weak refs processing]      # 弱引用处理&#xA;                    [class unloading]           # 卸载用不到的class&#xA;                    [scrub symbol table]        # 清理常量池&#xA;                    [scrub string table]        # 清理常量池&#xA;                    [1 CMS-remark]              # 清理后老年代占用及容量&#xA;                [CMS-concurrent-sweep-start]&#xA;                [CMS-concurrent-reset-start]&#xA;&#xA;不分代&#xA;    G1                      # Garbage First, 1.7引入, 1.8完善, 1.9默认&#xA;        特点&#xA;            适用上百G&#xA;            STW 10ms回收&#xA;                容易预测STW时间&#xA;                低latency, 但throughput也低&#xA;            并发回收, 三色标记&#xA;            只逻辑分代, 不物理分代 &#xA;                内存分Region, Region组成不同大小块，块在逻辑分代中&#xA;                Eden和Old区的内存映射会变化&#xA;            动态新老代空间                      # 如果YGC频繁，就Young调大&#xA;                不要手工指定, 是G1预测YGC停顿时间的基准, 停顿时间通过参数设置&#xA;        概念&#xA;            CSet            # Collection Set&#xA;                可回收Region集合, 回收时存活的对象被移动&#xA;                占堆空间不到1%&#xA;            RSet            # Remembered Set&#xA;                用于找到谁引用当前对象(对象级别), 记录其他Region的引用&#xA;                赋值时有GC写屏障                # 非内存屏障&#xA;            CardTable       # YGC定位垃圾，要从Root查所有Old区对象，效率低&#xA;                Old区对象引用Young区时, bitmap标DirtyCard。YGC时只扫描DirtyCard&#xA;            MixedGC         # 默认45%, 同CMS&#xA;                初始标记&#xA;                重新标记&#xA;                筛选回收    # 筛选Region回收，有用对象复制到其它Region&#xA;        日志&#xA;            [GC pause (G1 Evacuation Pause) (young) (initial-mark)]         # 复制存活对象, initial-mark在MixedGC时有&#xA;            [GC concurrent-root-region-scan-start]                          # 混合回收&#xA;            [GC concurrent-mark-start]                                      # 混合回收&#xA;            [Full GC (Allocation Failure)]                                  # 无法evacuation时, G1中很严重&#xA;    ZGC                     # JDK11, 不分代(SingleGeneration)&#xA;        特点&#xA;            STW设计10ms, 实际1ms&#xA;            适用4T（JDK13 16T）&#xA;            内存分块（有大有小）&#xA;        概念&#xA;            没有RSet, 改进了SATB指针&#xA;    Shenandoah              # JDK11&#xA;    Epsilon                 # JDK11, debug用&#xA;    Zulu&#xA;组合&#xA;    S + SO&#xA;    PS + PO                 # 1.8默认, 10G内存10+秒&#xA;    PN + CMS&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;算法&#34;&gt;&#xA;  算法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;定位&#xA;    引用计数(ReferenceCount)&#xA;        循环引用问题        # 内部互相引用，没有外部引用&#xA;    根可达算法(RootSearching)&#xA;        线程栈变量 &#xA;        静态变量&#xA;        常量池&#xA;        JNI指针             # 本地方法用到的对象&#xA;并发标记&#xA;    三色标记&#xA;        白                  # 未被标记&#xA;        灰                  # 自身被遍历到，成员变量未被遍历到&#xA;        黑                  # 自身、成员变量都被遍历到&#xA;        漏标问题 &#xA;            两个必要条件 &#xA;                黑引用白后，灰对白的引用断开&#xA;            算法&#xA;                incremental update                      # 增量更新，关注引用的增加, CMS用的&#xA;                    增加引用后，标记为灰, 重新标记阶段再扫描&#xA;                    缺点是灰色还要重新扫描&#xA;                SATB snapshot at the beginning          # 关注引用的删除, G1用的&#xA;                    开始时快照, 引用消失时，引用推到堆栈, 下次扫描还扫白色对象&#xA;                    优点是只扫描修改过的对象, 看RSet中有没有引用&#xA;    颜色指针                # 信息记在指针里&#xA;    租户隔离, Session Base GC           # Web专用, 基于session, session断开后删除&#xA;    各GC应用&#xA;        CMS&#xA;            三色标记 + Incremental Update&#xA;        G1&#xA;            三色标记 + SATB&#xA;        ZGC&#xA;            颜色指针 + 写屏障&#xA;        Shenandoah&#xA;            颜色指针 + 读屏障&#xA;清除&#xA;    标记清除(Mark-Sweep)    # 一遍标记，一遍清理, 适合老年代&#xA;        算法简单，戚对象多时效率高&#xA;        两遍扫描效率低，容易产生碎片&#xA;    拷贝(Copying)           # 存活对象copy到新内存, 旧内存直接清理，适合伊甸区(新生代)&#xA;        适用存活对象少的情况&#xA;        内存减半&#xA;    标记压缩(Mark-Compact)  # 有用的填到前边去空隙去, 适合老年代&#xA;        不会碎片，不会内存减半&#xA;        扫描两次，还要移动&#xA;分代模型&#xA;    分代模型                # -Xms -Xmx设置大小&#xA;        new/young(新生代)   # MinorGC/YGC, -Xmn设置大小, 默认占比1&#xA;            eden(伊甸)      # 默认占比8&#xA;            survivor x 2    # 默认每个占比1&#xA;        old(老年代)         # MajorGC/FullGC, 1.8默认占比2, 之前是3&#xA;            tenured(终身)&#xA;        methodArea          # 1.7永久代, 1.8元数据区&#xA;    各JVM的分代模型&#xA;        Epsilon ZGC Shenandoah不是分代模型&#xA;        G1是逻辑分代，物理不分代&#xA;        其他都是逻辑分代 + 物理分代&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;调优tuning&#34;&gt;&#xA;  调优(Tuning)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%b0%83%e4%bc%98tuning&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;前提&#xA;    从业务场景开始&#xA;    无监控(能压测), 不调优&#xA;目标&#xA;    减少FGC&#xA;    确定倾向                        # 吞吐量, 或响应时间&#xA;        吞吐量好: PS + PO&#xA;        响应时间好: G1 或 PN + CMS  # G1吞吐量少10%&#xA;组成部分&#xA;    JVM预规划&#xA;    优化JVM运行环境(慢、卡顿)&#xA;    解决JVM运行时出现的问题(OOM)&#xA;步骤&#xA;    熟悉业务场景&#xA;        响应时间&#xA;        吞吐量&#xA;    选择回收器组合&#xA;    计算内存需求(小的快，大的少gc)&#xA;    选CPU&#xA;    设定年代大小、升级年龄&#xA;    设定日志参数&#xA;    观察日志情况&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;问题分析&#34;&gt;&#xA;  问题分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工具-1&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;CPU经常100%&#xA;    top查进程CPU(top)&#xA;    进程中线程CPU(top -Hp)&#xA;    导出该线程堆栈(jstack)&#xA;    查哪个方法(栈帧)消耗时间(jstack)&#xA;内存高&#xA;    导出堆内存(jmap)&#xA;    分析(jhat jvisualvm mat jprofiler ...)&#xA;监控JVM&#xA;    jstat jvisualvm jprofiler arthas top ...&#xA;    网管: Ansible&#xA;流程&#xA;    网管报警&#xA;    top -Hp 进程号&#xA;    jstack 进程号               # 列出所有线程号, 线程状态&#xA;        WAITING, 一直等不到, BLOCKED, 拿不到锁&#xA;        waiting on &amp;lt;0x0000&amp;gt; (a java.lang.Object)    # 找到目标等待的线程&#xA;    jstack -l 16进制线程号      &#xA;    jps&#xA;    jinfo 进程号                # 列JVM信息&#xA;    jstat -gc 进程号 500        # 每500ms打印一次gc信息&#xA;    jmap -histo 进程号 | head -20                   # 列所有对象&#xA;        有性能消耗，但不很高，可以在线执行&#xA;    jmap -dump:format=b, file=x pid                 # 导出转储文件&#xA;        内存特别大时，jmap会卡顿&#xA;        多个服务器可用，停一个不影响&#xA;        设定HeapDumpOnOutOfMemoryError产生堆转储文件                 &#xA;        在线定位(中小型公司用不到)&#xA;    jhat -J-mx512M x.hprof      # 分析堆dump文件, 有OQL&#xA;    arthas                      # 在线定位&#xA;        启动&#xA;            java -jar arthas-boot.jar&#xA;        常用命令                # 没有集成jmap功能&#xA;            jvm                 # jinfo&#xA;            thread              # jstack&#xA;                thread 1&#xA;            dashboard           # top&#xA;            heapdump            # jmap -dump&#xA;            dump&#xA;            redefine            # 热替换&#xA;                目前只能改method实现，不能改方法名与属性&#xA;            jad                 # 反编译类&#xA;                看动态代理生成的类&#xA;                看第三方类&#xA;                看版本&#xA;            sc                  # search class, 显示class信息&#xA;            watch               # watch method&#xA;    MAT                         # 分析dump文件&#xA;    jprofiler&#xA;    jconsole                    # 需要JMX&#xA;        JMX会消耗性能生产服务器不开&#xA;        JMX图形界面只用于压测&#xA;    jvisualVM                   # 需要JMX, 可分析dump文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;内存-1&#34;&gt;&#xA;  内存&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e5%ad%98-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;现象&#xA;    OOM崩溃&#xA;    CPU飙高, 不断FGC&#xA;线程池不当运用&#xA;加内存反而卡顿&#xA;    GC, 应该用CMS或G1替换 PS+PO&#xA;JIRA不停FGC, 没定位出来&#xA;    扩内存到50G, GC换G1, 重启&#xA;tomcat server.max-http-header-size过大&#xA;    默认4096, 每个请求都分配&#xA;lambda表达式导致方法区溢出&#xA;    java.lang.OutofMemoryError: Compressed class space&#xA;disruptor不释放缓存&#xA;使用Unsafe分配内存, 直接内存溢出&#xA;-Xss设定小, 栈溢出&#xA;重写finalize()引发GC&#xA;    finalize()耗时长, GC时回收不过来，不停GC&#xA;内存不到10%，频繁FGC&#xA;    有人显式调用System.gc()                         # 不定时调，但会频繁调&#xA;大量线程, native thread OOM&#xA;    减少堆空间，留更多系统内存产生native thread&#xA;G1产生FGC&#xA;    降低MixedGC触发的阈值       # 默认45%&#xA;    扩内存&#xA;    提高CPU                     # 回收快&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hotspot参数&#34;&gt;&#xA;  HotSpot参数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hotspot%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;辅助&#xA;    -XX:+PrintCommandLineFlags -version             # 打印启动参数, -version是随便一个命令&#xA;    -XX:+PrintFlagsFinal -version                   # 打印所有XX参数&#xA;    -XX:+PrintFlagsInitial      # 打印默认参数&#xA;    -XX:+PrintVMOptions         # 显示VM启动参数&#xA;    -                           # 标准参数&#xA;    -X                          # 显示非标参数&#xA;    -XX                         # 显示不稳定参数&#xA;内存&#xA;    -XX:+HeapDumpOnOutOfMemoryError                 # OOM时产生堆转储文件 &#xA;    -Xms40M                     # 堆起始大小&#xA;    -Xmx60M                     # 堆最大大小, 最好和Xms一样以免堆弹大弹小&#xA;    -Xmn                        # 年经代&#xA;    -Xss                        # 栈空间&#xA;    -XX:InitialHeapSize         # 起始堆大小，自动算&#xA;    -XX:MaxHeapSize             # 堆最大大小，自动算&#xA;内存模型&#xA;    -XX:-DoEscapeAnalysis       # 去逃逸分析&#xA;    -XX:-EliminateAllocations   # 去标量替换&#xA;    -XX:-UseTLAB                # 去tlab&#xA;    -XX:TLABSize                # 设置TLAB大小&#xA;    -XX:+PrintTLAB&#xA;    -XX:MaxTenuringThreshold    # 进老年代（升代）回收次数, 最大值15， CMS默认6，其它默认15&#xA;对象和类&#xA;    -XX:+UseCompressedClassPointers                 # class指针压缩&#xA;        开启时4字节，不开启时8字节&#xA;    -XX:+UseCompressedOops                          # 引用类型指针压缩, Ordinary Object Pointers&#xA;        开启为4字节，不开启时8字节&#xA;    -verbose:class              # 类加载详细过程&#xA;    -XX:PreBlockSpin            # 锁自旋次数&#xA;编译&#xA;    -Xmixed                     # 混合模式&#xA;    -Xint                       # 解释模式&#xA;    -Xcomp                      # 编译模式&#xA;    -XX:CompileThreshold = 10000                    # 检测热点代码次数&#xA;GC&#xA;    -XX:+PrintGC                # 打印GC信息&#xA;    PrintGCDetails              # 打印GC更详细&#xA;    PrintGCTimeStamps           # 打印GC时间&#xA;    PrintGCCauses               # GC原因&#xA;    PrintHeapAtGC&#xA;    PrintGCApplicationConcurrentTime                # GC应用程序时间&#xA;    PrintCApplicationStoppedTime                    # 打印STW时长&#xA;    -XX:+PrintReferenceGC       # 打印回收多少种引用类型&#xA;    -XX:+UseConcMarkSweepGC     # 用CMS&#xA;    -XX:+DisableExplictGC       # System.gc()不管用&#xA;&#xA;    Parallel常用&#xA;        -XX:SurvivorRatio           # 新生代Eden区和Surivor区的比例&#xA;        -XX:PreTenureSizeThreshold  # 大对象到底多大&#xA;        -XX:+ParallelGCThreads      # 并发线程数, 默认是CPU数&#xA;        -XX:+UseAdaptiveSizePolicy  # 自动调所有区比例&#xA;    CMS常用&#xA;        -XX:ParallelCMSThreads      # 并发线程数，默认是CPU数一半&#xA;        -XX:CMSInitiatingOccupancyFraction 92%          # 老年代占多少时触发GC, 1.8 92%, 之前68%&#xA;            设小一点，清除浮动垃圾&#xA;            过大时，栈分配不下，Promotion Failure，触发FGC&#xA;        -XX:+UseCMSCompactAtFullCollection              # GC时压缩，避免碎片片&#xA;        -XX:CMSFullGCsBeforeCompaction                  # 多少次GC后压缩&#xA;        -XX:+CMSClassUnloadingEnabled                   # 回收方法区&#xA;        -XX:CMSInitiatingPermOccupancyFraction          # 到什么比例时进行Perm回收, 1.8之前&#xA;        GCTimeRatio                                     # GC占程序运行时间的百分比&#xA;        -XX:MaxGCPauseMillis                            # GC停顿时间, CMS会减少年轻代大小&#xA;    G1&#xA;        -XX:MaxGCPauseMillis                            # STW时间, 区别CMS, G1会调整Young区的块数&#xA;        GCTimeRatio&#xA;        -XX:GCPauseIntervalMillis                       # STW之间间隔时间&#xA;        -XX:+G1HeapRegionSize                           # Region大小, 1 2 4 8 16 32, 逐渐增大, GC间隔更长, 每次GC时间更长&#xA;            ZGC是动态调整的&#xA;        G1NewSizePercent                                # 新生代最小比例, 默认5%&#xA;        G1MaxNewSizePercent                             # 新生代最大比例，默认60%&#xA;        ConcGCThreads                                   # GC线程数&#xA;        InitiatingHeapOccupancyPercent                  # 启动GC的堆空间占用比例&#xA;&#xA;JMX监控&#xA;    -Djava.rmi.server.hostname=192.168.1.1&#xA;    -Dcom.sun.management.jmxremote &#xA;    -Dcom.sun.management.jmxremote.port=11111 &#xA;    -Dcom.sun.management.jmxremote.authenticate=false &#xA;    -Dcom.sun.management.jmxremote.ssl=false&#xA;调优                            # 参数越来越少&#xA;    JVM参数800个&#xA;    CMS参数300个&#xA;    G1参数100个&#xA;    ZGC更少&#xA;    Zing1个&#xA;GC组合参数&#xA;    -XX:+UseSerialGC&#xA;        S + SO&#xA;    -XX:+UseParNewGC                # 已废弃&#xA;        PN + SO&#xA;    -XX:+UseConc(urrent)MarkSweepGC&#xA;        PN + CMS + SO&#xA;    -XX:+UseParallelGC               # 1.8默认&#xA;        PS + PO&#xA;    -XX:+UseParallelOldGC&#xA;        PS + PO&#xA;    -XX:+UseG1GC&#xA;        G1&#xA;日志参数&#xA;    -Xloggc:/logs/xx-xx-%t.log&#xA;    -XX:+UseGCLogFileRotation           # 5个满了，覆盖第一个&#xA;    -XX:NumberOfGCLogFiles=5&#xA;    -XX:GCLogFileSize=1024M&#xA;    -XX:+PrintGCDetails&#xA;    -XX:+PrintGCDateStamps&#xA;    -XX:+PrintGCCause&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;hotspot日志&#34;&gt;&#xA;  HotSpot日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hotspot%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;GC                          # PrintGCDetails&#xA;    [GC&#xA;        GC表示YGC, Full GC是FGC&#xA;    (Allocation Failure)&#xA;        原因&#xA;    [DefNew:4544k-&amp;gt;259k(6144k), 0.0873 secs]&#xA;        DefNew表示年轻代, 回收前后的大小, 6144是年轻代总大小，回收时间&#xA;    4544k-&amp;gt;4356k(19840k), 0.0812 secs]&#xA;        堆的前后大小, 19840是堆总空间, 回收时间&#xA;    [Times: user=0.01 sys=0.00, real=0.01 secs]&#xA;        linux time命令，用户态时间，内核态时间，总时间&#xA;异常退出dump堆&#xA;    def new generation total 6144k, used 5504k [0x00, 0x00, 0x00]&#xA;        新生代总共多少，用了多少。内存起始地址，使用空间结束地址，整体空间结束地址&#xA;        total = eden + 1个survivor&#xA;    eden space 5504k, 100% used []&#xA;        eden&#xA;    from space 640k, 0% used []&#xA;        s0&#xA;    to space 640, 0% used []&#xA;        s1&#xA;    tenured generation total 13696k, used 13312k []&#xA;        old&#xA;    the space 13696k, 97% used []&#xA;        old&#xA;    Metaspace used 2538k, capacity 4486k, committed 4864k, reserved 1056768k&#xA;        used真正使用的大小&#xA;        capacity目前指定的容量 &#xA;        committed 表示预先占用的大小&#xA;        reserved表示共保留的大小&#xA;    class space used 275k, capacity 386k, committed 512k, reserved 1048576k&#xA;        metaspace中存class的部分&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/pl/java/collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/pl/java/collection/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;物理容器&#xA;    数组&#xA;    链表&#xA;Java容器&#xA;    Collection&#xA;        List&#xA;            ArrayList&#xA;            Vector                          # JDK1.0，所有方法加synchronized&#xA;                Stack&#xA;            LinkedList&#xA;            CopyOnWriteList                 # 写时复制整个list, 写加锁读无锁, 无fail-fast&#xA;        Set&#xA;            HashSet&#xA;                LinkedHashSet&#xA;            SortedSet&#xA;                TreeSet&#xA;            EnumSet&#xA;            CopyOnWriteArraySet&#xA;            ConcurrentSkipListSet&#xA;        Queue                               # 相比List添加线程友好API&#xA;            Deque                           # 双端队列&#xA;                ArrayDeque&#xA;                BlockingDeque&#xA;                    LinkedBlockingDeque&#xA;            BlockingQueue                   # LockSupport实现, channel, 生产者消费者&#xA;                SynchronousQueue            # 锁实现, 无缓冲区channel&#xA;                TransferQueue               # CAS, 生产者带队列阻塞&#xA;                    LinkedTransferQueue&#xA;                ArrayBlockingQueue          # 有缓冲区channel&#xA;                DelayQueue                  # 内部维护按时间排序队列&#xA;                PriorityBlockingQueue&#xA;                LinkedBlockingQueue         # 最大数量Integer.MAX_VALUE&#xA;            PriorityQueue                   # 堆排序实现&#xA;            ConcurrentLinkedQueue           # CAS&#xA;    Map&#xA;        HashMap&#xA;            LinkedHashMap                   # 双向链表，按插入或访问顺序遍历&#xA;        Hashtable                           # JDK1.0，所有方法加synchronized&#xA;        ConcurrentHashMap                   # CAS, 写慢、读快&#xA;        ConcurrentSkipListMap               # 有序, 没有concurrentTreeMap因为CAS红黑树难实现&#xA;        TreeMap                             # 有序，红黑树, 查找效率高。&#xA;        WeakHashMap&#xA;        IdentityHashMap&#xA;工具类&#xA;    Collections&#xA;        synchronizedMap(Map)                # 内部mutex加synchronized&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;queue&#34;&gt;&#xA;  Queue&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#queue&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    add()                                   # 满了报异常&#xA;    boolean offer()                         # 返回是否成功&#xA;    boolean offer(long, TimeUnit)           # 返回是否成功&#xA;    poll()&#xA;    peek()&#xA;    element()                               # 同peek(), 但空时报错&#xA;    remove()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;blockingqueue&#34;&gt;&#xA;  BlockingQueue&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#blockingqueue&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    put()                                   # 阻塞&#xA;    take()                                  # 阻塞&#xA;TransferQueue&#xA;    transfer()&#xA;    take()&#xA;    getWaitingConsumerCount()               # 阻塞的消费者长度&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://runout.run/docs/pl/java/spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://runout.run/docs/pl/java/spring/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    容器, 也容纳管理了第三方框架         # 目的是解耦框架api&#xA;    轻量级，模块化，无(少)侵入&#xA;IOC(inversion of control)&#xA;    容器用工厂装配对象并管理, 面向接口编程&#xA;    优点&#xA;        降低代码量&#xA;        容易测试&#xA;        最小侵入性松耦合&#xA;    方式&#xA;        Setter&#xA;        构造器&#xA;        静态工厂、实例工厂&#xA;DI(dependency injection)&#xA;    容器向类添加属性        # 反射，用带参构造或set方法&#xA;AOP(aspect oriented programming)&#xA;    # 继承是纵向组织，AOP横切入业务&#xA;    # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用）&#xA;    动态代理实现切入代码&#xA;        权限控制&#xA;        事务管理&#xA;        记录日志&#xA;    概念&#xA;        连接点:普通方法&#xA;        切入点:名称满足条件的连接点&#xA;        增强（通知）类:服务对象&#xA;            # 切入点与增强是多对多的&#xA;        切面:切入点 + 增强类                        # 我们切入的是横切面&#xA;        目标对象（服务对象）：要注入的对象&#xA;    通知&#xA;        before              # 执行前&#xA;        after               # 执行后&#xA;        after-returning     # 正常退出&#xA;        after-throwing      # 异常退出&#xA;        around              # 执行前后&#xA;        代理对象(业务对象)：被注入的对象&#xA;模块&#xA;    dao, orm, aop, jee, web, core&#xA;结构&#xA;    核心容器(core container)&#xA;        Core        # 最底层，资源访问，类型转换&#xA;        Beans       # IOC, DI, BeanFactory&#xA;        Context     # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播&#xA;        EL          # 表达式语言&#xA;    AOP, Aspects    # Aspects对AspectsJ集成, 功能多于spring asp&#xA;    数据访问/集成&#xA;        JDBC&#xA;        ORM&#xA;        OXM         # object xml 映射&#xA;        JMS         # 消息与异步通信&#xA;        事务&#xA;    Web/Remoting&#xA;        Web             # ioc窗口，rmi, hessian,burlap, web service&#xA;        Web-Servlet&#xA;        Web-Struts&#xA;        Web-Porlet      # portal认证&#xA;    Test&#xA;设计模式&#xA;    代理&#xA;        目标对象实现接口，使用Proxy&#xA;        未实现接口，使用CGLIB&#xA;    单例&#xA;        bean默认单例&#xA;    模板, 解决代码重复问题&#xA;        RestTemplate, JmsTemplate, JpaTemplate&#xA;    控制器&#xA;        DispatherServlet对请求分发&#xA;    视图帮助(view helper)&#xA;        提供jsp标签、高效宏 帮助在视图中写代码&#xA;    依赖注入&#xA;        BeanFactory, ApplicationContext核心理念&#xA;    工厂&#xA;        BeanFactory&#xA;循环依赖问题&#xA;    构造器, 正在创建在Bean池标记，创建完删除标记，标记冲突报错      # 所以用@Autowired决定注入时机，不写在构造方法里&#xA;    单例， 三级缓存, 提前暴露使双方都可初始化&#xA;    setter, 提前暴露bean&#xA;版本&#xA;    2.5&#xA;        注解&#xA;    3.2&#xA;        基于注解的注入测试类@RunW..&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;jar包 ：&#xA;    核心包：/dist/modules                # 或是/dist中的spring.jar包&#xA;        core模块&#xA;            beans&#xA;            context&#xA;            context-support&#xA;            core&#xA;    日志包：/lib/jakata-commons/commons-logging.jar&#xA;创建xml文件(最好在JavaBean的旁边)&#xA;    绑定约束文件        /dist/resources/spring-beans-2.5.xsd&#xA;    copy xml文件的头：/sample/petclinic/war/web-inf/app...xml&#xA;    创建JavaBean.java&#xA;    xml文件中配置bean                # src下&#xA;        &amp;lt;bean id=&amp;quot;&amp;quot; class=&amp;quot;&amp;quot;&amp;gt;                # id值唯一,class指定 javaBean的类目录&#xA;            &amp;lt;property name=&amp;quot;&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;&amp;quot; ref=&amp;quot;girlID&amp;quot;&amp;gt;                # 引用类型，其中girlID为spring配置的bean Id&#xA;业务类中&#xA;    ApplicationContext ac = new ClassPathXmlApplicationContext(new String [] {&amp;quot;配置xml文件路径&amp;quot;})&#xA;        # 注意：ac创建时，其内部的JavaBean默认全部实例化一遍，并且全部注入了属性&#xA;        ## 该容器不用关闭&#xA;    if(ac.containsBean(&amp;quot;boyID&amp;quot;)){&#xA;        Boy boy = (Boy)ac.getBean(&amp;quot;boyID&amp;quot;);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ApplicationContext是一个接口，表示spring容器/ioc容器&#xA;&#xA;ClassPathXmlApplicationContext        # 只从类路径中读取xml配置文件（src/目录下能访问的路径）省略src/目录&#xA;&#xA;FileSystemXmlApplicationContext                # 文件路径 ,从src/开始&#xA;&#xA;    ac.getBean(&amp;quot;boyID&amp;quot;)&#xA;    ac.containsBean(&amp;quot;boyID&amp;quot;)                # 通过此方法去判断是否存在 ，而不是得到的是否为null&#xA;    ac.destroy()                                        # ac中的bean实例全部销毁&#xA;&#xA;BeanFactory&#xA;    # 基础IOC容器, 默认延迟初始化&#xA;    DefaultListableBeanFactory&#xA;    ApplicationContext&#xA;    XmlBeanFactory      # 根据xml中的定义加载bean&#xA;Spring-DAO      # 提供规范, 翻译框架(JDBC&amp;lt;Hibernate,JPA等)异常为DataAccessException&#xA;    @Repository 注解DAO类&#xA;Spring-JDBC     # 模板类&#xA;    DataSource&#xA;    JdbcTemplate&#xA;    JdbcDaoSupport  # 对dao扩展, DataAccessExceptions异常翻译器&#xA;Spring-ORM      # 统称，对各模块(JPA,JDO,Hibernate,iBatis,TopLink,OJB)实现了spring的集成类&#xA;    把DataSource注入到SessionFactory或EntityManagerFactory等bean中     # jdbc不需要，因为jdbc直接使用DataSource&#xA;    HibernateTemplate&#xA;    HibernateDAOSupport     # 继承它提供aop拦截器&#xA;Web&#xA;    # 在ApplicationContext基础上, 提供web上下文和面向web的服务&#xA;    ApplicationContext      # 以BeanFactory为基础,容器启动后默认全部初始化绑定&#xA;        FileSystemXmlApplicationContext     # 指定文件&#xA;        ClassPathXmlApplicationContext      # 从classpath找设置&#xA;        WebXmlApplicationContext&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;注解&#34;&gt;&#xA;  注解&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e8%a7%a3&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;applicationContext.xml&#xA;    &amp;lt;context:annotation-config/&amp;gt;&#xA;    &amp;lt;!-- 添加注解扫描功能,启动的时候哪些包要检查是否有注解 --&amp;gt;&#xA;    &amp;lt;context:component-scan base-package=&amp;quot;xxx&amp;quot; /&amp;gt;&#xA;&#xA;&#xA;@Required           # setter&#xA;@Autowired          # setter、构造方法、变量&#xA;@Qualifier(&amp;quot;dataSource)                     # 多类配置时，指定使用类&#xA;@Bean               # 返回对象注册为bean&#xA;@Configuration      # bean定义&#xA;&#xA;@Service            # 添加类名小写的spring bean id        也可以@Service(value=&amp;quot;xx&amp;quot;)自定义id&#xA;                    ## action类前换成@Controller                @Service也是可以的&#xA;@Scope(value=&amp;quot;prototype&amp;quot;)&#xA;                    # 工具类或其它组件类换成@Component 也可以@Service,如定时器TimerTask就是组件&#xA;@Resource           # 按属性名注入资源&#xA;&#xA;测试类&#xA;    @RunWith(SpringJUnit4ClassRunner.class)&#xA;    @ContextConfiguration(locations = &amp;quot;classpath:applicationContext*.xml&amp;quot;)&#xA;&#xA;&#xA;@PostConstruct      # 类加载时运行的方法，相当于xml中配置的init-method&#xA;@PreDestroy         # 类销毁前运行的方法&#xA;&#xA;aop&#xA;    applicationContext.xml&#xA;        &amp;lt;aop:aspectj-autoproxy/&amp;gt;&#xA;    @Aspect&#xA;        # 注册一个类为切面&#xA;    @Pointcut(value=&amp;quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&amp;quot;)&#xA;        # 配置切点表达式&#xA;    private void testAop(){}&#xA;    @AfterReturning(pointcut=&amp;quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&amp;quot;)&#xA;        # 配置通知，在通知中配置切点&#xA;    @AfterReturning(value=&amp;quot;testAop()&amp;quot;)&#xA;        # 配置通知，使用已经配置的切点&#xA;    @Around(value=&amp;quot;testAop()&amp;quot;)&#xA;        # 配置通知，使用已经配置的切点&#xA;    @Around(value=&amp;quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.queryByWord(..))&amp;quot;)&#xA;        # 配置通知，在通知中配置切点,注意这里没有pointcut,只有value&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模块&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;监听器&#34;&gt;&#xA;  监听器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%91%e5%90%ac%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    org.springframework.web.context.ContextLoaderListener中&#xA;        this.contextLoader.initWebApplicationContext(event.getServletContext());&#xA;            # 加载Spring 的配置文件 ，加载Application内置对象中&#xA;    initWebApplicationContext方法中&#xA;        this.context = createWebApplicationContext(servletContext, parent);&#xA;        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);&#xA;            # 创建并存储spring的application内置对象到ServletContext中，属性名称是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&#xA;    createWebApplicationContext方法中&#xA;        wac.setConfigLocation(sc.getInitParameter(CONFIG_LOCATION_PARAM));&#xA;            # 该类文件中有：public static final String CONFIG_LOCATION_PARAM = &amp;quot;contextConfigLocation&amp;quot;;&#xA;            # 获得web.xml中配置的context-param初始化参数：contextConfigLocation的内容，并加载spring配置文件&#xA;&#xA;使用&#xA;    servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);&#xA;&#xA;    ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;properties&#34;&gt;&#xA;  properties&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#properties&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;spring xml配置文件中使用properties配置的属性&#xA;    配置一个bean的class类是org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer的单例bean&#xA;        &amp;lt;property name=&amp;quot;locations&amp;quot; value=&amp;quot;classpath:public.properties&amp;quot; &amp;gt;&#xA;            &amp;lt;array&amp;gt;&#xA;                &amp;lt;value&amp;gt;classpath:conn.properties&amp;lt;/value&amp;gt;&#xA;        或&#xA;        &amp;lt;property name=&amp;quot;location&amp;quot; value=&amp;quot;classpath:conn.properties&amp;quot; /&amp;gt;&#xA;    xml文件中用&amp;quot;${driver}&amp;quot;的方式引用properties中配置的属性&#xA;java类中用spring的注解注入properties配置的属性&#xA;    # 要求必须是spring管理的类&#xA;    bean中的class类换成org.springframework.beans.factory.config.PropertiesFactoryBean&#xA;    id=&amp;quot;Xxx&amp;quot;其它相同&#xA;    java类的属性或set方法上添加注解：&#xA;    @Value(&amp;quot;#{public.basePath}#{public.filePath}&amp;quot;)&#xA;        # 其中public 是上面配置的bean的id(xml文件中注入属性的话用不到id,所以没有配置)&#xA;        ## &#39;#{}&#39;代表引用属性&#xA;        ## &#39;.&#39;可以用&#39;[]&#39;代替，如public[basePath]&#xA;        ## 字符串的拼接可以用+连接&#xA;        # 第一次配置@Value的时候不会成功，改一次值再试就可以了&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;bean&#34;&gt;&#xA;  bean&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;创建bean的顺序&#xA;    xml中按配置顺序的先后&#xA;    注解中按照字母的顺序&#xA;生命周期&#xA;    配置中定义&amp;lt;bean&amp;gt;&amp;lt;/bean&amp;gt;&#xA;    初始化&#xA;        配置文件中init-method&#xA;        实现org.springframework.beans.factory.InitializingBean接口&#xA;    调用&#xA;    销毁&#xA;        配置文件中destroy-method&#xA;        实现org.springframework.bean.factory.DisposeableBean&#xA;scope&#xA;    # 默认singleton&#xA;    prototype   # 每次产生新对象&#xA;    singleton   # 单例&#xA;    request     # 一个请求一个对象，只在ApplicationContext下有效&#xA;    session     # 一个session一个对象，只在ApplicationContext下有效&#xA;    global-session      # 一个全局session一个对象, 只在ApplicationContext下有效&#xA;内部bean&#xA;    &amp;lt;property&amp;gt;或&amp;lt;constructor-arg&amp;gt;中定义的&amp;lt;bean&amp;gt;,通常匿名&#xA;注入对象&#xA;    &amp;lt;list&amp;gt;&#xA;    &amp;lt;set&amp;gt;&#xA;    &amp;lt;map&amp;gt;&#xA;    &amp;lt;props&amp;gt;         # 键值都只能是string类型&#xA;自动装配&#xA;    方式&#xA;        no      # 不自动装配，通过ref属性指定&#xA;        byName&#xA;            查找类中setter&#xA;            容器中找id&#xA;            报空指针&#xA;        byType&#xA;            容器中找类型      # 找到多个时抛异常&#xA;        constructor&#xA;            byType带构造函数参数&#xA;        autodetect&#xA;            先试constructor, 再试byType&#xA;    写法&#xA;        &amp;lt;bean&amp;gt;属性autowire=&amp;quot;byName&amp;quot;&#xA;        @Autowired&#xA;            类型自动装配&#xA;            加上@Qualifier(value=&amp;quot;a&amp;quot;)&#xA;                @Resource(name=&amp;quot;a&amp;quot;)注解的name装配&#xA;                byName装配&#xA;                byType装配&#xA;&#xA;配置&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;&#xA;        xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;&#xA;        xsi:schemaLocation=&amp;quot;&#xA;            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&#xA;            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&amp;quot;&amp;gt;&#xA;        &amp;lt;bean&#xA;            id=&amp;quot;userDaoID&amp;quot;&#xA;            name=&amp;quot;&amp;quot;&#xA;            class=&amp;quot;cn.itcast.javaee.spring.bean.life.UserDao&amp;quot;&#xA;            init-method=&amp;quot;getSession&amp;quot;&#xA;            destroy-method=&amp;quot;closeSession&amp;quot;&#xA;            factory-method=&amp;quot;getUserDao&amp;quot;&#xA;            scope=&amp;quot;singleton&amp;quot;&#xA;            lazy-init=&amp;quot;false&amp;quot;&#xA;            parent=&amp;quot;userDaoID&amp;quot;&#xA;            abstract=&amp;quot;true&amp;quot;&#xA;            autowire=&amp;quot;no&amp;quot;&amp;gt;&#xA;                &amp;lt;constructor-arg type=&amp;quot;java.lang.Integer&amp;quot; index ref&amp;gt;&#xA;                    &amp;lt;value&amp;gt;2013&amp;lt;/value&amp;gt;&#xA;                &amp;lt;constructor-arg type=&amp;quot;java.lang.Double&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;6000&amp;lt;/value&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;aa&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;name&amp;quot; ref=&amp;quot;dateID&amp;quot; /&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;telSet&amp;quot;&amp;gt;&#xA;                &amp;lt;set&amp;gt;&#xA;                    &amp;lt;value&amp;gt;11&amp;lt;/value&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;cityList&amp;quot;&amp;gt;&#xA;                &amp;lt;list&amp;gt;&#xA;                    &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;telCityMap&amp;quot;&amp;gt;&#xA;                &amp;lt;map&amp;gt;&#xA;                    &amp;lt;entry key=&amp;quot;&amp;quot;&amp;gt;&#xA;                        &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;&#xA;                &amp;lt;property name=&amp;quot;&amp;quot;&amp;gt;&#xA;                    &amp;lt;props&amp;gt;&#xA;                        &amp;lt;prop key=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/prop&amp;gt;&#xA;标签、属性分析&#xA;    bean标签：代表一个JavaBean&#xA;        # 多个JavaBean配置时，先配置的先创建，先创建的后销毁&#xA;        id：该JavaBean的唯一标识&#xA;        name：可以和id一样用，但是name可以设置&amp;quot;/a&amp;quot;来绑定路径&#xA;        class：该JavaBean的类路径&#xA;        init-method：创建该JavaBean时运行的其中的方法&#xA;        destroy-method：销毁该JavaBean时运行的其中的方法&#xA;            # ClassPathXmlApplicationContext类的实例不监听销毁方法&#xA;            ## 用AbstractApplicationContext中的close()与registerShutdownHook()方法&#xA;            ## close()直接马上销毁，registerShutdownHook()方法会注册关闭钩子,监听容器的销毁&#xA;            ## &#xA;        factory-method：创建该Bean的函数&#xA;            得到接口实现类的方法&#xA;            1.通过实现类的无参构造器                # 没有factory-method属性&#xA;            2.没有无参构造器时，工厂静态方法创建实例&#xA;                &amp;lt;bean id=&amp;quot;userDaoID&amp;quot; factory-bean=&amp;quot;daoFactoryID&amp;quot; factory-method=&amp;quot;getUserDao&amp;quot;&amp;gt;&#xA;                    # class中的内容是工厂类，而非UserDao类，factory-method是工厂类中返回UserDao类的静态方法&#xA;            3.没有无参构造器时，工厂非静态方法创建实例&#xA;                &amp;lt;bean id=&amp;quot;daoFactoryID&amp;quot; class=&amp;quot;cn.itcast.javaee.spring.bean.create.type3.DaoFactory&amp;quot;&amp;gt;&#xA;                    &amp;lt;bean id=&amp;quot;userDaoID&amp;quot; factory-bean=&amp;quot;daoFactoryID&amp;quot; factory-method=&amp;quot;getUserDao&amp;quot;&amp;gt;&#xA;                        # 先实例化工厂（Spring 加载本xml文件默认实例化），然后静态方法的配置即可&#xA;        scope：作用域&#xA;            1.singleton（单例）是默认值，是单例的，会调用init destory方法 &#xA;            2.prototype（原型）每次创建一个实例， 调用init方法，但不调用destory方法（实例的维护 ：javase程序交给jvm,javaee程序交给服务器）&#xA;        lazy-init&#xA;            1.false:为启动容器时立即创建一个实例                # singleton与prototype模式都会创建&#xA;            2.true:启动时不加载,获取时创建&#xA;        parent：        继承一个Spring bean(包含其中的所有属性)&#xA;            # javaBean类中不必有实际的继承关系（但是有继承关系则必要配置parent）&#xA;        abstract=&amp;quot;true&amp;quot;        : 配置此Bean为抽象Bean&#xA;        autowire=&amp;quot;no&amp;quot;:自动装配，只能装配关联属性&#xA;            # 还可以进行注解装配&#xA;            byName      装配时根据bean中的每个属性名从spring中找id同名的bean,通过setter方法注入到该属性中&#xA;            byType      根据bean中的每个属性的类型找到spring中映射该类型的bean进行装配,通过setter方法注入到该属性中&#xA;            constructor 找满参构造器装载，构造器中的参数以byType方式注入&#xA;            autodetect  先找构造器装载，再set方法注入。但实际使用中只能set方法注入&#xA;            no          不注入&#xA;        可以配置init-method与destroy-method属性来配置该bean创建和销毁时执行的方法&#xA;    注入值                  # 通过setter方法注入值 &#xA;        &amp;lt;constructor-arg type=&amp;quot;java.lang.Integer&amp;quot; index ref&amp;gt;        &#xA;            &amp;lt;value&amp;gt;2013&amp;lt;/value&amp;gt;    # 传入构造方法参数注入值，,位置不能颠倒，不调用setter方法&#xA;                ## type是注入参数的类型，index是参数的标号，从0开始，ref是引用类型,有引用类型时不用&amp;lt;value&amp;gt;标签&#xA;            &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;aa&amp;quot;/&amp;gt;                # 基本类型直接赋值（包括包装类型与String）&#xA;            &amp;lt;property name=&amp;quot;name&amp;quot; ref=&amp;quot;dateID&amp;quot;/&amp;gt;        # 引用类型,dateID是一个Spring Bean&#xA;                ## 可以直接引用Spring Bean 的id &#xA;                &amp;lt;set&amp;gt;&#xA;                    &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;                                                # set集合&#xA;                &amp;lt;list&amp;gt;&#xA;                    &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;                                                # list集合&#xA;                &amp;lt;map&amp;gt;&#xA;                    &amp;lt;entry key=&amp;quot;&amp;quot;&amp;gt;&#xA;                            &amp;lt;value&amp;gt;&amp;lt;/value&amp;gt;                                        # map集合&#xA;                    # 集合的值均可配置引用类型&#xA;                &amp;lt;property name=&amp;quot;&amp;quot;&amp;gt;&#xA;                    &amp;lt;props&amp;gt;&#xA;                        &amp;lt;prop key=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/prop&amp;gt;                        # 属性类型，只能配置基本类型 （包括包装类型与String）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;aop&#34;&gt;&#xA;  aop&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;实现      # 基于Aspectj&#xA;原理&#xA;    启动容器时，创建目标对象与代理对象&#xA;    &amp;lt;aop:config/&amp;gt;加载完时,通过cglib创建目标对象的代理对象，运行时产生&#xA;    程序员-代理对象-代理方法-目标对象-目标方法-代理对象&#xA;使用&#xA;    写类文件&#xA;    1.jar包  aspectjweaver.jar/aspectjrt.jar/cglib-nodep-2.1_3.jar(动态代理包)&#xA;    2.配置xml文件头,保留aop&#xA;        &amp;lt;bean id class/&amp;gt;        # 目标对象&#xA;        &amp;lt;bean id=&amp;quot;serviceBeanID&amp;quot; class /&amp;gt;    # 配置增强对象&#xA;        &amp;lt;aop:config&amp;gt;            # 相当于创建了代理对象&#xA;            &amp;lt;aop:pointcut id=&amp;quot;xxxx&amp;quot; expression=&amp;quot;&amp;quot; /&amp;gt;        # 切入点表达式：expression=&amp;quot;execution(public void addUser() throws java.lang.Exception)&amp;quot;&#xA;                ## 可以写成execution(public void 类名.*()),表示匹配所有方法&#xA;                ## execution(* *(..))        第一个*是返回值，第二个*是方法，..表示参数不限&#xA;                ## 可以声明抛异常&#xA;                ## 条件命名为xxxx,升级连接点到切入点&#xA;            &amp;lt;aop:aspect ref=&amp;quot;serviceBeanID&amp;quot;&amp;gt;&#xA;                &amp;lt;aop:before method=&amp;quot;writeLog&amp;quot; pointcut-ref=&amp;quot;xxxx&amp;quot;/&amp;gt;    # 前置增强，method是注入的方法，xxxx是增强的条件,只能写一个方法&#xA;                &amp;lt;aop:after/&amp;gt;&#xA;                &amp;lt;aop:after-returning/&amp;gt;      # 方法返回后执行&#xA;                &amp;lt;aop:after-throwing/&amp;gt;      # 抛出异常时执行&#xA;                &amp;lt;aop:around/&amp;gt;              # 环线，执行目标方法前、后都执行,出错则之后的函数不执行&#xA;                    public void both(ProceedingJoinPoint pjp){      # ProceedingJoinPoint是连接代理对象 与目标对象的桥梁&#xA;                        open();&#xA;                        pjp.proceed();      # 执行目标代码&#xA;                        close();&#xA;                    }&#xA;                    # 目标方法出错，后置增强仍然执行,after-throwing执行，前置增强不执行,after-returning不执行&#xA;                    &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot; pointcut-ref=&amp;quot;xxxx&amp;quot;/&amp;gt;                # 配置事务的切面&#xA;切入点表达式&#xA;    execution(方法的修饰符 方法的返回值类型 方法所属的类 方法名 方法中参数列表 方法抛出的异常)&#xA;        方法的修饰符：    支持通配符*，可省略&#xA;        方法的返回值类型：支持通配符*，表示所有返回值，不可省&#xA;        方法所属的类：    支持通配符*，可省略&#xA;        方法名：          支持通配符*，表示所有方法，不可省&#xA;        方法中参数列表：  支持通配符*，不可省&#xA;                # *表示【一个】任意类型的参数&#xA;                ## ..表示零个或一个或多个任何类型的参数【提倡】&#xA;    execution(方法的返回值类型 方法名（方法中参数列表））                # 一般形式&#xA;&#xA;    例如:&#xA;    execution(public void add()throws Exception)&#xA;    execution(public void add(..)throws Exception)&#xA;    execution(public void add(*)throws Exception)&#xA;    execution(* cn.itcast.web.spring.aop.UserDao.add(..))&#xA;    execution(* add()throws Exception)&#xA;    execution(public void *(..)throws Exception)&#xA;            execution(public void a*(..)throws Exception)：方法名以a字符开始&#xA;    execution(public void *d(..)throws Exception)：方法名以d字符结束&#xA;    execution(* add())&#xA;    execution(* *(..))&#xA;切点方法的编写&#xA;    public void Xxx(JoinPoint joinPoint){&#xA;        joinPoint.getTarget();                # 获取目标对象&#xA;        joinPoint.getSignature();        # 获取当前连接点的方法信息&#xA;        joinPoint.getArgs()[0];                # 获取当前连接点的第一个参数&#xA;        ..&#xA;    }&#xA;    public Goods Yxx(ProceedingJoinPoint joinPoint){&#xA;        Object object = joinPoint.proceed();        # 得到连接点的返回值&#xA;        ..&#xA;        return goods;                # 本切面返回的数据会作为切点返回的数据返回给调用它的函数&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;dao&#34;&gt;&#xA;  dao&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dao&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    1.xml文件中&#xA;    &amp;lt;!-- 配置C3P0连接池 --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;comboPooledDataSourceID&amp;quot; class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/spring&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;initialPoolSize&amp;quot; value=&amp;quot;60&amp;quot;/&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;acquireIncrement&amp;quot; value=&amp;quot;5&amp;quot;/&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;&#xA;        &amp;lt;!-- 配置JdbcTemplate --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;jdbcTemplateID&amp;quot; class=&amp;quot;org.springframework.jdbc.core.JdbcTemplate&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;comboPooledDataSourceID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;&#xA;        &amp;lt;!-- 配置UserDao --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;userDaoID&amp;quot; class=&amp;quot;dao.UserDao&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;jt&amp;quot; ref=&amp;quot;jdbcTemplateID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;    2.Dao中&#xA;        private JdbcTemplate jt;&#xA;        addUser()&#xA;            String sql = &amp;quot;&amp;quot;;&#xA;            Object [] params = {user.getUsername(),user.getPassword()}&#xA;            jt.update(sql,params);&#xA;            批量：&#xA;            for(int i = 0; i &amp;lt; ids.length; i++){&#xA;                sqls[i] = &amp;quot;&amp;quot;;&#xA;            }&#xA;            jt.batchUpdate(sqls);&#xA;            查询一个&#xA;        return (User)jt.queryForObject(sql,params,new RowMapper(){&#xA;                public Object mapRow(ResultSet rs,int rowNum){          # rs是查询出来的结果集,rowNum是结果集的行号,从0开始&#xA;                    Integer id = rs.getInt(&amp;quot;id&amp;quot;);&#xA;                    User user = new User(id);&#xA;                    return user;&#xA;                }&#xA;                });&#xA;            查询多个                # query方法把RowMapper帮助类中返回的user分别加入到list中，返回一个list&#xA;            list = jt.query(sql,new RowMapper(){&#xA;                    public Object mapRow()&#xA;                        ..&#xA;                        return bean;&#xA;                })&#xA;            分页&#xA;                            String sql = &amp;quot;select * from users limit ?,?&amp;quot;;&#xA;                            Object[] params = {0,3};&#xA;            jt.query(sql,params,new RowMapper(){&#xA;            记录&#xA;            jt.queryForInt(sql);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事务&#34;&gt;&#xA;  事务&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;TransactionInterceptor&#xA;    transactionManager          # 指定事务治理类&#xA;    transactionAttributes       # key方法名 value事务属性&#xA;注解&#xA;    @Transactional(propagation = Propagation.REQUIRED)&#xA;手写      # TransactionDefinition&#xA;    Public class BankServiceImpl implements BancService{&#xA;        Private BanckDao bankDao;&#xA;        private TransactionDefinition txDefinition;&#xA;        private PlatformTransactionManager txManager;&#xA;        public boolean transfer(Long fromId, Long toId, double amount) {&#xA;            TransactionStatus txStatus = txManager.getTransaction(txDefinition);&#xA;            boolean result = false;&#xA;            try {&#xA;                result = bankDao.transfer(fromId, toId, amount);&#xA;                txManager.commit(txStatus);&#xA;            } catch (Exception e) {&#xA;                result = false;&#xA;                txManager.rollback(txStatus);&#xA;                System.out.println(&amp;quot;Transfer Error!&amp;quot;);&#xA;            }&#xA;            return result;&#xA;        }&#xA;    }&#xA;手写      # TransactionTemplate&#xA;    public class BankServiceImpl implements BankService {&#xA;        private BankDao bankDao;&#xA;        private TransactionTemplate transactionTemplate;&#xA;        public boolean transfer(final Long fromId, final Long toId, final double amount) {&#xA;            return (Boolean) transactionTemplate.execute(new TransactionCallback(){&#xA;            public Object doInTransaction(TransactionStatus status) {&#xA;                Object result;&#xA;                try {&#xA;                    result = bankDao.transfer(fromId, toId, amount);&#xA;                } catch (Exception e) {&#xA;                    status.setRollbackOnly();&#xA;                    result = false;&#xA;                    System.out.println(&amp;quot;Transfer Error!&amp;quot;);&#xA;                }&#xA;                return result;&#xA;            }&#xA;            });&#xA;        }&#xA;    }&#xA;配置      # TransactionInterceptor&#xA;    &amp;lt;bean id=&amp;quot;transactionInterceptor&amp;quot; class=&amp;quot;org.springframework.transaction.interceptor.TransactionInterceptor&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;transactionManager&amp;quot; ref=&amp;quot;transactionManager&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;transactionAttributes&amp;quot;&amp;gt;&#xA;            &amp;lt;props&amp;gt;&#xA;                &amp;lt;prop key=&amp;quot;transfer&amp;quot;&amp;gt;PROPAGATION_REQUIRED&amp;lt;/prop&amp;gt;&#xA;            &amp;lt;/props&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;bankServiceTarget&amp;quot; class=&amp;quot;footmark.spring.core.tx.declare.origin.BankServiceImpl&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;bankDao&amp;quot; ref=&amp;quot;bankDao&amp;quot;/&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;bankService&amp;quot; class=&amp;quot;org.springframework.aop.framework.ProxyFactoryBean&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;target&amp;quot; ref=&amp;quot;bankServiceTarget&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;interceptorNames&amp;quot;&amp;gt;&#xA;            &amp;lt;list&amp;gt;&#xA;                &amp;lt;idref bean=&amp;quot;transactionInterceptor&amp;quot;/&amp;gt;&#xA;            &amp;lt;/list&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;配置      # TransactionProxyFactoryBean&#xA;    &amp;lt;bean id=&amp;quot;bankServiceTarget&amp;quot; class=&amp;quot;footmark.spring.core.tx.declare.classic.BankServiceImpl&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;bankDao&amp;quot; ref=&amp;quot;bankDao&amp;quot;/&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;bankService&amp;quot; class=&amp;quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;target&amp;quot; ref=&amp;quot;bankServiceTarget&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;transactionManager&amp;quot; ref=&amp;quot;transactionManager&amp;quot;/&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;transactionAttributes&amp;quot;&amp;gt;&#xA;            &amp;lt;props&amp;gt;&#xA;                &amp;lt;prop key=&amp;quot;transfer&amp;quot;&amp;gt;PROPAGATION_REQUIRED&amp;lt;/prop&amp;gt;&#xA;            &amp;lt;/props&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;配置      # tx空间&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;&#xA;        xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&#xA;        xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;&#xA;        xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;&#xA;        xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;&#xA;        xsi:schemaLocation=&amp;quot;&#xA;            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&#xA;            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&#xA;            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&#xA;            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&amp;quot;&amp;gt;&#xA;&#xA;    &amp;lt;!--配置c3p0连接池--&amp;gt;&#xA;    &amp;lt;!-- 配置JdbcTemplate类 --&amp;gt;&#xA;    &amp;lt;!-- 配置Dao --&amp;gt;&#xA;    &amp;lt;!-- 配置jdbc事务管理器 --&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;dataSourceTransactionManagerID&amp;quot; class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;comboPooledDataSourceID&amp;quot;/&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;&#xA;    &amp;lt;!-- 配置事务增强(服务对象) --&amp;gt;&#xA;    &amp;lt;tx:advice id=&amp;quot;txAdvice&amp;quot; transaction-manager=&amp;quot;dataSourceTransactionManagerID&amp;quot;&amp;gt;&#xA;    &amp;lt;tx:attribute&amp;gt;&#xA;        &amp;lt;tx:method name=&amp;quot;addUsers&amp;quot;                      # 可以用通配符&amp;quot;*users&amp;quot;&#xA;            propagation=&amp;quot;required&amp;quot;                  # 传播行为：事务开始、结束的时间。required 保证方法执行时事务已开始，事务开始时不创建，没有开始时创建&#xA;            isolation=&amp;quot;default&amp;quot;                     # 隔离级别&#xA;            timeout=&amp;quot;-1&amp;quot;                            # 事务超时,-1代表不超时，用数据库底层的配置&#xA;            rollback-for:&amp;quot;java.lang.Exception&amp;quot;      # 何时回滚&#xA;            read-only=&amp;quot;false&amp;quot;                       # 不只读&#xA;                # name 方法名的匹配模式&#xA;                # required : 外部存在事务，则加入外部事务，不存在则新建事务&#xA;                # requires_new : 总是新建事务&#xA;                # mandatory : 外部必须存在事务&#xA;                # never : 外部不能存在事务&#xA;                # supports : 外部存在则加入，不存在则不以事务方式运行&#xA;                # not_supported : 总是非事务&#xA;                # nested : 外部存在事务，嵌套执行，不存在则新建&#xA;                # no-rollback-for 以逗号分隔异常，这些异常不会导致事务回滚&#xA;                # rollback-for 导致事务回滚的异常&#xA;        /&amp;gt;&#xA;    &amp;lt;tx:attribute&amp;gt;&#xA;&#xA;    &amp;lt;!-- 配置AOP --&amp;gt;&#xA;    &amp;lt;aop:config&amp;gt;&#xA;        &amp;lt;aop:pointcut id=&amp;quot;xxxx&amp;quot; expression=&amp;quot;execution(public void *Users(..))&amp;quot;/&amp;gt;&#xA;        ##&#xA;        任意公共方法的执行：&#xA;        execution(public * *(..))&#xA;        任何一个以“set”开始的方法的执行：&#xA;        execution(* set*(..))&#xA;        AccountService 接口的任意方法的执行：&#xA;        execution(* com.xyz.service.AccountService.*(..))&#xA;        定义在service包里的任意方法的执行：&#xA;        execution(* com.xyz.service.*.*(..))&#xA;        定义在service包和所有子包里的任意类的任意方法的执行：&#xA;        execution(* com.xyz.service..*.*(..))&#xA;        定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：&#xA;        execution(* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))&amp;quot;)&#xA;&#xA;        &amp;lt;!-- 将事务代码切入点addUser()方法中，从而产生事务 --&amp;gt;&#xA;        &amp;lt;aop:advisor advice-ref=&amp;quot;txAdvice&amp;quot; pointcut-ref=&amp;quot;xxxx&amp;quot;/&amp;gt;&#xA;    &amp;lt;/aop:config&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-mybatis&#34;&gt;&#xA;  spring mybatis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mybatis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基础&#xA;    #与$&#xA;        #相当于解析成引号, 防止sql注入&#xA;        $变量引用, 不能防止sql注入，用于传入表名之类&#xA;    特点&#xA;        sql易维护，传参方便&#xA;        orm&#xA;    Mapper接口&#xA;        方法名与配置id相同&#xA;        输入输出参数类型对应定义的parameterType类型和resultType类型&#xA;        类路径是配置的namespace&#xA;    缓存&#xA;        # 基于PerpetualCache的HashMap&#xA;        一级缓存&#xA;            存在本地&#xA;            作用域为session, session flush后清空&#xA;        二级缓存&#xA;            可定义存储服务&#xA;            作用域为namespace&#xA;            配置&#xA;                &amp;lt;cache/&amp;gt;&#xA;                    readOnly=&amp;quot;true&amp;quot; 时，缓存实例单例，false时返回缓存拷贝&#xA;        更新&#xA;            create, update, delete后，作用域下所有select缓存clear&#xA;与hibernate区别&#xA;    都通过SessionFactoryBuilder从配置生成SessionFactory, 再生成Session&#xA;    都支持jdbc和jta&#xA;    mybatis可细致优化sql, hibernate移植性好&#xA;    mybatis学习成本低&#xA;    mybatis本身缓存不好，hibernate对象维护和缓存好&#xA;    hibernate dao层封开发简单(不用维护映射)，crud方便&#xA;使用&#xA;    编程&#xA;        创建SqlSessionFactory&#xA;        创建SqlSession&#xA;        执行数据库操作&#xA;        session.commit()&#xA;        session.close()&#xA;    导入ibatis jar包&#xA;    配置文件&#xA;        SqlMap.properties        # 属性名可以修改&#xA;            driver=oracle.jdbc.driver.OracleDriver&#xA;            url=jdbc:oracle:thin:@127.0.0.1:1521:orcl&#xA;            username=root&#xA;            password=root&#xA;        SqlMapConfig.xml                # 总配置文件&#xA;            &amp;lt;sqlMapConfig&amp;gt;&#xA;                &amp;lt;properties recource=&amp;quot;SqlMap.properties&amp;quot;/&amp;gt;&#xA;                &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;&amp;gt;&#xA;                        &amp;lt;dataSource type=&amp;quot;SIMPLE&amp;quot;&amp;gt;&#xA;                            &amp;lt;property value=&amp;quot;${driver}&amp;quot; name=&amp;quot;JDBC.Driver&amp;quot;/&amp;gt;&#xA;                            &amp;lt;property value=&amp;quot;${url}&amp;quot; name=&amp;quot;JDBC.ConnectionURL&amp;quot;/&amp;gt;&#xA;                            &amp;lt;property value=&amp;quot;${username}&amp;quot; name=&amp;quot;JDBC.Username&amp;quot;/&amp;gt;&#xA;                            &amp;lt;property value=&amp;quot;${password}&amp;quot; name=&amp;quot;JDBC.Password&amp;quot;/&amp;gt;&#xA;                        &amp;lt;/dataSource&amp;gt;&#xA;                    &amp;lt;sqlMap resource=&amp;quot;Student.xml&amp;quot;/&amp;gt;&#xA;                &amp;lt;/transactionManager&amp;gt;&#xA;            &amp;lt;/sqlMapConfig&amp;gt;&#xA;        Student.xml                                # 映射xml文件&#xA;            &amp;lt;sqlMap&amp;gt;&#xA;                &amp;lt;typeAlias alias=&amp;quot;Student&amp;quot; type=&amp;quot;com.Student&amp;quot;/&amp;gt;&#xA;                    &amp;lt;select id=&amp;quot;selectAllStudent&amp;quot; resultClass=&amp;quot;Student&amp;quot;&amp;gt;&#xA;                        select * from Student&#xA;                    &amp;lt;/select&amp;gt;&#xA;                &amp;lt;/typeAlias&amp;gt;&#xA;            &amp;lt;/sqlMap&amp;gt;&#xA;        辅助类Student.java                 # 要求有无参构造方法&#xA;            private sid = 0;&#xA;            private String name = null;&#xA;            private String major = null;&#xA;            private Date birth = null;&#xA;            private float score = 0;&#xA;    Xxx.java&#xA;        private static SqlMapClient sqlMapClient = null;&#xA;        static{&#xA;            Reader reader = Resources.getResourceAsReader(总配置文件);&#xA;            sqlMapClient = SqlMapClientBuilder.buildSqlMapClient(reader);&#xA;            reader.close();&#xA;        }&#xA;        public List&amp;lt;Student&amp;gt; queryAllStudent(){&#xA;            List&amp;lt;Student&amp;gt; studentList = sqlMapClient.queryForList(&amp;quot;selectAllStudent&amp;quot;);&#xA;            return studentList;&#xA;        }&#xA;        @Test&#xA;        public void testHere(){&#xA;            for(Student student: this.queryAllStudent()){&#xA;                System.out.println(student.getName);&#xA;            }&#xA;        }&#xA;配置&#xA;    sqlMapConfig.xml&#xA;        mybatis加载属性顺序&#xA;            properties中property中的属性&#xA;            properties中resource或url中的属性&#xA;            parameterType中传递一属性&#xA;                # properties中配的属性会影响到mapper.xml中${}的sql拼接，因为都是ognl&#xA;        配置标签&#xA;            properties&#xA;            settings&#xA;                # ibatis有性能优化的参数，mybatis会自动调优，不用设置了&#xA;            typeAliases&#xA;                # 针对parameterType和resultType指定的类型定义别名&#xA;                # java.lang.Integer在mybatis中默认别名为int&#xA;            typeHandlers&#xA;                # 类型处理器，jdbc类型和java类型的转换&#xA;                ## 一般mybatis提供的类型处理器够用了&#xA;            objectFactory&#xA;            plugins&#xA;            environments&#xA;            mappers&#xA;    mapper.xml&#xA;        内容&#xA;            #{}接收简单类型, pojo的ognl属性注入&#xA;            ${}是字符串的拼接&#xA;&#xA;        SELECT * FROM USER WHERE id=#{id}&#xA;        SELECT * FROM USER WHERE username LIKE &#39;%${value}%&#39;&#xA;            # sql 注入&#xA;    输入输出映射&#xA;        parameterType&#xA;            java类型&#xA;            hashmap&#xA;                # #{key}来取value&#xA;            pojo&#xA;            包装类型&#xA;        resultType&#xA;                # 指定一条数据的类型，在java方法的返回类型中list或pojo来体现数据条数&#xA;                # mybatis判断mapper代理中使用selectOne或者selectType&#xA;            pojo&#xA;                # 返回字段可以是别名，但要与pojo中的属性名相同&#xA;                ## 如果有记录返回但没有pojo中匹配的属性名对应，则直接不创建该对象&#xA;            java类型&#xA;                # 在返回结果只有一行一列时，可以是简单类型&#xA;            hashmap&#xA;                # key是字段的字，value是字段的值&#xA;                ## 多条数据时，list里面存hashmap&#xA;        resultMap&#xA;            # 查询出来的字段名与pojo属性名不一致&#xA;            定义resultMap&#xA;            使用resultMap&#xA;    动态sql&#xA;        &amp;lt;where&amp;gt;&#xA;        &amp;lt;if&amp;gt;&#xA;&#xA;        sql片段&amp;lt;sql&amp;gt;&#xA;&#xA;        &amp;lt;foreach&amp;gt;&#xA;    高级映射&#xA;    缓存&#xA;    逆向&#xA;        要求&#xA;            1. mapper.xml中namespace 写mapper接口&#xA;                &amp;lt;mapper namespace=&amp;quot;com.otr.tea.mapper.UserMapper&amp;quot;&amp;gt;&#xA;            2. mapper.java中方法名与mapper.xml的statementid一致&#xA;            3. mapper.java中方法的输入类型与mapper.xml中的parameterType一致&#xA;                # 由于传入的参数只有一个，所以用包装类型的pojo来传多个参数，不利于业务层的可扩展性&#xA;            4. mapper.java中方法的返回类型与mapper.xml中的resultType一致&#xA;        机制&#xA;            如果Mapper中返回类型为pojo, 则调用selectOne, 如果是List, 则调用selectList&#xA;api&#xA;    sqlSessionFactory&#xA;    sqlSession                        # 是线程不安全的，因为它的类中有数据和属性&#xA;                                    ＃ 是多例的，在方法中局部变量使用&#xA;        Executor                # 执行器操作数据库（基本执行器，缓存执行器）&#xA;    mapped statement                # 封装sql语句、输入参数、输出结果类型&#xA;&#xA;    例子&#xA;        InputStream is = Resources.getResourceAsStream(&amp;quot;SqlMapConfig.xml&amp;quot;);&#xA;            # Resources是mybatis提供的资源加载类&#xA;        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);&#xA;        SqlSession sqlSession = factory.openSession();&#xA;        User user = sqlSession.selectOne(&amp;quot;test.findUserById&amp;quot;, 1);&#xA;            ＃ selectList()&#xA;            # insert(&amp;quot;test.insertUser&amp;quot;, user)&#xA;            ## sqlSession.commit();&#xA;            ## user.getId() 会主键返回&#xA;            ### mysql中LAST_INSERT_ID()在insert语句后接着执行可以得到刚刚自成的id&#xA;        sqlSession.close();&#xA;案例&#xA;    返回id&#xA;        mysql&#xA;            &amp;lt;insert id=&amp;quot;insert&amp;quot; parameterType=&amp;quot;com.test.User&amp;quot; keyProperty=&amp;quot;userId&amp;quot; useGeneratedKeys=&amp;quot;true&amp;quot; &amp;gt;&#xA;        oracle&#xA;            &amp;lt;insert id=&amp;quot;insert&amp;quot; parameterType=&amp;quot;com.test.User&amp;quot;&amp;gt;&#xA;                &amp;lt;selectKey resultType=&amp;quot;INTEGER&amp;quot; order=&amp;quot;BEFORE&amp;quot; keyProperty=&amp;quot;userId&amp;quot;&amp;gt;&#xA;                    SELECT SEQ_USER.NEXTVAL as userId from DUAL&#xA;                &amp;lt;/selectKey&amp;gt;&#xA;&#xA;                insert into user (user_id, user_name, modified, state)&#xA;                values (#{userId,jdbcType=INTEGER}, #{userName,jdbcType=VARCHAR},&#xA;                #{modified,jdbcType=TIMESTAMP}, #{state,jdbcType=INTEGER})&#xA;            &amp;lt;/insert&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-struts2&#34;&gt;&#xA;  spring struts2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-struts2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    tomcat启动日志：没有整合时不能加载struts-plugin.xml（spring-struts-plugin.jar包中的配置文件 ）&#xA;    struts中struts-default中常量配置加载com.opensymphony.xword2.ObjectFactory类作为默认struts创建action的类&#xA;    加载后struts-plugin.xml 中 修改了常量为struts-spring-plugin中的类来创建struts的类，也就是整个struts2创建action类的类被更改了&#xA;&#xA;整合&#xA;    jar包 struts2/lib/struts2-spring-plugin-2.3.1.1.jar                        # 为了在struts的xml配置文件中的class找spring 的容器&#xA;    配置web.xml   # \samples\petclinic\war\WEB-INF\web.xml目录下有示例&#xA;                                            &#xA;        &amp;lt;listener&amp;gt;          # 监听器，web程序启动时加载spring bean&#xA;        &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&#xA;        &amp;lt;context-param&amp;gt;     # （可选）配置spring 配置文件的路径，&#xA;                            ## 从示例文件中查到，默认文件目录是/WEB-INF/applicationContext.xml(我们示例文件也是从源码/simple项目下的这个开头的文件中找的)&#xA;            &amp;lt;param-name&amp;gt;contextConfigLocation&#xA;            &amp;lt;param-value&amp;gt;/WEB-INF/classes/struts2/xxx.xml&#xA;    UserAction 中    # 不用值栈是因为通用性&#xA;    spring.xml        # action类由spring 产生&#xA;        &amp;lt;bean id=&amp;quot;userActionID&amp;quot; class=&amp;quot;&amp;quot; scope=&amp;quot;prototype&amp;quot;/&amp;gt;&#xA;    struts2的配置文件中，替换class属性为spring beanid，其它一样&#xA;总结&#xA;    spring的web配置是由下向上，一个个依赖注入的过程&#xA;        comboPooledDataSourceID -&amp;gt;&#xA;        localSessionFactoryBeanID -&amp;gt;&#xA;        hibernateTemplateID -&amp;gt;&#xA;        SysStaffDaoID -&amp;gt;&#xA;        SysStaffServiceID -&amp;gt;&#xA;        SysStaffActionID -&amp;gt;&#xA;        struts.xml配置中的&amp;lt;action class=&amp;quot;SysStaffActionID&amp;quot;&amp;gt;&#xA;    最后给Dao中的方法加入事务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;spring-mvc&#34;&gt;&#xA;  spring mvc&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-mvc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;原理&#xA;    DispatchServlet doService()捕获请求, doDispatch()用HandlerMapping映射url得到HandlerExcutionChain(执行链, 包括拦截器和handler)&#xA;    handler getHandlerAdapter得到适配器来处理handler, 返回ModelAndView&#xA;        # HandlerAdapter分三类: Servlet、Controller, HttpRequest&#xA;    DispatchServlet用ViewResolver(视图解析器)解析ModelAndView成View&#xA;        # ModelAndView是逻辑视图，DispatchServlet转化成视图View&#xA;    返回View&#xA;与struts2区别&#xA;    spring mvc方法对应请求, struts2是类&#xA;    spring mvc请求是方法调用，struts2创建Action实例&#xA;    spring mvc用aop处理请求，struts2用独有的拦截器(interceptor)&#xA;    spring mvc入口是servlet, struts2入口是filter&#xA;    spring mvc集成ajax(@ResponseBody), struts2需要插件&#xA;    spring mvc验证支持JSR303, struts2不支持&#xA;    spring mvc与spring无缝&#xA;    spring mvc不需要配置&#xA;注解&#xA;    @RequestMapping             # url映射&#xA;    @RequestBody                # 转换参数到对象&#xA;    @ResponseBody               # 返回对象转json&#xA;&#xA;    开启注解处理器&#xA;        springmvc.xml&#xA;            &amp;lt;mvc:annotation-driven&amp;gt;&#xA;乱码问题&#xA;    post&#xA;        web.xml中配置CharacterEncodingFilter&#xA;    get&#xA;        tomcat配置文件修改项目编码&#xA;        new String(Request.getParameter(&amp;quot;a&amp;quot;).getBytes(&amp;quot;ISO8859-1&amp;quot;), &amp;quot;utf-8&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;quartz定时器&#34;&gt;&#xA;  quartz:定时器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#quartz%e5%ae%9a%e6%97%b6%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;执行：ApplicationContext类加载后自动执行&#xA;导包：quartz-all.jar包 与  commons-collections.jar包 与 commons-logging.jar&#xA;xml配置：&#xA;    &amp;lt;!-- 任务类 ,其中有个叫execute的方法--&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;myTaskID&amp;quot; class=&amp;quot;jee.quartz.MyTask&amp;quot;/&amp;gt;&#xA;&#xA;    &amp;lt;!-- spring提供专用于定时任务类 --&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;methodInvokingJobDetailFactoryBeanID&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&amp;quot;&amp;gt;&#xA;        &amp;lt;!-- 要定时执行的实例的spring bean id --&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;targetObject&amp;quot;&amp;gt;&#xA;                &amp;lt;ref bean=&amp;quot;myTaskID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;!-- spring bean中定时执行的方法 --&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;targetMethod&amp;quot;&amp;gt;&#xA;                &amp;lt;value&amp;gt;execute&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;!-- spring提供专用于任务频率类，给上面的任务指定频率 --&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;cronTriggerBeanID&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.CronTriggerBean&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;jobDetail&amp;quot;&amp;gt;&#xA;                &amp;lt;ref bean=&amp;quot;methodInvokingJobDetailFactoryBeanID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;cronExpression&amp;quot;&amp;gt;&#xA;                &amp;lt;value&amp;gt;0 0/1 * * * ?&amp;lt;/value&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;    &amp;lt;!-- spring提供的专用于任务频率工厂类 --&amp;gt;&#xA;    &amp;lt;bean id=&amp;quot;schedulerFactoryBeanID&amp;quot; class=&amp;quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&amp;quot;&amp;gt;&#xA;        &amp;lt;property name=&amp;quot;triggers&amp;quot;&amp;gt;&#xA;            &amp;lt;ref bean=&amp;quot;cronTriggerBeanID&amp;quot;/&amp;gt;&#xA;        &amp;lt;/property&amp;gt;&#xA;    &amp;lt;/bean&amp;gt;&#xA;任务频率cronTriggerBean的配置：&#xA;    cron解析器:&#xA;        反斜线（/）字符表示增量值。例如，在秒字段中“5/15”代表从第 5 秒开始，每 15 秒一次。&#xA;        问号（?）字符和字母 L 字符只有在月内日期和周内日期字段中可用。问号表示这个字段不包含&#xA;        具体值。&#xA;        所以，如果指定月内日期，可以在周内日期字段中插入“?”，表示周内日期值无关紧要。字母&#xA;        L 字符是 last 的缩写。放在月内日期字段中，表示安排在当月最后一天执行。在周内日期字&#xA;        段中，如果“L”单独存在，就等于“7”，否则代表当月内周内日期的最后一个实例。所以“0L”&#xA;        表示安排在当月的最后一个星期日执行。&#xA;        在月内日期字段中的字母（W）字符把执行安排在最靠近指定值的工作日。把“1W”放在月内&#xA;        日期字段中，表示把执行安排在当月的第一个工作日内。&#xA;        井号（#）字符为给定月份指定具体的工作日实例。把“MON#2”放在周内日期字段中，表示把任&#xA;        务安排在当月的第二个星期一。&#xA;        星号（*）字符是通配字符，表示该字段可以接受任何可能的值。&#xA;    顺序：秒 分 时 日 月 周 年（年可以忽略）&#xA;    例子&#xA;        0 0 10,14,16 * * ?                  每天上午10点，下午2点，4点&#xA;        0 0/30 9-17 * * ?            朝九晚五工作时间内每半小时&#xA;        0 0 12 ? * WED                          表示每个星期三中午12点&#xA;        0 0 12 * * ?                          每天中午12点触发&#xA;        0 15 10 ? * *                          每天上午10:15触发&#xA;        0 15 10 * * ?                          每天上午10:15触发&#xA;        0 15 10 * * ? *                  每天上午10:15触发&#xA;        0 15 10 * * ? 2013          2013年的每天上午10:15触发&#xA;        0 * 14 * * ?                          在每天下午2点到下午2:59期间的每1分钟触发&#xA;        0 0/5 14 * * ?                          在每天下午2点到下午2:55期间的每5分钟触发&#xA;        0 0/5 14,18 * * ?                  在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发&#xA;        0 0-5 14 * * ?                          在每天下午2点到下午2:05期间的每1分钟触发&#xA;        0 10,44 14 ? 3 WED                  每年三月的星期三的下午2:10和2:44触发&#xA;        0 15 10 ? * MON-FRI                周一至周五的上午10:15触发&#xA;        0 15 10 15 * ?                          每月15日上午10:15触发&#xA;        0 15 10 L * ?                            每月最后一日的上午10:15触发&#xA;        0 15 10 ? * 6L                    每月的最后一个星期五上午10:15触发&#xA;        0 15 10 ? * 6L 2014-2018        2014年至2018年的每月的最后一个星期五上午10:15触发&#xA;        0 15 10 ? * 6#3                        每月的第三个星期五上午10:15触发&#xA;        0/1 * * * * ?                        每秒钟触发一次&#xA;        0 0/1 * * * ?                        每分钟解发一次&#xA;        0 0 0/1 * * ?                        每小时解发一次&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;远程调用&#34;&gt;&#xA;  远程调用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9c%e7%a8%8b%e8%b0%83%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# rmi:remote message invoke&#xA;服务端&#xA;    1.自定义接口IServer,自定义抽象方法int rax(int)&#xA;    2.写接口实现类ServerImpl&#xA;    3.配置spring.xml 文件&#xA;        &amp;lt;!-- 服务端实现类 --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;serverImplID&amp;quot; class=&amp;quot;jee.server.ServerImpl&amp;quot;/&amp;gt;&#xA;        &amp;lt;!-- spring提供的专用于RMI服务端注册器 --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;rmiServiceExporterID&amp;quot; class=&amp;quot;org.springframework.remoting.rmi.RmiServiceExporter&amp;quot;&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;serviceInterface&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;jee.server.IServer&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;service&amp;quot;&amp;gt;&#xA;                    &amp;lt;ref bean=&amp;quot;serverImplID&amp;quot;/&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;serviceName&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;XXXX&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;客户端&#xA;    配置spring.xml 文件&#xA;        &amp;lt;!-- spring提供专用于RMI远程服务代理工厂类 --&amp;gt;&#xA;        &amp;lt;bean id=&amp;quot;rmiProxyFactoryBeanID&amp;quot; class=&amp;quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&amp;quot;&amp;gt;&#xA;            &amp;lt;!-- 协议名://远程提供服务的IP地址:提供服务的端口/提供服务的名称 --&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;serviceUrl&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;rmi://127.0.0.1:1099/XXXX&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;            &amp;lt;property name=&amp;quot;serviceInterface&amp;quot;&amp;gt;&#xA;                    &amp;lt;value&amp;gt;jee.client.IServer&amp;lt;/value&amp;gt;&#xA;            &amp;lt;/property&amp;gt;&#xA;        &amp;lt;/bean&amp;gt;&#xA;执行：&#xA;    服务端加载 ApplicationContext类&#xA;    客户端&#xA;        加载 ApplicationContext类 ac&#xA;        ac.getBean方法中得到RmiProxyFactoryBean实际类型（可变类型）的实例，强转成服务端自定义的接口IServer的实现类（实现类由服务器决定）&#xA;        执行IServer实现类中的方法int rax(int)，实现了远程调用&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;websocket&#34;&gt;&#xA;  websocket&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#websocket&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;handler&#xA;    extends TextWebSocketHandler&#xA;        @Override&#xA;        handleTextMessge()                      # 处理client.send()的数据&#xA;&#xA;        @Override&#xA;        afterConnectionEstablished(WebSocketSession)                    # 连接事件&#xA;&#xA;        @Override&#xA;        handleTransportError()                  # 出错事件&#xA;&#xA;        @Override&#xA;        afterConnectionClosed()                 # 断开事件&#xA;&#xA;        @Override&#xA;        supportsPartialMessages()               # 并行处理&#xA;config&#xA;    @EnableWebSocket&#xA;    implements WebSocketConfigurer&#xA;        @Override&#xA;        registerWebSocketHandlers()&#xA;            registry.addHandler(handler, &amp;quot;/ws&amp;quot;)                         # 路由handler&#xA;client&#xA;    extends WebSocketClient&#xA;        constructor(uri)&#xA;            super(new URI(uri))&#xA;&#xA;        @Override&#xA;        onOpen()&#xA;&#xA;        @Override&#xA;        onClose()&#xA;&#xA;        @Override&#xA;        onError()&#xA;&#xA;        @Override&#xA;        onMessage()&#xA;service&#xA;    init()&#xA;        client = new Client(&amp;quot;ws://127.0.0.1:8001/ws&amp;quot;)&#xA;        client.connectBlocking()&#xA;    send()&#xA;        while(!client.getReadyState().equals(ReadyState.OPEN)){&#xA;            log(&amp;quot;connecting&amp;quot;)&#xA;        }&#xA;        client.send(&amp;quot;&amp;quot;)&#xA;runner&#xA;    implements ApplicationRunner&#xA;        run()&#xA;            service.init()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-boot&#34;&gt;&#xA;  spring boot&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    减少配置, 习惯大于配置&#xA;    支持groovy, gradle&#xA;命令&#xA;    java -jar xxx.jar&#xA;        --server.port=8080                                      # --后内容，相当于application.yml设置&#xA;        --spring.profiles.active=two                            # 选择applicaton-two.yml配置&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;基础文件&#34;&gt;&#xA;  基础文件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;目录&#xA;    src&#xA;        main&#xA;            java&#xA;                com.outrun&#xA;                    XxxApplication&#xA;            resources&#xA;                static/&#xA;                templates/&#xA;                application.properties&#xA;                application.yml&#xA;            webapp&#xA;                WEB-INF&#xA;        test&#xA;            java&#xA;                com.outrun&#xA;                    XxxApplicationTests&#xA;    pom.xml&#xA;XxxApplication.java                                     # 程序入口&#xA;    @SpringBootApplication                              # 类，组合@Configuration, @EnableAutoConfiguration, @ComponentScan&#xA;        @EnableAutoConfiguration根据jar包依赖自动配置&#xA;        扫描该注解同级下级包的Bean&#xA;application.yml                                         # application.yml或application.properties, 放在src/main/resources或config目录下&#xA;pom.xml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;配置&#34;&gt;&#xA;  配置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;区分环境&#xA;    application-{profile}.properties                                    # profile比如是dev, test, prod&#xA;    设置spring.profiles.active=dev来区分&#xA;加载顺序                                                                 # 为了外部人员维护，可覆盖定义&#xA;    命令行&#xA;    SPRING_APPLICATION_JSON环境变量, json格式&#xA;    java:comp/env的JNDI属性&#xA;    java系统属性                                                         # System.getProperties()查看&#xA;    系统环境变量&#xA;    random.*配置的随机属性&#xA;    jar包外文件名, 如application-{profile}.properties&#xA;    jar包内文件名&#xA;    @Configuration注解类中，@PropertySource修改的属性&#xA;    SpringApplication.setDefaultProperties定义的内容&#xA;application.yml&#xA;    ---                                                 # ---分隔多个配置，这里相当于建立了application-two.yml文件&#xA;    spring:&#xA;        profiles: two&#xA;    ---&#xA;    spring:&#xA;        profiles&#xA;            active: dev                                 # 配置环境, 加载applicaton-dev.yml&#xA;        application:&#xA;            name: app1&#xA;pom.xml&#xA;    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;                          # 不用war包部署, 嵌入了tomcat, jar可服务&#xA;    &amp;lt;parent&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;             # 提供spring boot基础依赖和默认配置&#xA;        &amp;lt;relativePath/&amp;gt;                                 # 从仓库查找parent&#xA;    &amp;lt;/parent&amp;gt;&#xA;    &amp;lt;properties&amp;gt;&#xA;        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;&#xA;        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;&#xA;        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;&#xA;    &amp;lt;/properties&amp;gt;&#xA;    &amp;lt;dependencies&amp;gt;&#xA;    &amp;lt;/dependencies&amp;gt;&#xA;    &amp;lt;build&amp;gt;&#xA;        &amp;lt;plugins&amp;gt;&#xA;            &amp;lt;plugin&amp;gt;&#xA;                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;       # 方便启动停止应用, 如mvn spring-boot:run&#xA;            &amp;lt;/plugin&amp;gt;&#xA;        &amp;lt;/plugins&amp;gt;&#xA;    &amp;lt;/build&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;注解-1&#34;&gt;&#xA;  注解&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e8%a7%a3-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;@SpringBootApplication                      # spring boot 启动类&#xA;    组合了@Configuration, @EnableAutoConfiguration, @ComponentScan&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类&#34;&gt;&#xA;  类&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;ApplicationRunner                           # 继承该类，注解@Component, 随容器启动运行&#xA;    run()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;插件&#34;&gt;&#xA;  插件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;maven&#34;&gt;&#xA;  maven&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#maven&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;命令&#xA;    mvn spring-boot:run&#xA;pom.xml&#xA;    &amp;lt;plugin&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;       # 方便启动停止应用, 如mvn spring-boot:run&#xA;    &amp;lt;/plugin&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;组件&#34;&gt;&#xA;  组件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%84%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;starter POMs            # spring-boot-starter开头的组件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;子域&#34;&gt;&#xA;  子域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%90%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;namedcontextfactory&#34;&gt;&#xA;  NamedContextFactory&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#namedcontextfactory&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Spec1 implements NamedContextFactory.Specification {&#xA;    @Override&#xA;    public String getName(){}&#xA;    @Override&#xA;    public Class&amp;lt;?&amp;gt;[] getConfiguration(){}&#xA;}&#xA;public class MyFactory extends NamedContextFactory&amp;lt;Specification1&amp;gt; {&#xA;    public MyFactory(Class&amp;lt;?&amp;gt; clazz) {&#xA;        super(clazz, &amp;quot;my&amp;quot;, &amp;quot;my.name&amp;quot;)&#xA;    }&#xA;}&#xA;@Configuration&#xA;public class Config0 {&#xA;    @Bean&#xA;    Bean0 getBean(){&#xA;        return new Bean0()&#xA;    }&#xA;}&#xA;&#xA;parent = new AnnotationConfigApplicationContext()&#xA;parent.register(Config0.class)&#xA;parent.refresh()&#xA;factory = new MyFactory(Config00.class)&#xA;factory.setApplicationContext(parent) &#xA;&#xA;spec1 = new Spec1(&amp;quot;1&amp;quot;, new Class[]{Config1.class})&#xA;factory.setConfigurations(List.of(spec1))&#xA;factory.getInstance(&amp;quot;1&amp;quot;, Bean0.class)   // 子域共享&#xA;factory.getInstance(&amp;quot;1&amp;quot;, Bean00.class)  // 子域复制&#xA;factory.getInstance(&amp;quot;1&amp;quot;, Bean1.class)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring&#34;&gt;&#xA;  spring&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;配置&#xA;    随机数用${random}&#xA;        ${random.value} 字符串&#xA;        ${random.int} int&#xA;        ${random.long} long&#xA;        ${random.int(10)} 10以内int&#xA;        ${random.int[10,20]} 10到20 int&#xA;    pom.xml&#xA;        &amp;lt;dependency&amp;gt;&#xA;            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;            &amp;lt;artifactId&amp;gt;spring-boot-configuration-processor&amp;lt;/artifactId&amp;gt;&#xA;            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;&#xA;        &amp;lt;/dependency&amp;gt;&#xA;    application.yml&#xA;        aa&#xA;            bb: 1                                           # 可用properties类管理属性&#xA;        xxx: 1                                              # 自定义value&#xA;            配置文件中用&amp;quot;${xxx}&amp;quot;引用&#xA;            类中用@Value(&amp;quot;${xxx}&amp;quot;)注入到属性&#xA;            SpEL中用&amp;quot;#{xxx}&amp;quot;引用&#xA;    AaProperties.java&#xA;        @Component&#xA;        @ConfigurationProperties(prefix = &amp;quot;aa&amp;quot;)&#xA;        public class AaProperties {&#xA;            private String bb;&#xA;            ...getter和setter...&#xA;        }&#xA;    注解    &#xA;        @Configuration&#xA;        @PropertySource(value = &amp;quot;classpath:test.properties&amp;quot;)                    # 加载文件, 配合@ConfigurationProperties注入属性&#xA;        @EnableConfigurationProperties({ConfigBean.class, User.class})          # 加载bean, 配合@Autowired注入&#xA;基础&#xA;    注解&#xA;        @Value(&amp;quot;${xxx}&amp;quot;)&#xA;        @Autowired                                  # 装载bean&#xA;        @Bean                                       # 实例化Bean, 属性名为方法名&#xA;            @Bean&#xA;            public RestTemplate restTemplate() {&#xA;                return new RestTemplate();&#xA;            }&#xA;            相当于&#xA;            RestTemplate restTemplate = new RestTemplate();&#xA;        @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)                         # 生命周期&#xA;            singleton                               # 单例&#xA;            prototype                               # 多例&#xA;            request                                 # web程序ContextApplication用, 随请求创建&#xA;            session                                 # web程序ContextApplication用, 随session创建&#xA;            global session                          # porlet的global用, 其它用降级为session&#xA;        @EventListener(XxxEvent.class)              # 修饰方法, 外部publishEvent()时触发&#xA;实体&#xA;    注解&#xA;        @Entity                                     # 修饰bean类&#xA;        @Id                                         # id属性&#xA;        @GeneratedValue(strategy=GenerationType.AUTO)                           # 自增属性&#xA;        @Column(nullable = false, unique = true)&#xA;组件&#xA;    注解&#xA;        @Component&#xA;        @ConfigurationProperties(prefix = &amp;quot;my&amp;quot;)     # 注入properties对应名称的属性&#xA;dao&#xA;    注解&#xA;        @Repository                                 # 修饰类&#xA;service&#xA;    注解&#xA;        @Service                                    # 修饰类&#xA;        @PostConstruct                              # 修饰方法, 加载servlet时, init()前执行&#xA;        @PreDestroy                                 # 修饰方法, 销毁servlet时, destroy()后执行&#xA;controller&#xA;    注解&#xA;        @Controller                                 # 修饰类&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;测试&#34;&gt;&#xA;  测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;注解&#xA;    @Before&#xA;    @Test&#xA;    @RunWith(SpringRunner.class)                # 修饰类, 测试spring&#xA;    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)                 # 修饰类, 测试spring boot&#xA;    @LocalServerPort                            # 注入端口号&#xA;    @AutoConfigureMockMvc                       # 使用mockMvc, 用@Autowired注入MockMvc&#xA;    @WebAppConfiguration                                # 模拟ServletContext&#xA;XxxApplicationTests.java                        # junit测试&#xA;    @RunWith(SpringJUnit4ClassRunner.class)&#xA;    @SpringApplicationConfiguration(classes = XxxApplication.class)&#xA;    @WebAppConfiguration&#xA;    public class XxxApplicationTests {&#xA;        private MockMvc mvc;&#xA;        @Before&#xA;        public void setUp() throws Exception {&#xA;            mvc = MockMvcBuilders.standaloneSetup(new XxxController()).build();&#xA;        }&#xA;        @Test&#xA;        public void hello() throws Exception {&#xA;            mvc.perform(MockMvcRequestBuilders.get(&amp;quot;/hello&amp;quot;).accept(MediaType.APPLICATION_JSON))&#xA;                .addExpect(status().isOk())&#xA;                .addExpect(content().string(equalTo(&amp;quot;hello&amp;quot;)));&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数据库&#34;&gt;&#xA;  数据库&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e5%ba%93&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    spring-boot-starter-jdbc&#xA;    spring-boot-starter-data-jpa                            # spring data JPA&#xA;application.yml&#xA;    jpa:&#xA;        generate-ddl: false&#xA;        show-sql: true&#xA;        hibernate:&#xA;            ddl-auto: none                          # create时, 第一次create之后update&#xA;    datasource:&#xA;        platform: h2&#xA;        schema: classpath:schema.sql                # 建表&#xA;        data: classpath:data.sql                    # 数据&#xA;注解&#xA;    @Transactional                                  # 修饰方法，开启事务，或在事务中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;mybatis&#34;&gt;&#xA;  mybatis&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mybatis&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;!-- mybatis --&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;    &amp;lt;!-- mysql --&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;version&amp;gt;5.1.21&amp;lt;/version&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;application.yml&#xA;    spring:&#xA;        datasource:&#xA;            url: jdbc:mysql://127.0.0.1:3306/outrun?characterEncoding=UTF-8&#xA;            username: root&#xA;            password: asdf&#xA;            driver-class-name: com.mysql.jdbc.Driver&#xA;        jpa:&#xA;        hibernate:&#xA;            ddl-auto: update  # 新建连接必要&#xA;    mybatis:&#xA;        mapper-locations: classpath:mapper/*.xml        # 指定mapper.xml位置&#xA;&#xA;&#xA;mapper.xml                      # 用mbg生成&#xA;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&#xA;    &amp;lt;!DOCTYPE mapper PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;&#xA;    &amp;lt;mapper namespace=&amp;quot;com.outrun.erp.mapper.UserMapper&amp;quot;&amp;gt;&#xA;&#xA;        &amp;lt;resultMap id=&amp;quot;BaseResultMap&amp;quot; type=&amp;quot;com.outrun.erp.entities.User&amp;quot;&amp;gt;&#xA;            &amp;lt;id column=&amp;quot;id&amp;quot; jdbcType=&amp;quot;BIGINT&amp;quot; property=&amp;quot;id&amp;quot; /&amp;gt;&#xA;            &amp;lt;result column=&amp;quot;name&amp;quot; jdbcType=&amp;quot;VARCHAR&amp;quot; property=&amp;quot;name&amp;quot; /&amp;gt;&#xA;        &amp;lt;/resultMap&amp;gt;&#xA;&#xA;        &amp;lt;select id=&amp;quot;selectUserById&amp;quot; parameterType=&amp;quot;long&amp;quot; resultMap=&amp;quot;UserMap&amp;quot;&amp;gt;&#xA;            SELECT name FROM user WHERE id=#{userId}&#xA;        &amp;lt;/select&amp;gt;&#xA;&#xA;        &amp;lt;insert id=&amp;quot;inserUser&amp;quot;&amp;gt;&#xA;            &amp;lt;selectKey keyProperty=&amp;quot;id&amp;quot; resultType=&amp;quot;int&amp;quot; order=&amp;quot;BEFORE&amp;quot;&amp;gt;&#xA;                select field1 from seq1&#xA;            &amp;lt;/selectKey&amp;gt;&#xA;        &amp;lt;/insert&amp;gt;&#xA;&#xA;        &amp;lt;sql id=&amp;quot;userColumns&amp;quot;&amp;gt;&#xA;            ${alias}.id, ${alias}.username&#xA;        &amp;lt;/sql&amp;gt;&#xA;        &amp;lt;select id=&amp;quot;selectColumns&amp;quot; resultType=&amp;quot;map&amp;quot;&amp;gt;&#xA;            select&#xA;                &amp;lt;include refid=&amp;quot;userColumns&amp;quot;&amp;gt;&amp;lt;property name=&amp;quot;alias&amp;quot; value=&amp;quot;tb1&amp;quot;/&amp;gt;&amp;lt;/include&amp;gt;&#xA;            from tb1&#xA;        &amp;lt;/select&amp;gt;&#xA;&#xA;        &amp;lt;select id=&amp;quot;dynamicSql&amp;quot; resultType=&amp;quot;User&amp;quot;&amp;gt;&#xA;            select * from user&#xA;            where state = 0&#xA;            &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;&#xA;                and title like #{title}&#xA;            &amp;lt;/if&amp;gt;&#xA;&#xA;            &amp;lt;choose&amp;gt;&#xA;                &amp;lt;when test=&amp;quot;title != null&amp;quot;&amp;gt;&#xA;                    and title like #{title}&#xA;                &amp;lt;/when&amp;gt;&#xA;                &amp;lt;when test=&amp;quot;author != null and author.name != null&amp;quot;&amp;gt;&#xA;                    and author_name like ${author.name}&#xA;                &amp;lt;/when&amp;gt;&#xA;                &amp;lt;otherwise&amp;gt;&#xA;                    and featured = 1&#xA;                &amp;lt;/otherwise&amp;gt;&#xA;            &amp;lt;/choose&amp;gt;&#xA;&#xA;            &amp;lt;foreach item=&amp;quot;item&amp;quot; index=&amp;quot;index&amp;quot; collection=&amp;quot;list&amp;quot; open=&amp;quot;(&amp;quot; separator=&amp;quot;,&amp;quot; close=&amp;quot;)&amp;quot;&amp;gt;&#xA;                #{item}&#xA;            &amp;lt;/foreach&amp;gt;&#xA;&#xA;            &amp;lt;trim prefix=&amp;quot;where&amp;quot; prefixOverrides=&amp;quot;and | or&amp;quot;&amp;gt;&#xA;                ...&#xA;            &amp;lt;/trim&amp;gt;&#xA;&#xA;            &amp;lt;bind name=&amp;quot;a&amp;quot; value=&amp;quot;&#39;%&#39; + _data.getTitle() + &#39;%&#39;&amp;quot; /&amp;gt;&#xA;            select * from blog&#xA;            where title like #{a}&#xA;        &amp;lt;/select&amp;gt;&#xA;&#xA;        &amp;lt;update&amp;gt;&#xA;            update User&#xA;                &amp;lt;set&amp;gt;&#xA;                    &amp;lt;if test=&amp;quot;username != null&amp;quot;&amp;gt;username=#{username},&amp;lt;/if&amp;gt;&#xA;                &amp;lt;/set&amp;gt;&#xA;        &amp;lt;/update&amp;gt;&#xA;&#xA;        &amp;lt;cache&amp;gt;                 # 该命名空间缓存&#xA;        &amp;lt;cache-ref&amp;gt;             # 引用其它命名空间缓存&#xA;        &amp;lt;delete&amp;gt;&#xA;        &amp;lt;resultMap&amp;gt;&#xA;            &amp;lt;constructor&amp;gt;       # 构造方法&#xA;                &amp;lt;idArg&amp;gt;         # id参数, 标记id帮助提高性能&#xA;                &amp;lt;arg&amp;gt;           # 普通参数&#xA;            &amp;lt;/constructor&amp;gt;&#xA;            &amp;lt;id&amp;gt;                # 标记id帮助提高性能&#xA;            &amp;lt;result&amp;gt;            # 普通字段&#xA;            &amp;lt;association&amp;gt;       # 关联&#xA;            &amp;lt;collection&amp;gt;        # 结构体&#xA;            &amp;lt;discriminator&amp;gt;     # 自动映射&#xA;        &amp;lt;/resultMap&amp;gt;&#xA;    &amp;lt;/mapper&amp;gt;&#xA;mapper/UserMapper&#xA;    @Mapper           # 如果扫描mapper.xml，不用加@Mapper&#xA;    public interface UserMapper {&#xA;        List&amp;lt;User&amp;gt; selectUserById(@Param(&amp;quot;userId&amp;quot;) long userId)&#xA;&#xA;        @Select(&amp;quot;select * from user&amp;quot;)&#xA;        List&amp;lt;User&amp;gt; findAll();&#xA;    }&#xA;entities/User&#xA;    public class User {&#xA;        private Integer id;&#xA;        private String name;&#xA;        ...getter, setter...&#xA;    }&#xA;注解&#xA;    @Table(name = &amp;quot;user&amp;quot;)                   # 修饰类，指定表&#xA;    @Id                                     # 修饰属性, 指定主键&#xA;    @Column(name = &amp;quot;name&amp;quot;)                  # 修饰属性, 指定字段&#xA;&#xA;    @Mapper                                 # 修饰类&#xA;    @Select(&amp;quot;select * from user&amp;quot;)           # 修饰方法&#xA;    @Param(&amp;quot;userId&amp;quot;)                        # 修饰参数&#xA;api&#xA;    SqlSessionFactory&#xA;        build&#xA;        openSession                         # 重载事务方法&#xA;    SqlSesion&#xA;        selectOne()&#xA;        selectList()&#xA;        selectMap()&#xA;        insert()&#xA;        update()&#xA;        delete()&#xA;        commit()&#xA;        rollback()&#xA;        clearCache()&#xA;        close()&#xA;    Mapper&#xA;        o-&amp;gt;&#xA;        @Insert(&amp;quot;insert into tb1(id, name) values(#{id}, #{name})&amp;quot;)&#xA;        @SelectKey(statement=&amp;quot;next value&amp;quot;, keyProperty=&amp;quot;id&amp;quot;, before=true, resultType=int.class)&#xA;        int insertTable1(String name)&#xA;    SQL&#xA;        INSERT_INTO()&#xA;        VALUES()&#xA;&#xA;        o-&amp;gt;&#xA;        new SQL(){{&#xA;            SELECT(&amp;quot;a.name&amp;quot;);&#xA;            SELECT(&amp;quot;a.age&amp;quot;);&#xA;            FROM(&amp;quot;tb1 a&amp;quot;);&#xA;            WHERE(&amp;quot;a.name like ?&amp;quot;);&#xA;        }}.toString()&#xA;    LogFactory&#xA;        useSlf4jLogging()&#xA;        useLog4jLogging()&#xA;        useStdOutLogging()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;web&#34;&gt;&#xA;  web&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#web&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 用的spring mvc&#xA;pom.xml&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;                 # web模块, 有tomcat, spring mvc&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;            # 测试模块, 有JUnit, Hamcrest, Mockito&#xA;    &amp;lt;/dependency&amp;gt;&#xA;application.yml&#xA;    server&#xA;        port: 8080                                      # 默认8080&#xA;        servlet&#xA;            context-path: /hello                        # uri前缀&#xA;静态资源&#xA;    默认映射public, resources, static到/&#xA;注解&#xA;    控制器&#xA;        @RestController                             # 修饰类, 组合@Controller与@responseBody&#xA;        @RequestMapping(&amp;quot;/index&amp;quot;)                   # 修改类或方法, url&#xA;            @GetMapping(&amp;quot;/{id}&amp;quot;)                    # 相当于@RequestMapping(method=RequestMethod.GET)&#xA;            @PostMapping&#xA;            @PutMapping&#xA;            @DeleteMapping&#xA;            @PatchMapping&#xA;        @CrossOrigin                                # 修饰方法, 允许跨域&#xA;        @RequestBody                                # 修饰方法, 解析body到参数&#xA;        @PathVariable Long id                       # 修饰参数, 接收url参数&#xA;内置对象&#xA;    ServerProperties                                # 单例可@Autowired, 存端口之类属性&#xA;自实现&#xA;    XxxController.java&#xA;        @RestController&#xA;        public class HelloController {&#xA;            @RequestMapping(&amp;quot;/hello&amp;quot;)&#xA;            public String index() {&#xA;                return &amp;quot;hello&amp;quot;;&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;日志&#34;&gt;&#xA;  日志&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    logging:&#xA;        level:&#xA;            root: INFO&#xA;            org.hibernate: INFO&#xA;            org.hibernate.type.descriptor.sql.BasicBinder: TRACE&#xA;            org.hibernate.type.descriptor.sql.BasicExtractor: TRACE&#xA;注解&#xA;    @Slf4j                                      # 修饰类，其中可直接用log变量&#xA;    @EnableSwagger2                             # 修饰类&#xA;    @Api(tags = &amp;quot;&amp;quot;)                             # 修饰类, 文档&#xA;    @ApiModel(&amp;quot;&amp;quot;)                               # 修饰类&#xA;    @ApiModelProperty(&amp;quot;)                        # 修饰属性&#xA;    @ApiOperation(value=&amp;quot;&amp;quot;, notes=&amp;quot;&amp;quot;)           # 修改方法, 文档&#xA;    @ApiIgnore                                  # 修饰方法, 文档忽略&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jackson&#34;&gt;&#xA;  jackson&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jackson&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;注解&#xA;    @JsonInclude                                # 修饰类, 序列化时包含&#xA;        @JsonInclude(JsonInclude.Include.NON_EMPTY)                 # null或&amp;quot;&amp;quot;时不序列化&#xA;    @JsonIgnore                                 # 修饰属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;scheduled&#34;&gt;&#xA;  Scheduled&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#scheduled&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;scheduled&#xA;    注解&#xA;        @Scheduled                                  # 修饰方法, 定时调度&#xA;            @Scheduled(initialDelay = 1000, fixedRate = 1000)&#xA;    类&#xA;        @Configuration&#xA;        implements SchedulingConfigurer             # 配置类&#xA;            configureTasks(ScheduledTaskRegistrar)&#xA;                registrar.setScheduler(Executors.newScheduledThreadPool(2));    # worker池&#xA;async&#xA;    注解&#xA;        @Async                                      # 修饰方法, 异步调用 &#xA;    类&#xA;        implements AsyncUncaughtExceptionHandler    # 处理@Async异常&#xA;            @Override&#xA;            public void handleUncaughtException()&#xA;&#xA;        @Configuration&#xA;        @EnableAsync&#xA;        implements AsyncConfigurer&#xA;            @Bean&#xA;            @Override&#xA;            public Executor getAsyncExecutor()&#xA;&#xA;            @Override&#xA;            public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler()             # 处理无返回值＠Async方法异常&#xA;                return handler&#xA;    使用&#xA;    @Async&#xA;    Future&amp;lt;String&amp;gt; fetch(){&#xA;        return new AsyncResult&amp;lt;String&amp;gt;(&amp;quot;&amp;quot;)&#xA;    }&#xA;    future = fetch()&#xA;    try{&#xA;        future.get()&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;热部署&#34;&gt;&#xA;  热部署&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%83%ad%e9%83%a8%e7%bd%b2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;                                       # 热部署&#xA;    &amp;lt;/dependency&amp;gt;&#xA;application.yml&#xA;    spring:&#xA;        devtools:&#xA;        restart:&#xA;            enabled: true&#xA;            additional-paths: src/main/java&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;jsp&#34;&gt;&#xA;  jsp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jsp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;!-- servlet依赖. --&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;&#xA;    &amp;lt;!-- tomcat的支持.--&amp;gt;&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;&#xA;        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;application.yml&#xA;    spring:&#xA;        mvc:&#xA;        view:&#xA;            prefix: /WEB-INF/views/&#xA;            suffix: .jsp&#xA;controller类&#xA;    @Controller&#xA;    public class XxxController {&#xA;        @RequestMapping(&amp;quot;/xxx&amp;quot;)&#xA;        public String xxx(Model m) {&#xA;            m.addAttribute(&amp;quot;a&amp;quot;, 1);&#xA;            return &amp;quot;view1&amp;quot;;&#xA;        }&#xA;    }&#xA;src/main/webapp/WEB-INF/views/view1.jsp&#xA;    &amp;lt;%@ page language=&amp;quot;java&amp;quot; contentType=&amp;quot;text/html; charset=utf-8&amp;quot; pageEncoding=&amp;quot;utf-8&amp;quot;%&amp;gt;&#xA;    jsp ${a}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;lombok&#34;&gt;&#xA;  lombok&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#lombok&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;注解&#xA;    @Builder                            # 修饰类, 可build方式设置属性&#xA;    @Getter                             # 修饰类, 生成getter&#xA;    @Setter                             # 修饰类, 生成setter&#xA;    @ToString                           # 修饰类, 生成toString方法&#xA;    @Data                               # 修饰类, 注入getter, setter, toString&#xA;    @NoArgsConstructor                  # 修饰类, 生成无参构造方法&#xA;    @AllArgsContructor                  # 修饰类, 生成带所有参数的构造方法&#xA;    @RequiredArgsConstructor            # 修饰类, 生成带常量、@NotNull修饰变量参数的构造方法&#xA;        @RequiredArgsConstructor(onConstructor_ = @Autowired)               # 构造类时，自动对private final 属性@Autowire&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;remote-shell&#34;&gt;&#xA;  remote shell&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#remote-shell&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    spring-boot-starter-remote-shell&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;actuator&#34;&gt;&#xA;  actuator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#actuator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    &amp;lt;dependency&amp;gt;&#xA;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&#xA;        &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;/dependency&amp;gt;&#xA;原生端点&#xA;    应用配置类&#xA;        /autoconfig                                 # 自动化配置详情&#xA;            positiveMatches&#x9;                        # 成功&#xA;            negativeMatches&#xA;        /beans                                      # 所有bean&#xA;        /configprops                                # 属性&#xA;        /env                                        # 环境属性&#xA;        /mappings                                   # spring mvc映射关系&#xA;        /info                                       # 自定义信息，默认为空，用info前缀定义&#xA;    度量指标&#xA;        /metrics                                    # 程序信息，内存、线程、gc等&#xA;            nonheap.*                               # 非堆内存&#xA;            gauge.*                                 # http请求性能，如gauge.response表示上次延迟&#xA;            counter.*                               # 记录累计，如counter.status.200表示返回200的次数&#xA;        /metrics/{name}                             # 查看某项&#xA;            /metrics/mem.free&#xA;        /health                                     # 启动状态，磁盘空间&#xA;            DiskSpaceHealthIndicator                # 低磁盘空间&#xA;            DataSourceHealthIndicator               # DataSource连接是否可用&#xA;            MongoHealthIndicator&#xA;            RabbitHealthIndicator&#xA;            RedisHealthIndicator&#xA;            SolrHealthIndicator&#xA;        /dump                                       # 线程信息&#xA;        /trace                                      # 跟踪信息&#xA;    操作控制                                         # 用属性配置开启&#xA;        /shutdown                                   # 关闭端点&#xA;            通过endpoints.shutdown.enabled=true开启&#xA;自定义counter统计&#xA;    @Autowired&#xA;    private CounterService counterService;&#xA;    counterService.increment(&amp;quot;didispace.hello.count&amp;quot;)&#xA;自定义health检测器&#xA;    @Component&#xA;    public class RocketMQHealthIndicator implements HealthIndicator {&#xA;        private int check(){}&#xA;        @Override&#xA;        public Health health() {&#xA;            int errorCode = check();&#xA;            if (errorCode !=0) {&#xA;                return Health.down().withDetail(&amp;quot;Error Code&amp;quot;, errorCode).build();&#xA;                return Health.up().build();&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-boot-admin&#34;&gt;&#xA;  spring boot admin&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-boot-admin&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;application.yml&#xA;    spring:&#xA;        application:&#xA;            name: erp-admin-server&#xA;        boot:&#xA;            admin:&#xA;                routes:&#xA;                    endpoints: env,metrics,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream&#xA;    endpoints:&#xA;        health:&#xA;            sensitive: false&#xA;            enabled: true&#xA;        actuator:&#xA;            enabled: true&#xA;            sensitive: false&#xA;        beans:&#xA;            sensitive: false&#xA;            enabled: true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-initializer&#34;&gt;&#xA;  spring initializer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-initializer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    生成spring基础项目&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-security&#34;&gt;&#xA;  spring security&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-security&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;配置&#xA;    application.yml&#xA;        security:   &#xA;            basic:&#xA;                enabled: false                          # 禁用security&#xA;注解&#xA;    @EnableWebSecurity                                  # 修饰WebSecurityConfigurerAdapter, 开启web验证&#xA;    @EnableGlobalMethodSecurity(prePostEnabled = true)  # 修饰WebSecurityConfigurerAdapter, 开启方法验证&#xA;    @PreAuthorize                                       # 修饰controller方法&#xA;api&#xA;    Subject                                             # 主体数据结构, 如用户&#xA;    SecurityManager                                     # 安全管理器, 管理所有subject&#xA;    UserDetails&#xA;        getAuthorities()&#xA;        getUsername()&#xA;        getPassword()&#xA;        isAccountNonExpired()&#xA;        isAccountNonLocked()&#xA;        isCredentialsNonExpired()&#xA;        isEnabled()&#xA;    GrantedAuthority&#xA;        getAuthority()&#xA;    WebSecurityConfigurerAdapter&#xA;        configure(HttpSecurity)                         # 验证请求&#xA;        configure(AuthenticationManagerBuilder)         # 验证数据，需要授权服务配置AuthenticationManager&#xA;            userDetailService&#xA;            passwordEncoder&#xA;        authenticationManagerBean()                     # 指定管理bean&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;spring-security-oauth2&#34;&gt;&#xA;  spring security oauth2&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-security-oauth2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;pom.xml&#xA;    spring-cloud-starter-oauth2&#xA;结构    &#xA;    OAuth2 Provider&#xA;        Authorization Service                           # 授权服务&#xA;        Resource Service                                # 资源服务&#xA;        Spring Security过滤器&#xA;            /oauth/authorize                            # 授权&#xA;            /oauth/token                                # 获取token&#xA;授权服务&#xA;    applicatoin.yml                                     # server&#xA;        security:   &#xA;            oauth2:&#xA;                resource:&#xA;                    filter-order: 3&#xA;    注解&#xA;        @EnableAuthorizationServer                      # 修饰AuthorizationServerConfigurerAdapter, 开启授权服务&#xA;    api&#xA;        AuthorizationServerConfigurerAdapter            # 授权服务配置&#xA;            configure(ClientDetailsServiceConfigurer)                           # 客户端信息&#xA;                clientId&#xA;                secret&#xA;                scope&#xA;                authorizedGrantTypes                    # password, refresh_token, client_credentials&#xA;                authorities                             # 具体权限&#xA;            configure(AuthorizationServerEndpointsConfigurer)                   # 使用token的服务&#xA;                authenticationManager                   # 密码认证&#xA;                    authenticate(Authentication)&#xA;                userDetailService                       # 获取用户数据&#xA;                    loadUserByUsername(String)&#xA;                authorizationCodeServices               # 验证码&#xA;                implicitGrantService&#xA;                tokenGranter&#xA;                tokenStore&#xA;                    InMemoryTokenStore&#xA;                    JdbcTokenStore&#xA;                    JwtTokenStore&#xA;            configure(AuthorizationServerSecurityConfigurer)                    # 使用token服务的安全策略, 授权服务与资源服务分离时配置&#xA;    接口&#xA;        Principal /users/current&#xA;    测试&#xA;        insert into user(username, password) values(&#39;outrun&#39;, &#39;$2a$10$l7.7AJEHtXukwUZiKAyVSO6lHJOyHhPxHvi7MHawe8SjlOKkCVbAe&#39;)&#xA;        curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf&#xA;        浏览器&#xA;            url: localhost:9016/uaa/oauth/token&#xA;            header&#xA;                &#39;Authorization&#39;: &#39;Basic &#39; + base64(&#39;erp-auth-resource:asdf&#39;)&#xA;            data&#xA;                username: &#39;outrun&#39;&#xA;                password: &#39;123456&#39;&#xA;                grant_type: &#39;password&#39;&#xA;资源服务&#xA;    application.yml                                     # client&#xA;        security:&#xA;            oauth2:&#xA;                resource:&#xA;                    user-info-uri: http://localhost:9016/uaa/users/current&#xA;                client:&#xA;                    clientId: erp-auth-resource&#xA;                    clientSecret: asdf&#xA;                    accessTokenUri: http://localhost:9016/uaa/oauth/token&#xA;                    grant-type: client_credentials,password&#xA;                    scope: server&#xA;    注解&#xA;        @EnableResourceServer                           # 修饰ResourceServerConfigurerAdapter, 开启资源服务&#xA;                                                        # 修饰AuthorizationServerConfigurerAdapter, 因为授权服务提供token获取和验证接口&#xA;        @PreAuthorize(&amp;quot;hasAuthority(&#39;ROLE_ADMIN&#39;))      # 修饰controller方法，验证权限&#xA;    api&#xA;        ResourceServerConfigurerAdapter                 # 资源服务配置&#xA;            configure(HttpSecurity)&#xA;                authorizeRequests                       # 请求放行&#xA;    测试&#xA;        curl -d &amp;quot;username=outrun&amp;amp;password=asdf&amp;quot; &amp;quot;localhost:9017/user/registry&amp;quot;&#xA;        insert into role values(1, &#39;ROLE_USER&#39;), (2, &#39;ROLE_ADMIN&#39;)&#xA;        insert into &#39;user_role&#39; values(user_id, 2)&#xA;        curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf&#xA;        curl -l -H &amp;quot;Authorization:Bearer 7df6669c-0c86-417b-827f-9a58297f57e5&amp;quot; -X GET &amp;quot;localhost:9017/hello&amp;quot;&#xA;客户端&#xA;    注解&#xA;        @EnableOAuth2Client                             # 修饰[Oauth2ClientConfig], 客户端&#xA;    api&#xA;        [Oauth2ClientConfig]                            # 客户端配置, 自定义类，名称任意&#xA;            ClientCredentialsResourceDetails            # bean, 资源信息&#xA;            RequestInterceptor                          # bean, 保存请求上下文&#xA;            OAuth2RestTemplate                          # bean, 用于向授权服务发送请求&#xA;表&#xA;    clientdetails&#xA;    oauth_access_token&#xA;    oauth_approvals&#xA;    oauth_client_details&#xA;    oauth_client_token&#xA;    oauth_code&#xA;    oauth_refresh_token&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;spring-integration&#34;&gt;&#xA;  spring integration&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-integration&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 服务编排&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
