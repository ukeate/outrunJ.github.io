<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  基础
  #

特点
    容器, 也容纳管理了第三方框架         # 目的是解耦框架api
    轻量级，模块化，无(少)侵入
IOC(inversion of control)
    容器用工厂装配对象并管理, 面向接口编程
    优点
        降低代码量
        容易测试
        最小侵入性松耦合
    方式
        Setter
        构造器
        静态工厂、实例工厂
DI(dependency injection)
    容器向类添加属性        # 反射，用带参构造或set方法
AOP(aspect oriented programming)
    # 继承是纵向组织，AOP横切入业务
    # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用）
    动态代理实现切入代码
        权限控制
        事务管理
        记录日志
    概念
        连接点:普通方法
        切入点:名称满足条件的连接点
        增强（通知）类:服务对象
            # 切入点与增强是多对多的
        切面:切入点 &#43; 增强类                        # 我们切入的是横切面
        目标对象（服务对象）：要注入的对象
    通知
        before              # 执行前
        after               # 执行后
        after-returning     # 正常退出
        after-throwing      # 异常退出
        around              # 执行前后
        代理对象(业务对象)：被注入的对象
模块
    dao, orm, aop, jee, web, core
结构
    核心容器(core container)
        Core        # 最底层，资源访问，类型转换
        Beans       # IOC, DI, BeanFactory
        Context     # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播
        EL          # 表达式语言
    AOP, Aspects    # Aspects对AspectsJ集成, 功能多于spring asp
    数据访问/集成
        JDBC
        ORM
        OXM         # object xml 映射
        JMS         # 消息与异步通信
        事务
    Web/Remoting
        Web             # ioc窗口，rmi, hessian,burlap, web service
        Web-Servlet
        Web-Struts
        Web-Porlet      # portal认证
    Test
设计模式
    代理
        目标对象实现接口，使用Proxy
        未实现接口，使用CGLIB
    单例
        bean默认单例
    模板, 解决代码重复问题
        RestTemplate, JmsTemplate, JpaTemplate
    控制器
        DispatherServlet对请求分发
    视图帮助(view helper)
        提供jsp标签、高效宏 帮助在视图中写代码
    依赖注入
        BeanFactory, ApplicationContext核心理念
    工厂
        BeanFactory
循环依赖问题
    构造器, 正在创建在Bean池标记，创建完删除标记，标记冲突报错      # 所以用@Autowired决定注入时机，不写在构造方法里
    单例， 三级缓存, 提前暴露使双方都可初始化
    setter, 提前暴露bean
版本
    2.5
        注解
    3.2
        基于注解的注入测试类@RunW..


  使用
  #

jar包 ：
    核心包：/dist/modules                # 或是/dist中的spring.jar包
        core模块
            beans
            context
            context-support
            core
    日志包：/lib/jakata-commons/commons-logging.jar
创建xml文件(最好在JavaBean的旁边)
    绑定约束文件        /dist/resources/spring-beans-2.5.xsd
    copy xml文件的头：/sample/petclinic/war/web-inf/app...xml
    创建JavaBean.java
    xml文件中配置bean                # src下
        &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;                # id值唯一,class指定 javaBean的类目录
            &lt;property name=&quot;&quot; value=&quot;&quot;&gt;
            &lt;property name=&quot;&quot; ref=&quot;girlID&quot;&gt;                # 引用类型，其中girlID为spring配置的bean Id
业务类中
    ApplicationContext ac = new ClassPathXmlApplicationContext(new String [] {&quot;配置xml文件路径&quot;})
        # 注意：ac创建时，其内部的JavaBean默认全部实例化一遍，并且全部注入了属性
        ## 该容器不用关闭
    if(ac.containsBean(&quot;boyID&quot;)){
        Boy boy = (Boy)ac.getBean(&quot;boyID&quot;);
    }


  api
  #

ApplicationContext是一个接口，表示spring容器/ioc容器

ClassPathXmlApplicationContext        # 只从类路径中读取xml配置文件（src/目录下能访问的路径）省略src/目录

FileSystemXmlApplicationContext                # 文件路径 ,从src/开始

    ac.getBean(&quot;boyID&quot;)
    ac.containsBean(&quot;boyID&quot;)                # 通过此方法去判断是否存在 ，而不是得到的是否为null
    ac.destroy()                                        # ac中的bean实例全部销毁

BeanFactory
    # 基础IOC容器, 默认延迟初始化
    DefaultListableBeanFactory
    ApplicationContext
    XmlBeanFactory      # 根据xml中的定义加载bean
Spring-DAO      # 提供规范, 翻译框架(JDBC&lt;Hibernate,JPA等)异常为DataAccessException
    @Repository 注解DAO类
Spring-JDBC     # 模板类
    DataSource
    JdbcTemplate
    JdbcDaoSupport  # 对dao扩展, DataAccessExceptions异常翻译器
Spring-ORM      # 统称，对各模块(JPA,JDO,Hibernate,iBatis,TopLink,OJB)实现了spring的集成类
    把DataSource注入到SessionFactory或EntityManagerFactory等bean中     # jdbc不需要，因为jdbc直接使用DataSource
    HibernateTemplate
    HibernateDAOSupport     # 继承它提供aop拦截器
Web
    # 在ApplicationContext基础上, 提供web上下文和面向web的服务
    ApplicationContext      # 以BeanFactory为基础,容器启动后默认全部初始化绑定
        FileSystemXmlApplicationContext     # 指定文件
        ClassPathXmlApplicationContext      # 从classpath找设置
        WebXmlApplicationContext


  注解
  #

applicationContext.xml
    &lt;context:annotation-config/&gt;
    &lt;!-- 添加注解扫描功能,启动的时候哪些包要检查是否有注解 --&gt;
    &lt;context:component-scan base-package=&quot;xxx&quot; /&gt;


@Required           # setter
@Autowired          # setter、构造方法、变量
@Qualifier(&quot;dataSource)                     # 多类配置时，指定使用类
@Bean               # 返回对象注册为bean
@Configuration      # bean定义

@Service            # 添加类名小写的spring bean id        也可以@Service(value=&quot;xx&quot;)自定义id
                    ## action类前换成@Controller                @Service也是可以的
@Scope(value=&quot;prototype&quot;)
                    # 工具类或其它组件类换成@Component 也可以@Service,如定时器TimerTask就是组件
@Resource           # 按属性名注入资源

测试类
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations = &quot;classpath:applicationContext*.xml&quot;)


@PostConstruct      # 类加载时运行的方法，相当于xml中配置的init-method
@PreDestroy         # 类销毁前运行的方法

aop
    applicationContext.xml
        &lt;aop:aspectj-autoproxy/&gt;
    @Aspect
        # 注册一个类为切面
    @Pointcut(value=&quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&quot;)
        # 配置切点表达式
    private void testAop(){}
    @AfterReturning(pointcut=&quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&quot;)
        # 配置通知，在通知中配置切点
    @AfterReturning(value=&quot;testAop()&quot;)
        # 配置通知，使用已经配置的切点
    @Around(value=&quot;testAop()&quot;)
        # 配置通知，使用已经配置的切点
    @Around(value=&quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.queryByWord(..))&quot;)
        # 配置通知，在通知中配置切点,注意这里没有pointcut,只有value


  模块
  #


  监听器
  #

原理
    org.springframework.web.context.ContextLoaderListener中
        this.contextLoader.initWebApplicationContext(event.getServletContext());
            # 加载Spring 的配置文件 ，加载Application内置对象中
    initWebApplicationContext方法中
        this.context = createWebApplicationContext(servletContext, parent);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
            # 创建并存储spring的application内置对象到ServletContext中，属性名称是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE
    createWebApplicationContext方法中
        wac.setConfigLocation(sc.getInitParameter(CONFIG_LOCATION_PARAM));
            # 该类文件中有：public static final String CONFIG_LOCATION_PARAM = &quot;contextConfigLocation&quot;;
            # 获得web.xml中配置的context-param初始化参数：contextConfigLocation的内容，并加载spring配置文件

使用
    servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);

    ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext)


  properties
  #

spring xml配置文件中使用properties配置的属性
    配置一个bean的class类是org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer的单例bean
        &lt;property name=&quot;locations&quot; value=&quot;classpath:public.properties&quot; &gt;
            &lt;array&gt;
                &lt;value&gt;classpath:conn.properties&lt;/value&gt;
        或
        &lt;property name=&quot;location&quot; value=&quot;classpath:conn.properties&quot; /&gt;
    xml文件中用&quot;${driver}&quot;的方式引用properties中配置的属性
java类中用spring的注解注入properties配置的属性
    # 要求必须是spring管理的类
    bean中的class类换成org.springframework.beans.factory.config.PropertiesFactoryBean
    id=&quot;Xxx&quot;其它相同
    java类的属性或set方法上添加注解：
    @Value(&quot;#{public.basePath}#{public.filePath}&quot;)
        # 其中public 是上面配置的bean的id(xml文件中注入属性的话用不到id,所以没有配置)
        ## &#39;#{}&#39;代表引用属性
        ## &#39;.&#39;可以用&#39;[]&#39;代替，如public[basePath]
        ## 字符串的拼接可以用&#43;连接
        # 第一次配置@Value的时候不会成功，改一次值再试就可以了


  bean
  #

创建bean的顺序
    xml中按配置顺序的先后
    注解中按照字母的顺序
生命周期
    配置中定义&lt;bean&gt;&lt;/bean&gt;
    初始化
        配置文件中init-method
        实现org.springframework.beans.factory.InitializingBean接口
    调用
    销毁
        配置文件中destroy-method
        实现org.springframework.bean.factory.DisposeableBean
scope
    # 默认singleton
    prototype   # 每次产生新对象
    singleton   # 单例
    request     # 一个请求一个对象，只在ApplicationContext下有效
    session     # 一个session一个对象，只在ApplicationContext下有效
    global-session      # 一个全局session一个对象, 只在ApplicationContext下有效
内部bean
    &lt;property&gt;或&lt;constructor-arg&gt;中定义的&lt;bean&gt;,通常匿名
注入对象
    &lt;list&gt;
    &lt;set&gt;
    &lt;map&gt;
    &lt;props&gt;         # 键值都只能是string类型
自动装配
    方式
        no      # 不自动装配，通过ref属性指定
        byName
            查找类中setter
            容器中找id
            报空指针
        byType
            容器中找类型      # 找到多个时抛异常
        constructor
            byType带构造函数参数
        autodetect
            先试constructor, 再试byType
    写法
        &lt;bean&gt;属性autowire=&quot;byName&quot;
        @Autowired
            类型自动装配
            加上@Qualifier(value=&quot;a&quot;)
                @Resource(name=&quot;a&quot;)注解的name装配
                byName装配
                byType装配

配置
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;
        &lt;bean
            id=&quot;userDaoID&quot;
            name=&quot;&quot;
            class=&quot;cn.itcast.javaee.spring.bean.life.UserDao&quot;
            init-method=&quot;getSession&quot;
            destroy-method=&quot;closeSession&quot;
            factory-method=&quot;getUserDao&quot;
            scope=&quot;singleton&quot;
            lazy-init=&quot;false&quot;
            parent=&quot;userDaoID&quot;
            abstract=&quot;true&quot;
            autowire=&quot;no&quot;&gt;
                &lt;constructor-arg type=&quot;java.lang.Integer&quot; index ref&gt;
                    &lt;value&gt;2013&lt;/value&gt;
                &lt;constructor-arg type=&quot;java.lang.Double&quot;&gt;
                    &lt;value&gt;6000&lt;/value&gt;
                &lt;property name=&quot;name&quot; value=&quot;aa&quot;&gt;&lt;/property&gt;
                &lt;property name=&quot;name&quot; ref=&quot;dateID&quot; /&gt;
                &lt;property name=&quot;telSet&quot;&gt;
                &lt;set&gt;
                    &lt;value&gt;11&lt;/value&gt;
                &lt;property name=&quot;cityList&quot;&gt;
                &lt;list&gt;
                    &lt;value&gt;&lt;/value&gt;
                &lt;property name=&quot;telCityMap&quot;&gt;
                &lt;map&gt;
                    &lt;entry key=&quot;&quot;&gt;
                        &lt;value&gt;&lt;/value&gt;
                &lt;property name=&quot;&quot;&gt;
                    &lt;props&gt;
                        &lt;prop key=&quot;&quot;&gt;&lt;/prop&gt;
标签、属性分析
    bean标签：代表一个JavaBean
        # 多个JavaBean配置时，先配置的先创建，先创建的后销毁
        id：该JavaBean的唯一标识
        name：可以和id一样用，但是name可以设置&quot;/a&quot;来绑定路径
        class：该JavaBean的类路径
        init-method：创建该JavaBean时运行的其中的方法
        destroy-method：销毁该JavaBean时运行的其中的方法
            # ClassPathXmlApplicationContext类的实例不监听销毁方法
            ## 用AbstractApplicationContext中的close()与registerShutdownHook()方法
            ## close()直接马上销毁，registerShutdownHook()方法会注册关闭钩子,监听容器的销毁
            ## 
        factory-method：创建该Bean的函数
            得到接口实现类的方法
            1.通过实现类的无参构造器                # 没有factory-method属性
            2.没有无参构造器时，工厂静态方法创建实例
                &lt;bean id=&quot;userDaoID&quot; factory-bean=&quot;daoFactoryID&quot; factory-method=&quot;getUserDao&quot;&gt;
                    # class中的内容是工厂类，而非UserDao类，factory-method是工厂类中返回UserDao类的静态方法
            3.没有无参构造器时，工厂非静态方法创建实例
                &lt;bean id=&quot;daoFactoryID&quot; class=&quot;cn.itcast.javaee.spring.bean.create.type3.DaoFactory&quot;&gt;
                    &lt;bean id=&quot;userDaoID&quot; factory-bean=&quot;daoFactoryID&quot; factory-method=&quot;getUserDao&quot;&gt;
                        # 先实例化工厂（Spring 加载本xml文件默认实例化），然后静态方法的配置即可
        scope：作用域
            1.singleton（单例）是默认值，是单例的，会调用init destory方法 
            2.prototype（原型）每次创建一个实例， 调用init方法，但不调用destory方法（实例的维护 ：javase程序交给jvm,javaee程序交给服务器）
        lazy-init
            1.false:为启动容器时立即创建一个实例                # singleton与prototype模式都会创建
            2.true:启动时不加载,获取时创建
        parent：        继承一个Spring bean(包含其中的所有属性)
            # javaBean类中不必有实际的继承关系（但是有继承关系则必要配置parent）
        abstract=&quot;true&quot;        : 配置此Bean为抽象Bean
        autowire=&quot;no&quot;:自动装配，只能装配关联属性
            # 还可以进行注解装配
            byName      装配时根据bean中的每个属性名从spring中找id同名的bean,通过setter方法注入到该属性中
            byType      根据bean中的每个属性的类型找到spring中映射该类型的bean进行装配,通过setter方法注入到该属性中
            constructor 找满参构造器装载，构造器中的参数以byType方式注入
            autodetect  先找构造器装载，再set方法注入。但实际使用中只能set方法注入
            no          不注入
        可以配置init-method与destroy-method属性来配置该bean创建和销毁时执行的方法
    注入值                  # 通过setter方法注入值 
        &lt;constructor-arg type=&quot;java.lang.Integer&quot; index ref&gt;        
            &lt;value&gt;2013&lt;/value&gt;    # 传入构造方法参数注入值，,位置不能颠倒，不调用setter方法
                ## type是注入参数的类型，index是参数的标号，从0开始，ref是引用类型,有引用类型时不用&lt;value&gt;标签
            &lt;property name=&quot;name&quot; value=&quot;aa&quot;/&gt;                # 基本类型直接赋值（包括包装类型与String）
            &lt;property name=&quot;name&quot; ref=&quot;dateID&quot;/&gt;        # 引用类型,dateID是一个Spring Bean
                ## 可以直接引用Spring Bean 的id 
                &lt;set&gt;
                    &lt;value&gt;&lt;/value&gt;                                                # set集合
                &lt;list&gt;
                    &lt;value&gt;&lt;/value&gt;                                                # list集合
                &lt;map&gt;
                    &lt;entry key=&quot;&quot;&gt;
                            &lt;value&gt;&lt;/value&gt;                                        # map集合
                    # 集合的值均可配置引用类型
                &lt;property name=&quot;&quot;&gt;
                    &lt;props&gt;
                        &lt;prop key=&quot;&quot;&gt;&lt;/prop&gt;                        # 属性类型，只能配置基本类型 （包括包装类型与String）


  aop
  #

实现      # 基于Aspectj
原理
    启动容器时，创建目标对象与代理对象
    &lt;aop:config/&gt;加载完时,通过cglib创建目标对象的代理对象，运行时产生
    程序员-代理对象-代理方法-目标对象-目标方法-代理对象
使用
    写类文件
    1.jar包  aspectjweaver.jar/aspectjrt.jar/cglib-nodep-2.1_3.jar(动态代理包)
    2.配置xml文件头,保留aop
        &lt;bean id class/&gt;        # 目标对象
        &lt;bean id=&quot;serviceBeanID&quot; class /&gt;    # 配置增强对象
        &lt;aop:config&gt;            # 相当于创建了代理对象
            &lt;aop:pointcut id=&quot;xxxx&quot; expression=&quot;&quot; /&gt;        # 切入点表达式：expression=&quot;execution(public void addUser() throws java.lang.Exception)&quot;
                ## 可以写成execution(public void 类名.*()),表示匹配所有方法
                ## execution(* *(..))        第一个*是返回值，第二个*是方法，..表示参数不限
                ## 可以声明抛异常
                ## 条件命名为xxxx,升级连接点到切入点
            &lt;aop:aspect ref=&quot;serviceBeanID&quot;&gt;
                &lt;aop:before method=&quot;writeLog&quot; pointcut-ref=&quot;xxxx&quot;/&gt;    # 前置增强，method是注入的方法，xxxx是增强的条件,只能写一个方法
                &lt;aop:after/&gt;
                &lt;aop:after-returning/&gt;      # 方法返回后执行
                &lt;aop:after-throwing/&gt;      # 抛出异常时执行
                &lt;aop:around/&gt;              # 环线，执行目标方法前、后都执行,出错则之后的函数不执行
                    public void both(ProceedingJoinPoint pjp){      # ProceedingJoinPoint是连接代理对象 与目标对象的桥梁
                        open();
                        pjp.proceed();      # 执行目标代码
                        close();
                    }
                    # 目标方法出错，后置增强仍然执行,after-throwing执行，前置增强不执行,after-returning不执行
                    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;xxxx&quot;/&gt;                # 配置事务的切面
切入点表达式
    execution(方法的修饰符 方法的返回值类型 方法所属的类 方法名 方法中参数列表 方法抛出的异常)
        方法的修饰符：    支持通配符*，可省略
        方法的返回值类型：支持通配符*，表示所有返回值，不可省
        方法所属的类：    支持通配符*，可省略
        方法名：          支持通配符*，表示所有方法，不可省
        方法中参数列表：  支持通配符*，不可省
                # *表示【一个】任意类型的参数
                ## ..表示零个或一个或多个任何类型的参数【提倡】
    execution(方法的返回值类型 方法名（方法中参数列表））                # 一般形式

    例如:
    execution(public void add()throws Exception)
    execution(public void add(..)throws Exception)
    execution(public void add(*)throws Exception)
    execution(* cn.itcast.web.spring.aop.UserDao.add(..))
    execution(* add()throws Exception)
    execution(public void *(..)throws Exception)
            execution(public void a*(..)throws Exception)：方法名以a字符开始
    execution(public void *d(..)throws Exception)：方法名以d字符结束
    execution(* add())
    execution(* *(..))
切点方法的编写
    public void Xxx(JoinPoint joinPoint){
        joinPoint.getTarget();                # 获取目标对象
        joinPoint.getSignature();        # 获取当前连接点的方法信息
        joinPoint.getArgs()[0];                # 获取当前连接点的第一个参数
        ..
    }
    public Goods Yxx(ProceedingJoinPoint joinPoint){
        Object object = joinPoint.proceed();        # 得到连接点的返回值
        ..
        return goods;                # 本切面返回的数据会作为切点返回的数据返回给调用它的函数
    }


  dao
  #

使用
    1.xml文件中
    &lt;!-- 配置C3P0连接池 --&gt;
        &lt;bean id=&quot;comboPooledDataSourceID&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring&quot;/&gt;
            &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;initialPoolSize&quot; value=&quot;60&quot;/&gt;
            &lt;property name=&quot;acquireIncrement&quot; value=&quot;5&quot;/&gt;
        &lt;/bean&gt;

        &lt;!-- 配置JdbcTemplate --&gt;
        &lt;bean id=&quot;jdbcTemplateID&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;comboPooledDataSourceID&quot;/&gt;
        &lt;/bean&gt;

        &lt;!-- 配置UserDao --&gt;
        &lt;bean id=&quot;userDaoID&quot; class=&quot;dao.UserDao&quot;&gt;
            &lt;property name=&quot;jt&quot; ref=&quot;jdbcTemplateID&quot;/&gt;
        &lt;/bean&gt;
    2.Dao中
        private JdbcTemplate jt;
        addUser()
            String sql = &quot;&quot;;
            Object [] params = {user.getUsername(),user.getPassword()}
            jt.update(sql,params);
            批量：
            for(int i = 0; i &lt; ids.length; i&#43;&#43;){
                sqls[i] = &quot;&quot;;
            }
            jt.batchUpdate(sqls);
            查询一个
        return (User)jt.queryForObject(sql,params,new RowMapper(){
                public Object mapRow(ResultSet rs,int rowNum){          # rs是查询出来的结果集,rowNum是结果集的行号,从0开始
                    Integer id = rs.getInt(&quot;id&quot;);
                    User user = new User(id);
                    return user;
                }
                });
            查询多个                # query方法把RowMapper帮助类中返回的user分别加入到list中，返回一个list
            list = jt.query(sql,new RowMapper(){
                    public Object mapRow()
                        ..
                        return bean;
                })
            分页
                            String sql = &quot;select * from users limit ?,?&quot;;
                            Object[] params = {0,3};
            jt.query(sql,params,new RowMapper(){
            记录
            jt.queryForInt(sql);


  事务
  #

TransactionInterceptor
    transactionManager          # 指定事务治理类
    transactionAttributes       # key方法名 value事务属性
注解
    @Transactional(propagation = Propagation.REQUIRED)
手写      # TransactionDefinition
    Public class BankServiceImpl implements BancService{
        Private BanckDao bankDao;
        private TransactionDefinition txDefinition;
        private PlatformTransactionManager txManager;
        public boolean transfer(Long fromId, Long toId, double amount) {
            TransactionStatus txStatus = txManager.getTransaction(txDefinition);
            boolean result = false;
            try {
                result = bankDao.transfer(fromId, toId, amount);
                txManager.commit(txStatus);
            } catch (Exception e) {
                result = false;
                txManager.rollback(txStatus);
                System.out.println(&quot;Transfer Error!&quot;);
            }
            return result;
        }
    }
手写      # TransactionTemplate
    public class BankServiceImpl implements BankService {
        private BankDao bankDao;
        private TransactionTemplate transactionTemplate;
        public boolean transfer(final Long fromId, final Long toId, final double amount) {
            return (Boolean) transactionTemplate.execute(new TransactionCallback(){
            public Object doInTransaction(TransactionStatus status) {
                Object result;
                try {
                    result = bankDao.transfer(fromId, toId, amount);
                } catch (Exception e) {
                    status.setRollbackOnly();
                    result = false;
                    System.out.println(&quot;Transfer Error!&quot;);
                }
                return result;
            }
            });
        }
    }
配置      # TransactionInterceptor
    &lt;bean id=&quot;transactionInterceptor&quot; class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
        &lt;property name=&quot;transactionAttributes&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;bankServiceTarget&quot; class=&quot;footmark.spring.core.tx.declare.origin.BankServiceImpl&quot;&gt;
        &lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;bankService&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
        &lt;property name=&quot;target&quot; ref=&quot;bankServiceTarget&quot;/&gt;
        &lt;property name=&quot;interceptorNames&quot;&gt;
            &lt;list&gt;
                &lt;idref bean=&quot;transactionInterceptor&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
配置      # TransactionProxyFactoryBean
    &lt;bean id=&quot;bankServiceTarget&quot; class=&quot;footmark.spring.core.tx.declare.classic.BankServiceImpl&quot;&gt;
        &lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;bankService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;
        &lt;property name=&quot;target&quot; ref=&quot;bankServiceTarget&quot;/&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
        &lt;property name=&quot;transactionAttributes&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
配置      # tx空间
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

    &lt;!--配置c3p0连接池--&gt;
    &lt;!-- 配置JdbcTemplate类 --&gt;
    &lt;!-- 配置Dao --&gt;
    &lt;!-- 配置jdbc事务管理器 --&gt;
    &lt;bean id=&quot;dataSourceTransactionManagerID&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;comboPooledDataSourceID&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 配置事务增强(服务对象) --&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;dataSourceTransactionManagerID&quot;&gt;
    &lt;tx:attribute&gt;
        &lt;tx:method name=&quot;addUsers&quot;                      # 可以用通配符&quot;*users&quot;
            propagation=&quot;required&quot;                  # 传播行为：事务开始、结束的时间。required 保证方法执行时事务已开始，事务开始时不创建，没有开始时创建
            isolation=&quot;default&quot;                     # 隔离级别
            timeout=&quot;-1&quot;                            # 事务超时,-1代表不超时，用数据库底层的配置
            rollback-for:&quot;java.lang.Exception&quot;      # 何时回滚
            read-only=&quot;false&quot;                       # 不只读
                # name 方法名的匹配模式
                # required : 外部存在事务，则加入外部事务，不存在则新建事务
                # requires_new : 总是新建事务
                # mandatory : 外部必须存在事务
                # never : 外部不能存在事务
                # supports : 外部存在则加入，不存在则不以事务方式运行
                # not_supported : 总是非事务
                # nested : 外部存在事务，嵌套执行，不存在则新建
                # no-rollback-for 以逗号分隔异常，这些异常不会导致事务回滚
                # rollback-for 导致事务回滚的异常
        /&gt;
    &lt;tx:attribute&gt;

    &lt;!-- 配置AOP --&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;xxxx&quot; expression=&quot;execution(public void *Users(..))&quot;/&gt;
        ##
        任意公共方法的执行：
        execution(public * *(..))
        任何一个以“set”开始的方法的执行：
        execution(* set*(..))
        AccountService 接口的任意方法的执行：
        execution(* com.xyz.service.AccountService.*(..))
        定义在service包里的任意方法的执行：
        execution(* com.xyz.service.*.*(..))
        定义在service包和所有子包里的任意类的任意方法的执行：
        execution(* com.xyz.service..*.*(..))
        定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：
        execution(* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))&quot;)

        &lt;!-- 将事务代码切入点addUser()方法中，从而产生事务 --&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;xxxx&quot;/&gt;
    &lt;/aop:config&gt;


  spring mybatis
  #

基础
    #与$
        #相当于解析成引号, 防止sql注入
        $变量引用, 不能防止sql注入，用于传入表名之类
    特点
        sql易维护，传参方便
        orm
    Mapper接口
        方法名与配置id相同
        输入输出参数类型对应定义的parameterType类型和resultType类型
        类路径是配置的namespace
    缓存
        # 基于PerpetualCache的HashMap
        一级缓存
            存在本地
            作用域为session, session flush后清空
        二级缓存
            可定义存储服务
            作用域为namespace
            配置
                &lt;cache/&gt;
                    readOnly=&quot;true&quot; 时，缓存实例单例，false时返回缓存拷贝
        更新
            create, update, delete后，作用域下所有select缓存clear
与hibernate区别
    都通过SessionFactoryBuilder从配置生成SessionFactory, 再生成Session
    都支持jdbc和jta
    mybatis可细致优化sql, hibernate移植性好
    mybatis学习成本低
    mybatis本身缓存不好，hibernate对象维护和缓存好
    hibernate dao层封开发简单(不用维护映射)，crud方便
使用
    编程
        创建SqlSessionFactory
        创建SqlSession
        执行数据库操作
        session.commit()
        session.close()
    导入ibatis jar包
    配置文件
        SqlMap.properties        # 属性名可以修改
            driver=oracle.jdbc.driver.OracleDriver
            url=jdbc:oracle:thin:@127.0.0.1:1521:orcl
            username=root
            password=root
        SqlMapConfig.xml                # 总配置文件
            &lt;sqlMapConfig&gt;
                &lt;properties recource=&quot;SqlMap.properties&quot;/&gt;
                &lt;transactionManager type=&quot;JDBC&quot;&gt;
                        &lt;dataSource type=&quot;SIMPLE&quot;&gt;
                            &lt;property value=&quot;${driver}&quot; name=&quot;JDBC.Driver&quot;/&gt;
                            &lt;property value=&quot;${url}&quot; name=&quot;JDBC.ConnectionURL&quot;/&gt;
                            &lt;property value=&quot;${username}&quot; name=&quot;JDBC.Username&quot;/&gt;
                            &lt;property value=&quot;${password}&quot; name=&quot;JDBC.Password&quot;/&gt;
                        &lt;/dataSource&gt;
                    &lt;sqlMap resource=&quot;Student.xml&quot;/&gt;
                &lt;/transactionManager&gt;
            &lt;/sqlMapConfig&gt;
        Student.xml                                # 映射xml文件
            &lt;sqlMap&gt;
                &lt;typeAlias alias=&quot;Student&quot; type=&quot;com.Student&quot;/&gt;
                    &lt;select id=&quot;selectAllStudent&quot; resultClass=&quot;Student&quot;&gt;
                        select * from Student
                    &lt;/select&gt;
                &lt;/typeAlias&gt;
            &lt;/sqlMap&gt;
        辅助类Student.java                 # 要求有无参构造方法
            private sid = 0;
            private String name = null;
            private String major = null;
            private Date birth = null;
            private float score = 0;
    Xxx.java
        private static SqlMapClient sqlMapClient = null;
        static{
            Reader reader = Resources.getResourceAsReader(总配置文件);
            sqlMapClient = SqlMapClientBuilder.buildSqlMapClient(reader);
            reader.close();
        }
        public List&lt;Student&gt; queryAllStudent(){
            List&lt;Student&gt; studentList = sqlMapClient.queryForList(&quot;selectAllStudent&quot;);
            return studentList;
        }
        @Test
        public void testHere(){
            for(Student student: this.queryAllStudent()){
                System.out.println(student.getName);
            }
        }
配置
    sqlMapConfig.xml
        mybatis加载属性顺序
            properties中property中的属性
            properties中resource或url中的属性
            parameterType中传递一属性
                # properties中配的属性会影响到mapper.xml中${}的sql拼接，因为都是ognl
        配置标签
            properties
            settings
                # ibatis有性能优化的参数，mybatis会自动调优，不用设置了
            typeAliases
                # 针对parameterType和resultType指定的类型定义别名
                # java.lang.Integer在mybatis中默认别名为int
            typeHandlers
                # 类型处理器，jdbc类型和java类型的转换
                ## 一般mybatis提供的类型处理器够用了
            objectFactory
            plugins
            environments
            mappers
    mapper.xml
        内容
            #{}接收简单类型, pojo的ognl属性注入
            ${}是字符串的拼接

        SELECT * FROM USER WHERE id=#{id}
        SELECT * FROM USER WHERE username LIKE &#39;%${value}%&#39;
            # sql 注入
    输入输出映射
        parameterType
            java类型
            hashmap
                # #{key}来取value
            pojo
            包装类型
        resultType
                # 指定一条数据的类型，在java方法的返回类型中list或pojo来体现数据条数
                # mybatis判断mapper代理中使用selectOne或者selectType
            pojo
                # 返回字段可以是别名，但要与pojo中的属性名相同
                ## 如果有记录返回但没有pojo中匹配的属性名对应，则直接不创建该对象
            java类型
                # 在返回结果只有一行一列时，可以是简单类型
            hashmap
                # key是字段的字，value是字段的值
                ## 多条数据时，list里面存hashmap
        resultMap
            # 查询出来的字段名与pojo属性名不一致
            定义resultMap
            使用resultMap
    动态sql
        &lt;where&gt;
        &lt;if&gt;

        sql片段&lt;sql&gt;

        &lt;foreach&gt;
    高级映射
    缓存
    逆向
        要求
            1. mapper.xml中namespace 写mapper接口
                &lt;mapper namespace=&quot;com.otr.tea.mapper.UserMapper&quot;&gt;
            2. mapper.java中方法名与mapper.xml的statementid一致
            3. mapper.java中方法的输入类型与mapper.xml中的parameterType一致
                # 由于传入的参数只有一个，所以用包装类型的pojo来传多个参数，不利于业务层的可扩展性
            4. mapper.java中方法的返回类型与mapper.xml中的resultType一致
        机制
            如果Mapper中返回类型为pojo, 则调用selectOne, 如果是List, 则调用selectList
api
    sqlSessionFactory
    sqlSession                        # 是线程不安全的，因为它的类中有数据和属性
                                    ＃ 是多例的，在方法中局部变量使用
        Executor                # 执行器操作数据库（基本执行器，缓存执行器）
    mapped statement                # 封装sql语句、输入参数、输出结果类型

    例子
        InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
            # Resources是mybatis提供的资源加载类
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = factory.openSession();
        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);
            ＃ selectList()
            # insert(&quot;test.insertUser&quot;, user)
            ## sqlSession.commit();
            ## user.getId() 会主键返回
            ### mysql中LAST_INSERT_ID()在insert语句后接着执行可以得到刚刚自成的id
        sqlSession.close();
案例
    返回id
        mysql
            &lt;insert id=&quot;insert&quot; parameterType=&quot;com.test.User&quot; keyProperty=&quot;userId&quot; useGeneratedKeys=&quot;true&quot; &gt;
        oracle
            &lt;insert id=&quot;insert&quot; parameterType=&quot;com.test.User&quot;&gt;
                &lt;selectKey resultType=&quot;INTEGER&quot; order=&quot;BEFORE&quot; keyProperty=&quot;userId&quot;&gt;
                    SELECT SEQ_USER.NEXTVAL as userId from DUAL
                &lt;/selectKey&gt;

                insert into user (user_id, user_name, modified, state)
                values (#{userId,jdbcType=INTEGER}, #{userName,jdbcType=VARCHAR},
                #{modified,jdbcType=TIMESTAMP}, #{state,jdbcType=INTEGER})
            &lt;/insert&gt;


  spring struts2
  #

原理
    tomcat启动日志：没有整合时不能加载struts-plugin.xml（spring-struts-plugin.jar包中的配置文件 ）
    struts中struts-default中常量配置加载com.opensymphony.xword2.ObjectFactory类作为默认struts创建action的类
    加载后struts-plugin.xml 中 修改了常量为struts-spring-plugin中的类来创建struts的类，也就是整个struts2创建action类的类被更改了

整合
    jar包 struts2/lib/struts2-spring-plugin-2.3.1.1.jar                        # 为了在struts的xml配置文件中的class找spring 的容器
    配置web.xml   # \samples\petclinic\war\WEB-INF\web.xml目录下有示例
                                            
        &lt;listener&gt;          # 监听器，web程序启动时加载spring bean
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener
        &lt;context-param&gt;     # （可选）配置spring 配置文件的路径，
                            ## 从示例文件中查到，默认文件目录是/WEB-INF/applicationContext.xml(我们示例文件也是从源码/simple项目下的这个开头的文件中找的)
            &lt;param-name&gt;contextConfigLocation
            &lt;param-value&gt;/WEB-INF/classes/struts2/xxx.xml
    UserAction 中    # 不用值栈是因为通用性
    spring.xml        # action类由spring 产生
        &lt;bean id=&quot;userActionID&quot; class=&quot;&quot; scope=&quot;prototype&quot;/&gt;
    struts2的配置文件中，替换class属性为spring beanid，其它一样
总结
    spring的web配置是由下向上，一个个依赖注入的过程
        comboPooledDataSourceID -&gt;
        localSessionFactoryBeanID -&gt;
        hibernateTemplateID -&gt;
        SysStaffDaoID -&gt;
        SysStaffServiceID -&gt;
        SysStaffActionID -&gt;
        struts.xml配置中的&lt;action class=&quot;SysStaffActionID&quot;&gt;
    最后给Dao中的方法加入事务


  spring mvc
  #

原理
    DispatchServlet doService()捕获请求, doDispatch()用HandlerMapping映射url得到HandlerExcutionChain(执行链, 包括拦截器和handler)
    handler getHandlerAdapter得到适配器来处理handler, 返回ModelAndView
        # HandlerAdapter分三类: Servlet、Controller, HttpRequest
    DispatchServlet用ViewResolver(视图解析器)解析ModelAndView成View
        # ModelAndView是逻辑视图，DispatchServlet转化成视图View
    返回View
与struts2区别
    spring mvc方法对应请求, struts2是类
    spring mvc请求是方法调用，struts2创建Action实例
    spring mvc用aop处理请求，struts2用独有的拦截器(interceptor)
    spring mvc入口是servlet, struts2入口是filter
    spring mvc集成ajax(@ResponseBody), struts2需要插件
    spring mvc验证支持JSR303, struts2不支持
    spring mvc与spring无缝
    spring mvc不需要配置
注解
    @RequestMapping             # url映射
    @RequestBody                # 转换参数到对象
    @ResponseBody               # 返回对象转json

    开启注解处理器
        springmvc.xml
            &lt;mvc:annotation-driven&gt;
乱码问题
    post
        web.xml中配置CharacterEncodingFilter
    get
        tomcat配置文件修改项目编码
        new String(Request.getParameter(&quot;a&quot;).getBytes(&quot;ISO8859-1&quot;), &quot;utf-8&quot;)


  quartz:定时器
  #

执行：ApplicationContext类加载后自动执行
导包：quartz-all.jar包 与  commons-collections.jar包 与 commons-logging.jar
xml配置：
    &lt;!-- 任务类 ,其中有个叫execute的方法--&gt;
    &lt;bean id=&quot;myTaskID&quot; class=&quot;jee.quartz.MyTask&quot;/&gt;

    &lt;!-- spring提供专用于定时任务类 --&gt;
    &lt;bean id=&quot;methodInvokingJobDetailFactoryBeanID&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;
        &lt;!-- 要定时执行的实例的spring bean id --&gt;
        &lt;property name=&quot;targetObject&quot;&gt;
                &lt;ref bean=&quot;myTaskID&quot;/&gt;
        &lt;/property&gt;
        &lt;!-- spring bean中定时执行的方法 --&gt;
        &lt;property name=&quot;targetMethod&quot;&gt;
                &lt;value&gt;execute&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- spring提供专用于任务频率类，给上面的任务指定频率 --&gt;
    &lt;bean id=&quot;cronTriggerBeanID&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;
        &lt;property name=&quot;jobDetail&quot;&gt;
                &lt;ref bean=&quot;methodInvokingJobDetailFactoryBeanID&quot;/&gt;
        &lt;/property&gt;
        &lt;property name=&quot;cronExpression&quot;&gt;
                &lt;value&gt;0 0/1 * * * ?&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- spring提供的专用于任务频率工厂类 --&gt;
    &lt;bean id=&quot;schedulerFactoryBeanID&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;
        &lt;property name=&quot;triggers&quot;&gt;
            &lt;ref bean=&quot;cronTriggerBeanID&quot;/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
任务频率cronTriggerBean的配置：
    cron解析器:
        反斜线（/）字符表示增量值。例如，在秒字段中“5/15”代表从第 5 秒开始，每 15 秒一次。
        问号（?）字符和字母 L 字符只有在月内日期和周内日期字段中可用。问号表示这个字段不包含
        具体值。
        所以，如果指定月内日期，可以在周内日期字段中插入“?”，表示周内日期值无关紧要。字母
        L 字符是 last 的缩写。放在月内日期字段中，表示安排在当月最后一天执行。在周内日期字
        段中，如果“L”单独存在，就等于“7”，否则代表当月内周内日期的最后一个实例。所以“0L”
        表示安排在当月的最后一个星期日执行。
        在月内日期字段中的字母（W）字符把执行安排在最靠近指定值的工作日。把“1W”放在月内
        日期字段中，表示把执行安排在当月的第一个工作日内。
        井号（#）字符为给定月份指定具体的工作日实例。把“MON#2”放在周内日期字段中，表示把任
        务安排在当月的第二个星期一。
        星号（*）字符是通配字符，表示该字段可以接受任何可能的值。
    顺序：秒 分 时 日 月 周 年（年可以忽略）
    例子
        0 0 10,14,16 * * ?                  每天上午10点，下午2点，4点
        0 0/30 9-17 * * ?            朝九晚五工作时间内每半小时
        0 0 12 ? * WED                          表示每个星期三中午12点
        0 0 12 * * ?                          每天中午12点触发
        0 15 10 ? * *                          每天上午10:15触发
        0 15 10 * * ?                          每天上午10:15触发
        0 15 10 * * ? *                  每天上午10:15触发
        0 15 10 * * ? 2013          2013年的每天上午10:15触发
        0 * 14 * * ?                          在每天下午2点到下午2:59期间的每1分钟触发
        0 0/5 14 * * ?                          在每天下午2点到下午2:55期间的每5分钟触发
        0 0/5 14,18 * * ?                  在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
        0 0-5 14 * * ?                          在每天下午2点到下午2:05期间的每1分钟触发
        0 10,44 14 ? 3 WED                  每年三月的星期三的下午2:10和2:44触发
        0 15 10 ? * MON-FRI                周一至周五的上午10:15触发
        0 15 10 15 * ?                          每月15日上午10:15触发
        0 15 10 L * ?                            每月最后一日的上午10:15触发
        0 15 10 ? * 6L                    每月的最后一个星期五上午10:15触发
        0 15 10 ? * 6L 2014-2018        2014年至2018年的每月的最后一个星期五上午10:15触发
        0 15 10 ? * 6#3                        每月的第三个星期五上午10:15触发
        0/1 * * * * ?                        每秒钟触发一次
        0 0/1 * * * ?                        每分钟解发一次
        0 0 0/1 * * ?                        每小时解发一次


  远程调用
  #

# rmi:remote message invoke
服务端
    1.自定义接口IServer,自定义抽象方法int rax(int)
    2.写接口实现类ServerImpl
    3.配置spring.xml 文件
        &lt;!-- 服务端实现类 --&gt;
        &lt;bean id=&quot;serverImplID&quot; class=&quot;jee.server.ServerImpl&quot;/&gt;
        &lt;!-- spring提供的专用于RMI服务端注册器 --&gt;
        &lt;bean id=&quot;rmiServiceExporterID&quot; class=&quot;org.springframework.remoting.rmi.RmiServiceExporter&quot;&gt;
            &lt;property name=&quot;serviceInterface&quot;&gt;
                    &lt;value&gt;jee.server.IServer&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name=&quot;service&quot;&gt;
                    &lt;ref bean=&quot;serverImplID&quot;/&gt;
            &lt;/property&gt;
            &lt;property name=&quot;serviceName&quot;&gt;
                    &lt;value&gt;XXXX&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
客户端
    配置spring.xml 文件
        &lt;!-- spring提供专用于RMI远程服务代理工厂类 --&gt;
        &lt;bean id=&quot;rmiProxyFactoryBeanID&quot; class=&quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&quot;&gt;
            &lt;!-- 协议名://远程提供服务的IP地址:提供服务的端口/提供服务的名称 --&gt;
            &lt;property name=&quot;serviceUrl&quot;&gt;
                    &lt;value&gt;rmi://127.0.0.1:1099/XXXX&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name=&quot;serviceInterface&quot;&gt;
                    &lt;value&gt;jee.client.IServer&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
执行：
    服务端加载 ApplicationContext类
    客户端
        加载 ApplicationContext类 ac
        ac.getBean方法中得到RmiProxyFactoryBean实际类型（可变类型）的实例，强转成服务端自定义的接口IServer的实现类（实现类由服务器决定）
        执行IServer实现类中的方法int rax(int)，实现了远程调用


  websocket
  #

handler
    extends TextWebSocketHandler
        @Override
        handleTextMessge()                      # 处理client.send()的数据

        @Override
        afterConnectionEstablished(WebSocketSession)                    # 连接事件

        @Override
        handleTransportError()                  # 出错事件

        @Override
        afterConnectionClosed()                 # 断开事件

        @Override
        supportsPartialMessages()               # 并行处理
config
    @EnableWebSocket
    implements WebSocketConfigurer
        @Override
        registerWebSocketHandlers()
            registry.addHandler(handler, &quot;/ws&quot;)                         # 路由handler
client
    extends WebSocketClient
        constructor(uri)
            super(new URI(uri))

        @Override
        onOpen()

        @Override
        onClose()

        @Override
        onError()

        @Override
        onMessage()
service
    init()
        client = new Client(&quot;ws://127.0.0.1:8001/ws&quot;)
        client.connectBlocking()
    send()
        while(!client.getReadyState().equals(ReadyState.OPEN)){
            log(&quot;connecting&quot;)
        }
        client.send(&quot;&quot;)
runner
    implements ApplicationRunner
        run()
            service.init()


  spring boot
  #

介绍
    减少配置, 习惯大于配置
    支持groovy, gradle
命令
    java -jar xxx.jar
        --server.port=8080                                      # --后内容，相当于application.yml设置
        --spring.profiles.active=two                            # 选择applicaton-two.yml配置


  基础文件
  #

目录
    src
        main
            java
                com.outrun
                    XxxApplication
            resources
                static/
                templates/
                application.properties
                application.yml
            webapp
                WEB-INF
        test
            java
                com.outrun
                    XxxApplicationTests
    pom.xml
XxxApplication.java                                     # 程序入口
    @SpringBootApplication                              # 类，组合@Configuration, @EnableAutoConfiguration, @ComponentScan
        @EnableAutoConfiguration根据jar包依赖自动配置
        扫描该注解同级下级包的Bean
application.yml                                         # application.yml或application.properties, 放在src/main/resources或config目录下
pom.xml


  配置
  #

区分环境
    application-{profile}.properties                                    # profile比如是dev, test, prod
    设置spring.profiles.active=dev来区分
加载顺序                                                                 # 为了外部人员维护，可覆盖定义
    命令行
    SPRING_APPLICATION_JSON环境变量, json格式
    java:comp/env的JNDI属性
    java系统属性                                                         # System.getProperties()查看
    系统环境变量
    random.*配置的随机属性
    jar包外文件名, 如application-{profile}.properties
    jar包内文件名
    @Configuration注解类中，@PropertySource修改的属性
    SpringApplication.setDefaultProperties定义的内容
application.yml
    ---                                                 # ---分隔多个配置，这里相当于建立了application-two.yml文件
    spring:
        profiles: two
    ---
    spring:
        profiles
            active: dev                                 # 配置环境, 加载applicaton-dev.yml
        application:
            name: app1
pom.xml
    &lt;packaging&gt;jar&lt;/packaging&gt;                          # 不用war包部署, 嵌入了tomcat, jar可服务
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;             # 提供spring boot基础依赖和默认配置
        &lt;relativePath/&gt;                                 # 从仓库查找parent
    &lt;/parent&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;       # 方便启动停止应用, 如mvn spring-boot:run
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;


  注解
  #

@SpringBootApplication                      # spring boot 启动类
    组合了@Configuration, @EnableAutoConfiguration, @ComponentScan


  类
  #

ApplicationRunner                           # 继承该类，注解@Component, 随容器启动运行
    run()


  插件
  #


  maven
  #

命令
    mvn spring-boot:run
pom.xml
    &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;       # 方便启动停止应用, 如mvn spring-boot:run
    &lt;/plugin&gt;


  组件
  #

starter POMs            # spring-boot-starter开头的组件


  子域
  #


  NamedContextFactory
  #

class Spec1 implements NamedContextFactory.Specification {
    @Override
    public String getName(){}
    @Override
    public Class&lt;?&gt;[] getConfiguration(){}
}
public class MyFactory extends NamedContextFactory&lt;Specification1&gt; {
    public MyFactory(Class&lt;?&gt; clazz) {
        super(clazz, &quot;my&quot;, &quot;my.name&quot;)
    }
}
@Configuration
public class Config0 {
    @Bean
    Bean0 getBean(){
        return new Bean0()
    }
}

parent = new AnnotationConfigApplicationContext()
parent.register(Config0.class)
parent.refresh()
factory = new MyFactory(Config00.class)
factory.setApplicationContext(parent) 

spec1 = new Spec1(&quot;1&quot;, new Class[]{Config1.class})
factory.setConfigurations(List.of(spec1))
factory.getInstance(&quot;1&quot;, Bean0.class)   // 子域共享
factory.getInstance(&quot;1&quot;, Bean00.class)  // 子域复制
factory.getInstance(&quot;1&quot;, Bean1.class)


  spring
  #

配置
    随机数用${random}
        ${random.value} 字符串
        ${random.int} int
        ${random.long} long
        ${random.int(10)} 10以内int
        ${random.int[10,20]} 10到20 int
    pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    application.yml
        aa
            bb: 1                                           # 可用properties类管理属性
        xxx: 1                                              # 自定义value
            配置文件中用&quot;${xxx}&quot;引用
            类中用@Value(&quot;${xxx}&quot;)注入到属性
            SpEL中用&quot;#{xxx}&quot;引用
    AaProperties.java
        @Component
        @ConfigurationProperties(prefix = &quot;aa&quot;)
        public class AaProperties {
            private String bb;
            ...getter和setter...
        }
    注解    
        @Configuration
        @PropertySource(value = &quot;classpath:test.properties&quot;)                    # 加载文件, 配合@ConfigurationProperties注入属性
        @EnableConfigurationProperties({ConfigBean.class, User.class})          # 加载bean, 配合@Autowired注入
基础
    注解
        @Value(&quot;${xxx}&quot;)
        @Autowired                                  # 装载bean
        @Bean                                       # 实例化Bean, 属性名为方法名
            @Bean
            public RestTemplate restTemplate() {
                return new RestTemplate();
            }
            相当于
            RestTemplate restTemplate = new RestTemplate();
        @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)                         # 生命周期
            singleton                               # 单例
            prototype                               # 多例
            request                                 # web程序ContextApplication用, 随请求创建
            session                                 # web程序ContextApplication用, 随session创建
            global session                          # porlet的global用, 其它用降级为session
        @EventListener(XxxEvent.class)              # 修饰方法, 外部publishEvent()时触发
实体
    注解
        @Entity                                     # 修饰bean类
        @Id                                         # id属性
        @GeneratedValue(strategy=GenerationType.AUTO)                           # 自增属性
        @Column(nullable = false, unique = true)
组件
    注解
        @Component
        @ConfigurationProperties(prefix = &quot;my&quot;)     # 注入properties对应名称的属性
dao
    注解
        @Repository                                 # 修饰类
service
    注解
        @Service                                    # 修饰类
        @PostConstruct                              # 修饰方法, 加载servlet时, init()前执行
        @PreDestroy                                 # 修饰方法, 销毁servlet时, destroy()后执行
controller
    注解
        @Controller                                 # 修饰类


  测试
  #

pom.xml
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
注解
    @Before
    @Test
    @RunWith(SpringRunner.class)                # 修饰类, 测试spring
    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)                 # 修饰类, 测试spring boot
    @LocalServerPort                            # 注入端口号
    @AutoConfigureMockMvc                       # 使用mockMvc, 用@Autowired注入MockMvc
    @WebAppConfiguration                                # 模拟ServletContext
XxxApplicationTests.java                        # junit测试
    @RunWith(SpringJUnit4ClassRunner.class)
    @SpringApplicationConfiguration(classes = XxxApplication.class)
    @WebAppConfiguration
    public class XxxApplicationTests {
        private MockMvc mvc;
        @Before
        public void setUp() throws Exception {
            mvc = MockMvcBuilders.standaloneSetup(new XxxController()).build();
        }
        @Test
        public void hello() throws Exception {
            mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))
                .addExpect(status().isOk())
                .addExpect(content().string(equalTo(&quot;hello&quot;)));
        }
    }


  数据库
  #

pom.xml
    spring-boot-starter-jdbc
    spring-boot-starter-data-jpa                            # spring data JPA
application.yml
    jpa:
        generate-ddl: false
        show-sql: true
        hibernate:
            ddl-auto: none                          # create时, 第一次create之后update
    datasource:
        platform: h2
        schema: classpath:schema.sql                # 建表
        data: classpath:data.sql                    # 数据
注解
    @Transactional                                  # 修饰方法，开启事务，或在事务中


  mybatis
  #

pom.xml
    &lt;!-- mybatis --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- mysql --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.21&lt;/version&gt;
    &lt;/dependency&gt;
application.yml
    spring:
        datasource:
            url: jdbc:mysql://127.0.0.1:3306/outrun?characterEncoding=UTF-8
            username: root
            password: asdf
            driver-class-name: com.mysql.jdbc.Driver
        jpa:
        hibernate:
            ddl-auto: update  # 新建连接必要
    mybatis:
        mapper-locations: classpath:mapper/*.xml        # 指定mapper.xml位置


mapper.xml                      # 用mbg生成
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
    &lt;mapper namespace=&quot;com.outrun.erp.mapper.UserMapper&quot;&gt;

        &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.outrun.erp.entities.User&quot;&gt;
            &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;
            &lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot; /&gt;
        &lt;/resultMap&gt;

        &lt;select id=&quot;selectUserById&quot; parameterType=&quot;long&quot; resultMap=&quot;UserMap&quot;&gt;
            SELECT name FROM user WHERE id=#{userId}
        &lt;/select&gt;

        &lt;insert id=&quot;inserUser&quot;&gt;
            &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;
                select field1 from seq1
            &lt;/selectKey&gt;
        &lt;/insert&gt;

        &lt;sql id=&quot;userColumns&quot;&gt;
            ${alias}.id, ${alias}.username
        &lt;/sql&gt;
        &lt;select id=&quot;selectColumns&quot; resultType=&quot;map&quot;&gt;
            select
                &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;tb1&quot;/&gt;&lt;/include&gt;
            from tb1
        &lt;/select&gt;

        &lt;select id=&quot;dynamicSql&quot; resultType=&quot;User&quot;&gt;
            select * from user
            where state = 0
            &lt;if test=&quot;title != null&quot;&gt;
                and title like #{title}
            &lt;/if&gt;

            &lt;choose&gt;
                &lt;when test=&quot;title != null&quot;&gt;
                    and title like #{title}
                &lt;/when&gt;
                &lt;when test=&quot;author != null and author.name != null&quot;&gt;
                    and author_name like ${author.name}
                &lt;/when&gt;
                &lt;otherwise&gt;
                    and featured = 1
                &lt;/otherwise&gt;
            &lt;/choose&gt;

            &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
                #{item}
            &lt;/foreach&gt;

            &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&gt;
                ...
            &lt;/trim&gt;

            &lt;bind name=&quot;a&quot; value=&quot;&#39;%&#39; &#43; _data.getTitle() &#43; &#39;%&#39;&quot; /&gt;
            select * from blog
            where title like #{a}
        &lt;/select&gt;

        &lt;update&gt;
            update User
                &lt;set&gt;
                    &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;
                &lt;/set&gt;
        &lt;/update&gt;

        &lt;cache&gt;                 # 该命名空间缓存
        &lt;cache-ref&gt;             # 引用其它命名空间缓存
        &lt;delete&gt;
        &lt;resultMap&gt;
            &lt;constructor&gt;       # 构造方法
                &lt;idArg&gt;         # id参数, 标记id帮助提高性能
                &lt;arg&gt;           # 普通参数
            &lt;/constructor&gt;
            &lt;id&gt;                # 标记id帮助提高性能
            &lt;result&gt;            # 普通字段
            &lt;association&gt;       # 关联
            &lt;collection&gt;        # 结构体
            &lt;discriminator&gt;     # 自动映射
        &lt;/resultMap&gt;
    &lt;/mapper&gt;
mapper/UserMapper
    @Mapper           # 如果扫描mapper.xml，不用加@Mapper
    public interface UserMapper {
        List&lt;User&gt; selectUserById(@Param(&quot;userId&quot;) long userId)

        @Select(&quot;select * from user&quot;)
        List&lt;User&gt; findAll();
    }
entities/User
    public class User {
        private Integer id;
        private String name;
        ...getter, setter...
    }
注解
    @Table(name = &quot;user&quot;)                   # 修饰类，指定表
    @Id                                     # 修饰属性, 指定主键
    @Column(name = &quot;name&quot;)                  # 修饰属性, 指定字段

    @Mapper                                 # 修饰类
    @Select(&quot;select * from user&quot;)           # 修饰方法
    @Param(&quot;userId&quot;)                        # 修饰参数
api
    SqlSessionFactory
        build
        openSession                         # 重载事务方法
    SqlSesion
        selectOne()
        selectList()
        selectMap()
        insert()
        update()
        delete()
        commit()
        rollback()
        clearCache()
        close()
    Mapper
        o-&gt;
        @Insert(&quot;insert into tb1(id, name) values(#{id}, #{name})&quot;)
        @SelectKey(statement=&quot;next value&quot;, keyProperty=&quot;id&quot;, before=true, resultType=int.class)
        int insertTable1(String name)
    SQL
        INSERT_INTO()
        VALUES()

        o-&gt;
        new SQL(){{
            SELECT(&quot;a.name&quot;);
            SELECT(&quot;a.age&quot;);
            FROM(&quot;tb1 a&quot;);
            WHERE(&quot;a.name like ?&quot;);
        }}.toString()
    LogFactory
        useSlf4jLogging()
        useLog4jLogging()
        useStdOutLogging()


  web
  #

# 用的spring mvc
pom.xml
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 # web模块, 有tomcat, spring mvc
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            # 测试模块, 有JUnit, Hamcrest, Mockito
    &lt;/dependency&gt;
application.yml
    server
        port: 8080                                      # 默认8080
        servlet
            context-path: /hello                        # uri前缀
静态资源
    默认映射public, resources, static到/
注解
    控制器
        @RestController                             # 修饰类, 组合@Controller与@responseBody
        @RequestMapping(&quot;/index&quot;)                   # 修改类或方法, url
            @GetMapping(&quot;/{id}&quot;)                    # 相当于@RequestMapping(method=RequestMethod.GET)
            @PostMapping
            @PutMapping
            @DeleteMapping
            @PatchMapping
        @CrossOrigin                                # 修饰方法, 允许跨域
        @RequestBody                                # 修饰方法, 解析body到参数
        @PathVariable Long id                       # 修饰参数, 接收url参数
内置对象
    ServerProperties                                # 单例可@Autowired, 存端口之类属性
自实现
    XxxController.java
        @RestController
        public class HelloController {
            @RequestMapping(&quot;/hello&quot;)
            public String index() {
                return &quot;hello&quot;;
            }
        }


  日志
  #

application.yml
    logging:
        level:
            root: INFO
            org.hibernate: INFO
            org.hibernate.type.descriptor.sql.BasicBinder: TRACE
            org.hibernate.type.descriptor.sql.BasicExtractor: TRACE
注解
    @Slf4j                                      # 修饰类，其中可直接用log变量
    @EnableSwagger2                             # 修饰类
    @Api(tags = &quot;&quot;)                             # 修饰类, 文档
    @ApiModel(&quot;&quot;)                               # 修饰类
    @ApiModelProperty(&quot;)                        # 修饰属性
    @ApiOperation(value=&quot;&quot;, notes=&quot;&quot;)           # 修改方法, 文档
    @ApiIgnore                                  # 修饰方法, 文档忽略


  jackson
  #

注解
    @JsonInclude                                # 修饰类, 序列化时包含
        @JsonInclude(JsonInclude.Include.NON_EMPTY)                 # null或&quot;&quot;时不序列化
    @JsonIgnore                                 # 修饰属性


  Scheduled
  #

scheduled
    注解
        @Scheduled                                  # 修饰方法, 定时调度
            @Scheduled(initialDelay = 1000, fixedRate = 1000)
    类
        @Configuration
        implements SchedulingConfigurer             # 配置类
            configureTasks(ScheduledTaskRegistrar)
                registrar.setScheduler(Executors.newScheduledThreadPool(2));    # worker池
async
    注解
        @Async                                      # 修饰方法, 异步调用 
    类
        implements AsyncUncaughtExceptionHandler    # 处理@Async异常
            @Override
            public void handleUncaughtException()

        @Configuration
        @EnableAsync
        implements AsyncConfigurer
            @Bean
            @Override
            public Executor getAsyncExecutor()

            @Override
            public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler()             # 处理无返回值＠Async方法异常
                return handler
    使用
    @Async
    Future&lt;String&gt; fetch(){
        return new AsyncResult&lt;String&gt;(&quot;&quot;)
    }
    future = fetch()
    try{
        future.get()
    }


  热部署
  #

pom.xml
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;                                       # 热部署
    &lt;/dependency&gt;
application.yml
    spring:
        devtools:
        restart:
            enabled: true
            additional-paths: src/main/java


  jsp
  #

pom.xml
    &lt;!-- servlet依赖. --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!-- tomcat的支持.--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
application.yml
    spring:
        mvc:
        view:
            prefix: /WEB-INF/views/
            suffix: .jsp
controller类
    @Controller
    public class XxxController {
        @RequestMapping(&quot;/xxx&quot;)
        public String xxx(Model m) {
            m.addAttribute(&quot;a&quot;, 1);
            return &quot;view1&quot;;
        }
    }
src/main/webapp/WEB-INF/views/view1.jsp
    &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;
    jsp ${a}


  lombok
  #

注解
    @Builder                            # 修饰类, 可build方式设置属性
    @Getter                             # 修饰类, 生成getter
    @Setter                             # 修饰类, 生成setter
    @ToString                           # 修饰类, 生成toString方法
    @Data                               # 修饰类, 注入getter, setter, toString
    @NoArgsConstructor                  # 修饰类, 生成无参构造方法
    @AllArgsContructor                  # 修饰类, 生成带所有参数的构造方法
    @RequiredArgsConstructor            # 修饰类, 生成带常量、@NotNull修饰变量参数的构造方法
        @RequiredArgsConstructor(onConstructor_ = @Autowired)               # 构造类时，自动对private final 属性@Autowire


  remote shell
  #

pom.xml
    spring-boot-starter-remote-shell


  actuator
  #

pom.xml
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
原生端点
    应用配置类
        /autoconfig                                 # 自动化配置详情
            positiveMatches	                        # 成功
            negativeMatches
        /beans                                      # 所有bean
        /configprops                                # 属性
        /env                                        # 环境属性
        /mappings                                   # spring mvc映射关系
        /info                                       # 自定义信息，默认为空，用info前缀定义
    度量指标
        /metrics                                    # 程序信息，内存、线程、gc等
            nonheap.*                               # 非堆内存
            gauge.*                                 # http请求性能，如gauge.response表示上次延迟
            counter.*                               # 记录累计，如counter.status.200表示返回200的次数
        /metrics/{name}                             # 查看某项
            /metrics/mem.free
        /health                                     # 启动状态，磁盘空间
            DiskSpaceHealthIndicator                # 低磁盘空间
            DataSourceHealthIndicator               # DataSource连接是否可用
            MongoHealthIndicator
            RabbitHealthIndicator
            RedisHealthIndicator
            SolrHealthIndicator
        /dump                                       # 线程信息
        /trace                                      # 跟踪信息
    操作控制                                         # 用属性配置开启
        /shutdown                                   # 关闭端点
            通过endpoints.shutdown.enabled=true开启
自定义counter统计
    @Autowired
    private CounterService counterService;
    counterService.increment(&quot;didispace.hello.count&quot;)
自定义health检测器
    @Component
    public class RocketMQHealthIndicator implements HealthIndicator {
        private int check(){}
        @Override
        public Health health() {
            int errorCode = check();
            if (errorCode !=0) {
                return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();
                return Health.up().build();
            }
        }
    }


  spring boot admin
  #

application.yml
    spring:
        application:
            name: erp-admin-server
        boot:
            admin:
                routes:
                    endpoints: env,metrics,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream
    endpoints:
        health:
            sensitive: false
            enabled: true
        actuator:
            enabled: true
            sensitive: false
        beans:
            sensitive: false
            enabled: true


  spring initializer
  #

介绍
    生成spring基础项目


  spring security
  #

配置
    application.yml
        security:   
            basic:
                enabled: false                          # 禁用security
注解
    @EnableWebSecurity                                  # 修饰WebSecurityConfigurerAdapter, 开启web验证
    @EnableGlobalMethodSecurity(prePostEnabled = true)  # 修饰WebSecurityConfigurerAdapter, 开启方法验证
    @PreAuthorize                                       # 修饰controller方法
api
    Subject                                             # 主体数据结构, 如用户
    SecurityManager                                     # 安全管理器, 管理所有subject
    UserDetails
        getAuthorities()
        getUsername()
        getPassword()
        isAccountNonExpired()
        isAccountNonLocked()
        isCredentialsNonExpired()
        isEnabled()
    GrantedAuthority
        getAuthority()
    WebSecurityConfigurerAdapter
        configure(HttpSecurity)                         # 验证请求
        configure(AuthenticationManagerBuilder)         # 验证数据，需要授权服务配置AuthenticationManager
            userDetailService
            passwordEncoder
        authenticationManagerBean()                     # 指定管理bean


  spring security oauth2
  #

pom.xml
    spring-cloud-starter-oauth2
结构    
    OAuth2 Provider
        Authorization Service                           # 授权服务
        Resource Service                                # 资源服务
        Spring Security过滤器
            /oauth/authorize                            # 授权
            /oauth/token                                # 获取token
授权服务
    applicatoin.yml                                     # server
        security:   
            oauth2:
                resource:
                    filter-order: 3
    注解
        @EnableAuthorizationServer                      # 修饰AuthorizationServerConfigurerAdapter, 开启授权服务
    api
        AuthorizationServerConfigurerAdapter            # 授权服务配置
            configure(ClientDetailsServiceConfigurer)                           # 客户端信息
                clientId
                secret
                scope
                authorizedGrantTypes                    # password, refresh_token, client_credentials
                authorities                             # 具体权限
            configure(AuthorizationServerEndpointsConfigurer)                   # 使用token的服务
                authenticationManager                   # 密码认证
                    authenticate(Authentication)
                userDetailService                       # 获取用户数据
                    loadUserByUsername(String)
                authorizationCodeServices               # 验证码
                implicitGrantService
                tokenGranter
                tokenStore
                    InMemoryTokenStore
                    JdbcTokenStore
                    JwtTokenStore
            configure(AuthorizationServerSecurityConfigurer)                    # 使用token服务的安全策略, 授权服务与资源服务分离时配置
    接口
        Principal /users/current
    测试
        insert into user(username, password) values(&#39;outrun&#39;, &#39;$2a$10$l7.7AJEHtXukwUZiKAyVSO6lHJOyHhPxHvi7MHawe8SjlOKkCVbAe&#39;)
        curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf
        浏览器
            url: localhost:9016/uaa/oauth/token
            header
                &#39;Authorization&#39;: &#39;Basic &#39; &#43; base64(&#39;erp-auth-resource:asdf&#39;)
            data
                username: &#39;outrun&#39;
                password: &#39;123456&#39;
                grant_type: &#39;password&#39;
资源服务
    application.yml                                     # client
        security:
            oauth2:
                resource:
                    user-info-uri: http://localhost:9016/uaa/users/current
                client:
                    clientId: erp-auth-resource
                    clientSecret: asdf
                    accessTokenUri: http://localhost:9016/uaa/oauth/token
                    grant-type: client_credentials,password
                    scope: server
    注解
        @EnableResourceServer                           # 修饰ResourceServerConfigurerAdapter, 开启资源服务
                                                        # 修饰AuthorizationServerConfigurerAdapter, 因为授权服务提供token获取和验证接口
        @PreAuthorize(&quot;hasAuthority(&#39;ROLE_ADMIN&#39;))      # 修饰controller方法，验证权限
    api
        ResourceServerConfigurerAdapter                 # 资源服务配置
            configure(HttpSecurity)
                authorizeRequests                       # 请求放行
    测试
        curl -d &quot;username=outrun&amp;password=asdf&quot; &quot;localhost:9017/user/registry&quot;
        insert into role values(1, &#39;ROLE_USER&#39;), (2, &#39;ROLE_ADMIN&#39;)
        insert into &#39;user_role&#39; values(user_id, 2)
        curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf
        curl -l -H &quot;Authorization:Bearer 7df6669c-0c86-417b-827f-9a58297f57e5&quot; -X GET &quot;localhost:9017/hello&quot;
客户端
    注解
        @EnableOAuth2Client                             # 修饰[Oauth2ClientConfig], 客户端
    api
        [Oauth2ClientConfig]                            # 客户端配置, 自定义类，名称任意
            ClientCredentialsResourceDetails            # bean, 资源信息
            RequestInterceptor                          # bean, 保存请求上下文
            OAuth2RestTemplate                          # bean, 用于向授权服务发送请求
表
    clientdetails
    oauth_access_token
    oauth_approvals
    oauth_client_details
    oauth_client_token
    oauth_code
    oauth_refresh_token


  spring integration
  #

# 服务编排
">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://runout.run/docs/pl/java/spring/">
  <meta property="og:site_name" content="outrun的笔记">
  <meta property="og:title" content="outrun的笔记">
  <meta property="og:description" content="基础 # 特点 容器, 也容纳管理了第三方框架 # 目的是解耦框架api 轻量级，模块化，无(少)侵入 IOC(inversion of control) 容器用工厂装配对象并管理, 面向接口编程 优点 降低代码量 容易测试 最小侵入性松耦合 方式 Setter 构造器 静态工厂、实例工厂 DI(dependency injection) 容器向类添加属性 # 反射，用带参构造或set方法 AOP(aspect oriented programming) # 继承是纵向组织，AOP横切入业务 # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用） 动态代理实现切入代码 权限控制 事务管理 记录日志 概念 连接点:普通方法 切入点:名称满足条件的连接点 增强（通知）类:服务对象 # 切入点与增强是多对多的 切面:切入点 &#43; 增强类 # 我们切入的是横切面 目标对象（服务对象）：要注入的对象 通知 before # 执行前 after # 执行后 after-returning # 正常退出 after-throwing # 异常退出 around # 执行前后 代理对象(业务对象)：被注入的对象 模块 dao, orm, aop, jee, web, core 结构 核心容器(core container) Core # 最底层，资源访问，类型转换 Beans # IOC, DI, BeanFactory Context # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播 EL # 表达式语言 AOP, Aspects # Aspects对AspectsJ集成, 功能多于spring asp 数据访问/集成 JDBC ORM OXM # object xml 映射 JMS # 消息与异步通信 事务 Web/Remoting Web # ioc窗口，rmi, hessian,burlap, web service Web-Servlet Web-Struts Web-Porlet # portal认证 Test 设计模式 代理 目标对象实现接口，使用Proxy 未实现接口，使用CGLIB 单例 bean默认单例 模板, 解决代码重复问题 RestTemplate, JmsTemplate, JpaTemplate 控制器 DispatherServlet对请求分发 视图帮助(view helper) 提供jsp标签、高效宏 帮助在视图中写代码 依赖注入 BeanFactory, ApplicationContext核心理念 工厂 BeanFactory 循环依赖问题 构造器, 正在创建在Bean池标记，创建完删除标记，标记冲突报错 # 所以用@Autowired决定注入时机，不写在构造方法里 单例， 三级缓存, 提前暴露使双方都可初始化 setter, 提前暴露bean 版本 2.5 注解 3.2 基于注解的注入测试类@RunW.. 使用 # jar包 ： 核心包：/dist/modules # 或是/dist中的spring.jar包 core模块 beans context context-support core 日志包：/lib/jakata-commons/commons-logging.jar 创建xml文件(最好在JavaBean的旁边) 绑定约束文件 /dist/resources/spring-beans-2.5.xsd copy xml文件的头：/sample/petclinic/war/web-inf/app...xml 创建JavaBean.java xml文件中配置bean # src下 &lt;bean id=&#34;&#34; class=&#34;&#34;&gt; # id值唯一,class指定 javaBean的类目录 &lt;property name=&#34;&#34; value=&#34;&#34;&gt; &lt;property name=&#34;&#34; ref=&#34;girlID&#34;&gt; # 引用类型，其中girlID为spring配置的bean Id 业务类中 ApplicationContext ac = new ClassPathXmlApplicationContext(new String [] {&#34;配置xml文件路径&#34;}) # 注意：ac创建时，其内部的JavaBean默认全部实例化一遍，并且全部注入了属性 ## 该容器不用关闭 if(ac.containsBean(&#34;boyID&#34;)){ Boy boy = (Boy)ac.getBean(&#34;boyID&#34;); } api # ApplicationContext是一个接口，表示spring容器/ioc容器 ClassPathXmlApplicationContext # 只从类路径中读取xml配置文件（src/目录下能访问的路径）省略src/目录 FileSystemXmlApplicationContext # 文件路径 ,从src/开始 ac.getBean(&#34;boyID&#34;) ac.containsBean(&#34;boyID&#34;) # 通过此方法去判断是否存在 ，而不是得到的是否为null ac.destroy() # ac中的bean实例全部销毁 BeanFactory # 基础IOC容器, 默认延迟初始化 DefaultListableBeanFactory ApplicationContext XmlBeanFactory # 根据xml中的定义加载bean Spring-DAO # 提供规范, 翻译框架(JDBC&lt;Hibernate,JPA等)异常为DataAccessException @Repository 注解DAO类 Spring-JDBC # 模板类 DataSource JdbcTemplate JdbcDaoSupport # 对dao扩展, DataAccessExceptions异常翻译器 Spring-ORM # 统称，对各模块(JPA,JDO,Hibernate,iBatis,TopLink,OJB)实现了spring的集成类 把DataSource注入到SessionFactory或EntityManagerFactory等bean中 # jdbc不需要，因为jdbc直接使用DataSource HibernateTemplate HibernateDAOSupport # 继承它提供aop拦截器 Web # 在ApplicationContext基础上, 提供web上下文和面向web的服务 ApplicationContext # 以BeanFactory为基础,容器启动后默认全部初始化绑定 FileSystemXmlApplicationContext # 指定文件 ClassPathXmlApplicationContext # 从classpath找设置 WebXmlApplicationContext 注解 # applicationContext.xml &lt;context:annotation-config/&gt; &lt;!-- 添加注解扫描功能,启动的时候哪些包要检查是否有注解 --&gt; &lt;context:component-scan base-package=&#34;xxx&#34; /&gt; @Required # setter @Autowired # setter、构造方法、变量 @Qualifier(&#34;dataSource) # 多类配置时，指定使用类 @Bean # 返回对象注册为bean @Configuration # bean定义 @Service # 添加类名小写的spring bean id 也可以@Service(value=&#34;xx&#34;)自定义id ## action类前换成@Controller @Service也是可以的 @Scope(value=&#34;prototype&#34;) # 工具类或其它组件类换成@Component 也可以@Service,如定时器TimerTask就是组件 @Resource # 按属性名注入资源 测试类 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = &#34;classpath:applicationContext*.xml&#34;) @PostConstruct # 类加载时运行的方法，相当于xml中配置的init-method @PreDestroy # 类销毁前运行的方法 aop applicationContext.xml &lt;aop:aspectj-autoproxy/&gt; @Aspect # 注册一个类为切面 @Pointcut(value=&#34;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&#34;) # 配置切点表达式 private void testAop(){} @AfterReturning(pointcut=&#34;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&#34;) # 配置通知，在通知中配置切点 @AfterReturning(value=&#34;testAop()&#34;) # 配置通知，使用已经配置的切点 @Around(value=&#34;testAop()&#34;) # 配置通知，使用已经配置的切点 @Around(value=&#34;execution(* cn.it.shop.service.impl.GoodsServiceImpl.queryByWord(..))&#34;) # 配置通知，在通知中配置切点,注意这里没有pointcut,只有value 模块 # 监听器 # 原理 org.springframework.web.context.ContextLoaderListener中 this.contextLoader.initWebApplicationContext(event.getServletContext()); # 加载Spring 的配置文件 ，加载Application内置对象中 initWebApplicationContext方法中 this.context = createWebApplicationContext(servletContext, parent); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); # 创建并存储spring的application内置对象到ServletContext中，属性名称是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE createWebApplicationContext方法中 wac.setConfigLocation(sc.getInitParameter(CONFIG_LOCATION_PARAM)); # 该类文件中有：public static final String CONFIG_LOCATION_PARAM = &#34;contextConfigLocation&#34;; # 获得web.xml中配置的context-param初始化参数：contextConfigLocation的内容，并加载spring配置文件 使用 servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext) properties # spring xml配置文件中使用properties配置的属性 配置一个bean的class类是org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer的单例bean &lt;property name=&#34;locations&#34; value=&#34;classpath:public.properties&#34; &gt; &lt;array&gt; &lt;value&gt;classpath:conn.properties&lt;/value&gt; 或 &lt;property name=&#34;location&#34; value=&#34;classpath:conn.properties&#34; /&gt; xml文件中用&#34;${driver}&#34;的方式引用properties中配置的属性 java类中用spring的注解注入properties配置的属性 # 要求必须是spring管理的类 bean中的class类换成org.springframework.beans.factory.config.PropertiesFactoryBean id=&#34;Xxx&#34;其它相同 java类的属性或set方法上添加注解： @Value(&#34;#{public.basePath}#{public.filePath}&#34;) # 其中public 是上面配置的bean的id(xml文件中注入属性的话用不到id,所以没有配置) ## &#39;#{}&#39;代表引用属性 ## &#39;.&#39;可以用&#39;[]&#39;代替，如public[basePath] ## 字符串的拼接可以用&#43;连接 # 第一次配置@Value的时候不会成功，改一次值再试就可以了 bean # 创建bean的顺序 xml中按配置顺序的先后 注解中按照字母的顺序 生命周期 配置中定义&lt;bean&gt;&lt;/bean&gt; 初始化 配置文件中init-method 实现org.springframework.beans.factory.InitializingBean接口 调用 销毁 配置文件中destroy-method 实现org.springframework.bean.factory.DisposeableBean scope # 默认singleton prototype # 每次产生新对象 singleton # 单例 request # 一个请求一个对象，只在ApplicationContext下有效 session # 一个session一个对象，只在ApplicationContext下有效 global-session # 一个全局session一个对象, 只在ApplicationContext下有效 内部bean &lt;property&gt;或&lt;constructor-arg&gt;中定义的&lt;bean&gt;,通常匿名 注入对象 &lt;list&gt; &lt;set&gt; &lt;map&gt; &lt;props&gt; # 键值都只能是string类型 自动装配 方式 no # 不自动装配，通过ref属性指定 byName 查找类中setter 容器中找id 报空指针 byType 容器中找类型 # 找到多个时抛异常 constructor byType带构造函数参数 autodetect 先试constructor, 再试byType 写法 &lt;bean&gt;属性autowire=&#34;byName&#34; @Autowired 类型自动装配 加上@Qualifier(value=&#34;a&#34;) @Resource(name=&#34;a&#34;)注解的name装配 byName装配 byType装配 配置 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xmlns:context=&#34;http://www.springframework.org/schema/context&#34; xsi:schemaLocation=&#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&#34;&gt; &lt;bean id=&#34;userDaoID&#34; name=&#34;&#34; class=&#34;cn.itcast.javaee.spring.bean.life.UserDao&#34; init-method=&#34;getSession&#34; destroy-method=&#34;closeSession&#34; factory-method=&#34;getUserDao&#34; scope=&#34;singleton&#34; lazy-init=&#34;false&#34; parent=&#34;userDaoID&#34; abstract=&#34;true&#34; autowire=&#34;no&#34;&gt; &lt;constructor-arg type=&#34;java.lang.Integer&#34; index ref&gt; &lt;value&gt;2013&lt;/value&gt; &lt;constructor-arg type=&#34;java.lang.Double&#34;&gt; &lt;value&gt;6000&lt;/value&gt; &lt;property name=&#34;name&#34; value=&#34;aa&#34;&gt;&lt;/property&gt; &lt;property name=&#34;name&#34; ref=&#34;dateID&#34; /&gt; &lt;property name=&#34;telSet&#34;&gt; &lt;set&gt; &lt;value&gt;11&lt;/value&gt; &lt;property name=&#34;cityList&#34;&gt; &lt;list&gt; &lt;value&gt;&lt;/value&gt; &lt;property name=&#34;telCityMap&#34;&gt; &lt;map&gt; &lt;entry key=&#34;&#34;&gt; &lt;value&gt;&lt;/value&gt; &lt;property name=&#34;&#34;&gt; &lt;props&gt; &lt;prop key=&#34;&#34;&gt;&lt;/prop&gt; 标签、属性分析 bean标签：代表一个JavaBean # 多个JavaBean配置时，先配置的先创建，先创建的后销毁 id：该JavaBean的唯一标识 name：可以和id一样用，但是name可以设置&#34;/a&#34;来绑定路径 class：该JavaBean的类路径 init-method：创建该JavaBean时运行的其中的方法 destroy-method：销毁该JavaBean时运行的其中的方法 # ClassPathXmlApplicationContext类的实例不监听销毁方法 ## 用AbstractApplicationContext中的close()与registerShutdownHook()方法 ## close()直接马上销毁，registerShutdownHook()方法会注册关闭钩子,监听容器的销毁 ## factory-method：创建该Bean的函数 得到接口实现类的方法 1.通过实现类的无参构造器 # 没有factory-method属性 2.没有无参构造器时，工厂静态方法创建实例 &lt;bean id=&#34;userDaoID&#34; factory-bean=&#34;daoFactoryID&#34; factory-method=&#34;getUserDao&#34;&gt; # class中的内容是工厂类，而非UserDao类，factory-method是工厂类中返回UserDao类的静态方法 3.没有无参构造器时，工厂非静态方法创建实例 &lt;bean id=&#34;daoFactoryID&#34; class=&#34;cn.itcast.javaee.spring.bean.create.type3.DaoFactory&#34;&gt; &lt;bean id=&#34;userDaoID&#34; factory-bean=&#34;daoFactoryID&#34; factory-method=&#34;getUserDao&#34;&gt; # 先实例化工厂（Spring 加载本xml文件默认实例化），然后静态方法的配置即可 scope：作用域 1.singleton（单例）是默认值，是单例的，会调用init destory方法 2.prototype（原型）每次创建一个实例， 调用init方法，但不调用destory方法（实例的维护 ：javase程序交给jvm,javaee程序交给服务器） lazy-init 1.false:为启动容器时立即创建一个实例 # singleton与prototype模式都会创建 2.true:启动时不加载,获取时创建 parent： 继承一个Spring bean(包含其中的所有属性) # javaBean类中不必有实际的继承关系（但是有继承关系则必要配置parent） abstract=&#34;true&#34; : 配置此Bean为抽象Bean autowire=&#34;no&#34;:自动装配，只能装配关联属性 # 还可以进行注解装配 byName 装配时根据bean中的每个属性名从spring中找id同名的bean,通过setter方法注入到该属性中 byType 根据bean中的每个属性的类型找到spring中映射该类型的bean进行装配,通过setter方法注入到该属性中 constructor 找满参构造器装载，构造器中的参数以byType方式注入 autodetect 先找构造器装载，再set方法注入。但实际使用中只能set方法注入 no 不注入 可以配置init-method与destroy-method属性来配置该bean创建和销毁时执行的方法 注入值 # 通过setter方法注入值 &lt;constructor-arg type=&#34;java.lang.Integer&#34; index ref&gt; &lt;value&gt;2013&lt;/value&gt; # 传入构造方法参数注入值，,位置不能颠倒，不调用setter方法 ## type是注入参数的类型，index是参数的标号，从0开始，ref是引用类型,有引用类型时不用&lt;value&gt;标签 &lt;property name=&#34;name&#34; value=&#34;aa&#34;/&gt; # 基本类型直接赋值（包括包装类型与String） &lt;property name=&#34;name&#34; ref=&#34;dateID&#34;/&gt; # 引用类型,dateID是一个Spring Bean ## 可以直接引用Spring Bean 的id &lt;set&gt; &lt;value&gt;&lt;/value&gt; # set集合 &lt;list&gt; &lt;value&gt;&lt;/value&gt; # list集合 &lt;map&gt; &lt;entry key=&#34;&#34;&gt; &lt;value&gt;&lt;/value&gt; # map集合 # 集合的值均可配置引用类型 &lt;property name=&#34;&#34;&gt; &lt;props&gt; &lt;prop key=&#34;&#34;&gt;&lt;/prop&gt; # 属性类型，只能配置基本类型 （包括包装类型与String） aop # 实现 # 基于Aspectj 原理 启动容器时，创建目标对象与代理对象 &lt;aop:config/&gt;加载完时,通过cglib创建目标对象的代理对象，运行时产生 程序员-代理对象-代理方法-目标对象-目标方法-代理对象 使用 写类文件 1.jar包 aspectjweaver.jar/aspectjrt.jar/cglib-nodep-2.1_3.jar(动态代理包) 2.配置xml文件头,保留aop &lt;bean id class/&gt; # 目标对象 &lt;bean id=&#34;serviceBeanID&#34; class /&gt; # 配置增强对象 &lt;aop:config&gt; # 相当于创建了代理对象 &lt;aop:pointcut id=&#34;xxxx&#34; expression=&#34;&#34; /&gt; # 切入点表达式：expression=&#34;execution(public void addUser() throws java.lang.Exception)&#34; ## 可以写成execution(public void 类名.*()),表示匹配所有方法 ## execution(* *(..)) 第一个*是返回值，第二个*是方法，..表示参数不限 ## 可以声明抛异常 ## 条件命名为xxxx,升级连接点到切入点 &lt;aop:aspect ref=&#34;serviceBeanID&#34;&gt; &lt;aop:before method=&#34;writeLog&#34; pointcut-ref=&#34;xxxx&#34;/&gt; # 前置增强，method是注入的方法，xxxx是增强的条件,只能写一个方法 &lt;aop:after/&gt; &lt;aop:after-returning/&gt; # 方法返回后执行 &lt;aop:after-throwing/&gt; # 抛出异常时执行 &lt;aop:around/&gt; # 环线，执行目标方法前、后都执行,出错则之后的函数不执行 public void both(ProceedingJoinPoint pjp){ # ProceedingJoinPoint是连接代理对象 与目标对象的桥梁 open(); pjp.proceed(); # 执行目标代码 close(); } # 目标方法出错，后置增强仍然执行,after-throwing执行，前置增强不执行,after-returning不执行 &lt;aop:advisor advice-ref=&#34;txAdvice&#34; pointcut-ref=&#34;xxxx&#34;/&gt; # 配置事务的切面 切入点表达式 execution(方法的修饰符 方法的返回值类型 方法所属的类 方法名 方法中参数列表 方法抛出的异常) 方法的修饰符： 支持通配符*，可省略 方法的返回值类型：支持通配符*，表示所有返回值，不可省 方法所属的类： 支持通配符*，可省略 方法名： 支持通配符*，表示所有方法，不可省 方法中参数列表： 支持通配符*，不可省 # *表示【一个】任意类型的参数 ## ..表示零个或一个或多个任何类型的参数【提倡】 execution(方法的返回值类型 方法名（方法中参数列表）） # 一般形式 例如: execution(public void add()throws Exception) execution(public void add(..)throws Exception) execution(public void add(*)throws Exception) execution(* cn.itcast.web.spring.aop.UserDao.add(..)) execution(* add()throws Exception) execution(public void *(..)throws Exception) execution(public void a*(..)throws Exception)：方法名以a字符开始 execution(public void *d(..)throws Exception)：方法名以d字符结束 execution(* add()) execution(* *(..)) 切点方法的编写 public void Xxx(JoinPoint joinPoint){ joinPoint.getTarget(); # 获取目标对象 joinPoint.getSignature(); # 获取当前连接点的方法信息 joinPoint.getArgs()[0]; # 获取当前连接点的第一个参数 .. } public Goods Yxx(ProceedingJoinPoint joinPoint){ Object object = joinPoint.proceed(); # 得到连接点的返回值 .. return goods; # 本切面返回的数据会作为切点返回的数据返回给调用它的函数 } dao # 使用 1.xml文件中 &lt;!-- 配置C3P0连接池 --&gt; &lt;bean id=&#34;comboPooledDataSourceID&#34; class=&#34;com.mchange.v2.c3p0.ComboPooledDataSource&#34;&gt; &lt;property name=&#34;driverClass&#34; value=&#34;com.mysql.jdbc.Driver&#34;/&gt; &lt;property name=&#34;jdbcUrl&#34; value=&#34;jdbc:mysql://127.0.0.1:3306/spring&#34;/&gt; &lt;property name=&#34;user&#34; value=&#34;root&#34;/&gt; &lt;property name=&#34;password&#34; value=&#34;root&#34;/&gt; &lt;property name=&#34;initialPoolSize&#34; value=&#34;60&#34;/&gt; &lt;property name=&#34;acquireIncrement&#34; value=&#34;5&#34;/&gt; &lt;/bean&gt; &lt;!-- 配置JdbcTemplate --&gt; &lt;bean id=&#34;jdbcTemplateID&#34; class=&#34;org.springframework.jdbc.core.JdbcTemplate&#34;&gt; &lt;property name=&#34;dataSource&#34; ref=&#34;comboPooledDataSourceID&#34;/&gt; &lt;/bean&gt; &lt;!-- 配置UserDao --&gt; &lt;bean id=&#34;userDaoID&#34; class=&#34;dao.UserDao&#34;&gt; &lt;property name=&#34;jt&#34; ref=&#34;jdbcTemplateID&#34;/&gt; &lt;/bean&gt; 2.Dao中 private JdbcTemplate jt; addUser() String sql = &#34;&#34;; Object [] params = {user.getUsername(),user.getPassword()} jt.update(sql,params); 批量： for(int i = 0; i &lt; ids.length; i&#43;&#43;){ sqls[i] = &#34;&#34;; } jt.batchUpdate(sqls); 查询一个 return (User)jt.queryForObject(sql,params,new RowMapper(){ public Object mapRow(ResultSet rs,int rowNum){ # rs是查询出来的结果集,rowNum是结果集的行号,从0开始 Integer id = rs.getInt(&#34;id&#34;); User user = new User(id); return user; } }); 查询多个 # query方法把RowMapper帮助类中返回的user分别加入到list中，返回一个list list = jt.query(sql,new RowMapper(){ public Object mapRow() .. return bean; }) 分页 String sql = &#34;select * from users limit ?,?&#34;; Object[] params = {0,3}; jt.query(sql,params,new RowMapper(){ 记录 jt.queryForInt(sql); 事务 # TransactionInterceptor transactionManager # 指定事务治理类 transactionAttributes # key方法名 value事务属性 注解 @Transactional(propagation = Propagation.REQUIRED) 手写 # TransactionDefinition Public class BankServiceImpl implements BancService{ Private BanckDao bankDao; private TransactionDefinition txDefinition; private PlatformTransactionManager txManager; public boolean transfer(Long fromId, Long toId, double amount) { TransactionStatus txStatus = txManager.getTransaction(txDefinition); boolean result = false; try { result = bankDao.transfer(fromId, toId, amount); txManager.commit(txStatus); } catch (Exception e) { result = false; txManager.rollback(txStatus); System.out.println(&#34;Transfer Error!&#34;); } return result; } } 手写 # TransactionTemplate public class BankServiceImpl implements BankService { private BankDao bankDao; private TransactionTemplate transactionTemplate; public boolean transfer(final Long fromId, final Long toId, final double amount) { return (Boolean) transactionTemplate.execute(new TransactionCallback(){ public Object doInTransaction(TransactionStatus status) { Object result; try { result = bankDao.transfer(fromId, toId, amount); } catch (Exception e) { status.setRollbackOnly(); result = false; System.out.println(&#34;Transfer Error!&#34;); } return result; } }); } } 配置 # TransactionInterceptor &lt;bean id=&#34;transactionInterceptor&#34; class=&#34;org.springframework.transaction.interceptor.TransactionInterceptor&#34;&gt; &lt;property name=&#34;transactionManager&#34; ref=&#34;transactionManager&#34;/&gt; &lt;property name=&#34;transactionAttributes&#34;&gt; &lt;props&gt; &lt;prop key=&#34;transfer&#34;&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&#34;bankServiceTarget&#34; class=&#34;footmark.spring.core.tx.declare.origin.BankServiceImpl&#34;&gt; &lt;property name=&#34;bankDao&#34; ref=&#34;bankDao&#34;/&gt; &lt;/bean&gt; &lt;bean id=&#34;bankService&#34; class=&#34;org.springframework.aop.framework.ProxyFactoryBean&#34;&gt; &lt;property name=&#34;target&#34; ref=&#34;bankServiceTarget&#34;/&gt; &lt;property name=&#34;interceptorNames&#34;&gt; &lt;list&gt; &lt;idref bean=&#34;transactionInterceptor&#34;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 配置 # TransactionProxyFactoryBean &lt;bean id=&#34;bankServiceTarget&#34; class=&#34;footmark.spring.core.tx.declare.classic.BankServiceImpl&#34;&gt; &lt;property name=&#34;bankDao&#34; ref=&#34;bankDao&#34;/&gt; &lt;/bean&gt; &lt;bean id=&#34;bankService&#34; class=&#34;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&#34;&gt; &lt;property name=&#34;target&#34; ref=&#34;bankServiceTarget&#34;/&gt; &lt;property name=&#34;transactionManager&#34; ref=&#34;transactionManager&#34;/&gt; &lt;property name=&#34;transactionAttributes&#34;&gt; &lt;props&gt; &lt;prop key=&#34;transfer&#34;&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 配置 # tx空间 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xmlns:aop=&#34;http://www.springframework.org/schema/aop&#34; xmlns:context=&#34;http://www.springframework.org/schema/context&#34; xmlns:tx=&#34;http://www.springframework.org/schema/tx&#34; xsi:schemaLocation=&#34; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&#34;&gt; &lt;!--配置c3p0连接池--&gt; &lt;!-- 配置JdbcTemplate类 --&gt; &lt;!-- 配置Dao --&gt; &lt;!-- 配置jdbc事务管理器 --&gt; &lt;bean id=&#34;dataSourceTransactionManagerID&#34; class=&#34;org.springframework.jdbc.datasource.DataSourceTransactionManager&#34;&gt; &lt;property name=&#34;dataSource&#34; ref=&#34;comboPooledDataSourceID&#34;/&gt; &lt;/bean&gt; &lt;!-- 配置事务增强(服务对象) --&gt; &lt;tx:advice id=&#34;txAdvice&#34; transaction-manager=&#34;dataSourceTransactionManagerID&#34;&gt; &lt;tx:attribute&gt; &lt;tx:method name=&#34;addUsers&#34; # 可以用通配符&#34;*users&#34; propagation=&#34;required&#34; # 传播行为：事务开始、结束的时间。required 保证方法执行时事务已开始，事务开始时不创建，没有开始时创建 isolation=&#34;default&#34; # 隔离级别 timeout=&#34;-1&#34; # 事务超时,-1代表不超时，用数据库底层的配置 rollback-for:&#34;java.lang.Exception&#34; # 何时回滚 read-only=&#34;false&#34; # 不只读 # name 方法名的匹配模式 # required : 外部存在事务，则加入外部事务，不存在则新建事务 # requires_new : 总是新建事务 # mandatory : 外部必须存在事务 # never : 外部不能存在事务 # supports : 外部存在则加入，不存在则不以事务方式运行 # not_supported : 总是非事务 # nested : 外部存在事务，嵌套执行，不存在则新建 # no-rollback-for 以逗号分隔异常，这些异常不会导致事务回滚 # rollback-for 导致事务回滚的异常 /&gt; &lt;tx:attribute&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&#34;xxxx&#34; expression=&#34;execution(public void *Users(..))&#34;/&gt; ## 任意公共方法的执行： execution(public * *(..)) 任何一个以“set”开始的方法的执行： execution(* set*(..)) AccountService 接口的任意方法的执行： execution(* com.xyz.service.AccountService.*(..)) 定义在service包里的任意方法的执行： execution(* com.xyz.service.*.*(..)) 定义在service包和所有子包里的任意类的任意方法的执行： execution(* com.xyz.service..*.*(..)) 定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行： execution(* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))&#34;) &lt;!-- 将事务代码切入点addUser()方法中，从而产生事务 --&gt; &lt;aop:advisor advice-ref=&#34;txAdvice&#34; pointcut-ref=&#34;xxxx&#34;/&gt; &lt;/aop:config&gt; spring mybatis # 基础 #与$ #相当于解析成引号, 防止sql注入 $变量引用, 不能防止sql注入，用于传入表名之类 特点 sql易维护，传参方便 orm Mapper接口 方法名与配置id相同 输入输出参数类型对应定义的parameterType类型和resultType类型 类路径是配置的namespace 缓存 # 基于PerpetualCache的HashMap 一级缓存 存在本地 作用域为session, session flush后清空 二级缓存 可定义存储服务 作用域为namespace 配置 &lt;cache/&gt; readOnly=&#34;true&#34; 时，缓存实例单例，false时返回缓存拷贝 更新 create, update, delete后，作用域下所有select缓存clear 与hibernate区别 都通过SessionFactoryBuilder从配置生成SessionFactory, 再生成Session 都支持jdbc和jta mybatis可细致优化sql, hibernate移植性好 mybatis学习成本低 mybatis本身缓存不好，hibernate对象维护和缓存好 hibernate dao层封开发简单(不用维护映射)，crud方便 使用 编程 创建SqlSessionFactory 创建SqlSession 执行数据库操作 session.commit() session.close() 导入ibatis jar包 配置文件 SqlMap.properties # 属性名可以修改 driver=oracle.jdbc.driver.OracleDriver url=jdbc:oracle:thin:@127.0.0.1:1521:orcl username=root password=root SqlMapConfig.xml # 总配置文件 &lt;sqlMapConfig&gt; &lt;properties recource=&#34;SqlMap.properties&#34;/&gt; &lt;transactionManager type=&#34;JDBC&#34;&gt; &lt;dataSource type=&#34;SIMPLE&#34;&gt; &lt;property value=&#34;${driver}&#34; name=&#34;JDBC.Driver&#34;/&gt; &lt;property value=&#34;${url}&#34; name=&#34;JDBC.ConnectionURL&#34;/&gt; &lt;property value=&#34;${username}&#34; name=&#34;JDBC.Username&#34;/&gt; &lt;property value=&#34;${password}&#34; name=&#34;JDBC.Password&#34;/&gt; &lt;/dataSource&gt; &lt;sqlMap resource=&#34;Student.xml&#34;/&gt; &lt;/transactionManager&gt; &lt;/sqlMapConfig&gt; Student.xml # 映射xml文件 &lt;sqlMap&gt; &lt;typeAlias alias=&#34;Student&#34; type=&#34;com.Student&#34;/&gt; &lt;select id=&#34;selectAllStudent&#34; resultClass=&#34;Student&#34;&gt; select * from Student &lt;/select&gt; &lt;/typeAlias&gt; &lt;/sqlMap&gt; 辅助类Student.java # 要求有无参构造方法 private sid = 0; private String name = null; private String major = null; private Date birth = null; private float score = 0; Xxx.java private static SqlMapClient sqlMapClient = null; static{ Reader reader = Resources.getResourceAsReader(总配置文件); sqlMapClient = SqlMapClientBuilder.buildSqlMapClient(reader); reader.close(); } public List&lt;Student&gt; queryAllStudent(){ List&lt;Student&gt; studentList = sqlMapClient.queryForList(&#34;selectAllStudent&#34;); return studentList; } @Test public void testHere(){ for(Student student: this.queryAllStudent()){ System.out.println(student.getName); } } 配置 sqlMapConfig.xml mybatis加载属性顺序 properties中property中的属性 properties中resource或url中的属性 parameterType中传递一属性 # properties中配的属性会影响到mapper.xml中${}的sql拼接，因为都是ognl 配置标签 properties settings # ibatis有性能优化的参数，mybatis会自动调优，不用设置了 typeAliases # 针对parameterType和resultType指定的类型定义别名 # java.lang.Integer在mybatis中默认别名为int typeHandlers # 类型处理器，jdbc类型和java类型的转换 ## 一般mybatis提供的类型处理器够用了 objectFactory plugins environments mappers mapper.xml 内容 #{}接收简单类型, pojo的ognl属性注入 ${}是字符串的拼接 SELECT * FROM USER WHERE id=#{id} SELECT * FROM USER WHERE username LIKE &#39;%${value}%&#39; # sql 注入 输入输出映射 parameterType java类型 hashmap # #{key}来取value pojo 包装类型 resultType # 指定一条数据的类型，在java方法的返回类型中list或pojo来体现数据条数 # mybatis判断mapper代理中使用selectOne或者selectType pojo # 返回字段可以是别名，但要与pojo中的属性名相同 ## 如果有记录返回但没有pojo中匹配的属性名对应，则直接不创建该对象 java类型 # 在返回结果只有一行一列时，可以是简单类型 hashmap # key是字段的字，value是字段的值 ## 多条数据时，list里面存hashmap resultMap # 查询出来的字段名与pojo属性名不一致 定义resultMap 使用resultMap 动态sql &lt;where&gt; &lt;if&gt; sql片段&lt;sql&gt; &lt;foreach&gt; 高级映射 缓存 逆向 要求 1. mapper.xml中namespace 写mapper接口 &lt;mapper namespace=&#34;com.otr.tea.mapper.UserMapper&#34;&gt; 2. mapper.java中方法名与mapper.xml的statementid一致 3. mapper.java中方法的输入类型与mapper.xml中的parameterType一致 # 由于传入的参数只有一个，所以用包装类型的pojo来传多个参数，不利于业务层的可扩展性 4. mapper.java中方法的返回类型与mapper.xml中的resultType一致 机制 如果Mapper中返回类型为pojo, 则调用selectOne, 如果是List, 则调用selectList api sqlSessionFactory sqlSession # 是线程不安全的，因为它的类中有数据和属性 ＃ 是多例的，在方法中局部变量使用 Executor # 执行器操作数据库（基本执行器，缓存执行器） mapped statement # 封装sql语句、输入参数、输出结果类型 例子 InputStream is = Resources.getResourceAsStream(&#34;SqlMapConfig.xml&#34;); # Resources是mybatis提供的资源加载类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = factory.openSession(); User user = sqlSession.selectOne(&#34;test.findUserById&#34;, 1); ＃ selectList() # insert(&#34;test.insertUser&#34;, user) ## sqlSession.commit(); ## user.getId() 会主键返回 ### mysql中LAST_INSERT_ID()在insert语句后接着执行可以得到刚刚自成的id sqlSession.close(); 案例 返回id mysql &lt;insert id=&#34;insert&#34; parameterType=&#34;com.test.User&#34; keyProperty=&#34;userId&#34; useGeneratedKeys=&#34;true&#34; &gt; oracle &lt;insert id=&#34;insert&#34; parameterType=&#34;com.test.User&#34;&gt; &lt;selectKey resultType=&#34;INTEGER&#34; order=&#34;BEFORE&#34; keyProperty=&#34;userId&#34;&gt; SELECT SEQ_USER.NEXTVAL as userId from DUAL &lt;/selectKey&gt; insert into user (user_id, user_name, modified, state) values (#{userId,jdbcType=INTEGER}, #{userName,jdbcType=VARCHAR}, #{modified,jdbcType=TIMESTAMP}, #{state,jdbcType=INTEGER}) &lt;/insert&gt; spring struts2 # 原理 tomcat启动日志：没有整合时不能加载struts-plugin.xml（spring-struts-plugin.jar包中的配置文件 ） struts中struts-default中常量配置加载com.opensymphony.xword2.ObjectFactory类作为默认struts创建action的类 加载后struts-plugin.xml 中 修改了常量为struts-spring-plugin中的类来创建struts的类，也就是整个struts2创建action类的类被更改了 整合 jar包 struts2/lib/struts2-spring-plugin-2.3.1.1.jar # 为了在struts的xml配置文件中的class找spring 的容器 配置web.xml # \samples\petclinic\war\WEB-INF\web.xml目录下有示例 &lt;listener&gt; # 监听器，web程序启动时加载spring bean &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener &lt;context-param&gt; # （可选）配置spring 配置文件的路径， ## 从示例文件中查到，默认文件目录是/WEB-INF/applicationContext.xml(我们示例文件也是从源码/simple项目下的这个开头的文件中找的) &lt;param-name&gt;contextConfigLocation &lt;param-value&gt;/WEB-INF/classes/struts2/xxx.xml UserAction 中 # 不用值栈是因为通用性 spring.xml # action类由spring 产生 &lt;bean id=&#34;userActionID&#34; class=&#34;&#34; scope=&#34;prototype&#34;/&gt; struts2的配置文件中，替换class属性为spring beanid，其它一样 总结 spring的web配置是由下向上，一个个依赖注入的过程 comboPooledDataSourceID -&gt; localSessionFactoryBeanID -&gt; hibernateTemplateID -&gt; SysStaffDaoID -&gt; SysStaffServiceID -&gt; SysStaffActionID -&gt; struts.xml配置中的&lt;action class=&#34;SysStaffActionID&#34;&gt; 最后给Dao中的方法加入事务 spring mvc # 原理 DispatchServlet doService()捕获请求, doDispatch()用HandlerMapping映射url得到HandlerExcutionChain(执行链, 包括拦截器和handler) handler getHandlerAdapter得到适配器来处理handler, 返回ModelAndView # HandlerAdapter分三类: Servlet、Controller, HttpRequest DispatchServlet用ViewResolver(视图解析器)解析ModelAndView成View # ModelAndView是逻辑视图，DispatchServlet转化成视图View 返回View 与struts2区别 spring mvc方法对应请求, struts2是类 spring mvc请求是方法调用，struts2创建Action实例 spring mvc用aop处理请求，struts2用独有的拦截器(interceptor) spring mvc入口是servlet, struts2入口是filter spring mvc集成ajax(@ResponseBody), struts2需要插件 spring mvc验证支持JSR303, struts2不支持 spring mvc与spring无缝 spring mvc不需要配置 注解 @RequestMapping # url映射 @RequestBody # 转换参数到对象 @ResponseBody # 返回对象转json 开启注解处理器 springmvc.xml &lt;mvc:annotation-driven&gt; 乱码问题 post web.xml中配置CharacterEncodingFilter get tomcat配置文件修改项目编码 new String(Request.getParameter(&#34;a&#34;).getBytes(&#34;ISO8859-1&#34;), &#34;utf-8&#34;) quartz:定时器 # 执行：ApplicationContext类加载后自动执行 导包：quartz-all.jar包 与 commons-collections.jar包 与 commons-logging.jar xml配置： &lt;!-- 任务类 ,其中有个叫execute的方法--&gt; &lt;bean id=&#34;myTaskID&#34; class=&#34;jee.quartz.MyTask&#34;/&gt; &lt;!-- spring提供专用于定时任务类 --&gt; &lt;bean id=&#34;methodInvokingJobDetailFactoryBeanID&#34; class=&#34;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&#34;&gt; &lt;!-- 要定时执行的实例的spring bean id --&gt; &lt;property name=&#34;targetObject&#34;&gt; &lt;ref bean=&#34;myTaskID&#34;/&gt; &lt;/property&gt; &lt;!-- spring bean中定时执行的方法 --&gt; &lt;property name=&#34;targetMethod&#34;&gt; &lt;value&gt;execute&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- spring提供专用于任务频率类，给上面的任务指定频率 --&gt; &lt;bean id=&#34;cronTriggerBeanID&#34; class=&#34;org.springframework.scheduling.quartz.CronTriggerBean&#34;&gt; &lt;property name=&#34;jobDetail&#34;&gt; &lt;ref bean=&#34;methodInvokingJobDetailFactoryBeanID&#34;/&gt; &lt;/property&gt; &lt;property name=&#34;cronExpression&#34;&gt; &lt;value&gt;0 0/1 * * * ?&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- spring提供的专用于任务频率工厂类 --&gt; &lt;bean id=&#34;schedulerFactoryBeanID&#34; class=&#34;org.springframework.scheduling.quartz.SchedulerFactoryBean&#34;&gt; &lt;property name=&#34;triggers&#34;&gt; &lt;ref bean=&#34;cronTriggerBeanID&#34;/&gt; &lt;/property&gt; &lt;/bean&gt; 任务频率cronTriggerBean的配置： cron解析器: 反斜线（/）字符表示增量值。例如，在秒字段中“5/15”代表从第 5 秒开始，每 15 秒一次。 问号（?）字符和字母 L 字符只有在月内日期和周内日期字段中可用。问号表示这个字段不包含 具体值。 所以，如果指定月内日期，可以在周内日期字段中插入“?”，表示周内日期值无关紧要。字母 L 字符是 last 的缩写。放在月内日期字段中，表示安排在当月最后一天执行。在周内日期字 段中，如果“L”单独存在，就等于“7”，否则代表当月内周内日期的最后一个实例。所以“0L” 表示安排在当月的最后一个星期日执行。 在月内日期字段中的字母（W）字符把执行安排在最靠近指定值的工作日。把“1W”放在月内 日期字段中，表示把执行安排在当月的第一个工作日内。 井号（#）字符为给定月份指定具体的工作日实例。把“MON#2”放在周内日期字段中，表示把任 务安排在当月的第二个星期一。 星号（*）字符是通配字符，表示该字段可以接受任何可能的值。 顺序：秒 分 时 日 月 周 年（年可以忽略） 例子 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 12 ? * WED 表示每个星期三中午12点 0 0 12 * * ? 每天中午12点触发 0 15 10 ? * * 每天上午10:15触发 0 15 10 * * ? 每天上午10:15触发 0 15 10 * * ? * 每天上午10:15触发 0 15 10 * * ? 2013 2013年的每天上午10:15触发 0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 15 10 15 * ? 每月15日上午10:15触发 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 ? * 6L 2014-2018 2014年至2018年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 0/1 * * * * ? 每秒钟触发一次 0 0/1 * * * ? 每分钟解发一次 0 0 0/1 * * ? 每小时解发一次 远程调用 # # rmi:remote message invoke 服务端 1.自定义接口IServer,自定义抽象方法int rax(int) 2.写接口实现类ServerImpl 3.配置spring.xml 文件 &lt;!-- 服务端实现类 --&gt; &lt;bean id=&#34;serverImplID&#34; class=&#34;jee.server.ServerImpl&#34;/&gt; &lt;!-- spring提供的专用于RMI服务端注册器 --&gt; &lt;bean id=&#34;rmiServiceExporterID&#34; class=&#34;org.springframework.remoting.rmi.RmiServiceExporter&#34;&gt; &lt;property name=&#34;serviceInterface&#34;&gt; &lt;value&gt;jee.server.IServer&lt;/value&gt; &lt;/property&gt; &lt;property name=&#34;service&#34;&gt; &lt;ref bean=&#34;serverImplID&#34;/&gt; &lt;/property&gt; &lt;property name=&#34;serviceName&#34;&gt; &lt;value&gt;XXXX&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 客户端 配置spring.xml 文件 &lt;!-- spring提供专用于RMI远程服务代理工厂类 --&gt; &lt;bean id=&#34;rmiProxyFactoryBeanID&#34; class=&#34;org.springframework.remoting.rmi.RmiProxyFactoryBean&#34;&gt; &lt;!-- 协议名://远程提供服务的IP地址:提供服务的端口/提供服务的名称 --&gt; &lt;property name=&#34;serviceUrl&#34;&gt; &lt;value&gt;rmi://127.0.0.1:1099/XXXX&lt;/value&gt; &lt;/property&gt; &lt;property name=&#34;serviceInterface&#34;&gt; &lt;value&gt;jee.client.IServer&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 执行： 服务端加载 ApplicationContext类 客户端 加载 ApplicationContext类 ac ac.getBean方法中得到RmiProxyFactoryBean实际类型（可变类型）的实例，强转成服务端自定义的接口IServer的实现类（实现类由服务器决定） 执行IServer实现类中的方法int rax(int)，实现了远程调用 websocket # handler extends TextWebSocketHandler @Override handleTextMessge() # 处理client.send()的数据 @Override afterConnectionEstablished(WebSocketSession) # 连接事件 @Override handleTransportError() # 出错事件 @Override afterConnectionClosed() # 断开事件 @Override supportsPartialMessages() # 并行处理 config @EnableWebSocket implements WebSocketConfigurer @Override registerWebSocketHandlers() registry.addHandler(handler, &#34;/ws&#34;) # 路由handler client extends WebSocketClient constructor(uri) super(new URI(uri)) @Override onOpen() @Override onClose() @Override onError() @Override onMessage() service init() client = new Client(&#34;ws://127.0.0.1:8001/ws&#34;) client.connectBlocking() send() while(!client.getReadyState().equals(ReadyState.OPEN)){ log(&#34;connecting&#34;) } client.send(&#34;&#34;) runner implements ApplicationRunner run() service.init() spring boot # 介绍 减少配置, 习惯大于配置 支持groovy, gradle 命令 java -jar xxx.jar --server.port=8080 # --后内容，相当于application.yml设置 --spring.profiles.active=two # 选择applicaton-two.yml配置 基础文件 # 目录 src main java com.outrun XxxApplication resources static/ templates/ application.properties application.yml webapp WEB-INF test java com.outrun XxxApplicationTests pom.xml XxxApplication.java # 程序入口 @SpringBootApplication # 类，组合@Configuration, @EnableAutoConfiguration, @ComponentScan @EnableAutoConfiguration根据jar包依赖自动配置 扫描该注解同级下级包的Bean application.yml # application.yml或application.properties, 放在src/main/resources或config目录下 pom.xml 配置 # 区分环境 application-{profile}.properties # profile比如是dev, test, prod 设置spring.profiles.active=dev来区分 加载顺序 # 为了外部人员维护，可覆盖定义 命令行 SPRING_APPLICATION_JSON环境变量, json格式 java:comp/env的JNDI属性 java系统属性 # System.getProperties()查看 系统环境变量 random.*配置的随机属性 jar包外文件名, 如application-{profile}.properties jar包内文件名 @Configuration注解类中，@PropertySource修改的属性 SpringApplication.setDefaultProperties定义的内容 application.yml --- # ---分隔多个配置，这里相当于建立了application-two.yml文件 spring: profiles: two --- spring: profiles active: dev # 配置环境, 加载applicaton-dev.yml application: name: app1 pom.xml &lt;packaging&gt;jar&lt;/packaging&gt; # 不用war包部署, 嵌入了tomcat, jar可服务 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; # 提供spring boot基础依赖和默认配置 &lt;relativePath/&gt; # 从仓库查找parent &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; # 方便启动停止应用, 如mvn spring-boot:run &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 注解 # @SpringBootApplication # spring boot 启动类 组合了@Configuration, @EnableAutoConfiguration, @ComponentScan 类 # ApplicationRunner # 继承该类，注解@Component, 随容器启动运行 run() 插件 # maven # 命令 mvn spring-boot:run pom.xml &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; # 方便启动停止应用, 如mvn spring-boot:run &lt;/plugin&gt; 组件 # starter POMs # spring-boot-starter开头的组件 子域 # NamedContextFactory # class Spec1 implements NamedContextFactory.Specification { @Override public String getName(){} @Override public Class&lt;?&gt;[] getConfiguration(){} } public class MyFactory extends NamedContextFactory&lt;Specification1&gt; { public MyFactory(Class&lt;?&gt; clazz) { super(clazz, &#34;my&#34;, &#34;my.name&#34;) } } @Configuration public class Config0 { @Bean Bean0 getBean(){ return new Bean0() } } parent = new AnnotationConfigApplicationContext() parent.register(Config0.class) parent.refresh() factory = new MyFactory(Config00.class) factory.setApplicationContext(parent) spec1 = new Spec1(&#34;1&#34;, new Class[]{Config1.class}) factory.setConfigurations(List.of(spec1)) factory.getInstance(&#34;1&#34;, Bean0.class) // 子域共享 factory.getInstance(&#34;1&#34;, Bean00.class) // 子域复制 factory.getInstance(&#34;1&#34;, Bean1.class) spring # 配置 随机数用${random} ${random.value} 字符串 ${random.int} int ${random.long} long ${random.int(10)} 10以内int ${random.int[10,20]} 10到20 int pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; application.yml aa bb: 1 # 可用properties类管理属性 xxx: 1 # 自定义value 配置文件中用&#34;${xxx}&#34;引用 类中用@Value(&#34;${xxx}&#34;)注入到属性 SpEL中用&#34;#{xxx}&#34;引用 AaProperties.java @Component @ConfigurationProperties(prefix = &#34;aa&#34;) public class AaProperties { private String bb; ...getter和setter... } 注解 @Configuration @PropertySource(value = &#34;classpath:test.properties&#34;) # 加载文件, 配合@ConfigurationProperties注入属性 @EnableConfigurationProperties({ConfigBean.class, User.class}) # 加载bean, 配合@Autowired注入 基础 注解 @Value(&#34;${xxx}&#34;) @Autowired # 装载bean @Bean # 实例化Bean, 属性名为方法名 @Bean public RestTemplate restTemplate() { return new RestTemplate(); } 相当于 RestTemplate restTemplate = new RestTemplate(); @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) # 生命周期 singleton # 单例 prototype # 多例 request # web程序ContextApplication用, 随请求创建 session # web程序ContextApplication用, 随session创建 global session # porlet的global用, 其它用降级为session @EventListener(XxxEvent.class) # 修饰方法, 外部publishEvent()时触发 实体 注解 @Entity # 修饰bean类 @Id # id属性 @GeneratedValue(strategy=GenerationType.AUTO) # 自增属性 @Column(nullable = false, unique = true) 组件 注解 @Component @ConfigurationProperties(prefix = &#34;my&#34;) # 注入properties对应名称的属性 dao 注解 @Repository # 修饰类 service 注解 @Service # 修饰类 @PostConstruct # 修饰方法, 加载servlet时, init()前执行 @PreDestroy # 修饰方法, 销毁servlet时, destroy()后执行 controller 注解 @Controller # 修饰类 测试 # pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 注解 @Before @Test @RunWith(SpringRunner.class) # 修饰类, 测试spring @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) # 修饰类, 测试spring boot @LocalServerPort # 注入端口号 @AutoConfigureMockMvc # 使用mockMvc, 用@Autowired注入MockMvc @WebAppConfiguration # 模拟ServletContext XxxApplicationTests.java # junit测试 @RunWith(SpringJUnit4ClassRunner.class) @SpringApplicationConfiguration(classes = XxxApplication.class) @WebAppConfiguration public class XxxApplicationTests { private MockMvc mvc; @Before public void setUp() throws Exception { mvc = MockMvcBuilders.standaloneSetup(new XxxController()).build(); } @Test public void hello() throws Exception { mvc.perform(MockMvcRequestBuilders.get(&#34;/hello&#34;).accept(MediaType.APPLICATION_JSON)) .addExpect(status().isOk()) .addExpect(content().string(equalTo(&#34;hello&#34;))); } } 数据库 # pom.xml spring-boot-starter-jdbc spring-boot-starter-data-jpa # spring data JPA application.yml jpa: generate-ddl: false show-sql: true hibernate: ddl-auto: none # create时, 第一次create之后update datasource: platform: h2 schema: classpath:schema.sql # 建表 data: classpath:data.sql # 数据 注解 @Transactional # 修饰方法，开启事务，或在事务中 mybatis # pom.xml &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt; &lt;/dependency&gt; application.yml spring: datasource: url: jdbc:mysql://127.0.0.1:3306/outrun?characterEncoding=UTF-8 username: root password: asdf driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update # 新建连接必要 mybatis: mapper-locations: classpath:mapper/*.xml # 指定mapper.xml位置 mapper.xml # 用mbg生成 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;!DOCTYPE mapper PUBLIC &#34;-//mybatis.org//DTD Mapper 3.0//EN&#34; &#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;&gt; &lt;mapper namespace=&#34;com.outrun.erp.mapper.UserMapper&#34;&gt; &lt;resultMap id=&#34;BaseResultMap&#34; type=&#34;com.outrun.erp.entities.User&#34;&gt; &lt;id column=&#34;id&#34; jdbcType=&#34;BIGINT&#34; property=&#34;id&#34; /&gt; &lt;result column=&#34;name&#34; jdbcType=&#34;VARCHAR&#34; property=&#34;name&#34; /&gt; &lt;/resultMap&gt; &lt;select id=&#34;selectUserById&#34; parameterType=&#34;long&#34; resultMap=&#34;UserMap&#34;&gt; SELECT name FROM user WHERE id=#{userId} &lt;/select&gt; &lt;insert id=&#34;inserUser&#34;&gt; &lt;selectKey keyProperty=&#34;id&#34; resultType=&#34;int&#34; order=&#34;BEFORE&#34;&gt; select field1 from seq1 &lt;/selectKey&gt; &lt;/insert&gt; &lt;sql id=&#34;userColumns&#34;&gt; ${alias}.id, ${alias}.username &lt;/sql&gt; &lt;select id=&#34;selectColumns&#34; resultType=&#34;map&#34;&gt; select &lt;include refid=&#34;userColumns&#34;&gt;&lt;property name=&#34;alias&#34; value=&#34;tb1&#34;/&gt;&lt;/include&gt; from tb1 &lt;/select&gt; &lt;select id=&#34;dynamicSql&#34; resultType=&#34;User&#34;&gt; select * from user where state = 0 &lt;if test=&#34;title != null&#34;&gt; and title like #{title} &lt;/if&gt; &lt;choose&gt; &lt;when test=&#34;title != null&#34;&gt; and title like #{title} &lt;/when&gt; &lt;when test=&#34;author != null and author.name != null&#34;&gt; and author_name like ${author.name} &lt;/when&gt; &lt;otherwise&gt; and featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;foreach item=&#34;item&#34; index=&#34;index&#34; collection=&#34;list&#34; open=&#34;(&#34; separator=&#34;,&#34; close=&#34;)&#34;&gt; #{item} &lt;/foreach&gt; &lt;trim prefix=&#34;where&#34; prefixOverrides=&#34;and | or&#34;&gt; ... &lt;/trim&gt; &lt;bind name=&#34;a&#34; value=&#34;&#39;%&#39; &#43; _data.getTitle() &#43; &#39;%&#39;&#34; /&gt; select * from blog where title like #{a} &lt;/select&gt; &lt;update&gt; update User &lt;set&gt; &lt;if test=&#34;username != null&#34;&gt;username=#{username},&lt;/if&gt; &lt;/set&gt; &lt;/update&gt; &lt;cache&gt; # 该命名空间缓存 &lt;cache-ref&gt; # 引用其它命名空间缓存 &lt;delete&gt; &lt;resultMap&gt; &lt;constructor&gt; # 构造方法 &lt;idArg&gt; # id参数, 标记id帮助提高性能 &lt;arg&gt; # 普通参数 &lt;/constructor&gt; &lt;id&gt; # 标记id帮助提高性能 &lt;result&gt; # 普通字段 &lt;association&gt; # 关联 &lt;collection&gt; # 结构体 &lt;discriminator&gt; # 自动映射 &lt;/resultMap&gt; &lt;/mapper&gt; mapper/UserMapper @Mapper # 如果扫描mapper.xml，不用加@Mapper public interface UserMapper { List&lt;User&gt; selectUserById(@Param(&#34;userId&#34;) long userId) @Select(&#34;select * from user&#34;) List&lt;User&gt; findAll(); } entities/User public class User { private Integer id; private String name; ...getter, setter... } 注解 @Table(name = &#34;user&#34;) # 修饰类，指定表 @Id # 修饰属性, 指定主键 @Column(name = &#34;name&#34;) # 修饰属性, 指定字段 @Mapper # 修饰类 @Select(&#34;select * from user&#34;) # 修饰方法 @Param(&#34;userId&#34;) # 修饰参数 api SqlSessionFactory build openSession # 重载事务方法 SqlSesion selectOne() selectList() selectMap() insert() update() delete() commit() rollback() clearCache() close() Mapper o-&gt; @Insert(&#34;insert into tb1(id, name) values(#{id}, #{name})&#34;) @SelectKey(statement=&#34;next value&#34;, keyProperty=&#34;id&#34;, before=true, resultType=int.class) int insertTable1(String name) SQL INSERT_INTO() VALUES() o-&gt; new SQL(){{ SELECT(&#34;a.name&#34;); SELECT(&#34;a.age&#34;); FROM(&#34;tb1 a&#34;); WHERE(&#34;a.name like ?&#34;); }}.toString() LogFactory useSlf4jLogging() useLog4jLogging() useStdOutLogging() web # # 用的spring mvc pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; # web模块, 有tomcat, spring mvc &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; # 测试模块, 有JUnit, Hamcrest, Mockito &lt;/dependency&gt; application.yml server port: 8080 # 默认8080 servlet context-path: /hello # uri前缀 静态资源 默认映射public, resources, static到/ 注解 控制器 @RestController # 修饰类, 组合@Controller与@responseBody @RequestMapping(&#34;/index&#34;) # 修改类或方法, url @GetMapping(&#34;/{id}&#34;) # 相当于@RequestMapping(method=RequestMethod.GET) @PostMapping @PutMapping @DeleteMapping @PatchMapping @CrossOrigin # 修饰方法, 允许跨域 @RequestBody # 修饰方法, 解析body到参数 @PathVariable Long id # 修饰参数, 接收url参数 内置对象 ServerProperties # 单例可@Autowired, 存端口之类属性 自实现 XxxController.java @RestController public class HelloController { @RequestMapping(&#34;/hello&#34;) public String index() { return &#34;hello&#34;; } } 日志 # application.yml logging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACE 注解 @Slf4j # 修饰类，其中可直接用log变量 @EnableSwagger2 # 修饰类 @Api(tags = &#34;&#34;) # 修饰类, 文档 @ApiModel(&#34;&#34;) # 修饰类 @ApiModelProperty(&#34;) # 修饰属性 @ApiOperation(value=&#34;&#34;, notes=&#34;&#34;) # 修改方法, 文档 @ApiIgnore # 修饰方法, 文档忽略 jackson # 注解 @JsonInclude # 修饰类, 序列化时包含 @JsonInclude(JsonInclude.Include.NON_EMPTY) # null或&#34;&#34;时不序列化 @JsonIgnore # 修饰属性 Scheduled # scheduled 注解 @Scheduled # 修饰方法, 定时调度 @Scheduled(initialDelay = 1000, fixedRate = 1000) 类 @Configuration implements SchedulingConfigurer # 配置类 configureTasks(ScheduledTaskRegistrar) registrar.setScheduler(Executors.newScheduledThreadPool(2)); # worker池 async 注解 @Async # 修饰方法, 异步调用 类 implements AsyncUncaughtExceptionHandler # 处理@Async异常 @Override public void handleUncaughtException() @Configuration @EnableAsync implements AsyncConfigurer @Bean @Override public Executor getAsyncExecutor() @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() # 处理无返回值＠Async方法异常 return handler 使用 @Async Future&lt;String&gt; fetch(){ return new AsyncResult&lt;String&gt;(&#34;&#34;) } future = fetch() try{ future.get() } 热部署 # pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; # 热部署 &lt;/dependency&gt; application.yml spring: devtools: restart: enabled: true additional-paths: src/main/java jsp # pom.xml &lt;!-- servlet依赖. --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- tomcat的支持.--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; application.yml spring: mvc: view: prefix: /WEB-INF/views/ suffix: .jsp controller类 @Controller public class XxxController { @RequestMapping(&#34;/xxx&#34;) public String xxx(Model m) { m.addAttribute(&#34;a&#34;, 1); return &#34;view1&#34;; } } src/main/webapp/WEB-INF/views/view1.jsp &lt;%@ page language=&#34;java&#34; contentType=&#34;text/html; charset=utf-8&#34; pageEncoding=&#34;utf-8&#34;%&gt; jsp ${a} lombok # 注解 @Builder # 修饰类, 可build方式设置属性 @Getter # 修饰类, 生成getter @Setter # 修饰类, 生成setter @ToString # 修饰类, 生成toString方法 @Data # 修饰类, 注入getter, setter, toString @NoArgsConstructor # 修饰类, 生成无参构造方法 @AllArgsContructor # 修饰类, 生成带所有参数的构造方法 @RequiredArgsConstructor # 修饰类, 生成带常量、@NotNull修饰变量参数的构造方法 @RequiredArgsConstructor(onConstructor_ = @Autowired) # 构造类时，自动对private final 属性@Autowire remote shell # pom.xml spring-boot-starter-remote-shell actuator # pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 原生端点 应用配置类 /autoconfig # 自动化配置详情 positiveMatches	# 成功 negativeMatches /beans # 所有bean /configprops # 属性 /env # 环境属性 /mappings # spring mvc映射关系 /info # 自定义信息，默认为空，用info前缀定义 度量指标 /metrics # 程序信息，内存、线程、gc等 nonheap.* # 非堆内存 gauge.* # http请求性能，如gauge.response表示上次延迟 counter.* # 记录累计，如counter.status.200表示返回200的次数 /metrics/{name} # 查看某项 /metrics/mem.free /health # 启动状态，磁盘空间 DiskSpaceHealthIndicator # 低磁盘空间 DataSourceHealthIndicator # DataSource连接是否可用 MongoHealthIndicator RabbitHealthIndicator RedisHealthIndicator SolrHealthIndicator /dump # 线程信息 /trace # 跟踪信息 操作控制 # 用属性配置开启 /shutdown # 关闭端点 通过endpoints.shutdown.enabled=true开启 自定义counter统计 @Autowired private CounterService counterService; counterService.increment(&#34;didispace.hello.count&#34;) 自定义health检测器 @Component public class RocketMQHealthIndicator implements HealthIndicator { private int check(){} @Override public Health health() { int errorCode = check(); if (errorCode !=0) { return Health.down().withDetail(&#34;Error Code&#34;, errorCode).build(); return Health.up().build(); } } } spring boot admin # application.yml spring: application: name: erp-admin-server boot: admin: routes: endpoints: env,metrics,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream endpoints: health: sensitive: false enabled: true actuator: enabled: true sensitive: false beans: sensitive: false enabled: true spring initializer # 介绍 生成spring基础项目 spring security # 配置 application.yml security: basic: enabled: false # 禁用security 注解 @EnableWebSecurity # 修饰WebSecurityConfigurerAdapter, 开启web验证 @EnableGlobalMethodSecurity(prePostEnabled = true) # 修饰WebSecurityConfigurerAdapter, 开启方法验证 @PreAuthorize # 修饰controller方法 api Subject # 主体数据结构, 如用户 SecurityManager # 安全管理器, 管理所有subject UserDetails getAuthorities() getUsername() getPassword() isAccountNonExpired() isAccountNonLocked() isCredentialsNonExpired() isEnabled() GrantedAuthority getAuthority() WebSecurityConfigurerAdapter configure(HttpSecurity) # 验证请求 configure(AuthenticationManagerBuilder) # 验证数据，需要授权服务配置AuthenticationManager userDetailService passwordEncoder authenticationManagerBean() # 指定管理bean spring security oauth2 # pom.xml spring-cloud-starter-oauth2 结构 OAuth2 Provider Authorization Service # 授权服务 Resource Service # 资源服务 Spring Security过滤器 /oauth/authorize # 授权 /oauth/token # 获取token 授权服务 applicatoin.yml # server security: oauth2: resource: filter-order: 3 注解 @EnableAuthorizationServer # 修饰AuthorizationServerConfigurerAdapter, 开启授权服务 api AuthorizationServerConfigurerAdapter # 授权服务配置 configure(ClientDetailsServiceConfigurer) # 客户端信息 clientId secret scope authorizedGrantTypes # password, refresh_token, client_credentials authorities # 具体权限 configure(AuthorizationServerEndpointsConfigurer) # 使用token的服务 authenticationManager # 密码认证 authenticate(Authentication) userDetailService # 获取用户数据 loadUserByUsername(String) authorizationCodeServices # 验证码 implicitGrantService tokenGranter tokenStore InMemoryTokenStore JdbcTokenStore JwtTokenStore configure(AuthorizationServerSecurityConfigurer) # 使用token服务的安全策略, 授权服务与资源服务分离时配置 接口 Principal /users/current 测试 insert into user(username, password) values(&#39;outrun&#39;, &#39;$2a$10$l7.7AJEHtXukwUZiKAyVSO6lHJOyHhPxHvi7MHawe8SjlOKkCVbAe&#39;) curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf 浏览器 url: localhost:9016/uaa/oauth/token header &#39;Authorization&#39;: &#39;Basic &#39; &#43; base64(&#39;erp-auth-resource:asdf&#39;) data username: &#39;outrun&#39; password: &#39;123456&#39; grant_type: &#39;password&#39; 资源服务 application.yml # client security: oauth2: resource: user-info-uri: http://localhost:9016/uaa/users/current client: clientId: erp-auth-resource clientSecret: asdf accessTokenUri: http://localhost:9016/uaa/oauth/token grant-type: client_credentials,password scope: server 注解 @EnableResourceServer # 修饰ResourceServerConfigurerAdapter, 开启资源服务 # 修饰AuthorizationServerConfigurerAdapter, 因为授权服务提供token获取和验证接口 @PreAuthorize(&#34;hasAuthority(&#39;ROLE_ADMIN&#39;)) # 修饰controller方法，验证权限 api ResourceServerConfigurerAdapter # 资源服务配置 configure(HttpSecurity) authorizeRequests # 请求放行 测试 curl -d &#34;username=outrun&amp;password=asdf&#34; &#34;localhost:9017/user/registry&#34; insert into role values(1, &#39;ROLE_USER&#39;), (2, &#39;ROLE_ADMIN&#39;) insert into &#39;user_role&#39; values(user_id, 2) curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf curl -l -H &#34;Authorization:Bearer 7df6669c-0c86-417b-827f-9a58297f57e5&#34; -X GET &#34;localhost:9017/hello&#34; 客户端 注解 @EnableOAuth2Client # 修饰[Oauth2ClientConfig], 客户端 api [Oauth2ClientConfig] # 客户端配置, 自定义类，名称任意 ClientCredentialsResourceDetails # bean, 资源信息 RequestInterceptor # bean, 保存请求上下文 OAuth2RestTemplate # bean, 用于向授权服务发送请求 表 clientdetails oauth_access_token oauth_approvals oauth_client_details oauth_client_token oauth_code oauth_refresh_token spring integration # # 服务编排">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:modified_time" content="2021-09-22T21:45:53+08:00">
<title>Spring | outrun的笔记</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css" integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.dc9a8161e6c374f95d1e4ce6b94723a050d02b08398745f1301dbdde08c5b9f0.js" integrity="sha256-3JqBYebDdPldHkzmuUcjoFDQKwg5h0XxMB293gjFufA=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>outrun的笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/architect"><strong>架构</strong></a>
<ul>
<li><a href="/docs/architect/method"><strong><strong>规划与方法</strong></strong></a>
<ul>
<li><a href="/docs/architect/method/product_plan">产品规划</a></li>
<li><a href="/docs/architect/method/advice_plan">咨询规划</a></li>
<li><a href="/docs/architect/method/test_plan">测试规划</a></li>
<li><a href="/docs/architect/method/architect">服务治理</a></li>
<li><a href="/docs/architect/method/ops_plan">运维规划</a></li>
<li><a href="/docs/architect/method/project_plan">项目规划</a></li>
<li><a href="/docs/architect/method/code_plan">代码规划</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy"><strong><strong>战略技术方案</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/middle_platform"><strong><strong>中台</strong></strong></a></li>
<li><a href="/docs/architect/strategy/datalake"><strong><strong>湖仓一体</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/big_data/ecology">生态体系</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy/ai"><strong><strong>人工智能</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/ai/deep">深度学习</a></li>
<li><a href="/docs/architect/strategy/ai/map">知识图谱</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy/iot"><strong><strong>物联网</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/iot/framework">框架</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy/block_chain"><strong><strong>区块链</strong></strong></a></li>
<li><a href="/docs/architect/strategy/meta"><strong><strong>元宇宙Web3.0</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/meta/media">媒体</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy/cloud"><strong><strong>云原生</strong></strong></a></li>
<li><a href="/docs/architect/strategy/edge"><strong><strong>边缘计算</strong></strong></a></li>
</ul>
</li>
<li><a href="/docs/architect/project"><strong><strong>工程设计原则</strong></strong></a>
<ul>
<li><a href="/docs/architect/project/ddd">DDD</a></li>
<li><a href="/docs/architect/project/frontend">前端设计</a></li>
</ul>
</li>
<li><a href="/docs/architect/code"><strong><strong>代码原则</strong></strong></a>
<ul>
<li><a href="/docs/architect/code/design_mode">设计模式</a></li>
<li><a href="/docs/architect/code/security">安全/协议</a></li>
</ul>
</li>
<li><a href="/docs/architect/manage"><strong><strong>管理</strong></strong></a>
<ul>
<li><a href="/docs/architect/manage/organize"><strong><strong>组织</strong></strong></a>
<ul>
<li><a href="/docs/architect/manage/organize/people">人员</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/architect/summary">这些年我做过的技术</a></li>
</ul>
</li>
<li><a href="/docs/tool"><strong>工具</strong></a>
<ul>
<li><a href="/docs/tool/linux"><strong><strong>Linux系统</strong></strong></a>
<ul>
<li><a href="/docs/tool/linux/linux_tool">Linux工具</a></li>
<li><a href="/docs/tool/linux/scene">Linux场景</a></li>
<li><a href="/docs/tool/linux/linux_program">Linux系统编程</a></li>
</ul>
</li>
<li><a href="/docs/tool/ops"><strong><strong>运维工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/ops/monitor">监控指标</a></li>
<li><a href="/docs/tool/ops/docker">Docker</a></li>
<li><a href="/docs/tool/ops/k8s">Kubernetes</a></li>
</ul>
</li>
<li><a href="/docs/tool/develop"><strong><strong>开发工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/develop/vim">Vim</a></li>
<li><a href="/docs/tool/develop/eclipse">Eclipse</a></li>
<li><a href="/docs/tool/develop/apple">Apple</a></li>
<li><a href="/docs/tool/develop/jetbrains">Jetbrains</a></li>
</ul>
</li>
<li><a href="/docs/tool/test"><strong><strong>测试工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/test/debug">代码调试</a></li>
</ul>
</li>
<li><a href="/docs/tool/product"><strong><strong>产品工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/product/enterprise_system">企业级系统</a></li>
<li><a href="/docs/tool/product/framework">服务与框架</a></li>
</ul>
</li>
<li><a href="/docs/tool/physics"><strong><strong>实物工具</strong></strong></a></li>
</ul>
</li>
<li><a href="/docs/middleware"><strong>中间件</strong></a>
<ul>
<li><a href="/docs/middleware/container"><strong><strong>容器</strong></strong></a>
<ul>
<li><a href="/docs/middleware/container/nginx">Nginx</a></li>
<li><a href="/docs/middleware/container/nodejs">Node.js</a></li>
</ul>
</li>
<li><a href="/docs/middleware/distributed"><strong><strong>分布式</strong></strong></a>
<ul>
<li><a href="/docs/middleware/distributed/spring_cloud">Spring Cloud</a></li>
</ul>
</li>
<li><a href="/docs/middleware/library"><strong><strong>库</strong></strong></a>
<ul>
<li><a href="/docs/middleware/library/hibernate">Hibernate</a></li>
</ul>
</li>
<li><a href="/docs/middleware/library_frontend"><strong><strong>前端库</strong></strong></a>
<ul>
<li><a href="/docs/middleware/library_frontend/jquery">JQuery</a></li>
<li><a href="/docs/middleware/library_frontend/bootstrap">Bootstrap</a></li>
<li><a href="/docs/middleware/library_frontend/angular">Angular</a></li>
<li><a href="/docs/middleware/library_frontend/react">React</a></li>
<li><a href="/docs/middleware/library_frontend/threejs">Three.js</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/db"><strong>数据库</strong></a>
<ul>
<li><a href="/docs/db/mongodb">MongoDB</a></li>
<li><a href="/docs/db/mysql">Mysql</a></li>
<li><a href="/docs/db/oracle">Oracle</a></li>
<li><a href="/docs/db/postgresql">PgSQL</a></li>
<li><a href="/docs/db/redis">Redis</a></li>
<li><a href="/docs/db/elasticsearch">Elasticsearch</a></li>
</ul>
</li>
<li><a href="/docs/pl"><strong>语言</strong></a>
<ul>
<li><a href="/docs/pl/principle">原理</a></li>
<li><a href="/docs/pl/java"><strong><strong>Java</strong></strong></a>
<ul>
<li><a href="/docs/pl/java/jvm">JVM</a></li>
<li><a href="/docs/pl/java/collection">Java Collection</a></li>
<li><a href="/docs/pl/java/juc">Java Concurrent</a></li>
<li><a href="/docs/pl/java/spring">Spring</a></li>
<li><a href="/docs/pl/java/rxjava">RxJava</a></li>
<li><a href="/docs/pl/java/javaweb">JavaWeb</a></li>
</ul>
</li>
<li><a href="/docs/pl/go">GO</a></li>
<li><a href="/docs/pl/js">JS</a></li>
<li><a href="/docs/pl/python">Python</a></li>
<li><a href="/docs/pl/haskell">Haskell</a></li>
<li><a href="/docs/pl/clojure">Clojure</a></li>
<li><a href="/docs/pl/markup_language"><strong><strong>标记语言</strong></strong></a>
<ul>
<li><a href="/docs/pl/markup_language/html">HTML</a></li>
<li><a href="/docs/pl/markup_language/css">CSS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/basic"><strong>基本功</strong></a>
<ul>
<li><a href="/docs/basic/algorithm"><strong><strong>算法</strong></strong></a>
<ul>
<li><a href="/docs/basic/algorithm/math">数学</a></li>
<li><a href="/docs/basic/algorithm/thought">思想</a></li>
<li><a href="/docs/basic/algorithm/data_structure">数据结构</a></li>
</ul>
</li>
<li><a href="/docs/basic/computer"><strong><strong>计算机</strong></strong></a>
<ul>
<li><a href="/docs/basic/computer/principle">原理</a></li>
<li><a href="/docs/basic/computer/performance">性能</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/cache"><strong>Cache</strong></a>
<ul>
<li><a href="/docs/cache/ops">运维</a></li>
<li><a href="/docs/cache/template">模板配置</a></li>
<li><a href="/docs/cache/soft_arch">软考</a></li>
</ul>
</li>
<li><a href="/docs/misc"><strong>Misc</strong></a></li>
<li><a href="/posts"><strong>Posts</strong></a></li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Spring</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a></li>
    <li><a href="#使用">使用</a></li>
    <li><a href="#api">api</a></li>
    <li><a href="#注解">注解</a></li>
    <li><a href="#模块">模块</a>
      <ul>
        <li><a href="#监听器">监听器</a></li>
        <li><a href="#properties">properties</a></li>
        <li><a href="#bean">bean</a></li>
        <li><a href="#aop">aop</a></li>
        <li><a href="#dao">dao</a></li>
        <li><a href="#事务">事务</a></li>
        <li><a href="#spring-mybatis">spring mybatis</a></li>
        <li><a href="#spring-struts2">spring struts2</a></li>
        <li><a href="#spring-mvc">spring mvc</a></li>
        <li><a href="#quartz定时器">quartz:定时器</a></li>
        <li><a href="#远程调用">远程调用</a></li>
        <li><a href="#websocket">websocket</a></li>
      </ul>
    </li>
    <li><a href="#spring-boot">spring boot</a>
      <ul>
        <li><a href="#基础文件">基础文件</a></li>
        <li><a href="#配置">配置</a></li>
        <li><a href="#注解-1">注解</a></li>
        <li><a href="#类">类</a></li>
        <li><a href="#插件">插件</a>
          <ul>
            <li><a href="#maven">maven</a></li>
          </ul>
        </li>
        <li><a href="#组件">组件</a></li>
        <li><a href="#子域">子域</a>
          <ul>
            <li><a href="#namedcontextfactory">NamedContextFactory</a></li>
            <li><a href="#spring">spring</a></li>
            <li><a href="#测试">测试</a></li>
            <li><a href="#数据库">数据库</a></li>
            <li><a href="#web">web</a></li>
            <li><a href="#日志">日志</a></li>
            <li><a href="#jackson">jackson</a></li>
            <li><a href="#scheduled">Scheduled</a></li>
            <li><a href="#热部署">热部署</a></li>
            <li><a href="#jsp">jsp</a></li>
            <li><a href="#lombok">lombok</a></li>
            <li><a href="#remote-shell">remote shell</a></li>
            <li><a href="#actuator">actuator</a></li>
            <li><a href="#spring-boot-admin">spring boot admin</a></li>
            <li><a href="#spring-initializer">spring initializer</a></li>
            <li><a href="#spring-security">spring security</a></li>
            <li><a href="#spring-security-oauth2">spring security oauth2</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#spring-integration">spring integration</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>特点
    容器, 也容纳管理了第三方框架         # 目的是解耦框架api
    轻量级，模块化，无(少)侵入
IOC(inversion of control)
    容器用工厂装配对象并管理, 面向接口编程
    优点
        降低代码量
        容易测试
        最小侵入性松耦合
    方式
        Setter
        构造器
        静态工厂、实例工厂
DI(dependency injection)
    容器向类添加属性        # 反射，用带参构造或set方法
AOP(aspect oriented programming)
    # 继承是纵向组织，AOP横切入业务
    # oop是静态概念，aop是动态概念（aop的切面可以替换或不使用）
    动态代理实现切入代码
        权限控制
        事务管理
        记录日志
    概念
        连接点:普通方法
        切入点:名称满足条件的连接点
        增强（通知）类:服务对象
            # 切入点与增强是多对多的
        切面:切入点 + 增强类                        # 我们切入的是横切面
        目标对象（服务对象）：要注入的对象
    通知
        before              # 执行前
        after               # 执行后
        after-returning     # 正常退出
        after-throwing      # 异常退出
        around              # 执行前后
        代理对象(业务对象)：被注入的对象
模块
    dao, orm, aop, jee, web, core
结构
    核心容器(core container)
        Core        # 最底层，资源访问，类型转换
        Beans       # IOC, DI, BeanFactory
        Context     # 以Core、Beans为基础，ApplicationContext。资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播
        EL          # 表达式语言
    AOP, Aspects    # Aspects对AspectsJ集成, 功能多于spring asp
    数据访问/集成
        JDBC
        ORM
        OXM         # object xml 映射
        JMS         # 消息与异步通信
        事务
    Web/Remoting
        Web             # ioc窗口，rmi, hessian,burlap, web service
        Web-Servlet
        Web-Struts
        Web-Porlet      # portal认证
    Test
设计模式
    代理
        目标对象实现接口，使用Proxy
        未实现接口，使用CGLIB
    单例
        bean默认单例
    模板, 解决代码重复问题
        RestTemplate, JmsTemplate, JpaTemplate
    控制器
        DispatherServlet对请求分发
    视图帮助(view helper)
        提供jsp标签、高效宏 帮助在视图中写代码
    依赖注入
        BeanFactory, ApplicationContext核心理念
    工厂
        BeanFactory
循环依赖问题
    构造器, 正在创建在Bean池标记，创建完删除标记，标记冲突报错      # 所以用@Autowired决定注入时机，不写在构造方法里
    单例， 三级缓存, 提前暴露使双方都可初始化
    setter, 提前暴露bean
版本
    2.5
        注解
    3.2
        基于注解的注入测试类@RunW..
</code></pre>
<h1 id="使用">
  使用
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8">#</a>
</h1>
<pre><code>jar包 ：
    核心包：/dist/modules                # 或是/dist中的spring.jar包
        core模块
            beans
            context
            context-support
            core
    日志包：/lib/jakata-commons/commons-logging.jar
创建xml文件(最好在JavaBean的旁边)
    绑定约束文件        /dist/resources/spring-beans-2.5.xsd
    copy xml文件的头：/sample/petclinic/war/web-inf/app...xml
    创建JavaBean.java
    xml文件中配置bean                # src下
        &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;                # id值唯一,class指定 javaBean的类目录
            &lt;property name=&quot;&quot; value=&quot;&quot;&gt;
            &lt;property name=&quot;&quot; ref=&quot;girlID&quot;&gt;                # 引用类型，其中girlID为spring配置的bean Id
业务类中
    ApplicationContext ac = new ClassPathXmlApplicationContext(new String [] {&quot;配置xml文件路径&quot;})
        # 注意：ac创建时，其内部的JavaBean默认全部实例化一遍，并且全部注入了属性
        ## 该容器不用关闭
    if(ac.containsBean(&quot;boyID&quot;)){
        Boy boy = (Boy)ac.getBean(&quot;boyID&quot;);
    }
</code></pre>
<h1 id="api">
  api
  <a class="anchor" href="#api">#</a>
</h1>
<pre><code>ApplicationContext是一个接口，表示spring容器/ioc容器

ClassPathXmlApplicationContext        # 只从类路径中读取xml配置文件（src/目录下能访问的路径）省略src/目录

FileSystemXmlApplicationContext                # 文件路径 ,从src/开始

    ac.getBean(&quot;boyID&quot;)
    ac.containsBean(&quot;boyID&quot;)                # 通过此方法去判断是否存在 ，而不是得到的是否为null
    ac.destroy()                                        # ac中的bean实例全部销毁

BeanFactory
    # 基础IOC容器, 默认延迟初始化
    DefaultListableBeanFactory
    ApplicationContext
    XmlBeanFactory      # 根据xml中的定义加载bean
Spring-DAO      # 提供规范, 翻译框架(JDBC&lt;Hibernate,JPA等)异常为DataAccessException
    @Repository 注解DAO类
Spring-JDBC     # 模板类
    DataSource
    JdbcTemplate
    JdbcDaoSupport  # 对dao扩展, DataAccessExceptions异常翻译器
Spring-ORM      # 统称，对各模块(JPA,JDO,Hibernate,iBatis,TopLink,OJB)实现了spring的集成类
    把DataSource注入到SessionFactory或EntityManagerFactory等bean中     # jdbc不需要，因为jdbc直接使用DataSource
    HibernateTemplate
    HibernateDAOSupport     # 继承它提供aop拦截器
Web
    # 在ApplicationContext基础上, 提供web上下文和面向web的服务
    ApplicationContext      # 以BeanFactory为基础,容器启动后默认全部初始化绑定
        FileSystemXmlApplicationContext     # 指定文件
        ClassPathXmlApplicationContext      # 从classpath找设置
        WebXmlApplicationContext
</code></pre>
<h1 id="注解">
  注解
  <a class="anchor" href="#%e6%b3%a8%e8%a7%a3">#</a>
</h1>
<pre><code>applicationContext.xml
    &lt;context:annotation-config/&gt;
    &lt;!-- 添加注解扫描功能,启动的时候哪些包要检查是否有注解 --&gt;
    &lt;context:component-scan base-package=&quot;xxx&quot; /&gt;


@Required           # setter
@Autowired          # setter、构造方法、变量
@Qualifier(&quot;dataSource)                     # 多类配置时，指定使用类
@Bean               # 返回对象注册为bean
@Configuration      # bean定义

@Service            # 添加类名小写的spring bean id        也可以@Service(value=&quot;xx&quot;)自定义id
                    ## action类前换成@Controller                @Service也是可以的
@Scope(value=&quot;prototype&quot;)
                    # 工具类或其它组件类换成@Component 也可以@Service,如定时器TimerTask就是组件
@Resource           # 按属性名注入资源

测试类
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations = &quot;classpath:applicationContext*.xml&quot;)


@PostConstruct      # 类加载时运行的方法，相当于xml中配置的init-method
@PreDestroy         # 类销毁前运行的方法

aop
    applicationContext.xml
        &lt;aop:aspectj-autoproxy/&gt;
    @Aspect
        # 注册一个类为切面
    @Pointcut(value=&quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&quot;)
        # 配置切点表达式
    private void testAop(){}
    @AfterReturning(pointcut=&quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.save(..))&quot;)
        # 配置通知，在通知中配置切点
    @AfterReturning(value=&quot;testAop()&quot;)
        # 配置通知，使用已经配置的切点
    @Around(value=&quot;testAop()&quot;)
        # 配置通知，使用已经配置的切点
    @Around(value=&quot;execution(* cn.it.shop.service.impl.GoodsServiceImpl.queryByWord(..))&quot;)
        # 配置通知，在通知中配置切点,注意这里没有pointcut,只有value
</code></pre>
<h1 id="模块">
  模块
  <a class="anchor" href="#%e6%a8%a1%e5%9d%97">#</a>
</h1>
<h2 id="监听器">
  监听器
  <a class="anchor" href="#%e7%9b%91%e5%90%ac%e5%99%a8">#</a>
</h2>
<pre><code>原理
    org.springframework.web.context.ContextLoaderListener中
        this.contextLoader.initWebApplicationContext(event.getServletContext());
            # 加载Spring 的配置文件 ，加载Application内置对象中
    initWebApplicationContext方法中
        this.context = createWebApplicationContext(servletContext, parent);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
            # 创建并存储spring的application内置对象到ServletContext中，属性名称是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE
    createWebApplicationContext方法中
        wac.setConfigLocation(sc.getInitParameter(CONFIG_LOCATION_PARAM));
            # 该类文件中有：public static final String CONFIG_LOCATION_PARAM = &quot;contextConfigLocation&quot;;
            # 获得web.xml中配置的context-param初始化参数：contextConfigLocation的内容，并加载spring配置文件

使用
    servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);

    ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext)
</code></pre>
<h2 id="properties">
  properties
  <a class="anchor" href="#properties">#</a>
</h2>
<pre><code>spring xml配置文件中使用properties配置的属性
    配置一个bean的class类是org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer的单例bean
        &lt;property name=&quot;locations&quot; value=&quot;classpath:public.properties&quot; &gt;
            &lt;array&gt;
                &lt;value&gt;classpath:conn.properties&lt;/value&gt;
        或
        &lt;property name=&quot;location&quot; value=&quot;classpath:conn.properties&quot; /&gt;
    xml文件中用&quot;${driver}&quot;的方式引用properties中配置的属性
java类中用spring的注解注入properties配置的属性
    # 要求必须是spring管理的类
    bean中的class类换成org.springframework.beans.factory.config.PropertiesFactoryBean
    id=&quot;Xxx&quot;其它相同
    java类的属性或set方法上添加注解：
    @Value(&quot;#{public.basePath}#{public.filePath}&quot;)
        # 其中public 是上面配置的bean的id(xml文件中注入属性的话用不到id,所以没有配置)
        ## '#{}'代表引用属性
        ## '.'可以用'[]'代替，如public[basePath]
        ## 字符串的拼接可以用+连接
        # 第一次配置@Value的时候不会成功，改一次值再试就可以了
</code></pre>
<h2 id="bean">
  bean
  <a class="anchor" href="#bean">#</a>
</h2>
<pre><code>创建bean的顺序
    xml中按配置顺序的先后
    注解中按照字母的顺序
生命周期
    配置中定义&lt;bean&gt;&lt;/bean&gt;
    初始化
        配置文件中init-method
        实现org.springframework.beans.factory.InitializingBean接口
    调用
    销毁
        配置文件中destroy-method
        实现org.springframework.bean.factory.DisposeableBean
scope
    # 默认singleton
    prototype   # 每次产生新对象
    singleton   # 单例
    request     # 一个请求一个对象，只在ApplicationContext下有效
    session     # 一个session一个对象，只在ApplicationContext下有效
    global-session      # 一个全局session一个对象, 只在ApplicationContext下有效
内部bean
    &lt;property&gt;或&lt;constructor-arg&gt;中定义的&lt;bean&gt;,通常匿名
注入对象
    &lt;list&gt;
    &lt;set&gt;
    &lt;map&gt;
    &lt;props&gt;         # 键值都只能是string类型
自动装配
    方式
        no      # 不自动装配，通过ref属性指定
        byName
            查找类中setter
            容器中找id
            报空指针
        byType
            容器中找类型      # 找到多个时抛异常
        constructor
            byType带构造函数参数
        autodetect
            先试constructor, 再试byType
    写法
        &lt;bean&gt;属性autowire=&quot;byName&quot;
        @Autowired
            类型自动装配
            加上@Qualifier(value=&quot;a&quot;)
                @Resource(name=&quot;a&quot;)注解的name装配
                byName装配
                byType装配

配置
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;
        &lt;bean
            id=&quot;userDaoID&quot;
            name=&quot;&quot;
            class=&quot;cn.itcast.javaee.spring.bean.life.UserDao&quot;
            init-method=&quot;getSession&quot;
            destroy-method=&quot;closeSession&quot;
            factory-method=&quot;getUserDao&quot;
            scope=&quot;singleton&quot;
            lazy-init=&quot;false&quot;
            parent=&quot;userDaoID&quot;
            abstract=&quot;true&quot;
            autowire=&quot;no&quot;&gt;
                &lt;constructor-arg type=&quot;java.lang.Integer&quot; index ref&gt;
                    &lt;value&gt;2013&lt;/value&gt;
                &lt;constructor-arg type=&quot;java.lang.Double&quot;&gt;
                    &lt;value&gt;6000&lt;/value&gt;
                &lt;property name=&quot;name&quot; value=&quot;aa&quot;&gt;&lt;/property&gt;
                &lt;property name=&quot;name&quot; ref=&quot;dateID&quot; /&gt;
                &lt;property name=&quot;telSet&quot;&gt;
                &lt;set&gt;
                    &lt;value&gt;11&lt;/value&gt;
                &lt;property name=&quot;cityList&quot;&gt;
                &lt;list&gt;
                    &lt;value&gt;&lt;/value&gt;
                &lt;property name=&quot;telCityMap&quot;&gt;
                &lt;map&gt;
                    &lt;entry key=&quot;&quot;&gt;
                        &lt;value&gt;&lt;/value&gt;
                &lt;property name=&quot;&quot;&gt;
                    &lt;props&gt;
                        &lt;prop key=&quot;&quot;&gt;&lt;/prop&gt;
标签、属性分析
    bean标签：代表一个JavaBean
        # 多个JavaBean配置时，先配置的先创建，先创建的后销毁
        id：该JavaBean的唯一标识
        name：可以和id一样用，但是name可以设置&quot;/a&quot;来绑定路径
        class：该JavaBean的类路径
        init-method：创建该JavaBean时运行的其中的方法
        destroy-method：销毁该JavaBean时运行的其中的方法
            # ClassPathXmlApplicationContext类的实例不监听销毁方法
            ## 用AbstractApplicationContext中的close()与registerShutdownHook()方法
            ## close()直接马上销毁，registerShutdownHook()方法会注册关闭钩子,监听容器的销毁
            ## 
        factory-method：创建该Bean的函数
            得到接口实现类的方法
            1.通过实现类的无参构造器                # 没有factory-method属性
            2.没有无参构造器时，工厂静态方法创建实例
                &lt;bean id=&quot;userDaoID&quot; factory-bean=&quot;daoFactoryID&quot; factory-method=&quot;getUserDao&quot;&gt;
                    # class中的内容是工厂类，而非UserDao类，factory-method是工厂类中返回UserDao类的静态方法
            3.没有无参构造器时，工厂非静态方法创建实例
                &lt;bean id=&quot;daoFactoryID&quot; class=&quot;cn.itcast.javaee.spring.bean.create.type3.DaoFactory&quot;&gt;
                    &lt;bean id=&quot;userDaoID&quot; factory-bean=&quot;daoFactoryID&quot; factory-method=&quot;getUserDao&quot;&gt;
                        # 先实例化工厂（Spring 加载本xml文件默认实例化），然后静态方法的配置即可
        scope：作用域
            1.singleton（单例）是默认值，是单例的，会调用init destory方法 
            2.prototype（原型）每次创建一个实例， 调用init方法，但不调用destory方法（实例的维护 ：javase程序交给jvm,javaee程序交给服务器）
        lazy-init
            1.false:为启动容器时立即创建一个实例                # singleton与prototype模式都会创建
            2.true:启动时不加载,获取时创建
        parent：        继承一个Spring bean(包含其中的所有属性)
            # javaBean类中不必有实际的继承关系（但是有继承关系则必要配置parent）
        abstract=&quot;true&quot;        : 配置此Bean为抽象Bean
        autowire=&quot;no&quot;:自动装配，只能装配关联属性
            # 还可以进行注解装配
            byName      装配时根据bean中的每个属性名从spring中找id同名的bean,通过setter方法注入到该属性中
            byType      根据bean中的每个属性的类型找到spring中映射该类型的bean进行装配,通过setter方法注入到该属性中
            constructor 找满参构造器装载，构造器中的参数以byType方式注入
            autodetect  先找构造器装载，再set方法注入。但实际使用中只能set方法注入
            no          不注入
        可以配置init-method与destroy-method属性来配置该bean创建和销毁时执行的方法
    注入值                  # 通过setter方法注入值 
        &lt;constructor-arg type=&quot;java.lang.Integer&quot; index ref&gt;        
            &lt;value&gt;2013&lt;/value&gt;    # 传入构造方法参数注入值，,位置不能颠倒，不调用setter方法
                ## type是注入参数的类型，index是参数的标号，从0开始，ref是引用类型,有引用类型时不用&lt;value&gt;标签
            &lt;property name=&quot;name&quot; value=&quot;aa&quot;/&gt;                # 基本类型直接赋值（包括包装类型与String）
            &lt;property name=&quot;name&quot; ref=&quot;dateID&quot;/&gt;        # 引用类型,dateID是一个Spring Bean
                ## 可以直接引用Spring Bean 的id 
                &lt;set&gt;
                    &lt;value&gt;&lt;/value&gt;                                                # set集合
                &lt;list&gt;
                    &lt;value&gt;&lt;/value&gt;                                                # list集合
                &lt;map&gt;
                    &lt;entry key=&quot;&quot;&gt;
                            &lt;value&gt;&lt;/value&gt;                                        # map集合
                    # 集合的值均可配置引用类型
                &lt;property name=&quot;&quot;&gt;
                    &lt;props&gt;
                        &lt;prop key=&quot;&quot;&gt;&lt;/prop&gt;                        # 属性类型，只能配置基本类型 （包括包装类型与String）
</code></pre>
<h2 id="aop">
  aop
  <a class="anchor" href="#aop">#</a>
</h2>
<pre><code>实现      # 基于Aspectj
原理
    启动容器时，创建目标对象与代理对象
    &lt;aop:config/&gt;加载完时,通过cglib创建目标对象的代理对象，运行时产生
    程序员-代理对象-代理方法-目标对象-目标方法-代理对象
使用
    写类文件
    1.jar包  aspectjweaver.jar/aspectjrt.jar/cglib-nodep-2.1_3.jar(动态代理包)
    2.配置xml文件头,保留aop
        &lt;bean id class/&gt;        # 目标对象
        &lt;bean id=&quot;serviceBeanID&quot; class /&gt;    # 配置增强对象
        &lt;aop:config&gt;            # 相当于创建了代理对象
            &lt;aop:pointcut id=&quot;xxxx&quot; expression=&quot;&quot; /&gt;        # 切入点表达式：expression=&quot;execution(public void addUser() throws java.lang.Exception)&quot;
                ## 可以写成execution(public void 类名.*()),表示匹配所有方法
                ## execution(* *(..))        第一个*是返回值，第二个*是方法，..表示参数不限
                ## 可以声明抛异常
                ## 条件命名为xxxx,升级连接点到切入点
            &lt;aop:aspect ref=&quot;serviceBeanID&quot;&gt;
                &lt;aop:before method=&quot;writeLog&quot; pointcut-ref=&quot;xxxx&quot;/&gt;    # 前置增强，method是注入的方法，xxxx是增强的条件,只能写一个方法
                &lt;aop:after/&gt;
                &lt;aop:after-returning/&gt;      # 方法返回后执行
                &lt;aop:after-throwing/&gt;      # 抛出异常时执行
                &lt;aop:around/&gt;              # 环线，执行目标方法前、后都执行,出错则之后的函数不执行
                    public void both(ProceedingJoinPoint pjp){      # ProceedingJoinPoint是连接代理对象 与目标对象的桥梁
                        open();
                        pjp.proceed();      # 执行目标代码
                        close();
                    }
                    # 目标方法出错，后置增强仍然执行,after-throwing执行，前置增强不执行,after-returning不执行
                    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;xxxx&quot;/&gt;                # 配置事务的切面
切入点表达式
    execution(方法的修饰符 方法的返回值类型 方法所属的类 方法名 方法中参数列表 方法抛出的异常)
        方法的修饰符：    支持通配符*，可省略
        方法的返回值类型：支持通配符*，表示所有返回值，不可省
        方法所属的类：    支持通配符*，可省略
        方法名：          支持通配符*，表示所有方法，不可省
        方法中参数列表：  支持通配符*，不可省
                # *表示【一个】任意类型的参数
                ## ..表示零个或一个或多个任何类型的参数【提倡】
    execution(方法的返回值类型 方法名（方法中参数列表））                # 一般形式

    例如:
    execution(public void add()throws Exception)
    execution(public void add(..)throws Exception)
    execution(public void add(*)throws Exception)
    execution(* cn.itcast.web.spring.aop.UserDao.add(..))
    execution(* add()throws Exception)
    execution(public void *(..)throws Exception)
            execution(public void a*(..)throws Exception)：方法名以a字符开始
    execution(public void *d(..)throws Exception)：方法名以d字符结束
    execution(* add())
    execution(* *(..))
切点方法的编写
    public void Xxx(JoinPoint joinPoint){
        joinPoint.getTarget();                # 获取目标对象
        joinPoint.getSignature();        # 获取当前连接点的方法信息
        joinPoint.getArgs()[0];                # 获取当前连接点的第一个参数
        ..
    }
    public Goods Yxx(ProceedingJoinPoint joinPoint){
        Object object = joinPoint.proceed();        # 得到连接点的返回值
        ..
        return goods;                # 本切面返回的数据会作为切点返回的数据返回给调用它的函数
    }
</code></pre>
<h2 id="dao">
  dao
  <a class="anchor" href="#dao">#</a>
</h2>
<pre><code>使用
    1.xml文件中
    &lt;!-- 配置C3P0连接池 --&gt;
        &lt;bean id=&quot;comboPooledDataSourceID&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/spring&quot;/&gt;
            &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;initialPoolSize&quot; value=&quot;60&quot;/&gt;
            &lt;property name=&quot;acquireIncrement&quot; value=&quot;5&quot;/&gt;
        &lt;/bean&gt;

        &lt;!-- 配置JdbcTemplate --&gt;
        &lt;bean id=&quot;jdbcTemplateID&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;comboPooledDataSourceID&quot;/&gt;
        &lt;/bean&gt;

        &lt;!-- 配置UserDao --&gt;
        &lt;bean id=&quot;userDaoID&quot; class=&quot;dao.UserDao&quot;&gt;
            &lt;property name=&quot;jt&quot; ref=&quot;jdbcTemplateID&quot;/&gt;
        &lt;/bean&gt;
    2.Dao中
        private JdbcTemplate jt;
        addUser()
            String sql = &quot;&quot;;
            Object [] params = {user.getUsername(),user.getPassword()}
            jt.update(sql,params);
            批量：
            for(int i = 0; i &lt; ids.length; i++){
                sqls[i] = &quot;&quot;;
            }
            jt.batchUpdate(sqls);
            查询一个
        return (User)jt.queryForObject(sql,params,new RowMapper(){
                public Object mapRow(ResultSet rs,int rowNum){          # rs是查询出来的结果集,rowNum是结果集的行号,从0开始
                    Integer id = rs.getInt(&quot;id&quot;);
                    User user = new User(id);
                    return user;
                }
                });
            查询多个                # query方法把RowMapper帮助类中返回的user分别加入到list中，返回一个list
            list = jt.query(sql,new RowMapper(){
                    public Object mapRow()
                        ..
                        return bean;
                })
            分页
                            String sql = &quot;select * from users limit ?,?&quot;;
                            Object[] params = {0,3};
            jt.query(sql,params,new RowMapper(){
            记录
            jt.queryForInt(sql);
</code></pre>
<h2 id="事务">
  事务
  <a class="anchor" href="#%e4%ba%8b%e5%8a%a1">#</a>
</h2>
<pre><code>TransactionInterceptor
    transactionManager          # 指定事务治理类
    transactionAttributes       # key方法名 value事务属性
注解
    @Transactional(propagation = Propagation.REQUIRED)
手写      # TransactionDefinition
    Public class BankServiceImpl implements BancService{
        Private BanckDao bankDao;
        private TransactionDefinition txDefinition;
        private PlatformTransactionManager txManager;
        public boolean transfer(Long fromId, Long toId, double amount) {
            TransactionStatus txStatus = txManager.getTransaction(txDefinition);
            boolean result = false;
            try {
                result = bankDao.transfer(fromId, toId, amount);
                txManager.commit(txStatus);
            } catch (Exception e) {
                result = false;
                txManager.rollback(txStatus);
                System.out.println(&quot;Transfer Error!&quot;);
            }
            return result;
        }
    }
手写      # TransactionTemplate
    public class BankServiceImpl implements BankService {
        private BankDao bankDao;
        private TransactionTemplate transactionTemplate;
        public boolean transfer(final Long fromId, final Long toId, final double amount) {
            return (Boolean) transactionTemplate.execute(new TransactionCallback(){
            public Object doInTransaction(TransactionStatus status) {
                Object result;
                try {
                    result = bankDao.transfer(fromId, toId, amount);
                } catch (Exception e) {
                    status.setRollbackOnly();
                    result = false;
                    System.out.println(&quot;Transfer Error!&quot;);
                }
                return result;
            }
            });
        }
    }
配置      # TransactionInterceptor
    &lt;bean id=&quot;transactionInterceptor&quot; class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
        &lt;property name=&quot;transactionAttributes&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;bankServiceTarget&quot; class=&quot;footmark.spring.core.tx.declare.origin.BankServiceImpl&quot;&gt;
        &lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;bankService&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
        &lt;property name=&quot;target&quot; ref=&quot;bankServiceTarget&quot;/&gt;
        &lt;property name=&quot;interceptorNames&quot;&gt;
            &lt;list&gt;
                &lt;idref bean=&quot;transactionInterceptor&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
配置      # TransactionProxyFactoryBean
    &lt;bean id=&quot;bankServiceTarget&quot; class=&quot;footmark.spring.core.tx.declare.classic.BankServiceImpl&quot;&gt;
        &lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;bankService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;
        &lt;property name=&quot;target&quot; ref=&quot;bankServiceTarget&quot;/&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
        &lt;property name=&quot;transactionAttributes&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
配置      # tx空间
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;

    &lt;!--配置c3p0连接池--&gt;
    &lt;!-- 配置JdbcTemplate类 --&gt;
    &lt;!-- 配置Dao --&gt;
    &lt;!-- 配置jdbc事务管理器 --&gt;
    &lt;bean id=&quot;dataSourceTransactionManagerID&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;comboPooledDataSourceID&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 配置事务增强(服务对象) --&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;dataSourceTransactionManagerID&quot;&gt;
    &lt;tx:attribute&gt;
        &lt;tx:method name=&quot;addUsers&quot;                      # 可以用通配符&quot;*users&quot;
            propagation=&quot;required&quot;                  # 传播行为：事务开始、结束的时间。required 保证方法执行时事务已开始，事务开始时不创建，没有开始时创建
            isolation=&quot;default&quot;                     # 隔离级别
            timeout=&quot;-1&quot;                            # 事务超时,-1代表不超时，用数据库底层的配置
            rollback-for:&quot;java.lang.Exception&quot;      # 何时回滚
            read-only=&quot;false&quot;                       # 不只读
                # name 方法名的匹配模式
                # required : 外部存在事务，则加入外部事务，不存在则新建事务
                # requires_new : 总是新建事务
                # mandatory : 外部必须存在事务
                # never : 外部不能存在事务
                # supports : 外部存在则加入，不存在则不以事务方式运行
                # not_supported : 总是非事务
                # nested : 外部存在事务，嵌套执行，不存在则新建
                # no-rollback-for 以逗号分隔异常，这些异常不会导致事务回滚
                # rollback-for 导致事务回滚的异常
        /&gt;
    &lt;tx:attribute&gt;

    &lt;!-- 配置AOP --&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;xxxx&quot; expression=&quot;execution(public void *Users(..))&quot;/&gt;
        ##
        任意公共方法的执行：
        execution(public * *(..))
        任何一个以“set”开始的方法的执行：
        execution(* set*(..))
        AccountService 接口的任意方法的执行：
        execution(* com.xyz.service.AccountService.*(..))
        定义在service包里的任意方法的执行：
        execution(* com.xyz.service.*.*(..))
        定义在service包和所有子包里的任意类的任意方法的执行：
        execution(* com.xyz.service..*.*(..))
        定义在pointcutexp包和所有子包里的JoinPointObjP2类的任意方法的执行：
        execution(* com.test.spring.aop.pointcutexp..JoinPointObjP2.*(..))&quot;)

        &lt;!-- 将事务代码切入点addUser()方法中，从而产生事务 --&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;xxxx&quot;/&gt;
    &lt;/aop:config&gt;
</code></pre>
<h2 id="spring-mybatis">
  spring mybatis
  <a class="anchor" href="#spring-mybatis">#</a>
</h2>
<pre><code>基础
    #与$
        #相当于解析成引号, 防止sql注入
        $变量引用, 不能防止sql注入，用于传入表名之类
    特点
        sql易维护，传参方便
        orm
    Mapper接口
        方法名与配置id相同
        输入输出参数类型对应定义的parameterType类型和resultType类型
        类路径是配置的namespace
    缓存
        # 基于PerpetualCache的HashMap
        一级缓存
            存在本地
            作用域为session, session flush后清空
        二级缓存
            可定义存储服务
            作用域为namespace
            配置
                &lt;cache/&gt;
                    readOnly=&quot;true&quot; 时，缓存实例单例，false时返回缓存拷贝
        更新
            create, update, delete后，作用域下所有select缓存clear
与hibernate区别
    都通过SessionFactoryBuilder从配置生成SessionFactory, 再生成Session
    都支持jdbc和jta
    mybatis可细致优化sql, hibernate移植性好
    mybatis学习成本低
    mybatis本身缓存不好，hibernate对象维护和缓存好
    hibernate dao层封开发简单(不用维护映射)，crud方便
使用
    编程
        创建SqlSessionFactory
        创建SqlSession
        执行数据库操作
        session.commit()
        session.close()
    导入ibatis jar包
    配置文件
        SqlMap.properties        # 属性名可以修改
            driver=oracle.jdbc.driver.OracleDriver
            url=jdbc:oracle:thin:@127.0.0.1:1521:orcl
            username=root
            password=root
        SqlMapConfig.xml                # 总配置文件
            &lt;sqlMapConfig&gt;
                &lt;properties recource=&quot;SqlMap.properties&quot;/&gt;
                &lt;transactionManager type=&quot;JDBC&quot;&gt;
                        &lt;dataSource type=&quot;SIMPLE&quot;&gt;
                            &lt;property value=&quot;${driver}&quot; name=&quot;JDBC.Driver&quot;/&gt;
                            &lt;property value=&quot;${url}&quot; name=&quot;JDBC.ConnectionURL&quot;/&gt;
                            &lt;property value=&quot;${username}&quot; name=&quot;JDBC.Username&quot;/&gt;
                            &lt;property value=&quot;${password}&quot; name=&quot;JDBC.Password&quot;/&gt;
                        &lt;/dataSource&gt;
                    &lt;sqlMap resource=&quot;Student.xml&quot;/&gt;
                &lt;/transactionManager&gt;
            &lt;/sqlMapConfig&gt;
        Student.xml                                # 映射xml文件
            &lt;sqlMap&gt;
                &lt;typeAlias alias=&quot;Student&quot; type=&quot;com.Student&quot;/&gt;
                    &lt;select id=&quot;selectAllStudent&quot; resultClass=&quot;Student&quot;&gt;
                        select * from Student
                    &lt;/select&gt;
                &lt;/typeAlias&gt;
            &lt;/sqlMap&gt;
        辅助类Student.java                 # 要求有无参构造方法
            private sid = 0;
            private String name = null;
            private String major = null;
            private Date birth = null;
            private float score = 0;
    Xxx.java
        private static SqlMapClient sqlMapClient = null;
        static{
            Reader reader = Resources.getResourceAsReader(总配置文件);
            sqlMapClient = SqlMapClientBuilder.buildSqlMapClient(reader);
            reader.close();
        }
        public List&lt;Student&gt; queryAllStudent(){
            List&lt;Student&gt; studentList = sqlMapClient.queryForList(&quot;selectAllStudent&quot;);
            return studentList;
        }
        @Test
        public void testHere(){
            for(Student student: this.queryAllStudent()){
                System.out.println(student.getName);
            }
        }
配置
    sqlMapConfig.xml
        mybatis加载属性顺序
            properties中property中的属性
            properties中resource或url中的属性
            parameterType中传递一属性
                # properties中配的属性会影响到mapper.xml中${}的sql拼接，因为都是ognl
        配置标签
            properties
            settings
                # ibatis有性能优化的参数，mybatis会自动调优，不用设置了
            typeAliases
                # 针对parameterType和resultType指定的类型定义别名
                # java.lang.Integer在mybatis中默认别名为int
            typeHandlers
                # 类型处理器，jdbc类型和java类型的转换
                ## 一般mybatis提供的类型处理器够用了
            objectFactory
            plugins
            environments
            mappers
    mapper.xml
        内容
            #{}接收简单类型, pojo的ognl属性注入
            ${}是字符串的拼接

        SELECT * FROM USER WHERE id=#{id}
        SELECT * FROM USER WHERE username LIKE '%${value}%'
            # sql 注入
    输入输出映射
        parameterType
            java类型
            hashmap
                # #{key}来取value
            pojo
            包装类型
        resultType
                # 指定一条数据的类型，在java方法的返回类型中list或pojo来体现数据条数
                # mybatis判断mapper代理中使用selectOne或者selectType
            pojo
                # 返回字段可以是别名，但要与pojo中的属性名相同
                ## 如果有记录返回但没有pojo中匹配的属性名对应，则直接不创建该对象
            java类型
                # 在返回结果只有一行一列时，可以是简单类型
            hashmap
                # key是字段的字，value是字段的值
                ## 多条数据时，list里面存hashmap
        resultMap
            # 查询出来的字段名与pojo属性名不一致
            定义resultMap
            使用resultMap
    动态sql
        &lt;where&gt;
        &lt;if&gt;

        sql片段&lt;sql&gt;

        &lt;foreach&gt;
    高级映射
    缓存
    逆向
        要求
            1. mapper.xml中namespace 写mapper接口
                &lt;mapper namespace=&quot;com.otr.tea.mapper.UserMapper&quot;&gt;
            2. mapper.java中方法名与mapper.xml的statementid一致
            3. mapper.java中方法的输入类型与mapper.xml中的parameterType一致
                # 由于传入的参数只有一个，所以用包装类型的pojo来传多个参数，不利于业务层的可扩展性
            4. mapper.java中方法的返回类型与mapper.xml中的resultType一致
        机制
            如果Mapper中返回类型为pojo, 则调用selectOne, 如果是List, 则调用selectList
api
    sqlSessionFactory
    sqlSession                        # 是线程不安全的，因为它的类中有数据和属性
                                    ＃ 是多例的，在方法中局部变量使用
        Executor                # 执行器操作数据库（基本执行器，缓存执行器）
    mapped statement                # 封装sql语句、输入参数、输出结果类型

    例子
        InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
            # Resources是mybatis提供的资源加载类
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);
        SqlSession sqlSession = factory.openSession();
        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);
            ＃ selectList()
            # insert(&quot;test.insertUser&quot;, user)
            ## sqlSession.commit();
            ## user.getId() 会主键返回
            ### mysql中LAST_INSERT_ID()在insert语句后接着执行可以得到刚刚自成的id
        sqlSession.close();
案例
    返回id
        mysql
            &lt;insert id=&quot;insert&quot; parameterType=&quot;com.test.User&quot; keyProperty=&quot;userId&quot; useGeneratedKeys=&quot;true&quot; &gt;
        oracle
            &lt;insert id=&quot;insert&quot; parameterType=&quot;com.test.User&quot;&gt;
                &lt;selectKey resultType=&quot;INTEGER&quot; order=&quot;BEFORE&quot; keyProperty=&quot;userId&quot;&gt;
                    SELECT SEQ_USER.NEXTVAL as userId from DUAL
                &lt;/selectKey&gt;

                insert into user (user_id, user_name, modified, state)
                values (#{userId,jdbcType=INTEGER}, #{userName,jdbcType=VARCHAR},
                #{modified,jdbcType=TIMESTAMP}, #{state,jdbcType=INTEGER})
            &lt;/insert&gt;
</code></pre>
<h2 id="spring-struts2">
  spring struts2
  <a class="anchor" href="#spring-struts2">#</a>
</h2>
<pre><code>原理
    tomcat启动日志：没有整合时不能加载struts-plugin.xml（spring-struts-plugin.jar包中的配置文件 ）
    struts中struts-default中常量配置加载com.opensymphony.xword2.ObjectFactory类作为默认struts创建action的类
    加载后struts-plugin.xml 中 修改了常量为struts-spring-plugin中的类来创建struts的类，也就是整个struts2创建action类的类被更改了

整合
    jar包 struts2/lib/struts2-spring-plugin-2.3.1.1.jar                        # 为了在struts的xml配置文件中的class找spring 的容器
    配置web.xml   # \samples\petclinic\war\WEB-INF\web.xml目录下有示例
                                            
        &lt;listener&gt;          # 监听器，web程序启动时加载spring bean
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener
        &lt;context-param&gt;     # （可选）配置spring 配置文件的路径，
                            ## 从示例文件中查到，默认文件目录是/WEB-INF/applicationContext.xml(我们示例文件也是从源码/simple项目下的这个开头的文件中找的)
            &lt;param-name&gt;contextConfigLocation
            &lt;param-value&gt;/WEB-INF/classes/struts2/xxx.xml
    UserAction 中    # 不用值栈是因为通用性
    spring.xml        # action类由spring 产生
        &lt;bean id=&quot;userActionID&quot; class=&quot;&quot; scope=&quot;prototype&quot;/&gt;
    struts2的配置文件中，替换class属性为spring beanid，其它一样
总结
    spring的web配置是由下向上，一个个依赖注入的过程
        comboPooledDataSourceID -&gt;
        localSessionFactoryBeanID -&gt;
        hibernateTemplateID -&gt;
        SysStaffDaoID -&gt;
        SysStaffServiceID -&gt;
        SysStaffActionID -&gt;
        struts.xml配置中的&lt;action class=&quot;SysStaffActionID&quot;&gt;
    最后给Dao中的方法加入事务
</code></pre>
<h2 id="spring-mvc">
  spring mvc
  <a class="anchor" href="#spring-mvc">#</a>
</h2>
<pre><code>原理
    DispatchServlet doService()捕获请求, doDispatch()用HandlerMapping映射url得到HandlerExcutionChain(执行链, 包括拦截器和handler)
    handler getHandlerAdapter得到适配器来处理handler, 返回ModelAndView
        # HandlerAdapter分三类: Servlet、Controller, HttpRequest
    DispatchServlet用ViewResolver(视图解析器)解析ModelAndView成View
        # ModelAndView是逻辑视图，DispatchServlet转化成视图View
    返回View
与struts2区别
    spring mvc方法对应请求, struts2是类
    spring mvc请求是方法调用，struts2创建Action实例
    spring mvc用aop处理请求，struts2用独有的拦截器(interceptor)
    spring mvc入口是servlet, struts2入口是filter
    spring mvc集成ajax(@ResponseBody), struts2需要插件
    spring mvc验证支持JSR303, struts2不支持
    spring mvc与spring无缝
    spring mvc不需要配置
注解
    @RequestMapping             # url映射
    @RequestBody                # 转换参数到对象
    @ResponseBody               # 返回对象转json

    开启注解处理器
        springmvc.xml
            &lt;mvc:annotation-driven&gt;
乱码问题
    post
        web.xml中配置CharacterEncodingFilter
    get
        tomcat配置文件修改项目编码
        new String(Request.getParameter(&quot;a&quot;).getBytes(&quot;ISO8859-1&quot;), &quot;utf-8&quot;)
</code></pre>
<h2 id="quartz定时器">
  quartz:定时器
  <a class="anchor" href="#quartz%e5%ae%9a%e6%97%b6%e5%99%a8">#</a>
</h2>
<pre><code>执行：ApplicationContext类加载后自动执行
导包：quartz-all.jar包 与  commons-collections.jar包 与 commons-logging.jar
xml配置：
    &lt;!-- 任务类 ,其中有个叫execute的方法--&gt;
    &lt;bean id=&quot;myTaskID&quot; class=&quot;jee.quartz.MyTask&quot;/&gt;

    &lt;!-- spring提供专用于定时任务类 --&gt;
    &lt;bean id=&quot;methodInvokingJobDetailFactoryBeanID&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;
        &lt;!-- 要定时执行的实例的spring bean id --&gt;
        &lt;property name=&quot;targetObject&quot;&gt;
                &lt;ref bean=&quot;myTaskID&quot;/&gt;
        &lt;/property&gt;
        &lt;!-- spring bean中定时执行的方法 --&gt;
        &lt;property name=&quot;targetMethod&quot;&gt;
                &lt;value&gt;execute&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- spring提供专用于任务频率类，给上面的任务指定频率 --&gt;
    &lt;bean id=&quot;cronTriggerBeanID&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;
        &lt;property name=&quot;jobDetail&quot;&gt;
                &lt;ref bean=&quot;methodInvokingJobDetailFactoryBeanID&quot;/&gt;
        &lt;/property&gt;
        &lt;property name=&quot;cronExpression&quot;&gt;
                &lt;value&gt;0 0/1 * * * ?&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- spring提供的专用于任务频率工厂类 --&gt;
    &lt;bean id=&quot;schedulerFactoryBeanID&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;
        &lt;property name=&quot;triggers&quot;&gt;
            &lt;ref bean=&quot;cronTriggerBeanID&quot;/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
任务频率cronTriggerBean的配置：
    cron解析器:
        反斜线（/）字符表示增量值。例如，在秒字段中“5/15”代表从第 5 秒开始，每 15 秒一次。
        问号（?）字符和字母 L 字符只有在月内日期和周内日期字段中可用。问号表示这个字段不包含
        具体值。
        所以，如果指定月内日期，可以在周内日期字段中插入“?”，表示周内日期值无关紧要。字母
        L 字符是 last 的缩写。放在月内日期字段中，表示安排在当月最后一天执行。在周内日期字
        段中，如果“L”单独存在，就等于“7”，否则代表当月内周内日期的最后一个实例。所以“0L”
        表示安排在当月的最后一个星期日执行。
        在月内日期字段中的字母（W）字符把执行安排在最靠近指定值的工作日。把“1W”放在月内
        日期字段中，表示把执行安排在当月的第一个工作日内。
        井号（#）字符为给定月份指定具体的工作日实例。把“MON#2”放在周内日期字段中，表示把任
        务安排在当月的第二个星期一。
        星号（*）字符是通配字符，表示该字段可以接受任何可能的值。
    顺序：秒 分 时 日 月 周 年（年可以忽略）
    例子
        0 0 10,14,16 * * ?                  每天上午10点，下午2点，4点
        0 0/30 9-17 * * ?            朝九晚五工作时间内每半小时
        0 0 12 ? * WED                          表示每个星期三中午12点
        0 0 12 * * ?                          每天中午12点触发
        0 15 10 ? * *                          每天上午10:15触发
        0 15 10 * * ?                          每天上午10:15触发
        0 15 10 * * ? *                  每天上午10:15触发
        0 15 10 * * ? 2013          2013年的每天上午10:15触发
        0 * 14 * * ?                          在每天下午2点到下午2:59期间的每1分钟触发
        0 0/5 14 * * ?                          在每天下午2点到下午2:55期间的每5分钟触发
        0 0/5 14,18 * * ?                  在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
        0 0-5 14 * * ?                          在每天下午2点到下午2:05期间的每1分钟触发
        0 10,44 14 ? 3 WED                  每年三月的星期三的下午2:10和2:44触发
        0 15 10 ? * MON-FRI                周一至周五的上午10:15触发
        0 15 10 15 * ?                          每月15日上午10:15触发
        0 15 10 L * ?                            每月最后一日的上午10:15触发
        0 15 10 ? * 6L                    每月的最后一个星期五上午10:15触发
        0 15 10 ? * 6L 2014-2018        2014年至2018年的每月的最后一个星期五上午10:15触发
        0 15 10 ? * 6#3                        每月的第三个星期五上午10:15触发
        0/1 * * * * ?                        每秒钟触发一次
        0 0/1 * * * ?                        每分钟解发一次
        0 0 0/1 * * ?                        每小时解发一次
</code></pre>
<h2 id="远程调用">
  远程调用
  <a class="anchor" href="#%e8%bf%9c%e7%a8%8b%e8%b0%83%e7%94%a8">#</a>
</h2>
<pre><code># rmi:remote message invoke
服务端
    1.自定义接口IServer,自定义抽象方法int rax(int)
    2.写接口实现类ServerImpl
    3.配置spring.xml 文件
        &lt;!-- 服务端实现类 --&gt;
        &lt;bean id=&quot;serverImplID&quot; class=&quot;jee.server.ServerImpl&quot;/&gt;
        &lt;!-- spring提供的专用于RMI服务端注册器 --&gt;
        &lt;bean id=&quot;rmiServiceExporterID&quot; class=&quot;org.springframework.remoting.rmi.RmiServiceExporter&quot;&gt;
            &lt;property name=&quot;serviceInterface&quot;&gt;
                    &lt;value&gt;jee.server.IServer&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name=&quot;service&quot;&gt;
                    &lt;ref bean=&quot;serverImplID&quot;/&gt;
            &lt;/property&gt;
            &lt;property name=&quot;serviceName&quot;&gt;
                    &lt;value&gt;XXXX&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
客户端
    配置spring.xml 文件
        &lt;!-- spring提供专用于RMI远程服务代理工厂类 --&gt;
        &lt;bean id=&quot;rmiProxyFactoryBeanID&quot; class=&quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&quot;&gt;
            &lt;!-- 协议名://远程提供服务的IP地址:提供服务的端口/提供服务的名称 --&gt;
            &lt;property name=&quot;serviceUrl&quot;&gt;
                    &lt;value&gt;rmi://127.0.0.1:1099/XXXX&lt;/value&gt;
            &lt;/property&gt;
            &lt;property name=&quot;serviceInterface&quot;&gt;
                    &lt;value&gt;jee.client.IServer&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
执行：
    服务端加载 ApplicationContext类
    客户端
        加载 ApplicationContext类 ac
        ac.getBean方法中得到RmiProxyFactoryBean实际类型（可变类型）的实例，强转成服务端自定义的接口IServer的实现类（实现类由服务器决定）
        执行IServer实现类中的方法int rax(int)，实现了远程调用
</code></pre>
<h2 id="websocket">
  websocket
  <a class="anchor" href="#websocket">#</a>
</h2>
<pre><code>handler
    extends TextWebSocketHandler
        @Override
        handleTextMessge()                      # 处理client.send()的数据

        @Override
        afterConnectionEstablished(WebSocketSession)                    # 连接事件

        @Override
        handleTransportError()                  # 出错事件

        @Override
        afterConnectionClosed()                 # 断开事件

        @Override
        supportsPartialMessages()               # 并行处理
config
    @EnableWebSocket
    implements WebSocketConfigurer
        @Override
        registerWebSocketHandlers()
            registry.addHandler(handler, &quot;/ws&quot;)                         # 路由handler
client
    extends WebSocketClient
        constructor(uri)
            super(new URI(uri))

        @Override
        onOpen()

        @Override
        onClose()

        @Override
        onError()

        @Override
        onMessage()
service
    init()
        client = new Client(&quot;ws://127.0.0.1:8001/ws&quot;)
        client.connectBlocking()
    send()
        while(!client.getReadyState().equals(ReadyState.OPEN)){
            log(&quot;connecting&quot;)
        }
        client.send(&quot;&quot;)
runner
    implements ApplicationRunner
        run()
            service.init()
</code></pre>
<h1 id="spring-boot">
  spring boot
  <a class="anchor" href="#spring-boot">#</a>
</h1>
<pre><code>介绍
    减少配置, 习惯大于配置
    支持groovy, gradle
命令
    java -jar xxx.jar
        --server.port=8080                                      # --后内容，相当于application.yml设置
        --spring.profiles.active=two                            # 选择applicaton-two.yml配置
</code></pre>
<h2 id="基础文件">
  基础文件
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80%e6%96%87%e4%bb%b6">#</a>
</h2>
<pre><code>目录
    src
        main
            java
                com.outrun
                    XxxApplication
            resources
                static/
                templates/
                application.properties
                application.yml
            webapp
                WEB-INF
        test
            java
                com.outrun
                    XxxApplicationTests
    pom.xml
XxxApplication.java                                     # 程序入口
    @SpringBootApplication                              # 类，组合@Configuration, @EnableAutoConfiguration, @ComponentScan
        @EnableAutoConfiguration根据jar包依赖自动配置
        扫描该注解同级下级包的Bean
application.yml                                         # application.yml或application.properties, 放在src/main/resources或config目录下
pom.xml
</code></pre>
<h2 id="配置">
  配置
  <a class="anchor" href="#%e9%85%8d%e7%bd%ae">#</a>
</h2>
<pre><code>区分环境
    application-{profile}.properties                                    # profile比如是dev, test, prod
    设置spring.profiles.active=dev来区分
加载顺序                                                                 # 为了外部人员维护，可覆盖定义
    命令行
    SPRING_APPLICATION_JSON环境变量, json格式
    java:comp/env的JNDI属性
    java系统属性                                                         # System.getProperties()查看
    系统环境变量
    random.*配置的随机属性
    jar包外文件名, 如application-{profile}.properties
    jar包内文件名
    @Configuration注解类中，@PropertySource修改的属性
    SpringApplication.setDefaultProperties定义的内容
application.yml
    ---                                                 # ---分隔多个配置，这里相当于建立了application-two.yml文件
    spring:
        profiles: two
    ---
    spring:
        profiles
            active: dev                                 # 配置环境, 加载applicaton-dev.yml
        application:
            name: app1
pom.xml
    &lt;packaging&gt;jar&lt;/packaging&gt;                          # 不用war包部署, 嵌入了tomcat, jar可服务
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;             # 提供spring boot基础依赖和默认配置
        &lt;relativePath/&gt;                                 # 从仓库查找parent
    &lt;/parent&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;       # 方便启动停止应用, 如mvn spring-boot:run
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
<h2 id="注解-1">
  注解
  <a class="anchor" href="#%e6%b3%a8%e8%a7%a3-1">#</a>
</h2>
<pre><code>@SpringBootApplication                      # spring boot 启动类
    组合了@Configuration, @EnableAutoConfiguration, @ComponentScan
</code></pre>
<h2 id="类">
  类
  <a class="anchor" href="#%e7%b1%bb">#</a>
</h2>
<pre><code>ApplicationRunner                           # 继承该类，注解@Component, 随容器启动运行
    run()
</code></pre>
<h2 id="插件">
  插件
  <a class="anchor" href="#%e6%8f%92%e4%bb%b6">#</a>
</h2>
<h3 id="maven">
  maven
  <a class="anchor" href="#maven">#</a>
</h3>
<pre><code>命令
    mvn spring-boot:run
pom.xml
    &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;       # 方便启动停止应用, 如mvn spring-boot:run
    &lt;/plugin&gt;
</code></pre>
<h2 id="组件">
  组件
  <a class="anchor" href="#%e7%bb%84%e4%bb%b6">#</a>
</h2>
<pre><code>starter POMs            # spring-boot-starter开头的组件
</code></pre>
<h2 id="子域">
  子域
  <a class="anchor" href="#%e5%ad%90%e5%9f%9f">#</a>
</h2>
<h3 id="namedcontextfactory">
  NamedContextFactory
  <a class="anchor" href="#namedcontextfactory">#</a>
</h3>
<pre><code>class Spec1 implements NamedContextFactory.Specification {
    @Override
    public String getName(){}
    @Override
    public Class&lt;?&gt;[] getConfiguration(){}
}
public class MyFactory extends NamedContextFactory&lt;Specification1&gt; {
    public MyFactory(Class&lt;?&gt; clazz) {
        super(clazz, &quot;my&quot;, &quot;my.name&quot;)
    }
}
@Configuration
public class Config0 {
    @Bean
    Bean0 getBean(){
        return new Bean0()
    }
}

parent = new AnnotationConfigApplicationContext()
parent.register(Config0.class)
parent.refresh()
factory = new MyFactory(Config00.class)
factory.setApplicationContext(parent) 

spec1 = new Spec1(&quot;1&quot;, new Class[]{Config1.class})
factory.setConfigurations(List.of(spec1))
factory.getInstance(&quot;1&quot;, Bean0.class)   // 子域共享
factory.getInstance(&quot;1&quot;, Bean00.class)  // 子域复制
factory.getInstance(&quot;1&quot;, Bean1.class)
</code></pre>
<h3 id="spring">
  spring
  <a class="anchor" href="#spring">#</a>
</h3>
<pre><code>配置
    随机数用${random}
        ${random.value} 字符串
        ${random.int} int
        ${random.long} long
        ${random.int(10)} 10以内int
        ${random.int[10,20]} 10到20 int
    pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    application.yml
        aa
            bb: 1                                           # 可用properties类管理属性
        xxx: 1                                              # 自定义value
            配置文件中用&quot;${xxx}&quot;引用
            类中用@Value(&quot;${xxx}&quot;)注入到属性
            SpEL中用&quot;#{xxx}&quot;引用
    AaProperties.java
        @Component
        @ConfigurationProperties(prefix = &quot;aa&quot;)
        public class AaProperties {
            private String bb;
            ...getter和setter...
        }
    注解    
        @Configuration
        @PropertySource(value = &quot;classpath:test.properties&quot;)                    # 加载文件, 配合@ConfigurationProperties注入属性
        @EnableConfigurationProperties({ConfigBean.class, User.class})          # 加载bean, 配合@Autowired注入
基础
    注解
        @Value(&quot;${xxx}&quot;)
        @Autowired                                  # 装载bean
        @Bean                                       # 实例化Bean, 属性名为方法名
            @Bean
            public RestTemplate restTemplate() {
                return new RestTemplate();
            }
            相当于
            RestTemplate restTemplate = new RestTemplate();
        @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)                         # 生命周期
            singleton                               # 单例
            prototype                               # 多例
            request                                 # web程序ContextApplication用, 随请求创建
            session                                 # web程序ContextApplication用, 随session创建
            global session                          # porlet的global用, 其它用降级为session
        @EventListener(XxxEvent.class)              # 修饰方法, 外部publishEvent()时触发
实体
    注解
        @Entity                                     # 修饰bean类
        @Id                                         # id属性
        @GeneratedValue(strategy=GenerationType.AUTO)                           # 自增属性
        @Column(nullable = false, unique = true)
组件
    注解
        @Component
        @ConfigurationProperties(prefix = &quot;my&quot;)     # 注入properties对应名称的属性
dao
    注解
        @Repository                                 # 修饰类
service
    注解
        @Service                                    # 修饰类
        @PostConstruct                              # 修饰方法, 加载servlet时, init()前执行
        @PreDestroy                                 # 修饰方法, 销毁servlet时, destroy()后执行
controller
    注解
        @Controller                                 # 修饰类
</code></pre>
<h3 id="测试">
  测试
  <a class="anchor" href="#%e6%b5%8b%e8%af%95">#</a>
</h3>
<pre><code>pom.xml
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
注解
    @Before
    @Test
    @RunWith(SpringRunner.class)                # 修饰类, 测试spring
    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)                 # 修饰类, 测试spring boot
    @LocalServerPort                            # 注入端口号
    @AutoConfigureMockMvc                       # 使用mockMvc, 用@Autowired注入MockMvc
    @WebAppConfiguration                                # 模拟ServletContext
XxxApplicationTests.java                        # junit测试
    @RunWith(SpringJUnit4ClassRunner.class)
    @SpringApplicationConfiguration(classes = XxxApplication.class)
    @WebAppConfiguration
    public class XxxApplicationTests {
        private MockMvc mvc;
        @Before
        public void setUp() throws Exception {
            mvc = MockMvcBuilders.standaloneSetup(new XxxController()).build();
        }
        @Test
        public void hello() throws Exception {
            mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))
                .addExpect(status().isOk())
                .addExpect(content().string(equalTo(&quot;hello&quot;)));
        }
    }
</code></pre>
<h3 id="数据库">
  数据库
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93">#</a>
</h3>
<pre><code>pom.xml
    spring-boot-starter-jdbc
    spring-boot-starter-data-jpa                            # spring data JPA
application.yml
    jpa:
        generate-ddl: false
        show-sql: true
        hibernate:
            ddl-auto: none                          # create时, 第一次create之后update
    datasource:
        platform: h2
        schema: classpath:schema.sql                # 建表
        data: classpath:data.sql                    # 数据
注解
    @Transactional                                  # 修饰方法，开启事务，或在事务中
</code></pre>
<h4 id="mybatis">
  mybatis
  <a class="anchor" href="#mybatis">#</a>
</h4>
<pre><code>pom.xml
    &lt;!-- mybatis --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- mysql --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.21&lt;/version&gt;
    &lt;/dependency&gt;
application.yml
    spring:
        datasource:
            url: jdbc:mysql://127.0.0.1:3306/outrun?characterEncoding=UTF-8
            username: root
            password: asdf
            driver-class-name: com.mysql.jdbc.Driver
        jpa:
        hibernate:
            ddl-auto: update  # 新建连接必要
    mybatis:
        mapper-locations: classpath:mapper/*.xml        # 指定mapper.xml位置


mapper.xml                      # 用mbg生成
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
    &lt;mapper namespace=&quot;com.outrun.erp.mapper.UserMapper&quot;&gt;

        &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.outrun.erp.entities.User&quot;&gt;
            &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;
            &lt;result column=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;name&quot; /&gt;
        &lt;/resultMap&gt;

        &lt;select id=&quot;selectUserById&quot; parameterType=&quot;long&quot; resultMap=&quot;UserMap&quot;&gt;
            SELECT name FROM user WHERE id=#{userId}
        &lt;/select&gt;

        &lt;insert id=&quot;inserUser&quot;&gt;
            &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;
                select field1 from seq1
            &lt;/selectKey&gt;
        &lt;/insert&gt;

        &lt;sql id=&quot;userColumns&quot;&gt;
            ${alias}.id, ${alias}.username
        &lt;/sql&gt;
        &lt;select id=&quot;selectColumns&quot; resultType=&quot;map&quot;&gt;
            select
                &lt;include refid=&quot;userColumns&quot;&gt;&lt;property name=&quot;alias&quot; value=&quot;tb1&quot;/&gt;&lt;/include&gt;
            from tb1
        &lt;/select&gt;

        &lt;select id=&quot;dynamicSql&quot; resultType=&quot;User&quot;&gt;
            select * from user
            where state = 0
            &lt;if test=&quot;title != null&quot;&gt;
                and title like #{title}
            &lt;/if&gt;

            &lt;choose&gt;
                &lt;when test=&quot;title != null&quot;&gt;
                    and title like #{title}
                &lt;/when&gt;
                &lt;when test=&quot;author != null and author.name != null&quot;&gt;
                    and author_name like ${author.name}
                &lt;/when&gt;
                &lt;otherwise&gt;
                    and featured = 1
                &lt;/otherwise&gt;
            &lt;/choose&gt;

            &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
                #{item}
            &lt;/foreach&gt;

            &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&gt;
                ...
            &lt;/trim&gt;

            &lt;bind name=&quot;a&quot; value=&quot;'%' + _data.getTitle() + '%'&quot; /&gt;
            select * from blog
            where title like #{a}
        &lt;/select&gt;

        &lt;update&gt;
            update User
                &lt;set&gt;
                    &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;
                &lt;/set&gt;
        &lt;/update&gt;

        &lt;cache&gt;                 # 该命名空间缓存
        &lt;cache-ref&gt;             # 引用其它命名空间缓存
        &lt;delete&gt;
        &lt;resultMap&gt;
            &lt;constructor&gt;       # 构造方法
                &lt;idArg&gt;         # id参数, 标记id帮助提高性能
                &lt;arg&gt;           # 普通参数
            &lt;/constructor&gt;
            &lt;id&gt;                # 标记id帮助提高性能
            &lt;result&gt;            # 普通字段
            &lt;association&gt;       # 关联
            &lt;collection&gt;        # 结构体
            &lt;discriminator&gt;     # 自动映射
        &lt;/resultMap&gt;
    &lt;/mapper&gt;
mapper/UserMapper
    @Mapper           # 如果扫描mapper.xml，不用加@Mapper
    public interface UserMapper {
        List&lt;User&gt; selectUserById(@Param(&quot;userId&quot;) long userId)

        @Select(&quot;select * from user&quot;)
        List&lt;User&gt; findAll();
    }
entities/User
    public class User {
        private Integer id;
        private String name;
        ...getter, setter...
    }
注解
    @Table(name = &quot;user&quot;)                   # 修饰类，指定表
    @Id                                     # 修饰属性, 指定主键
    @Column(name = &quot;name&quot;)                  # 修饰属性, 指定字段

    @Mapper                                 # 修饰类
    @Select(&quot;select * from user&quot;)           # 修饰方法
    @Param(&quot;userId&quot;)                        # 修饰参数
api
    SqlSessionFactory
        build
        openSession                         # 重载事务方法
    SqlSesion
        selectOne()
        selectList()
        selectMap()
        insert()
        update()
        delete()
        commit()
        rollback()
        clearCache()
        close()
    Mapper
        o-&gt;
        @Insert(&quot;insert into tb1(id, name) values(#{id}, #{name})&quot;)
        @SelectKey(statement=&quot;next value&quot;, keyProperty=&quot;id&quot;, before=true, resultType=int.class)
        int insertTable1(String name)
    SQL
        INSERT_INTO()
        VALUES()

        o-&gt;
        new SQL(){{
            SELECT(&quot;a.name&quot;);
            SELECT(&quot;a.age&quot;);
            FROM(&quot;tb1 a&quot;);
            WHERE(&quot;a.name like ?&quot;);
        }}.toString()
    LogFactory
        useSlf4jLogging()
        useLog4jLogging()
        useStdOutLogging()
</code></pre>
<h3 id="web">
  web
  <a class="anchor" href="#web">#</a>
</h3>
<pre><code># 用的spring mvc
pom.xml
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 # web模块, 有tomcat, spring mvc
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            # 测试模块, 有JUnit, Hamcrest, Mockito
    &lt;/dependency&gt;
application.yml
    server
        port: 8080                                      # 默认8080
        servlet
            context-path: /hello                        # uri前缀
静态资源
    默认映射public, resources, static到/
注解
    控制器
        @RestController                             # 修饰类, 组合@Controller与@responseBody
        @RequestMapping(&quot;/index&quot;)                   # 修改类或方法, url
            @GetMapping(&quot;/{id}&quot;)                    # 相当于@RequestMapping(method=RequestMethod.GET)
            @PostMapping
            @PutMapping
            @DeleteMapping
            @PatchMapping
        @CrossOrigin                                # 修饰方法, 允许跨域
        @RequestBody                                # 修饰方法, 解析body到参数
        @PathVariable Long id                       # 修饰参数, 接收url参数
内置对象
    ServerProperties                                # 单例可@Autowired, 存端口之类属性
自实现
    XxxController.java
        @RestController
        public class HelloController {
            @RequestMapping(&quot;/hello&quot;)
            public String index() {
                return &quot;hello&quot;;
            }
        }
</code></pre>
<h3 id="日志">
  日志
  <a class="anchor" href="#%e6%97%a5%e5%bf%97">#</a>
</h3>
<pre><code>application.yml
    logging:
        level:
            root: INFO
            org.hibernate: INFO
            org.hibernate.type.descriptor.sql.BasicBinder: TRACE
            org.hibernate.type.descriptor.sql.BasicExtractor: TRACE
注解
    @Slf4j                                      # 修饰类，其中可直接用log变量
    @EnableSwagger2                             # 修饰类
    @Api(tags = &quot;&quot;)                             # 修饰类, 文档
    @ApiModel(&quot;&quot;)                               # 修饰类
    @ApiModelProperty(&quot;)                        # 修饰属性
    @ApiOperation(value=&quot;&quot;, notes=&quot;&quot;)           # 修改方法, 文档
    @ApiIgnore                                  # 修饰方法, 文档忽略
</code></pre>
<h3 id="jackson">
  jackson
  <a class="anchor" href="#jackson">#</a>
</h3>
<pre><code>注解
    @JsonInclude                                # 修饰类, 序列化时包含
        @JsonInclude(JsonInclude.Include.NON_EMPTY)                 # null或&quot;&quot;时不序列化
    @JsonIgnore                                 # 修饰属性
</code></pre>
<h3 id="scheduled">
  Scheduled
  <a class="anchor" href="#scheduled">#</a>
</h3>
<pre><code>scheduled
    注解
        @Scheduled                                  # 修饰方法, 定时调度
            @Scheduled(initialDelay = 1000, fixedRate = 1000)
    类
        @Configuration
        implements SchedulingConfigurer             # 配置类
            configureTasks(ScheduledTaskRegistrar)
                registrar.setScheduler(Executors.newScheduledThreadPool(2));    # worker池
async
    注解
        @Async                                      # 修饰方法, 异步调用 
    类
        implements AsyncUncaughtExceptionHandler    # 处理@Async异常
            @Override
            public void handleUncaughtException()

        @Configuration
        @EnableAsync
        implements AsyncConfigurer
            @Bean
            @Override
            public Executor getAsyncExecutor()

            @Override
            public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler()             # 处理无返回值＠Async方法异常
                return handler
    使用
    @Async
    Future&lt;String&gt; fetch(){
        return new AsyncResult&lt;String&gt;(&quot;&quot;)
    }
    future = fetch()
    try{
        future.get()
    }
</code></pre>
<h3 id="热部署">
  热部署
  <a class="anchor" href="#%e7%83%ad%e9%83%a8%e7%bd%b2">#</a>
</h3>
<pre><code>pom.xml
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;                                       # 热部署
    &lt;/dependency&gt;
application.yml
    spring:
        devtools:
        restart:
            enabled: true
            additional-paths: src/main/java
</code></pre>
<h3 id="jsp">
  jsp
  <a class="anchor" href="#jsp">#</a>
</h3>
<pre><code>pom.xml
    &lt;!-- servlet依赖. --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!-- tomcat的支持.--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
application.yml
    spring:
        mvc:
        view:
            prefix: /WEB-INF/views/
            suffix: .jsp
controller类
    @Controller
    public class XxxController {
        @RequestMapping(&quot;/xxx&quot;)
        public String xxx(Model m) {
            m.addAttribute(&quot;a&quot;, 1);
            return &quot;view1&quot;;
        }
    }
src/main/webapp/WEB-INF/views/view1.jsp
    &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;
    jsp ${a}
</code></pre>
<h3 id="lombok">
  lombok
  <a class="anchor" href="#lombok">#</a>
</h3>
<pre><code>注解
    @Builder                            # 修饰类, 可build方式设置属性
    @Getter                             # 修饰类, 生成getter
    @Setter                             # 修饰类, 生成setter
    @ToString                           # 修饰类, 生成toString方法
    @Data                               # 修饰类, 注入getter, setter, toString
    @NoArgsConstructor                  # 修饰类, 生成无参构造方法
    @AllArgsContructor                  # 修饰类, 生成带所有参数的构造方法
    @RequiredArgsConstructor            # 修饰类, 生成带常量、@NotNull修饰变量参数的构造方法
        @RequiredArgsConstructor(onConstructor_ = @Autowired)               # 构造类时，自动对private final 属性@Autowire
</code></pre>
<h3 id="remote-shell">
  remote shell
  <a class="anchor" href="#remote-shell">#</a>
</h3>
<pre><code>pom.xml
    spring-boot-starter-remote-shell
</code></pre>
<h3 id="actuator">
  actuator
  <a class="anchor" href="#actuator">#</a>
</h3>
<pre><code>pom.xml
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
原生端点
    应用配置类
        /autoconfig                                 # 自动化配置详情
            positiveMatches	                        # 成功
            negativeMatches
        /beans                                      # 所有bean
        /configprops                                # 属性
        /env                                        # 环境属性
        /mappings                                   # spring mvc映射关系
        /info                                       # 自定义信息，默认为空，用info前缀定义
    度量指标
        /metrics                                    # 程序信息，内存、线程、gc等
            nonheap.*                               # 非堆内存
            gauge.*                                 # http请求性能，如gauge.response表示上次延迟
            counter.*                               # 记录累计，如counter.status.200表示返回200的次数
        /metrics/{name}                             # 查看某项
            /metrics/mem.free
        /health                                     # 启动状态，磁盘空间
            DiskSpaceHealthIndicator                # 低磁盘空间
            DataSourceHealthIndicator               # DataSource连接是否可用
            MongoHealthIndicator
            RabbitHealthIndicator
            RedisHealthIndicator
            SolrHealthIndicator
        /dump                                       # 线程信息
        /trace                                      # 跟踪信息
    操作控制                                         # 用属性配置开启
        /shutdown                                   # 关闭端点
            通过endpoints.shutdown.enabled=true开启
自定义counter统计
    @Autowired
    private CounterService counterService;
    counterService.increment(&quot;didispace.hello.count&quot;)
自定义health检测器
    @Component
    public class RocketMQHealthIndicator implements HealthIndicator {
        private int check(){}
        @Override
        public Health health() {
            int errorCode = check();
            if (errorCode !=0) {
                return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();
                return Health.up().build();
            }
        }
    }
</code></pre>
<h3 id="spring-boot-admin">
  spring boot admin
  <a class="anchor" href="#spring-boot-admin">#</a>
</h3>
<pre><code>application.yml
    spring:
        application:
            name: erp-admin-server
        boot:
            admin:
                routes:
                    endpoints: env,metrics,dump,jolokia,info,configprops,trace,logfile,refresh,flyway,liquibase,heapdump,loggers,auditevents,hystrix.stream
    endpoints:
        health:
            sensitive: false
            enabled: true
        actuator:
            enabled: true
            sensitive: false
        beans:
            sensitive: false
            enabled: true
</code></pre>
<h3 id="spring-initializer">
  spring initializer
  <a class="anchor" href="#spring-initializer">#</a>
</h3>
<pre><code>介绍
    生成spring基础项目
</code></pre>
<h3 id="spring-security">
  spring security
  <a class="anchor" href="#spring-security">#</a>
</h3>
<pre><code>配置
    application.yml
        security:   
            basic:
                enabled: false                          # 禁用security
注解
    @EnableWebSecurity                                  # 修饰WebSecurityConfigurerAdapter, 开启web验证
    @EnableGlobalMethodSecurity(prePostEnabled = true)  # 修饰WebSecurityConfigurerAdapter, 开启方法验证
    @PreAuthorize                                       # 修饰controller方法
api
    Subject                                             # 主体数据结构, 如用户
    SecurityManager                                     # 安全管理器, 管理所有subject
    UserDetails
        getAuthorities()
        getUsername()
        getPassword()
        isAccountNonExpired()
        isAccountNonLocked()
        isCredentialsNonExpired()
        isEnabled()
    GrantedAuthority
        getAuthority()
    WebSecurityConfigurerAdapter
        configure(HttpSecurity)                         # 验证请求
        configure(AuthenticationManagerBuilder)         # 验证数据，需要授权服务配置AuthenticationManager
            userDetailService
            passwordEncoder
        authenticationManagerBean()                     # 指定管理bean
</code></pre>
<h3 id="spring-security-oauth2">
  spring security oauth2
  <a class="anchor" href="#spring-security-oauth2">#</a>
</h3>
<pre><code>pom.xml
    spring-cloud-starter-oauth2
结构    
    OAuth2 Provider
        Authorization Service                           # 授权服务
        Resource Service                                # 资源服务
        Spring Security过滤器
            /oauth/authorize                            # 授权
            /oauth/token                                # 获取token
授权服务
    applicatoin.yml                                     # server
        security:   
            oauth2:
                resource:
                    filter-order: 3
    注解
        @EnableAuthorizationServer                      # 修饰AuthorizationServerConfigurerAdapter, 开启授权服务
    api
        AuthorizationServerConfigurerAdapter            # 授权服务配置
            configure(ClientDetailsServiceConfigurer)                           # 客户端信息
                clientId
                secret
                scope
                authorizedGrantTypes                    # password, refresh_token, client_credentials
                authorities                             # 具体权限
            configure(AuthorizationServerEndpointsConfigurer)                   # 使用token的服务
                authenticationManager                   # 密码认证
                    authenticate(Authentication)
                userDetailService                       # 获取用户数据
                    loadUserByUsername(String)
                authorizationCodeServices               # 验证码
                implicitGrantService
                tokenGranter
                tokenStore
                    InMemoryTokenStore
                    JdbcTokenStore
                    JwtTokenStore
            configure(AuthorizationServerSecurityConfigurer)                    # 使用token服务的安全策略, 授权服务与资源服务分离时配置
    接口
        Principal /users/current
    测试
        insert into user(username, password) values('outrun', '$2a$10$l7.7AJEHtXukwUZiKAyVSO6lHJOyHhPxHvi7MHawe8SjlOKkCVbAe')
        curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf
        浏览器
            url: localhost:9016/uaa/oauth/token
            header
                'Authorization': 'Basic ' + base64('erp-auth-resource:asdf')
            data
                username: 'outrun'
                password: '123456'
                grant_type: 'password'
资源服务
    application.yml                                     # client
        security:
            oauth2:
                resource:
                    user-info-uri: http://localhost:9016/uaa/users/current
                client:
                    clientId: erp-auth-resource
                    clientSecret: asdf
                    accessTokenUri: http://localhost:9016/uaa/oauth/token
                    grant-type: client_credentials,password
                    scope: server
    注解
        @EnableResourceServer                           # 修饰ResourceServerConfigurerAdapter, 开启资源服务
                                                        # 修饰AuthorizationServerConfigurerAdapter, 因为授权服务提供token获取和验证接口
        @PreAuthorize(&quot;hasAuthority('ROLE_ADMIN'))      # 修饰controller方法，验证权限
    api
        ResourceServerConfigurerAdapter                 # 资源服务配置
            configure(HttpSecurity)
                authorizeRequests                       # 请求放行
    测试
        curl -d &quot;username=outrun&amp;password=asdf&quot; &quot;localhost:9017/user/registry&quot;
        insert into role values(1, 'ROLE_USER'), (2, 'ROLE_ADMIN')
        insert into 'user_role' values(user_id, 2)
        curl erp-auth-resource:asdf@localhost:9016/uaa/oauth/token -d grant_type=password -d username=outrun -d password=asdf
        curl -l -H &quot;Authorization:Bearer 7df6669c-0c86-417b-827f-9a58297f57e5&quot; -X GET &quot;localhost:9017/hello&quot;
客户端
    注解
        @EnableOAuth2Client                             # 修饰[Oauth2ClientConfig], 客户端
    api
        [Oauth2ClientConfig]                            # 客户端配置, 自定义类，名称任意
            ClientCredentialsResourceDetails            # bean, 资源信息
            RequestInterceptor                          # bean, 保存请求上下文
            OAuth2RestTemplate                          # bean, 用于向授权服务发送请求
表
    clientdetails
    oauth_access_token
    oauth_approvals
    oauth_client_details
    oauth_client_token
    oauth_code
    oauth_refresh_token
</code></pre>
<h1 id="spring-integration">
  spring integration
  <a class="anchor" href="#spring-integration">#</a>
</h1>
<pre><code># 服务编排
</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/commit/e291a00972b570fc85fd45722f3a423fe96dd780" title='Last modified by outrunJ | Sep 22, 2021' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>Sep 22, 2021</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/tree/master/content/content/docs/pl/java/spring.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a></li>
    <li><a href="#使用">使用</a></li>
    <li><a href="#api">api</a></li>
    <li><a href="#注解">注解</a></li>
    <li><a href="#模块">模块</a>
      <ul>
        <li><a href="#监听器">监听器</a></li>
        <li><a href="#properties">properties</a></li>
        <li><a href="#bean">bean</a></li>
        <li><a href="#aop">aop</a></li>
        <li><a href="#dao">dao</a></li>
        <li><a href="#事务">事务</a></li>
        <li><a href="#spring-mybatis">spring mybatis</a></li>
        <li><a href="#spring-struts2">spring struts2</a></li>
        <li><a href="#spring-mvc">spring mvc</a></li>
        <li><a href="#quartz定时器">quartz:定时器</a></li>
        <li><a href="#远程调用">远程调用</a></li>
        <li><a href="#websocket">websocket</a></li>
      </ul>
    </li>
    <li><a href="#spring-boot">spring boot</a>
      <ul>
        <li><a href="#基础文件">基础文件</a></li>
        <li><a href="#配置">配置</a></li>
        <li><a href="#注解-1">注解</a></li>
        <li><a href="#类">类</a></li>
        <li><a href="#插件">插件</a>
          <ul>
            <li><a href="#maven">maven</a></li>
          </ul>
        </li>
        <li><a href="#组件">组件</a></li>
        <li><a href="#子域">子域</a>
          <ul>
            <li><a href="#namedcontextfactory">NamedContextFactory</a></li>
            <li><a href="#spring">spring</a></li>
            <li><a href="#测试">测试</a></li>
            <li><a href="#数据库">数据库</a></li>
            <li><a href="#web">web</a></li>
            <li><a href="#日志">日志</a></li>
            <li><a href="#jackson">jackson</a></li>
            <li><a href="#scheduled">Scheduled</a></li>
            <li><a href="#热部署">热部署</a></li>
            <li><a href="#jsp">jsp</a></li>
            <li><a href="#lombok">lombok</a></li>
            <li><a href="#remote-shell">remote shell</a></li>
            <li><a href="#actuator">actuator</a></li>
            <li><a href="#spring-boot-admin">spring boot admin</a></li>
            <li><a href="#spring-initializer">spring initializer</a></li>
            <li><a href="#spring-security">spring security</a></li>
            <li><a href="#spring-security-oauth2">spring security oauth2</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#spring-integration">spring integration</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












