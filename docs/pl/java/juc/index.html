<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  基础
  #

并发编程三大特性
    可见性(visibility)
        synchronized会刷新线程栈
    有序性(ordering)
    原子性(atomicity)


  CPU
  #

PC寄存器(Program Counter Register, 存下一指令)
优化
    乱序读
    合并写
    乱序执行(流水线)
ALU
    访问速度
        Registers: &lt; 1ns
        L1 cache(核内): 1ns
        WC(Writer Comblining) Buffer    # 合并写, 一般4个字节
        L2 cache(核内): 3ns
        L3 cache(CPU内): 15ns
        memory: 80ns
局部性原理
    空间
        按块读取(cache line)
            一次读64Bytes               # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知
            Java1.8注解@Contended       # 保证不在同一行，需要JVM参数-XX:-RestrictContended
    时间
        批量读指令
内存屏障                        # 不同CPU不一样
    Intel
        sfence                      # save, 之前写操作必须完成
        lfence                      # load, 之前读操作必须完成
        mfence                      # mix(save &#43; load)
lock指令                            # 指令执行完之前，锁内存
    lock_add


  CPU缓存一致性协议
  #

# 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁
状态
    MESI Cache一致性协议                    # Intel CPU，实现方式为主动监听
        Modified                            # 一行数据在CPU Modified, 其它CPU为Invalid
        Exclusive                           # 独享，其它CPU没有
        Shared                              # 别人也在读
        Invalid                             # 别人改过了
    MSI
    MOSI
缓存行                                      # 多数64字节
    伪共享                                  # 缓存行内无关数据也要同步


  OS
  #

进程
    # 资源分配
线程
    # 调度执行
    切换(Context Switch)
        CPU导出原线程指令和data到cache, 再导入新线程数据
    线程数
        N(threads) = N(CPU) * U(CPU) * (1 &#43; W/C)
            # N(CPU): CPU数
            # U(CPU): 期望CPU利用率, 0到1
            # W/C: wait时间/compute时间, (1&#43;W/C)即运行时间/计算时间。用profiler、arthas分析
        压测决定
CPU性能压榨
    单进程
    批处理
    多进程切换
    多线程进程内切换
        I/O复用
    协程(纤程、绿色线程)用户空间切换


  JVM
  #


  内存屏障
  #

LoadLoad
StoreStore
LoadStore
StoreLoad


  乱序执行(指令重排序)
  #

为什么
    CPU快, 指令1阻塞时，指令2先执行
判断
    代码不影响单线程最终一致性
例子，多线程

        static int x = 0, y = 0;
        static int a = 0, b = 0;
        void main(){
            for (long i = 0; i &lt; Long.MAX_VALUE; i&#43;&#43;&gt;) {
                x=0;
                y=0;
                a=0;
                b=0;
                CountDownLatch latch = new CountDownLatch(2);

                Thread one = new Thread(() -&gt; {
                    public void run() {
                        a = 1;
                        x = b;
                        latch.countDown();
                    }
                });
                
                Thread other = new Thread(() -&gt; {
                    public void run() {
                        b = 1;
                        y = a;
                        latch.countDown();
                    }
                });
                one.start();
                other.start();
                latch.await();
                if (x == 0 &amp;&amp; y == 0) {
                    break;
                }

            }
        }
例子，类初始化指令换顺序

        class T {
            int m = 8;
        }
        T t = new T();
        汇编码
            0 new #2 &lt;T&gt;
                # 变量半初始化状态为0
            3 dup
            4 invokespecial #3 &lt;T.&lt;init&gt;&gt;
            7 astore_1
                # 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0。线程访问时中间状态逸出
            8 return
        class C {
            private int num = 0;
            public C() {
                new Thread(() -&gt; System.out.println(this.num)).start();
            }
            void main() {
                new C();
                System.in.read();
            }
        }

  Unsafe类
  #

# 相当于指针。1.8只能根部类用, 11可以直接用
操作内存
    allocateMemory
    putXX
    freeMemory
    pageSize
生成类实例
    allocateInstance
操作类或实例
    objectFieldOffset
    getInt
    getObject
CAS
    compareAndSwapObject()          # JDK1.8
    compareAndSetObject()
    weakCompareAndSetObject()       # JDK11


  修饰符与锁
  #


  概念
  #

锁细化                              # 少代码加轻量锁
锁粗化                              # 锁太多时，如行锁变表锁


  synchronized
  #

实现方式
    JVM没要求实现方式
    早期都是OS调度
    HotSpot
        在对象头(64位)上用2位实现，组合成锁的类型
        锁升级                      # 不比原子类慢，升完不降
            偏向锁, 第一个线程第一次访问只记线程id
            自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平
            重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景
原子性、可见性
可重入                              # 同一个对象同线程可重入
加锁对象
    方法锁和对象锁锁this
    static方法锁和类锁锁class类
    继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象
使用注意
    抛异常立即释放锁，但被锁数据已更新
    不能用的对象
        String常量，可能未知地方锁同一个
        Integer、Long等基本类型, 值变化会生成新对象
    synchronized的属性加final防止赋值


  volatile
  #

# 用synchronized性能差不多，volatile一般不用
作用
    # 没有原子性，可能写同一值
    变量在线程见可见性
        依靠CPU缓存一致性协议
    禁止指令重排序                  # 用JVM的读写屏障
        
修饰引用类型，内部属性不监控

DCL(Double Check Lock)单例volatile问题

        private static volatile C c;    // 禁止了创建c指令重排序
        private C(){}
        public static C getInstance() {
            if (c == null) {
                synchronized (C.class) {
                    if (c == null) {
                        // 申请内存(半初始化状态默认0)，成员变量初始化，赋值
                        // 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象
                        c = new C();    
                    }
                }
            }
            return c;
        }

  CAS
  #

# Compare And Set/Swap, 无锁优化, 乐观锁, 自旋
# Unsafe类支持
CPU原语
    cas(V, Expected, NewValue)
        if V == E                   # 无并发值判断问题，原语上加了屏障
        V = New
        else try again or fail
Java
    AtomicInteger
        incrementAndGet()
ABA问题
    # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据
    版本号                          # Java版本号类AtomicStampedReference
LongAdder
    LongAdder每次加数字, LongAccumulator用lambda
    分段锁(CAS)。值分开放数组里, 多线程对应一个item
性能测试
    LongAdder(713) &gt; Atomic(2166) &gt; Synchronized(3129)


  锁
  #


  AQS
  #

# AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种
# 实现方式: CAS，volatile, 模板方法
类图
    AbstractQueueSynchronizer
        Sync
            NonfairSync
方法
    AbstractQueueSynchronizer
        # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待)
        Node
            volatile Node prev
            volatile Node next
            volatile Thread thread
        VarHandle
            # JDK1.9，保存引用，普通属性原子操作。
            # 相比反射，直接操作二进制码
            get()
            set()
            compareAndSet()         # 原子性
            getAndAdd()             # 原子性
            class C {
                int x = 0;
                private static VarHandle handle;
                static {
                    handle = MethodHandles.lookup().findVarHandle(C.class, &quot;x&quot;, int.class)
                    handle.compareAndSet(c, 0, 1);

                }
            }
        volatile state              # 多态实现
        acquire()
        tryAcquire()                # 模板方法
        acquireQueued()             # 获得
        addWaiter(Node.EXCLUSIVE)   # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表)
        cancelAcquire()             # status CANCELLED, tail时设置null, 非tail时unpark下一节点
    NonfairSync
        nonfairTryAcquire()


  ReentrantLock
  #

    # 可重入锁，CAS实现, state记重入多少次
    new ReentrantLock(true)         # 公平锁
    tryLock(long, TimeUnit)
    lockInterruptibly()             # 响应interrupt()标记
    newCondition()                  # 多一个等待队列

    源码
        调NonfairSync


  CountDownLatch
  #

    # 比join()灵活
    new CountDownLatch(4)
    countDown()
    await()


  CyclicBarrier
  #

    # 满了一起放行, 场景如I/O批量消费
    new CyclicBarrier(4, ()-&gt;{})
    await()


  Phaser
  #

    # 阶段批量执行过滤
    class MyPhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch(phase) {
                case 0:
                    print(&quot;arrived&quot; &#43; registeredParties);
                    return false;
                case 1:
                    print(&quot;eated&quot; &#43; registeredParties);
                    return false;
                case 2:
                    print(&quot;hugged&quot; &#43; registeredParties);
                    return true;
                default:
                    return true;
            }
        }
    }
    Person implements Runnable {
        private int i;
        public Person(int i) {
            this.i = i;
        }
        public void arrive() {
            phaser.arriveAndAwaitAdvance();
        }
        public void eat() {
            phaser.arriveAndAwaitAdvance();
        }
        public void hug() {
            if (i == 0 || i == 1) {
                phaser.arriveAndAwaitAdvance();
            } else {
                phaser.arriveAndDeregister();
            }
        }

        @Override
        public void run() {
            arrive();
            eat();
            hug();
        }
    }
    phaser = new MyPhaser();
    phaser.bulkRegister(5);
    for (int i = 0; i &lt; 5; i&#43;&#43;) {
        new Thread(new Person(i)).start()
    }


  ReadWriteLock
  #

    # 读锁是共享锁，不能写，悲观锁
    # 写锁是排他锁，不能读写
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    void read(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    void write(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    for (int i =0; i&lt;10;i&#43;&#43;) {
        new Thread(()-&gt;read(readLock)).start();
    }
    for (int i =0; i&lt;2; i&#43;&#43;) {
        new Thread(()-&gt;write(writeLock)).start();
    }


  StampedLock
  #

    # 读时允许写，读完判断不一致再读一遍，乐观锁


  Semaphore
  #

    # 信号量, 限流同时运行, 用于线程间同步。可设置公平
    Semaphore s = new Semaphore(1, true)
    new Thread(() -&gt; {
        s.acquire();
        s.release()
    })


  Exchanger
  #

    # 线程间通信, 阻塞交换
    exchange()


  LockSupport
  #

    # 线程间通信，非锁阻塞，指定线程唤醒
    # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1)
    Thread t = new Thread(() -&gt; {
        for (int i = 0; i &lt; 10; i&#43;&#43;) {
            if (i == 5) {
                LockSupport.park();
            }
        }
    })
    t.start();
    TimeUnit.SECONDS.sleep(1);
    LockSupport.unpark(t);


  线程及线程池
  #


  使用注意
  #

为什么不用Executors线程池
    用LinkedBlockingQueue超数量OOM
    拒绝策略
    线程命名


  类
  #

    Object
        wait()                              # 释放synchronized锁并加入等待队列，唤醒后执行需要得到synchronized锁
        notify()                            # 只唤醒，不释放当前synchronized锁
    Thread
        static currentThread()
        static sleep()
        static yield()                      # 让出CPU, 进Ready队列
        start()
        getState()
        join()                              # 等待结束
        setDaemon()                         # 是否后台
        setPriority(Thread.NORM_PRIORITY)   # 优先级，没有用


    interface Runnable
        void run()
    interface Callable
        V call() throws Exception
    interface Future
        get()
        get(long, TimeUnit)
        cancel(boolean)
        isCanceled()
        isDone()
        interface RunnableFuture
            class FutureTask
        interface CompletableFuture         # parallel
            static CompletableFuture&lt;U&gt; supplyAsync()
            static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;U&gt;...)
            static CompletableFuture&lt;Void&gt; anyOf(CompletableFuture&lt;U&gt;...)
            T join()
            CompletableFuture&lt;U&gt; thenApply()
            CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;T&gt;)

    interface ThreadFactory
        Thread newThread(Runnable)
        class DefaultThreadFactory
    interface Executor
        void execute()
        interface ExecutorService
            shutdown()
            shutdownNow()
            isShutdown()
            isTerminated()
            awaitTermination(long, TimeUnit)
            Future submit(Callable&lt;T&gt;)
            Future submit(Runnable, T)                     # 手动设个result
            submit(Runnable)
            invokeAll(Collection&lt;Callable&lt;T&gt;&gt;)
            invokeAll(Collection&lt;Callable&lt;T&gt;&gt;, long, TimeUnit)
            invokeAny(Collection&lt;Callable&lt;T&gt;&gt;)
            invokeAny(Collection&lt;Callable&lt;T&gt;&gt;, long, TimeUnit)
            abstract AbstractExecutorService
                RunnableFuture&lt;T&gt; newTaskFor(Runnable, T)
                RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt;)
                T doInvokeAny(Collection&lt;Callable&lt;T&gt;&gt;, boolean timed, long)
                submit()
                invokeAll(Collection&lt;Callable&lt;T&gt;&gt;)
                    # 忽略CancellationException, ExecutionException，其它异常抛出并取消未完成任务
                invokeAll(Collection&lt;Callable&lt;T&gt;&gt;, long, TimeUnit)
                    # 忽略CancellationException, ExecutionException, TimeoutException，其它异常抛出并取消未完成任务
                invokeAny(Collection&lt;Callable&lt;T&gt;&gt;)
                invokeAny(Collection&lt;Callable&lt;T&gt;&gt;, long, TimeUnit)
                class ThreadPoolExecutor                    # 线程池&#43;任务队列
                    # 任务顺序: 核心线程, 任务队列，起新线程，拒绝策略
                    class ScheduledThreadPoolExecutor       # 用DelayedWorkQueue
                        scheduleAtFixedRate(()-&gt;{}, int initial, int period, TimeUnit)
                class ForkJoinPool
                    execute(ForkJoinTask)
            interface ScheduledExecutorService
                    [class ScheduledThreadPoolExecutor]
    interface CompletionService                             # 不阻塞全部任务，已有结果入队列
        poll()
        class ExecutorCompletionService


    static class Executors
        newSingleThreadExecutor()                           # 为了用任务队列和生命周期管理
        newCachedThreadPool()                               # 超时60s, max为MAX_VALUE, 任务不堆积场景
        newFixedThreadPool()
        newScheduledThreadPool()                            # AbstractQueuedSynchronizer
        newWorkStealingPool()                               # ForkJoinPool, go的M,G,P
            # 每个线程单独队列, 尾部偷加尾部

  创建线程
  #

# 继承
class MyThread extendws Thread {
    @Override
    public void run(){}
}
new MyThread().start();

# 组合
class MyRun implements Runnable {
    @Override
    public void run(){}
}
new Thread(new MyRun()).start();

# 返回值
class myCall implements Callable&lt;String&gt; {
    @Override
    public String call(){}
}
FutureTask = ft = new FutureTask&lt;String&gt;(new MyCall())
new Thread(ft).start();
ft.get();

# 线程池
// execute无返回值
ExecutorService service = Executors.newCachedThreadPool()
service.execute(()-&gt;{});
// submit有返回值 
Future&lt;String&gt; f = service.submit(new MyCall());
service.shutdown();


  线程状态
  #

NEW
RUNNABLE            # 可调度
    READY
    RUNNING
WAITING             # 等待唤醒，忙等待(一直占CPU)
    o.wait()
    t.join()
    LockSupport.park()
    Lock.lock()

    o.notify()
    o.notifyAll()
    LockSupport.unpark()
    Lock.unlock()
TIMED WAITING
    Thread.sleep(time)
    o.wait(time)
    t.join(time)
    LockSupport.parkNanos()
    LockSupport.parkUntil()
BLOCKING            # 阻塞等待（不占CPU但经过OS调度)
    synchronized
TERMINATED


  线程打断
  #

方法 
    interrupt()                 # 设置打断标记位
    isInterrupted()             # 检查标记位
    static interrupted()        # 检查当前线程标记位，并重置
检测当前线程打断标记的方法      # 抛异常并重置
    Thread.sleep()
    o.wait();
    o.join();
    ReentrantLock
        lockInterruptibly()
不检测当前线程打断标记的方法
    synchronized                # 不是代码实现检测不了
    ReentrantLock
        lock()
强制打断
    Thread
        stop()                  # 已废弃, 立即释放所有锁
        suspend()               # 已废弃，强制暂停，所有锁不释放容易死锁
        resume()                # 已废弃，强制恢复
volatile
    判断数字不准，有同步的时间延迟, interrupt()也有延迟
    也需要代码中判断, 但interrupt()有wait()等系统方法支持


  线程间通信
  #


  通知
  #

# synchronized wait() notify(), CountDownLatch, LockSupport
volatile List c = new ArrayList();
final Object lock = new Object();
new Thread(() -&gt; {
    synchronized(lock) {
        if (c.size() != 5) {
            lock.wait();
        }
        lock.notify();              // 唤醒t1
    }
}, &quot;t2&quot;).start();

TimeUnit.SECONDS.sleep(1);

new Thread(() -&gt; {
    synchronized(lock) {
        for (int i = 0; i &lt; 10; i&#43;&#43;) {
            c.add(new Object());
            if (c.size() == 5) {
                lock.notify();
                lock.wait();        // 让出sychronized锁
            }
        }
    }
}, &quot;t1&quot;).start();


  生产消费
  #

# 优化count可以用CAS加(有ABA问题)
class MyContainer&lt;T&gt; {
    final private List&lt;T&gt; list = new LinkedList&lt;&gt;();
    final private int MAX = 10;
    private int count = 0;

    public synchronized void put(T t) {
        while(list.size() == MAX) {
            this.wait();            // 期间可能有add() 
        }
        list.add(t);
        count&#43;&#43;;
        this.notifyAll();           // 应该只唤醒消费者
    }

    public synchronized T get() {
        T t = null;
        while(list.size() == 0) {
            this.wait();
        }
        t = list.removeFirst();
        count--;
        this.notifyAll();           // 应该只唤醒生产者
        return t;
    }
}

# 同步容器, ReentrantLock Condition
private Lock lock = new ReentrantLock();
private Condition producer = lock.newCondition();
private Condition consumer = lock.newCondition();

public void put(T t) {
    try {
        lock.lock();
        while(list.size() == MAX) {
            producer.await();
        }
        list.add(t);
        count&#43;&#43;;
        consumer.signalAll();
    } finally {
        lock.unlock();
    }
}

public T get() {
    T t = null;
    try {
        lock.lock();
        while(list.size() == 0) {
            consumer.await();
        }
        t = list.removeFirst();
        count--;
        producer.signalAll();
    } finally {
        lock.unlock();
    }
    return t;
}


  协程
  #

quasar库                            # 需要设javaagent, 每个fiber生成栈
    fiber =  new Fiber&lt;Void&gt;()
    fiber.start()


  并发API
  #


  Stream
  #

parallelStream()                    # ForkJoinPool


  ThreadLocal
  #

内部类
    ThreadLocalMap&lt;ThreadLocal, Object&gt;
        # 存在每个线程里。场景如声明式事务拿conn
        # key是弱引用指向ThreadLocal, value是强引用。
    Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        Object value;
        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
方法
    set(T)
内存泄露问题
    ThreadLocal&lt;M&gt; tl = new ThreadLocal();
    tl.set(new M());
    tl = null;
        # threadLocalMap中key弱引用回收, value不回收
    tl.remove();
        # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在


  PipedStream
  #

# 效率不高
PipedInputStream
    connect(PipedOutputStream)
    read(byte[])
PipedOutputStream
    write(byte[])


  JMH
  #

# Java Microbenchmark Harness
概念
    Warmup                              # 预热
    Mesurement                          # 总执行次数
    Timeout                             # 每次执行超时时间
    Threads                             # fork线程数
    Benchmark mode                      # 模式
    Benchmark                           # 方法名
环境变量
    TEMP或TMP                           # JHM临时文件存放
使用
    @Benchmark
    @Warmup(iterations = 2, time = 3)           # 执行2次, 每次隔3秒
    @Fork(5)                                    # 多少线程
    @BenchmarkMode(Mode.Throughput)             # 显示每秒多少次
    @Measurement(iterations = 10, time = 3)     # 共测10次, 每次隔3秒
    public void testA() {

    }


  Disruptor
  #

介绍
    CAS, 环形数组Buffer
        数组用sequence定位修改快,也避免了头尾加锁
        直接覆盖降低GC
            覆盖前有等待策略
    单机MQ
        发布订阅模式
        观察者模式
    EventFactory
        会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC
使用
    class MyEvent {}
    class MyEventFactory implements EventFactory&lt;MyEvent&gt; {
        @Override
        public MyEvent newInstance() {}
    }
    class MyEventHandler implements EventHandler&lt;MyEvent&gt; {
        @Override
        void onEvent(MyEvent, long sequence, boolean endOfBatch) {}
    }
    class MyExceptionHandler implements ExceptionHandler&lt;MyEvent&gt; {
        @Override
        void handleEventException()
        @Override
        void handleOnStartException()
        @Override
        void handleOnShutdownException()
    }
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(MyEvent::new, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory(), 
        ProducerType.SINGLE, new BlockingWaitStrategy())
        # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁
    // 消费
    disruptor.handleEventsWith(handler1, handler2)
    disruptor.handleEventsWith((event,seq,end)-&gt;{})
    disruptor.handleExceptionsFor(handler1).with(excptionHandler1)

    disruptor.start()

    // 生产
    ringBuffer = disruptor.getRingBuffer()
    sequence = ringBuffer.next()
    event = ringBuffer.get(sequence)
    event.set(&quot;&quot;)
    ringBuffer.publish(sequence)
    translator = new EventTranslator&lt;&gt;() {
        @Override
        void translateTo(event, sequence) {
            event.set(&quot;&quot;)
        }
    }
    ringBuffer.publishEvent(translator)
    ringBuffer.publishEvent((event,seq, &quot;&quot;) -&gt; event.set(l), &quot;&quot;)
等待策略
    BlockingWaitStrategy                # 阻塞直到再次唤醒
    BusySpinWaitStrategy                # 自旋等待
    SleepingWaitStrategy                # sleep等待
    LiteBlockingWaitStrategy            # 同BlockingWaitStrategy减少加锁次数                
    LiteTimeoutBlockingWaitStrategy     # 同LiteBlockingWaitStrategy加超时            
    PhasedBackoffWaitStrategy
    TimeoutBlockingWaitStrategy         # 同BlockingWaitStrategy加超时                
    YieldingWaitStrategy                # 尝试100然后Thread.yield()


  源码分析
  #


  ThreadPoolExecutor
  #

new ThreadPoolExecutor()                    
    int corePoolSize                    # 核心线程数, 永远存活。可设置参与回收
    int maximumPoolSize                 # 最大线程数
    long keepAliveTime                  # 生存时间
    TimeUnit
    BlockingQueue&lt;Runnable&gt;             # 任务队列
    ThreadFactory                       # 线程工厂, 设线程名
    RejectedExecutionHandler            # 拒绝策略
        Abort                           # 抛异常
        Discard                         # 忽略掉
        DiscardOldest                   # 忽略掉排除最久的
        CallerRuns                      # 调用者线程执行, 再多就阻塞
AtomicInteger ctl
    # 高3位线程池状态，低29位线程数量
void execute()
    判断添加核心线程
    放入队列成功
        拒绝或添加非核心线程
    添加非核心线程失败
        拒绝
boolean addWorker(Runable, boolean)
    线程数量加1
    添加Worker
        加锁
        加线程
        启动
class Worker extends AbstractQueuedSynchronizer implements Runnable
    # 本身是AQS锁, 被多任务(线程)访问
    Tread thread


  ForkJoinPool
  #

abstract class ForkJoinTask
    ForkJoinTask&lt;V&gt; fork()
    V join()
    abstract class RecursiveAction          # 无返回值
        void compute()
    abstract class RecursiveTask            # 有返回值
例子
    class MyTask extends RecursiveTask&lt;Long&gt; {
        int start;
        int end;
        @Override
        Long compute() {
            if (end - start &lt;= MAX_NUM) {
                return sum
            }
            subTask1 = new MyTask(start, mid)
            subTask2 = new MyTask(mid, end)
            subTask1.fork()
            subTask2.fork()
            return subTask1.join() &#43; subTask2.join();
        }
    }
    fjp = new ForkJoinPool()
    task = new MyTask(0, nums.length)
    fjp .execute(task)
    result = task.join()
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://runout.run/docs/pl/java/juc/">
  <meta property="og:site_name" content="outrun的笔记">
  <meta property="og:title" content="Java并发">
  <meta property="og:description" content="基础 # 并发编程三大特性 可见性(visibility) synchronized会刷新线程栈 有序性(ordering) 原子性(atomicity) CPU # PC寄存器(Program Counter Register, 存下一指令) 优化 乱序读 合并写 乱序执行(流水线) ALU 访问速度 Registers: &lt; 1ns L1 cache(核内): 1ns WC(Writer Comblining) Buffer # 合并写, 一般4个字节 L2 cache(核内): 3ns L3 cache(CPU内): 15ns memory: 80ns 局部性原理 空间 按块读取(cache line) 一次读64Bytes # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知 Java1.8注解@Contended # 保证不在同一行，需要JVM参数-XX:-RestrictContended 时间 批量读指令 内存屏障 # 不同CPU不一样 Intel sfence # save, 之前写操作必须完成 lfence # load, 之前读操作必须完成 mfence # mix(save &#43; load) lock指令 # 指令执行完之前，锁内存 lock_add CPU缓存一致性协议 # # 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁 状态 MESI Cache一致性协议 # Intel CPU，实现方式为主动监听 Modified # 一行数据在CPU Modified, 其它CPU为Invalid Exclusive # 独享，其它CPU没有 Shared # 别人也在读 Invalid # 别人改过了 MSI MOSI 缓存行 # 多数64字节 伪共享 # 缓存行内无关数据也要同步 OS # 进程 # 资源分配 线程 # 调度执行 切换(Context Switch) CPU导出原线程指令和data到cache, 再导入新线程数据 线程数 N(threads) = N(CPU) * U(CPU) * (1 &#43; W/C) # N(CPU): CPU数 # U(CPU): 期望CPU利用率, 0到1 # W/C: wait时间/compute时间, (1&#43;W/C)即运行时间/计算时间。用profiler、arthas分析 压测决定 CPU性能压榨 单进程 批处理 多进程切换 多线程进程内切换 I/O复用 协程(纤程、绿色线程)用户空间切换 JVM # 内存屏障 # LoadLoad StoreStore LoadStore StoreLoad 乱序执行(指令重排序) # 为什么 CPU快, 指令1阻塞时，指令2先执行 判断 代码不影响单线程最终一致性 例子，多线程 static int x = 0, y = 0; static int a = 0, b = 0; void main(){ for (long i = 0; i &lt; Long.MAX_VALUE; i&#43;&#43;&gt;) { x=0; y=0; a=0; b=0; CountDownLatch latch = new CountDownLatch(2); Thread one = new Thread(() -&gt; { public void run() { a = 1; x = b; latch.countDown(); } }); Thread other = new Thread(() -&gt; { public void run() { b = 1; y = a; latch.countDown(); } }); one.start(); other.start(); latch.await(); if (x == 0 &amp;&amp; y == 0) { break; } } } 例子，类初始化指令换顺序 class T { int m = 8; } T t = new T(); 汇编码 0 new #2 &lt;T&gt; # 变量半初始化状态为0 3 dup 4 invokespecial #3 &lt;T.&lt;init&gt;&gt; 7 astore_1 # 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0。线程访问时中间状态逸出 8 return class C { private int num = 0; public C() { new Thread(() -&gt; System.out.println(this.num)).start(); } void main() { new C(); System.in.read(); } } Unsafe类 # # 相当于指针。1.8只能根部类用, 11可以直接用 操作内存 allocateMemory putXX freeMemory pageSize 生成类实例 allocateInstance 操作类或实例 objectFieldOffset getInt getObject CAS compareAndSwapObject() # JDK1.8 compareAndSetObject() weakCompareAndSetObject() # JDK11 修饰符与锁 # 概念 # 锁细化 # 少代码加轻量锁 锁粗化 # 锁太多时，如行锁变表锁 synchronized # 实现方式 JVM没要求实现方式 早期都是OS调度 HotSpot 在对象头(64位)上用2位实现，组合成锁的类型 锁升级 # 不比原子类慢，升完不降 偏向锁, 第一个线程第一次访问只记线程id 自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平 重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景 原子性、可见性 可重入 # 同一个对象同线程可重入 加锁对象 方法锁和对象锁锁this static方法锁和类锁锁class类 继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象 使用注意 抛异常立即释放锁，但被锁数据已更新 不能用的对象 String常量，可能未知地方锁同一个 Integer、Long等基本类型, 值变化会生成新对象 synchronized的属性加final防止赋值 volatile # # 用synchronized性能差不多，volatile一般不用 作用 # 没有原子性，可能写同一值 变量在线程见可见性 依靠CPU缓存一致性协议 禁止指令重排序 # 用JVM的读写屏障 修饰引用类型，内部属性不监控 DCL(Double Check Lock)单例volatile问题 private static volatile C c; // 禁止了创建c指令重排序 private C(){} public static C getInstance() { if (c == null) { synchronized (C.class) { if (c == null) { // 申请内存(半初始化状态默认0)，成员变量初始化，赋值 // 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象 c = new C(); } } } return c; } CAS # # Compare And Set/Swap, 无锁优化, 乐观锁, 自旋 # Unsafe类支持 CPU原语 cas(V, Expected, NewValue) if V == E # 无并发值判断问题，原语上加了屏障 V = New else try again or fail Java AtomicInteger incrementAndGet() ABA问题 # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据 版本号 # Java版本号类AtomicStampedReference LongAdder LongAdder每次加数字, LongAccumulator用lambda 分段锁(CAS)。值分开放数组里, 多线程对应一个item 性能测试 LongAdder(713) &gt; Atomic(2166) &gt; Synchronized(3129) 锁 # AQS # # AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种 # 实现方式: CAS，volatile, 模板方法 类图 AbstractQueueSynchronizer Sync NonfairSync 方法 AbstractQueueSynchronizer # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待) Node volatile Node prev volatile Node next volatile Thread thread VarHandle # JDK1.9，保存引用，普通属性原子操作。 # 相比反射，直接操作二进制码 get() set() compareAndSet() # 原子性 getAndAdd() # 原子性 class C { int x = 0; private static VarHandle handle; static { handle = MethodHandles.lookup().findVarHandle(C.class, &#34;x&#34;, int.class) handle.compareAndSet(c, 0, 1); } } volatile state # 多态实现 acquire() tryAcquire() # 模板方法 acquireQueued() # 获得 addWaiter(Node.EXCLUSIVE) # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表) cancelAcquire() # status CANCELLED, tail时设置null, 非tail时unpark下一节点 NonfairSync nonfairTryAcquire() ReentrantLock # # 可重入锁，CAS实现, state记重入多少次 new ReentrantLock(true) # 公平锁 tryLock(long, TimeUnit) lockInterruptibly() # 响应interrupt()标记 newCondition() # 多一个等待队列 源码 调NonfairSync CountDownLatch # # 比join()灵活 new CountDownLatch(4) countDown() await() CyclicBarrier # # 满了一起放行, 场景如I/O批量消费 new CyclicBarrier(4, ()-&gt;{}) await() Phaser # # 阶段批量执行过滤 class MyPhaser extends Phaser { @Override protected boolean onAdvance(int phase, int registeredParties) { switch(phase) { case 0: print(&#34;arrived&#34; &#43; registeredParties); return false; case 1: print(&#34;eated&#34; &#43; registeredParties); return false; case 2: print(&#34;hugged&#34; &#43; registeredParties); return true; default: return true; } } } Person implements Runnable { private int i; public Person(int i) { this.i = i; } public void arrive() { phaser.arriveAndAwaitAdvance(); } public void eat() { phaser.arriveAndAwaitAdvance(); } public void hug() { if (i == 0 || i == 1) { phaser.arriveAndAwaitAdvance(); } else { phaser.arriveAndDeregister(); } } @Override public void run() { arrive(); eat(); hug(); } } phaser = new MyPhaser(); phaser.bulkRegister(5); for (int i = 0; i &lt; 5; i&#43;&#43;) { new Thread(new Person(i)).start() } ReadWriteLock # # 读锁是共享锁，不能写，悲观锁 # 写锁是排他锁，不能读写 ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); Lock readLock = readWriteLock.readLock(); Lock writeLock = readWriteLock.writeLock(); void read(Lock lock) { lock.lock() lock.unlock() } void write(Lock lock) { lock.lock() lock.unlock() } for (int i =0; i&lt;10;i&#43;&#43;) { new Thread(()-&gt;read(readLock)).start(); } for (int i =0; i&lt;2; i&#43;&#43;) { new Thread(()-&gt;write(writeLock)).start(); } StampedLock # # 读时允许写，读完判断不一致再读一遍，乐观锁 Semaphore # # 信号量, 限流同时运行, 用于线程间同步。可设置公平 Semaphore s = new Semaphore(1, true) new Thread(() -&gt; { s.acquire(); s.release() }) Exchanger # # 线程间通信, 阻塞交换 exchange() LockSupport # # 线程间通信，非锁阻塞，指定线程唤醒 # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1) Thread t = new Thread(() -&gt; { for (int i = 0; i &lt; 10; i&#43;&#43;) { if (i == 5) { LockSupport.park(); } } }) t.start(); TimeUnit.SECONDS.sleep(1); LockSupport.unpark(t); 线程及线程池 # 使用注意 # 为什么不用Executors线程池 用LinkedBlockingQueue超数量OOM 拒绝策略 线程命名 类 # Object wait() # 释放synchronized锁并加入等待队列，唤醒后执行需要得到synchronized锁 notify() # 只唤醒，不释放当前synchronized锁 Thread static currentThread() static sleep() static yield() # 让出CPU, 进Ready队列 start() getState() join() # 等待结束 setDaemon() # 是否后台 setPriority(Thread.NORM_PRIORITY) # 优先级，没有用 interface Runnable void run() interface Callable V call() throws Exception interface Future get() get(long, TimeUnit) cancel(boolean) isCanceled() isDone() interface RunnableFuture class FutureTask interface CompletableFuture # parallel static CompletableFuture&lt;U&gt; supplyAsync() static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;U&gt;...) static CompletableFuture&lt;Void&gt; anyOf(CompletableFuture&lt;U&gt;...) T join() CompletableFuture&lt;U&gt; thenApply() CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;T&gt;) interface ThreadFactory Thread newThread(Runnable) class DefaultThreadFactory interface Executor void execute() interface ExecutorService shutdown() shutdownNow() isShutdown() isTerminated() awaitTermination(long, TimeUnit) Future submit(Callable&lt;T&gt;) Future submit(Runnable, T) # 手动设个result submit(Runnable) invokeAll(Collection&lt;Callable&lt;T&gt;&gt;) invokeAll(Collection&lt;Callable&lt;T&gt;&gt;, long, TimeUnit) invokeAny(Collection&lt;Callable&lt;T&gt;&gt;) invokeAny(Collection&lt;Callable&lt;T&gt;&gt;, long, TimeUnit) abstract AbstractExecutorService RunnableFuture&lt;T&gt; newTaskFor(Runnable, T) RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt;) T doInvokeAny(Collection&lt;Callable&lt;T&gt;&gt;, boolean timed, long) submit() invokeAll(Collection&lt;Callable&lt;T&gt;&gt;) # 忽略CancellationException, ExecutionException，其它异常抛出并取消未完成任务 invokeAll(Collection&lt;Callable&lt;T&gt;&gt;, long, TimeUnit) # 忽略CancellationException, ExecutionException, TimeoutException，其它异常抛出并取消未完成任务 invokeAny(Collection&lt;Callable&lt;T&gt;&gt;) invokeAny(Collection&lt;Callable&lt;T&gt;&gt;, long, TimeUnit) class ThreadPoolExecutor # 线程池&#43;任务队列 # 任务顺序: 核心线程, 任务队列，起新线程，拒绝策略 class ScheduledThreadPoolExecutor # 用DelayedWorkQueue scheduleAtFixedRate(()-&gt;{}, int initial, int period, TimeUnit) class ForkJoinPool execute(ForkJoinTask) interface ScheduledExecutorService [class ScheduledThreadPoolExecutor] interface CompletionService # 不阻塞全部任务，已有结果入队列 poll() class ExecutorCompletionService static class Executors newSingleThreadExecutor() # 为了用任务队列和生命周期管理 newCachedThreadPool() # 超时60s, max为MAX_VALUE, 任务不堆积场景 newFixedThreadPool() newScheduledThreadPool() # AbstractQueuedSynchronizer newWorkStealingPool() # ForkJoinPool, go的M,G,P # 每个线程单独队列, 尾部偷加尾部 创建线程 # # 继承 class MyThread extendws Thread { @Override public void run(){} } new MyThread().start(); # 组合 class MyRun implements Runnable { @Override public void run(){} } new Thread(new MyRun()).start(); # 返回值 class myCall implements Callable&lt;String&gt; { @Override public String call(){} } FutureTask = ft = new FutureTask&lt;String&gt;(new MyCall()) new Thread(ft).start(); ft.get(); # 线程池 // execute无返回值 ExecutorService service = Executors.newCachedThreadPool() service.execute(()-&gt;{}); // submit有返回值 Future&lt;String&gt; f = service.submit(new MyCall()); service.shutdown(); 线程状态 # NEW RUNNABLE # 可调度 READY RUNNING WAITING # 等待唤醒，忙等待(一直占CPU) o.wait() t.join() LockSupport.park() Lock.lock() o.notify() o.notifyAll() LockSupport.unpark() Lock.unlock() TIMED WAITING Thread.sleep(time) o.wait(time) t.join(time) LockSupport.parkNanos() LockSupport.parkUntil() BLOCKING # 阻塞等待（不占CPU但经过OS调度) synchronized TERMINATED 线程打断 # 方法 interrupt() # 设置打断标记位 isInterrupted() # 检查标记位 static interrupted() # 检查当前线程标记位，并重置 检测当前线程打断标记的方法 # 抛异常并重置 Thread.sleep() o.wait(); o.join(); ReentrantLock lockInterruptibly() 不检测当前线程打断标记的方法 synchronized # 不是代码实现检测不了 ReentrantLock lock() 强制打断 Thread stop() # 已废弃, 立即释放所有锁 suspend() # 已废弃，强制暂停，所有锁不释放容易死锁 resume() # 已废弃，强制恢复 volatile 判断数字不准，有同步的时间延迟, interrupt()也有延迟 也需要代码中判断, 但interrupt()有wait()等系统方法支持 线程间通信 # 通知 # # synchronized wait() notify(), CountDownLatch, LockSupport volatile List c = new ArrayList(); final Object lock = new Object(); new Thread(() -&gt; { synchronized(lock) { if (c.size() != 5) { lock.wait(); } lock.notify(); // 唤醒t1 } }, &#34;t2&#34;).start(); TimeUnit.SECONDS.sleep(1); new Thread(() -&gt; { synchronized(lock) { for (int i = 0; i &lt; 10; i&#43;&#43;) { c.add(new Object()); if (c.size() == 5) { lock.notify(); lock.wait(); // 让出sychronized锁 } } } }, &#34;t1&#34;).start(); 生产消费 # # 优化count可以用CAS加(有ABA问题) class MyContainer&lt;T&gt; { final private List&lt;T&gt; list = new LinkedList&lt;&gt;(); final private int MAX = 10; private int count = 0; public synchronized void put(T t) { while(list.size() == MAX) { this.wait(); // 期间可能有add() } list.add(t); count&#43;&#43;; this.notifyAll(); // 应该只唤醒消费者 } public synchronized T get() { T t = null; while(list.size() == 0) { this.wait(); } t = list.removeFirst(); count--; this.notifyAll(); // 应该只唤醒生产者 return t; } } # 同步容器, ReentrantLock Condition private Lock lock = new ReentrantLock(); private Condition producer = lock.newCondition(); private Condition consumer = lock.newCondition(); public void put(T t) { try { lock.lock(); while(list.size() == MAX) { producer.await(); } list.add(t); count&#43;&#43;; consumer.signalAll(); } finally { lock.unlock(); } } public T get() { T t = null; try { lock.lock(); while(list.size() == 0) { consumer.await(); } t = list.removeFirst(); count--; producer.signalAll(); } finally { lock.unlock(); } return t; } 协程 # quasar库 # 需要设javaagent, 每个fiber生成栈 fiber = new Fiber&lt;Void&gt;() fiber.start() 并发API # Stream # parallelStream() # ForkJoinPool ThreadLocal # 内部类 ThreadLocalMap&lt;ThreadLocal, Object&gt; # 存在每个线程里。场景如声明式事务拿conn # key是弱引用指向ThreadLocal, value是强引用。 Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } 方法 set(T) 内存泄露问题 ThreadLocal&lt;M&gt; tl = new ThreadLocal(); tl.set(new M()); tl = null; # threadLocalMap中key弱引用回收, value不回收 tl.remove(); # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在 PipedStream # # 效率不高 PipedInputStream connect(PipedOutputStream) read(byte[]) PipedOutputStream write(byte[]) JMH # # Java Microbenchmark Harness 概念 Warmup # 预热 Mesurement # 总执行次数 Timeout # 每次执行超时时间 Threads # fork线程数 Benchmark mode # 模式 Benchmark # 方法名 环境变量 TEMP或TMP # JHM临时文件存放 使用 @Benchmark @Warmup(iterations = 2, time = 3) # 执行2次, 每次隔3秒 @Fork(5) # 多少线程 @BenchmarkMode(Mode.Throughput) # 显示每秒多少次 @Measurement(iterations = 10, time = 3) # 共测10次, 每次隔3秒 public void testA() { } Disruptor # 介绍 CAS, 环形数组Buffer 数组用sequence定位修改快,也避免了头尾加锁 直接覆盖降低GC 覆盖前有等待策略 单机MQ 发布订阅模式 观察者模式 EventFactory 会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC 使用 class MyEvent {} class MyEventFactory implements EventFactory&lt;MyEvent&gt; { @Override public MyEvent newInstance() {} } class MyEventHandler implements EventHandler&lt;MyEvent&gt; { @Override void onEvent(MyEvent, long sequence, boolean endOfBatch) {} } class MyExceptionHandler implements ExceptionHandler&lt;MyEvent&gt; { @Override void handleEventException() @Override void handleOnStartException() @Override void handleOnShutdownException() } disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory()) disruptor = new Disruptor&lt;&gt;(MyEvent::new, 1024, Executors,defaultThreadFactory()) disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory(), ProducerType.SINGLE, new BlockingWaitStrategy()) # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁 // 消费 disruptor.handleEventsWith(handler1, handler2) disruptor.handleEventsWith((event,seq,end)-&gt;{}) disruptor.handleExceptionsFor(handler1).with(excptionHandler1) disruptor.start() // 生产 ringBuffer = disruptor.getRingBuffer() sequence = ringBuffer.next() event = ringBuffer.get(sequence) event.set(&#34;&#34;) ringBuffer.publish(sequence) translator = new EventTranslator&lt;&gt;() { @Override void translateTo(event, sequence) { event.set(&#34;&#34;) } } ringBuffer.publishEvent(translator) ringBuffer.publishEvent((event,seq, &#34;&#34;) -&gt; event.set(l), &#34;&#34;) 等待策略 BlockingWaitStrategy # 阻塞直到再次唤醒 BusySpinWaitStrategy # 自旋等待 SleepingWaitStrategy # sleep等待 LiteBlockingWaitStrategy # 同BlockingWaitStrategy减少加锁次数 LiteTimeoutBlockingWaitStrategy # 同LiteBlockingWaitStrategy加超时 PhasedBackoffWaitStrategy TimeoutBlockingWaitStrategy # 同BlockingWaitStrategy加超时 YieldingWaitStrategy # 尝试100然后Thread.yield() 源码分析 # ThreadPoolExecutor # new ThreadPoolExecutor() int corePoolSize # 核心线程数, 永远存活。可设置参与回收 int maximumPoolSize # 最大线程数 long keepAliveTime # 生存时间 TimeUnit BlockingQueue&lt;Runnable&gt; # 任务队列 ThreadFactory # 线程工厂, 设线程名 RejectedExecutionHandler # 拒绝策略 Abort # 抛异常 Discard # 忽略掉 DiscardOldest # 忽略掉排除最久的 CallerRuns # 调用者线程执行, 再多就阻塞 AtomicInteger ctl # 高3位线程池状态，低29位线程数量 void execute() 判断添加核心线程 放入队列成功 拒绝或添加非核心线程 添加非核心线程失败 拒绝 boolean addWorker(Runable, boolean) 线程数量加1 添加Worker 加锁 加线程 启动 class Worker extends AbstractQueuedSynchronizer implements Runnable # 本身是AQS锁, 被多任务(线程)访问 Tread thread ForkJoinPool # abstract class ForkJoinTask ForkJoinTask&lt;V&gt; fork() V join() abstract class RecursiveAction # 无返回值 void compute() abstract class RecursiveTask # 有返回值 例子 class MyTask extends RecursiveTask&lt;Long&gt; { int start; int end; @Override Long compute() { if (end - start &lt;= MAX_NUM) { return sum } subTask1 = new MyTask(start, mid) subTask2 = new MyTask(mid, end) subTask1.fork() subTask2.fork() return subTask1.join() &#43; subTask2.join(); } } fjp = new ForkJoinPool() task = new MyTask(0, nums.length) fjp .execute(task) result = task.join()">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2018-10-09T08:48:07+08:00">
    <meta property="article:modified_time" content="2021-06-18T13:03:49+08:00">
<title>Java并发 | outrun的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://runout.run/docs/pl/java/juc/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.de073bde8a6e6d0bd83cd24901f31edc4f18d2b60264b1a5c09063bb3745c1c7.js" integrity="sha256-3gc73opubQvYPNJJAfMe3E8Y0rYCZLGlwJBjuzdFwcc=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span>outrun的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/" class="">架构</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/" class="">代码</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/security/" class="">Security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/design_mode/" class="">Java设计模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/" class="">工程设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/ddd/" class="">工程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/frontend/" class="">前端</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>战略性技术</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/" class="">AI</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/map/" class="">知识图谱</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/framework/" class="">Framework</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/media/" class="">媒体</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/middle_platform/" class="">中台</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/block_chain/" class="">Block Chain</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Cloud</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/" class="">Datalake</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/ecology/" class="">Ecology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/edge/" class="">Edge</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/" class="">Manage</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/" class="">组织</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/people/" class="">人员</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/" class="">Method</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/product_plan/" class="">产品规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/code_plan/" class="">代码规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/ops_plan/" class="">运维规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/advice_plan/" class="">咨询规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/architect/" class="">服务治理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/project_plan/" class="">项目规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/test_plan/" class="">测试规划</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/summary/" class="">这些年我做过的技术</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/" class="">数据库</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mongodb/" class="">Mongodb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/postgresql/" class="">Postgre SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/oracle/" class="">Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/" class="">中间件</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/" class="">支撑-分布式</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/spring_cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/" class="">前端</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/bootstrap/" class="">Bootstrap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/threejs/" class="">Threejs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/angular/" class="">Angular</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/jquery/" class="">Jquery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/react/" class="">React</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/" class="">小功能</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/hibernate/" class="">Hibernate</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Container</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nginx/" class="">Nginx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nodejs/" class="">Nodejs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/" class="">程序语言</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/principle/" class="">程序语言原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/haskell/" class="">Haskell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/elixir/" class="">Elixir</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/clojure/" class="">Clojure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/js/" class="">JS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/java_reactive/" class="">Java响应式编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/javaweb/" class="">JavaWeb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/juc/" class="active">Java并发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/jvm/" class="">JVM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/collection/" class="">Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/spring/" class="">Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/" class="">Markup Language</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/html/" class="">Html</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/css/" class="">Css</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/" class="">工具</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/" class="">运维</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/monitor/" class="">Monitor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/docker/" class="">Docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/k8s/" class="">Kubernetes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/enterprise_system/" class="">企业级系统</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/" class="">Develop</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/eclipse/" class="">Eclipse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/vim/" class="">VIM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/apple/" class="">Apple</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/jetbrains/" class="">Jetbrains</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/" class="">Linux</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_program/" class="">LinuxProgram</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/scene/" class="">LinuxScene</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_tool/" class="">LinuxTool</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/framework/" class="">Framework</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/physics/" class="">实物工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/" class="">测试</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/debug/" class="">程序调试</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/" class="">Cache</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/ops/" class="">Ops</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/work_code/" class="">Work Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/template/" class="">模板配置</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/soft_arch/" class="">软考架构师</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/misc/" class="">杂项</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/" class="">基本功</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/speach/" class="">演说</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/body/" class="">身体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/" class="">Computer</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/principle/" class="">支撑-原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/performance/" class="">Performance</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/" class="">算法</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/thought/" class="">算法思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/data_structure/" class="">数据结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/math/" class="">数学</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Java并发</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a>
      <ul>
        <li><a href="#cpu">CPU</a>
          <ul>
            <li><a href="#cpu缓存一致性协议">CPU缓存一致性协议</a></li>
          </ul>
        </li>
        <li><a href="#os">OS</a></li>
        <li><a href="#jvm">JVM</a>
          <ul>
            <li><a href="#内存屏障">内存屏障</a></li>
            <li><a href="#乱序执行指令重排序">乱序执行(指令重排序)</a></li>
          </ul>
        </li>
        <li><a href="#unsafe类">Unsafe类</a></li>
      </ul>
    </li>
    <li><a href="#修饰符与锁">修饰符与锁</a>
      <ul>
        <li><a href="#概念">概念</a></li>
        <li><a href="#synchronized">synchronized</a></li>
        <li><a href="#volatile">volatile</a></li>
        <li><a href="#cas">CAS</a></li>
        <li><a href="#锁">锁</a>
          <ul>
            <li><a href="#aqs">AQS</a></li>
            <li><a href="#reentrantlock">ReentrantLock</a></li>
            <li><a href="#countdownlatch">CountDownLatch</a></li>
            <li><a href="#cyclicbarrier">CyclicBarrier</a></li>
            <li><a href="#phaser">Phaser</a></li>
            <li><a href="#readwritelock">ReadWriteLock</a></li>
            <li><a href="#stampedlock">StampedLock</a></li>
            <li><a href="#semaphore">Semaphore</a></li>
            <li><a href="#exchanger">Exchanger</a></li>
            <li><a href="#locksupport">LockSupport</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#线程及线程池">线程及线程池</a>
      <ul>
        <li><a href="#使用注意">使用注意</a></li>
        <li><a href="#类">类</a></li>
        <li><a href="#创建线程">创建线程</a></li>
        <li><a href="#线程状态">线程状态</a></li>
        <li><a href="#线程打断">线程打断</a></li>
        <li><a href="#线程间通信">线程间通信</a>
          <ul>
            <li><a href="#通知">通知</a></li>
            <li><a href="#生产消费">生产消费</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#协程">协程</a></li>
    <li><a href="#并发api">并发API</a>
      <ul>
        <li><a href="#stream">Stream</a></li>
        <li><a href="#threadlocal">ThreadLocal</a></li>
        <li><a href="#pipedstream">PipedStream</a></li>
        <li><a href="#jmh">JMH</a></li>
        <li><a href="#disruptor">Disruptor</a></li>
      </ul>
    </li>
    <li><a href="#源码分析">源码分析</a>
      <ul>
        <li><a href="#threadpoolexecutor">ThreadPoolExecutor</a></li>
        <li><a href="#forkjoinpool">ForkJoinPool</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>并发编程三大特性
    可见性(visibility)
        synchronized会刷新线程栈
    有序性(ordering)
    原子性(atomicity)
</code></pre>
<h2 id="cpu">
  CPU
  <a class="anchor" href="#cpu">#</a>
</h2>
<pre><code>PC寄存器(Program Counter Register, 存下一指令)
优化
    乱序读
    合并写
    乱序执行(流水线)
ALU
    访问速度
        Registers: &lt; 1ns
        L1 cache(核内): 1ns
        WC(Writer Comblining) Buffer    # 合并写, 一般4个字节
        L2 cache(核内): 3ns
        L3 cache(CPU内): 15ns
        memory: 80ns
局部性原理
    空间
        按块读取(cache line)
            一次读64Bytes               # disruptor RingBuffer实现前后7个long，两个元素不同行，避免缓存一致性协议的通知
            Java1.8注解@Contended       # 保证不在同一行，需要JVM参数-XX:-RestrictContended
    时间
        批量读指令
内存屏障                        # 不同CPU不一样
    Intel
        sfence                      # save, 之前写操作必须完成
        lfence                      # load, 之前读操作必须完成
        mfence                      # mix(save + load)
lock指令                            # 指令执行完之前，锁内存
    lock_add
</code></pre>
<h3 id="cpu缓存一致性协议">
  CPU缓存一致性协议
  <a class="anchor" href="#cpu%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e5%8d%8f%e8%ae%ae">#</a>
</h3>
<pre><code># 是缓存锁。无法被缓存、跨越多个缓存的数据，依然总线锁
状态
    MESI Cache一致性协议                    # Intel CPU，实现方式为主动监听
        Modified                            # 一行数据在CPU Modified, 其它CPU为Invalid
        Exclusive                           # 独享，其它CPU没有
        Shared                              # 别人也在读
        Invalid                             # 别人改过了
    MSI
    MOSI
缓存行                                      # 多数64字节
    伪共享                                  # 缓存行内无关数据也要同步
</code></pre>
<h2 id="os">
  OS
  <a class="anchor" href="#os">#</a>
</h2>
<pre><code>进程
    # 资源分配
线程
    # 调度执行
    切换(Context Switch)
        CPU导出原线程指令和data到cache, 再导入新线程数据
    线程数
        N(threads) = N(CPU) * U(CPU) * (1 + W/C)
            # N(CPU): CPU数
            # U(CPU): 期望CPU利用率, 0到1
            # W/C: wait时间/compute时间, (1+W/C)即运行时间/计算时间。用profiler、arthas分析
        压测决定
CPU性能压榨
    单进程
    批处理
    多进程切换
    多线程进程内切换
        I/O复用
    协程(纤程、绿色线程)用户空间切换
</code></pre>
<h2 id="jvm">
  JVM
  <a class="anchor" href="#jvm">#</a>
</h2>
<h3 id="内存屏障">
  内存屏障
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c">#</a>
</h3>
<pre><code>LoadLoad
StoreStore
LoadStore
StoreLoad
</code></pre>
<h3 id="乱序执行指令重排序">
  乱序执行(指令重排序)
  <a class="anchor" href="#%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f">#</a>
</h3>
<pre><code>为什么
    CPU快, 指令1阻塞时，指令2先执行
判断
    代码不影响单线程最终一致性
例子，多线程
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 0, y <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 0, b <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> Long.<span style="color:#a6e22e">MAX_VALUE</span>; i<span style="color:#f92672">++&gt;</span>) {
</span></span><span style="display:flex;"><span>                x<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                y<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                a<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                b<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>                CountDownLatch latch <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CountDownLatch(2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Thread one <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>                        a <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>                        x <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>                        latch.<span style="color:#a6e22e">countDown</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                Thread other <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>                        b <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>                        y <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>                        latch.<span style="color:#a6e22e">countDown</span>();
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>                one.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>                other.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>                latch.<span style="color:#a6e22e">await</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span> y <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><pre><code>例子，类初始化指令换顺序
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> 8;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        T t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T();
</span></span><span style="display:flex;"><span>        汇编码
</span></span><span style="display:flex;"><span>            0 <span style="color:#66d9ef">new</span> <span style="color:#960050;background-color:#1e0010">#</span>2 <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">#</span> 变量半初始化状态为0
</span></span><span style="display:flex;"><span>            3 dup
</span></span><span style="display:flex;"><span>            4 invokespecial <span style="color:#960050;background-color:#1e0010">#</span>3 <span style="color:#f92672">&lt;</span>T.<span style="color:#f92672">&lt;</span>init<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>            7 astore_1
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">#</span> 4,7乱序执行, 先建立了关联再初始化, 变量中间状态值为0<span style="color:#960050;background-color:#1e0010">。</span>线程访问时中间状态逸出
</span></span><span style="display:flex;"><span>            8 <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">C</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">num</span>)).<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> C();
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">read</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h2 id="unsafe类">
  Unsafe类
  <a class="anchor" href="#unsafe%e7%b1%bb">#</a>
</h2>
<pre><code># 相当于指针。1.8只能根部类用, 11可以直接用
操作内存
    allocateMemory
    putXX
    freeMemory
    pageSize
生成类实例
    allocateInstance
操作类或实例
    objectFieldOffset
    getInt
    getObject
CAS
    compareAndSwapObject()          # JDK1.8
    compareAndSetObject()
    weakCompareAndSetObject()       # JDK11
</code></pre>
<h1 id="修饰符与锁">
  修饰符与锁
  <a class="anchor" href="#%e4%bf%ae%e9%a5%b0%e7%ac%a6%e4%b8%8e%e9%94%81">#</a>
</h1>
<h2 id="概念">
  概念
  <a class="anchor" href="#%e6%a6%82%e5%bf%b5">#</a>
</h2>
<pre><code>锁细化                              # 少代码加轻量锁
锁粗化                              # 锁太多时，如行锁变表锁
</code></pre>
<h2 id="synchronized">
  synchronized
  <a class="anchor" href="#synchronized">#</a>
</h2>
<pre><code>实现方式
    JVM没要求实现方式
    早期都是OS调度
    HotSpot
        在对象头(64位)上用2位实现，组合成锁的类型
        锁升级                      # 不比原子类慢，升完不降
            偏向锁, 第一个线程第一次访问只记线程id
            自旋锁，线程争抢时，JDK6旋10次，现在为CPU内核数一半。非公平
            重量级锁，OS调度，线程WAIT。符合执行时间长，线程多的场景
原子性、可见性
可重入                              # 同一个对象同线程可重入
加锁对象
    方法锁和对象锁锁this
    static方法锁和类锁锁class类
    继承时锁的子对象(因为是this), 调super synchronized方法也锁子对象
使用注意
    抛异常立即释放锁，但被锁数据已更新
    不能用的对象
        String常量，可能未知地方锁同一个
        Integer、Long等基本类型, 值变化会生成新对象
    synchronized的属性加final防止赋值
</code></pre>
<h2 id="volatile">
  volatile
  <a class="anchor" href="#volatile">#</a>
</h2>
<pre><code># 用synchronized性能差不多，volatile一般不用
作用
    # 没有原子性，可能写同一值
    变量在线程见可见性
        依靠CPU缓存一致性协议
    禁止指令重排序                  # 用JVM的读写屏障
        
修饰引用类型，内部属性不监控

DCL(Double Check Lock)单例volatile问题
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">volatile</span> C c;    <span style="color:#75715e">// 禁止了创建c指令重排序</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">C</span>(){}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> C <span style="color:#a6e22e">getInstance</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">synchronized</span> (C.<span style="color:#a6e22e">class</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 申请内存(半初始化状态默认0)，成员变量初始化，赋值</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e">// 先赋值未初始化时，线程2判断非空，返回了半初始化状态的对象</span>
</span></span><span style="display:flex;"><span>                        c <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> C();    
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h2 id="cas">
  CAS
  <a class="anchor" href="#cas">#</a>
</h2>
<pre><code># Compare And Set/Swap, 无锁优化, 乐观锁, 自旋
# Unsafe类支持
CPU原语
    cas(V, Expected, NewValue)
        if V == E                   # 无并发值判断问题，原语上加了屏障
        V = New
        else try again or fail
Java
    AtomicInteger
        incrementAndGet()
ABA问题
    # 线程1读取标记, 线程2改过又改回来，线程1判断标记锁住了提交了业务数据
    版本号                          # Java版本号类AtomicStampedReference
LongAdder
    LongAdder每次加数字, LongAccumulator用lambda
    分段锁(CAS)。值分开放数组里, 多线程对应一个item
性能测试
    LongAdder(713) &gt; Atomic(2166) &gt; Synchronized(3129)
</code></pre>
<h2 id="锁">
  锁
  <a class="anchor" href="#%e9%94%81">#</a>
</h2>
<h3 id="aqs">
  AQS
  <a class="anchor" href="#aqs">#</a>
</h3>
<pre><code># AbstractQueueSynchronizer, CLH(Craig, Landin, and Hagersten)队列锁的变种
# 实现方式: CAS，volatile, 模板方法
类图
    AbstractQueueSynchronizer
        Sync
            NonfairSync
方法
    AbstractQueueSynchronizer
        # 一个state和一个双向链表，双向链表看前一结点状态(如持有时等待)
        Node
            volatile Node prev
            volatile Node next
            volatile Thread thread
        VarHandle
            # JDK1.9，保存引用，普通属性原子操作。
            # 相比反射，直接操作二进制码
            get()
            set()
            compareAndSet()         # 原子性
            getAndAdd()             # 原子性
            class C {
                int x = 0;
                private static VarHandle handle;
                static {
                    handle = MethodHandles.lookup().findVarHandle(C.class, &quot;x&quot;, int.class)
                    handle.compareAndSet(c, 0, 1);

                }
            }
        volatile state              # 多态实现
        acquire()
        tryAcquire()                # 模板方法
        acquireQueued()             # 获得
        addWaiter(Node.EXCLUSIVE)   # 放入队列，排他锁或共享锁, CAS设置tail(从前锁整表)
        cancelAcquire()             # status CANCELLED, tail时设置null, 非tail时unpark下一节点
    NonfairSync
        nonfairTryAcquire()
</code></pre>
<h3 id="reentrantlock">
  ReentrantLock
  <a class="anchor" href="#reentrantlock">#</a>
</h3>
<pre><code>    # 可重入锁，CAS实现, state记重入多少次
    new ReentrantLock(true)         # 公平锁
    tryLock(long, TimeUnit)
    lockInterruptibly()             # 响应interrupt()标记
    newCondition()                  # 多一个等待队列

    源码
        调NonfairSync
</code></pre>
<h3 id="countdownlatch">
  CountDownLatch
  <a class="anchor" href="#countdownlatch">#</a>
</h3>
<pre><code>    # 比join()灵活
    new CountDownLatch(4)
    countDown()
    await()
</code></pre>
<h3 id="cyclicbarrier">
  CyclicBarrier
  <a class="anchor" href="#cyclicbarrier">#</a>
</h3>
<pre><code>    # 满了一起放行, 场景如I/O批量消费
    new CyclicBarrier(4, ()-&gt;{})
    await()
</code></pre>
<h3 id="phaser">
  Phaser
  <a class="anchor" href="#phaser">#</a>
</h3>
<pre><code>    # 阶段批量执行过滤
    class MyPhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch(phase) {
                case 0:
                    print(&quot;arrived&quot; + registeredParties);
                    return false;
                case 1:
                    print(&quot;eated&quot; + registeredParties);
                    return false;
                case 2:
                    print(&quot;hugged&quot; + registeredParties);
                    return true;
                default:
                    return true;
            }
        }
    }
    Person implements Runnable {
        private int i;
        public Person(int i) {
            this.i = i;
        }
        public void arrive() {
            phaser.arriveAndAwaitAdvance();
        }
        public void eat() {
            phaser.arriveAndAwaitAdvance();
        }
        public void hug() {
            if (i == 0 || i == 1) {
                phaser.arriveAndAwaitAdvance();
            } else {
                phaser.arriveAndDeregister();
            }
        }

        @Override
        public void run() {
            arrive();
            eat();
            hug();
        }
    }
    phaser = new MyPhaser();
    phaser.bulkRegister(5);
    for (int i = 0; i &lt; 5; i++) {
        new Thread(new Person(i)).start()
    }
</code></pre>
<h3 id="readwritelock">
  ReadWriteLock
  <a class="anchor" href="#readwritelock">#</a>
</h3>
<pre><code>    # 读锁是共享锁，不能写，悲观锁
    # 写锁是排他锁，不能读写
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    void read(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    void write(Lock lock) {
        lock.lock()
        lock.unlock()
    }
    for (int i =0; i&lt;10;i++) {
        new Thread(()-&gt;read(readLock)).start();
    }
    for (int i =0; i&lt;2; i++) {
        new Thread(()-&gt;write(writeLock)).start();
    }
</code></pre>
<h3 id="stampedlock">
  StampedLock
  <a class="anchor" href="#stampedlock">#</a>
</h3>
<pre><code>    # 读时允许写，读完判断不一致再读一遍，乐观锁
</code></pre>
<h3 id="semaphore">
  Semaphore
  <a class="anchor" href="#semaphore">#</a>
</h3>
<pre><code>    # 信号量, 限流同时运行, 用于线程间同步。可设置公平
    Semaphore s = new Semaphore(1, true)
    new Thread(() -&gt; {
        s.acquire();
        s.release()
    })
</code></pre>
<h3 id="exchanger">
  Exchanger
  <a class="anchor" href="#exchanger">#</a>
</h3>
<pre><code>    # 线程间通信, 阻塞交换
    exchange()
</code></pre>
<h3 id="locksupport">
  LockSupport
  <a class="anchor" href="#locksupport">#</a>
</h3>
<pre><code>    # 线程间通信，非锁阻塞，指定线程唤醒
    # 线程启动后，unpark()可以在park()前调用生效, make(chan struct{}, 1)
    Thread t = new Thread(() -&gt; {
        for (int i = 0; i &lt; 10; i++) {
            if (i == 5) {
                LockSupport.park();
            }
        }
    })
    t.start();
    TimeUnit.SECONDS.sleep(1);
    LockSupport.unpark(t);
</code></pre>
<h1 id="线程及线程池">
  线程及线程池
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e5%8f%8a%e7%ba%bf%e7%a8%8b%e6%b1%a0">#</a>
</h1>
<h2 id="使用注意">
  使用注意
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%b3%a8%e6%84%8f">#</a>
</h2>
<pre><code>为什么不用Executors线程池
    用LinkedBlockingQueue超数量OOM
    拒绝策略
    线程命名
</code></pre>
<h2 id="类">
  类
  <a class="anchor" href="#%e7%b1%bb">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    Object
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wait</span>()                              <span style="color:#960050;background-color:#1e0010">#</span> 释放synchronized锁并加入等待队列<span style="color:#960050;background-color:#1e0010">，</span>唤醒后执行需要得到synchronized锁
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">notify</span>()                            <span style="color:#960050;background-color:#1e0010">#</span> 只唤醒<span style="color:#960050;background-color:#1e0010">，</span>不释放当前synchronized锁
</span></span><span style="display:flex;"><span>    Thread
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">currentThread</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">sleep</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">yield</span>()                      <span style="color:#960050;background-color:#1e0010">#</span> 让出CPU, 进Ready队列
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">start</span>()
</span></span><span style="display:flex;"><span>        getState()
</span></span><span style="display:flex;"><span>        join()                              <span style="color:#960050;background-color:#1e0010">#</span> 等待结束
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setDaemon</span>()                         <span style="color:#960050;background-color:#1e0010">#</span> 是否后台
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">setPriority</span>(Thread.<span style="color:#a6e22e">NORM_PRIORITY</span>)   <span style="color:#960050;background-color:#1e0010">#</span> 优先级<span style="color:#960050;background-color:#1e0010">，</span>没有用
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Runnable</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Callable</span>
</span></span><span style="display:flex;"><span>        V <span style="color:#a6e22e">call</span>() <span style="color:#66d9ef">throws</span> Exception
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Future</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">get</span>()
</span></span><span style="display:flex;"><span>        get(<span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>        cancel(<span style="color:#66d9ef">boolean</span>)
</span></span><span style="display:flex;"><span>        isCanceled()
</span></span><span style="display:flex;"><span>        isDone()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">RunnableFuture</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FutureTask</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CompletableFuture</span>         <span style="color:#960050;background-color:#1e0010">#</span> parallel
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">supplyAsync</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">allOf</span>(CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>...)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">static</span> CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">anyOf</span>(CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>...)
</span></span><span style="display:flex;"><span>            T <span style="color:#a6e22e">join</span>()
</span></span><span style="display:flex;"><span>            CompletableFuture<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenApply</span>()
</span></span><span style="display:flex;"><span>            CompletableFuture<span style="color:#f92672">&lt;</span>Void<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">thenAccept</span>(Consumer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ThreadFactory</span>
</span></span><span style="display:flex;"><span>        Thread <span style="color:#a6e22e">newThread</span>(Runnable)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DefaultThreadFactory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Executor</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ExecutorService</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">shutdown</span>()
</span></span><span style="display:flex;"><span>            shutdownNow()
</span></span><span style="display:flex;"><span>            isShutdown()
</span></span><span style="display:flex;"><span>            isTerminated()
</span></span><span style="display:flex;"><span>            awaitTermination(<span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            Future <span style="color:#a6e22e">submit</span>(Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>            Future <span style="color:#a6e22e">submit</span>(Runnable, T)                     <span style="color:#960050;background-color:#1e0010">#</span> 手动设个result
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">submit</span>(Runnable)
</span></span><span style="display:flex;"><span>            invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>            invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>            invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">abstract</span> AbstractExecutorService
</span></span><span style="display:flex;"><span>                RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">newTaskFor</span>(Runnable, T)
</span></span><span style="display:flex;"><span>                RunnableFuture<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">newTaskFor</span>(Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>                T <span style="color:#a6e22e">doInvokeAny</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">boolean</span> timed, <span style="color:#66d9ef">long</span>)
</span></span><span style="display:flex;"><span>                submit()
</span></span><span style="display:flex;"><span>                invokeAll(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 忽略CancellationException, ExecutionException<span style="color:#960050;background-color:#1e0010">，</span>其它异常抛出并取消未完成任务
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">invokeAll</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 忽略CancellationException, ExecutionException, TimeoutException<span style="color:#960050;background-color:#1e0010">，</span>其它异常抛出并取消未完成任务
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">invokeAny</span>(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>)
</span></span><span style="display:flex;"><span>                invokeAny(Collection<span style="color:#f92672">&lt;</span>Callable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>, <span style="color:#66d9ef">long</span>, TimeUnit)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPoolExecutor</span>                    <span style="color:#960050;background-color:#1e0010">#</span> 线程池<span style="color:#f92672">+</span>任务队列
</span></span><span style="display:flex;"><span>                    <span style="color:#960050;background-color:#1e0010">#</span> 任务顺序: 核心线程, 任务队列<span style="color:#960050;background-color:#1e0010">，</span>起新线程<span style="color:#960050;background-color:#1e0010">，</span>拒绝策略
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span>       <span style="color:#960050;background-color:#1e0010">#</span> 用DelayedWorkQueue
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">scheduleAtFixedRate</span>(()<span style="color:#f92672">-&gt;</span>{}, <span style="color:#66d9ef">int</span> initial, <span style="color:#66d9ef">int</span> period, TimeUnit)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForkJoinPool</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">execute</span>(ForkJoinTask)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ScheduledExecutorService</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">[</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledThreadPoolExecutor</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">CompletionService</span>                             <span style="color:#960050;background-color:#1e0010">#</span> 不阻塞全部任务<span style="color:#960050;background-color:#1e0010">，</span>已有结果入队列
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">poll</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExecutorCompletionService</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Executors</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newSingleThreadExecutor</span>()                           <span style="color:#960050;background-color:#1e0010">#</span> 为了用任务队列和生命周期管理
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newCachedThreadPool</span>()                               <span style="color:#960050;background-color:#1e0010">#</span> 超时60s, max为MAX_VALUE, 任务不堆积场景
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newFixedThreadPool</span>()
</span></span><span style="display:flex;"><span>        newScheduledThreadPool()                            <span style="color:#960050;background-color:#1e0010">#</span> AbstractQueuedSynchronizer
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newWorkStealingPool</span>()                               <span style="color:#960050;background-color:#1e0010">#</span> ForkJoinPool, go的M,G,P
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span> 每个线程单独队列, 尾部偷加尾部
</span></span></code></pre></div><h2 id="创建线程">
  创建线程
  <a class="anchor" href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b">#</a>
</h2>
<pre><code># 继承
class MyThread extendws Thread {
    @Override
    public void run(){}
}
new MyThread().start();

# 组合
class MyRun implements Runnable {
    @Override
    public void run(){}
}
new Thread(new MyRun()).start();

# 返回值
class myCall implements Callable&lt;String&gt; {
    @Override
    public String call(){}
}
FutureTask = ft = new FutureTask&lt;String&gt;(new MyCall())
new Thread(ft).start();
ft.get();

# 线程池
// execute无返回值
ExecutorService service = Executors.newCachedThreadPool()
service.execute(()-&gt;{});
// submit有返回值 
Future&lt;String&gt; f = service.submit(new MyCall());
service.shutdown();
</code></pre>
<h2 id="线程状态">
  线程状态
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81">#</a>
</h2>
<pre><code>NEW
RUNNABLE            # 可调度
    READY
    RUNNING
WAITING             # 等待唤醒，忙等待(一直占CPU)
    o.wait()
    t.join()
    LockSupport.park()
    Lock.lock()

    o.notify()
    o.notifyAll()
    LockSupport.unpark()
    Lock.unlock()
TIMED WAITING
    Thread.sleep(time)
    o.wait(time)
    t.join(time)
    LockSupport.parkNanos()
    LockSupport.parkUntil()
BLOCKING            # 阻塞等待（不占CPU但经过OS调度)
    synchronized
TERMINATED
</code></pre>
<h2 id="线程打断">
  线程打断
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%89%93%e6%96%ad">#</a>
</h2>
<pre><code>方法 
    interrupt()                 # 设置打断标记位
    isInterrupted()             # 检查标记位
    static interrupted()        # 检查当前线程标记位，并重置
检测当前线程打断标记的方法      # 抛异常并重置
    Thread.sleep()
    o.wait();
    o.join();
    ReentrantLock
        lockInterruptibly()
不检测当前线程打断标记的方法
    synchronized                # 不是代码实现检测不了
    ReentrantLock
        lock()
强制打断
    Thread
        stop()                  # 已废弃, 立即释放所有锁
        suspend()               # 已废弃，强制暂停，所有锁不释放容易死锁
        resume()                # 已废弃，强制恢复
volatile
    判断数字不准，有同步的时间延迟, interrupt()也有延迟
    也需要代码中判断, 但interrupt()有wait()等系统方法支持
</code></pre>
<h2 id="线程间通信">
  线程间通信
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1">#</a>
</h2>
<h3 id="通知">
  通知
  <a class="anchor" href="#%e9%80%9a%e7%9f%a5">#</a>
</h3>
<pre><code># synchronized wait() notify(), CountDownLatch, LockSupport
volatile List c = new ArrayList();
final Object lock = new Object();
new Thread(() -&gt; {
    synchronized(lock) {
        if (c.size() != 5) {
            lock.wait();
        }
        lock.notify();              // 唤醒t1
    }
}, &quot;t2&quot;).start();

TimeUnit.SECONDS.sleep(1);

new Thread(() -&gt; {
    synchronized(lock) {
        for (int i = 0; i &lt; 10; i++) {
            c.add(new Object());
            if (c.size() == 5) {
                lock.notify();
                lock.wait();        // 让出sychronized锁
            }
        }
    }
}, &quot;t1&quot;).start();
</code></pre>
<h3 id="生产消费">
  生产消费
  <a class="anchor" href="#%e7%94%9f%e4%ba%a7%e6%b6%88%e8%b4%b9">#</a>
</h3>
<pre><code># 优化count可以用CAS加(有ABA问题)
class MyContainer&lt;T&gt; {
    final private List&lt;T&gt; list = new LinkedList&lt;&gt;();
    final private int MAX = 10;
    private int count = 0;

    public synchronized void put(T t) {
        while(list.size() == MAX) {
            this.wait();            // 期间可能有add() 
        }
        list.add(t);
        count++;
        this.notifyAll();           // 应该只唤醒消费者
    }

    public synchronized T get() {
        T t = null;
        while(list.size() == 0) {
            this.wait();
        }
        t = list.removeFirst();
        count--;
        this.notifyAll();           // 应该只唤醒生产者
        return t;
    }
}

# 同步容器, ReentrantLock Condition
private Lock lock = new ReentrantLock();
private Condition producer = lock.newCondition();
private Condition consumer = lock.newCondition();

public void put(T t) {
    try {
        lock.lock();
        while(list.size() == MAX) {
            producer.await();
        }
        list.add(t);
        count++;
        consumer.signalAll();
    } finally {
        lock.unlock();
    }
}

public T get() {
    T t = null;
    try {
        lock.lock();
        while(list.size() == 0) {
            consumer.await();
        }
        t = list.removeFirst();
        count--;
        producer.signalAll();
    } finally {
        lock.unlock();
    }
    return t;
}
</code></pre>
<h1 id="协程">
  协程
  <a class="anchor" href="#%e5%8d%8f%e7%a8%8b">#</a>
</h1>
<pre><code>quasar库                            # 需要设javaagent, 每个fiber生成栈
    fiber =  new Fiber&lt;Void&gt;()
    fiber.start()
</code></pre>
<h1 id="并发api">
  并发API
  <a class="anchor" href="#%e5%b9%b6%e5%8f%91api">#</a>
</h1>
<h2 id="stream">
  Stream
  <a class="anchor" href="#stream">#</a>
</h2>
<pre><code>parallelStream()                    # ForkJoinPool
</code></pre>
<h2 id="threadlocal">
  ThreadLocal
  <a class="anchor" href="#threadlocal">#</a>
</h2>
<pre><code>内部类
    ThreadLocalMap&lt;ThreadLocal, Object&gt;
        # 存在每个线程里。场景如声明式事务拿conn
        # key是弱引用指向ThreadLocal, value是强引用。
    Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        Object value;
        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
方法
    set(T)
内存泄露问题
    ThreadLocal&lt;M&gt; tl = new ThreadLocal();
    tl.set(new M());
    tl = null;
        # threadLocalMap中key弱引用回收, value不回收
    tl.remove();
        # 必需remove()否则内存泄露, threadLocalMap中value强引用，tl回收了也一直存在
</code></pre>
<h2 id="pipedstream">
  PipedStream
  <a class="anchor" href="#pipedstream">#</a>
</h2>
<pre><code># 效率不高
PipedInputStream
    connect(PipedOutputStream)
    read(byte[])
PipedOutputStream
    write(byte[])
</code></pre>
<h2 id="jmh">
  JMH
  <a class="anchor" href="#jmh">#</a>
</h2>
<pre><code># Java Microbenchmark Harness
概念
    Warmup                              # 预热
    Mesurement                          # 总执行次数
    Timeout                             # 每次执行超时时间
    Threads                             # fork线程数
    Benchmark mode                      # 模式
    Benchmark                           # 方法名
环境变量
    TEMP或TMP                           # JHM临时文件存放
使用
    @Benchmark
    @Warmup(iterations = 2, time = 3)           # 执行2次, 每次隔3秒
    @Fork(5)                                    # 多少线程
    @BenchmarkMode(Mode.Throughput)             # 显示每秒多少次
    @Measurement(iterations = 10, time = 3)     # 共测10次, 每次隔3秒
    public void testA() {

    }
</code></pre>
<h2 id="disruptor">
  Disruptor
  <a class="anchor" href="#disruptor">#</a>
</h2>
<pre><code>介绍
    CAS, 环形数组Buffer
        数组用sequence定位修改快,也避免了头尾加锁
        直接覆盖降低GC
            覆盖前有等待策略
    单机MQ
        发布订阅模式
        观察者模式
    EventFactory
        会调工厂提前分配内存, 使用时不new而是修改值，提高效率, 降低GC
使用
    class MyEvent {}
    class MyEventFactory implements EventFactory&lt;MyEvent&gt; {
        @Override
        public MyEvent newInstance() {}
    }
    class MyEventHandler implements EventHandler&lt;MyEvent&gt; {
        @Override
        void onEvent(MyEvent, long sequence, boolean endOfBatch) {}
    }
    class MyExceptionHandler implements ExceptionHandler&lt;MyEvent&gt; {
        @Override
        void handleEventException()
        @Override
        void handleOnStartException()
        @Override
        void handleOnShutdownException()
    }
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(MyEvent::new, 1024, Executors,defaultThreadFactory())
    disruptor = new Disruptor&lt;&gt;(factory, 1024, Executors,defaultThreadFactory(), 
        ProducerType.SINGLE, new BlockingWaitStrategy())
        # 默认ProducerType.MULTI, SINGLE可提高性能不用加锁
    // 消费
    disruptor.handleEventsWith(handler1, handler2)
    disruptor.handleEventsWith((event,seq,end)-&gt;{})
    disruptor.handleExceptionsFor(handler1).with(excptionHandler1)

    disruptor.start()

    // 生产
    ringBuffer = disruptor.getRingBuffer()
    sequence = ringBuffer.next()
    event = ringBuffer.get(sequence)
    event.set(&quot;&quot;)
    ringBuffer.publish(sequence)
    translator = new EventTranslator&lt;&gt;() {
        @Override
        void translateTo(event, sequence) {
            event.set(&quot;&quot;)
        }
    }
    ringBuffer.publishEvent(translator)
    ringBuffer.publishEvent((event,seq, &quot;&quot;) -&gt; event.set(l), &quot;&quot;)
等待策略
    BlockingWaitStrategy                # 阻塞直到再次唤醒
    BusySpinWaitStrategy                # 自旋等待
    SleepingWaitStrategy                # sleep等待
    LiteBlockingWaitStrategy            # 同BlockingWaitStrategy减少加锁次数                
    LiteTimeoutBlockingWaitStrategy     # 同LiteBlockingWaitStrategy加超时            
    PhasedBackoffWaitStrategy
    TimeoutBlockingWaitStrategy         # 同BlockingWaitStrategy加超时                
    YieldingWaitStrategy                # 尝试100然后Thread.yield()
</code></pre>
<h1 id="源码分析">
  源码分析
  <a class="anchor" href="#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90">#</a>
</h1>
<h2 id="threadpoolexecutor">
  ThreadPoolExecutor
  <a class="anchor" href="#threadpoolexecutor">#</a>
</h2>
<pre><code>new ThreadPoolExecutor()                    
    int corePoolSize                    # 核心线程数, 永远存活。可设置参与回收
    int maximumPoolSize                 # 最大线程数
    long keepAliveTime                  # 生存时间
    TimeUnit
    BlockingQueue&lt;Runnable&gt;             # 任务队列
    ThreadFactory                       # 线程工厂, 设线程名
    RejectedExecutionHandler            # 拒绝策略
        Abort                           # 抛异常
        Discard                         # 忽略掉
        DiscardOldest                   # 忽略掉排除最久的
        CallerRuns                      # 调用者线程执行, 再多就阻塞
AtomicInteger ctl
    # 高3位线程池状态，低29位线程数量
void execute()
    判断添加核心线程
    放入队列成功
        拒绝或添加非核心线程
    添加非核心线程失败
        拒绝
boolean addWorker(Runable, boolean)
    线程数量加1
    添加Worker
        加锁
        加线程
        启动
class Worker extends AbstractQueuedSynchronizer implements Runnable
    # 本身是AQS锁, 被多任务(线程)访问
    Tread thread
</code></pre>
<h2 id="forkjoinpool">
  ForkJoinPool
  <a class="anchor" href="#forkjoinpool">#</a>
</h2>
<pre><code>abstract class ForkJoinTask
    ForkJoinTask&lt;V&gt; fork()
    V join()
    abstract class RecursiveAction          # 无返回值
        void compute()
    abstract class RecursiveTask            # 有返回值
例子
    class MyTask extends RecursiveTask&lt;Long&gt; {
        int start;
        int end;
        @Override
        Long compute() {
            if (end - start &lt;= MAX_NUM) {
                return sum
            }
            subTask1 = new MyTask(start, mid)
            subTask2 = new MyTask(mid, end)
            subTask1.fork()
            subTask2.fork()
            return subTask1.join() + subTask2.join();
        }
    }
    fjp = new ForkJoinPool()
    task = new MyTask(0, nums.length)
    fjp .execute(task)
    result = task.join()
</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/commit/1bb58a2a578f674675d9eb7e3d272d9330ca1ccd" title='Last modified by 申文庆 | Jun 17, 2021' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="" />
      <span>Jun 17, 2021</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/tree/master/content/content/docs/pl/java/juc.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a>
      <ul>
        <li><a href="#cpu">CPU</a>
          <ul>
            <li><a href="#cpu缓存一致性协议">CPU缓存一致性协议</a></li>
          </ul>
        </li>
        <li><a href="#os">OS</a></li>
        <li><a href="#jvm">JVM</a>
          <ul>
            <li><a href="#内存屏障">内存屏障</a></li>
            <li><a href="#乱序执行指令重排序">乱序执行(指令重排序)</a></li>
          </ul>
        </li>
        <li><a href="#unsafe类">Unsafe类</a></li>
      </ul>
    </li>
    <li><a href="#修饰符与锁">修饰符与锁</a>
      <ul>
        <li><a href="#概念">概念</a></li>
        <li><a href="#synchronized">synchronized</a></li>
        <li><a href="#volatile">volatile</a></li>
        <li><a href="#cas">CAS</a></li>
        <li><a href="#锁">锁</a>
          <ul>
            <li><a href="#aqs">AQS</a></li>
            <li><a href="#reentrantlock">ReentrantLock</a></li>
            <li><a href="#countdownlatch">CountDownLatch</a></li>
            <li><a href="#cyclicbarrier">CyclicBarrier</a></li>
            <li><a href="#phaser">Phaser</a></li>
            <li><a href="#readwritelock">ReadWriteLock</a></li>
            <li><a href="#stampedlock">StampedLock</a></li>
            <li><a href="#semaphore">Semaphore</a></li>
            <li><a href="#exchanger">Exchanger</a></li>
            <li><a href="#locksupport">LockSupport</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#线程及线程池">线程及线程池</a>
      <ul>
        <li><a href="#使用注意">使用注意</a></li>
        <li><a href="#类">类</a></li>
        <li><a href="#创建线程">创建线程</a></li>
        <li><a href="#线程状态">线程状态</a></li>
        <li><a href="#线程打断">线程打断</a></li>
        <li><a href="#线程间通信">线程间通信</a>
          <ul>
            <li><a href="#通知">通知</a></li>
            <li><a href="#生产消费">生产消费</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#协程">协程</a></li>
    <li><a href="#并发api">并发API</a>
      <ul>
        <li><a href="#stream">Stream</a></li>
        <li><a href="#threadlocal">ThreadLocal</a></li>
        <li><a href="#pipedstream">PipedStream</a></li>
        <li><a href="#jmh">JMH</a></li>
        <li><a href="#disruptor">Disruptor</a></li>
      </ul>
    </li>
    <li><a href="#源码分析">源码分析</a>
      <ul>
        <li><a href="#threadpoolexecutor">ThreadPoolExecutor</a></li>
        <li><a href="#forkjoinpool">ForkJoinPool</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












