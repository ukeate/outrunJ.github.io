<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="基础 # 分层 视图层 jsp 控制层 servlet 业务层 过滤数据 manager层 封装第三方，service能力下沉，dao中间件 数据访问层对象 封装对象 数据库 java web 13种技术 JDBC Java Database Connectivty JNDI Java Name and Directory Interface EJB Enterprise JavaBean RMI Remote Method Invoke Java IDL/CORBA JSP Java Server Pages Java Servlet XML Extensible Markup Language JMS Java Message Service JTS Java Transaction Service JTA Java Transaction Architecture JavaMail JAF JavaBeans Activation Framework jsp # 基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层 域对象 pageContext # 当前页面有效 request # 一次请求范围 session # 会话 application context # 同一服务器 内置对象 Request Response Session Out # 输出流 PageContext # context Page # jsp的this Exception # &lt;%@ page isErrorPage=&quot;true&quot;%&gt; 时使用，显示异常信息 Application # 服务器 Config # 服务器配置 jsp-el表达式 # ${ } 11个内置对象 pageContext // pageContext page // map （相当于pageScope，不过写法上省略了Scope） requestScope // map sessionScope // map applicationScope // map param // map ,用${param.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="JavaWeb" />
<meta property="og:description" content="基础 # 分层 视图层 jsp 控制层 servlet 业务层 过滤数据 manager层 封装第三方，service能力下沉，dao中间件 数据访问层对象 封装对象 数据库 java web 13种技术 JDBC Java Database Connectivty JNDI Java Name and Directory Interface EJB Enterprise JavaBean RMI Remote Method Invoke Java IDL/CORBA JSP Java Server Pages Java Servlet XML Extensible Markup Language JMS Java Message Service JTS Java Transaction Service JTA Java Transaction Architecture JavaMail JAF JavaBeans Activation Framework jsp # 基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层 域对象 pageContext # 当前页面有效 request # 一次请求范围 session # 会话 application context # 同一服务器 内置对象 Request Response Session Out # 输出流 PageContext # context Page # jsp的this Exception # &lt;%@ page isErrorPage=&quot;true&quot;%&gt; 时使用，显示异常信息 Application # 服务器 Config # 服务器配置 jsp-el表达式 # ${ } 11个内置对象 pageContext // pageContext page // map （相当于pageScope，不过写法上省略了Scope） requestScope // map sessionScope // map applicationScope // map param // map ,用${param." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/docs/pl/java/javaweb/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2018-10-09T08:48:07+08:00" />
<meta property="article:modified_time" content="2022-04-23T22:18:41+08:00" />

<title>JavaWeb | outrun的笔记</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css" integrity="sha256-RhgbyTN1upMgJudTs3xA5v&#43;LsWqe93DHi8xmPkV3sbo=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.9def807346ed076476e2de27242a6bc2aa84967096bd9c162c291236fbaafe1e.js" integrity="sha256-ne&#43;Ac0btB2R24t4nJCprwqqElnCWvZwWLCkSNvuq/h4=" crossorigin="anonymous"></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-154152836-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>outrun的笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  <ul>
<li><a href="/"><strong>介绍</strong></a></li>
<li><a href="/docs/architect"><strong>架构</strong></a>
<ul>
<li><a href="/docs/architect/method"><strong><strong>规划与方法</strong></strong></a>
<ul>
<li><a href="/docs/architect/method/product_plan">产品规划</a></li>
<li><a href="/docs/architect/method/advice_plan">咨询规划</a></li>
<li><a href="/docs/architect/method/test_plan">测试规划</a></li>
<li><a href="/docs/architect/method/architect">服务治理</a></li>
<li><a href="/docs/architect/method/ops_plan">运维规划</a></li>
<li><a href="/docs/architect/method/project_plan">项目规划</a></li>
<li><a href="/docs/architect/method/code_plan">代码规划</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy"><strong><strong>战略技术方案</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/middle_platform"><strong><strong>中台</strong></strong></a></li>
<li><a href="/docs/architect/strategy/datalake"><strong><strong>湖仓一体</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/big_data/ecology">生态体系</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy/ai"><strong><strong>人工智能</strong></strong></a></li>
<li><a href="/docs/architect/strategy/iot"><strong><strong>物联网</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/iot/framework">框架</a></li>
</ul>
</li>
<li><a href="/docs/architect/strategy/block_chain"><strong><strong>区块链</strong></strong></a></li>
<li><a href="/docs/architect/strategy/meta"><strong><strong>元宇宙</strong></strong></a>
<ul>
<li><a href="/docs/architect/strategy/meta/media">媒体</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/architect/project"><strong><strong>工程设计原则</strong></strong></a>
<ul>
<li><a href="/docs/architect/project/ddd">DDD</a></li>
<li><a href="/docs/architect/project/frontend">前端设计</a></li>
</ul>
</li>
<li><a href="/docs/architect/code"><strong><strong>代码原则</strong></strong></a>
<ul>
<li><a href="/docs/architect/code/design_mode">设计模式</a></li>
<li><a href="/docs/architect/code/security">安全/协议</a></li>
</ul>
</li>
<li><a href="/docs/architect/manage"><strong><strong>管理</strong></strong></a>
<ul>
<li><a href="/docs/architect/manage/organize"><strong><strong>组织</strong></strong></a>
<ul>
<li><a href="/docs/architect/manage/organize/people">人员</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/architect/summary">这些年我做过的技术</a></li>
</ul>
</li>
<li><a href="/docs/tool"><strong>工具</strong></a>
<ul>
<li><a href="/docs/tool/linux"><strong><strong>Linux系统</strong></strong></a>
<ul>
<li><a href="/docs/tool/linux/linux_tool">Linux工具</a></li>
<li><a href="/docs/tool/linux/scene">Linux场景</a></li>
<li><a href="/docs/tool/linux/linux_program">Linux系统编程</a></li>
</ul>
</li>
<li><a href="/docs/tool/ops"><strong><strong>运维工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/ops/monitor">监控指标</a></li>
<li><a href="/docs/tool/ops/docker">Docker</a></li>
<li><a href="/docs/tool/ops/k8s">Kubernetes</a></li>
</ul>
</li>
<li><a href="/docs/tool/develop"><strong><strong>开发工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/develop/vim">Vim</a></li>
<li><a href="/docs/tool/develop/eclipse">Eclipse</a></li>
<li><a href="/docs/tool/develop/apple">Apple</a></li>
<li><a href="/docs/tool/develop/jetbrains">Jetbrains</a></li>
</ul>
</li>
<li><a href="/docs/tool/test"><strong><strong>测试工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/test/debug">代码调试</a></li>
</ul>
</li>
<li><a href="/docs/tool/product"><strong><strong>产品工具</strong></strong></a>
<ul>
<li><a href="/docs/tool/product/enterprise_system">企业级系统</a></li>
<li><a href="/docs/tool/product/framework">服务与框架</a></li>
</ul>
</li>
<li><a href="/docs/tool/physics"><strong><strong>实物工具</strong></strong></a></li>
</ul>
</li>
<li><a href="/docs/middleware"><strong>中间件</strong></a>
<ul>
<li><a href="/docs/middleware/container"><strong><strong>容器</strong></strong></a>
<ul>
<li><a href="/docs/middleware/container/nginx">Nginx</a></li>
<li><a href="/docs/middleware/container/nodejs">Node.js</a></li>
</ul>
</li>
<li><a href="/docs/middleware/distributed"><strong><strong>分布式</strong></strong></a>
<ul>
<li><a href="/docs/middleware/distributed/spring_cloud">Spring Cloud</a></li>
</ul>
</li>
<li><a href="/docs/middleware/library"><strong><strong>库</strong></strong></a>
<ul>
<li><a href="/docs/middleware/library/hibernate">Hibernate</a></li>
</ul>
</li>
<li><a href="/docs/middleware/library_frontend"><strong><strong>前端库</strong></strong></a>
<ul>
<li><a href="/docs/middleware/library_frontend/jquery">JQuery</a></li>
<li><a href="/docs/middleware/library_frontend/bootstrap">Bootstrap</a></li>
<li><a href="/docs/middleware/library_frontend/angular">Angular</a></li>
<li><a href="/docs/middleware/library_frontend/react">React</a></li>
<li><a href="/docs/middleware/library_frontend/threejs">Three.js</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/db"><strong>数据库</strong></a>
<ul>
<li><a href="/docs/db/mongodb">MongoDB</a></li>
<li><a href="/docs/db/mysql">Mysql</a></li>
<li><a href="/docs/db/oracle">Oracle</a></li>
<li><a href="/docs/db/postgresql">PgSQL</a></li>
<li><a href="/docs/db/redis">Redis</a></li>
<li><a href="/docs/db/elasticsearch">Elasticsearch</a></li>
</ul>
</li>
<li><a href="/docs/pl"><strong>语言</strong></a>
<ul>
<li><a href="/docs/pl/principle">原理</a></li>
<li><a href="/docs/pl/java"><strong><strong>Java</strong></strong></a>
<ul>
<li><a href="/docs/pl/java/jvm">JVM</a></li>
<li><a href="/docs/pl/java/collection">Java Collection</a></li>
<li><a href="/docs/pl/java/juc">Java Concurrent</a></li>
<li><a href="/docs/pl/java/spring">Spring</a></li>
<li><a href="/docs/pl/java/rxjava">RxJava</a></li>
<li><a href="/docs/pl/java/javaweb">JavaWeb</a></li>
</ul>
</li>
<li><a href="/docs/pl/go">GO</a></li>
<li><a href="/docs/pl/js">JS</a></li>
<li><a href="/docs/pl/python">Python</a></li>
<li><a href="/docs/pl/haskell">Haskell</a></li>
<li><a href="/docs/pl/clojure">Clojure</a></li>
<li><a href="/docs/pl/markup_language"><strong><strong>标记语言</strong></strong></a>
<ul>
<li><a href="/docs/pl/markup_language/html">HTML</a></li>
<li><a href="/docs/pl/markup_language/css">CSS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/basic"><strong>基本功</strong></a>
<ul>
<li><a href="/docs/basic/algorithm"><strong><strong>算法</strong></strong></a>
<ul>
<li><a href="/docs/basic/algorithm/math">数学</a></li>
<li><a href="/docs/basic/algorithm/thought">思想</a></li>
<li><a href="/docs/basic/algorithm/data_structure">数据结构</a></li>
</ul>
</li>
<li><a href="/docs/basic/computer"><strong><strong>计算机</strong></strong></a>
<ul>
<li><a href="/docs/basic/computer/principle">原理</a></li>
<li><a href="/docs/basic/computer/performance">性能</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/docs/cache"><strong>Cache</strong></a>
<ul>
<li><a href="/docs/cache/ops">运维</a></li>
<li><a href="/docs/cache/template">模板配置</a></li>
<li><a href="/docs/cache/soft_arch">软考</a></li>
</ul>
</li>
<li><a href="/docs/misc"><strong>Misc</strong></a></li>
<li><a href="/posts"><strong>Posts</strong></a></li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>JavaWeb</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a>
      <ul>
        <li><a href="#jsp">jsp</a>
          <ul>
            <li><a href="#jsp-el表达式">jsp-el表达式</a></li>
            <li><a href="#jsp-taglib标签库">jsp-taglib标签库</a></li>
            <li><a href="#jsp动作标签">jsp动作标签</a></li>
            <li><a href="#jsp函数">jsp函数</a></li>
            <li><a href="#jsp基本">jsp基本</a></li>
            <li><a href="#jsp验证码">jsp验证码</a></li>
            <li><a href="#自定义标签">自定义标签</a></li>
          </ul>
        </li>
        <li><a href="#jdbc">jdbc</a></li>
        <li><a href="#i18n">i18n</a></li>
      </ul>
    </li>
    <li><a href="#中间件">中间件</a>
      <ul>
        <li><a href="#监听器">监听器</a></li>
        <li><a href="#过滤器">过滤器</a></li>
        <li><a href="#struts2">struts2</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="基础">
  基础
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80">#</a>
</h1>
<pre><code>分层
    视图层         jsp
    控制层         servlet
    业务层         过滤数据
    manager层     封装第三方，service能力下沉，dao中间件
    数据访问层对象  封装对象
    数据库
java web 13种技术
    JDBC        Java Database Connectivty
    JNDI        Java Name and Directory Interface
    EJB        Enterprise JavaBean
    RMI        Remote Method Invoke
    Java IDL/CORBA
    JSP        Java Server Pages
    Java Servlet
    XML        Extensible Markup Language
    JMS        Java Message Service
    JTS        Java Transaction Service
    JTA        Java Transaction Architecture
    JavaMail
    JAF        JavaBeans Activation Framework
</code></pre>
<h2 id="jsp">
  jsp
  <a class="anchor" href="#jsp">#</a>
</h2>
<pre><code>基于servlet, html页面嵌java代码，第一次访问时解释成servlet。位于视图层
域对象
    pageContext     # 当前页面有效
    request         # 一次请求范围
    session         # 会话
    application context     # 同一服务器
内置对象
    Request
    Response
    Session
    Out             # 输出流
    PageContext     # context
    Page            # jsp的this
    Exception       # &lt;%@ page isErrorPage=&quot;true&quot;%&gt; 时使用，显示异常信息
    Application     # 服务器
    Config          # 服务器配置
</code></pre>
<h3 id="jsp-el表达式">
  jsp-el表达式
  <a class="anchor" href="#jsp-el%e8%a1%a8%e8%be%be%e5%bc%8f">#</a>
</h3>
<pre><code>${  }
11个内置对象
    pageContext    // pageContext
    page        // map （相当于pageScope，不过写法上省略了Scope）
    requestScope    // map
    sessionScope    // map
    applicationScope    // map
    param        // map        ,用${param.name}的形式得到传递的参数
    paramValues    // map&lt;String,String []&gt;
    header        // map
    hearderValues    // map&lt;String, String []&gt;
    cookie        // map
    initParam        // map

语法
${list[0]}&lt;br&gt;
    ${map.mapteststring}&lt;br&gt;
    ${map[mapkey]}&lt;br&gt;
    ${map['mapteststring']}&lt;br&gt;
    ${request }
    ${pageContext.request.contextPath }&lt;br&gt;        # el表达式中访问内置对象
    ${requestScope.aaa }                # 访问内置对象requestScope，得到request作用域中的aaa元素
    ${pageContext.servletContext.contextPath }&lt;br&gt;
    ${param}&lt;br&gt;
    ${paramValues['a'] }&lt;br&gt;
    ${paramValues['a'][0] }
    ${paramValues['a'][1] }
    ${paramValues['a'][2] }&lt;br&gt;
    ${empty novalue}&lt;br&gt;
    ${1&gt;2?&quot;yes&quot; : &quot;no&quot;}&lt;br&gt;

        #  . 与 [] 可以替换使用，但有两点需要注意
        1  .1不行，但是[1]可以
        2    1&gt; map[&quot;key&quot;]    是取map中&quot;key&quot;对应的值
            2&gt; map[key]是先从作用域中取得key的字符串如&quot;aaa&quot;,再取map中&quot;aaa&quot;对应的值
            3&gt; .key    相当于1&gt;中的介绍，是取map中&quot;key&quot;对应的值
            4&gt; .是不能相当于2&gt;中的介绍那样使用的
比较符${ }中使用
    empty
    not empty
    三元式（?:）
    简单的算术运算
</code></pre>
<h3 id="jsp-taglib标签库">
  jsp-taglib标签库
  <a class="anchor" href="#jsp-taglib%e6%a0%87%e7%ad%be%e5%ba%93">#</a>
</h3>
<pre><code>jstl标签库1.1 或1.2
    标签库1.1中需要    jstl.jar 与 standard.jar 库
可放入域scope的类型
    page
    request
    session
    application
    functions
el表达式级使用，其它都标签级使用
functions
    &lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt;
    ${fn:contains(&quot;gzitcast&quot;, &quot;itcast&quot;) }  &lt;br&gt;
    ${fn:containsIgnoreCase(&quot;gzitcast&quot;, &quot;ITCAST&quot;) }  &lt;br&gt;
    ${fn:endsWith(&quot;gzitcast&quot;, &quot;st&quot;) } &lt;br&gt;
    ${fn:indexOf(&quot;gzitcsat&quot;, &quot;cs&quot;) } &lt;br&gt;
    ${fn:join(arr, &quot;-&quot;) } &lt;br&gt;
    ${fn:length(&quot;gzitcast&quot;) } &lt;br&gt;
    ${fn:replace(&quot;gzitcast&quot;, &quot;gz&quot;, &quot;广州&quot;) } &lt;br&gt;
    ${fn:split(&quot;gz,it,cast&quot;, &quot;,&quot;) } &lt;br&gt;
    ${fn:startsWith(&quot;gzitcsat&quot;, &quot;gz&quot;) } &lt;br&gt;
    ${fn:substring(&quot;gzitcsat&quot;, 3, 8) } &lt;br&gt;
    ${fn:substringAfter(&quot;gzitcsat&quot;, &quot;cs&quot;) } &lt;br&gt;
    ${fn:substringBefore(&quot;gzitcsat&quot;, &quot;cs&quot;) } &lt;br&gt;
    ${fn:toLowerCase(&quot;gziTCsat&quot;) } &lt;br&gt;
    ${fn:toUpperCase(&quot;gziTCsat&quot;) } &lt;br&gt;
    ${fn:trim(&quot;  gzitcsat  &quot;) } &lt;br&gt;
    &lt;%-- 对字符串中进行转义处理，如：会把&quot;&lt;&quot;替换为&quot;&amp;lt;&quot;，把&quot;&gt;&quot;替换为&quot;&amp;gt;&quot; --%&gt;
    ${fn:escapeXml(&quot;&lt;h3&gt;gzitcsat&lt;/h3&gt;&quot;) } &lt;br&gt;
core
    所有标签：
        out
        set
        remove
        catch
        if
        choose
        when
        otherwise
        forEach
        url
        param
        redirect
        forTokens
        import

    &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/cores&quot;%&gt;
    &lt;c:out var=&quot;&quot;    default=&quot;&quot;    escapeXml=&quot;true&quot;&gt;    &lt;%--    放过xml过滤，让它显示，默认不显示    --%&gt;
    -------------------------------------
    scope方式
    &lt;c:set    var=&quot;&quot;    value=&quot;&quot;    scope=&quot;&quot;&gt;
    target方式    &lt;%--    这个放入page作用域中的map值    --%&gt;
    &lt;%  Map map = new HashMap();  %&gt;
    &lt;c:set    property=&quot;key1&quot;    value=&quot;key1value&quot;    target=&quot;&lt;%=map%&gt;&quot;
    &lt;%  pageContext.setAttribute(&quot;map&quot;, map);  %&gt;
    &lt;c:out    value=&quot;${map[key2]}&quot;

    -------------------------------------
    &lt;c:catch var=&quot;e&quot;&gt;&lt;/c:catch&gt;
    &lt;c:out value='&lt;%= ((Exception)pageContext.getAttribute(&quot;e&quot;,PageContext.PAGE_SCOPE)).getMessage() %&gt;'&gt;&lt;/c:out&gt;
    -------------------------------------
    &lt;c:remove    var=&quot;&quot;    scope=&quot;&quot;&gt;
    -------------------------------------
    &lt;c:if test=&quot;${not empty    }&quot; scope=&quot;&quot;    var=&quot;&quot;&gt;
    -------------------------------------
    &lt;%--    if...else标签    --%&gt;
    &lt;c:choose&gt;
    &lt;c:when test=&quot;&quot;&gt;
    &lt;c:otherwise&gt;
    -------------------------------------
    &lt;c:forEach  begin=&quot;&quot;    end=&quot;&quot;    step=&quot;&quot;    items=&quot;&quot;    var=&quot;&quot;    varStatus=&quot;state&quot;&gt;          &lt;%--    varStatus中的函数有first last count begin end    --%&gt;
    &lt;tr bgcolor='${state.count%2 == 0? &quot;red&quot; : &quot;pink&quot;}' &gt;
    &lt;/c:forEach&gt;

    varStatus可用的函数
        current    // 当前这次迭代的项
        index    // 索引
        count    // 计数
        first        // 第一个
        last        // 最后一个
        begin    // begin属性值
        end        // end 属性值
        step        // step属性值
    -------------------------------------
    uri 代表所有协议路径

    &lt;c:url    var=&quot;itcast&quot;    value=&quot;http://www.itcast.cn&quot;    scope=&quot;page&quot;    context=&quot;&quot;    &gt;    &lt;%--    context 是整个网站    --%&gt;
    &lt;c:param    name=&quot;name&quot;    value=&quot;中文&quot;&gt;    &lt;%--    这样传参数有编码    --%&gt;

    如果value值为&quot;/&quot; 则加入context属性提供上下文名称，如果context也被省略，就使用当前servlet的上下文名称
    -------------------------------------
    &lt;c:redirect    url=&quot;${itcast}&quot;    context=&quot;&quot;    &gt;
    -------------------------------------
    &lt;c:set    var=&quot;name&quot;    value=&quot;xx,xxx,xxx,xx&quot;    scope=&quot;request&quot;    &gt;
    &lt;c:forTokens    items=&quot;${name}&quot;    delims=&quot;,&quot;    begin=&quot;&quot;    end=&quot;&quot;    step=&quot;1&quot;    var=&quot;name&quot;    varStatus=&quot;&quot;    &gt;    &lt;%--切割字符串--%&gt;
    -------------------------------------
    &lt;c:import    url=&quot;/publics/head.jsp&quot;    &gt;    &lt;%--动态包含，引入公共文件--%&gt;&lt;%--网站publics文件夹--%&gt;


sql标签库
    # 以前没有mvc模式的时候，通过页面访问数据库时用的，现在不用
    引入
        &lt;%@ taglib prefix=&quot;sql&quot; uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; %&gt;
    设置数据源
        &lt;sql:setDataSource dataSource=”dataSource”[var=”name”]
                            [scope=”page|request|session|application”]/&gt;
    jdbc连接
        &lt;sql:setDataSource driver=”driverClass” url=”jdbcURL”
                user=”username”
                password=”pwd”
                [var=”name”]
                [scope=”page|request|session|application”]/&gt;

    JSTL提供了&lt;sql:query&gt;、&lt;sql:update&gt;、&lt;sql:param&gt;、&lt;sql:dateParam&gt;和&lt;sql:transaction&gt;这5个标签
        1.query:
        query必需指定数据源
        &lt;sql:query sql=”sqlQuery” var=”name” [scope=”page|request|session|application”]
        [dataSource=”dateSource”]
        [maxRow=”maxRow”]
        [startRow=”starRow”]/&gt;
        或
        &lt;sql:query var=”name” [scope=”page|request|session|application”]
        [dataSource=”dateSource”]
        [maxRow=”maxRow”]    # 设定最多可以暂存数据的长度
        [startRow=”starRow”]    # 设定从哪一行开始
                &gt;
                sqlQuery
                &lt;/sql:query&gt;

        结果集的参数
            rowCount    # 结果集中的记录总数
            rowsByIndex    # 以数字为作索引的查询结果
            columnNames    # 字段名称数组
            Rows    # 以字段为索引查询的结果
            limitedByMaxRows    # 是否设置了maxRows属性来限制查询记录的数量
                limitedByMaxRows用来判断程序是否收到maxRows属性的限制。
                并不是说设定了maxRows属性，得到结果集的limitedByMaxRows的属性都为true，
                当取出的结果集小于maxRows时，则maxRows没有对结果集起到作用此时也为false。
                例如可以使用startRow属性限制结果集的数据量。

        2.update:
        &lt;/sql:update&gt;
        &lt;sql:update sql=”SQL语句” [var=”name”] [scope=”page|request|session|application”]
                [dateSource=”dateSource”]/&gt;
        或
    &lt;sql:update [var=”name”] [scope=”page|request|session|application”]
                [dateSource=”dateSource”]
                    &gt;
                    SQL语句
        参数说明
            dataSource    # 数据源对象
            其它与query一样

        3.param 参数设置
        &lt;sql:param value=”value”/&gt;
        或
        &lt;sql:param&gt;
            Value
            &lt;/sql:param&gt;

        4.dataParam 标签    # 用于为SQL标签填充日期类型的参数值

        参数说明
            value：java.util.Date类型的参数。
            type属性：指定填充日期的类型timestamp（全部日期和时间）、time（填充的参数为时间）、date（填充的参数为日期）。

        5.transaction 标签

        &lt;sql:transaction [dataSource=”dataSource”]
            [isolation=”read_committed|read_uncommitted|repeatable|serializable”]
            &gt;
            &lt;sql:query&gt;
            &lt;sql:uptade&gt;
        &lt;/sql:transation&gt;

xml标签库
    核心操作
    out    # 主要用来取出XML中的字符串。
        属性
        select    # XPath语句
        escapeXml    # 是否转换特殊字符

    parse    # 用来解析xml文件
        属性
        doc    # XML文件
        systemId    # XML文件的URL
        filter    # XMLFilter过滤器
        varDom    # 储存解析后的XML文件
        scopeDom    # varDom的范围

    set    # 将从XML文件取得的内容储存至属性范围中
        属性
        select    # XPath语句

    流程控制
    if
    choose when otherwise
        属性
        select    # XPath语句
    文件转换
    &lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]
        [result=”result”]
        [var=”name”]
        [scope=”scopeName”]
        [xsltSystemId=”xsltsystemid”]/&gt;
    或
    &lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]
        [result=”result”]
        [var=”name”]
        [scope=”scopeName”]
        [xsltSystemId=”xsltsystemid”]
        &gt;
        &lt;x:param/&gt;
        &lt;/x:transform&gt;
    或
    &lt;x:transform doc=”xmldoc” xslt=”XSLTStytlesheet”[docSystemId=”xmlsystemid”]
        [result=”result”]
        [var=”name”]
        [scope=”scopeName”]
        [xsltSystemId=”xsltsystemid”]
        &gt;

        属性
        doc    # 指定xml文件来源
        xslt    # 转化xml的样式模板
        docSystemId    # xml文件的URI
        xsltSystemId    # xslt文件的URI
        result    # 用来存储转换后的结果对象

国际化
    &lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
    国际化标签
    1.setLocale    # 设置一个全局的地区代码,设定的是本地的环境
        中文－大陆:&lt;fmt:setLocale value=&quot;zh_CN&quot;/&gt; &lt;fmt:formatDate value=&quot;${todayValue}&quot;/&gt;&lt;br&gt;

    2.requestEncoding    # 设置统一的请求编码
        &lt;fmt:requestEncoding value=&quot;GB2312&quot;/&gt;

    信息显示标签
    1.&lt;fmt:bundle&gt; 设置临时要读取的资源文件
    2.&lt;fmt:message&gt;  通过key取得value
    3.&lt;fmt:setBundle&gt;  设置一个要读取的全局的资源文件
        如
        &lt;fmt:setBundle basename=&quot;applicationMessage&quot; var=&quot;MyResourse&quot;/&gt;    # 绑定了名为applicationMessage_zh_CN.properties一类 的文件
        &lt;fmt:bundle basename=&quot;MyResourse&quot; prefix=&quot;label.&quot;&gt;
        &lt;fmt:message key=&quot;backcolor&quot; bundle=&quot;${applicationBundle}&quot;/&gt;
        &lt;fmt:message key=&quot;fontcolor&quot; /&gt;
    &lt;/fmt:bundle&gt;


    数字及日期格式化标签
    1.&lt;fmt:formatDate&gt;  日期的格式化
        属性
        value:格式化的日期，该属性的内容应该是 java.util.Date 类型的实例
        type:格式化的类型
        pattern:格式化模式
        timeZone:指定格式化日期的时区
    2.&lt;fmt:parseDate&gt;  解析日期
        属性
        value:将被解析的字符串
        type:解析格式化的类型
        pattern:解析格式化模式
        parseLocale:以本地化的形式来解析字符串，该属性的内容为 String 或 java.util.Locale 类型的实例
        timeZone:指定解析格式化日期的时区
    3.&lt;fmt:formatNumber&gt;  数字格式化
        属性
        value:格式化的数字,该数值可以是 String 类型或 java.lang.Number 类型的实例
        type:格式化的类型,可能值包括:currency（货币）、number（数字）和percent（百分比）
        pattern:格式化模式
        maxIntegerDigits:指定格式化结果的最大值
        minIntegerDigits:指定格式化结果的最小值
        maxFractionDigits:指定格式化结果的最大值，带小数
        minFractionDigits:指定格式化结果的最小值，带小数
        如
        &lt;fmt:formatNumber value=&quot;1000.888&quot; type=&quot;currency&quot; var=&quot;money&quot;/&gt;

    4.&lt;fmt:parseNumber&gt;  解析数字
        属性
        value:将被解析的字符串
        type:解析格式化的类型
        pattern:解析格式化模式
        如
        &lt;fmt:parseNumber value=&quot;15%&quot; type=&quot;percent&quot; var=&quot;num&quot;/&gt;
    5.&lt;fmt:setTimeZone&gt;  标签则允许将时区设置保存为一个变量，在之后的工作可以根据该变量来进行属性描述
        属性
        value    # 时区的设置
        var    # 用于保存时区为一个变量
    6.&lt;fmt:timeZone&gt;  标签将使得在其标签体内的工作可以使用该时区设置
        属性
        value    # 时区的设置
    7.&lt;fmt:param&gt; 标签:用于参数传递
        如：在MyResourse.properties文件中,有一个索引值如下(其中,{0}代表占位符):
        Str2=Hi,{0}
        则,使用&lt;fmt:param&gt;标签传入值如下:
        &lt;fmt:bundle basename=&quot;MyResourse&quot;&gt;
            &lt;fmt:message key=&quot;Str2&quot;&gt;
            &lt;fmt:param value=&quot;张三&quot; /&gt;
            &lt;/fmt:message&gt;
        &lt;/fmt:bundle&gt;
        也可以在资源文件中指定参数的类型:
        如:在MyResourse.properties文件中,有一个索引值如下:
        Str3={0,date}
        则,使用&lt;fmt:param&gt;标签传入值如下:
        &lt;% request.setAttribute(&quot;now&quot;,new Date()); %&gt;
        &lt;fmt:bundle basename=&quot;MyResourse&quot;&gt;
            &lt;fmt:message key=&quot;Str3&quot;&gt;
            &lt;fmt:param value=&quot;${now}&quot; /&gt;
            &lt;/fmt:message&gt;
        &lt;/fmt:bundle&gt;
</code></pre>
<h3 id="jsp动作标签">
  jsp动作标签
  <a class="anchor" href="#jsp%e5%8a%a8%e4%bd%9c%e6%a0%87%e7%ad%be">#</a>
</h3>
<pre><code>在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。

一、Include行为

    &lt;jsp:include&gt;标签表示动态包含一个静态的或者动态的文件。

    语法：
    &lt;jsp:include page=&quot;path&quot; flush=&quot;true&quot; /&gt;
    or
    &lt;jsp:include page=&quot;path&quot; flush=&quot;true&quot;&gt;
    &lt;jsp:param name=&quot;paramName&quot; value=&quot;paramValue&quot; /&gt;
    &lt;/jsp:include&gt;

    注：
    1、page=&quot;path&quot; 为相对路径，或者代表相对路径的表达式。
    2、flush=&quot;true&quot; 必须使用flush为true，它默认值是false。
    3、&lt;jsp:param&gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&lt;jsp:param&gt;来传递多个参数给动态文件。
    4、&lt;jsp:include page=&quot;&quot; flush=&quot;&quot;&gt; 与&lt;%@ include file=&quot;&quot;%&gt;的区别：
        &lt;jsp:include &gt;是动态包含&lt;%@include%&gt;是静态包含。
        # jsp页面是把include指令元素（&lt;%@ include file=&quot;&quot;%&gt;）所指定的页面的实际内容（也就是代码段）加入到引入它的jsp页面中,合成一个文件后被jsp容器将它转化成servlet。
        ## 可以看到这时会产生一个临时class文件和一个servlet源文件。
        ## 而动作元素（&lt;jsp:include page=&quot;&quot;/&gt;）是在请求处理阶段引入的，会被JSP容器生成两个临时class文件和两个servlet原文件。
        ## 而引入的只是servlet的输出结果，即JspWriter对象的输出结果，而不是jsp的源代码。

二、Forward行为

    &lt;jsp:forward&gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。

    语法：
    &lt;jsp:forward page=&quot;path&quot;} /&gt;
    or
    &lt;jsp:forward page=&quot;path&quot;} &gt;
    &lt;jsp:param name=&quot;paramName&quot; value=&quot;paramValue&quot; /&gt;……
    &lt;/jsp:forward&gt;

    注：
    1、page=&quot;path&quot; 为一个表达式，或者一个字符串。
    2、&lt;jsp:param&gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&lt;jsp:param&gt;将多个参数发送到一个动态文件中。

三、UseBean行为

    &lt;jsp:useBean&gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。

    语法：
    &lt;jsp:useBean id=&quot;name&quot; scope=&quot;page | request | session | application&quot; typeSpec /&gt;
    其中typeSpec有以下几种可能的情况：
    class=&quot;className&quot; | class=&quot;className&quot; type=&quot;typeName&quot; | beanName=&quot;beanName&quot; type=&quot;typeName&quot; | type=&quot;typeName&quot; |

    注：
    你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。

四、GetProperty行为

    &lt;jsp:getProperty&gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。

    语法：
    &lt;jsp:getProperty name=&quot;name&quot; property=&quot;propertyName&quot; /&gt;

    注：
    1、在使用&lt;jsp:getProperty&gt;之前，必须用&lt;jsp:useBean&gt;来创建它。
    2、不能使用&lt;jsp:getProperty&gt;来检索一个已经被索引了的属性。
    3、能够和JavaBeans组件一起使用&lt;jsp:getProperty&gt;，但是不能与Enterprise Java Bean一起使用。
JavaScript通用库  Jsp语法
JSP的动作标签  2008-04-01 11:47:49|  分类： JSP学习 |  标签： |字号大
中
小 订阅
在JSP中的动作行为包括：Include、 Forward、 UseBean、 GetProperty、 SetProperty、 Plugin。

一、Include行为

&lt;jsp:include&gt;标签表示包含一个静态的或者动态的文件。

语法：
&lt;jsp:include page=&quot;path&quot; flush=&quot;true&quot; /&gt;
or
&lt;jsp:include page=&quot;path&quot; flush=&quot;true&quot;&gt;
&lt;jsp:param name=&quot;paramName&quot; value=&quot;paramValue&quot; /&gt;
&lt;/jsp:include&gt;

注：
1、page=&quot;path&quot; 为相对路径，或者代表相对路径的表达式。
2、flush=&quot;true&quot; 必须使用flush为true，它默认值是false。
3、&lt;jsp:param&gt;子句能让你传递一个或多个参数给动态文件，也可在一个页面中使用多个&lt;jsp:param&gt;来传递多个参数给动态文件。

二、Forward行为

&lt;jsp:forward&gt;标签表示重定向一个静态html/jsp的文件，或者是一个程序段。

语法：
&lt;jsp:forward page=&quot;path&quot;} /&gt;
or
&lt;jsp:forward page=&quot;path&quot;} &gt;
&lt;jsp:param name=&quot;paramName&quot; value=&quot;paramValue&quot; /&gt;……
&lt;/jsp:forward&gt;

注：
1、page=&quot;path&quot; 为一个表达式，或者一个字符串。
2、&lt;jsp:param&gt; name 指定参数名，value指定参数值。参数被发送到一个动态文件，参数可以是一个或多个值，而这个文件却必须是动态文件。要传递多个参数，则可以在一个JSP文件中使用多个&lt;jsp:param&gt;将多个参数发送到一个动态文件中。

三、UseBean行为

&lt;jsp:useBean&gt;标签表示用来在JSP页面中创建一个BEAN实例并指定它的名字以及作用范围。

语法：
&lt;jsp:useBean id=&quot;name&quot; scope=&quot;page | request | session | application&quot; typeSpec /&gt;
其中typeSpec有以下几种可能的情况：
class=&quot;className&quot; | class=&quot;className&quot; type=&quot;typeName&quot; | beanName=&quot;beanName&quot; type=&quot;typeName&quot; | type=&quot;typeName&quot; |

注：
你必须使用class或type，而不能同时使用class和beanName。beanName表示Bean的名字，其形式为“a.b.c”。

四、GetProperty行为

&lt;jsp:getProperty&gt;标签表示获取BEAN的属性的值并将之转化为一个字符串，然后将其插入到输出的页面中。

语法：
&lt;jsp:getProperty name=&quot;name&quot; property=&quot;propertyName&quot; /&gt;

注：
1、在使用&lt;jsp:getProperty&gt;之前，必须用&lt;jsp:useBean&gt;来创建它。
2、不能使用&lt;jsp:getProperty&gt;来检索一个已经被索引了的属性。
3、能够和JavaBeans组件一起使用&lt;jsp:getProperty&gt;，但是不能与Enterprise Java Bean一起使用。

五、SetProperty行为

    &lt;jsp:setProperty&gt;标签表示用来设置Bean中的属性值。

    语法：
    &lt;jsp:setProperty name=&quot;beanName&quot; prop_expr /&gt;
    其中prop_expr有以下几种可能的情形：
    property=&quot;*&quot; | property=&quot;propertyName&quot; | property=&quot;propertyName&quot; param=&quot;parameterName&quot; | property=&quot;propertyName&quot; value=&quot;propertyValue&quot;

    注：
    使用 jsp:setProperty 来为一个Bean的属性赋值；可以使用两种方式来实现。
    1、在jsp:useBean后使用jsp:setProperty：
    &lt;jsp:useBean id=&quot;myUser&quot; … /&gt;
    …
    &lt;jsp:setProperty name=&quot;user&quot; property=&quot;user&quot; … /&gt;
    在这种方式中，jsp:setProperty将被执行。
    2、jsp:setProperty出现在jsp:useBean标签内：
    &lt;jsp:useBean id=&quot;myUser&quot; … &gt;
    …
    &lt;jsp:setProperty name=&quot;user&quot; property=&quot;user&quot; … /&gt;
    &lt;/jsp:useBean&gt;
    在这种方式中，jsp:setProperty只会在新的对象被实例化时才将被执行。

    * 在&lt;jsp:setProperty&gt;中的name值应当和&lt;jsp:useBean&gt;中的id值相同。

六、Plugin行为

    &lt;jsp:plugin&gt;标签表示执行一个applet或Bean，有可能的话还要下载一个Java插件用于执行它。

    语法：
    &lt;jsp:plugin
    type=&quot;bean | applet&quot;
    code=&quot;classFileName&quot;
    codebase=&quot;classFileDirectoryName&quot;
    [ name=&quot;instanceName&quot; ]
    [ archive=&quot;URIToArchive, ...&quot; ]
    [ align=&quot;bottom | top | middle | left | right&quot; ]
    [ height=&quot;displayPixels&quot; ]
    [ width=&quot;displayPixels&quot; ]
    [ hspace=&quot;leftRightPixels&quot; ]
    [ vspace=&quot;topBottomPixels&quot; ]
    [ jreversion=&quot;JREVersionNumber | 1.1&quot; ]
    [ nspluginurl=&quot;URLToPlugin&quot; ]
    [ iepluginurl=&quot;URLToPlugin&quot; ] &gt;
    [ &lt;jsp:params&gt;
    [ &lt;jsp:param name=&quot;parameterName&quot; value=&quot;{parameterValue | &lt;％= expression ％&gt;}&quot; /&gt; ]+
    &lt;/jsp:params&gt; ]
    [ &lt;jsp:fallback&gt; text message for user &lt;/jsp:fallback&gt; ]
    &lt;/jsp:plugin&gt;

    注：
    &lt;jsp:plugin&gt;元素用于在浏览器中播放或显示一个对象（典型的就是applet和Bean),而这种显示需要在浏览器的java插件。
    当Jsp文件被编译，送往浏览器时，&lt;jsp:plugin&gt;元素将会根据浏览器的版本替换成&lt;object&gt;或者&lt;embed&gt;元素。注意，&lt;object&gt;用于HTML 4.0 ，&lt;embed&gt;用于HTML 3.2。
    一般来说，&lt;jsp:plugin&gt;元素会指定对象是Applet还是Bean,同样也会指定class的名字，还有位置，另外还会指定将从哪里下载这个Java插件。
</code></pre>
<h3 id="jsp函数">
  jsp函数
  <a class="anchor" href="#jsp%e5%87%bd%e6%95%b0">#</a>
</h3>
<pre><code>用response.getOutputStream返回数据（而非JspWriter）时，调用：
    # 如输出图片对象：ImageIO.write(image, &quot;jpeg&quot;, response.getOutputStream());
    out.clear();        # 清空 out
    out = pageContext.pushBody()    # 将图片对象的流从out输出，直到整个输出结束（接收方网页加载全部完成时）后才断开
</code></pre>
<h3 id="jsp基本">
  jsp基本
  <a class="anchor" href="#jsp%e5%9f%ba%e6%9c%ac">#</a>
</h3>
<pre><code>模板元素
脚本
&lt;%    %&gt;
脚本表达式
&lt;%=    %&gt;
注释
&lt;%--    --%&gt;
指令
    &lt;%@ page%&gt;
    language=&quot;java&quot;
    import=&quot;java.util.*,java.io.*&quot;
    contentType=&quot;mineType [; charset=characterSet]&quot;
    pageEncoding=&quot;characterSet&quot;
    session=&quot;true&quot;
    buffer=&quot;none | 8kb | sizekb&quot;
    autoFlush=&quot;true&quot;
    isThreadSafe=&quot;true&quot;
    info=&quot;text&quot;
    errorPage=&quot;relative_url&quot;
    isErrorPage=&quot;true&quot;
    isELIgnored=&quot;true&quot;
    &lt;%@ include%&gt;    # &lt;%@ include file=&quot;in.jspf&quot; %&gt; 是静态包含（原代码中包含），一般包含名字为*.jspf的jsp文件
    &lt;%@ taglib%&gt;    # 标签库
声明
    &lt;%!    %&gt;    # 全局声明（刷新页面仍然保存数据）
    &lt;% %&gt;    # 局部的声明（刷新页面不保存数据）
标签
    &lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt;
    &lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;
内置对象 9个
    pageContext
    request
    response
    config
    session
    application
    page
    out
    exception

    全局变量
    static final JspFactory        _jspxFactory
    static java.util.List        _jspx_dependants
    javax.el.ExpressionFactory    _el_expressionfactory
    org.apache.AnnotationProcessor    _jsp_annotationprocessor
    在_jspService中的变量
    HttpServletRequest        request
    HttpServletResponse        response
    PageContext        pageContext = null;
                pageContext = _jspxFactory.getPageContext(this,request,response,null,true,8192,ture);
    HttpSession        session = null;
                session = pageContext.getSession();
    ServletContext        application = null;
                application = pageContext.getServletContext();
    ServletConfig        config = null;
                config = pageContext.getServletConfig();
    JspWriter            out = null;
                out = pageContext.getOut();
    Object            page = this;
    JspWriter            _jspx_out = null;
                _jspx_out = out;
    PageContext        _jspx_page_context = null;
                _jspx_page_context = pageContext;
</code></pre>
<h3 id="jsp验证码">
  jsp验证码
  <a class="anchor" href="#jsp%e9%aa%8c%e8%af%81%e7%a0%81">#</a>
</h3>
<pre><code>实例    # 在&lt;img&gt;标签的src属性中指定该jsp文件即可

    ## out.clear();out = pageContext.pushBody();两条语句的作用是
    ## 使该验证码jsp文件的传输不会默认地在返回数据后中断，而是在&lt;img&gt;标签调用该jsp的页面加载结束之后再中断数据的传输
    &lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page contentType=&quot;image/jpeg&quot; import=&quot;java.util.*,java.awt.*,java.awt.image.*,javax.imageio.*&quot;%&gt;
&lt;%!
    // 声明区，定义产生颜色和验证内容的全局方法
    public Color getColor(){

    Random random = new Random();
    int r = random.nextInt(256);
    int g = random.nextInt(256);
    int b = random.nextInt(256);
    return new Color(r,g,b);
    }
    public String getNum(){
    String str = &quot;&quot;;
    Random random = new Random();
    for(int i = 0; i &lt; 4; i++){
        str += random.nextInt(10) + &quot; &quot;;
    }
    return str;
    }
%&gt;
&lt;%
    // 设置响应无缓存
    response.setHeader(&quot;pragma&quot;, &quot;mo-cache&quot;);
    response.setHeader(&quot;cache-control&quot;, &quot;no-cache&quot;);
    response.setDateHeader(&quot;expires&quot;, 0);
    // 图片对象,画笔对象
    BufferedImage image = new BufferedImage(80,30,BufferedImage.TYPE_INT_RGB);
    Graphics g = image.getGraphics();
    // 画背景
    g.setColor(new Color(200,200,200));
    g.fillRect(0, 0, 80, 30);
    // 画干扰线
    for(int i = 0; i &lt; 30; i++){
    Random random = new Random();
    int x = random.nextInt(80);
    int y = random.nextInt(30);
    int xl = random.nextInt(x+10);
    int yl = random.nextInt(y+10);
    g.setColor(getColor());
    g.drawLine(x, y, x + xl, y + yl);
    }
    // 画内容
    g.setFont(new Font(&quot;serif&quot;, Font.BOLD,16));
    g.setColor(Color.BLACK);
    String checkNum = getNum();
    g.drawString(checkNum,15,20);
    // 放内容到session中，返回图片流
    session.setAttribute(&quot;validateCode&quot;, checkNum.replaceAll(&quot; &quot;, &quot;&quot;));
    ImageIO.write(image, &quot;jpeg&quot;, response.getOutputStream());
    out.clear();
    out = pageContext.pushBody();    // 不按照jsp默认的getWriter()方法输出，用我们定义的流的方法进行输出
%&gt;
</code></pre>
<h3 id="自定义标签">
  自定义标签
  <a class="anchor" href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a0%87%e7%ad%be">#</a>
</h3>
<pre><code>1、JspTag 接口（标记接口，类以Serializable）
2、Tag 接口（空标签，如&lt;img/&gt;）
    属性：
    static int EVAL_BODY_INCLUDE        通过流执行标签体
    static int EVAL_PAGE              继续执行页面
    static int SKIP_BODY            忽略执行标签体
    static int SKIP_PAGE            忽略后面的JSP页面
    方法：
    // 生命周期方法
    int doEndTag()            当遇到标签结束的时候自动执行
    int doStartTag()            当遇到标签开始的时候自动执行
    // 实现方法
    Tag getParent()            获取当前标签的父标签处理类对象
    void release()            当事件改变的时候自动执行
    void setPageContext(PageContext pc)    设置当前的JSP上下文环境
    void setParent(Tag t)        设置当前标签的父标签对象
3、TagSupport 类（有属性的标签，如&lt;img src=&quot;&quot;/&gt;）
    实现了Tag接口并且提供处理标签属性的方法(set和get)。而且内部定义了一个PageContext变量并且已经初始化开发者可以直接使用this或者super直接方法该属性。
4、BodyTagSupport类（有属性有文本内容和标签，如&lt;img src=&quot;&quot;&gt;aaa&lt;/img&gt;）
    新属性
    protected  BodyContent bodyContent
    新方法
    void setBodyContent(BodyContent b)
    BodyContent getBodyContent()

    BodyContent类
        abstract String getString()    //获取标签体

    写Tag接口的标签库
    1、写Tag接口实现类
        写属性pageContext（getter 和setter），从setPageContext(PageContext pc)方法中获得该属性
        复写方法
    2、写tld文件，放到/META-INF文件夹中
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
        &lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot;
        version=&quot;2.1&quot;&gt;

        &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
        &lt;short-name&gt;ouru&lt;/short-name&gt;    # 简称
        &lt;uri&gt;/outrun-tags&lt;/uri&gt;    # 自定义引入标签时写的路径

        &lt;tag&gt;
        &lt;name&gt;testDate&lt;/name&gt;
        &lt;tag-class&gt;outrun.util.jsp.taglib.test.DataImplTag&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
        &lt;/tag&gt;

        &lt;/taglib&gt;
    3、jsp 中引用它
        &lt;%@ taglib prefix=&quot;ouru&quot; uri=&quot;/META-INF/myUtil.tld&quot; %&gt;
    写TagSupport接口的实现类
    pageContext已内置
    定义接收属性
    tld文件中加入attribute属性
        &lt;attribute&gt;        属性描述的开始
        &lt;name&gt;pattern&lt;/name&gt;    描述属性名
        &lt;required&gt;true&lt;/required&gt;    描述属性是否是必须的
        &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;  描述属性值是否可以是输出表达式
        &lt;/attribute&gt;
    写BodyTagSupport接口的实现类
    BodyContent body = this.getBodyContent();
    String desc = body.getString();

    tld 文件中
    &lt;body-content&gt;JSP&lt;/body-content&gt;    # 有标签体，可执行脚本表达式
                        ## scriptless，有标签体，不执委脚本表达式
                        ## empty,没有标签体

Jsp2.0
    JspTag — SimpleTag — SimpleTagSupport

    SimpleTagSupport类
    该类可以直接进行操作标签的属性和标签体。
    void doTag()                遇到标签的时候自动指定
    protected  JspFragment getJspBody()          获取标签体对象
    protected  JspContext getJspContext()      获取JSP上下文环境对象
    JspTag getParent()            获取该标签的父标签处理类对象
        JspFragment类
        该类代表的标签的标签体。
        abstract  void invoke(Writer out)    输出数据到指定的流，null输出到JSP页面
    获得标签体的方法：
        Writer writer = new StringWriter();
        JspFragment jspFragment = getJspBody();
        jspFragment.invoke(writer);
        String text = writer.toString();
    项目：实现 if else 判断
    Choose.java
        private boolean tag = true;

        public boolean isTag() {
            return tag;
        }

        public void setTag(boolean tag) {
            this.tag = tag;
        }

        @Override
        public void doTag() throws JspException, IOException {
            getJspBody().invoke(null);
            super.doTag();
        }
    when.java 文件
        private boolean test = false;
        public boolean isTest() {
            return test;
        }

        public void setTest(boolean test) {
            this.test = test;
        }
        @Override
        public void doTag() throws JspException, IOException {
            Choose parent = (Choose) getParent();
            if(isTest() &amp;&amp; parent.isTag()){
            // 条件成立
            getJspBody().invoke(null);
            // 设置父的tag为false
            parent.setTag(false);
            }
            super.doTag();
        }
    Otherwise.java 文件
        @Override
        public void doTag() throws JspException, IOException {
            Choose parent = (Choose) getParent();
            if(parent.isTag()){
            // 条件成立
            getJspBody().invoke(null);
            parent.setTag(false);
            }
            super.doTag();
        }
    tld文件
        &lt;tag&gt;
        &lt;name&gt;choose&lt;/name&gt;
        &lt;tag-class&gt;outrun.util.jsp.taglib.ifelse.Choose&lt;/tag-class&gt;
        &lt;body-content&gt;scriptless&lt;/body-content&gt;    # 有标签体，可执行脚本表达式
                                ## scriptless，有标签体，不执委脚本表达式
                                ## empty,没有标签体

        &lt;/tag&gt;

        &lt;tag&gt;
        &lt;name&gt;when&lt;/name&gt;
        &lt;tag-class&gt;outrun.util.jsp.taglib.ifelse.When&lt;/tag-class&gt;
        &lt;body-content&gt;scriptless&lt;/body-content&gt;
        &lt;attribute&gt;
        &lt;name&gt;test&lt;/name&gt;
        &lt;required&gt;true&lt;/required&gt;
        &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;
        &lt;/attribute&gt;
        &lt;/tag&gt;

        &lt;tag&gt;
        &lt;name&gt;otherwise&lt;/name&gt;
        &lt;tag-class&gt;outrun.util.jsp.taglib.ifelse.Otherwise&lt;/tag-class&gt;
        &lt;body-content&gt;scriptless&lt;/body-content&gt;
        &lt;/tag&gt;



控件标签：
自定义函数库
    1 创建函数库类
    public class MyFunctions {
    public static String formatMyName(String name) {
    return &quot;your name is &quot; + name;
    }
    public static int add(int a, int b) {
    return a+b;
    }
    }

    2 在TLD文件中配置 (引用于目标1中的tld文件)
    &lt;function&gt;
    &lt;name&gt;formatMyName&lt;/name&gt;
    &lt;function-class&gt;com.taglib.MyFunctions&lt;/function-class&gt;
    &lt;function-signature&gt;java.lang.String formatMyName(java.lang.String)&lt;/function-signature&gt;
    &lt;/function&gt;

    &lt;function&gt;
    &lt;name&gt;add&lt;/name&gt;
    &lt;function-class&gt;com.taglib.MyFunctions&lt;/function-class&gt;
    &lt;function-signature&gt;java.lang.String add(int, int)&lt;/function-signature&gt;
    &lt;/function&gt;

    3 JSP中调用

    ${cc:formatMyName(&quot;wangfei&quot;) }
    ${cc:add(12, 34) }
</code></pre>
<h2 id="jdbc">
  jdbc
  <a class="anchor" href="#jdbc">#</a>
</h2>
<pre><code>流程
    Class.forName()     # 加载驱动
    DriverManager.getConnection()
    获得sql会话对象 Statement或PreparedStatement
    设置参数setXxx(), 执行sql，处理结果集
    关闭结果集、关闭会话、关闭连接
Statement
    execute
    executeQuery
    executeUpdate
    不要使用Statement
        容易sql注入
        代码可读性可维护性差
        PreparedStatement性能高，db缓存机制，相同预编译语句调用不再编译
PreparedStatement
    # 继承Statement, 预编译sql

事务怎么写
    编程式
    声明式: 用aop注入
三种连接
    Connection
        默认自动提交
        禁止自动提交开启事务, 后调commit
    Pooled Connection
        使用完后不用关闭
    XA Connection
        分布式事务
        XAResource获得
</code></pre>
<h2 id="i18n">
  i18n
  <a class="anchor" href="#i18n">#</a>
</h2>
<pre><code>页面需要获取用户信息，从数据库中取数据显示

java类中试用：
cn.itcast.resource包中
    hello_en_US.properties
    hello=hello
    hello_zh_CN.properties
    hello=编码后的“你好”
    Test.java
    #  获取信息
    Locale locale = locale.CHINA;
    #  加载资源
    ResourceBundle bundler = ResourceBundle.getBundle(&quot;cn.itcast.resource.hello&quot;,locale);
    #  取出数据
    String str = bundler.getString(&quot;hello&quot;);

jsp中
&lt;%
    ResourceBundle bundler = ResourceBundle.getBundle(&quot;lang.properties.hello&quot;, request.getLocale());
    out.write(bundler.getString(&quot;title&quot;));
%&gt;
&lt;fmt&gt;标签
    &lt;fmt:setLocale value=&quot;${pageContext.request.locale }&quot; scope=&quot;page&quot;/&gt;
    &lt;fmt:setBundle basename=&quot;lang.properties.hello&quot; var=&quot;bundler&quot; scope=&quot;page&quot;/&gt;
    &lt;fmt:message bundle=&quot;${bundler }&quot; key=&quot;title&quot;&gt;&lt;/fmt:message&gt;
资源转码
    native2ascii.exe
    myeclipse properties文件编辑器
ie 中得到en_US
Locale locale
    getLanguage();
    getCountry();
    getDefault();
ResourceBundle
    读取文件cn.itcast.resource.hello省略_en_US.properties
    getString(String key)
实例1：
    创建页面
    创建资源文件
    编辑页面
    request.getLocale();
    ResourceBundle.getBundle(&quot;&quot;,locale);
    getString(&quot;&quot;)
实例2：
    编辑页面
    &lt;%@ taglib%&gt;
    &lt;f:setLocale scope=&quot;&quot; value=&quot;&quot;&gt;
    &lt;f:setBundle basename=&quot;&quot; var=&quot;&quot; scope=&quot;&quot;&gt;
    &lt;f:message bundle=&quot;&quot; key=&quot;&quot; &gt;
动态数据国际化
日期国际化
    SimpleDateFormat    #  继承DateFormat
    getDateTimeInstance
    getDateInstance
    getTimeInstance

    static int FULL
    static int LONG
    static int MEDIUM
    static int SHORT
实例3：
    cn.itcast.i18n.MyDateI18n
    DateFormat format = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);
    String str = format.format(new Date());
    解析页面中的字符串
    FULL 和 LONG  和 MEDIUM 和 SHORT 的 区别
    DataFomat
    String format(Date date)
    Date parse(String source)
    创建static string2Date(String str)
    #  分析区域
    Locale locale = Locale.CHINA;

    #  分析日期的风格
    int dateType = DateFormat.SHORT;
    int timeType = DateFormat.FULL;

    #  获取对象
    DateFormat format = DateFormat.getDateTimeInstance(dateType,timeType,locale);

    #  解析
    format.parse(str);
动态数字国际化
    java.text.*;
    Number类
    NumberFormat(普通数字，货币，百分比)
    getIntegetInstance
    getCurrencyInstance
    getPercentInstance(Locale inLocale)

    format
    parse
    创建cn.itcast.i18n.MyNumberI18n
    #  获取对象
    #  getPercentInstance
    #  getCurrencyInstance
    NumberFormat format = NumberFormat.getIntegerInstance(Locale.CHINA);

    #  格式化 或解析
    long num = 10000000000L;
    #  Number num = format.parse(str);
    #  double price = num.doubleValue();
    format.format(num);
动态文本国际化
    At 12:30 pm on jul 3,1998, a hurricance destroyed 99 houses and caused $1000000 of damage.
    MessageFormat
    MessageFormat(String pattern,Locale locale)
    format(String pattern,Object...arguments)
    format(Object)
    parse()
    占位
    At{0}  on {0}, a hurricance destroyed{1} houses and caused {2} of damage.

    实例1：
    MyMessageI18n.java
    #  定义模式字符串
    String pattern
    #  定义locale对象
    MessageFormat format = new MessageFormat(pattern,Locale.CHINA);
    #  定义参数数组
    DateFormat datef = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.SHORT,Locale.US);
    Date date = datef.parse(&quot;Jul 3,1998 12:30 PM&quot;);

    Integer num = new Integer(99);

    long currency = NumberFormat.getCurrencyInstance(Locale.US).parse(&quot;$1000000&quot;);
    String damage = NumberFormat.getCurrencyInstance(locale).format(currency);

    Object [] values = {date,num,damage};
    #  格式化
    String str = format.format(values);

    分析：{索引，对象，类型}
    MessageFormat messf = new MessageFormat(&quot;{0,time,short} on {0,date}, a hurricance destroyed {1} houses and caused {2,number,currency} of damage.&quot;,Locale.CHINA);

    Object [] values = {new Date(),new Integer(100),1000};

    String str = messf.format(values);
</code></pre>
<h1 id="中间件">
  中间件
  <a class="anchor" href="#%e4%b8%ad%e9%97%b4%e4%bb%b6">#</a>
</h1>
<pre><code>顺序
    监听器 -&gt; 过滤器
</code></pre>
<h2 id="监听器">
  监听器
  <a class="anchor" href="#%e7%9b%91%e5%90%ac%e5%99%a8">#</a>
</h2>
<pre><code>分类
    ServletContextListener
    ServletContextAttributeListener
    HttpSessionListener
    HttpSessionAttributeListener
    HttpSessionActivationListener
web.xml 注册在过滤器后面，servlet前面
    &lt;listener&gt;
    &lt;listener-class&gt;cn.listen.MyListener&lt;/listener-class&gt;
    &lt;/listener&gt;
自定义
    public class MyListener implements ServletContextListener {
        public void contextDestroyed(ServletContextEvent sce) {
            System.out.println(&quot;die&quot;);
        }
        public void contextInitialized(ServletContextEvent sce) {
            System.out.println(&quot;init&quot;);
        }

        // 当过滤器被销毁时自动执行
        public void destroy(){
            System.out.println(&quot;Filterdestroyed&quot;);
        }
        // 当拦截的时候
        public void doFilter(request,response,chain){
            System.out.println(&quot;doFilter&quot;);
            System.out.println(&quot;放行目标资源&quot;);
            chain.doFilter(request,response);
            System.out.println(&quot;目标已经放行&quot;);
        }
        // 初始化的时候
        public void init(FilterConfig config){
            System.out.println(&quot;FilterInited&quot;);
        }
    }
</code></pre>
<h2 id="过滤器">
  过滤器
  <a class="anchor" href="#%e8%bf%87%e6%bb%a4%e5%99%a8">#</a>
</h2>
<pre><code>web.xml
    &lt;filter&gt;
        &lt;filter-name&gt;testFilter
        &lt;filter-class&gt;cn.itcast.filter.text.TestFilter
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;GB2312&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;testFilter
        &lt;url-pattern&gt;/*
    &lt;/filter-mapping&gt;

api
    Filter接口
        ## 多个过滤器, 按web.xml中注册的顺序映射调用。servlet执行完后, 从后向前返回执行chain.doFilter之后的方法
        init
        destroy
        doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
    FilterChain接口
        doFilter(ServletRequest request, ServletResponse response)
    FilterConfig接口
        private FilterConfig config = null;
        init()
            this.config = config;
        doFilter()
            String ip = this.config.getInitParameter(&quot;ip&quot;);

映射
    1.映射的url
    2.servlet的名字
        # 通配servlet &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
    3.为了映射servlet中的转发, 映射一个过滤器到某种传递方式
        &lt;filter-mapping&gt;
            &lt;dispatcher&gt;FORWARD
                # FORWARD 转发方式
                # REQUEST  请求方式
                # INCLUDE  包含方式
                # ERROR  错误页面
            &lt;/dispatcher&gt;
        &lt;/filter-mapping&gt;
设置编码
    doFilter()
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        httpRequest.setCharacterEncoding(&quot;utf-8&quot;)
        String method = httpRequest.getMethod();
        if(&quot;get&quot;.equalsIgnoreCase(method)){
            chain.doFilter(new MyWapperRequest(httpRequest),response);
        }else{
            request.setCharacterEncoding(&quot;utf-8&quot;);
        }

    class MyWapperRequest extends HttpServletRequestWrapper{
        private HttpServletRequest request = null;

        public MyWapperRequest (HttpServletRequest request){
            super(request);
            this.request = request;
        }

        @Override
        public String getParameter(String name){
            String value = request.getParameter(name);
            String method = request.getMethod();
            if(value != null &amp;&amp;&quot;get&quot;.equalsIgnoreCase(method)){
                value = new String(value.getBytes(&quot;iso8859-1&quot;),request.getCharacterEncoding())
            }
            return value;
        }
    }

设置缓存
    # Expires:-1
    # Cache-Control:no-cache
    # Pragma:no-cache

    NoCacheFilter implements Filter # 设置不缓存
        doFilter()
            HttpServletResponse httpResponse = response;
            httpResponse.setHeader(&quot;Expires&quot;,-1 + &quot;&quot;);
            //  setDataHeader(&quot;expires&quot;,-1);
            httpResponse.setHeader(&quot;cache-control&quot;,&quot;no-cache&quot;);
            httpResponse.setHeader(&quot;pragma&quot;,&quot;no-cache&quot;);
            chain.doFilter(request,httpResponse);



    CacheFilter
        # 缓存静态资源
        # web.xml中url-pattern 可以映射多个 param-name=jpg param-value=2
        private FilterConfig config = null;

        doFilter()
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            HttpServletResponse httpRequest = (HttpServletRequest) request;

        String resource = request.getRequestURI();
        String date  = null;
        if(resource.endsWith(&quot;jpg&quot;)){
            date =  config.getInitParameter(&quot;jpg&quot;);
            httpResponse.setDateHeader(&quot;expires&quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);    // 换算成秒
        } else if(resource.endsWith(&quot;js&quot;)){
            String date  = config.getInitParameter(&quot;js&quot;);
            config.getInitParameter(&quot;js&quot;);
            httpResponse.setDateHeader(&quot;expires&quot;,System.currentTimeMillis() + longDate * 60 * 60 * 1000);
        }

        chain.doFilter(httpRequest,httpResponse);

修改编码
    EncodingFilter implements Filter{
        doFilter(request,response){
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            HttpServletResponse httpRequest = (HttpServletRequest) request;
            httpRequest.setCharacterEncoding(&quot;utf-8&quot;);
            chain.doFilter(httpRequest,httpResponse);
        }
    }
    class EncodingRequest extends HttpServletRequestWrapper{
        private HttpServletRequest request;
        public EncodingRequest (HttpServletRequest request){
            super(request);
            this.request = request;
        }

        @Override
        public String getParameter(String name){
            String value = request.getParameter(name)
            if(value != null &amp;&amp; &quot;get&quot;.equalsIgnoreCase(request.getMethod)){
                value = new String(value.getBytes(&quot;iso8859&quot;),&quot;utf-8&quot;);
            }
            return value;
        }
    }

登录
    LoginFilter
        init(){
            this.config  = config;
        }
        private FilterConfig config = null;
        doFilter(){
            String path = this.config.getInitParameter(&quot;loginPage&quot;);
            HttpSession session = httpRequest.getSession(false);

            // 判断用户请求的是否是UserServlet
            String servletName = httpRequest.getServletPath();
            servletName = substring(servletName.lastIndexOf(&quot;/&quot;)+1);
            if(&quot;UsersServlet&quot;.equals(servletName)){
            }else{ // 一般的servlet
                if(session != null){
                    // 获取登录标记
                    User user = null;
                    user = (User)session.getAttribute(&quot;user&quot;);

                    // 判断
                    if(user != null){
                        // 放行资源
                        chain.doFilter(httpRequest,httpResponse);
                    }else{
                        // 页面重定向到登录页面
                        httpResponse.sendRedirect(httpRequest.getContextPath() + &quot;/&quot; + path);
                    }
                }
            }
        }
    web.xml
        &lt;filter&gt;
            &lt;filter-name&gt;loginFilter
            &lt;filter-class&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;loginPage
                &lt;param-value&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;
                &lt;url-pattern&gt;/jsps/*
                &lt;url-pattern&gt;/servlet/*
                &lt;url-pattern&gt;/publics/*
            &lt;filter-name&gt;
                &lt;url-pattern&gt;/publics/head.jsp
                &lt;dispatcher&gt;INCLUDE
                &lt;dispatcher&gt;FORWARD
                &lt;dispatcher&gt;ERROR
                &lt;dispatcher&gt;REQUEST
                    # 默认是request，当加上其它参数时（如include），request会没有，所以要加两个forward,request
                    ## 是指向里面以该方法请求的时候进行过滤
</code></pre>
<h2 id="struts2">
  struts2
  <a class="anchor" href="#struts2">#</a>
</h2>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/commit/9d2ea756f7e5d3ffd8c443f52554888da5999c1a" title='Last modified by outrunJ | Apr 23, 2022' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>Apr 23, 2022</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/tree/master/content/content/docs/pl/java/javaweb.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#基础">基础</a>
      <ul>
        <li><a href="#jsp">jsp</a>
          <ul>
            <li><a href="#jsp-el表达式">jsp-el表达式</a></li>
            <li><a href="#jsp-taglib标签库">jsp-taglib标签库</a></li>
            <li><a href="#jsp动作标签">jsp动作标签</a></li>
            <li><a href="#jsp函数">jsp函数</a></li>
            <li><a href="#jsp基本">jsp基本</a></li>
            <li><a href="#jsp验证码">jsp验证码</a></li>
            <li><a href="#自定义标签">自定义标签</a></li>
          </ul>
        </li>
        <li><a href="#jdbc">jdbc</a></li>
        <li><a href="#i18n">i18n</a></li>
      </ul>
    </li>
    <li><a href="#中间件">中间件</a>
      <ul>
        <li><a href="#监听器">监听器</a></li>
        <li><a href="#过滤器">过滤器</a></li>
        <li><a href="#struts2">struts2</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












