<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  介绍
  #

源于ML
标准化的、纯函数式编程语言
非限定性语义和强静态类型
作为其他语言设计新功能时的样板，如Python的lambda标记语句


  工具
  #

检索函数用http://www.Haskell.org/hoogle


  单词
  #

polymorphism
    # 多态
monomorphic
    # 单态


  风格
  #

point free style
    sum&#39; xs = foldl (&#43;) 0 xs
    sum&#39; = foldl (&#43;) 0


  注意
  #

使用缩进代替括号，但也可用括号


  文件扩展名
  #

# 文件中不用let定义变量, 
# 变量赋值两次会报错, 这意味着代码顺序不重要
hs


  内置变量
  #

pi


  模块
  #

:m Data.Char Data.Map
    # 加载模块
    chr
        # chr :: Int -&gt; Char
    ord
        # ord :: Char -&gt; Int
    toUpper
    toLower
import Data.Char
    # 导入到全局命名空间
    import Data.List (nub, sort)
    import Data.List hiding (nub)
    import qualified Data.Map as M
        # 这样其中命名冲突的filter, null函数，只能用Data.Map.filter或M.filter方式调用
可用模块
    prelude
        # 默认载入的模块
    Data
        Char
        List
        Map
        Set
自定义模块
module Geometry.Sphere
(sphereVolume
, sphereArea
, Shape(..)
    # 导出类型和其所有构造子
) where
sphereVolum :: Float -&gt; Float
sphereVolum radius = (4.0 / 3.0) * pi * (radius ^ 3)


  命令函数
  #

:load
    # 加载模块
    :load a.hs
:l
:cd
    # 切换工作目录
    :cd c:\a
:reload
    # 重载所有模块
:r
:type
    :type &#39;H&#39;
:t
:info
    # 查看一个typeclass有哪些instance和subclass
    # 类型的信息、函数的类型声明
:k
    # 查看kind
    :k Int
        # Int :: *
    :k Maybe
        # Maybe :: * -&gt; *


  操作符
  #

%
    # 分号
&amp;&amp;
||
&#43;&#43;    
    # 字符串拼接
/=
    # 不等
do
    # 动作的combine, do 是&gt;&gt;=的语法糖, 用来连接一系列动作
&lt;-
    # name &lt;- getLine, 存到变量
    # 除了程序的最后一行用来作返回值，其它语句都可以用 &lt;-


  表达式
  #

# 表达式可以随处安放
if x &lt; 0 then
    -1
else if x &gt; 0 then
    1
else
    0

case x of
    0 -&gt; 1
    1 -&gt; 5
    _ -&gt; (-1)

let a = 1
    # 局部绑定, in可省略则定义到全局
    twice_a = 2 * a
in (a &#43; twice_a, a - twice_a)
    
let boot x  y z = x * y &#43; z in boot 3 4 2


  I/O action
  #

# 在main中 I/O action才被执行
# return () 语句产生I/O action, do接着执行
# 执行后会打印结果，结果为()时不打印
main = do
    _ &lt;- putStrLn &quot;a&quot;
    name &lt;- getLine
    putStrLn (name)


  类型表示
  #

Eq a =&gt; a -&gt; a -&gt; Bool
    # =&gt; 前面是类型约束, 后面表示传入两个同类型参数，返回Bool类型


  变量
  #

let pi = 3.14
    # 变量不可变，但可重复定义
(-1)
    # 负数一般加小括号
  let r = 25 :: Double
    # 默认猜测是Integer
    # monomorphish restriction(单一同态限定)原理，可以指定polymorphic(多态)
    ## let r = 25 :: Num a =&gt; a
True, False
    # 类型为 Bool
&quot;abc&quot;
    # 类型为[char], 与&#39;a&#39;:&#39;b&#39;:&#39;c&#39;:[]
    a = &quot;aaa&quot; :: String
        # 得到一个String, 与[char]同样使用
LT, GT, EQ


  函数
  #

# 函数名与参数，参数与参数之间有空格隔开
# 函数比运算符先结合
let area r = pi * r ^ 2
    # 定义函数, 
area 2
area (-2)
let area2 r = area r
let first (x, y) = x
    # 接收元组
uppercase, lowercase :: String -&gt; String
    # 指定函数类型
分段定义
    # 编译成case语句
    f 0 = 1
    f 1 = 5
    f _ = -1
函数合成调用
    square (f 1)
    (square . f) 1
(\xs -&gt; length xs &gt; 15)
    # lambda表达式
    # lambda可以用模式匹配，但使用不了多个模式


  列表
  #

# 列表，类型必须相同。
# 列表都由[]追加得到，逗号是语法糖
let n = [1, 2]
[1..20]
    # range浮点数不精确
take 20 [1,2..]
[2,4..20]
[&#39;a&#39;..&#39;z&#39;]
0:n
    # 得到追加列表[0, 1, 2]， 头部追加叫作consing, cons是constructor
    # -1:0:n
[[1], [2]]
n !! 1
    # 取元素
l1 &gt; l2
    # 元素依次比较
[x*2 | x &lt;- [1..10], x*2 &gt;= 12]
    # list comprehension
    boomBangs xs = [if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;-xs, odd x]
    [x*y | x &lt;-[1,2], y &lt;-[3,4]]
        # 聚合得[3,4,6,8]
    length&#39; xs = sum [1 | _ &lt;- xs]

    xxs = [[1,2], [3,4]]
    [[x | x &lt;- xs, even x] | xs &lt;- xxs]

    [(a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 &#43; b^2 = c ^2]

    [a &#43; b | (a,b) &lt;- xs]
        # list comprehension中的模式匹配
模式匹配
    x:xs
    x:y:z:xs


  元组
  #

# 类型可不同，不能单元素。2元组叫pairs, 3元组叫triples, n元组叫n-tuple
# 元组不可变
# 元组的类型由长度和其中的类型决定, (&quot;a&quot;, 1)与(1, &quot;a&quot;)是不同的类型，所以[(&quot;a&quot;, 1), (2, &quot;b&quot;)]是错误的
(True, 1)
((1,2), True)


  monad
  #

o-&gt; do
doGuessing num = do
    putStrLn &quot;Enter your guess:&quot;
    guess &lt;- getLine
    if (read guess) &lt; num
    then do putStrLn &quot;Too low&quot;
        doGuessing num
    else if (read guess) &gt; num
    then do putStrLn &quot;Too high&quot;
        doGuessing num
    else putStrLn &quot;You Win&quot;
        # 只有一个动作时，可省略do

o-&gt; do
doGuessing num = do
    putStrLn &quot;Enter your guess:&quot;
    guess &lt;- getLine
    case compare (read guess) num of
        LT -&gt; do putStrLn &quot;Too low&quot;
        GT -&gt; do putStrLn &quot;Too high&quot;
        EQ -&gt; putStrLn &quot;You Win&quot;

o-&gt; functor applicative monad
class Functor f where
fmap :: (a -&gt; b) -&gt; f a -&gt; f b
class Functor f =&gt; Applicative f where
pure :: a -&gt; f a
() :: f (a -&gt; b) -&gt; f a -&gt; f b
class Applicative m =&gt; Monad m where
return :: a -&gt; m a
(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
(&gt;&gt;) :: m a -&gt; m b -&gt; m b
x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y
fail :: String -&gt; m a
fail msg = error msg
instance Functor Maybe where
fmap func (Just x) = Just (func x)
fmap func Nothing  = Nothing
instance Applicative Maybe where
pure = Just
Nothing  _ = Nothing
(Just func)  something = fmap func something
instance Monad Maybe where
return = Just
Nothing &gt;&gt;= func = Nothing
Just x &gt;&gt;= func  = func x


  内置函数
  #

prelude
    $
        # 函数调用符，优先级最低。而空格是最高优先级
        # $右结合。而空格左结合
        # 等价于在右而写一对括号
    .
        # f . g = \x -&gt; f (g x)
        # 函数组合
    main
        # main :: IO ()
        main = do
    signum
        # 根据数字返回 -1, 0, 1
    not
    id
        # identity
    unlines
        unlines [&quot;a&quot;, &quot;b&quot;]
            # 成为 &quot;a\nb\n&quot;
    unwords
        unwords [&quot;a&quot;, &quot;b&quot;]
            # 成为 &quot;a b&quot;
    show
        # 接受各种类型，转换为String, 再转义打印
    read
        read &quot;5&quot; :: Int
        read &quot;5&quot; - 2
        read &quot;[1,2,3]&quot; &#43;&#43; [4]
    reads
        # 读取失败返回[]而不报错
    negate
        # 取反数字
    abs
        # 绝对值
    length
        # 列表的长度, [a] -&gt; Int , a在这里是一个type variable, 以小写字母开头(具体类型都大写开头)。
    map
    compare
        # 返回 LT, GT, EQ其中一个
    min
    max
    compare
        # 返回LT, GT, EQ
        &quot;Abc&quot; `compare` &quot;Zyx&quot;
    mod
        # 取模
    odd
        # 奇数
    even
        # 偶数
    succ
        # 取Enum的后继
    pred
        # 取Enum的前置
    minBound
        # 取Bound下限
    maxBound
    substract
        # 减

    head
    tail
        # 除第一个
    last
    init
        # 除最后一个

    null
        # 检查list是否空
    reverse
        # list反转
    take
        take 1 [1,2,3]
    takeWhile
        # 取list值，直到某条件
    drop
        drop 1 [1,2,3]
    maximum
        # list中最大元素
    minimun
        # list中最小元素
    sum
        # list和
    product
        # list积
    elem
        # 判断元素是否在list中
        4 `elem` [3,4,5]
    cycle
        take 7 (cycle [1,2,3])
            # [1,2,3,1,2,3,1]
    repeat
        repeat 5
    replicate
        replicate 3 10
            # [10, 10, 10]

    fst (1, 2)
        # 只适合2元组
    snd (1, 2)
        # 只适合2元组
    zip
        # zip3, zip4 ... zip7
        zip [1,2,3] [4,5,6]
            # [(1,4), (2,5), (3,6)]
    zipWith
        # zipWith1 ... zipWith7
        zipWith (\x y -&gt; x &#43; y) [1,2] [3,4]
            # [4,6]
    fromIntegral
        # 返回更通用的数字类型
    error &quot;&quot;
        # 抛错
    flip
        # 翻转两个参数调用
    map
    filter
    foldl
        foldl (\acc x -&gt; acc &#43; x) 0 xs
    foldr
        foldr (\x acc -&gt; f x : acc) [] xs
    foldl1
        # 以第一个元素为初始值，空list报错
    foldr1
    foldl&#39;
        # foldl的strict版
    foldr&#39;
    scanl
        # 返回累加过程的list
    scanr
    scanl1
    scanr1
    o-&gt; I/O action
        # 只有在main中执行
        # 类型为 IO a
        putStrLn
            # 只接受String，不转义打印，加换行符
            # putStrLn :: String -&gt; IO () , 表示接收String, 是IO动作, 结果类型是()。表示是一个&quot;IO monad&quot;动作
        putStr
            # 由putChar递归定义，边界条件是空字符串
        putChar
        print
            # 打印Show typeclass的值
        getLine
            # 控制台读一行
            # getLine :: IO String
            name &lt;- getLine
        getChar
        sequence
        # 顺序执行I/O action
        mapM
            mapM print [1,2,3]
                # 对list元素执行sequence f
        mapM_
            # 同mapM，不打印[(),()]
        getContents
            # 读直到 eof (ctrl &#43; d)
        interact
            # 用函数处理输入，返回到输出
Data.List
    # 每个元素存在thunk中
    \
        # 差集
        [1..3] \\ [2]
            # [1,3]
        &quot;Im a big baby&quot; \\ &quot;big&quot;
            # &quot;Im a baby&quot;
    union
    intersection
    insert
        # 插入一个元素到可排序list相对位置
    nub
        # 去重复元素,常用Set转换取代,提高很多效率
    map
        # 导出到了prelude
    filter
        # 导出到了prelude
    intersperse
        intersperse &#39;.&#39; &quot;abc&quot;
            # &quot;a.b.c&quot;
    intercalate
        # 同intersperse, 但插入list
    transpose
        # 二元list列为行
    foldl&#39;
        # fold的严格版，直接计算出中间值，而非用惰性&quot;承诺&quot;塞满堆栈
    foldl1&#39;
    concat
        # 移除一级嵌套
    concatMap
        # 先map再concat
        concatMap (replicate 2) [1..3]
            # [1,1,2,2,3,3]
    and
        # list中全true返回true
        and $ map (&gt;4) [5,6,7,8]
    or
    any
    iterate
        # 无限迭代值到函数，结果形成list
        take 10 $ iterate (*2) 1
    splitAt
        # 断开list, 返回二元组
        splitAt 3 &quot;abcdef&quot;
            # (&quot;abc&quot;, &quot;def&quot;)
    takeWhile
        # 取元素，直到不符合条件
    dropWhile
    span
        # 同takeWhile, 不过返回分割list的二元组
    break
        # 同span, 但在条件首次为true时断开
    sort
        # list元素要求Ord类型，排序list
    group
        # 合并相邻并相等的list元素
    inits
        # init递归调用自身
        inits &quot;abc&quot;
            # [&quot;&quot;, &quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;]
    tails
        # tail递归调用自身
        tails &quot;abc&quot;
            # [&quot;abc&quot;, &quot;bc&quot;, &quot;c&quot;, &quot;&quot;]
    isInfixOf
        # list中搜索子list, 有则返回true
        &quot;cat&quot; `isInfixOf` &quot;im a cat&quot;
    isPrefixOf
        # 是否以某list开头
    isSuffixOf
        # 是否以某list结尾
    elem
        # 是否包含某元素
    notElem
    partition
        # 条件划分list为二元组
        partition (`elem` [&#39;A&#39;..&#39;Z&#39;]) &quot;AbCD&quot;
            # (&quot;ACD&quot;, &quot;b&quot;)
    find
        # 条件查找list, 返回第一个符合元素的Maybe值
    elemIndex
        # 返回elem第一个元素的索引的Maybe值
    elemIndices
        # 返回所有匹配索引的list
    findIndex
    findIndices
    lines
        # 字符串分行到list
    unlines
    words
        # 字符串分词到list
    unwords
    delete
        # 删除list中第一个匹配元素
        delete &#39;h&#39; &quot;hha&quot;
            # &quot;ha&quot;
    replace
    lookup
        # 用a查找[(&#39;a&#39;, &#39;b&#39;)]中的b
    genericLength
        # 换Int类型为Num类型
    genericTake
    genericDrop
    genericSplitAt
    genericIndex
    genericReplicate

    nubBy
        # 传递函数判断相等性，取代==
    deleteBy
    unionBy
    intersectBy
    groupBy
    sortBy
    insertBy
    maximumBy
    minimumBy
Data.Monoid
    Monoid
    Product
    Sum
    Any
    All
Data.Foldable
    foldr
    foldl
    foldr1
    foldl1
Data.Function
    on
        ((==) `on` (&gt; 0))
            # 判断相等性，等价于 (\x y -&gt; (x &gt; 0) == (y &gt; 0))
        (compare `on` length)
            # 判断大小
Data.Char
    isControl
        # 是否控制字符
    isSpace
        # 包括空格, tab, 换行等
    isLower
    isUpper
    isAlpha
        # 是否字母
    isAlphaNum
        # 字母或数字
    isPrint
        # 可打印
    isDigit
    isOctDigit
    isHexDigit
    isLetter
        # 同isAlpha
    isMark
        # unicode注音字符
    isNumber
    isPunctuation
        # 是否标点符号
    isSymbol
        # 货币符号
    isSeperater
        # unicode空格或分隔符
    isAscii
        # unicode 前128位
    isLatin1
        # unicode 前256位
    isAsciiUpper
    isAsciiLower
    GeneralCategory
        # 得到字符的分类，一共31类, 属于Eq类型
        generalCategory &#39; &#39;
            # Space
    toUpper
    toLower
    toTitle
    digitToInt
        # 数字，大小写字母list 转成 int list
    intToDigit
    ord
    char
Data.Map
    # 用avl树实现
    fromList
        # 重复键会忽略，要求key有相等性和排序性
    fromListWith
        # 重复键给函数处理
    toList
    empty
        # 返回空map
    insert
        insert 3 10 map
    insertWith
        # 已包含键时函数处理
    null
        # 检查map是否空
    size
        # 返回map的大小
    singleton
        singleton 3, 9
            # fromList [(3,9)]
    lookup
    member
        # key 是否在map中
    map
    filter
    keys
    elems
Data.Set
    # 要求元素可排序，自动排序、唯一
    # 用avl树实现
    fromList
    intersection
    difference
        # 存在于第一集合而不在第二集合的元素
    union
    null
    size
    member
    empty
    singleton
    insert
    delete
    isSubsetOf    
        # 子集
        fromList [1,2] isSubsetOf fromList [1,2]
    isProperSubsetOf
        # 真子集
    filter
    map
Data.ByteString
    # strict bytestring
    # Empty相当于[], cons相当于:
Data.ByteString.Lazy
    # 每个元素存在chunk中，每个chunk 64k，每个chunk相当于一个strict bytestring
    # cons在chunk不满的时候会新建chunk, cons&#39;是strick版的cons, 会填充chunk
    pack
        # pack :: [Word8] -&gt; ByteString
        pack [80,81]
    unpack
    fromChunks
        # 转换strick bytestring 到lazy
    toChunks
        # lazy转strick
Data.Ratio
Control.Applicative
    Applicative
        class (Functor f) =&gt; Applicative f where
            pure :: a -&gt; fa
            (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
            f &lt;$&gt; x = fmap f x
    ZipList
        ZipList3
        ZipList7
    getZipList
    liftA2
        liftA2 f x y = f &lt;$&gt; x &lt;*&gt; y 
    sequenceA
Control.Monad
    when
        # Bool true时，返回后面的I/O action, 否则return ()
    forever
        # 不断执行后面的I/O action
        forever $ do
            putStr &quot;a&quot;
    forM
        # 同mapM, 但两个参数顺序相反
    liftM
        # monad中的fmap
    liftM2 liftM3 liftM4 liftM5
    `ap`
        # monad中的&lt;*&gt;
    join
        join :: (Monad m) =&gt; m (m a) -&gt; m a
        join mm = do
            m &lt;- mm
            m
    filterM
    foldM
Control.Monad.State
    State
        newtype State s a = State {runState :: s -&gt; (a, s)}
    get
    put
Control.Monad.Error
System.IO
    openFile
        # openFile :: FilePath -&gt; IOMode -&gt; IO Handle
        # data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
        do
        handle = openFile &quot;a.txt&quot; ReadMode
        contents &lt;- hGetContents handle
        putStr contents
        hClose handle
    withFile
        # withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
        # 处理完关掉
        withFile &quot;a.txt&quot; ReadMode (\handle -&gt; do
            contents &lt;- hGetContents handle
            putStr contents)
    readFile
        # readFile :: FilePath -&gt; IO String
        do
        contents &lt;- readFile &quot;a.txt&quot;
        putStr contents
    wirteFile
        # writeFile :: FilePath -&gt; String -&gt; IO ()
        do
        writeFile &quot;a.txt&quot; contents
    appendFile
    hSetBuffering
        # 读binary file时的buffer，默认是系统值
        # data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)
        hSetBuffering handle $ BlockBuffering (Just 2048)
    hFlush
        # 写入时自动Flush
    openTempFile
        (tempName, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot;
    hGetContents
    hClose
    hGetLine
    hPusStr
    hPutStrLn
    hGetChar
System.IO.Error
    catch
        # catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a
        toTry `catch` handler
        handler e
            | isDoesNotExistError e = 
                case ioeGetFileName e of Just path -&gt; putStrLn $ &quot;a&quot; &#43;&#43; path
                    Nothing -&gt; putStrLn &quot;b&quot;
            | otherwise = ioError e
    isDoesNotExistError
    isAlreadyExistsError
    isFullError
    isEOFError
    isIllegalOperation
    isPermissionError
    isUserError
    ioeGetFileName
        # ioeGetFileName :: IOError -&gt; Maybe FilePath
    ioError
        # 丢出接到的error
System.Directory
    removeFile
        removeFile &quot;a.txt&quot;
    renameFile
        renameFile tempName &quot;a.txt&quot;
    copyFile
    doesFileExist
System.Environment
    getArgs
    getProgName
System.Random
    mkStdGen
        # mkStdGen :: Int -&gt; StdGen
    getStdGen
        # IO类型, 得到系统启动时的global generator
    newStdGen
        # 把现有的random generator分成两个新的generators, 其中一个指定成新的，返回另一个
    random
        # random :: (RandomGen g, Random a) = g -&gt; (a, g)
        random (mkStdGen 100) :: (Int, StdGen)
    randoms
        take 5 $ randoms (mkStdGen 11) :: [Int]
    randomR
        # 区间random
        randomR (1,6) (mkStdGen 2)
    randomRs
        take 10 $ randomRs (&#39;a&#39;, &#39;z&#39;) (mkStdGen 3) :: [Char]


  函数
  #

o-&gt; 模式匹配
    # case的语法糖
    # 对构造子匹配，如 8 &#39;a&#39; : []
factorial :: (Integral a) =&gt; a -&gt; a
factorial 0 = 1
factorial n = n * factorial (n - 1)

addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)
addVectors (x1, y1) (x2, y2) = (x1 &#43; x2, y1 &#43; y2)

first :: (a, b, c) -&gt; a
first (x, _, _) = x

tell :: (Show a) =&gt; [a] -&gt; String
tell [] = &quot;&quot;
tell [x: []] = &quot;&quot;
tell [x:y:[]] = &quot;&quot;
tell [x:y:_] = &quot;too long, the first is &quot; &#43;&#43; show x &#43;&#43; &quot; and the second is &quot; &#43;&#43; show y

length&#39; :: (Num b) =&gt; [a] -&gt; b
length&#39; [] = 0
length&#39; (_:xs) = 1 &#43; length&#39; xs

capital :: String -&gt; String
capital &quot;&quot; = &quot;&quot;
capital all@(x:xs) = &quot;The first letter of &quot; &#43;&#43; all &#43;&#43; &quot; is &quot; &#43;&#43; [x]
    # @是as模式

o-&gt; guard
bmiTell :: (RealFloat a) =&gt; a -&gt; String
bmiTell weight height
    | bmi &lt;= skinny = &quot;You&#39;re underweight&quot;
    | bmi &lt;= normal = &quot;You&#39;re supposedly normal&quot;
    | bmi &lt;= fat = &quot;You&#39;re fat&quot;
    | otherwise = &quot;You&#39;re a whale&quot;
    where bmi = weight / height ^ 2
    (skinny, normal, fat) = (18.5, 25.0, 30.0)
        # where是语法结构，不是表达式
calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]
calcBmis xs = [bmi w h | (w, h) &lt;- xs, let bmi = w / h ^ 2]

myCompare :: (Ord a) =&gt; a -&gt; a -&gt; Ordering
a `myCompare` b
    | a &gt; b = GT
    | a == b = EQ
    | otherwise = LT

o-&gt; quicksort
quicksort :: (Ord a) =&gt; [a] -&gt; [a]
quicksort [] = []
quicksort (x:xs) = 
    let smallerSorted = quicksort (filter (&lt;=x) xs)
        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]
    in smallerSorted &#43;&#43; [x] &#43;&#43; biggerSorted

o-&gt; curry
compareWithHundred :: (Num a, ord a) =&gt; a -&gt; Ordering
compareWithHundred = compare 100

divideByTen :: (Floating a) =&gt; a -&gt; a
divideByTen = (/10)
    # 中缀函数用括号来不完全调用
    # 但(-4)表示负4, (substract 4)来表示减4函数

o-&gt; 高阶函数
applyTwice :: (a -&gt; a) -&gt; a -&gt; a
applyTwice f x = f (f x)

o-&gt; lambda
addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a
addThree = \x -&gt; \y -&gt; \z -&gt; x &#43; y &#43; z

o-&gt; $ 做数据函数
map ($ 3) [(4&#43;), (10*), (^2), sqrt]


  类型
  #

类型
    Int
        # 有界整数
    Integer
        # 无界整数
    Float
        # 单精度浮点数
    Double
    Bool
    Char
    Maybe
    []
    ()
    a
        # type variables
类型约束
    Eq
    # 可判断相等性的类型，可用 == 或 /= 判断
        # 只除函数
    Ord
        #可比较大小的类型, 必定是Eq
        # 只除函数
    Ordering
        # 只有GT, EQ, LT
    Show
        # 可用字符串表示的类型
        # 只除函数
    Read
        # 与Show相反
    Enum
        # 连续的类型，有后继子(successer)和前置子(predecesor), 分别通过succ函数和pred函数得到
        # 可以[1..2]构造list
        # 包含 (), Bool, Char, Ordering, Int, Integer, Float, Double
    Bounded
        # 有上限和下限
        # 如果Tuple中都属于Bounded, 那么这个Tuple属于Bounded
    Num
        # 数字特征
    Integral
        # 整数
    Floating
        # 浮点，包含Float和Double
构造类型
    data Bool = False | True deriving (Ord)
        # Bool是构造的类型, False为值构造子，值可以用:t查看其类型
        # 值构造子可以用于模式匹配
        # 这里值构造子是没有参数的，叫作nullary
        # False在True前，所以比较时True比False大
    data Point = Point Float Float deriving (Show)
        # 值构造子可以与类型同名
    data Shape = Circle Point Float | Rectangle  Point Point deriving (Show)
        # 派生自Show, 就可show值成字符串
    data Person = Person {firstName :: String
        , lastName :: String
        } deriving (Show)
            # Record Syntax, 同 Person String String,  但自动生成同名的取值函数，show显示也改变
        let p = Person {firstName=&quot;aa&quot;, lastName=&quot;bb&quot;}
    
        tellPerson :: Person -&gt; String
        tellPerson (Person {firstName = a, lastName = b}) = a &#43;&#43; b
    newtype CharList = CharList {getCharList :: [Char]} deriving {Eq, Show}
        # newtype将现有类型包成新类型，只能定义单一值构造子，且其只能有一个字段。并将包裹和解开的成本都去掉
类型构造子
    # data声明中不能加类型约束
    data Maybe a = Nothing | Just a
    data Car a b = Car { company :: a
        , year :: b
        } deriving (Show)
    tellCar :: (Show a) =&gt; Car String a -&gt; String
类型别名
    type String = [Char]
    type AssocList k v = [(k,v)]
        # 别名类型构造子
    type IntMap = Map Int
        # 不全调用得到不全类型构造子, 同 type intMap v = Map Int v
infixr
    infixr 5 :-:
        # 定义中缀构造子, 5是优先级, :-:是符号
        # 默认left-associative

    infixr 5 .&#43;&#43;
    (.&#43;&#43;) :: List a -&gt; List a -&gt; List a
    Empty .&#43;&#43; ys = ys
    (x :-: xs) .&#43;&#43; ys = x :-: (xs .&#43;&#43; ys)
recursive data structures
    data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
typeclass
    class Eq a where
        (==) :: a -&gt; a -&gt; Bool
        (/=) :: a -&gt; a -&gt; Bool
        x == y = not (x /= y)
        x /= y = not (x == y)
            # 只需要instance一个定义就好，这个定义叫minimal complete definition
    data TrafficLight = Red | Yellow | Green
    instance Eq TrafficLight where
        Red == Red = True
        Green == Green = True
        Yellow == Yellow = True
        _ == _ = False
    instance Show TrafficLight where
        show Red = &quot;Red light&quot;
        show Yellow = &quot;Yellow light&quot;
        show Green = &quot;Green light&quot;

    class (Eq a) =&gt; Num a where
        # Num 是 Eq  的 subclass, 要是Num必是Eq

    instance (Eq m) =&gt; Eq (Maybe m) where
        Just x == Just y = x == y
        Nothing == Nothing = True
        _ == _ = False
            
o-&gt; Either
data Either a b = Left a | Right a deriving (Eq, Ord, Read, Show)

o-&gt; Tree
data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)

o-&gt; YesNo
class YesNo a where
    yesno :: a -&gt; Bool
instance YesNo Int where
    yesno 0 = False
    yesno _ = True

o-&gt; Functor
class Functor f where
    # map over
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
instance Functor Maybe where
    # 接收构造子而非类型
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
instance Functor (Either a) where
    # parital apply Either, Either a 是个类型构造子
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x
instance Functor ((-&gt;) r) where
    # 对函数的functor
    fmap f g = (\x -&gt; f (g x))


  命令
  #

ghci
    set prompt &quot;ghci&gt; &quot;
        # 设置显示的提示符
ghc
    ghc --make a.hs
runhaskell
ghc-pkg list
    # 列出已安装的软件包


  玄学
  #

o-&gt;
:{
data X = X
a :: Int -&gt; Int
a x = x &#43; 3
:}
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://runout.run/docs/pl/haskell/">
  <meta property="og:site_name" content="outrun的笔记">
  <meta property="og:title" content="Haskell">
  <meta property="og:description" content="介绍 # 源于ML 标准化的、纯函数式编程语言 非限定性语义和强静态类型 作为其他语言设计新功能时的样板，如Python的lambda标记语句 工具 # 检索函数用http://www.Haskell.org/hoogle 单词 # polymorphism # 多态 monomorphic # 单态 风格 # point free style sum&#39; xs = foldl (&#43;) 0 xs sum&#39; = foldl (&#43;) 0 注意 # 使用缩进代替括号，但也可用括号 文件扩展名 # # 文件中不用let定义变量, # 变量赋值两次会报错, 这意味着代码顺序不重要 hs 内置变量 # pi 模块 # :m Data.Char Data.Map # 加载模块 chr # chr :: Int -&gt; Char ord # ord :: Char -&gt; Int toUpper toLower import Data.Char # 导入到全局命名空间 import Data.List (nub, sort) import Data.List hiding (nub) import qualified Data.Map as M # 这样其中命名冲突的filter, null函数，只能用Data.Map.filter或M.filter方式调用 可用模块 prelude # 默认载入的模块 Data Char List Map Set 自定义模块 module Geometry.Sphere (sphereVolume , sphereArea , Shape(..) # 导出类型和其所有构造子 ) where sphereVolum :: Float -&gt; Float sphereVolum radius = (4.0 / 3.0) * pi * (radius ^ 3) 命令函数 # :load # 加载模块 :load a.hs :l :cd # 切换工作目录 :cd c:\a :reload # 重载所有模块 :r :type :type &#39;H&#39; :t :info # 查看一个typeclass有哪些instance和subclass # 类型的信息、函数的类型声明 :k # 查看kind :k Int # Int :: * :k Maybe # Maybe :: * -&gt; * 操作符 # % # 分号 &amp;&amp; || &#43;&#43; # 字符串拼接 /= # 不等 do # 动作的combine, do 是&gt;&gt;=的语法糖, 用来连接一系列动作 &lt;- # name &lt;- getLine, 存到变量 # 除了程序的最后一行用来作返回值，其它语句都可以用 &lt;- 表达式 # # 表达式可以随处安放 if x &lt; 0 then -1 else if x &gt; 0 then 1 else 0 case x of 0 -&gt; 1 1 -&gt; 5 _ -&gt; (-1) let a = 1 # 局部绑定, in可省略则定义到全局 twice_a = 2 * a in (a &#43; twice_a, a - twice_a) let boot x y z = x * y &#43; z in boot 3 4 2 I/O action # # 在main中 I/O action才被执行 # return () 语句产生I/O action, do接着执行 # 执行后会打印结果，结果为()时不打印 main = do _ &lt;- putStrLn &#34;a&#34; name &lt;- getLine putStrLn (name) 类型表示 # Eq a =&gt; a -&gt; a -&gt; Bool # =&gt; 前面是类型约束, 后面表示传入两个同类型参数，返回Bool类型 变量 # let pi = 3.14 # 变量不可变，但可重复定义 (-1) # 负数一般加小括号 let r = 25 :: Double # 默认猜测是Integer # monomorphish restriction(单一同态限定)原理，可以指定polymorphic(多态) ## let r = 25 :: Num a =&gt; a True, False # 类型为 Bool &#34;abc&#34; # 类型为[char], 与&#39;a&#39;:&#39;b&#39;:&#39;c&#39;:[] a = &#34;aaa&#34; :: String # 得到一个String, 与[char]同样使用 LT, GT, EQ 函数 # # 函数名与参数，参数与参数之间有空格隔开 # 函数比运算符先结合 let area r = pi * r ^ 2 # 定义函数, area 2 area (-2) let area2 r = area r let first (x, y) = x # 接收元组 uppercase, lowercase :: String -&gt; String # 指定函数类型 分段定义 # 编译成case语句 f 0 = 1 f 1 = 5 f _ = -1 函数合成调用 square (f 1) (square . f) 1 (\xs -&gt; length xs &gt; 15) # lambda表达式 # lambda可以用模式匹配，但使用不了多个模式 列表 # # 列表，类型必须相同。 # 列表都由[]追加得到，逗号是语法糖 let n = [1, 2] [1..20] # range浮点数不精确 take 20 [1,2..] [2,4..20] [&#39;a&#39;..&#39;z&#39;] 0:n # 得到追加列表[0, 1, 2]， 头部追加叫作consing, cons是constructor # -1:0:n [[1], [2]] n !! 1 # 取元素 l1 &gt; l2 # 元素依次比较 [x*2 | x &lt;- [1..10], x*2 &gt;= 12] # list comprehension boomBangs xs = [if x &lt; 10 then &#34;BOOM!&#34; else &#34;BANG!&#34; | x &lt;-xs, odd x] [x*y | x &lt;-[1,2], y &lt;-[3,4]] # 聚合得[3,4,6,8] length&#39; xs = sum [1 | _ &lt;- xs] xxs = [[1,2], [3,4]] [[x | x &lt;- xs, even x] | xs &lt;- xxs] [(a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 &#43; b^2 = c ^2] [a &#43; b | (a,b) &lt;- xs] # list comprehension中的模式匹配 模式匹配 x:xs x:y:z:xs 元组 # # 类型可不同，不能单元素。2元组叫pairs, 3元组叫triples, n元组叫n-tuple # 元组不可变 # 元组的类型由长度和其中的类型决定, (&#34;a&#34;, 1)与(1, &#34;a&#34;)是不同的类型，所以[(&#34;a&#34;, 1), (2, &#34;b&#34;)]是错误的 (True, 1) ((1,2), True) monad # o-&gt; do doGuessing num = do putStrLn &#34;Enter your guess:&#34; guess &lt;- getLine if (read guess) &lt; num then do putStrLn &#34;Too low&#34; doGuessing num else if (read guess) &gt; num then do putStrLn &#34;Too high&#34; doGuessing num else putStrLn &#34;You Win&#34; # 只有一个动作时，可省略do o-&gt; do doGuessing num = do putStrLn &#34;Enter your guess:&#34; guess &lt;- getLine case compare (read guess) num of LT -&gt; do putStrLn &#34;Too low&#34; GT -&gt; do putStrLn &#34;Too high&#34; EQ -&gt; putStrLn &#34;You Win&#34; o-&gt; functor applicative monad class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b class Functor f =&gt; Applicative f where pure :: a -&gt; f a () :: f (a -&gt; b) -&gt; f a -&gt; f b class Applicative m =&gt; Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y fail :: String -&gt; m a fail msg = error msg instance Functor Maybe where fmap func (Just x) = Just (func x) fmap func Nothing = Nothing instance Applicative Maybe where pure = Just Nothing _ = Nothing (Just func) something = fmap func something instance Monad Maybe where return = Just Nothing &gt;&gt;= func = Nothing Just x &gt;&gt;= func = func x 内置函数 # prelude $ # 函数调用符，优先级最低。而空格是最高优先级 # $右结合。而空格左结合 # 等价于在右而写一对括号 . # f . g = \x -&gt; f (g x) # 函数组合 main # main :: IO () main = do signum # 根据数字返回 -1, 0, 1 not id # identity unlines unlines [&#34;a&#34;, &#34;b&#34;] # 成为 &#34;a\nb\n&#34; unwords unwords [&#34;a&#34;, &#34;b&#34;] # 成为 &#34;a b&#34; show # 接受各种类型，转换为String, 再转义打印 read read &#34;5&#34; :: Int read &#34;5&#34; - 2 read &#34;[1,2,3]&#34; &#43;&#43; [4] reads # 读取失败返回[]而不报错 negate # 取反数字 abs # 绝对值 length # 列表的长度, [a] -&gt; Int , a在这里是一个type variable, 以小写字母开头(具体类型都大写开头)。 map compare # 返回 LT, GT, EQ其中一个 min max compare # 返回LT, GT, EQ &#34;Abc&#34; `compare` &#34;Zyx&#34; mod # 取模 odd # 奇数 even # 偶数 succ # 取Enum的后继 pred # 取Enum的前置 minBound # 取Bound下限 maxBound substract # 减 head tail # 除第一个 last init # 除最后一个 null # 检查list是否空 reverse # list反转 take take 1 [1,2,3] takeWhile # 取list值，直到某条件 drop drop 1 [1,2,3] maximum # list中最大元素 minimun # list中最小元素 sum # list和 product # list积 elem # 判断元素是否在list中 4 `elem` [3,4,5] cycle take 7 (cycle [1,2,3]) # [1,2,3,1,2,3,1] repeat repeat 5 replicate replicate 3 10 # [10, 10, 10] fst (1, 2) # 只适合2元组 snd (1, 2) # 只适合2元组 zip # zip3, zip4 ... zip7 zip [1,2,3] [4,5,6] # [(1,4), (2,5), (3,6)] zipWith # zipWith1 ... zipWith7 zipWith (\x y -&gt; x &#43; y) [1,2] [3,4] # [4,6] fromIntegral # 返回更通用的数字类型 error &#34;&#34; # 抛错 flip # 翻转两个参数调用 map filter foldl foldl (\acc x -&gt; acc &#43; x) 0 xs foldr foldr (\x acc -&gt; f x : acc) [] xs foldl1 # 以第一个元素为初始值，空list报错 foldr1 foldl&#39; # foldl的strict版 foldr&#39; scanl # 返回累加过程的list scanr scanl1 scanr1 o-&gt; I/O action # 只有在main中执行 # 类型为 IO a putStrLn # 只接受String，不转义打印，加换行符 # putStrLn :: String -&gt; IO () , 表示接收String, 是IO动作, 结果类型是()。表示是一个&#34;IO monad&#34;动作 putStr # 由putChar递归定义，边界条件是空字符串 putChar print # 打印Show typeclass的值 getLine # 控制台读一行 # getLine :: IO String name &lt;- getLine getChar sequence # 顺序执行I/O action mapM mapM print [1,2,3] # 对list元素执行sequence f mapM_ # 同mapM，不打印[(),()] getContents # 读直到 eof (ctrl &#43; d) interact # 用函数处理输入，返回到输出 Data.List # 每个元素存在thunk中 \ # 差集 [1..3] \\ [2] # [1,3] &#34;Im a big baby&#34; \\ &#34;big&#34; # &#34;Im a baby&#34; union intersection insert # 插入一个元素到可排序list相对位置 nub # 去重复元素,常用Set转换取代,提高很多效率 map # 导出到了prelude filter # 导出到了prelude intersperse intersperse &#39;.&#39; &#34;abc&#34; # &#34;a.b.c&#34; intercalate # 同intersperse, 但插入list transpose # 二元list列为行 foldl&#39; # fold的严格版，直接计算出中间值，而非用惰性&#34;承诺&#34;塞满堆栈 foldl1&#39; concat # 移除一级嵌套 concatMap # 先map再concat concatMap (replicate 2) [1..3] # [1,1,2,2,3,3] and # list中全true返回true and $ map (&gt;4) [5,6,7,8] or any iterate # 无限迭代值到函数，结果形成list take 10 $ iterate (*2) 1 splitAt # 断开list, 返回二元组 splitAt 3 &#34;abcdef&#34; # (&#34;abc&#34;, &#34;def&#34;) takeWhile # 取元素，直到不符合条件 dropWhile span # 同takeWhile, 不过返回分割list的二元组 break # 同span, 但在条件首次为true时断开 sort # list元素要求Ord类型，排序list group # 合并相邻并相等的list元素 inits # init递归调用自身 inits &#34;abc&#34; # [&#34;&#34;, &#34;a&#34;, &#34;ab&#34;, &#34;abc&#34;] tails # tail递归调用自身 tails &#34;abc&#34; # [&#34;abc&#34;, &#34;bc&#34;, &#34;c&#34;, &#34;&#34;] isInfixOf # list中搜索子list, 有则返回true &#34;cat&#34; `isInfixOf` &#34;im a cat&#34; isPrefixOf # 是否以某list开头 isSuffixOf # 是否以某list结尾 elem # 是否包含某元素 notElem partition # 条件划分list为二元组 partition (`elem` [&#39;A&#39;..&#39;Z&#39;]) &#34;AbCD&#34; # (&#34;ACD&#34;, &#34;b&#34;) find # 条件查找list, 返回第一个符合元素的Maybe值 elemIndex # 返回elem第一个元素的索引的Maybe值 elemIndices # 返回所有匹配索引的list findIndex findIndices lines # 字符串分行到list unlines words # 字符串分词到list unwords delete # 删除list中第一个匹配元素 delete &#39;h&#39; &#34;hha&#34; # &#34;ha&#34; replace lookup # 用a查找[(&#39;a&#39;, &#39;b&#39;)]中的b genericLength # 换Int类型为Num类型 genericTake genericDrop genericSplitAt genericIndex genericReplicate nubBy # 传递函数判断相等性，取代== deleteBy unionBy intersectBy groupBy sortBy insertBy maximumBy minimumBy Data.Monoid Monoid Product Sum Any All Data.Foldable foldr foldl foldr1 foldl1 Data.Function on ((==) `on` (&gt; 0)) # 判断相等性，等价于 (\x y -&gt; (x &gt; 0) == (y &gt; 0)) (compare `on` length) # 判断大小 Data.Char isControl # 是否控制字符 isSpace # 包括空格, tab, 换行等 isLower isUpper isAlpha # 是否字母 isAlphaNum # 字母或数字 isPrint # 可打印 isDigit isOctDigit isHexDigit isLetter # 同isAlpha isMark # unicode注音字符 isNumber isPunctuation # 是否标点符号 isSymbol # 货币符号 isSeperater # unicode空格或分隔符 isAscii # unicode 前128位 isLatin1 # unicode 前256位 isAsciiUpper isAsciiLower GeneralCategory # 得到字符的分类，一共31类, 属于Eq类型 generalCategory &#39; &#39; # Space toUpper toLower toTitle digitToInt # 数字，大小写字母list 转成 int list intToDigit ord char Data.Map # 用avl树实现 fromList # 重复键会忽略，要求key有相等性和排序性 fromListWith # 重复键给函数处理 toList empty # 返回空map insert insert 3 10 map insertWith # 已包含键时函数处理 null # 检查map是否空 size # 返回map的大小 singleton singleton 3, 9 # fromList [(3,9)] lookup member # key 是否在map中 map filter keys elems Data.Set # 要求元素可排序，自动排序、唯一 # 用avl树实现 fromList intersection difference # 存在于第一集合而不在第二集合的元素 union null size member empty singleton insert delete isSubsetOf # 子集 fromList [1,2] isSubsetOf fromList [1,2] isProperSubsetOf # 真子集 filter map Data.ByteString # strict bytestring # Empty相当于[], cons相当于: Data.ByteString.Lazy # 每个元素存在chunk中，每个chunk 64k，每个chunk相当于一个strict bytestring # cons在chunk不满的时候会新建chunk, cons&#39;是strick版的cons, 会填充chunk pack # pack :: [Word8] -&gt; ByteString pack [80,81] unpack fromChunks # 转换strick bytestring 到lazy toChunks # lazy转strick Data.Ratio Control.Applicative Applicative class (Functor f) =&gt; Applicative f where pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b f &lt;$&gt; x = fmap f x ZipList ZipList3 ZipList7 getZipList liftA2 liftA2 f x y = f &lt;$&gt; x &lt;*&gt; y sequenceA Control.Monad when # Bool true时，返回后面的I/O action, 否则return () forever # 不断执行后面的I/O action forever $ do putStr &#34;a&#34; forM # 同mapM, 但两个参数顺序相反 liftM # monad中的fmap liftM2 liftM3 liftM4 liftM5 `ap` # monad中的&lt;*&gt; join join :: (Monad m) =&gt; m (m a) -&gt; m a join mm = do m &lt;- mm m filterM foldM Control.Monad.State State newtype State s a = State {runState :: s -&gt; (a, s)} get put Control.Monad.Error System.IO openFile # openFile :: FilePath -&gt; IOMode -&gt; IO Handle # data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode do handle = openFile &#34;a.txt&#34; ReadMode contents &lt;- hGetContents handle putStr contents hClose handle withFile # withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a # 处理完关掉 withFile &#34;a.txt&#34; ReadMode (\handle -&gt; do contents &lt;- hGetContents handle putStr contents) readFile # readFile :: FilePath -&gt; IO String do contents &lt;- readFile &#34;a.txt&#34; putStr contents wirteFile # writeFile :: FilePath -&gt; String -&gt; IO () do writeFile &#34;a.txt&#34; contents appendFile hSetBuffering # 读binary file时的buffer，默认是系统值 # data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int) hSetBuffering handle $ BlockBuffering (Just 2048) hFlush # 写入时自动Flush openTempFile (tempName, tempHandle) &lt;- openTempFile &#34;.&#34; &#34;temp&#34; hGetContents hClose hGetLine hPusStr hPutStrLn hGetChar System.IO.Error catch # catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a toTry `catch` handler handler e | isDoesNotExistError e = case ioeGetFileName e of Just path -&gt; putStrLn $ &#34;a&#34; &#43;&#43; path Nothing -&gt; putStrLn &#34;b&#34; | otherwise = ioError e isDoesNotExistError isAlreadyExistsError isFullError isEOFError isIllegalOperation isPermissionError isUserError ioeGetFileName # ioeGetFileName :: IOError -&gt; Maybe FilePath ioError # 丢出接到的error System.Directory removeFile removeFile &#34;a.txt&#34; renameFile renameFile tempName &#34;a.txt&#34; copyFile doesFileExist System.Environment getArgs getProgName System.Random mkStdGen # mkStdGen :: Int -&gt; StdGen getStdGen # IO类型, 得到系统启动时的global generator newStdGen # 把现有的random generator分成两个新的generators, 其中一个指定成新的，返回另一个 random # random :: (RandomGen g, Random a) = g -&gt; (a, g) random (mkStdGen 100) :: (Int, StdGen) randoms take 5 $ randoms (mkStdGen 11) :: [Int] randomR # 区间random randomR (1,6) (mkStdGen 2) randomRs take 10 $ randomRs (&#39;a&#39;, &#39;z&#39;) (mkStdGen 3) :: [Char] 函数 # o-&gt; 模式匹配 # case的语法糖 # 对构造子匹配，如 8 &#39;a&#39; : [] factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial (n - 1) addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a) addVectors (x1, y1) (x2, y2) = (x1 &#43; x2, y1 &#43; y2) first :: (a, b, c) -&gt; a first (x, _, _) = x tell :: (Show a) =&gt; [a] -&gt; String tell [] = &#34;&#34; tell [x: []] = &#34;&#34; tell [x:y:[]] = &#34;&#34; tell [x:y:_] = &#34;too long, the first is &#34; &#43;&#43; show x &#43;&#43; &#34; and the second is &#34; &#43;&#43; show y length&#39; :: (Num b) =&gt; [a] -&gt; b length&#39; [] = 0 length&#39; (_:xs) = 1 &#43; length&#39; xs capital :: String -&gt; String capital &#34;&#34; = &#34;&#34; capital all@(x:xs) = &#34;The first letter of &#34; &#43;&#43; all &#43;&#43; &#34; is &#34; &#43;&#43; [x] # @是as模式 o-&gt; guard bmiTell :: (RealFloat a) =&gt; a -&gt; String bmiTell weight height | bmi &lt;= skinny = &#34;You&#39;re underweight&#34; | bmi &lt;= normal = &#34;You&#39;re supposedly normal&#34; | bmi &lt;= fat = &#34;You&#39;re fat&#34; | otherwise = &#34;You&#39;re a whale&#34; where bmi = weight / height ^ 2 (skinny, normal, fat) = (18.5, 25.0, 30.0) # where是语法结构，不是表达式 calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] calcBmis xs = [bmi w h | (w, h) &lt;- xs, let bmi = w / h ^ 2] myCompare :: (Ord a) =&gt; a -&gt; a -&gt; Ordering a `myCompare` b | a &gt; b = GT | a == b = EQ | otherwise = LT o-&gt; quicksort quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort (filter (&lt;=x) xs) biggerSorted = quicksort [a | a &lt;- xs, a &gt; x] in smallerSorted &#43;&#43; [x] &#43;&#43; biggerSorted o-&gt; curry compareWithHundred :: (Num a, ord a) =&gt; a -&gt; Ordering compareWithHundred = compare 100 divideByTen :: (Floating a) =&gt; a -&gt; a divideByTen = (/10) # 中缀函数用括号来不完全调用 # 但(-4)表示负4, (substract 4)来表示减4函数 o-&gt; 高阶函数 applyTwice :: (a -&gt; a) -&gt; a -&gt; a applyTwice f x = f (f x) o-&gt; lambda addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a addThree = \x -&gt; \y -&gt; \z -&gt; x &#43; y &#43; z o-&gt; $ 做数据函数 map ($ 3) [(4&#43;), (10*), (^2), sqrt] 类型 # 类型 Int # 有界整数 Integer # 无界整数 Float # 单精度浮点数 Double Bool Char Maybe [] () a # type variables 类型约束 Eq # 可判断相等性的类型，可用 == 或 /= 判断 # 只除函数 Ord #可比较大小的类型, 必定是Eq # 只除函数 Ordering # 只有GT, EQ, LT Show # 可用字符串表示的类型 # 只除函数 Read # 与Show相反 Enum # 连续的类型，有后继子(successer)和前置子(predecesor), 分别通过succ函数和pred函数得到 # 可以[1..2]构造list # 包含 (), Bool, Char, Ordering, Int, Integer, Float, Double Bounded # 有上限和下限 # 如果Tuple中都属于Bounded, 那么这个Tuple属于Bounded Num # 数字特征 Integral # 整数 Floating # 浮点，包含Float和Double 构造类型 data Bool = False | True deriving (Ord) # Bool是构造的类型, False为值构造子，值可以用:t查看其类型 # 值构造子可以用于模式匹配 # 这里值构造子是没有参数的，叫作nullary # False在True前，所以比较时True比False大 data Point = Point Float Float deriving (Show) # 值构造子可以与类型同名 data Shape = Circle Point Float | Rectangle Point Point deriving (Show) # 派生自Show, 就可show值成字符串 data Person = Person {firstName :: String , lastName :: String } deriving (Show) # Record Syntax, 同 Person String String, 但自动生成同名的取值函数，show显示也改变 let p = Person {firstName=&#34;aa&#34;, lastName=&#34;bb&#34;} tellPerson :: Person -&gt; String tellPerson (Person {firstName = a, lastName = b}) = a &#43;&#43; b newtype CharList = CharList {getCharList :: [Char]} deriving {Eq, Show} # newtype将现有类型包成新类型，只能定义单一值构造子，且其只能有一个字段。并将包裹和解开的成本都去掉 类型构造子 # data声明中不能加类型约束 data Maybe a = Nothing | Just a data Car a b = Car { company :: a , year :: b } deriving (Show) tellCar :: (Show a) =&gt; Car String a -&gt; String 类型别名 type String = [Char] type AssocList k v = [(k,v)] # 别名类型构造子 type IntMap = Map Int # 不全调用得到不全类型构造子, 同 type intMap v = Map Int v infixr infixr 5 :-: # 定义中缀构造子, 5是优先级, :-:是符号 # 默认left-associative infixr 5 .&#43;&#43; (.&#43;&#43;) :: List a -&gt; List a -&gt; List a Empty .&#43;&#43; ys = ys (x :-: xs) .&#43;&#43; ys = x :-: (xs .&#43;&#43; ys) recursive data structures data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord) typeclass class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) # 只需要instance一个定义就好，这个定义叫minimal complete definition data TrafficLight = Red | Yellow | Green instance Eq TrafficLight where Red == Red = True Green == Green = True Yellow == Yellow = True _ == _ = False instance Show TrafficLight where show Red = &#34;Red light&#34; show Yellow = &#34;Yellow light&#34; show Green = &#34;Green light&#34; class (Eq a) =&gt; Num a where # Num 是 Eq 的 subclass, 要是Num必是Eq instance (Eq m) =&gt; Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False o-&gt; Either data Either a b = Left a | Right a deriving (Eq, Ord, Read, Show) o-&gt; Tree data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) o-&gt; YesNo class YesNo a where yesno :: a -&gt; Bool instance YesNo Int where yesno 0 = False yesno _ = True o-&gt; Functor class Functor f where # map over fmap :: (a -&gt; b) -&gt; f a -&gt; f b instance Functor Maybe where # 接收构造子而非类型 fmap f (Just x) = Just (f x) fmap f Nothing = Nothing instance Functor (Either a) where # parital apply Either, Either a 是个类型构造子 fmap f (Right x) = Right (f x) fmap f (Left x) = Left x instance Functor ((-&gt;) r) where # 对函数的functor fmap f g = (\x -&gt; f (g x)) 命令 # ghci set prompt &#34;ghci&gt; &#34; # 设置显示的提示符 ghc ghc --make a.hs runhaskell ghc-pkg list # 列出已安装的软件包 玄学 # o-&gt; :{ data X = X a :: Int -&gt; Int a x = x &#43; 3 :}">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2018-10-09T16:54:16+08:00">
    <meta property="article:modified_time" content="2019-06-17T13:24:09+08:00">
<title>Haskell | outrun的笔记</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://runout.run/docs/pl/haskell/">
<link rel="stylesheet" href="/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css" integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.82b3d863368d576b09dc9142a93468d8170f7706990cff55b58bfe72c4930b4b.js" integrity="sha256-grPYYzaNV2sJ3JFCqTRo2BcPdwaZDP9VtYv&#43;csSTC0s=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <script data-ad-client="ca-pub-6239994681364905" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="baidu_union_verify" content="aacbc30462cce84b2333063d99284e3b">
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span>outrun的笔记</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-28d9e6987399d0da843d24373bb5310b" class="toggle"  />
    <label for="section-28d9e6987399d0da843d24373bb5310b" class="flex justify-between">
      <a href="/docs/architect/" class="">架构</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/" class="">代码</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/security/" class="">Security</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/code/design_mode/" class="">Java设计模式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/" class="">工程设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/ddd/" class="">工程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/project/frontend/" class="">前端</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>战略性技术</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/" class="">AI</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/ai/map/" class="">知识图谱</a>
  

        </li>
      
    
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/iot/framework/" class="">Framework</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/" class="">IoT</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/meta/media/" class="">媒体</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/middle_platform/" class="">中台</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/block_chain/" class="">Block Chain</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Cloud</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/" class="">Datalake</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/datalake/ecology/" class="">Ecology</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/strategy/edge/" class="">Edge</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/" class="">Manage</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/" class="">组织</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/manage/organize/people/" class="">人员</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/" class="">Method</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/product_plan/" class="">产品规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/code_plan/" class="">代码规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/ops_plan/" class="">运维规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/advice_plan/" class="">咨询规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/architect/" class="">服务治理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/project_plan/" class="">项目规划</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/method/test_plan/" class="">测试规划</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/architect/summary/" class="">这些年我做过的技术</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-669f1276b655f93b7e7c5d3bcda5ec19" class="toggle"  />
    <label for="section-669f1276b655f93b7e7c5d3bcda5ec19" class="flex justify-between">
      <a href="/docs/misc/" class="">杂项</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ad4b307ab1b99c68532f747347427ad2" class="toggle"  />
    <label for="section-ad4b307ab1b99c68532f747347427ad2" class="flex justify-between">
      <a href="/docs/middleware/" class="">中间件</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/" class="">支撑-分布式</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/distributed/spring_cloud/" class="">Spring Cloud</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/" class="">前端</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/bootstrap/" class="">Bootstrap</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/threejs/" class="">Threejs</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/angular/" class="">Angular</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/jquery/" class="">Jquery</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library_frontend/react/" class="">React</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/" class="">小功能</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/library/hibernate/" class="">Hibernate</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Container</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nginx/" class="">Nginx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/middleware/container/nodejs/" class="">Nodejs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9d4b4d3532e4d7688278a56c3607ee43" class="toggle"  />
    <label for="section-9d4b4d3532e4d7688278a56c3607ee43" class="flex justify-between">
      <a href="/docs/cache/" class="">Cache</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/ops/" class="">Ops</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/work_code/" class="">Work Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/template/" class="">模板配置</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/cache/soft_arch/" class="">软考架构师</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-75015a3dca1e5254e5fd64787822da31" class="toggle"  />
    <label for="section-75015a3dca1e5254e5fd64787822da31" class="flex justify-between">
      <a href="/docs/basic/" class="">基本功</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/speach/" class="">演说</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/body/" class="">身体</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/" class="">Computer</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/principle/" class="">支撑-原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/computer/performance/" class="">Performance</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/" class="">算法</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/thought/" class="">算法思想</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/data_structure/" class="">数据结构</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/basic/algorithm/math/" class="">数学</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-57edaab097f41efb493c8fe5461c9d46" class="toggle"  />
    <label for="section-57edaab097f41efb493c8fe5461c9d46" class="flex justify-between">
      <a href="/docs/tool/" class="">工具</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/" class="">运维</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/monitor/" class="">Monitor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/docker/" class="">Docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/ops/k8s/" class="">Kubernetes</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/enterprise_system/" class="">企业级系统</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/" class="">Develop</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/eclipse/" class="">Eclipse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/vim/" class="">VIM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/apple/" class="">Apple</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/develop/jetbrains/" class="">Jetbrains</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/" class="">Linux</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_program/" class="">LinuxProgram</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/scene/" class="">LinuxScene</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/linux/linux_tool/" class="">LinuxTool</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/product/framework/" class="">Framework</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/physics/" class="">实物工具</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/" class="">测试</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tool/test/debug/" class="">程序调试</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-42c70ef47fd41d9af53858047493d78c" class="toggle"  />
    <label for="section-42c70ef47fd41d9af53858047493d78c" class="flex justify-between">
      <a href="/docs/db/" class="">数据库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mongodb/" class="">Mongodb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/postgresql/" class="">Postgre SQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/oracle/" class="">Oracle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/db/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2c3dac8cc024b2be2734e956eea228c9" class="toggle" checked />
    <label for="section-2c3dac8cc024b2be2734e956eea228c9" class="flex justify-between">
      <a href="/docs/pl/" class="">程序语言</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/principle/" class="">程序语言原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/haskell/" class="active">Haskell</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/elixir/" class="">Elixir</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/python/" class="">Python</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/clojure/" class="">Clojure</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/js/" class="">JS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/java_reactive/" class="">Java响应式编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/javaweb/" class="">JavaWeb</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/juc/" class="">Java并发</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/jvm/" class="">JVM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/collection/" class="">Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/java/spring/" class="">Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/" class="">Markup Language</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/html/" class="">Html</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/pl/markup_language/css/" class="">Css</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Haskell</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#工具">工具</a></li>
    <li><a href="#单词">单词</a></li>
    <li><a href="#风格">风格</a></li>
    <li><a href="#注意">注意</a></li>
    <li><a href="#文件扩展名">文件扩展名</a></li>
    <li><a href="#内置变量">内置变量</a></li>
    <li><a href="#模块">模块</a></li>
    <li><a href="#命令函数">命令函数</a></li>
    <li><a href="#操作符">操作符</a></li>
    <li><a href="#表达式">表达式</a></li>
    <li><a href="#io-action">I/O action</a></li>
    <li><a href="#类型表示">类型表示</a></li>
    <li><a href="#变量">变量</a></li>
    <li><a href="#函数">函数</a></li>
    <li><a href="#列表">列表</a></li>
    <li><a href="#元组">元组</a></li>
    <li><a href="#monad">monad</a></li>
    <li><a href="#内置函数">内置函数</a></li>
    <li><a href="#函数-1">函数</a></li>
    <li><a href="#类型">类型</a></li>
    <li><a href="#命令">命令</a></li>
    <li><a href="#玄学">玄学</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="介绍">
  介绍
  <a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#</a>
</h1>
<pre><code>源于ML
标准化的、纯函数式编程语言
非限定性语义和强静态类型
作为其他语言设计新功能时的样板，如Python的lambda标记语句
</code></pre>
<h1 id="工具">
  工具
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7">#</a>
</h1>
<pre><code>检索函数用http://www.Haskell.org/hoogle
</code></pre>
<h1 id="单词">
  单词
  <a class="anchor" href="#%e5%8d%95%e8%af%8d">#</a>
</h1>
<pre><code>polymorphism
    # 多态
monomorphic
    # 单态
</code></pre>
<h1 id="风格">
  风格
  <a class="anchor" href="#%e9%a3%8e%e6%a0%bc">#</a>
</h1>
<pre><code>point free style
    sum' xs = foldl (+) 0 xs
    sum' = foldl (+) 0
</code></pre>
<h1 id="注意">
  注意
  <a class="anchor" href="#%e6%b3%a8%e6%84%8f">#</a>
</h1>
<pre><code>使用缩进代替括号，但也可用括号
</code></pre>
<h1 id="文件扩展名">
  文件扩展名
  <a class="anchor" href="#%e6%96%87%e4%bb%b6%e6%89%a9%e5%b1%95%e5%90%8d">#</a>
</h1>
<pre><code># 文件中不用let定义变量, 
# 变量赋值两次会报错, 这意味着代码顺序不重要
hs
</code></pre>
<h1 id="内置变量">
  内置变量
  <a class="anchor" href="#%e5%86%85%e7%bd%ae%e5%8f%98%e9%87%8f">#</a>
</h1>
<pre><code>pi
</code></pre>
<h1 id="模块">
  模块
  <a class="anchor" href="#%e6%a8%a1%e5%9d%97">#</a>
</h1>
<pre><code>:m Data.Char Data.Map
    # 加载模块
    chr
        # chr :: Int -&gt; Char
    ord
        # ord :: Char -&gt; Int
    toUpper
    toLower
import Data.Char
    # 导入到全局命名空间
    import Data.List (nub, sort)
    import Data.List hiding (nub)
    import qualified Data.Map as M
        # 这样其中命名冲突的filter, null函数，只能用Data.Map.filter或M.filter方式调用
可用模块
    prelude
        # 默认载入的模块
    Data
        Char
        List
        Map
        Set
自定义模块
module Geometry.Sphere
(sphereVolume
, sphereArea
, Shape(..)
    # 导出类型和其所有构造子
) where
sphereVolum :: Float -&gt; Float
sphereVolum radius = (4.0 / 3.0) * pi * (radius ^ 3)
</code></pre>
<h1 id="命令函数">
  命令函数
  <a class="anchor" href="#%e5%91%bd%e4%bb%a4%e5%87%bd%e6%95%b0">#</a>
</h1>
<pre><code>:load
    # 加载模块
    :load a.hs
:l
:cd
    # 切换工作目录
    :cd c:\a
:reload
    # 重载所有模块
:r
:type
    :type 'H'
:t
:info
    # 查看一个typeclass有哪些instance和subclass
    # 类型的信息、函数的类型声明
:k
    # 查看kind
    :k Int
        # Int :: *
    :k Maybe
        # Maybe :: * -&gt; *
</code></pre>
<h1 id="操作符">
  操作符
  <a class="anchor" href="#%e6%93%8d%e4%bd%9c%e7%ac%a6">#</a>
</h1>
<pre><code>%
    # 分号
&amp;&amp;
||
++    
    # 字符串拼接
/=
    # 不等
do
    # 动作的combine, do 是&gt;&gt;=的语法糖, 用来连接一系列动作
&lt;-
    # name &lt;- getLine, 存到变量
    # 除了程序的最后一行用来作返回值，其它语句都可以用 &lt;-
</code></pre>
<h1 id="表达式">
  表达式
  <a class="anchor" href="#%e8%a1%a8%e8%be%be%e5%bc%8f">#</a>
</h1>
<pre><code># 表达式可以随处安放
if x &lt; 0 then
    -1
else if x &gt; 0 then
    1
else
    0

case x of
    0 -&gt; 1
    1 -&gt; 5
    _ -&gt; (-1)

let a = 1
    # 局部绑定, in可省略则定义到全局
    twice_a = 2 * a
in (a + twice_a, a - twice_a)
    
let boot x  y z = x * y + z in boot 3 4 2
</code></pre>
<h1 id="io-action">
  I/O action
  <a class="anchor" href="#io-action">#</a>
</h1>
<pre><code># 在main中 I/O action才被执行
# return () 语句产生I/O action, do接着执行
# 执行后会打印结果，结果为()时不打印
main = do
    _ &lt;- putStrLn &quot;a&quot;
    name &lt;- getLine
    putStrLn (name)
</code></pre>
<h1 id="类型表示">
  类型表示
  <a class="anchor" href="#%e7%b1%bb%e5%9e%8b%e8%a1%a8%e7%a4%ba">#</a>
</h1>
<pre><code>Eq a =&gt; a -&gt; a -&gt; Bool
    # =&gt; 前面是类型约束, 后面表示传入两个同类型参数，返回Bool类型
</code></pre>
<h1 id="变量">
  变量
  <a class="anchor" href="#%e5%8f%98%e9%87%8f">#</a>
</h1>
<pre><code>let pi = 3.14
    # 变量不可变，但可重复定义
(-1)
    # 负数一般加小括号
  let r = 25 :: Double
    # 默认猜测是Integer
    # monomorphish restriction(单一同态限定)原理，可以指定polymorphic(多态)
    ## let r = 25 :: Num a =&gt; a
True, False
    # 类型为 Bool
&quot;abc&quot;
    # 类型为[char], 与'a':'b':'c':[]
    a = &quot;aaa&quot; :: String
        # 得到一个String, 与[char]同样使用
LT, GT, EQ
</code></pre>
<h1 id="函数">
  函数
  <a class="anchor" href="#%e5%87%bd%e6%95%b0">#</a>
</h1>
<pre><code># 函数名与参数，参数与参数之间有空格隔开
# 函数比运算符先结合
let area r = pi * r ^ 2
    # 定义函数, 
area 2
area (-2)
let area2 r = area r
let first (x, y) = x
    # 接收元组
uppercase, lowercase :: String -&gt; String
    # 指定函数类型
分段定义
    # 编译成case语句
    f 0 = 1
    f 1 = 5
    f _ = -1
函数合成调用
    square (f 1)
    (square . f) 1
(\xs -&gt; length xs &gt; 15)
    # lambda表达式
    # lambda可以用模式匹配，但使用不了多个模式
</code></pre>
<h1 id="列表">
  列表
  <a class="anchor" href="#%e5%88%97%e8%a1%a8">#</a>
</h1>
<pre><code># 列表，类型必须相同。
# 列表都由[]追加得到，逗号是语法糖
let n = [1, 2]
[1..20]
    # range浮点数不精确
take 20 [1,2..]
[2,4..20]
['a'..'z']
0:n
    # 得到追加列表[0, 1, 2]， 头部追加叫作consing, cons是constructor
    # -1:0:n
[[1], [2]]
n !! 1
    # 取元素
l1 &gt; l2
    # 元素依次比较
[x*2 | x &lt;- [1..10], x*2 &gt;= 12]
    # list comprehension
    boomBangs xs = [if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;-xs, odd x]
    [x*y | x &lt;-[1,2], y &lt;-[3,4]]
        # 聚合得[3,4,6,8]
    length' xs = sum [1 | _ &lt;- xs]

    xxs = [[1,2], [3,4]]
    [[x | x &lt;- xs, even x] | xs &lt;- xxs]

    [(a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 = c ^2]

    [a + b | (a,b) &lt;- xs]
        # list comprehension中的模式匹配
模式匹配
    x:xs
    x:y:z:xs
</code></pre>
<h1 id="元组">
  元组
  <a class="anchor" href="#%e5%85%83%e7%bb%84">#</a>
</h1>
<pre><code># 类型可不同，不能单元素。2元组叫pairs, 3元组叫triples, n元组叫n-tuple
# 元组不可变
# 元组的类型由长度和其中的类型决定, (&quot;a&quot;, 1)与(1, &quot;a&quot;)是不同的类型，所以[(&quot;a&quot;, 1), (2, &quot;b&quot;)]是错误的
(True, 1)
((1,2), True)
</code></pre>
<h1 id="monad">
  monad
  <a class="anchor" href="#monad">#</a>
</h1>
<pre><code>o-&gt; do
doGuessing num = do
    putStrLn &quot;Enter your guess:&quot;
    guess &lt;- getLine
    if (read guess) &lt; num
    then do putStrLn &quot;Too low&quot;
        doGuessing num
    else if (read guess) &gt; num
    then do putStrLn &quot;Too high&quot;
        doGuessing num
    else putStrLn &quot;You Win&quot;
        # 只有一个动作时，可省略do

o-&gt; do
doGuessing num = do
    putStrLn &quot;Enter your guess:&quot;
    guess &lt;- getLine
    case compare (read guess) num of
        LT -&gt; do putStrLn &quot;Too low&quot;
        GT -&gt; do putStrLn &quot;Too high&quot;
        EQ -&gt; putStrLn &quot;You Win&quot;

o-&gt; functor applicative monad
class Functor f where
fmap :: (a -&gt; b) -&gt; f a -&gt; f b
class Functor f =&gt; Applicative f where
pure :: a -&gt; f a
() :: f (a -&gt; b) -&gt; f a -&gt; f b
class Applicative m =&gt; Monad m where
return :: a -&gt; m a
(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
(&gt;&gt;) :: m a -&gt; m b -&gt; m b
x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y
fail :: String -&gt; m a
fail msg = error msg
instance Functor Maybe where
fmap func (Just x) = Just (func x)
fmap func Nothing  = Nothing
instance Applicative Maybe where
pure = Just
Nothing  _ = Nothing
(Just func)  something = fmap func something
instance Monad Maybe where
return = Just
Nothing &gt;&gt;= func = Nothing
Just x &gt;&gt;= func  = func x
</code></pre>
<h1 id="内置函数">
  内置函数
  <a class="anchor" href="#%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0">#</a>
</h1>
<pre><code>prelude
    $
        # 函数调用符，优先级最低。而空格是最高优先级
        # $右结合。而空格左结合
        # 等价于在右而写一对括号
    .
        # f . g = \x -&gt; f (g x)
        # 函数组合
    main
        # main :: IO ()
        main = do
    signum
        # 根据数字返回 -1, 0, 1
    not
    id
        # identity
    unlines
        unlines [&quot;a&quot;, &quot;b&quot;]
            # 成为 &quot;a\nb\n&quot;
    unwords
        unwords [&quot;a&quot;, &quot;b&quot;]
            # 成为 &quot;a b&quot;
    show
        # 接受各种类型，转换为String, 再转义打印
    read
        read &quot;5&quot; :: Int
        read &quot;5&quot; - 2
        read &quot;[1,2,3]&quot; ++ [4]
    reads
        # 读取失败返回[]而不报错
    negate
        # 取反数字
    abs
        # 绝对值
    length
        # 列表的长度, [a] -&gt; Int , a在这里是一个type variable, 以小写字母开头(具体类型都大写开头)。
    map
    compare
        # 返回 LT, GT, EQ其中一个
    min
    max
    compare
        # 返回LT, GT, EQ
        &quot;Abc&quot; `compare` &quot;Zyx&quot;
    mod
        # 取模
    odd
        # 奇数
    even
        # 偶数
    succ
        # 取Enum的后继
    pred
        # 取Enum的前置
    minBound
        # 取Bound下限
    maxBound
    substract
        # 减

    head
    tail
        # 除第一个
    last
    init
        # 除最后一个

    null
        # 检查list是否空
    reverse
        # list反转
    take
        take 1 [1,2,3]
    takeWhile
        # 取list值，直到某条件
    drop
        drop 1 [1,2,3]
    maximum
        # list中最大元素
    minimun
        # list中最小元素
    sum
        # list和
    product
        # list积
    elem
        # 判断元素是否在list中
        4 `elem` [3,4,5]
    cycle
        take 7 (cycle [1,2,3])
            # [1,2,3,1,2,3,1]
    repeat
        repeat 5
    replicate
        replicate 3 10
            # [10, 10, 10]

    fst (1, 2)
        # 只适合2元组
    snd (1, 2)
        # 只适合2元组
    zip
        # zip3, zip4 ... zip7
        zip [1,2,3] [4,5,6]
            # [(1,4), (2,5), (3,6)]
    zipWith
        # zipWith1 ... zipWith7
        zipWith (\x y -&gt; x + y) [1,2] [3,4]
            # [4,6]
    fromIntegral
        # 返回更通用的数字类型
    error &quot;&quot;
        # 抛错
    flip
        # 翻转两个参数调用
    map
    filter
    foldl
        foldl (\acc x -&gt; acc + x) 0 xs
    foldr
        foldr (\x acc -&gt; f x : acc) [] xs
    foldl1
        # 以第一个元素为初始值，空list报错
    foldr1
    foldl'
        # foldl的strict版
    foldr'
    scanl
        # 返回累加过程的list
    scanr
    scanl1
    scanr1
    o-&gt; I/O action
        # 只有在main中执行
        # 类型为 IO a
        putStrLn
            # 只接受String，不转义打印，加换行符
            # putStrLn :: String -&gt; IO () , 表示接收String, 是IO动作, 结果类型是()。表示是一个&quot;IO monad&quot;动作
        putStr
            # 由putChar递归定义，边界条件是空字符串
        putChar
        print
            # 打印Show typeclass的值
        getLine
            # 控制台读一行
            # getLine :: IO String
            name &lt;- getLine
        getChar
        sequence
        # 顺序执行I/O action
        mapM
            mapM print [1,2,3]
                # 对list元素执行sequence f
        mapM_
            # 同mapM，不打印[(),()]
        getContents
            # 读直到 eof (ctrl + d)
        interact
            # 用函数处理输入，返回到输出
Data.List
    # 每个元素存在thunk中
    \
        # 差集
        [1..3] \\ [2]
            # [1,3]
        &quot;Im a big baby&quot; \\ &quot;big&quot;
            # &quot;Im a baby&quot;
    union
    intersection
    insert
        # 插入一个元素到可排序list相对位置
    nub
        # 去重复元素,常用Set转换取代,提高很多效率
    map
        # 导出到了prelude
    filter
        # 导出到了prelude
    intersperse
        intersperse '.' &quot;abc&quot;
            # &quot;a.b.c&quot;
    intercalate
        # 同intersperse, 但插入list
    transpose
        # 二元list列为行
    foldl'
        # fold的严格版，直接计算出中间值，而非用惰性&quot;承诺&quot;塞满堆栈
    foldl1'
    concat
        # 移除一级嵌套
    concatMap
        # 先map再concat
        concatMap (replicate 2) [1..3]
            # [1,1,2,2,3,3]
    and
        # list中全true返回true
        and $ map (&gt;4) [5,6,7,8]
    or
    any
    iterate
        # 无限迭代值到函数，结果形成list
        take 10 $ iterate (*2) 1
    splitAt
        # 断开list, 返回二元组
        splitAt 3 &quot;abcdef&quot;
            # (&quot;abc&quot;, &quot;def&quot;)
    takeWhile
        # 取元素，直到不符合条件
    dropWhile
    span
        # 同takeWhile, 不过返回分割list的二元组
    break
        # 同span, 但在条件首次为true时断开
    sort
        # list元素要求Ord类型，排序list
    group
        # 合并相邻并相等的list元素
    inits
        # init递归调用自身
        inits &quot;abc&quot;
            # [&quot;&quot;, &quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;]
    tails
        # tail递归调用自身
        tails &quot;abc&quot;
            # [&quot;abc&quot;, &quot;bc&quot;, &quot;c&quot;, &quot;&quot;]
    isInfixOf
        # list中搜索子list, 有则返回true
        &quot;cat&quot; `isInfixOf` &quot;im a cat&quot;
    isPrefixOf
        # 是否以某list开头
    isSuffixOf
        # 是否以某list结尾
    elem
        # 是否包含某元素
    notElem
    partition
        # 条件划分list为二元组
        partition (`elem` ['A'..'Z']) &quot;AbCD&quot;
            # (&quot;ACD&quot;, &quot;b&quot;)
    find
        # 条件查找list, 返回第一个符合元素的Maybe值
    elemIndex
        # 返回elem第一个元素的索引的Maybe值
    elemIndices
        # 返回所有匹配索引的list
    findIndex
    findIndices
    lines
        # 字符串分行到list
    unlines
    words
        # 字符串分词到list
    unwords
    delete
        # 删除list中第一个匹配元素
        delete 'h' &quot;hha&quot;
            # &quot;ha&quot;
    replace
    lookup
        # 用a查找[('a', 'b')]中的b
    genericLength
        # 换Int类型为Num类型
    genericTake
    genericDrop
    genericSplitAt
    genericIndex
    genericReplicate

    nubBy
        # 传递函数判断相等性，取代==
    deleteBy
    unionBy
    intersectBy
    groupBy
    sortBy
    insertBy
    maximumBy
    minimumBy
Data.Monoid
    Monoid
    Product
    Sum
    Any
    All
Data.Foldable
    foldr
    foldl
    foldr1
    foldl1
Data.Function
    on
        ((==) `on` (&gt; 0))
            # 判断相等性，等价于 (\x y -&gt; (x &gt; 0) == (y &gt; 0))
        (compare `on` length)
            # 判断大小
Data.Char
    isControl
        # 是否控制字符
    isSpace
        # 包括空格, tab, 换行等
    isLower
    isUpper
    isAlpha
        # 是否字母
    isAlphaNum
        # 字母或数字
    isPrint
        # 可打印
    isDigit
    isOctDigit
    isHexDigit
    isLetter
        # 同isAlpha
    isMark
        # unicode注音字符
    isNumber
    isPunctuation
        # 是否标点符号
    isSymbol
        # 货币符号
    isSeperater
        # unicode空格或分隔符
    isAscii
        # unicode 前128位
    isLatin1
        # unicode 前256位
    isAsciiUpper
    isAsciiLower
    GeneralCategory
        # 得到字符的分类，一共31类, 属于Eq类型
        generalCategory ' '
            # Space
    toUpper
    toLower
    toTitle
    digitToInt
        # 数字，大小写字母list 转成 int list
    intToDigit
    ord
    char
Data.Map
    # 用avl树实现
    fromList
        # 重复键会忽略，要求key有相等性和排序性
    fromListWith
        # 重复键给函数处理
    toList
    empty
        # 返回空map
    insert
        insert 3 10 map
    insertWith
        # 已包含键时函数处理
    null
        # 检查map是否空
    size
        # 返回map的大小
    singleton
        singleton 3, 9
            # fromList [(3,9)]
    lookup
    member
        # key 是否在map中
    map
    filter
    keys
    elems
Data.Set
    # 要求元素可排序，自动排序、唯一
    # 用avl树实现
    fromList
    intersection
    difference
        # 存在于第一集合而不在第二集合的元素
    union
    null
    size
    member
    empty
    singleton
    insert
    delete
    isSubsetOf    
        # 子集
        fromList [1,2] isSubsetOf fromList [1,2]
    isProperSubsetOf
        # 真子集
    filter
    map
Data.ByteString
    # strict bytestring
    # Empty相当于[], cons相当于:
Data.ByteString.Lazy
    # 每个元素存在chunk中，每个chunk 64k，每个chunk相当于一个strict bytestring
    # cons在chunk不满的时候会新建chunk, cons'是strick版的cons, 会填充chunk
    pack
        # pack :: [Word8] -&gt; ByteString
        pack [80,81]
    unpack
    fromChunks
        # 转换strick bytestring 到lazy
    toChunks
        # lazy转strick
Data.Ratio
Control.Applicative
    Applicative
        class (Functor f) =&gt; Applicative f where
            pure :: a -&gt; fa
            (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
            f &lt;$&gt; x = fmap f x
    ZipList
        ZipList3
        ZipList7
    getZipList
    liftA2
        liftA2 f x y = f &lt;$&gt; x &lt;*&gt; y 
    sequenceA
Control.Monad
    when
        # Bool true时，返回后面的I/O action, 否则return ()
    forever
        # 不断执行后面的I/O action
        forever $ do
            putStr &quot;a&quot;
    forM
        # 同mapM, 但两个参数顺序相反
    liftM
        # monad中的fmap
    liftM2 liftM3 liftM4 liftM5
    `ap`
        # monad中的&lt;*&gt;
    join
        join :: (Monad m) =&gt; m (m a) -&gt; m a
        join mm = do
            m &lt;- mm
            m
    filterM
    foldM
Control.Monad.State
    State
        newtype State s a = State {runState :: s -&gt; (a, s)}
    get
    put
Control.Monad.Error
System.IO
    openFile
        # openFile :: FilePath -&gt; IOMode -&gt; IO Handle
        # data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
        do
        handle = openFile &quot;a.txt&quot; ReadMode
        contents &lt;- hGetContents handle
        putStr contents
        hClose handle
    withFile
        # withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
        # 处理完关掉
        withFile &quot;a.txt&quot; ReadMode (\handle -&gt; do
            contents &lt;- hGetContents handle
            putStr contents)
    readFile
        # readFile :: FilePath -&gt; IO String
        do
        contents &lt;- readFile &quot;a.txt&quot;
        putStr contents
    wirteFile
        # writeFile :: FilePath -&gt; String -&gt; IO ()
        do
        writeFile &quot;a.txt&quot; contents
    appendFile
    hSetBuffering
        # 读binary file时的buffer，默认是系统值
        # data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)
        hSetBuffering handle $ BlockBuffering (Just 2048)
    hFlush
        # 写入时自动Flush
    openTempFile
        (tempName, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot;
    hGetContents
    hClose
    hGetLine
    hPusStr
    hPutStrLn
    hGetChar
System.IO.Error
    catch
        # catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a
        toTry `catch` handler
        handler e
            | isDoesNotExistError e = 
                case ioeGetFileName e of Just path -&gt; putStrLn $ &quot;a&quot; ++ path
                    Nothing -&gt; putStrLn &quot;b&quot;
            | otherwise = ioError e
    isDoesNotExistError
    isAlreadyExistsError
    isFullError
    isEOFError
    isIllegalOperation
    isPermissionError
    isUserError
    ioeGetFileName
        # ioeGetFileName :: IOError -&gt; Maybe FilePath
    ioError
        # 丢出接到的error
System.Directory
    removeFile
        removeFile &quot;a.txt&quot;
    renameFile
        renameFile tempName &quot;a.txt&quot;
    copyFile
    doesFileExist
System.Environment
    getArgs
    getProgName
System.Random
    mkStdGen
        # mkStdGen :: Int -&gt; StdGen
    getStdGen
        # IO类型, 得到系统启动时的global generator
    newStdGen
        # 把现有的random generator分成两个新的generators, 其中一个指定成新的，返回另一个
    random
        # random :: (RandomGen g, Random a) = g -&gt; (a, g)
        random (mkStdGen 100) :: (Int, StdGen)
    randoms
        take 5 $ randoms (mkStdGen 11) :: [Int]
    randomR
        # 区间random
        randomR (1,6) (mkStdGen 2)
    randomRs
        take 10 $ randomRs ('a', 'z') (mkStdGen 3) :: [Char]
</code></pre>
<h1 id="函数-1">
  函数
  <a class="anchor" href="#%e5%87%bd%e6%95%b0-1">#</a>
</h1>
<pre><code>o-&gt; 模式匹配
    # case的语法糖
    # 对构造子匹配，如 8 'a' : []
factorial :: (Integral a) =&gt; a -&gt; a
factorial 0 = 1
factorial n = n * factorial (n - 1)

addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

first :: (a, b, c) -&gt; a
first (x, _, _) = x

tell :: (Show a) =&gt; [a] -&gt; String
tell [] = &quot;&quot;
tell [x: []] = &quot;&quot;
tell [x:y:[]] = &quot;&quot;
tell [x:y:_] = &quot;too long, the first is &quot; ++ show x ++ &quot; and the second is &quot; ++ show y

length' :: (Num b) =&gt; [a] -&gt; b
length' [] = 0
length' (_:xs) = 1 + length' xs

capital :: String -&gt; String
capital &quot;&quot; = &quot;&quot;
capital all@(x:xs) = &quot;The first letter of &quot; ++ all ++ &quot; is &quot; ++ [x]
    # @是as模式

o-&gt; guard
bmiTell :: (RealFloat a) =&gt; a -&gt; String
bmiTell weight height
    | bmi &lt;= skinny = &quot;You're underweight&quot;
    | bmi &lt;= normal = &quot;You're supposedly normal&quot;
    | bmi &lt;= fat = &quot;You're fat&quot;
    | otherwise = &quot;You're a whale&quot;
    where bmi = weight / height ^ 2
    (skinny, normal, fat) = (18.5, 25.0, 30.0)
        # where是语法结构，不是表达式
calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]
calcBmis xs = [bmi w h | (w, h) &lt;- xs, let bmi = w / h ^ 2]

myCompare :: (Ord a) =&gt; a -&gt; a -&gt; Ordering
a `myCompare` b
    | a &gt; b = GT
    | a == b = EQ
    | otherwise = LT

o-&gt; quicksort
quicksort :: (Ord a) =&gt; [a] -&gt; [a]
quicksort [] = []
quicksort (x:xs) = 
    let smallerSorted = quicksort (filter (&lt;=x) xs)
        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]
    in smallerSorted ++ [x] ++ biggerSorted

o-&gt; curry
compareWithHundred :: (Num a, ord a) =&gt; a -&gt; Ordering
compareWithHundred = compare 100

divideByTen :: (Floating a) =&gt; a -&gt; a
divideByTen = (/10)
    # 中缀函数用括号来不完全调用
    # 但(-4)表示负4, (substract 4)来表示减4函数

o-&gt; 高阶函数
applyTwice :: (a -&gt; a) -&gt; a -&gt; a
applyTwice f x = f (f x)

o-&gt; lambda
addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a
addThree = \x -&gt; \y -&gt; \z -&gt; x + y + z

o-&gt; $ 做数据函数
map ($ 3) [(4+), (10*), (^2), sqrt]
</code></pre>
<h1 id="类型">
  类型
  <a class="anchor" href="#%e7%b1%bb%e5%9e%8b">#</a>
</h1>
<pre><code>类型
    Int
        # 有界整数
    Integer
        # 无界整数
    Float
        # 单精度浮点数
    Double
    Bool
    Char
    Maybe
    []
    ()
    a
        # type variables
类型约束
    Eq
    # 可判断相等性的类型，可用 == 或 /= 判断
        # 只除函数
    Ord
        #可比较大小的类型, 必定是Eq
        # 只除函数
    Ordering
        # 只有GT, EQ, LT
    Show
        # 可用字符串表示的类型
        # 只除函数
    Read
        # 与Show相反
    Enum
        # 连续的类型，有后继子(successer)和前置子(predecesor), 分别通过succ函数和pred函数得到
        # 可以[1..2]构造list
        # 包含 (), Bool, Char, Ordering, Int, Integer, Float, Double
    Bounded
        # 有上限和下限
        # 如果Tuple中都属于Bounded, 那么这个Tuple属于Bounded
    Num
        # 数字特征
    Integral
        # 整数
    Floating
        # 浮点，包含Float和Double
构造类型
    data Bool = False | True deriving (Ord)
        # Bool是构造的类型, False为值构造子，值可以用:t查看其类型
        # 值构造子可以用于模式匹配
        # 这里值构造子是没有参数的，叫作nullary
        # False在True前，所以比较时True比False大
    data Point = Point Float Float deriving (Show)
        # 值构造子可以与类型同名
    data Shape = Circle Point Float | Rectangle  Point Point deriving (Show)
        # 派生自Show, 就可show值成字符串
    data Person = Person {firstName :: String
        , lastName :: String
        } deriving (Show)
            # Record Syntax, 同 Person String String,  但自动生成同名的取值函数，show显示也改变
        let p = Person {firstName=&quot;aa&quot;, lastName=&quot;bb&quot;}
    
        tellPerson :: Person -&gt; String
        tellPerson (Person {firstName = a, lastName = b}) = a ++ b
    newtype CharList = CharList {getCharList :: [Char]} deriving {Eq, Show}
        # newtype将现有类型包成新类型，只能定义单一值构造子，且其只能有一个字段。并将包裹和解开的成本都去掉
类型构造子
    # data声明中不能加类型约束
    data Maybe a = Nothing | Just a
    data Car a b = Car { company :: a
        , year :: b
        } deriving (Show)
    tellCar :: (Show a) =&gt; Car String a -&gt; String
类型别名
    type String = [Char]
    type AssocList k v = [(k,v)]
        # 别名类型构造子
    type IntMap = Map Int
        # 不全调用得到不全类型构造子, 同 type intMap v = Map Int v
infixr
    infixr 5 :-:
        # 定义中缀构造子, 5是优先级, :-:是符号
        # 默认left-associative

    infixr 5 .++
    (.++) :: List a -&gt; List a -&gt; List a
    Empty .++ ys = ys
    (x :-: xs) .++ ys = x :-: (xs .++ ys)
recursive data structures
    data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
typeclass
    class Eq a where
        (==) :: a -&gt; a -&gt; Bool
        (/=) :: a -&gt; a -&gt; Bool
        x == y = not (x /= y)
        x /= y = not (x == y)
            # 只需要instance一个定义就好，这个定义叫minimal complete definition
    data TrafficLight = Red | Yellow | Green
    instance Eq TrafficLight where
        Red == Red = True
        Green == Green = True
        Yellow == Yellow = True
        _ == _ = False
    instance Show TrafficLight where
        show Red = &quot;Red light&quot;
        show Yellow = &quot;Yellow light&quot;
        show Green = &quot;Green light&quot;

    class (Eq a) =&gt; Num a where
        # Num 是 Eq  的 subclass, 要是Num必是Eq

    instance (Eq m) =&gt; Eq (Maybe m) where
        Just x == Just y = x == y
        Nothing == Nothing = True
        _ == _ = False
            
o-&gt; Either
data Either a b = Left a | Right a deriving (Eq, Ord, Read, Show)

o-&gt; Tree
data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)

o-&gt; YesNo
class YesNo a where
    yesno :: a -&gt; Bool
instance YesNo Int where
    yesno 0 = False
    yesno _ = True

o-&gt; Functor
class Functor f where
    # map over
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
instance Functor Maybe where
    # 接收构造子而非类型
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
instance Functor (Either a) where
    # parital apply Either, Either a 是个类型构造子
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x
instance Functor ((-&gt;) r) where
    # 对函数的functor
    fmap f g = (\x -&gt; f (g x))
</code></pre>
<h1 id="命令">
  命令
  <a class="anchor" href="#%e5%91%bd%e4%bb%a4">#</a>
</h1>
<pre><code>ghci
    set prompt &quot;ghci&gt; &quot;
        # 设置显示的提示符
ghc
    ghc --make a.hs
runhaskell
ghc-pkg list
    # 列出已安装的软件包
</code></pre>
<h1 id="玄学">
  玄学
  <a class="anchor" href="#%e7%8e%84%e5%ad%a6">#</a>
</h1>
<pre><code>o-&gt;
:{
data X = X
a :: Int -&gt; Int
a x = x + 3
:}
</code></pre>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/commit/527b54f06fb1e4192f7f9c86cfded0cda859d1b3" title='Last modified by shenwenqing | Jun 16, 2019' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="" />
      <span>Jun 16, 2019</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/outrunJ/hugo-blog/tree/master/content/content/docs/pl/haskell.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#工具">工具</a></li>
    <li><a href="#单词">单词</a></li>
    <li><a href="#风格">风格</a></li>
    <li><a href="#注意">注意</a></li>
    <li><a href="#文件扩展名">文件扩展名</a></li>
    <li><a href="#内置变量">内置变量</a></li>
    <li><a href="#模块">模块</a></li>
    <li><a href="#命令函数">命令函数</a></li>
    <li><a href="#操作符">操作符</a></li>
    <li><a href="#表达式">表达式</a></li>
    <li><a href="#io-action">I/O action</a></li>
    <li><a href="#类型表示">类型表示</a></li>
    <li><a href="#变量">变量</a></li>
    <li><a href="#函数">函数</a></li>
    <li><a href="#列表">列表</a></li>
    <li><a href="#元组">元组</a></li>
    <li><a href="#monad">monad</a></li>
    <li><a href="#内置函数">内置函数</a></li>
    <li><a href="#函数-1">函数</a></li>
    <li><a href="#类型">类型</a></li>
    <li><a href="#命令">命令</a></li>
    <li><a href="#玄学">玄学</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












