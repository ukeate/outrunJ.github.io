<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程序语言 on ukeate的笔记</title>
    <link>https://ukeate.com/docs/pl/</link>
    <description>Recent content in 程序语言 on ukeate的笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://ukeate.com/docs/pl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>程序语言原理</title>
      <link>https://ukeate.com/docs/pl/principle/</link>
      <pubDate>Wed, 10 Oct 2018 15:13:01 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/principle/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;注意&#xA;    比较语言，共通处(抽象的元知识)是要点&#xA;    在历史上判断设计者意图     # 利于了解知道的根基&#xA;    不同规则，只在特点语言中合理      # 如0在ruby为真&#xA;历史&#xA;    EDSAC           # 1949，纸带&#xA;    FORTRAN         # 1954, 中缀表达式, 运算符优先级、结合性&#xA;    FORTH           # 1958, 没有语法，后缀表达式，语法树&#xA;    LISP            # 1958, 括号，前缀表达式，语法树&#xA;语法&#xA;    引入优先级和左右结合&#xA;    规则不冲突是困难的&#xA;        vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;    # c++的语法缺陷, &amp;gt;&amp;gt;是位运算，必须加空格&#xA;结构化     # 60年代&#xA;    if          # 汇编是判断再向后跳代码, if使可读性好&#xA;    while       # 可读了反复执行的if&#xA;    for         # 可读了数值渐增的while&#xA;    foreach     # 可读了集合遍历&#xA;函数&#xA;    作用&#xA;        便于理解    # 组织划分部门&#xA;        便于再利用   # 再利用无代码成本&#xA;    用了跳转命令和返回命令      # 从记录函数前后地址到函数记录返回地址&#xA;    栈记录多级调用             # 解决多级调用返回地址被覆盖问题&#xA;    递归                     # 处理嵌套数据结构时，代码的嵌套结构&#xA;错误处理&#xA;    历史&#xA;        UNIVACI         # 1950, 溢出时中断(interrupt)跳转到000&#xA;        COBOL           # 1959, 两种类型错误，用两关键字处理&#xA;        PL/I            # 1964&#xA;            先定义出错处理代码。编程时引入on语句goto到处理代码, 不检查返回值&#xA;            可定义新错误类型, 可用signal condition主动出错&#xA;        john goodenough # 1975，论文&#xA;            程序员可能忘处理异常、在不正确位置处理、处理不正确类型异常&#xA;            应该声明可能抛出的异常、将可能出错结构括起来的语句结构&#xA;        CLU             # 1975, begin ... end 后 except 错误类型, 再写错误处理语句&#xA;        C++             # 1983, 1984-1989多次讨论，try{}catch{}, throw抛异常(没用raise和signal, 因为它们已经使用了)&#xA;        Windows NT 3.1  # 1993, 使用finally&#xA;        Java            # 1995, 引入finally&#xA;        D               # 2001, 作用域守护取代finally, 写在初始化语句后面scope(exit) unlock(m)&#xA;    方式&#xA;        返回值           # 遗漏错误，可读性下降&#xA;        异常处理         # 函数多出口&#xA;            必执行代码        # 成对操作无遗漏，不使用goto执行同段代码&#xA;                finally      # java, ruby, python&#xA;                析构函数      # c++, RAII(资源获取即初始化, resource acquisition is initialization)&#xA;    何时使用异常          # 有不同的规则。缺少参数，js不抛异常。数据越界，js返回undefined, ruby返回nil&#xA;        出错立刻抛异常     # 错误优先(fail first), 早发现问题&#xA;    异常传递              # 一层层函数向上传递，都无处理时程序异常退出&#xA;        上层函数不了解下层异常细节&#xA;        不了解下层调用不能捕获全部异常     # java用检查型异常解决, 但很麻烦&#xA;取名&#xA;    编号到取名       # 对照表实现, 变量名或函数名&#xA;    实现&#xA;        整个程序共用一个对照表     # perl无声明变量, 全局作用域、全局变量&#xA;                                # 1994 javascript&#xA;            解决冲突&#xA;                更长变量名&#xA;                作用域&#xA;        动态作用域               # 1991 perl4 local变量&#xA;                                # 1958 lisp&#xA;            之前存变量原值，之后用原值覆盖变量&#xA;            中间函数调用时，变量不是原值, 要看调用前所有代码   # 全局污染&#xA;        静态作用域               # 1975 scheme，调用时建专用对照表(属于调用而非函数)，查找变量更优先。&#xA;            # 又叫字面作用域(lexical scope), 因为和字面范围一致&#xA;                                # 1991 perl5 my变量&#xA;                                # 1991 python&#xA;                                # 1994 javascript val变量&#xA;                                # 1995 ruby&#xA;        python&#xA;            内置作用域           # 语言提供，如js的全局对象作用域&#xA;            全局作用域           # 当前文件字面&#xA;            局部作用域           # 函数&#xA;        赋值即定义&#xA;            嵌套函数直接找全局作用域，不字面上找外部函数作用域        # 2.0问题, 2001年2.1修复&#xA;            不能改变外部变量                                    # 2006年3.0 nonlocal声明为外部变量&#xA;类型&#xA;    比特列标记类型，解释成不同数据&#xA;    整数&#xA;        excess-3(加三码)       # UNIVACI, 4位表示0到9&#xA;        二进制                 # 1983, 任天堂计算机8位表示整数。目前32位和64位表示整数&#xA;            八进制(3位切分), 十六进制(4位切分)&#xA;    实数&#xA;        单独记小数点左移位数        # 定点数，不好实现和计算。&#xA;            银行用加三码和定点数&#xA;        前位段表示数，后位段表示小数点位置       # 浮点数，也可表示大整数&#xA;            IEEE 754        # 有误差&#xA;                第一位符号&#xA;                中8位是指数(-127-128), 负向左移正向右移，-127代表0, 128代表无限大&#xA;                后23位是尾数，从左到右代表1/2, 1/4, 1/8...&#xA;        二-十进制码          # 用二进制表示十进制，加三码是一种，无误差&#xA;    发展&#xA;        变量名表示类型         # FORTRAN, I-N开头表示整数，其它表示浮点数&#xA;        声明类型&#xA;        隐式类型转换           # 整数+浮点数，FORTRAN出错，c都转换为浮点数, 整数除法舍弃小数&#xA;            ML(1973年)中, 整数除法用x div y, 小数除法用 x / y&#xA;            python3.0(2008年)中, 不带舍去除法用 x / y, 带舍去除法用 x // y&#xA;    用户定义类型           # c中的结构体, c++中函数成为类型，用户实现的类型称为类&#xA;        类型即功能             # 访问控制(公开、非公开)&#xA;        接口                  # 不包含实现细节的类型&#xA;        异常成为类型           # CLU和Java&#xA;        类型实现所有功能        # 未实现。类型一致，功能就成立，没有bug&#xA;            类型不能表达的：数据处理时间，处理用内存，是否可以在线程中操作等&#xA;    总称型(部分可变类型)    # 类型为参数创建类型，c++的模板，java的泛型，haskell的类型构造器&#xA;    动态类型               # 类型信息和数值看作整体, 静态类型把变量名、内存地址、内存里的内容类型作为整体&#xA;        内存中同等类型对待，其中再细分类型&#xA;        灵活，运行时确定类型，但不能执行前编译检查bug&#xA;    类型推导               # 最早OCaml和Haskell这类ML语言擅长，现Scala等语言也越来越多&#xA;        目标是证明程序没有bug&#xA;容器&#xA;    语言中用语不共通           # haskell列表是链表，不可变，元组是放不同类型的列表&#xA;    数组、链表&#xA;    字典(散列、关联数组)       # 字典散列或树实现&#xA;    树&#xA;字符串&#xA;    字符集和字符编码           # 有的认为就按效率特异化编码，有的认为应标准化&#xA;        摩斯码                # 长短组合&#xA;        博多码                # 5位一字符，先通知字符种类&#xA;        EDSAC                # 5位一字符，shift切换，内容和博多码不同。用5孔纸带&#xA;        ASCII                # 7位&#xA;            EBCDIC           # IBM，8位&#xA;        ISO-xxx              # 区域化&#xA;            魔术注释符        # 告诉语言处理器编码，特殊记号事先写明&#xA;        unicode              # 统一&#xA;    字符串&#xA;        c语言一字符8位，定义字符为ASCII或EBCDIC。字符串不知长度，nul字符终止，没nul时可能内存中越界读取&#xA;        pascal一字符8位，带长度&#xA;        java一字符16位, 定义字符为unicode&#xA;        python2 ASCII码环境下，字符当作ASCII码，可以自动转换成unicode&#xA;        python3中&amp;quot;&amp;quot;是unicode码, b&amp;quot;&amp;quot;是字节列串，要显示转换类型，否则报错&#xA;        ruby一字符8位，追加编码信息&#xA;面向对象                      # 不同语言中面向对象意义不同&#xA;                             # goto因强大让人困惑，退出历史。面向对象、Trait也有这因素&#xA;    两种立场&#xA;        c++, 类是用户自定义类型，Simula语言的继承机制是关键&#xA;        smalltalk, 类让人痛苦，不要继承，不同状态对象传消息来通信&#xA;    历史              # ALGOL产生model思想(1958年), Simula , Smalltalk, C++, Java&#xA;        类在大部分语言中不是不可或缺的&#xA;        Java: 类是部件，将其组装就是程序设计&#xA;    归集方法和建模的发展              # 围绕实现多实例问题&#xA;        强关联元素分组存放，便于理解&#xA;        module                      # 关联函数集中, 1978年Modula-2引入, python, ruby叫模块，java, perl叫包&#xA;            初始化散列, 再作为参数传入包中函数，函数修改散列&#xA;            包提供初始化函数, 返回散列, 该函数成为构造函数(java叫工厂方法)。但使用包函数都要传入散列&#xA;            bless函数(perl)绑定包和散列产生blessed hash对象，它的方法对应包方法, curry了散列做参数&#xA;            包的初始化函数自己绑定, 返回blessed hash对象&#xA;        变量和函数放入散列            # js对象&#xA;            函数放入散列                                # 函数成为一等公民(first class citizen)，可赋值给变量。FORTRAN66中字符串还不是一等公民&#xA;                                                       # first-class function的思想来自Scheme语言&#xA;            函数中通过this隐式获取自身做散列              # perl中显示获得散列&#xA;            创建构造函数，返回以上散列。但返回的散列上都定义了新的函数&#xA;            把函数单独放置在包或对象, 使用时很麻烦&#xA;            引入原型概念,对象变量查找作用域在原型链中扩展    # 这里是委托方式的原型，也可以在实例化时通过负责来实现。原型变更的处理，不同语言有差异&#xA;                                                        # prototype-based的思想来自Self语言&#xA;            定义new f()运算, 函数f的原型是以上散列，多个new的新对象共享了散列的函数&#xA;                新对象原型指向函数f的原型&#xA;                以新对象为this,执行f&#xA;        闭包(closure)                # 维持内部作用域状态的函数, 作用域呈封闭状态&#xA;        类&#xA;            分类/分组                 # 1965年ALGOL提出&#xA;            用户定义类型              # 1979年c++, 参考Simula&#xA;                最初c语言结构体&#xA;                声明和定义类方法       # Smalltalk方法调用是传送消息，调未定义方法是否出错由该类决定&#xA;                作用                  # 成为一种模具&#xA;                    生成器            # module和散列只有该作用&#xA;                    可行操作的功能说明(类型、泛型)&#xA;                    代码再利用的单位(继承)&#xA;        继承&#xA;            实现策略&#xA;                父类实现一般化, 子类是父类的专门化&#xA;                共享部分提取           # 子类不是父类的一种, 函数思想考虑问题&#xA;                差异实现               # 覆盖变更部分，为了再利用使实现更轻松，不倾向使用&#xA;            问题&#xA;                多层级问题&#xA;                    向上不好找方法定义&#xA;                    修改方法时，向下影响子类    # 如动态作用域问题&#xA;                里氏替换原则               # 1987年提出，对父类成立的条件，一定对子类成立。为了维护父子关系间的一致性，继承是is-a关系&#xA;                    实际编程中，子类功能增加常打破里氏替换原则，无论是在开始设计上避免还是在开发中放弃继承都很麻烦&#xA;            多重继承                      # 东西常常不属于一个分类,java禁止多重继承&#xA;                问题&#xA;                    多父类成员名冲突&#xA;                        委托(delegation)  # 聚合(aggregation)，咨询(consultation), 不用多重继承，把原父类对象作为子类成员,后发展出依赖注入&#xA;                        接口多重继承       # Java引入，php5(2004年)引入&#xA;                        按顺序搜索&#xA;                            深度优先               # python2.1, 菱形继承中，第一层父类的值会覆盖第二层右边父类的值&#xA;                            C3线性化               # 1996年提出，python2.3, perl6默认, 对类编号，子类先于父类检查, 优先检查先书写的类&#xA;                            混入式处理(mix-in)     # 扁平成新类, 该类不能创建实例，python XxxMixIn类， ruby类单一继承，模块混入&#xA;                            Trait                 # 2002年Trait论文，Squeak最早引入, scala, perl6的Roll, php5.4, ruby2.0的mix method&#xA;                                类作用：创建实例(要求全面, 大的类),再利用单元(小的类)冲突&#xA;                                把再利用单元特别化&#xA;                                    ruby模块混入名称冲突时, 使用最后的模块, Trait会报错    # Smalltalk的Squeak处理器可取方法别名，可指定不参与冲突&#xA;                                    scala声明创建实例需要的方法, 另一Trait声明提供的方法，组合匹配后可创建实例&#xA;                                    对Trait改写定义新的Trait(继承), Trait组合成新Trait&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;原理&#34;&gt;&#xA;  原理&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;gc&#xA;    # garbage collector&#xA;    为什么gc&#xA;        减少编程工作量&#xA;        减少内存泄露&#xA;        安全性&#xA;    定位&#xA;        引用计数器(reference counting, java1.1废弃)   # 给每个对象设置计数器，有引用+1, 失效-1&#xA;            不能解决循环引用问题  # A, B互相引用不回收&#xA;            计数器修改开销大&#xA;        根搜索算法(使用)   # 从GC Roots对象起点，向下搜索，路径成为Reference Chain, 不可达对象不可用&#xA;            GC Roots包括&#xA;                虚拟机栈(栈帧中本地变量表)中的引用对象&#xA;                方法区域中的类静态引用对象&#xA;                方法区域中常量引用对象&#xA;                本地方法栈JNI(native方法)引用的对象&#xA;    回收算法&#xA;        标记-清除(mark-sweep)   # DVM(Dalvik Virtual Machine, 安卓用)使用的算法&#xA;            # 效率不高，清除后产生大量不连续空间&#xA;            标记所有要回收的对象&#xA;            清除标记对象&#xA;        复制(copying)&#xA;            # 实现简单，效率高。内存利用率不高&#xA;            # 用于新生代，两块比例8:1&#xA;            内存分成相等两块，使用其中一块&#xA;            回收时，存活对象复制到另一块，这块整个清理掉&#xA;        标记-整理(mark-compact)&#xA;            # 适合老年代&#xA;            把存活对象往内存一端移动&#xA;            回收边界外内存&#xA;        分代收集(generational collection)&#xA;            新生代用复制算法&#xA;            老年代用标记-整理算法&#xA;    4种引用类型回收   # java强引用、软引用、弱引用、虚引用&#xA;    方法区回收&#xA;        废弃的常量   # 看引用计数&#xA;        无用的类&#xA;            实例都已经回收&#xA;            加载该类的ClassLoader已回收&#xA;            该类的class对象没有被引用，无法反射该类的方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;异步编程&#34;&gt;&#xA;  异步编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;事件  # 高阶函数的优势&#xA;    解耦业务逻辑&#xA;问题&#xA;    异常处理    # 不能同步catch&#xA;    回调嵌套过深&#xA;    单线程模型中，业务处理阻塞全局&#xA;    异步转同步&#xA;实现&#xA;    事件发布订阅&#xA;        回调函数事件化(钩子机制)&#xA;    cps: continuation-passing style&#xA;        在函数式编程中, 多传一个参数k明确控制continuation&#xA;    promise/deferred        # promise/A, promise/B, promise/D模型&#xA;        # promise在外部暴露接口(可变部分), deferred在内部维护状态(不可变部分)&#xA;        状态&#xA;            未完成，完成，失败&#xA;            方向只能未完成-&amp;gt;完成, 未完成-&amp;gt;失败&#xA;            状态转化不能更改&#xA;        api&#xA;            then()&#xA;            done()&#xA;            all()     # 所有成功成功，一失败失败&#xA;            any()&#xA;    流程控制库&#xA;        尾触发     # 传next()函数&#xA;        async库(node.js)&#xA;            series()        # 串行&#xA;            parallel()      # 并行&#xA;            waterfall()     # 串行传结果&#xA;            auto()          # 计算依赖顺序执行&#xA;        bagpipe库(node.js)   # 限制并发, 任务可排队或拒绝, 超时控制&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;编译&#34;&gt;&#xA;  编译&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e8%af%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 流程&#xA;    词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成，表格管理，错误处理&#xA;    语义分析 -&amp;gt; 类型检查/推导 -&amp;gt; 代码优化 -&amp;gt; 机器码生成&#xA;            # 中间数据结构, 比如AST&#xA;    预处理，连接程序，装入程序，调试程序&#xA;&#xA;# 文法&#xA;    G = (Vn, Vt, S, P)&#xA;            # 终极符号, 非终级符号, 一个特殊非终级符号，产生式&#xA;    类型&#xA;            短语(0), 对应图灵机(TM)&#xA;            上下文相关(1), 对应线性有界自动机(LBA)&#xA;            上下文无关(2), 对应下推自动机(PDA)&#xA;            线性文法、正则文法、正规文法，对应有限自动机(FA)&#xA;                    # 无法控制自返数&#xA;# 状态机(FA)&#xA;    确定状态机(DFA)&#xA;    非确定状态机(NFA)&#xA;            # 同状态可多种转移&#xA;    DFA与NFA互相转换&#xA;# 词法分析&#xA;    状态转换矩阵法&#xA;# 语法分析&#xA;    # 源代码读入、解析成语法树&#xA;    自顶向下&#xA;            # 最左推导建立语法树&#xA;            # first集，follow集，predict集&#xA;            不回溯方法&#xA;            递归下降&#xA;            LL(1)&#xA;                    # 从左输入符号、产生左推导、每次读一个字符。LL(k)特例&#xA;    自底向上&#xA;            # 从左读, 从右向前归约&#xA;            简单优先关系&#xA;                    # 运算符优先关系矩阵&#xA;            LR(k)&#xA;                    # 从左输入，最右推导&#xA;                    LR(0)&#xA;                            # 只看栈顶状态，有分析动作冲突&#xA;                    SLR(1)&#xA;                            # LR(0)加向前看展望符，不能分析所有文法&#xA;                    LR(1)&#xA;                            # LR(0)的每个推导加一个向前搜索符，状态太多&#xA;                    LALR(1)&#xA;                            # LR(1)中同向前搜索符的状态合并&#xA;# 语义分析&#xA;    抽象语法树&#xA;    符号表&#xA;            # 动态规划记录变量的综合信息&#xA;    局部化处理&#xA;            # 压栈变量作用域&#xA;# 中间代码生成&#xA;    后缀式(逆波兰式)&#xA;    三地址&#xA;            # 操作符两变量地址，结果地址&#xA;    四元式操作符&#xA;            # 地址加，赋值，过程调用，类型转换，算术、逻辑、关系运算的存储&#xA;    语法制导&#xA;            # 中间代码产生式后拼上语义程序，在语法分析中遇到动作马上处理&#xA;    类型检查&#xA;    下标变量&#xA;            # 如数组下标，同上全用四元式表示&#xA;# 中间代码优化&#xA;    常量表达式&#xA;            a = 1, b = 2, c = a + b, 则只记c = 3&#xA;    公共表达式&#xA;            a = b * c, d = b * c, 则只记a&#xA;    循环不变式外提&#xA;            while k &amp;lt; 0 do b * c, 则b * c外提只计算一次&#xA;    基本块&#xA;            # 一块语句要么全执行，要么全不执行&#xA;    消减运算强度&#xA;            如加法代替乘法&#xA;    复写传播&#xA;            a = b, 后a, b不再变值，用a替代b&#xA;    无用代码消除&#xA;    数学优化（恒等变换）&#xA;            如a + 0 = a, a * 1 = a, a ^ 2 = a * a, a / 1 = a, 0 / a = 0&#xA;    窥孔优化&#xA;            对目标代码中短指令序列局部改进，如删除重复，控制流优化，代数化简，使用特殊指令等&#xA;    全局优化&#xA;            对整个程序控制流和数据分析再优化，如常量表达式全局优化&#xA;# 运行时时空管理&#xA;    内存划分&#xA;            存储&#xA;                    引用的库的代码&#xA;                    目标代码&#xA;                    静态变量&#xA;                    栈区&#xA;                            # 函数调用，中断现场&#xA;                    堆区&#xA;            存储策略&#xA;                    静态分配&#xA;                            #编译时分配固定存储单元&#xA;                    动态分配&#xA;                            栈&#xA;                            堆&#xA;            活动记录&#xA;                    保存局部变量，中间结果，临时变量，过程调用，控制信息等&#xA;                    专用寄存器&#xA;                    调用链&#xA;                            # 保存下一个调用的起始地址&#xA;                    动态链&#xA;                            # 保存前一个调用的起始地址&#xA;            访问环境&#xA;                    # 记录闭包起始地址&#xA;                    display表&#xA;                            # 过程需要的所有非局部数据所在的过程活动记录的起始地址&#xA;                    全局display表&#xA;                    静态链&#xA;                            # 指向外层过程的活动记录的地址地址&#xA;# 目标代码生成&#xA;    生成的语言&#xA;            机器语言&#xA;            可重定位的机器语言&#xA;                    # 由连接器装配后生成机器语言&#xA;                    # 多数用这种，如c语言&#xA;            汇编语言&#xA;    指令选择&#xA;    虚拟机&#xA;    寄存器分配&#xA;    四元式翻译&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Haskell</title>
      <link>https://ukeate.com/docs/pl/haskell/</link>
      <pubDate>Tue, 09 Oct 2018 16:54:16 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/haskell/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;源于ML&#xA;标准化的、纯函数式编程语言&#xA;非限定性语义和强静态类型&#xA;作为其他语言设计新功能时的样板，如Python的lambda标记语句&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;检索函数用http://www.Haskell.org/hoogle&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;单词&#34;&gt;&#xA;  单词&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%95%e8%af%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;polymorphism&#xA;    # 多态&#xA;monomorphic&#xA;    # 单态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;风格&#34;&gt;&#xA;  风格&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a3%8e%e6%a0%bc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;point free style&#xA;    sum&#39; xs = foldl (+) 0 xs&#xA;    sum&#39; = foldl (+) 0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;注意&#34;&gt;&#xA;  注意&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e6%84%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用缩进代替括号，但也可用括号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;文件扩展名&#34;&gt;&#xA;  文件扩展名&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e6%89%a9%e5%b1%95%e5%90%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 文件中不用let定义变量, &#xA;# 变量赋值两次会报错, 这意味着代码顺序不重要&#xA;hs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内置变量&#34;&gt;&#xA;  内置变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;pi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模块&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:m Data.Char Data.Map&#xA;    # 加载模块&#xA;    chr&#xA;        # chr :: Int -&amp;gt; Char&#xA;    ord&#xA;        # ord :: Char -&amp;gt; Int&#xA;    toUpper&#xA;    toLower&#xA;import Data.Char&#xA;    # 导入到全局命名空间&#xA;    import Data.List (nub, sort)&#xA;    import Data.List hiding (nub)&#xA;    import qualified Data.Map as M&#xA;        # 这样其中命名冲突的filter, null函数，只能用Data.Map.filter或M.filter方式调用&#xA;可用模块&#xA;    prelude&#xA;        # 默认载入的模块&#xA;    Data&#xA;        Char&#xA;        List&#xA;        Map&#xA;        Set&#xA;自定义模块&#xA;module Geometry.Sphere&#xA;(sphereVolume&#xA;, sphereArea&#xA;, Shape(..)&#xA;    # 导出类型和其所有构造子&#xA;) where&#xA;sphereVolum :: Float -&amp;gt; Float&#xA;sphereVolum radius = (4.0 / 3.0) * pi * (radius ^ 3)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令函数&#34;&gt;&#xA;  命令函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;:load&#xA;    # 加载模块&#xA;    :load a.hs&#xA;:l&#xA;:cd&#xA;    # 切换工作目录&#xA;    :cd c:\a&#xA;:reload&#xA;    # 重载所有模块&#xA;:r&#xA;:type&#xA;    :type &#39;H&#39;&#xA;:t&#xA;:info&#xA;    # 查看一个typeclass有哪些instance和subclass&#xA;    # 类型的信息、函数的类型声明&#xA;:k&#xA;    # 查看kind&#xA;    :k Int&#xA;        # Int :: *&#xA;    :k Maybe&#xA;        # Maybe :: * -&amp;gt; *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;操作符&#34;&gt;&#xA;  操作符&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;%&#xA;    # 分号&#xA;&amp;amp;&amp;amp;&#xA;||&#xA;++    &#xA;    # 字符串拼接&#xA;/=&#xA;    # 不等&#xA;do&#xA;    # 动作的combine, do 是&amp;gt;&amp;gt;=的语法糖, 用来连接一系列动作&#xA;&amp;lt;-&#xA;    # name &amp;lt;- getLine, 存到变量&#xA;    # 除了程序的最后一行用来作返回值，其它语句都可以用 &amp;lt;-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;表达式&#34;&gt;&#xA;  表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 表达式可以随处安放&#xA;if x &amp;lt; 0 then&#xA;    -1&#xA;else if x &amp;gt; 0 then&#xA;    1&#xA;else&#xA;    0&#xA;&#xA;case x of&#xA;    0 -&amp;gt; 1&#xA;    1 -&amp;gt; 5&#xA;    _ -&amp;gt; (-1)&#xA;&#xA;let a = 1&#xA;    # 局部绑定, in可省略则定义到全局&#xA;    twice_a = 2 * a&#xA;in (a + twice_a, a - twice_a)&#xA;    &#xA;let boot x  y z = x * y + z in boot 3 4 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;io-action&#34;&gt;&#xA;  I/O action&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#io-action&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 在main中 I/O action才被执行&#xA;# return () 语句产生I/O action, do接着执行&#xA;# 执行后会打印结果，结果为()时不打印&#xA;main = do&#xA;    _ &amp;lt;- putStrLn &amp;quot;a&amp;quot;&#xA;    name &amp;lt;- getLine&#xA;    putStrLn (name)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;类型表示&#34;&gt;&#xA;  类型表示&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b%e8%a1%a8%e7%a4%ba&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Eq a =&amp;gt; a -&amp;gt; a -&amp;gt; Bool&#xA;    # =&amp;gt; 前面是类型约束, 后面表示传入两个同类型参数，返回Bool类型&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;变量&#34;&gt;&#xA;  变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;let pi = 3.14&#xA;    # 变量不可变，但可重复定义&#xA;(-1)&#xA;    # 负数一般加小括号&#xA;  let r = 25 :: Double&#xA;    # 默认猜测是Integer&#xA;    # monomorphish restriction(单一同态限定)原理，可以指定polymorphic(多态)&#xA;    ## let r = 25 :: Num a =&amp;gt; a&#xA;True, False&#xA;    # 类型为 Bool&#xA;&amp;quot;abc&amp;quot;&#xA;    # 类型为[char], 与&#39;a&#39;:&#39;b&#39;:&#39;c&#39;:[]&#xA;    a = &amp;quot;aaa&amp;quot; :: String&#xA;        # 得到一个String, 与[char]同样使用&#xA;LT, GT, EQ&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 函数名与参数，参数与参数之间有空格隔开&#xA;# 函数比运算符先结合&#xA;let area r = pi * r ^ 2&#xA;    # 定义函数, &#xA;area 2&#xA;area (-2)&#xA;let area2 r = area r&#xA;let first (x, y) = x&#xA;    # 接收元组&#xA;uppercase, lowercase :: String -&amp;gt; String&#xA;    # 指定函数类型&#xA;分段定义&#xA;    # 编译成case语句&#xA;    f 0 = 1&#xA;    f 1 = 5&#xA;    f _ = -1&#xA;函数合成调用&#xA;    square (f 1)&#xA;    (square . f) 1&#xA;(\xs -&amp;gt; length xs &amp;gt; 15)&#xA;    # lambda表达式&#xA;    # lambda可以用模式匹配，但使用不了多个模式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;列表&#34;&gt;&#xA;  列表&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%97%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 列表，类型必须相同。&#xA;# 列表都由[]追加得到，逗号是语法糖&#xA;let n = [1, 2]&#xA;[1..20]&#xA;    # range浮点数不精确&#xA;take 20 [1,2..]&#xA;[2,4..20]&#xA;[&#39;a&#39;..&#39;z&#39;]&#xA;0:n&#xA;    # 得到追加列表[0, 1, 2]， 头部追加叫作consing, cons是constructor&#xA;    # -1:0:n&#xA;[[1], [2]]&#xA;n !! 1&#xA;    # 取元素&#xA;l1 &amp;gt; l2&#xA;    # 元素依次比较&#xA;[x*2 | x &amp;lt;- [1..10], x*2 &amp;gt;= 12]&#xA;    # list comprehension&#xA;    boomBangs xs = [if x &amp;lt; 10 then &amp;quot;BOOM!&amp;quot; else &amp;quot;BANG!&amp;quot; | x &amp;lt;-xs, odd x]&#xA;    [x*y | x &amp;lt;-[1,2], y &amp;lt;-[3,4]]&#xA;        # 聚合得[3,4,6,8]&#xA;    length&#39; xs = sum [1 | _ &amp;lt;- xs]&#xA;&#xA;    xxs = [[1,2], [3,4]]&#xA;    [[x | x &amp;lt;- xs, even x] | xs &amp;lt;- xxs]&#xA;&#xA;    [(a,b,c) | c &amp;lt;- [1..10], b &amp;lt;- [1..c], a &amp;lt;- [1..b], a^2 + b^2 = c ^2]&#xA;&#xA;    [a + b | (a,b) &amp;lt;- xs]&#xA;        # list comprehension中的模式匹配&#xA;模式匹配&#xA;    x:xs&#xA;    x:y:z:xs&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;元组&#34;&gt;&#xA;  元组&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%83%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 类型可不同，不能单元素。2元组叫pairs, 3元组叫triples, n元组叫n-tuple&#xA;# 元组不可变&#xA;# 元组的类型由长度和其中的类型决定, (&amp;quot;a&amp;quot;, 1)与(1, &amp;quot;a&amp;quot;)是不同的类型，所以[(&amp;quot;a&amp;quot;, 1), (2, &amp;quot;b&amp;quot;)]是错误的&#xA;(True, 1)&#xA;((1,2), True)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;monad&#34;&gt;&#xA;  monad&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#monad&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; do&#xA;doGuessing num = do&#xA;    putStrLn &amp;quot;Enter your guess:&amp;quot;&#xA;    guess &amp;lt;- getLine&#xA;    if (read guess) &amp;lt; num&#xA;    then do putStrLn &amp;quot;Too low&amp;quot;&#xA;        doGuessing num&#xA;    else if (read guess) &amp;gt; num&#xA;    then do putStrLn &amp;quot;Too high&amp;quot;&#xA;        doGuessing num&#xA;    else putStrLn &amp;quot;You Win&amp;quot;&#xA;        # 只有一个动作时，可省略do&#xA;&#xA;o-&amp;gt; do&#xA;doGuessing num = do&#xA;    putStrLn &amp;quot;Enter your guess:&amp;quot;&#xA;    guess &amp;lt;- getLine&#xA;    case compare (read guess) num of&#xA;        LT -&amp;gt; do putStrLn &amp;quot;Too low&amp;quot;&#xA;        GT -&amp;gt; do putStrLn &amp;quot;Too high&amp;quot;&#xA;        EQ -&amp;gt; putStrLn &amp;quot;You Win&amp;quot;&#xA;&#xA;o-&amp;gt; functor applicative monad&#xA;class Functor f where&#xA;fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;class Functor f =&amp;gt; Applicative f where&#xA;pure :: a -&amp;gt; f a&#xA;() :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;class Applicative m =&amp;gt; Monad m where&#xA;return :: a -&amp;gt; m a&#xA;(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&#xA;(&amp;gt;&amp;gt;) :: m a -&amp;gt; m b -&amp;gt; m b&#xA;x &amp;gt;&amp;gt; y = x &amp;gt;&amp;gt;= \_ -&amp;gt; y&#xA;fail :: String -&amp;gt; m a&#xA;fail msg = error msg&#xA;instance Functor Maybe where&#xA;fmap func (Just x) = Just (func x)&#xA;fmap func Nothing  = Nothing&#xA;instance Applicative Maybe where&#xA;pure = Just&#xA;Nothing  _ = Nothing&#xA;(Just func)  something = fmap func something&#xA;instance Monad Maybe where&#xA;return = Just&#xA;Nothing &amp;gt;&amp;gt;= func = Nothing&#xA;Just x &amp;gt;&amp;gt;= func  = func x&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内置函数&#34;&gt;&#xA;  内置函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;prelude&#xA;    $&#xA;        # 函数调用符，优先级最低。而空格是最高优先级&#xA;        # $右结合。而空格左结合&#xA;        # 等价于在右而写一对括号&#xA;    .&#xA;        # f . g = \x -&amp;gt; f (g x)&#xA;        # 函数组合&#xA;    main&#xA;        # main :: IO ()&#xA;        main = do&#xA;    signum&#xA;        # 根据数字返回 -1, 0, 1&#xA;    not&#xA;    id&#xA;        # identity&#xA;    unlines&#xA;        unlines [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&#xA;            # 成为 &amp;quot;a\nb\n&amp;quot;&#xA;    unwords&#xA;        unwords [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]&#xA;            # 成为 &amp;quot;a b&amp;quot;&#xA;    show&#xA;        # 接受各种类型，转换为String, 再转义打印&#xA;    read&#xA;        read &amp;quot;5&amp;quot; :: Int&#xA;        read &amp;quot;5&amp;quot; - 2&#xA;        read &amp;quot;[1,2,3]&amp;quot; ++ [4]&#xA;    reads&#xA;        # 读取失败返回[]而不报错&#xA;    negate&#xA;        # 取反数字&#xA;    abs&#xA;        # 绝对值&#xA;    length&#xA;        # 列表的长度, [a] -&amp;gt; Int , a在这里是一个type variable, 以小写字母开头(具体类型都大写开头)。&#xA;    map&#xA;    compare&#xA;        # 返回 LT, GT, EQ其中一个&#xA;    min&#xA;    max&#xA;    compare&#xA;        # 返回LT, GT, EQ&#xA;        &amp;quot;Abc&amp;quot; `compare` &amp;quot;Zyx&amp;quot;&#xA;    mod&#xA;        # 取模&#xA;    odd&#xA;        # 奇数&#xA;    even&#xA;        # 偶数&#xA;    succ&#xA;        # 取Enum的后继&#xA;    pred&#xA;        # 取Enum的前置&#xA;    minBound&#xA;        # 取Bound下限&#xA;    maxBound&#xA;    substract&#xA;        # 减&#xA;&#xA;    head&#xA;    tail&#xA;        # 除第一个&#xA;    last&#xA;    init&#xA;        # 除最后一个&#xA;&#xA;    null&#xA;        # 检查list是否空&#xA;    reverse&#xA;        # list反转&#xA;    take&#xA;        take 1 [1,2,3]&#xA;    takeWhile&#xA;        # 取list值，直到某条件&#xA;    drop&#xA;        drop 1 [1,2,3]&#xA;    maximum&#xA;        # list中最大元素&#xA;    minimun&#xA;        # list中最小元素&#xA;    sum&#xA;        # list和&#xA;    product&#xA;        # list积&#xA;    elem&#xA;        # 判断元素是否在list中&#xA;        4 `elem` [3,4,5]&#xA;    cycle&#xA;        take 7 (cycle [1,2,3])&#xA;            # [1,2,3,1,2,3,1]&#xA;    repeat&#xA;        repeat 5&#xA;    replicate&#xA;        replicate 3 10&#xA;            # [10, 10, 10]&#xA;&#xA;    fst (1, 2)&#xA;        # 只适合2元组&#xA;    snd (1, 2)&#xA;        # 只适合2元组&#xA;    zip&#xA;        # zip3, zip4 ... zip7&#xA;        zip [1,2,3] [4,5,6]&#xA;            # [(1,4), (2,5), (3,6)]&#xA;    zipWith&#xA;        # zipWith1 ... zipWith7&#xA;        zipWith (\x y -&amp;gt; x + y) [1,2] [3,4]&#xA;            # [4,6]&#xA;    fromIntegral&#xA;        # 返回更通用的数字类型&#xA;    error &amp;quot;&amp;quot;&#xA;        # 抛错&#xA;    flip&#xA;        # 翻转两个参数调用&#xA;    map&#xA;    filter&#xA;    foldl&#xA;        foldl (\acc x -&amp;gt; acc + x) 0 xs&#xA;    foldr&#xA;        foldr (\x acc -&amp;gt; f x : acc) [] xs&#xA;    foldl1&#xA;        # 以第一个元素为初始值，空list报错&#xA;    foldr1&#xA;    foldl&#39;&#xA;        # foldl的strict版&#xA;    foldr&#39;&#xA;    scanl&#xA;        # 返回累加过程的list&#xA;    scanr&#xA;    scanl1&#xA;    scanr1&#xA;    o-&amp;gt; I/O action&#xA;        # 只有在main中执行&#xA;        # 类型为 IO a&#xA;        putStrLn&#xA;            # 只接受String，不转义打印，加换行符&#xA;            # putStrLn :: String -&amp;gt; IO () , 表示接收String, 是IO动作, 结果类型是()。表示是一个&amp;quot;IO monad&amp;quot;动作&#xA;        putStr&#xA;            # 由putChar递归定义，边界条件是空字符串&#xA;        putChar&#xA;        print&#xA;            # 打印Show typeclass的值&#xA;        getLine&#xA;            # 控制台读一行&#xA;            # getLine :: IO String&#xA;            name &amp;lt;- getLine&#xA;        getChar&#xA;        sequence&#xA;        # 顺序执行I/O action&#xA;        mapM&#xA;            mapM print [1,2,3]&#xA;                # 对list元素执行sequence f&#xA;        mapM_&#xA;            # 同mapM，不打印[(),()]&#xA;        getContents&#xA;            # 读直到 eof (ctrl + d)&#xA;        interact&#xA;            # 用函数处理输入，返回到输出&#xA;Data.List&#xA;    # 每个元素存在thunk中&#xA;    \&#xA;        # 差集&#xA;        [1..3] \\ [2]&#xA;            # [1,3]&#xA;        &amp;quot;Im a big baby&amp;quot; \\ &amp;quot;big&amp;quot;&#xA;            # &amp;quot;Im a baby&amp;quot;&#xA;    union&#xA;    intersection&#xA;    insert&#xA;        # 插入一个元素到可排序list相对位置&#xA;    nub&#xA;        # 去重复元素,常用Set转换取代,提高很多效率&#xA;    map&#xA;        # 导出到了prelude&#xA;    filter&#xA;        # 导出到了prelude&#xA;    intersperse&#xA;        intersperse &#39;.&#39; &amp;quot;abc&amp;quot;&#xA;            # &amp;quot;a.b.c&amp;quot;&#xA;    intercalate&#xA;        # 同intersperse, 但插入list&#xA;    transpose&#xA;        # 二元list列为行&#xA;    foldl&#39;&#xA;        # fold的严格版，直接计算出中间值，而非用惰性&amp;quot;承诺&amp;quot;塞满堆栈&#xA;    foldl1&#39;&#xA;    concat&#xA;        # 移除一级嵌套&#xA;    concatMap&#xA;        # 先map再concat&#xA;        concatMap (replicate 2) [1..3]&#xA;            # [1,1,2,2,3,3]&#xA;    and&#xA;        # list中全true返回true&#xA;        and $ map (&amp;gt;4) [5,6,7,8]&#xA;    or&#xA;    any&#xA;    iterate&#xA;        # 无限迭代值到函数，结果形成list&#xA;        take 10 $ iterate (*2) 1&#xA;    splitAt&#xA;        # 断开list, 返回二元组&#xA;        splitAt 3 &amp;quot;abcdef&amp;quot;&#xA;            # (&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;)&#xA;    takeWhile&#xA;        # 取元素，直到不符合条件&#xA;    dropWhile&#xA;    span&#xA;        # 同takeWhile, 不过返回分割list的二元组&#xA;    break&#xA;        # 同span, 但在条件首次为true时断开&#xA;    sort&#xA;        # list元素要求Ord类型，排序list&#xA;    group&#xA;        # 合并相邻并相等的list元素&#xA;    inits&#xA;        # init递归调用自身&#xA;        inits &amp;quot;abc&amp;quot;&#xA;            # [&amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;ab&amp;quot;, &amp;quot;abc&amp;quot;]&#xA;    tails&#xA;        # tail递归调用自身&#xA;        tails &amp;quot;abc&amp;quot;&#xA;            # [&amp;quot;abc&amp;quot;, &amp;quot;bc&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;&amp;quot;]&#xA;    isInfixOf&#xA;        # list中搜索子list, 有则返回true&#xA;        &amp;quot;cat&amp;quot; `isInfixOf` &amp;quot;im a cat&amp;quot;&#xA;    isPrefixOf&#xA;        # 是否以某list开头&#xA;    isSuffixOf&#xA;        # 是否以某list结尾&#xA;    elem&#xA;        # 是否包含某元素&#xA;    notElem&#xA;    partition&#xA;        # 条件划分list为二元组&#xA;        partition (`elem` [&#39;A&#39;..&#39;Z&#39;]) &amp;quot;AbCD&amp;quot;&#xA;            # (&amp;quot;ACD&amp;quot;, &amp;quot;b&amp;quot;)&#xA;    find&#xA;        # 条件查找list, 返回第一个符合元素的Maybe值&#xA;    elemIndex&#xA;        # 返回elem第一个元素的索引的Maybe值&#xA;    elemIndices&#xA;        # 返回所有匹配索引的list&#xA;    findIndex&#xA;    findIndices&#xA;    lines&#xA;        # 字符串分行到list&#xA;    unlines&#xA;    words&#xA;        # 字符串分词到list&#xA;    unwords&#xA;    delete&#xA;        # 删除list中第一个匹配元素&#xA;        delete &#39;h&#39; &amp;quot;hha&amp;quot;&#xA;            # &amp;quot;ha&amp;quot;&#xA;    replace&#xA;    lookup&#xA;        # 用a查找[(&#39;a&#39;, &#39;b&#39;)]中的b&#xA;    genericLength&#xA;        # 换Int类型为Num类型&#xA;    genericTake&#xA;    genericDrop&#xA;    genericSplitAt&#xA;    genericIndex&#xA;    genericReplicate&#xA;&#xA;    nubBy&#xA;        # 传递函数判断相等性，取代==&#xA;    deleteBy&#xA;    unionBy&#xA;    intersectBy&#xA;    groupBy&#xA;    sortBy&#xA;    insertBy&#xA;    maximumBy&#xA;    minimumBy&#xA;Data.Monoid&#xA;    Monoid&#xA;    Product&#xA;    Sum&#xA;    Any&#xA;    All&#xA;Data.Foldable&#xA;    foldr&#xA;    foldl&#xA;    foldr1&#xA;    foldl1&#xA;Data.Function&#xA;    on&#xA;        ((==) `on` (&amp;gt; 0))&#xA;            # 判断相等性，等价于 (\x y -&amp;gt; (x &amp;gt; 0) == (y &amp;gt; 0))&#xA;        (compare `on` length)&#xA;            # 判断大小&#xA;Data.Char&#xA;    isControl&#xA;        # 是否控制字符&#xA;    isSpace&#xA;        # 包括空格, tab, 换行等&#xA;    isLower&#xA;    isUpper&#xA;    isAlpha&#xA;        # 是否字母&#xA;    isAlphaNum&#xA;        # 字母或数字&#xA;    isPrint&#xA;        # 可打印&#xA;    isDigit&#xA;    isOctDigit&#xA;    isHexDigit&#xA;    isLetter&#xA;        # 同isAlpha&#xA;    isMark&#xA;        # unicode注音字符&#xA;    isNumber&#xA;    isPunctuation&#xA;        # 是否标点符号&#xA;    isSymbol&#xA;        # 货币符号&#xA;    isSeperater&#xA;        # unicode空格或分隔符&#xA;    isAscii&#xA;        # unicode 前128位&#xA;    isLatin1&#xA;        # unicode 前256位&#xA;    isAsciiUpper&#xA;    isAsciiLower&#xA;    GeneralCategory&#xA;        # 得到字符的分类，一共31类, 属于Eq类型&#xA;        generalCategory &#39; &#39;&#xA;            # Space&#xA;    toUpper&#xA;    toLower&#xA;    toTitle&#xA;    digitToInt&#xA;        # 数字，大小写字母list 转成 int list&#xA;    intToDigit&#xA;    ord&#xA;    char&#xA;Data.Map&#xA;    # 用avl树实现&#xA;    fromList&#xA;        # 重复键会忽略，要求key有相等性和排序性&#xA;    fromListWith&#xA;        # 重复键给函数处理&#xA;    toList&#xA;    empty&#xA;        # 返回空map&#xA;    insert&#xA;        insert 3 10 map&#xA;    insertWith&#xA;        # 已包含键时函数处理&#xA;    null&#xA;        # 检查map是否空&#xA;    size&#xA;        # 返回map的大小&#xA;    singleton&#xA;        singleton 3, 9&#xA;            # fromList [(3,9)]&#xA;    lookup&#xA;    member&#xA;        # key 是否在map中&#xA;    map&#xA;    filter&#xA;    keys&#xA;    elems&#xA;Data.Set&#xA;    # 要求元素可排序，自动排序、唯一&#xA;    # 用avl树实现&#xA;    fromList&#xA;    intersection&#xA;    difference&#xA;        # 存在于第一集合而不在第二集合的元素&#xA;    union&#xA;    null&#xA;    size&#xA;    member&#xA;    empty&#xA;    singleton&#xA;    insert&#xA;    delete&#xA;    isSubsetOf    &#xA;        # 子集&#xA;        fromList [1,2] isSubsetOf fromList [1,2]&#xA;    isProperSubsetOf&#xA;        # 真子集&#xA;    filter&#xA;    map&#xA;Data.ByteString&#xA;    # strict bytestring&#xA;    # Empty相当于[], cons相当于:&#xA;Data.ByteString.Lazy&#xA;    # 每个元素存在chunk中，每个chunk 64k，每个chunk相当于一个strict bytestring&#xA;    # cons在chunk不满的时候会新建chunk, cons&#39;是strick版的cons, 会填充chunk&#xA;    pack&#xA;        # pack :: [Word8] -&amp;gt; ByteString&#xA;        pack [80,81]&#xA;    unpack&#xA;    fromChunks&#xA;        # 转换strick bytestring 到lazy&#xA;    toChunks&#xA;        # lazy转strick&#xA;Data.Ratio&#xA;Control.Applicative&#xA;    Applicative&#xA;        class (Functor f) =&amp;gt; Applicative f where&#xA;            pure :: a -&amp;gt; fa&#xA;            (&amp;lt;*&amp;gt;) :: f (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;            f &amp;lt;$&amp;gt; x = fmap f x&#xA;    ZipList&#xA;        ZipList3&#xA;        ZipList7&#xA;    getZipList&#xA;    liftA2&#xA;        liftA2 f x y = f &amp;lt;$&amp;gt; x &amp;lt;*&amp;gt; y &#xA;    sequenceA&#xA;Control.Monad&#xA;    when&#xA;        # Bool true时，返回后面的I/O action, 否则return ()&#xA;    forever&#xA;        # 不断执行后面的I/O action&#xA;        forever $ do&#xA;            putStr &amp;quot;a&amp;quot;&#xA;    forM&#xA;        # 同mapM, 但两个参数顺序相反&#xA;    liftM&#xA;        # monad中的fmap&#xA;    liftM2 liftM3 liftM4 liftM5&#xA;    `ap`&#xA;        # monad中的&amp;lt;*&amp;gt;&#xA;    join&#xA;        join :: (Monad m) =&amp;gt; m (m a) -&amp;gt; m a&#xA;        join mm = do&#xA;            m &amp;lt;- mm&#xA;            m&#xA;    filterM&#xA;    foldM&#xA;Control.Monad.State&#xA;    State&#xA;        newtype State s a = State {runState :: s -&amp;gt; (a, s)}&#xA;    get&#xA;    put&#xA;Control.Monad.Error&#xA;System.IO&#xA;    openFile&#xA;        # openFile :: FilePath -&amp;gt; IOMode -&amp;gt; IO Handle&#xA;        # data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode&#xA;        do&#xA;        handle = openFile &amp;quot;a.txt&amp;quot; ReadMode&#xA;        contents &amp;lt;- hGetContents handle&#xA;        putStr contents&#xA;        hClose handle&#xA;    withFile&#xA;        # withFile :: FilePath -&amp;gt; IOMode -&amp;gt; (Handle -&amp;gt; IO a) -&amp;gt; IO a&#xA;        # 处理完关掉&#xA;        withFile &amp;quot;a.txt&amp;quot; ReadMode (\handle -&amp;gt; do&#xA;            contents &amp;lt;- hGetContents handle&#xA;            putStr contents)&#xA;    readFile&#xA;        # readFile :: FilePath -&amp;gt; IO String&#xA;        do&#xA;        contents &amp;lt;- readFile &amp;quot;a.txt&amp;quot;&#xA;        putStr contents&#xA;    wirteFile&#xA;        # writeFile :: FilePath -&amp;gt; String -&amp;gt; IO ()&#xA;        do&#xA;        writeFile &amp;quot;a.txt&amp;quot; contents&#xA;    appendFile&#xA;    hSetBuffering&#xA;        # 读binary file时的buffer，默认是系统值&#xA;        # data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)&#xA;        hSetBuffering handle $ BlockBuffering (Just 2048)&#xA;    hFlush&#xA;        # 写入时自动Flush&#xA;    openTempFile&#xA;        (tempName, tempHandle) &amp;lt;- openTempFile &amp;quot;.&amp;quot; &amp;quot;temp&amp;quot;&#xA;    hGetContents&#xA;    hClose&#xA;    hGetLine&#xA;    hPusStr&#xA;    hPutStrLn&#xA;    hGetChar&#xA;System.IO.Error&#xA;    catch&#xA;        # catch :: IO a -&amp;gt; (IOError -&amp;gt; IO a) -&amp;gt; IO a&#xA;        toTry `catch` handler&#xA;        handler e&#xA;            | isDoesNotExistError e = &#xA;                case ioeGetFileName e of Just path -&amp;gt; putStrLn $ &amp;quot;a&amp;quot; ++ path&#xA;                    Nothing -&amp;gt; putStrLn &amp;quot;b&amp;quot;&#xA;            | otherwise = ioError e&#xA;    isDoesNotExistError&#xA;    isAlreadyExistsError&#xA;    isFullError&#xA;    isEOFError&#xA;    isIllegalOperation&#xA;    isPermissionError&#xA;    isUserError&#xA;    ioeGetFileName&#xA;        # ioeGetFileName :: IOError -&amp;gt; Maybe FilePath&#xA;    ioError&#xA;        # 丢出接到的error&#xA;System.Directory&#xA;    removeFile&#xA;        removeFile &amp;quot;a.txt&amp;quot;&#xA;    renameFile&#xA;        renameFile tempName &amp;quot;a.txt&amp;quot;&#xA;    copyFile&#xA;    doesFileExist&#xA;System.Environment&#xA;    getArgs&#xA;    getProgName&#xA;System.Random&#xA;    mkStdGen&#xA;        # mkStdGen :: Int -&amp;gt; StdGen&#xA;    getStdGen&#xA;        # IO类型, 得到系统启动时的global generator&#xA;    newStdGen&#xA;        # 把现有的random generator分成两个新的generators, 其中一个指定成新的，返回另一个&#xA;    random&#xA;        # random :: (RandomGen g, Random a) = g -&amp;gt; (a, g)&#xA;        random (mkStdGen 100) :: (Int, StdGen)&#xA;    randoms&#xA;        take 5 $ randoms (mkStdGen 11) :: [Int]&#xA;    randomR&#xA;        # 区间random&#xA;        randomR (1,6) (mkStdGen 2)&#xA;    randomRs&#xA;        take 10 $ randomRs (&#39;a&#39;, &#39;z&#39;) (mkStdGen 3) :: [Char]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;函数-1&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 模式匹配&#xA;    # case的语法糖&#xA;    # 对构造子匹配，如 8 &#39;a&#39; : []&#xA;factorial :: (Integral a) =&amp;gt; a -&amp;gt; a&#xA;factorial 0 = 1&#xA;factorial n = n * factorial (n - 1)&#xA;&#xA;addVectors :: (Num a) =&amp;gt; (a, a) -&amp;gt; (a, a) -&amp;gt; (a, a)&#xA;addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)&#xA;&#xA;first :: (a, b, c) -&amp;gt; a&#xA;first (x, _, _) = x&#xA;&#xA;tell :: (Show a) =&amp;gt; [a] -&amp;gt; String&#xA;tell [] = &amp;quot;&amp;quot;&#xA;tell [x: []] = &amp;quot;&amp;quot;&#xA;tell [x:y:[]] = &amp;quot;&amp;quot;&#xA;tell [x:y:_] = &amp;quot;too long, the first is &amp;quot; ++ show x ++ &amp;quot; and the second is &amp;quot; ++ show y&#xA;&#xA;length&#39; :: (Num b) =&amp;gt; [a] -&amp;gt; b&#xA;length&#39; [] = 0&#xA;length&#39; (_:xs) = 1 + length&#39; xs&#xA;&#xA;capital :: String -&amp;gt; String&#xA;capital &amp;quot;&amp;quot; = &amp;quot;&amp;quot;&#xA;capital all@(x:xs) = &amp;quot;The first letter of &amp;quot; ++ all ++ &amp;quot; is &amp;quot; ++ [x]&#xA;    # @是as模式&#xA;&#xA;o-&amp;gt; guard&#xA;bmiTell :: (RealFloat a) =&amp;gt; a -&amp;gt; String&#xA;bmiTell weight height&#xA;    | bmi &amp;lt;= skinny = &amp;quot;You&#39;re underweight&amp;quot;&#xA;    | bmi &amp;lt;= normal = &amp;quot;You&#39;re supposedly normal&amp;quot;&#xA;    | bmi &amp;lt;= fat = &amp;quot;You&#39;re fat&amp;quot;&#xA;    | otherwise = &amp;quot;You&#39;re a whale&amp;quot;&#xA;    where bmi = weight / height ^ 2&#xA;    (skinny, normal, fat) = (18.5, 25.0, 30.0)&#xA;        # where是语法结构，不是表达式&#xA;calcBmis :: (RealFloat a) =&amp;gt; [(a, a)] -&amp;gt; [a]&#xA;calcBmis xs = [bmi w h | (w, h) &amp;lt;- xs, let bmi = w / h ^ 2]&#xA;&#xA;myCompare :: (Ord a) =&amp;gt; a -&amp;gt; a -&amp;gt; Ordering&#xA;a `myCompare` b&#xA;    | a &amp;gt; b = GT&#xA;    | a == b = EQ&#xA;    | otherwise = LT&#xA;&#xA;o-&amp;gt; quicksort&#xA;quicksort :: (Ord a) =&amp;gt; [a] -&amp;gt; [a]&#xA;quicksort [] = []&#xA;quicksort (x:xs) = &#xA;    let smallerSorted = quicksort (filter (&amp;lt;=x) xs)&#xA;        biggerSorted = quicksort [a | a &amp;lt;- xs, a &amp;gt; x]&#xA;    in smallerSorted ++ [x] ++ biggerSorted&#xA;&#xA;o-&amp;gt; curry&#xA;compareWithHundred :: (Num a, ord a) =&amp;gt; a -&amp;gt; Ordering&#xA;compareWithHundred = compare 100&#xA;&#xA;divideByTen :: (Floating a) =&amp;gt; a -&amp;gt; a&#xA;divideByTen = (/10)&#xA;    # 中缀函数用括号来不完全调用&#xA;    # 但(-4)表示负4, (substract 4)来表示减4函数&#xA;&#xA;o-&amp;gt; 高阶函数&#xA;applyTwice :: (a -&amp;gt; a) -&amp;gt; a -&amp;gt; a&#xA;applyTwice f x = f (f x)&#xA;&#xA;o-&amp;gt; lambda&#xA;addThree :: (Num a) =&amp;gt; a -&amp;gt; a -&amp;gt; a -&amp;gt; a&#xA;addThree = \x -&amp;gt; \y -&amp;gt; \z -&amp;gt; x + y + z&#xA;&#xA;o-&amp;gt; $ 做数据函数&#xA;map ($ 3) [(4+), (10*), (^2), sqrt]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;类型&#xA;    Int&#xA;        # 有界整数&#xA;    Integer&#xA;        # 无界整数&#xA;    Float&#xA;        # 单精度浮点数&#xA;    Double&#xA;    Bool&#xA;    Char&#xA;    Maybe&#xA;    []&#xA;    ()&#xA;    a&#xA;        # type variables&#xA;类型约束&#xA;    Eq&#xA;    # 可判断相等性的类型，可用 == 或 /= 判断&#xA;        # 只除函数&#xA;    Ord&#xA;        #可比较大小的类型, 必定是Eq&#xA;        # 只除函数&#xA;    Ordering&#xA;        # 只有GT, EQ, LT&#xA;    Show&#xA;        # 可用字符串表示的类型&#xA;        # 只除函数&#xA;    Read&#xA;        # 与Show相反&#xA;    Enum&#xA;        # 连续的类型，有后继子(successer)和前置子(predecesor), 分别通过succ函数和pred函数得到&#xA;        # 可以[1..2]构造list&#xA;        # 包含 (), Bool, Char, Ordering, Int, Integer, Float, Double&#xA;    Bounded&#xA;        # 有上限和下限&#xA;        # 如果Tuple中都属于Bounded, 那么这个Tuple属于Bounded&#xA;    Num&#xA;        # 数字特征&#xA;    Integral&#xA;        # 整数&#xA;    Floating&#xA;        # 浮点，包含Float和Double&#xA;构造类型&#xA;    data Bool = False | True deriving (Ord)&#xA;        # Bool是构造的类型, False为值构造子，值可以用:t查看其类型&#xA;        # 值构造子可以用于模式匹配&#xA;        # 这里值构造子是没有参数的，叫作nullary&#xA;        # False在True前，所以比较时True比False大&#xA;    data Point = Point Float Float deriving (Show)&#xA;        # 值构造子可以与类型同名&#xA;    data Shape = Circle Point Float | Rectangle  Point Point deriving (Show)&#xA;        # 派生自Show, 就可show值成字符串&#xA;    data Person = Person {firstName :: String&#xA;        , lastName :: String&#xA;        } deriving (Show)&#xA;            # Record Syntax, 同 Person String String,  但自动生成同名的取值函数，show显示也改变&#xA;        let p = Person {firstName=&amp;quot;aa&amp;quot;, lastName=&amp;quot;bb&amp;quot;}&#xA;    &#xA;        tellPerson :: Person -&amp;gt; String&#xA;        tellPerson (Person {firstName = a, lastName = b}) = a ++ b&#xA;    newtype CharList = CharList {getCharList :: [Char]} deriving {Eq, Show}&#xA;        # newtype将现有类型包成新类型，只能定义单一值构造子，且其只能有一个字段。并将包裹和解开的成本都去掉&#xA;类型构造子&#xA;    # data声明中不能加类型约束&#xA;    data Maybe a = Nothing | Just a&#xA;    data Car a b = Car { company :: a&#xA;        , year :: b&#xA;        } deriving (Show)&#xA;    tellCar :: (Show a) =&amp;gt; Car String a -&amp;gt; String&#xA;类型别名&#xA;    type String = [Char]&#xA;    type AssocList k v = [(k,v)]&#xA;        # 别名类型构造子&#xA;    type IntMap = Map Int&#xA;        # 不全调用得到不全类型构造子, 同 type intMap v = Map Int v&#xA;infixr&#xA;    infixr 5 :-:&#xA;        # 定义中缀构造子, 5是优先级, :-:是符号&#xA;        # 默认left-associative&#xA;&#xA;    infixr 5 .++&#xA;    (.++) :: List a -&amp;gt; List a -&amp;gt; List a&#xA;    Empty .++ ys = ys&#xA;    (x :-: xs) .++ ys = x :-: (xs .++ ys)&#xA;recursive data structures&#xA;    data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)&#xA;typeclass&#xA;    class Eq a where&#xA;        (==) :: a -&amp;gt; a -&amp;gt; Bool&#xA;        (/=) :: a -&amp;gt; a -&amp;gt; Bool&#xA;        x == y = not (x /= y)&#xA;        x /= y = not (x == y)&#xA;            # 只需要instance一个定义就好，这个定义叫minimal complete definition&#xA;    data TrafficLight = Red | Yellow | Green&#xA;    instance Eq TrafficLight where&#xA;        Red == Red = True&#xA;        Green == Green = True&#xA;        Yellow == Yellow = True&#xA;        _ == _ = False&#xA;    instance Show TrafficLight where&#xA;        show Red = &amp;quot;Red light&amp;quot;&#xA;        show Yellow = &amp;quot;Yellow light&amp;quot;&#xA;        show Green = &amp;quot;Green light&amp;quot;&#xA;&#xA;    class (Eq a) =&amp;gt; Num a where&#xA;        # Num 是 Eq  的 subclass, 要是Num必是Eq&#xA;&#xA;    instance (Eq m) =&amp;gt; Eq (Maybe m) where&#xA;        Just x == Just y = x == y&#xA;        Nothing == Nothing = True&#xA;        _ == _ = False&#xA;            &#xA;o-&amp;gt; Either&#xA;data Either a b = Left a | Right a deriving (Eq, Ord, Read, Show)&#xA;&#xA;o-&amp;gt; Tree&#xA;data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)&#xA;&#xA;o-&amp;gt; YesNo&#xA;class YesNo a where&#xA;    yesno :: a -&amp;gt; Bool&#xA;instance YesNo Int where&#xA;    yesno 0 = False&#xA;    yesno _ = True&#xA;&#xA;o-&amp;gt; Functor&#xA;class Functor f where&#xA;    # map over&#xA;    fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&#xA;instance Functor Maybe where&#xA;    # 接收构造子而非类型&#xA;    fmap f (Just x) = Just (f x)&#xA;    fmap f Nothing = Nothing&#xA;instance Functor (Either a) where&#xA;    # parital apply Either, Either a 是个类型构造子&#xA;    fmap f (Right x) = Right (f x)&#xA;    fmap f (Left x) = Left x&#xA;instance Functor ((-&amp;gt;) r) where&#xA;    # 对函数的functor&#xA;    fmap f g = (\x -&amp;gt; f (g x))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ghci&#xA;    set prompt &amp;quot;ghci&amp;gt; &amp;quot;&#xA;        # 设置显示的提示符&#xA;ghc&#xA;    ghc --make a.hs&#xA;runhaskell&#xA;ghc-pkg list&#xA;    # 列出已安装的软件包&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;玄学&#34;&gt;&#xA;  玄学&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%84%e5%ad%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;&#xA;:{&#xA;data X = X&#xA;a :: Int -&amp;gt; Int&#xA;a x = x + 3&#xA;:}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Elixir</title>
      <link>https://ukeate.com/docs/pl/elixir/</link>
      <pubDate>Tue, 09 Oct 2018 16:24:04 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/elixir/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;跑在erlang虚拟机上&#xA;与erlang相同，actor称作进程, 是比线程更轻量的概念&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;使用&#34;&gt;&#xA;  使用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 元组&#xA;{:foo, &amp;quot;this&amp;quot;, 42}&#xA;        # 三元组&#xA;&#xA;o-&amp;gt; actor&#xA;defmodule Talker do&#xA;def loop do&#xA;    receive do&#xA;    {:greet, name, age} -&amp;gt; IO.puts(&amp;quot;Hello #{name}&amp;quot;)&#xA;    {:shutdown} -&amp;gt; exit(:normal)&#xA;    end&#xA;    loop&#xA;end&#xA;end&#xA;&#xA;pid = spawn(&amp;amp;Talker.loop/0)&#xA;send(pid, {:greet, &amp;quot;Huey&amp;quot;, 16})&#xA;sleep(1000)&#xA;&#xA;Process.flag(:trap_exit, true)&#xA;pid = spawn_link(&amp;amp;Takler.loop/0)&#xA;send(pid, {:shutdown})&#xA;receive do&#xA;{:EXIT, ^pid, reason} -&amp;gt; IO.puts(&amp;quot;Talker has exited (#{reason})&amp;quot;)&#xA;end&#xA;&#xA;o-&amp;gt; 有状态的actor&#xA;        # 递归&#xA;defmodule Counter do&#xA;def start(count) do&#xA;    spawn(__MODULE__, :loop, [count])&#xA;            # 伪变量__MODULE__, 是当前模块的名字&#xA;end&#xA;def next(counter) do&#xA;    send(counter, {:next})&#xA;end&#xA;def loop(count) do&#xA;    receive do&#xA;    {:next} -&amp;gt;&#xA;        IO.puts(&amp;quot;Current count: #{count}&amp;quot;)&#xA;        loop(count + 1)&#xA;    end&#xA;end&#xA;end&#xA;counter = spawn(Counter, :loop, [1])&#xA;send(counter, {:next})&#xA;&#xA;counter = Countre.start(42)&#xA;Counter.next(counter)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Go</title>
      <link>https://ukeate.com/docs/pl/go/</link>
      <pubDate>Tue, 09 Oct 2018 16:10:44 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/go/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    易工程化&#xA;        简单性而不方便性，避免工程复杂性乘法增长            # 某部分变复杂，增加其他部分的复杂性(功能、选项、配置)&#xA;            没有动态库, 没有泛型, 没有继承, 没有异常, 没有宏，没有注解，没有线程局部存储&#xA;        类型系统，无类型风格&#xA;        自然方式工作&#xA;            不显式初始化和隐式构造函数&#xA;            集合直接持有元素&#xA;        标准库避免配置和解释     # 自带电池&#xA;        项目结构简单&#xA;        编译检查代码格式&#xA;    csp(communicating sequential process)并发，变长栈运行轻量线程&#xA;    编译为本地机器码        # 像c一样，所以又叫类c语言&#xA;        编译快&#xA;            引用包名在头&#xA;            包依赖有向无环，可独立和并行编译&#xA;            目标文件包含依赖包信息&#xA;    强静态类型&#xA;    有gc&#xA;    变长栈，最小2kb, 最大1GB&#xA;    大厂支持&#xA;历史&#xA;    2007年设计，受影响于Alef(CSP系列), Oberon-2(ALGOL60, Modula-2系列), C&#xA;        # 目的解决google许多复杂性激增的软件系统&#xA;    2009年发布, 作者是Robert Griesemer, Rob Pike, Ken Thompson&#xA;    2012年1.0&#xA;并发编程特点&#xA;    语言层面关键字&#xA;    例程&#xA;        流程控制: csp       # channel为一等公民&#xA;        通信方式: promise-future, channel, event&#xA;    高效调度模型(调度器，资源占用小)&#xA;        O(1)的调度&#xA;        一进程可支撑上百万例程,5kib/goroutine的开销,&#xA;            变长栈存goroutine&#xA;编译&#xA;    CGO_ENABLED=0&#xA;        # 静态链接，不跨平台&#xA;    初始化&#xA;        包级别初始化在main前&#xA;        局部变量在函数执行时&#xA;配置&#xA;    GOROOT                  # go安装目录&#xA;    GOPATH                  # 包目录, 默认要有go的bin目录&#xA;    GOBIN                   # 当前bin目录&#xA;    GO15VENDOREXPERIMENT    # 依赖目录&#xA;    GOOS                    # 指定操作系统, 如android, linux, darwin, windows&#xA;    GOARCH                  # 处理器架构，如amd64, 386, arm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;命令&#34;&gt;&#xA;  命令&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;go&#xA;    help&#xA;        importpath          # 说明 指定代码托管网站版本协议&#xA;        gopath              # vendor怎么使用&#xA;        list                # go list 说明&#xA;    version&#xA;    env                     # 打印go环境信息&#xA;    run                     # 编译并运行&#xA;        -race               # 检查运行中的竞态冲突并报告&#xA;    build                   # 库被舍弃，main包编译成二进制执行文件, 会检测mod&#xA;        go build gopl.io&#xA;        go build x.go&#xA;        -race&#xA;        -i                  # 编译到指定位置&#xA;    install                 # 编译安装, 会检测mod&#xA;    clean                   # 清理build产生的文件&#xA;        -c                  # 清理.test文件&#xA;        -i                  # 清理生成的可执行文件&#xA;        -r                  # 包括依赖包的结果文件&#xA;    doc&#xA;        命令&#xA;            go doc go/build&#xA;        包&#xA;            go doc html/template&#xA;        包成员&#xA;            go doc time.Since&#xA;        方法&#xA;            go doc http.ListenAndServe&#xA;    fmt                     # 代码格式化&#xA;&#xA;    get                     # 下载依赖, 默认目录是GOPATH下的pkg。下载后自动install&#xA;        go get gopl.io/...  # ...通配&#xA;        get gopl.io@2       # 指定mod版本号&#xA;        -u                  # 更新到mod最新版本&#xA;        -v                  # 查看进度&#xA;    list                    # 列出指定代码包的信息&#xA;        go list ...         # ...通配&#xA;        go list ...xml...&#xA;        -json hash          # 输出json格式完整信息&#xA;        -f                  # 使用go模板&#xA;    fix                     # 升级旧代码成新版本代码&#xA;    vet                     # 检查静态错误&#xA;&#xA;    test&#xA;        # go test -cover -args -config config_it.toml -test.run &amp;quot;TestA&amp;quot;&#xA;        # 执行当前目录下所有_test.go结尾的文件&#xA;        -race&#xA;&#xA;        -file               # 可省略，测试单个文件, 如go test test_a.go a.go a.pb.go&#xA;                            ## 测试单个文件需要引入原文件&#xA;        -args               # 运行时参数&#xA;        -run TestFoo        # 正则表达式匹配方法，NONE表示不匹配。如&amp;quot;^TestFoo&amp;quot;, &amp;quot;F|F1&amp;quot;&#xA;        -test.run &amp;quot;TestCreate&amp;quot;                      # 同上&#xA;        -v                  # 每个测试用例的名称和时间&#xA;        -bench=&amp;quot;.*&amp;quot;         # 正则匹配benchmark测试函数&#xA;        -benchmem           # 显示benchmark测试时内存分配&#xA;        --cpuprofile=cpu.prof                       # 生成cpu分析文件，使用多个标记时(如cpu, mem), 一个类别会覆盖另一个。性能剖析启用时, go test不丢弃其临时可执行文件&#xA;        --blockprofile=block.out                    # 生成阻塞分析文件&#xA;        --memprofile=mem.prof                       # 生成内存分析文件&#xA;        -c                  # 生成可执行的二进制文件，名为x.test，它用来生成状态图&#xA;        -cover              # 显示覆盖语句汇总信息&#xA;        -coverprofile=c.out # 生成日志文件c.out，记录语句覆盖信息&#xA;        -covermode=count    # 语句覆盖信息不用bool而用count累加&#xA;&#xA;    tool&#xA;        cover               # 测试覆盖率工具使用方法&#xA;            go tool cover -html=c.out               # html分析c.out&#xA;        pprof               # 交互式访问概要文件&#xA;            go tool pprof module1.test cpu.prof                   # 性能测试状态图, 参数是可执行文件和剖析日志&#xA;            -test           # 文本格式&#xA;            -nodecount=10   # 限制输出10行&#xA;            -web            # 渲染有向图web显示&#xA;        fix                 # 同go fix&#xA;        vet                 # 同go vet&#xA;        cgo                 # 生成能够调用c语言代码的go源码文件&#xA;        compile&#xA;            -help           # 可传给编译器的参数&#xA;    mod&#xA;        init packageName1   # 生成go.mod&#xA;        download            # 下载mod&#xA;        tidy                # 下载缺少，删除多余&#xA;        edit                # 编辑go.mod&#xA;        graph               # 打印依赖图&#xA;        vendor              # 复制依赖到vendor&#xA;        verify              # 验证mod&#xA;        why                 # 打印依赖原因&#xA;godoc                       # 提供html页面&#xA;    -http=:6060             # 运行本地帮助网站&#xA;    -analysis=type          # 提供静态分析结果&#xA;        -analysis=pointer&#xA;gofmt&#xA;golint                          # 检查风格&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;常用&#34;&gt;&#xA;  常用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;go mod 配置&#xA;    环境变量&#xA;        GO111MODULE&#xA;            off                     # 总关闭&#xA;            on                      # 总开启&#xA;            auto                    # 默认，有go.mod开启&#xA;    路径&#xA;        $GOPATH/pkg/mod             # 保存多版本依赖, 被多项目引用&#xA;        go.mod                      # 被go命令维护, 融入了go命令的各个模块&#xA;        go.sum                      # 记录lock&#xA;    依赖加载顺序&#xA;        最新release tag&#xA;        最新commit&#xA;    命令&#xA;        go mod vendor&#xA;代理&#xA;    go env -w GOPROXY=https://goproxy.cn,direct&#xA;包升级&#xA;    go list -m -u all               # 检查可以升级的package&#xA;    go get -u need-upgrade-package  # 升级&#xA;性能测试&#xA;    go test -bench=.  --cpuprofile=cpu.prof --memprofile=mem.prof -config ../conf/config_lc.toml -test.run TestCreateType&#xA;覆盖率&#xA;    go test -cover -args -config config.toml -test.run &amp;quot;TestCreate&amp;quot;&#xA;性能分析&#xA;    go tool pprof service.test cpu.prof&#xA;    go-torch -b cpu.prof&#xA;包管理&#xA;    go list -m -u all&#xA;        # 列可升级包&#xA;    go list -u need-upgrade-package&#xA;        # 升级可升级包&#xA;    go get -u&#xA;        # 升级所有依赖&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;glide&#34;&gt;&#xA;  glide&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#glide&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    包管理&#xA;目录&#xA;    glide.yaml&#xA;    glide.lock&#xA;    main.go&#xA;    subpackages&#xA;    vendor&#xA;命令&#xA;    glide&#xA;        init&#xA;            # 扫描代码目录，创建glide.yaml文件，记录所有依赖&#xA;            删除glide.yaml中自己项目本身&#xA;        get&#xA;            # 安装并更新glide.yaml&#xA;            --all-dependencies -s -v github.com/go-redis/redis#5.0.0&#xA;                # --all-dependencies会更新subpackages&#xA;        update&#xA;            # 下载和更新glide.yaml中的所有依赖，放到vendor下&#xA;            # 递归更新&#xA;        install&#xA;            # 依据glide.lock与glide.yaml文件安装特定版本&#xA;            # glide.lock与glide.yaml不同步时，发出警告&#xA;        up&#xA;            # 更新依赖树，重建glide.lock文件&#xA;        name&#xA;            # 查看glide.yaml中依赖名称&#xA;        list&#xA;            # 依赖列表&#xA;        help&#xA;        --version&#xA;glide.yaml&#xA;    package: .&#xA;    import:&#xA;    - package: github.com/go-redis/redis&#xA;    version: 5.0.0&#xA;    repo:git@github.com:go-redis/redis&#xA;常见问题&#xA;    o-&amp;gt; cannot detect vcs&#xA;        glide.lock或vendor依赖旧版本&#xA;            清理glide.lock和vendor, 检查glide.yaml旧版本&#xA;        glide.yaml子目录处理不完善&#xA;            subpackages:&#xA;            - cloudsql&#xA;        glide mirror找不到包&#xA;            glide mirror set a a --vcs git&#xA;                # 改~/.glide/mirrors.yaml文件&#xA;    o-&amp;gt; does not appear to be a git repository&#xA;        加速服务没有项目&#xA;    o-&amp;gt; glide up依赖不是最新&#xA;        ~/.glide/cache中缓存了旧版本&#xA;    o-&amp;gt; cannot find package &amp;quot;.&amp;quot; in&#xA;        glide对非git协议自有域名处理歧义，子目录分析不准确&#xA;            清理缓存&#xA;                ~/.glide/cache/src/包名&#xA;                ~/.glide/cache/info/包名&#xA;            glide.yaml添加repo重定向及subpackages&#xA;                package: github.com/grpc-ecosystem/grpc-gateway&#xA;                repo: git@github.com:grpc-ecosystem/grpc-gateway.git&#xA;                subpackages:&#xA;                - internal&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;govendor&#34;&gt;&#xA;  govendor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#govendor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    包管理&#xA;使用&#xA;    go get -u -v github.com/kardianos/govendor&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;godev&#34;&gt;&#xA;  godev&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#godev&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gv&#34;&gt;&#xA;  gv&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gv&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gvt&#34;&gt;&#xA;  gvt&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gvt&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 依赖管理&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gvm&#34;&gt;&#xA;  gvm&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gvm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 版本管理&#xA;命令&#xA;    gvm&#xA;        install go1.5&#xA;        use go1.5&#xA;        list&#xA;        listall&#xA;        implode&#xA;            # 删除所有go版本和gvm本身&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gore&#34;&gt;&#xA;  gore&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gore&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# repl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;go-torch&#34;&gt;&#xA;  go-torch&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-torch&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 性能火焰图&#xA;go-torch -b cpu.prof&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;gf&#34;&gt;&#xA;  gf&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#gf&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;-v/version&#xA;-h/help&#xA;init&#xA;build&#xA;gen         # 生成模块&#xA;    gen dao&#xA;run&#xA;swagger&#xA;pack&#xA;get&#xA;docker&#xA;mod&#xA;update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;包                              # 路径引用，命名空间&#xA;    不能循环依赖&#xA;    main包                      # 入口包, 产生可执行文件，也可当库导入&#xA;        main()                  # 入口函数&#xA;    包名最好匹配目录名          # 导入路径的最后一段&#xA;    import&#xA;        逐行import或import(多行)&#xA;        import 别名 包路径&#xA;        import &amp;quot;gopkg.in/yaml.v2&amp;quot; 忽略.v2, 包名为yaml&#xA;        import _ &amp;quot;image/png&amp;quot; 空导入&#xA;        可导入相对目录，以.或..开头&#xA;    var和const&#xA;        逐行或var(多行), const(多行)&#xA;    包文件函数&#xA;        init                    # 文件在编译前排序，按依赖顺序和文件名，也是init的调用顺序。init不能调用和引用&#xA;    包依赖排序依次初始化&#xA;    工作空间&#xA;        src&#xA;        bin                     # 编译后的执行文件&#xA;        pkg                     # 编译后的包, 重复使用加快编译&#xA;    vendor目录放本地依赖&#xA;    文档注释影响编译&#xA;        // +build linux darwin                  # linux和darwin才编译&#xA;        // +build ignore                        # 任何时候都不编译&#xA;    内部包                      # 路径有internal的包, 只能被父目录导入&#xA;        net/http/internal/chunked&#xA;注释&#xA;    //或/**/&#xA;    package前写文档注释，可出现在任何文件中，但一个包约定一个&#xA;    doc.go约定为包的扩展文档注释&#xA;命名&#xA;    字母或下划线开头，区分大小写, 不能用关键字&#xA;    关键字: break, default, func, interface, select, case, defer, go, map, struct, chan, else&#xA;        goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return, var&#xA;    首字母大小写决定可见性，大写表示其是导出的&#xA;    go倾向短名称, 驼峰式命名, 缩写全大写或小写&#xA;操作符&#xA;    优先级:&#xA;        * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^    # 可加=, 如*=&#xA;        + - | ^             # 可加=, 如*=&#xA;        == != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;=     # 基本类型都可比较&#xA;        &amp;amp;&amp;amp;&#xA;        ||&#xA;        + -                 # 一元取正负&#xA;    %                       # 只能整数，符号与被除数一致&#xA;    /                       # 整数除，去小数部分。溢出高位丢弃&#xA;    &amp;amp; | ^ &amp;amp;^                # 按位独立&#xA;        &amp;amp;^                  # and not(位清空)右边1清左边为0&#xA;        &amp;amp;                   # and&#xA;        |                   # or&#xA;        ^                   # xor, 前缀表示取反或按位取补(逐位取反)&#xA;    &amp;lt;&amp;lt; &amp;gt;&amp;gt;                   # 注意，有符号数右移按符号位填补空位&#xA;声明定义&#xA;    不能有无用的声明变量&#xA;    var s string            # 未初始化值默认零值，类型和表达式可省一个&#xA;    var s string = &amp;quot;&amp;quot;       # 不推荐&#xA;    var s = &amp;quot;&amp;quot;              # 不推荐&#xA;    s := &amp;quot;&amp;quot;                 # 短变量声明&#xA;&#xA;    var i,j int             # 自动引申变量类型&#xA;    i, j := 0, 1&#xA;    i, j := true, &amp;quot;a&amp;quot;       # 类型可不一致&#xA;    i, err := 0, e          # err声明过(只检测本词法块，外层不算)，声明i, 赋值err。:=要求至少一个声明&#xA;&#xA;    const                   # 编译时计算&#xA;        枚举&#xA;            type Weekday int&#xA;            const (&#xA;                Sunday Weekday = iota               # 值为0&#xA;                Monday&#xA;                ...&#xA;            )&#xA;            const (&#xA;                i T1 = 1 &amp;lt;&amp;lt; iota                    # 值为1, 下值为 1&amp;lt;&amp;lt;1&#xA;                ...&#xA;            )&#xA;        无类型常量&#xA;            只有常量可以无类型&#xA;            无类型常量存大数精度高于基本类型, 算术精度高于机器精度, 至少256位&#xA;            可用于更多表达式，无需转换类型&#xA;            分类&#xA;                布尔: true&#xA;                整数: 0&#xA;                文字符号: &#39;\u0000&#39;&#xA;                浮点数: 0.0&#xA;                复数: 0i&#xA;                字符串: &amp;quot;&amp;quot;&#xA;            const (&#xA;                _ = 1 &amp;lt;&amp;lt; (10 * iota)             # 下值为 1&amp;lt;&amp;lt;(10*1)&#xA;                ...&#xA;            )&#xA;&#xA;&#xA;    type                    # 类型声明&#xA;        type A int          # 底层共类型, 可赋值性，可比较性。可重写String方法让fmt打印时个性化&#xA;        a = A(i)            # 可赋值就可类型转换&#xA;    func&#xA;    变量生命周期&#xA;        包级别是整个程序执行时间&#xA;        局部变量声明时创建，直到不可访问&#xA;    堆栈&#xA;        逃逸变量(函数外保存地址)在堆，局部变量在栈                   # 与变量创建方式无关(new与否), 逃逸需要一次额外内存分配。&#xA;赋值&#xA;    x = 1&#xA;    *p = 1&#xA;    p.name = &amp;quot;&amp;quot;&#xA;    m[key] = 1&#xA;&#xA;    +=&#xA;    i++和i--                # 只能自成一行, 且不能++i, --i&#xA;    _                       # 忽略变量&#xA;    a, b = b, a             # 多重赋值&#xA;&#xA;    v, err = f()&#xA;    v, ok = m[key]          # map查询&#xA;    v, ok = x.(T)           # 类型断言&#xA;    v, ok = &amp;lt;-ch            # 通道接收&#xA;    可赋值性：类型精准匹配，nil赋值任何接口变量或引用变量, 常量更易隐式转换赋值&#xA;        ==和!= 比较，两边要求是可赋值的&#xA;指针                         # 不能运算&#xA;    &amp;amp;获取地址&#xA;    *获取指针&#xA;语句&#xA;    变长参数&#xA;        f(s...)&#xA;    for&#xA;        for i, j := 0, 1; i &amp;lt; n; i++ {}&#xA;        for i &amp;lt; n {}&#xA;        for {}&#xA;        for index, value := range slice1{}&#xA;        for key, value := range map1 {}&#xA;        for range s{}&#xA;    if&#xA;        if i &amp;lt; n {} else if i &amp;lt; m {} else {}&#xA;        if err := f(); err != nil {}&#xA;    switch&#xA;        switch {                # 无标签(tagless), 相当于switch true,&#xA;        case x &amp;gt; 0:             # fallthrough可贯穿, 可用控制流标签&#xA;        }&#xA;        switch i := 0 {}        # switch true&#xA;        switch i++ { }          # switch true&#xA;        switch f() {}           # switch true&#xA;&#xA;        switch i {&#xA;        case 0:&#xA;        case 1:&#xA;        default:                # default可在任何地方&#xA;        }&#xA;&#xA;        switch t.(type) {                   # 类型匹配, 无匹配类型会panic, 不能用fallthrough&#xA;        case nil:&#xA;        case int, uint;&#xA;        case bool:&#xA;        case string:&#xA;        default:&#xA;        }&#xA;        switch x := x.(type) {}&#xA;    select                                  # channel用select, 值用switch。一直等待直到匹配(default会直接匹配)。多情况匹配随机选择。不能用fallthrough&#xA;        select {&#xA;        case &amp;lt;-ch1:&#xA;        case x := &amp;lt;-ch2:&#xA;        case ch3 &amp;lt;- y:&#xA;        default:&#xA;        }&#xA;&#xA;        o-&amp;gt; 超时&#xA;        select {&#xA;        case &amp;lt;-time.After(10*time.Second):&#xA;        case &amp;lt;-ch:&#xA;        }&#xA;&#xA;        o-&amp;gt; 自发自接&#xA;        for i := 0; i &amp;lt; 10; i++{&#xA;            select {&#xA;            case x := &amp;lt;-ch:&#xA;            case ch &amp;lt;- i:&#xA;            }&#xA;        }&#xA;&#xA;        o-&amp;gt; 标签&#xA;        c := make(chan struct{},2)&#xA;        label1:&#xA;        for {&#xA;            select {&#xA;            case c&amp;lt;- struct{}{}:&#xA;                fmt.Println(1)&#xA;            case &amp;lt;-c:&#xA;                fmt.Println(2)&#xA;                break                       # 无标签break跳出当前select块&#xA;                    # break label&#xA;                    # goto label2&#xA;                    # return&#xA;            default:&#xA;                fmt.Println(3)&#xA;            }&#xA;        }&#xA;        label2:&#xA;        ...&#xA;    控制流标签&#xA;        break, continue, goto   # 可标签化, 如break Label1&#xA;作用域&#xA;    词法块：语法块(block)(大括号), 隐式块(未在大括号中的声明, 如if中)&#xA;        全局块                   # 内置&#xA;        包级别                   # 函数外的声明&#xA;        文件级别                  # 导入的包&#xA;        局部&#xA;    控制流标签作用域是外层函数&#xA;    覆盖&#xA;        x := 1&#xA;        for {&#xA;            x := x+1&#xA;            if .. {&#xA;                x := x+1        # 这里值的x是最外层x&#xA;            }&#xA;        }&#xA;    if声明的变量(隐式词法块)，else中可见&#xA;        if v, err := f(); err != nil {      # else中处理非err逻辑&#xA;            return err&#xA;        } else {&#xA;            v.close()&#xA;        }&#xA;    包中声明作用域无顺序，可递归    # 常量、变量不可以引用自己&#xA; 函数&#xA;    字面量&#xA;        var func()                   # 声明&#xA;        func f(i int) int {}&#xA;        func f(i, j int) (int, error){}&#xA;        func f() (r int){}&#xA;        func f(vals ...int) {}       # 变长函数, 只放最后, vals是slice&#xA;            f(vals...)&#xA;    一等公民&#xA;    函数签名，即函数类型，包括形参列表和返回列表, 命名不影响&#xA;    未定义时为nil, 不可比较&#xA;    值传递, 不能指定默认值&#xA;    函数返回多值, 可return, 可做传入参数&#xA;    返回值有命名，可祼返回(不在return后写参数)&#xA;    错误&#xA;        v, ok := f()                  # 错误只一种情况&#xA;        v, err := f()                 # 错误信息会串联，避免首字母大写和换行&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;    匿名函数用字面量定义，包含外层词法环境(闭包)&#xA;        递归要先声明，再赋值定义&#xA;        重定义变量&#xA;        for _, dir := range dirs() {&#xA;            dir := dir                      # for块作用域变量共享位置，重定义dir每次一个位置&#xA;            dirs = append(dirs, func(){     # 匿名函数引用外层变量，却不一定同步执行&#xA;                os.RemoveAll(dir)&#xA;            })&#xA;        }&#xA;方法&#xA;    字面量&#xA;        func (t T) f(){}                    # t值传递, 方法名唯一, 方法名不能用字段名&#xA;        func (t *T) f(){}                   # t引用传递&#xA;&#xA;        type Path []Point                   # 别名赋方法(不能是指针和接口), 可覆盖原类型方法&#xA;        func (p *Path)f(){}&#xA;    方法可在任何类型(除指针和接口), 如函数&#xA;    变量与变量指针都可直接调方法，编译器隐式取地址或取指针&#xA;        P{1}.f()                            # 编译器不报错但运行出错, f()声明成引用传递, 但P{1}.时, 内存地址还未分配, 即还没有*P, 就无法调f()&#xA;    有引用传递方法时，避免值传递方法，会产生多例&#xA;    值为nil时可调方法&#xA;    方法可赋值&#xA;        f := t.f&#xA;        f(t.f)&#xA;    组合&#xA;        结构体匿名成员方法可如属性般直接调用&#xA;        匿名成员是引用时，多结构体可组合同一成员对象&#xA;        多匿名成员方法冲突时，调用时编译报错&#xA;        可给未命名结构体加方法&#xA;            t = struct{&#xA;                sync.Mutex&#xA;                v int&#xA;            }&#xA;            t.Lock(); t.v++; t.Unlock()&#xA;接口&#xA;    字面量&#xA;        type I interface {&#xA;            f()&#xA;        }&#xA;        type I2 interface {                  # 接口组合&#xA;            I&#xA;        }&#xA;&#xA;        v := t.(T)                           # 断言，失败panic&#xA;        v, ok := t.(T)                       # 失败不panic, ok=false&#xA;    隐式实现，方法匹配即可(接口即约定)           # 鸭子&#xA;    指针方法匹配接口，对接口赋值时要传指针&#xA;    interface{}为空接口类型，可赋值任何类型&#xA;    实现&#xA;        除了接口的定义类型，还包含动态类型(Type) + 动态值(Value)               # 编译时不知道，生成代码在运行时动态分发&#xA;            零值，是动态类型和动态值都是nil&#xA;                动态类型是nil, 指的是它为接口本身类型&#xA;                i = nil会设置接口为零值&#xA;            ==和!=比较&#xA;                动态值都为nil相等&#xA;                动态类型和动态值都相等，才相等&#xA;                    i = new(T); i != nil&#xA;                动态类型一致，动态值不可比较(如slice), 则panic                # 非平凡&#xA;                格式化输出%T拿到动态类型&#xA;    断言&#xA;        变定义类型, 动态类型和动态值不变&#xA;        空接口断言总失败&#xA;        断言成接口，使用公共功能&#xA;            v := t.(I)&#xA;            v.Common()&#xA;    风格&#xA;        强调功能相似性                         # 子类型多态(subtype polymorphism)&#xA;        联合再断言区分                         # 可识别联合(discriminated union), 特设多态(ad hoc polymorhpism)&#xA;            switch t.(type) {}&#xA;关键字&#xA;    defer fn                                 # 后进先出, return或panic后调用&#xA;        defer func(i){...}(1)&#xA;        return、出参赋值、defer顺序            # 先赋值，再defer，再return&#xA;            func f() (i int) {&#xA;                defer func(){&#xA;                    i++&#xA;                }&#xA;                return 0          # 相当于 i=0; i++; return&#xA;            }&#xA;    go fn&#xA;    异常&#xA;        panic()&#xA;            日志包括值(interface{}), 调用栈&#xA;                用interface{}自定义异常类型&#xA;                runtime.Stack()查看栈，利用defer函数在栈清理前调用, 所以栈存在&#xA;            终止当前goroutine, 外层goroutine不捕获&#xA;            按函数调用栈依次中止函数并调defer, 最上层后程序异常退出&#xA;            panic之后定义的defer不执行(声明不提前)&#xA;        recover()&#xA;            中止panic&#xA;            在defer中(panic时只调defer)捕获panic对象，没有时为nil&#xA;            捕获panic对象后, 捕获函数正常返回。要上抛就再手动panic()&#xA;        o-&amp;gt;&#xA;        func Try(fn func(), handler func(interface{})) {&#xA;            defer func() {&#xA;                if err := recover(); err != nil {&#xA;                    handler(err)&#xA;                }&#xA;            }()&#xA;            fn()&#xA;        }&#xA;&#xA;        func main() {／&#xA;            Try(func() {&#xA;                panic(&amp;quot;a&amp;quot;)&#xA;            }, func(e interface{}) {&#xA;                print(e)&#xA;            })&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内置&#34;&gt;&#xA;  内置&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;零值                              # 保障变量良好定义，没有未初始化变量&#xA;    数字0, 布尔false, 字符串&amp;quot;&amp;quot;&#xA;    接口和引用类型(slice, 指针, map, channel, 函数)nil&#xA;    复合类型其所有元素或成员零值&#xA;常量&#xA;    true&#xA;    false&#xA;    iota&#xA;    nil&#xA;        比较&#xA;            var s []int         # 未初始化比较, ==nil&#xA;            s = []int(nil)      # 强转, ==nil&#xA;            s = []int{}         # 初始化比较, !=nil&#xA;基本类型&#xA;    字面量&#xA;        06                      # 8进制&#xA;        0x0a                    # 16进制&#xA;        .1或1.                   # 小数点前后可省略&#xA;        2.2e10                  # 科学计数法&#xA;        1 + 2i                  # 复数&#xA;        字符串&#xA;            &amp;quot;\\&amp;quot;                # 转义&#xA;            &amp;quot;\r&amp;quot;                # 光标退到行首&#xA;            &amp;quot;\b&amp;quot;                # 光标退一字符&#xA;            &amp;quot;\x1a&amp;quot;              # 16进制表示位数据, 必2位，无法识别成unicode&#xA;            &amp;quot;\212&amp;quot;              # 8进制表示位数据, 必3位, 无法识别成unicode&#xA;            &amp;quot;\u1234&amp;quot;            # unicode, 16进制数字, 共4x4=16位&#xA;            &amp;quot;\u12345678&amp;quot;        # unicode, 16进制数字, 共4x8=32位&#xA;            ``                  # 原生字符串, 回车被删除(换行符保留)&#xA;    注意&#xA;        会自动截断，如int i=127; i+1=-128; i*i=1&#xA;    int                         # 平台原生整数大小，或该平台运算效率最高值, 多是int32&#xA;    int8                        # -128-127&#xA;    int16&#xA;    int32&#xA;    int64&#xA;    uint                        # 平台决定大小。无符号极少用于表示非负值，往往用于位运算或特定算术运算符，如位集，解析二进制，散列，加密&#xA;    uint8                       # 0-255&#xA;    uint16&#xA;    uint32&#xA;    uint64&#xA;    uintptr                     # 存放指针，大小不明确，底层编程&#xA;    float32                     # 运算会迅速累积误差, 正整数范围有限&#xA;    float64&#xA;    complex64                   # float32构成&#xA;    complex128                  # float64构成&#xA;        var x complex128 = complex(1,2)&#xA;        x := 1 + 2i&#xA;    bool&#xA;    byte                        # uint8别名, 强调是原始数据&#xA;    rune                        # int32别名, unicode码点(UTF-8), 下标取字符(非字节)&#xA;    string                      # 认为是UTF-8编码的unicode, 不合理字节替换成方块(\uFFFD)。不可变(安全截取、共用), 下标取字节，越界宕机异常&#xA;        和数组和slice一样操作&#xA;        []byte和string元素操作一致，只类型不同&#xA;        互换&#xA;            []byte, []rune, string                  # 转换产生副本&#xA;    error&#xA;聚合类型&#xA;    数组&#xA;        字面量&#xA;            var q [3]int&#xA;            q := [3]int{1,2,3}&#xA;            q := [...]int{1,2,3}                        # 长度由元素个数决定&#xA;            q := [...]int{0: 1, 3:2}                    # 指定索引元素值&#xA;        数组是值传递&#xA;        数组元素不可包含自己&#xA;        默认元素为零值&#xA;        不同长度不同类型，不能赋值&#xA;        如果元素可比较，数组就可比较     # 深度比较&#xA;            q1 &amp;lt; q2                   # 字符串比较按字节字典排序&#xA;    slice&#xA;        字面量&#xA;            q := []int{1,2,3}                           # 这里创建了slice, 指向了隐式创建的数组&#xA;            q[0:1]                                      # 左闭右开&#xA;            q[:1]; q[1:]; q[:]&#xA;        轻量级数据结构，用来访问数组的部分&#xA;        零值是nil, 行为和slice一样，不用特殊判断&#xA;        slice后标访问越界时，会自动扩展，越界超过数组长度+1时，会panic&#xA;            append(arr[:i], arr[i+1:]...)删除元素, i为最后元素时, i+1不越界&#xA;        不可比较, 只有写函数实现。只能和nil比较&#xA;            因为slice的元素不是直接的&#xA;                有可能包含它自身&#xA;                同slice不同时间会拥有不同元素&#xA;                    如果slice可比较来做map键, map只对key做浅拷贝, slice需要深度比较, 所以要求slice元素不变&#xA;        三元素                         # 有自己的属性，不是纯引用类型，是聚合类型&#xA;            指针: 指向slice在数组上起始位置&#xA;            长度: slice长度&#xA;            容量: 指针到数组结尾元素个数&#xA;    map                                # key可nil, 取不存在key时, 得到value类型的零值。随机无序遍历&#xA;        字面量&#xA;            m := map[string]int{&#xA;                &amp;quot;a&amp;quot;:1,&#xA;            }&#xA;            a[&amp;quot;b&amp;quot;]=2&#xA;        不能获得地址，如&amp;amp;m[&amp;quot;a&amp;quot;]          # 因为map增长时，已有元素可能重新散列&#xA;        迭代顺序随机                     # key用维护排序, 散列算法健壮&#xA;        零值是nil, 向nil map设置元素会panic&#xA;        map[key1]没有时，获得零值&#xA;            v, ok := m[&amp;quot;a&amp;quot;]             # 判断有无key&#xA;        不可比较，只能和nil比较&#xA;        key要求可比较，可以数组,不可以slice,可以自己映射成可比较类型&#xA;            q := [2]int{}&#xA;            m := map[[2]int]int{}&#xA;            m[q] = 1&#xA;    结构体&#xA;        字面量&#xA;            type T struct {                             # 结构体,&#xA;                Name string `json:&amp;quot;name0,omitempty&amp;quot;`    # 成员标签定义, opmitempty在零值时忽略&#xA;                I1, I2 int&#xA;            }&#xA;&#xA;            t := &amp;amp;T{&amp;quot;a&amp;quot;}                                # 顺序易出错, 用于明显的小结构。未指定成员为零值&#xA;            t := &amp;amp;T{&#xA;                Name: &amp;quot;a&amp;quot;,&#xA;            }&#xA;            (*t).Name = &amp;quot;a&amp;quot;&#xA;            t.Name = &amp;quot;a&amp;quot;                                # .可以用于指针&#xA;&#xA;            struct{}                                    # 空结构体，没有长度，无信息。&#xA;&#xA;            type T1 struct{                             # 匿名成员&#xA;                T&#xA;                T2&#xA;                *T3&#xA;                Name1 string&#xA;            }&#xA;            t1 := T1{&#xA;                T: {&#xA;                    Name: &amp;quot;a&amp;quot;&#xA;                }&#xA;            }&#xA;&#xA;        首字母大写可导出&#xA;        属性类型不可自己，但可自己指针&#xA;        结构体零值由成员零值组成            # 希望结构体方法中处理零值成一个自然的值，如sync.Mutex&#xA;        成员可比较，结构体实例可比较, 可作map key&#xA;        匿名成员(组合)&#xA;            点号访问可跨入(语法糖)，访问匿名成员属性和方法&#xA;                t1.Name; t1.T.Name&#xA;            不能有相同类型的匿名成员&#xA;            不可导出类型的匿名成员，内部成员不影响，但匿名成员本身不可见&#xA;引用类型&#xA;    Type&#xA;    IntegerType&#xA;    FloatType&#xA;    ComplexType&#xA;&#xA;    chan&#xA;        ch := make(chan string)&#xA;&#xA;        var cin chan&amp;lt;- string&#xA;        var cout &amp;lt;-chan string&#xA;&#xA;        ch &amp;lt;- &amp;quot;&amp;quot;&#xA;        &amp;lt;-ch&#xA;接口类型&#xA;    error&#xA;        Error()&#xA;命名类型&#xA;    type&#xA;    结构体&#xA;        type Point struct {&#xA;            X, Y int&#xA;        }&#xA;函数&#xA;    make()&#xA;        make([]int)&#xA;        make(map[string]int)&#xA;        make(chan int)&#xA;    delete()&#xA;        delete(m, &amp;quot;a&amp;quot;)          # 删除map元素, 没key不报错返回零值&#xA;    len()&#xA;        len(ch)                 # 当前缓冲个数&#xA;    cap()&#xA;        cap(ch)                 # 缓冲区容量&#xA;    new()                       # 创建指定类型变量，初始化为零值，返回地址。不带任何信息且是零值(struct{}和[0]int)的类型, new出的地址不同(从前相同)&#xA;        t := new(T)&#xA;    append()                    # 操作slice&#xA;        先检查原容量，容量够修改原数组元素，不够创建新数组(容量扩一倍)复制元素, 返回新slice&#xA;        所以append()最好赋值给原slice&#xA;        s1 := append(s1, s2...)&#xA;    copy()                      # slice或string元素复制&#xA;    close()                     # channel中用&#xA;    complex()                   # 创建复数对象&#xA;    real()                      # 获取复数的实部&#xA;    imag()                      # 获取复数的虚部&#xA;    panic()&#xA;    recover()&#xA;反射&#xA;    谨慎使用&#xA;        脆弱，能导致编译报错的写法，反射中都对应panic，执行时才知道&#xA;        降低自动重构和分析工具的安全性与准确度，反射对类型操作无法静态检查&#xA;        反射慢1-2个数量级(实测20位左右), 适合测试用，不适合关键路径上用&#xA;unsafe&#xA;    值在内存中对齐，计算更高效。结构体用内存间隙来对齐，占空间比元素之和更大&#xA;    结构体成员内存中重新排列可省内存，但目前不是&#xA;cgo&#xA;    o-&amp;gt; c文件&#xA;    #include &amp;lt;bzlib.h&amp;gt;&#xA;    int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen) {...}&#xA;&#xA;    o-&amp;gt; go文件&#xA;    /*&#xA;    #cgo CFLAGS: -I/usr/include&#xA;    #cgo LDFLAGS: -L/usr/lib -lbz2&#xA;    #include &amp;lt;bzlib.h&amp;gt;&#xA;    int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen);&#xA;    */&#xA;    import &amp;quot;C&amp;quot;&#xA;    import (&#xA;        &amp;quot;io&amp;quot;&#xA;        &amp;quot;unsafe&amp;quot;&#xA;    )&#xA;    type writer struct {&#xA;        w io.Writer&#xA;        stream *C.bz_stream&#xA;        outbuf [64*1024]byte&#xA;    }&#xA;    func NewWriter(out io.Writer) io.WriteCloser{&#xA;        const (&#xA;            blockSize = 9&#xA;            verbosity = 0&#xA;            workFactor = 30&#xA;        )&#xA;        w := &amp;amp;writer{w: out, stream: C.bz2alloc()}&#xA;        C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)&#xA;        return w&#xA;    }&#xA;    func (w *writer) Write(data []byte) (int, erro) {&#xA;        if w.stream == nil {&#xA;            panic(&amp;quot;closed&amp;quot;)&#xA;        }&#xA;        var total int&#xA;        for len(data) &amp;gt; 0 {&#xA;            inlen, outlen := C.uint(len(data)), C.uint(cap(w.outbuf))&#xA;            C.bz2compress(w.stream, C.BZ_RUN, (*C.char)(unsafe.Pointer(&amp;amp;data[0])), &amp;amp;inlen, (*C.char)(unsafe.Pointer(&amp;amp;w.outbuf)), &amp;amp;outlen)&#xA;            total += int(inlen)&#xA;            data = data[inlen:]&#xA;            if _, err := w.w.Write(w.outbuf[:outlen]); err != nil {&#xA;                return total, err&#xA;            }&#xA;        }&#xA;        return total, nil&#xA;    }&#xA;&#xA;    注释&#xA;        #cgo 指令指定C工具链选项&#xA;    import &amp;quot;c&amp;quot;&#xA;        编译时促使go build用cgo预处理其上注释&#xA;        产生临时包包含c函数对应声明&#xA;            包含类型，函数，预处理宏对象&#xA;            这里用了C.bz_stream和C.BZ2_bzCompressInit&#xA;    go也可编译成静态库链接进C, 或编译成动态库通过C加载和共享&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;内部包&#34;&gt;&#xA;  内部包&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e9%83%a8%e5%8c%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# golang.org/pkg 找到索引&#xA;errors&#xA;    New()&#xA;testing&#xA;    T&#xA;        Error()&#xA;        Errorf()&#xA;        Fatal()&#xA;        Fatalf()&#xA;    B&#xA;syscall                 # 执行其它语言&#xA;syscall/js&#xA;js/wasm                 # 1.11, webAssembly&#xA;go/doc&#xA;go/token&#xA;runtime&#xA;    Stack()                             # 调用栈&#xA;    Gosched()                           # 让出执行权&#xA;    Goexit()                            # 终止当前goroutine, 会执行defer&#xA;    LockOSThread()                      # 绑定协程到当前线程&#xA;    UnlockOSThread()&#xA;    GOMAXPROCS()                        # 并发线程数&#xA;    NumGoroutine()                      # 限制goroutine数&#xA;runtime/debug&#xA;os&#xA;    Stdin                   # 输入流&#xA;    Args                    # 运行参数&#xA;    FileInfo&#xA;&#xA;    Open()                  # 打开文件&#xA;        File&#xA;            Read()&#xA;            Write()&#xA;            Close()&#xA;    Exit(1)                 # 1异常退出&#xA;    RemoveAll()&#xA;    Stat()                  # 文件信息&#xA;os/exec                     # 子进程&#xA;io&#xA;    EOF                     # 文件结束标志, 是一个error&#xA;&#xA;    Copy()&#xA;    WriteString()&#xA;io/ioutil&#xA;    Discard                 # 丢弃&#xA;&#xA;    ReadFile()              # 读整个文件到内存&#xA;    ReadAll()&#xA;    WriteFile()&#xA;    ReadDir()&#xA;bufio                       # 带缓冲io&#xA;    NewScanner()&#xA;        Scanner             # 以行或单词断开&#xA;            Scan()          # 有内容返回true&#xA;            Text()&#xA;    NewReader()&#xA;        ReadRune()&#xA;path                        # 文件路径&#xA;    Base()                  # 获得最后文件名&#xA;path/filepath               # 根据平台处理文件路径&#xA;net&#xA;    Conn&#xA;net/http&#xA;    poolServer(epoll/kqueue/iocp)&#xA;        # 支持多核大量并发连接fd&#xA;    Get()&#xA;        Header&#xA;            Get()&#xA;        Body&#xA;            Close()&#xA;    HandleFunc()&#xA;        ResponseWriter&#xA;        Request&#xA;            RemoteAddr      # 客户ip:端口&#xA;            Host&#xA;            Method&#xA;            Proto           # 网络协议&#xA;            Header&#xA;            Form            # 先ParseForm()&#xA;            URL&#xA;                Path&#xA;&#xA;            ParseForm()&#xA;    ListenAndServe()&#xA;net/http/httputil&#xA;net/url&#xA;    QueryEscape()           # url转义&#xA;context                     # 线程安全, 树形结构&#xA;    Cancel()&#xA;    Deadline(Timeout)&#xA;    Value()&#xA;    TODO()&#xA;&#xA;    o-&amp;gt; ctx.Done()&#xA;    func f(ctx context.Context) (error) {&#xA;        errc := make(chan error, 1)&#xA;&#xA;        go func() {&#xA;            defer close(errc)&#xA;            time.Sleep(2 * time.Second)&#xA;            errc &amp;lt;- nil&#xA;        }()&#xA;&#xA;        select {&#xA;        case &amp;lt;-ctx.Done():&#xA;            &amp;lt;-errc&#xA;            return ctx.Err()&#xA;        case err := &amp;lt;-errc:&#xA;            return err&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; WithTimeout&#xA;    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)     # 调cancel提前结束&#xA;    defer cancel()&#xA;    return f(ctx)&#xA;flag&#xA;    Args                    # 非标识参数&#xA;    Parse()                 # 出错调os.Exit(2)&#xA;&#xA;    o-&amp;gt; 输入&#39;-s / a bc&#39;, 输出&#39;a/bc&#39;&#xA;    sep := flag.Strings(&amp;quot;s&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;desc s&amp;quot;)&#xA;    flag.Parse()&#xA;    println(strings.Join(flag.Args(), *sep))&#xA;log&#xA;    SetPrefix()&#xA;    SetFlags()              # 格式标记&#xA;    Fatal()                 # 加日期时间前缀&#xA;    Fatalf()&#xA;time&#xA;    Time&#xA;        Format()&#xA;&#xA;    Now()&#xA;    Since()&#xA;        Seconds()&#xA;    After()&#xA;    AfterFunc()&#xA;    NewTicker()&#xA;        ticker := time.NewTicker(1 * time.Second)&#xA;        &amp;lt;- ticker.C&#xA;        ticker.Stop()&#xA;    Tick()&#xA;        tick := time.Tick(1 * time.Second)          # 无法中止, 用于全局，否则内部goroutine泄漏&#xA;        for {&#xA;            &amp;lt;-tick&#xA;        }&#xA;&#xA;&#xA;fmt                         # string类型会调对象的String()方法&#xA;    Stringer                # 接口，有String()方法可匹配&#xA;&#xA;    Printf()                # 可以用转义序列(\t等)表示不可见字符&#xA;        %d                  # 十进制整数&#xA;        %x, %o, %b          # 十六进制、八进制、二进制整数&#xA;            %X&#xA;            % x             # 十六进制输出，两数一空格&#xA;        %f, %g, %e          # 浮点数6位小数、15位小数并自动精度与表示方式、6位小数e表示&#xA;            &amp;quot;%8.3f&amp;quot;         # 输出8字符宽度，保留3位小数&#xA;        %t                  # 布尔&#xA;        %c                  # unicode字符&#xA;        %s                  # 字符串&#xA;            %*s             # 缩进后面指定数字个空格&#xA;        %q                  # 带引号字符串(&amp;quot;abc&amp;quot;)，或字符(&#39;c&#39;)&#xA;        %v                  # 内置格式的任何值&#xA;            %#v             # 包含结构体成员名字&#xA;        %T                  # 类型&#xA;        %[1]c               # 重复利用第一个参数&#xA;            Printf(&amp;quot;%d %[1]c %[1]q&amp;quot;, &#39;a&#39;)&#xA;        %%                  # %本身&#xA;        特殊数字&#xA;            var z float64&#xA;            fmt.Println(z,-z,1/z,-1/z,z/z)              # &amp;quot;0 -0 +Inf -Inf NaN&amp;quot;&#xA;    Fprintf()&#xA;    Scanf()                 # 格式化输入&#xA;    Errorf()                # 产生一个error&#xA;strconv                     # 类型转换&#xA;    ParseFloat()&#xA;    ParseInt()&#xA;    ParseUint()&#xA;    Itoa()                  # 整数转字符串&#xA;    FormatInt(int64(1a), 2)&#xA;    FormatUint()&#xA;unicode                 # 单符号&#xA;    ToUpper()&#xA;    ToLower()&#xA;    IsDigit()&#xA;    IsLetter()&#xA;unicode/utf8            # 逐个处理&#xA;    RuneCountInString()                 # 字符数&#xA;    DecodeRuneInString()                # 解码, string类型默认调用&#xA;bytes                       # 操作byte数组&#xA;    Buffer&#xA;        WriteByte()&#xA;        WriteRune()&#xA;        WriteString()&#xA;        String()&#xA;&#xA;    Index()&#xA;    Contains()&#xA;    Count()&#xA;    Fields()&#xA;    HasPrefix()&#xA;    Join()&#xA;    Equal()&#xA;strings                     # 处理UTF-8或位序列&#xA;    Index()&#xA;    Split()&#xA;    HasPrefix()&#xA;    HasSuffix()&#xA;    Contains()&#xA;    Count()&#xA;    Fields()&#xA;    Join()&#xA;regexp&#xA;    MustCompile()           # 检查&#xA;    Compile()               # 编译表达式&#xA;text/template&#xA;    Must()                  # 检查，有错panic&#xA;&#xA;&#xA;    o-&amp;gt;&#xA;    {{.Name}}               # .代表当前值&#xA;    {{range .Items}}&#xA;        {{.Title | printf &amp;quot;%.64s&amp;quot;}}&#xA;        {{.CreateAt | daysAgo}}&#xA;    {{end}}&#xA;    template.New(&amp;quot;report&amp;quot;).&#xA;        Funcs(template.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}).&#xA;        Parse(templ)&#xA;text/tabwriter              # 生成表格&#xA;    Flush()&#xA;html/template               # 对html, js, css, url中原字符转义, 避免对输出页面注入控制&#xA;    Html                    # 字符串转成该类型，受信任，不用转义&#xA;&#xA;    Parse()                 # 解析html&#xA;encoding/json               # unicode&#xA;    Marshal()               # 转成json, 不可导出不可见&#xA;    MarshalIndent()         # 格式化转成json&#xA;    Unmarshal()&#xA;    NewDecoder()            # 流式解码&#xA;        Decode()&#xA;encoding/xml&#xA;encoding/gob&#xA;encoding/asn1&#xA;compress/gzip               # DEFLATE算法&#xA;    NewWriter()&#xA;    NewReader()&#xA;compress/bzip2              # Burrows-Wheeler变换, 压缩高，慢&#xA;&#xA;&#xA;sort&#xA;    IntSlice&#xA;        sort.Sort(sort.IntSlice(ints))&#xA;&#xA;    Sort()&#xA;    Reverse()&#xA;        sort.Sort(sort.Reverse(values))&#xA;    IsSorted()&#xA;    Strings()&#xA;    Ints()&#xA;    IntsAreSorted()&#xA;&#xA;    o-&amp;gt;&#xA;    type StringSlice []string&#xA;    func (p StringSlice) Len()int {return len(p)}&#xA;    func (p StringSlice) Less(i, j int)bool {return p[i] &amp;lt; p[j]}&#xA;    func (p StringSlice) Swap(i, j int) {p[i], p[j] = p[j], p[i]}&#xA;    sort.Sort(StringSlice(names))&#xA;math&#xA;    Sin()&#xA;    NaN()               # 返回NaN, NaN值比较总false(除!=), NaN用作信号量&#xA;math/rand&#xA;    Seed(time.Now().UTC().UnixNano())&#xA;    Float64()&#xA;math/cmplx              # 复数运算&#xA;    Sqrt(-1)            # 0 + 1i&#xA;math/bits&#xA;image&#xA;    Rect()&#xA;    NewPaletted()&#xA;        SetColorIndex()&#xA;    Decode()&#xA;    Encode()&#xA;image/color&#xA;    Color&#xA;    White&#xA;    Black&#xA;image/gif&#xA;    GIF&#xA;image/jpeg              # 空导入注册解码器&#xA;image/png               # 空导入注册解码器&#xA;&#xA;&#xA;sync&#xA;    Mutex&#xA;        Lock()&#xA;        Unlock()&#xA;    RWMutex&#xA;        Lock()&#xA;        Unlock()&#xA;        RLock()&#xA;        RUnlock()&#xA;    Once                                # 单例资源初始化，解决了多线程下读检查，防重写的问题&#xA;        Do()&#xA;    WaitGroup&#xA;    Cond&#xA;        Wait()                          # 计数加1, 进入阻塞&#xA;        Signal()                        # 解除一个阻塞，计数减1&#xA;        Broadcast()                     # 解除所有阻塞&#xA;    Map&#xA;    Pool&#xA;&#xA;&#xA;reflect                 # 非导出字段反射可见, 不可更新&#xA;    Type                # 类型&#xA;        String()        # 类型描述, fmt.Printf()中的&amp;quot;%T&amp;quot; 内部调用&#xA;        Field()         # 结构体成员, 返回StructField&#xA;            Name&#xA;        Method()&#xA;    Value               # 值&#xA;        String()        # 值描述，如&amp;quot;&amp;lt;int Value&amp;gt;&amp;quot;&#xA;        Type()&#xA;        Interface()     # 返回接口具体值&#xA;            x := v.Interface()&#xA;            i := x.(int)&#xA;        Kind()          # 得到类型，Bool, String, 各种数字, Array, Struct, Chan, Func, Ptr, Slice, Map, Interface, Invalid(零值), Func&#xA;        Index()         # 数组&#xA;        NumField()      # 结构体成员数&#xA;        FieldByName()&#xA;        MapKeys()       # map&#xA;        MapIndex()      # map&#xA;        IsValid()&#xA;        IsNil()         # 指针&#xA;        Elem()          # 指针指向元素&#xA;        CanAddr()       # 是否可寻址，如指针元素取Elem()的值，数组元素&#xA;        Addr()          # 取地址&#xA;            v.Addr().Interface().(*int)&#xA;        CanSet()        # 检查CanAddr()和是否非导出字段&#xA;        Set()           # 要求可寻址, 类型一致。可Set()interface{}类型&#xA;            SetInt(), SetUint(), SetString(), SetFloat()            # 相对Set()有容错性,不可SetXx()interface{}类型&#xA;            SetMapIndex()&#xA;        NumMethod()     # 方法数&#xA;        Method()        # 取方法&#xA;            Name&#xA;        Call()          # 执行Func类型Value&#xA;    StructField&#xA;        Tag&#xA;    StructTag&#xA;        Get()           # 字段标签中key的值&#xA;    Method&#xA;&#xA;    TypeOf()&#xA;    ValueOf()&#xA;    Zero()              # 零值&#xA;    Append()&#xA;    MakeMap()&#xA;    New()               # 类型新对象地址&#xA;    DeepEqual()         # 深度比较，基本类型用==, 组合类型逐层比较。&#xA;        判断武断，不认为值为nil的map和值不为nil的空map相等。slice同理&#xA;            var c, d map[string]int = nil, make(map[string]int)&#xA;            var a, b []string = nil, []string{}&#xA;&#xA;unsafe                  # 由编译器实现，暴露了内存布局。&#xA;    Pointer             # 任何地址，可比较，可比较nil。无类型向内存写任意值。&#xA;        可转成uintptr对地址计算&#xA;            问题&#xA;                移动垃圾回收器(目前未用)在移变量时地址改变使地址出错。&#xA;                goroutine增长栈时旧栈地址重新分配&#xA;            解决&#xA;                Pointer转uintptr再转回来在一条语句中实现&#xA;            应用&#xA;                深度比较时，防止循环引用，每次比较存两个抽象的指针(即Pointer)和类型(y和y[0]地址一样)&#xA;        var f float64&#xA;        i := *(*uint64)unsafe.Pointer(&amp;amp;f)&#xA;    Sizeof()            # 表达式占字节长度, 不计算表达式，由编译器推断&#xA;    Alignof             # 报告类型对齐方式&#xA;    Offsetof()          # 成员相对起始偏移量, 计算空位&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;外部包&#34;&gt;&#xA;  外部包&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%96%e9%83%a8%e5%8c%85&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;# godoc.org 搜索&#xA;goimports           # 格式化imports顺序&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;测试&#34;&gt;&#xA;  测试&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;规则&#xA;    文件名以_test.go结尾&#xA;    汇报PASS或FAIL, 平均执行时间&#xA;    忽略main函数, 当作库测试&#xA;        main特权函数 log.Fatal()和os.Exit()会阻止跟踪过程&#xA;    包测试循环依赖时，建立外部测试包&#xA;        导出内部成员用于测试的后门成员声明，放在export_test.go内&#xA;机制&#xA;    扫描*_test.go&#xA;    生成临时main包来调用，再编译、运行、汇报, 最后清空临时文件&#xA;Test函数                          # t用于汇报结果和日志&#xA;    func TestF(t *testing.T) {}&#xA;benchmark函数                     # 基准测试，性能&#xA;    b增加了成员N指定执行次数, 增加了性能检测方法&#xA;        开始指定小N, 再推断足够大的N检测稳定运行时间&#xA;    基准测试时初始化代码放循环外面，它的执行时间不加到每次迭代时间中。普通Test做不到&#xA;    用go test -bench=.运行&#xA;        报告中 f-8 1000000 1035 ns/op 分别代表GOMAXPROCS=8, 执行100000次，平均每次1035ns&#xA;&#xA;    o-&amp;gt; 基本使用&#xA;    func BenchmarkF(b *testing.B) {&#xA;        for i := 0; i &amp;lt; b.N; i++{&#xA;            f()&#xA;        }&#xA;    }&#xA;    o-&amp;gt; 相对比较, 如数量级、找最佳缓冲区大小、选算法策略&#xA;    func benchmark(b *testing.B, size int){}&#xA;    func Benchmark10(b *testing.B) {benchmark(b, 10)}&#xA;    func Benchmark100(b *testing.B) {benchmark(b, 100)}&#xA;Example函数                       # 示例，无参无结果。&#xA;    用处&#xA;        可举例子作为文档&#xA;        结尾注释 // output: 验证终端输出&#xA;        实验代码&#xA;    func ExampleF()  {&#xA;        fmt.Print(&amp;quot;a&amp;quot;)&#xA;        // output: aa&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发编程&#34;&gt;&#xA;  并发编程&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;同步&#xA;    func&#xA;    channel                                 # 和调度器深度关联，控制goroutine的阻塞和唤醒&#xA;        缓冲区&#xA;            作用&#xA;                异步&#xA;                    发送接收解耦&#xA;                    让数据可并行处理(计数信号量)&#xA;                    消除goroutine间速率差异(速率大致相同, 某刻休息)&#xA;                        上下游速率差异大时无作用&#xA;                阻塞时同步&#xA;            c := make(chan struct{})&#xA;            c1 := make(chan struct{}, 1)&#xA;            c ← struct{}{}                  # 阻塞&#xA;            ← c                             # 阻塞&#xA;&#xA;            c1 ← struct{}{}                 # 不阻塞&#xA;            c1 ← struct{}{}                 # 阻塞&#xA;            ← c1                            # 不阻塞&#xA;            ← c1                            # 阻塞&#xA;        方向&#xA;            var c chan struct{}             # in和out&#xA;            var cin &amp;lt;-chan struct{}         # in, 关闭时panic&#xA;                v := &amp;lt;-cin&#xA;            var cout chan&amp;lt;- struct{}        # out&#xA;                cout &amp;lt;- v&#xA;&#xA;            cin = c&#xA;            cout = c&#xA;            c = cin                         # 编译错误&#xA;            c = cout                        # 编译错误&#xA;        nil                                 # 永远阻塞, 用于开启禁用情况&#xA;            var c chan struct{}&#xA;            c &amp;lt;- struct{}{}                 # 阻塞&#xA;        关闭                                 # 关闭不是必须的，不影响回收。只是用来通知和广播&#xA;            c := make(chan struct{})&#xA;            close(c)                        # 再关闭panic&#xA;            c ← struct{}{}                  # panic&#xA;            o, ok := ← c                    # o得到零值, ok是false&#xA;    for range&#xA;        c := make(chan struct{})&#xA;        ...&#xA;        for x := range c {}                 # close(c)时break&#xA;    select&#xA;&#xA;    sync包&#xA;    sync/atomic包&#xA;&#xA;&#xA;    o-&amp;gt; 并发三个业务, 一起结束&#xA;    cond := sync.NewCond(new(sync.Mutex))&#xA;    wg := sync.WaitGroup{}&#xA;    wg.Add(3)&#xA;    wg1 := sync.WaitGroup{}&#xA;    wg1.Add(3)&#xA;    for i := 0; i &amp;lt; 3; i++ {&#xA;        go func(i int) {&#xA;            defer wg1.Done()&#xA;            cond.L.Lock()&#xA;            fmt.Println(&amp;quot;wait&amp;quot;, i)          # 业务预处理&#xA;            wg.Done()&#xA;            cond.Wait()                     # 阻塞&#xA;            fmt.Println(&amp;quot;done&amp;quot;, i)          # 业务后续处理(要求所有业务预处理过)&#xA;            cond.L.Unlock()&#xA;        }(i)&#xA;    }&#xA;    wg.Wait()                               # 业务预处理完成&#xA;&#xA;    cond.L.Lock()&#xA;    cond.Broadcast()                        # 处理业务后续&#xA;    cond.L.Unlock()&#xA;    wg1.Wait()                              # goroutine完成&#xA;异步&#xA;    语句&#xA;        语句是串行一致的(sequentially consistent)&#xA;        串行一致基础上，语句会重排, 重排中可能穿插执行其它goroutine语句&#xA;            t := map[string]int{&#xA;                &amp;quot;a&amp;quot;: 1&#xA;                &amp;quot;b&amp;quot;: 2&#xA;            }&#xA;            重排为&#xA;            t := make(map[string]int)&#xA;            t[&amp;quot;a&amp;quot;]=1&#xA;            t[&amp;quot;b&amp;quot;]=2&#xA;    goroutine&#xA;        语句&#xA;            go f()&#xA;        泄漏&#xA;            阻塞不能自动结束                  # 如操作channel时&#xA;            main中最后调panic(), 从崩溃转储信息判断资源释放情况&#xA;        死锁(deadlock)                      # 指没有可调度的goroutine&#xA;            所有goroutine阻塞或没有goroutine&#xA;        运行main的是主goroutine, main返回所有goroutine暴力终结&#xA;        无id(标识)&#xA;        不能中断&#xA;        无返回值&#xA;    runtime&#xA;    context&#xA;    time&#xA;并发模式                                    # 避免goroutine泄漏，保证通信顺序&#xA;    done/quit&#xA;        o-&amp;gt; done控制goroutine退出。         # 更快的响应要写更多的逻辑入侵，找到响应慢点写done逻辑&#xA;        func f(done &amp;lt;-chan struct{}) {&#xA;            select {&#xA;            case &amp;lt;-done:&#xA;                for range ch{              # 耗尽通道, 其它goroutine不会卡在ch&amp;lt;-上而退出&#xA;                }&#xA;                return&#xA;            }&#xA;        }&#xA;        func cancelled()bool{&#xA;            select {&#xA;            case &amp;lt;-done:&#xA;                return true&#xA;            default:&#xA;                return false&#xA;            }&#xA;        }&#xA;        func f2(){                          # 轮循函数中入口检查, 避免创建新goroutine&#xA;            if cancelled() {&#xA;                return&#xA;            }&#xA;        }&#xA;&#xA;        done := make(chan struct{})&#xA;        defer close(done)&#xA;        f(done)&#xA;    channels of channels&#xA;        o-&amp;gt; 循环处理请求&#xA;        func handle(reqs chan chan interface{}) {&#xA;            for req := range reqs {&#xA;                req &amp;lt;- 0&#xA;            }&#xA;        }&#xA;        func server(req chan interface{}) {&#xA;            reqs := make(chan chan interface{})&#xA;            defer close(reqs)&#xA;            go handle(reqs)&#xA;            reqs &amp;lt;- req&#xA;        }&#xA;        func client() interface{} {&#xA;            req := make(chan interface{})&#xA;            defer close(req)&#xA;            go server(req)&#xA;            return &amp;lt;-req&#xA;        }&#xA;        fmt.Println(client())&#xA;&#xA;        o-&amp;gt; 循环异常退出&#xA;        type S struct {&#xA;            closing chan chan error&#xA;        }&#xA;        func (s *S) close() error {&#xA;            errc := make(chan error)&#xA;            s.closing &amp;lt;- errc&#xA;            return &amp;lt;-errc&#xA;        }&#xA;        func (s *S) loop() {&#xA;            for {&#xA;                select {&#xA;                case errc := &amp;lt;-s.closing:&#xA;                    errc &amp;lt;- nil&#xA;                    return&#xA;                }&#xA;            }&#xA;        }&#xA;    pipeline(fan-in, fan-out)           # 传入传出channel来处理&#xA;        o-&amp;gt;&#xA;        func gen(done &amp;lt;-chan struct{}, nums ...int) &amp;lt;-chan int {&#xA;            out := make(chan int)&#xA;            go func() {&#xA;                defer close(out)&#xA;                for _, n := range nums {&#xA;                    select {&#xA;                    case out &amp;lt;- n:&#xA;                    case &amp;lt;-done:&#xA;                        return&#xA;                    }&#xA;                }&#xA;            }()&#xA;            return out&#xA;        }&#xA;        func sq(done &amp;lt;-chan struct{}, in &amp;lt;-chan int) &amp;lt;-chan int {&#xA;            out := make(chan int)&#xA;            go func() {&#xA;                defer close(out)&#xA;                for n := range in {&#xA;                    select {&#xA;                    case out &amp;lt;- n * n:&#xA;                    case &amp;lt;-done:&#xA;                        return&#xA;                    }&#xA;                }&#xA;            }()&#xA;            return out&#xA;        }&#xA;        func merge(done &amp;lt;-chan struct{}, cs ...&amp;lt;-chan int) &amp;lt;-chan int {&#xA;            # wg等cs数目个协程合并数据到out后，关闭out&#xA;            var wg sync.WaitGroup&#xA;            out := make(chan int)&#xA;&#xA;            output := func(c &amp;lt;-chan int) {&#xA;                for n := range c {&#xA;                    select {&#xA;                    case out &amp;lt;- n:&#xA;                    case &amp;lt;-done:&#xA;                    }&#xA;                }&#xA;                wg.Done()&#xA;            }&#xA;&#xA;            wg.Add(len(cs))&#xA;            for _, c := range cs {&#xA;                go output(c)&#xA;            }&#xA;&#xA;            go func() {&#xA;                wg.Wait()&#xA;                close(out)&#xA;            }()&#xA;            return out&#xA;        }&#xA;&#xA;        func main() {&#xA;            done := make(chan struct{})&#xA;            defer close(done)&#xA;&#xA;            for n := range sq(done, sq(done, gen(done, 2, 3))) {&#xA;                # gen产生维护数字chan, sq产生维护平方chan。三个chan&#xA;                # 三个goroutine done()时return, chan return时close()&#xA;                fmt.Println(n)&#xA;            }&#xA;&#xA;            // 扇出&#xA;            in := gen(done, 2, 3)&#xA;            c1 := sq(done, in)&#xA;            c2 := sq(done, in)&#xA;            // 扇进&#xA;            for n := range merge(done, c1, c2) {&#xA;                fmt.Println(n)&#xA;            }&#xA;        }&#xA;    timeout&#xA;        select {&#xA;        case &amp;lt;-ch:&#xA;            ...&#xA;        case &amp;lt;-time.After(time.Second)&#xA;            return&#xA;        }&#xA;    控制并发数&#xA;        并发写缓冲区channel&#xA;        for循环产生并发数goroutine&#xA;常用&#xA;    中断&#xA;        # os.Exit()程序返回错误码&#xA;&#xA;        done := make(chan struct{})&#xA;        go func() {&#xA;            defer close(done)&#xA;            c := make(chan os.Signal, 1)&#xA;            defer close(c)&#xA;            signal.Notify(c, os.Interrupt, os.Kill)&#xA;            defer signal.Stop(c)&#xA;            &amp;lt;-c&#xA;        }()&#xA;    并发压测&#xA;        func concurrent(done chan struct{}, fn func(), num int, ccu int, qps int) {     # num总数，ccu并行数，qps并发数&#xA;            interval := time.Duration(1e9/qps) * time.Nanosecond&#xA;            don := make(chan struct{}, 2)&#xA;            go func() {&#xA;                &amp;lt;-done&#xA;                for i := 0; i &amp;lt; ccu; i++ {&#xA;                    don &amp;lt;- struct{}{}&#xA;                }&#xA;            }()&#xA;&#xA;            //&#xA;            tasks := make(chan struct{})&#xA;            go func() {&#xA;                var wg sync.WaitGroup&#xA;                wg.Add(num)&#xA;                for i := 0; i &amp;lt; num; i++ {&#xA;                    tasks &amp;lt;- struct{}{}&#xA;                    wg.Done()&#xA;                    time.Sleep(interval)&#xA;                }&#xA;                wg.Wait()&#xA;                close(tasks)&#xA;            }()&#xA;&#xA;            //&#xA;            var wg sync.WaitGroup&#xA;            wg.Add(ccu)&#xA;            for i := 0; i &amp;lt; ccu; i++ {&#xA;                go func() {&#xA;                    defer wg.Done()&#xA;                    for range tasks {&#xA;                        select {&#xA;                        case &amp;lt;-don:&#xA;                            return&#xA;                        default:&#xA;                            fn()&#xA;                        }&#xA;                    }&#xA;                }()&#xA;            }&#xA;            wg.Wait()&#xA;        }&#xA;        m := sync.Mutex{}&#xA;        count := 0&#xA;        do := func(){&#xA;            m.Lock()&#xA;            count++&#xA;            m.Unlock()&#xA;        }&#xA;        concurrent(done, do, 999, 100, 1e3)&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Python</title>
      <link>https://ukeate.com/docs/pl/python/</link>
      <pubDate>Tue, 09 Oct 2018 16:05:05 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/python/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;虚拟机语言&#xA;虽然是脚本语言，可以预编译成pyc文件来执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;shell&#34;&gt;&#xA;  shell&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#shell&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;#! /usr/bin/python&#xA;# -*- coding: utf8 -*-&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;规范&#xA;    pep8&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;内置函数&#34;&gt;&#xA;  内置函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;&#xA;    input(&amp;quot;&amp;quot;)&#xA;        # x = int(input(&amp;quot;Please enter an integer:&amp;quot;))&#xA;    print(&amp;quot;%s&amp;quot;, % s1)&#xA;        ## %.3s % (&amp;quot;abcdef&amp;quot;)取3字符&#xA;        ## %.* s % (2, &amp;quot;abcd&amp;quot;)取2字符)&#xA;    # %r repr()显示字符串&#xA;        # %c 单个字符&#xA;        # %b 二进制整数&#xA;        # %x 十六进制整数&#xA;        # %d 十进制整数&#xA;        # %i 十进制整数&#xA;        # %o 八进制整数&#xA;        # %e %E 指数(基底分别为e E)&#xA;        # %-10.3f %-10.3F 浮点数&#xA;        ## 10位宽, 小数精确3位, 右对齐&#xA;        # %g %G 指数(e E)或浮点数(根据显示长度决定)&#xA;        # %% 字符%&#xA;        print(&amp;quot;c is %s, e is %i&amp;quot; % (c, e)&#xA;    str(1)&#xA;    int(&amp;quot;1&amp;quot;)&#xA;    range(1, 10)&#xA;        # range(-2, -11, -3)&#xA;    exec(&#39;&#39;)&#xA;        # 执行字符串中的代码&#xA;    execfile(r&#39;a.py&#39;)&#xA;    eval(&#39;2 * 3&#39;, globals, locals)&#xA;        # 执行字符串中的表达式&#xA;        # ast.literal_eval&#xA;    compile(str, filename, kind)&#xA;        # 编译字符串为模块&#xA;        # kind取值: single单语句, exec多语句, eval一个表达式&#xA;    assert 1 != 1&#xA;    repr(list)&#xA;        # 对象转换成代码字符串　&#xA;    map(str, range(100))&#xA;    filter()&#xA;    reduce()&#xA;    locals()&#xA;        # 当前作用域的变量字典&#xA;    isinstance(value, list)&#xA;    hasattr(obj, &#39;__call__&#39;)&#xA;        # 判断是否函数&#xA;    type(l)&#xA;        # 返回对象类型，或创建metaclass&#xA;    chr(48)&#xA;        # 返回字符&#xA;    unichr&#xA;    ord(&#39;0&#39;)&#xA;        # 返回ascii码&#xA;    bool()&#xA;    iter()&#xA;    next()&#xA;    zip(&#39;abc&#39;, &#39;123&#39;)&#xA;        list(zip())&#xA;o-&amp;gt; 文件&#xA;    spath = &amp;quot;D:/a.txt&amp;quot;&#xA;    f = open(spath, &amp;quot;w&amp;quot;)&#xA;        # 没有时创建&#xA;    f.write(&amp;quot;a\n&amp;quot;)&#xA;    f.writelines(&amp;quot;b&amp;quot;)&#xA;    f.close()&#xA;&#xA;    f = open(spath, &amp;quot;r&amp;quot;)&#xA;    for line in f:&#xA;        print(&amp;quot;%s&amp;quot; % line)&#xA;    f.readline()&#xA;    f.close()&#xA;o-&amp;gt; 文档&#xA;    dir(list)&#xA;    help(s.replace)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 基本类型&#xA;    数字&#xA;        1.2, 3+4j, Decimal, Fraction&#xA;    字符串&#xA;&#xA;&#xA;    列表&#xA;        [1, 2]&#xA;    字典&#xA;        {&#39;a&#39;:1}&#xA;    元组&#xA;        (1)&#xA;    文件&#xA;        open(&#39;eggs&#39;, &#39;r&#39;)&#xA;    集合&#xA;        {&#39;a&#39;}&#xA;    其他类型&#xA;        类型, None, False, True&#xA;    编程单元&#xA;        函数, 模块, 类&#xA;    实现相关类型&#xA;        编译代码堆栈跟踪&#xA;                &#xA;o-&amp;gt; 扩展属性&#xA;    dict = type(&#39;dict&#39;, (dict,), {})&#xA;    d = dict()&#xA;    d.a = 1&#xA;&#xA;o-&amp;gt; 序列&#xA;    [1,&#xA;    2]&#xA;    [1, [2]]&#xA;&#xA;    len(l)&#xA;    l[0]&#xA;    l[-1]&#xA;    l[1:3]&#xA;    l[1:]&#xA;    l[:3]&#xA;    l[:-1]&#xA;    l[:]&#xA;&#xA;    l + l&#xA;    l * 2&#xA;    del l[1:3]&#xA;    o-&amp;gt; 字符串&#xA;        # 不可变&#xA;        r&#39;a&#39; R&#39;a&#39; u&#39;a&#39; U&#39;a&#39; b&#39;a&#39; B&#39;a&#39;&#xA;        &#39;abc\&#xA;        def&#39;&#xA;        &#39;a&#39; &#39;b&#39;&#xA;        &#39;a&#39; &amp;quot;a&amp;quot; &#39;&#39;&#39;a&#39;&#39;&#39; &amp;quot;&amp;quot;&amp;quot;a&amp;quot;&amp;quot;&amp;quot;&#xA;&#xA;        s.startswith(&#39;a&#39;)&#xA;        s.find(&#39;a&#39;)&#xA;        s.replace(&#39;a&#39;, &#39;A&#39;)&#xA;        s.split(&#39;,&#39;)&#xA;        s.join(list)&#xA;        s.upper()&#xA;        s.isalpha()&#xA;        s.isdigit()&#xA;        s.rstrip()&#xA;                # 去右侧空白&#xA;        &#39;%s, %s&#39; % (&#39;a&#39;, &#39;b&#39;)&#xA;        &#39;{0},{1}&#39;.format(&#39;a&#39;, &#39;b&#39;)&#xA;&#xA;        if &#39;a&#39; in name:&#xA;    o-&amp;gt; 列表&#xA;        l.append(&#39;h&#39;)&#xA;        l.pop(2)&#xA;            # 弹出特定位置&#xA;        l.sort()&#xA;        l.reverse()&#xA;&#xA;        print(l)&#xA;&#xA;        for x in word:&#xA;&#xA;        [2 * i for i in [2,3,4] if i &amp;gt; 2]&#xA;            # 列表解析&#xA;            [row[1] + 1 for row in M]&#xA;            [M[i][i] for i in [0, 1, 2]]&#xA;            {ord(x) for x in &#39;spaam&#39;}&#xA;                # 创建集合&#xA;            {x: ord(x) for x in &#39;spaam&#39;}&#xA;                # 创建字典&#xA;    o-&amp;gt; 元组&#xA;        # 不可变&#xA;        (&#39;a&#39;, &#39;b&#39;)&#xA;        (1,) + (2,)&#xA;            # (1, 2)&#xA;        t.index(&#39;c&#39;)&#xA;        t.count(&#39;c&#39;)&#xA;    o-&amp;gt; set&#xA;        s = set(&#39;a&#39;)&#xA;        set([1])&#xA;        s.add(2)&#xA;&#xA;        s1, s2&#xA;        s1 &amp;amp; s2&#xA;        s1 | s2&#xA;        s1 - s2&#xA;        {x ** 2 for x in [1,2,3,4]}&#xA;            # 返回set&#xA;&#xA;o-&amp;gt; 字典&#xA;    d = {&#39;a&#39;: &#39;aaa&#39;, &#39;b&#39;: &#39;bbb&#39;, &#39;c&#39;: 12}&#xA;    d[&#39;d&#39;] = 3&#xA;&#xA;    d.items()&#xA;        # key value&#xA;    d.keys()&#xA;        list(d.keys())&#xA;&#xA;    len(d)&#xA;    del d[&#39;a&#39;]&#xA;    d.get(&#39;a&#39;, 0)&#xA;    d[&#39;a&#39;]&#xA;&#xA;    for key in d:&#xA;    if &#39;a&#39; in d:&#xA;    d[&#39;a&#39;] if &#39;a&#39; in d else 0&#xA;o-&amp;gt; 文件&#xA;    f = open(&#39;data.txt&#39;, &#39;w&#39;)&#xA;    f.write(&#39;a&#39;)&#xA;    f.close()&#xA;&#xA;    text = f.read()&#xA;        text.split()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;语句&#34;&gt;&#xA;  语句&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 语句&#xA;    在物理行中用分号划分逻辑行&#xA;    pass&#xA;o-&amp;gt; 运算符&#xA;    + - * / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= == !=&#xA;    &amp;amp; | ^ ~&#xA;        # 按位与 或 异或 翻转(x 变为 -(x + 1))&#xA;    not and or&#xA;    **&#xA;        # 幂&#xA;    //&#xA;        # 取整除&#xA;    code if None else 0&#xA;    True and 1 or 0&#xA;o-&amp;gt; 条件&#xA;    if x &amp;lt; 0:&#xA;            x = 0&#xA;    elif x == 0:&#xA;    else:&#xA;o-&amp;gt; 循环&#xA;    for x in a:&#xA;    else:&#xA;&#xA;    while running:&#xA;    else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;函数&#xA;    def sum(a, b=2, *args, **kwargs):&#xA;            # *args得到元组, kwargs得到字典&#xA;            &#39;&#39;&#39; doc&#xA;        string&#39;&#39;&#39;&#xA;&#xA;        global x&#xA;        nonlocal y&#xA;        return a + b&#xA;    sum(a=1)&#xA;    sum.__doc__&#xA;&#xA;    def make_repeater(n):&#xA;        return lambda s: s * n&#xA;            # lambda只能跟表达式，返回一个函数&#xA;生成器&#xA;    def gn2():&#xA;        yield&#xA;    def gn(N):&#xA;        for i in range(N):&#xA;            yield i ** 2&#xA;        yield from gn2()&#xA;            # 相当于静态引入gn2&#xA;    g = gn()&#xA;    next(g)&#xA;    g.send(1)&#xA;asyncio模块&#xA;    @asyncio.coroutine&#xA;    def f():&#xA;        yield from asyncio.sleep(1)&#xA;    loop = asyncio.get_event_loop()&#xA;    tasks = [asyncio.async(f())]&#xA;    loop.run_until_complete(asyncio.wait(tasks))&#xA;    loop.close()&#xA;协程&#xA;    @types.coroutine&#xA;    def f2():&#xA;        yield&#xA;&#xA;    async def f():&#xA;        print(1)&#xA;        await f2()&#xA;                # 协程显式交替，线程不用写，会隐式交替&#xA;&#xA;    try:&#xA;        f().send(None)&#xA;    except StopIteration:&#xA;        pass&#xA;协程asyncio&#xA;    async f():&#xA;        await asyncio.sleep(1)&#xA;    loop = asyncio.get_event_loop()&#xA;    tasks = [asyncio.ensure_future(f())]&#xA;    loop.run_until_complete(asyncio.wait(tasks))&#xA;    loop.close()&#xA;协程属性&#xA;    gi_frame&#xA;        f_code&#xA;            co_filename&#xA;        f_lineno&#xA;属性&#xA;    __name__&#xA;    __code__&#xA;    __annotations__&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;oop&#34;&gt;&#xA;  oop&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#oop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Base:&#xA;    __metaclass__ = models.SubfieldBase&#xA;        # __metaclass__实例化结果是类，用于继承&#xA;    description = &#39;&#39;&#xA;    def __init__(self, name):&#xA;        # self就是this&#xA;        #  __del__(self)&#xA;        # __str__(self)&#xA;        # __lt__(self)&#xA;        # __getitem__(self, key)&#xA;        ## x[key]索引时调用&#xA;        # __len__(self)&#xA;        super(Base, self).__init__(*args, **kwargs)&#xA;        self.data = []&#xA;&#xA;    def add(self, x)&#xA;        self.data.append(x)&#xA;    @classmethod&#xA;    def t1(cls):&#xA;    @staticmethod&#xA;    def t2():&#xA;class Child(Base):&#xA;    # 继承&#xA;    def plus(self, a, b):&#xA;        return a + b&#xA;oChild = Child()&#xA;oChild.add(&amp;quot;str1&amp;quot;)&#xA;oChild.data&#xA;oChild.plus(2, 3)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模块&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;# .pyc是字节编译文件&#xA;# __name__ 等于&#39;__main__&#39;时程序本身使用运行, 否则是引用&#xA;&#xA;# a.py&#xA;def add_func(a, b):&#xA;        return a + b&#xA;# b.py&#xA;from a import add_func&#xA;    # import add_func as f&#xA;    # from a import *&#xA;&#xA;# __init__.py&#xA;    # 表示文件夹为包, 可空&#xA;&#xA;包路径&#xA;    # 环境变量PYTHONPATH中的值&#xA;    import sys&#xA;    import os&#xA;&#xA;    sys.path&#xA;    sys.path.append(os.getcwd() + &amp;quot;\\parent\\child&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;异常&#34;&gt;&#xA;  异常&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e5%b8%b8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;if s == &amp;quot;&amp;quot;:&#xA;    raise Exception(&amp;quot;must not be empty.&amp;quot;)&#xA;try:&#xA;    i = int(s)&#xA;except Exception as err:&#xA;    # except Exception, err&#xA;    print(&#39;Error %d: %s&#39; % (e.args[0], e.args[1]))&#xA;except:&#xA;finally:&#xA;    print(&amp;quot;Goodbye.&amp;quot;)&#xA;else:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;模块-1&#34;&gt;&#xA;  模块&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;os&#xA;sys&#xA;    argv&#xA;        # 参数列表, 多维列表&#xA;    exit()&#xA;        # 退出线程&#xA;imp&#xA;    reload&#xA;        # 重载模块&#xA;time&#xA;timeit&#xA;profile&#xA;decimal&#xA;fractions&#xA;urllib&#xA;http&#xA;    http.server&#xA;        # python3中的SimpleHTTPServer&#xA;re&#xA;functools&#xA;itertools&#xA;SimpleHTTPServer&#xA;    # python2自带ftp服务器。&#xA;    pythom -m SimpleHTTPServer 8080&#xA;&#xA;&#xA;PyQt&#xA;    # gui&#xA;PyGTK&#xA;    # gui&#xA;wxPython&#xA;    # gui&#xA;TkInter&#xA;    # gui&#xA;matplotlib&#xA;    # 图形&#xA;pillow&#xA;    # ocr, 文字识别&#xA;pytesseract&#xA;    # ocr, 精确&#xA;&#xA;&#xA;numpy&#xA;math&#xA;random&#xA;scipy&#xA;    # 科学计算&#xA;&#xA;beautifulsoup&#xA;    # 网页结构化&#xA;scrapy&#xA;    # 网页结构化&#xA;requests&#xA;phantomJS&#xA;    # 运行网页js&#xA;selenium&#xA;    # 运行网页js&#xA;&#xA;&#xA;pandas&#xA;    # 数据分析，产生数据结构、操作、统计、绘图&#xA;seaborn&#xA;    # 数据可视化&#xA;scikit-learn&#xA;    # 机器学习&#xA;nltk&#xA;    # 自然语言分析&#xA;&#xA;&#xA;mysql-connector&#xA;mysqlclient&#xA;PyMySQL&#xA;MySQLdb&#xA;redis.py&#xA;south&#xA;    # 表结构迁移, django自带&#xA;&#xA;pickle&#xA;    # 持久化&#xA;qrcode&#xA;    # 二维码&#xA;&#xA;&#xA;ast&#xA;    # 运算前检查的eval()&#xA;datetime&#xA;shutil&#xA;    # shell&#xA;&#xA;&#xA;fabric&#xA;    # 运程自动部署&#xA;celery&#xA;    # 定时调度&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;ipython notebook&#xA;    # 在线运行python&#xA;bpython&#xA;    # 更好的repl&#xA;pdb&#xA;    # 调试&#xA;cprofile&#xA;    # 性能测试&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;steuptools&#34;&gt;&#xA;  steuptools&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#steuptools&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;easy_install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pip&#34;&gt;&#xA;  pip&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pip&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pip install -i http://pypi.douban.com/simple/ torndb&#xA;    # 用豆辨的pypi索引&#xA;pip install ipython==4.2.0&#xA;    # 安装指定版本&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pyenv&#34;&gt;&#xA;  pyenv&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#pyenv&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;pyenv versions&#xA;pyenv install 3.7.6&#xA;    --list&#xA;pyenv virtualenv 3.7.6 37&#xA;eval &amp;quot;$(pyenv init -)&amp;quot;&#xA;eval &amp;quot;$(pyenv virtualenv-init -)&amp;quot;&#xA;pyenv activate 37&#xA;pyenv deactivate&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;conda&#34;&gt;&#xA;  conda&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#conda&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;环境相关&#xA;    conda env&#xA;        create -f e.yml     # 创建环境&#xA;            -n name1    &#xA;        list                # 列出所有环境&#xA;        remove -n name1     # 删除环境&#xA;    conda activate e1&#xA;    conda init bash&#xA;包相关&#xA;    conda list              # 当前环境所有软件包&#xA;    conda search pillow     # 列出包所有版本&#xA;    conda install pillow=7.0.0&#xA;        -c                  # 指定channel，相当于命名空间&#xA;    conda uninstall pillow&#xA;    conda upgrade numpy&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;容器&#34;&gt;&#xA;  容器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;gunicorn&#xA;    # python实现&#xA;    sudo pip install gunicorn&#xA;    gunicorn -w4 -b0.0.0.0:8001 app.wsgi&#xA;uwsgi&#xA;    # c语言实现&#xA;    sudo pip install uwsgi&#xA;    uwsgi --http :8001 --chdir /path/to/project --home=/path/to/env --module project.wsgi&#xA;            # --home指定virtualenv的路径&#xA;nginx&#xA;shell&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Clojure</title>
      <link>https://ukeate.com/docs/pl/clojure/</link>
      <pubDate>Tue, 09 Oct 2018 16:00:21 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/clojure/</guid>
      <description>&lt;h1 id=&#34;介绍&#34;&gt;&#xA;  介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    是jvm上的一个lisp语言变种，比lisp更强调纯函数式编程&#xA;    操作符知道自己的特征值(identity value), 如+是0, *是1&#xA;    数组是懒惰的，需要时求值。适用于任意层的嵌套。头元素在使用后舍弃&#xA;    集合(vector, map, set)都是持久的，使用共享结构，与ruby, java中非持久结构有相似的性能&#xA;            # 持久的数据结构中，其它线程对数据的修改对该线程是不可见的&#xA;    没有尾递归优化，不常用递归，要用loop.recur&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;    s-expressions&#xA;            (max 3 5)&#xA;            (+ 1 (* 2 3))&#xA;            (def meaning-of-life 42)&#xA;            (if (&amp;lt; meaning-of-life 0) &amp;quot;negative&amp;quot; &amp;quot;non-negative&amp;quot;)&#xA;    (def droids [&amp;quot;Huey&amp;quot; &amp;quot;Dewey&amp;quot; &amp;quot;Louie&amp;quot;])&#xA;            (count droids)&#xA;            (droids 0)&#xA;    (def me {:name &amp;quot;Paul&amp;quot; :age 45 :sex :male})&#xA;            (:age me)&#xA;    (defn percentage [x p] (* x (/ p 100.0)))&#xA;            (percentage 200 10)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;并发&#34;&gt;&#xA;  并发&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 原子变量&#xA;        # 对一个值进行同步更新&#xA;(def my-atom (atom 42))&#xA;(deref my-atom)&#xA;@my-atom&#xA;(swap! my-atom inc)&#xA;(swap! my-atom + 2)&#xA;(reset! my-atom 0)&#xA;&#xA;(def session (atom {}))&#xA;(swap! session assoc :username &amp;quot;paul&amp;quot;)&#xA;&#xA;(if (compare-and-set! a old new)&#xA;        # 判断原子变量a的值是否是old, 是时赋成new并返回true&#xA;new&#xA;(recur))&#xA;&#xA;o-&amp;gt; conj 添加新成员&#xA;(def players (atom ()))&#xA;(defn list-players []&#xA;(response (json/encode @players)))&#xA;(defn create-player [player-name]&#xA;(swap! players conj player-name)&#xA;(status (response &amp;quot;&amp;quot;) 201))&#xA;(defroutes app-routes&#xA;(GET &amp;quot;/players&amp;quot; [] (list-players))&#xA;(PUT &amp;quot;/players/:player-name&amp;quot; [player-name] (create-player player-name)))&#xA;(defn -main [&amp;amp; args]&#xA;(run-jetty (site app-routes) {:port 3000}))&#xA;&#xA;o-&amp;gt; cons列表首添加元素&#xA;(def listv2 (cons 4 listv1))&#xA;&#xA;o-&amp;gt; validator&#xA;        # 值改变之前调用&#xA;(def non-negative (atom 0 :validator #(&amp;gt;= % 0)))&#xA;(reset! non-negative -1)&#xA;&#xA;o-&amp;gt; 监视器&#xA;        # 值改变之后调用　&#xA;(def a (atom 0))&#xA;(add-watch a :print #(println &amp;quot;Changed from &amp;quot; %3 &amp;quot; to &amp;quot; %4))&#xA;(swap! a + 2)&#xA;        # !的命名表示函数是事务不安全的&#xA;&#xA;o-&amp;gt; 代理&#xA;        # 对一个值进行异步更新。&#xA;        # 代理维护的数据与事务数据相同。代理具有事务性，send会在事务成功后生效&#xA;        # 方便做内存并发日志系统&#xA;(def my-agent (agent 0))&#xA;@my-agent&#xA;(send my-agent inc)&#xA;        # send在值更新之前立即返回，不进行重试。多线程同时调用send, 调用被串行。具有副作用&#xA;        # send使用公用线程池，send-off使用一个新线程，send-via使用由参数指定的executor&#xA;(send my-agent #((Thread/sleep 2000) (inc %)))&#xA;        # 设置延迟时间&#xA;(await my-agent)&#xA;        # 等待代理执行完成后再继续。await-for函数可以设置超时时间&#xA;&#xA;(def non-negative (agent 1 :validator (fn [new-val] (&amp;gt;= new-val 0))))&#xA;        # 代理可以使用校验器和监视器&#xA;        # 校验器失败时抛出异常，代理进入失效状态&#xA;        # 错误处理模式默认为 :fail, 可以置为:continue&#xA;        # 可以设置错误处理函数&#xA;(agent-error non-negative)&#xA;        # 查看代理是否在失效状态&#xA;(restart-agent non-negative 0)&#xA;        # 重置失效状态&#xA;&#xA;o-&amp;gt; 引用&#xA;        # 只有在事务中才能修改引用的值，对多个值进行同步更新&#xA;(def my-ref (ref 0))&#xA;@my-ref&#xA;&#xA;(dosync (ref-set my-ref 42))&#xA;        # dosync创建一个事务，事务同swap!一样，用重试机制实现&#xA;        # clojure的事务有原子性，一致性，隔离性，没有持久性&#xA;(dosync (alter my-ref inc))&#xA;        # commute替换alter，可以得到不很强的隔离性，用于做优化&#xA;(defn transfer [from to amount]&#xA;(dosync &#xA;    (alter from - amount)&#xA;    (alter to + amount)))&#xA;&#xA;o-&amp;gt; threed&#xA;(defn stress-thread [from to iterations amount]&#xA;(Thread. #(dotimes [_ iterations] (transfer from to amount))))&#xA;(let [t1 (stress-thread checking savings 100 100)&#xA;    t2 (stress-thread savings checking 200 100)]&#xA;(.start t1)&#xA;(.start t2)&#xA;(.join t1)&#xA;(.join t2))&#xA;&#xA;o-&amp;gt; ensure确保当前返回的值不被其它事务修改&#xA;(when (and (= (ensure left) :thinking) (= (ensure right) :thinking))&#xA;(ref-set philosopher :eating))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;csp&#34;&gt;&#xA;  csp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#csp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;        core.async提供了channel和go块&#xA;        引入的core.async中部分函数名与clojure核心库函数名冲突&#xA;&#xA;o-&amp;gt; channel&#xA;(def c (chan))&#xA;(thread (println &amp;quot;Read:&amp;quot; (&amp;lt;!! c) &amp;quot;from c&amp;quot;))&#xA;        # thread是core.async提供的辅助宏，将其中代码运行在一个单独的线程上&#xA;(&amp;gt;!! c &amp;quot;Hello thread&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;用例&#34;&gt;&#xA;  用例&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%a8%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt;求和&#xA;(defn recursive-sum &#xA;&amp;quot;&amp;quot;&#xA;        # 文档字符串&#xA;        ## (require &#39;[philosophers.util :refer :all])&#xA;        ## (clojure.repl/doc swap-when!) 来查看文档字符串&#xA;[numbers &amp;amp; args])&#xA;        # &amp;amp;表示可变参数&#xA;        ## (apply f old args) 将args展开，作为附加参数传递给f&#xA;(if (empty? numbers)&#xA;    0&#xA;    (+ (first numbers) (recursive-sum (rest numbers))))&#xA;&#xA;(defn reduce-sum [numbers]&#xA;(reduce (fn [acc x] (+ acc x)) 0 numbers))&#xA;&#xA;(defn sum [numbers]&#xA;(reduce + numbers))&#xA;&#xA;o-&amp;gt;并行&#xA;(ns sum.core&#xA;(:require [clojure.core.reducers :as r]))&#xA;&#xA;(defn parallel-sum [numbers]&#xA;(r/fold + numbers))&#xA;&#xA;(def numbers (into [] (range 0 10000)))&#xA;(time (sum numbers))&#xA;(time (sum numbers))&#xA;        # 预热jim编译器&#xA;(time (parallel-sum numbers))&#xA;&#xA;o-&amp;gt; map&#xA;(def counts {&amp;quot;apple&amp;quot; 2 &amp;quot;orange&amp;quot; 1})&#xA;        (get counts &amp;quot;apple&amp;quot; 0)&#xA;        (get counts &amp;quot;banana&amp;quot; 0)&#xA;                # 没有时返回设定的默认值0&#xA;        (assoc counts &amp;quot;banana&amp;quot; 1)&#xA;        (assoc counts &amp;quot;apple&amp;quot; 3)&#xA;&#xA;o-&amp;gt; frequencies&#xA;(defn word-frequencies [words]&#xA;(reduce&#xA;(fn [counts word] (assoc counts word (inc (get counts word 0))))&#xA;{} words))&#xA;&#xA;(frequencies [&amp;quot;one&amp;quot; &amp;quot;potato&amp;quot;])&#xA;        # 标准库中已提供&#xA;&#xA;o-&amp;gt; partial函数&#xA;        # 返回一个被局部代入的函数&#xA;(def multiply-by-2 (partial * 2))&#xA;(multiply-by-2 3)&#xA;&#xA;o-&amp;gt; 序列&#xA;(defn get-words [text] (re-seq #&amp;quot;\w+&amp;quot; text))&#xA;(get-words &amp;quot;one tow three four&amp;quot;)&#xA;(map get-words [&amp;quot;one two three&amp;quot; &amp;quot;four five six&amp;quot;])&#xA;(mapcat get-words [&amp;quot;one two three&amp;quot; &amp;quot;four five six&amp;quot;])&#xA;        # 平辅数组&#xA;&#xA;o-&amp;gt; iterate&#xA;        # 不断将函数应用到初始值，第一次返回值，第二次返回值&#xA;(take 10 (iterate inc 0))&#xA;(take 10 (iterate (partial + 2) 0))&#xA;(take-last 5 (range 0 10000))&#xA;        # 头元素使用后舍弃，耗相同的内存&#xA;&#xA;o-&amp;gt; pmap&#xA;(pmap #(frequencies (get-words %)) pages)&#xA;        # pmap在需要结果时并行计算，仅生成需要的结果，称为半懒惰(semi-lazy)&#xA;        # #(...)是读取器宏，来快速创建匿名函数，参数通过%1, %2标识, 只有一个参数时可以是%&#xA;        ## (fn [page] (frequencies (get-words page)))与其等价&#xA;&#xA;o-&amp;gt; merge-with&#xA;        # 标准库函数&#xA;(merge-with f &amp;amp; maps)&#xA;        # 将maps中其余map合并到第一个map中，返回合并后的map&#xA;        ## 同键名时，多个值从左向右地合并，调用传递的f(val-in-result val-in-latter)&#xA;(def merge-counts (partial merge-with +))&#xA;(merge-counts {:x 1 :y 2} {:y 1 :z 1})&#xA;&#xA;o-&amp;gt; partition-all&#xA;        # 序列分批&#xA;(partition-all 4 [1 2 3 4 5 6 7 8 9 10])&#xA;        # ((1 2 3 4) (5 6 7 8) (9 10))&#xA;&#xA;o-&amp;gt; reducers包&#xA;        # 化简器，不代表函数的结果，代表如何产生结果的描述&#xA;        ## 嵌套的函数返回化简器，比返回懒惰序列效率更高&#xA;        ## 可以对整个嵌套链的集合操作，可以用fold进行并行化&#xA;        # clojure.core中大部分函数都有其对应的化简器版本&#xA;(require &#39;[clojure.core.reducers :as r]&#39;)&#xA;(r/map (partial * 2) [1 2 3 4])&#xA;        # 返回一个化简器(reducible)&#xA;(reduce conj [] reducible)&#xA;        # conj函数第一个参数为一个集合(初始值为[]), 将第二个参数合并到第一个参数中&#xA;(into [] reducible)&#xA;        # into函数为内置函数，同上&#xA;&#xA;o-&amp;gt;协议(类似java中的接口)来定义&#xA;(defprotocol CollReduce&#xA;        # 化简&#xA;(coll-reduce [coll f] [coll f init]))&#xA;        # coll相当于this, 支持多态性分派(polymorphic dispatch)&#xA;(coll-reduce coll f)&#xA;&#xA;(defn my-reduce&#xA;([f coll] (coll-reduce coll f))&#xA;([f init coll] (coll-reduce coll f init)))&#xA;(my-reduce + [1 2 3 4])&#xA;(my-reduce + 10 [1 2 3 4])&#xA;&#xA;(defn make-reducer [reducible transforms]&#xA;(reify&#xA;    CollReduce&#xA;    (coll-reduce [_ f1]&#xA;    (coll-reduce reducible (transformf f1) (f1)))&#xA;    (coll-reduce [_ f1 init]&#xA;    (coll-reduce reducible (transformf f1) init))))&#xA;        # 用reify实现一个协议&#xA;        # 调用reducible的coll-reduce方法。用transformf对f1进行转换，转换出的函数作为传给coll-reduce方法的一个参数&#xA;        # _表示未被使用的函数参数名，可以写成(coll-reduce [this f1])&#xA;&#xA;(defn my-map [mapf reducible]&#xA;(make-reducer reducible&#xA;    (fn [reducef]&#xA;    (fn [acc v]&#xA;        (reducef acc (mapf v))))))&#xA;        # acc是之前化简结果, v是集合元素。mapf对v进行转换&#xA;&#xA;o-&amp;gt; fold折叠&#xA;        # 不能适用于懒惰序列&#xA;(defprotocol CollFold&#xA;(coll-fold [coll n combinef reducef]))&#xA;&#xA;(defn my-fold&#xA;([reducef coll]&#xA;    (my-fold reducef reducef coll))&#xA;([combinef reducef coll]&#xA;    (my-fold 512 combinef reducef coll))&#xA;([n combinef reducef coll]&#xA;    (coll-fold coll n combinef reducef)))&#xA;&#xA;(defn make-reducer [reducible transformf]&#xA;(reify&#xA;    CollFold&#xA;    (coll-fold [_ n combinef reducef]&#xA;    (coll-fold reducible n combinef (transformf reducef)))&#xA;&#xA;    (CollReduce&#xA;    (coll-reduce [_ f1]&#xA;        (coll-reduce reducible (transformf f1) (f1)))&#xA;    (coll-reduce [_ f1 init]&#xA;        (coll-reduce reducible (transformf f1) init))))&#xA;&#xA;(def numbers (into [] (take 10000000 (repeatedly #(rand-int 10)))))&#xA;(require [&#39;reducers.parallel-frequencies :refer :all&#39;])&#xA;(time (frequencies numbers))&#xA;(time (parallel-frequencies numbers))&#xA;&#xA;o-&amp;gt; doall强迫懒惰序列对全部元素求值&#xA;(reduce + (doall (map (partial * 2) (range 10000))))&#xA;&#xA;o-&amp;gt; future&#xA;        # 单独线程中执行一段代码&#xA;        # 典型场景是异步通信&#xA;(def sum (future (+ 1 2 3 4 5)))&#xA;sum&#xA;        # 返回一个future对象&#xA;(deref sum)&#xA;@sum&#xA;        # 运行&#xA;(let [a (future (+ 1 2))&#xA;    b (future (+ 3 4))]&#xA;(+ @a @b))&#xA;        # let给a赋值，阻塞当前线程直到被求值&#xA;        # 外层加法将一直阻塞，直到所有代表的值被求值&#xA;&#xA;o-&amp;gt; promise&#xA;        # 创建promise对象后，代码并不会像future一样立即执行，等待deliver赋值后执行&#xA;(def meaning-of-life (promise))&#xA;(future (println &amp;quot;The meaning of life is:&amp;quot; @meaning-of-life))&#xA;(deliver meaning-of-life 42)&#xA;&#xA;o-&amp;gt; Compojure库的服务器&#xA;(def snippets (repeatedly promise))&#xA;(defn accept-snippet [n test]&#xA;(deliver (nth snippets n) test))&#xA;(future&#xA;(doseq [snippet (map deref snippets)]&#xA;    (println snippet)))&#xA;&#xA;(defroutes app-routes&#xA;(PUT &amp;quot;/snippet/:n&amp;quot; [n :as {:keys [body]}]&#xA;    (accept-snippet (edn/read-string n) (slurp body))&#xA;    (response &amp;quot;OK&amp;quot;)))&#xA;(defn -main [&amp;amp; args]&#xA;(run-jetty (site app-routes) {:port 3000}))&#xA;&#xA;o-&amp;gt; re-seq正则&#xA;(defn sentence-split [text]&#xA;(map trim (re-seq #&amp;quot;[^\.!\?:;]+[\.!\?:;]*&amp;quot; text)))&#xA;        # trim是内置函数&#xA;(defn is-sentence? [text]&#xA;(re-matches #&amp;quot;^.*[\.!\?:;]$&amp;quot; text))&#xA;&#xA;o-&amp;gt; reductions&#xA;        # 同reduce, 返回中间值构成的序列&#xA;(reductions + [1 2 3 4])&#xA;        # (1 3 6 10)&#xA;&#xA;o-&amp;gt; clj-http库&#xA;(def translator &amp;quot;http://localhost:3001/translate&amp;quot;)&#xA;(defn translate [text]&#xA;(future&#xA;    (:body (client/post translator {:body text}))))&#xA;&#xA;o-&amp;gt; delay在解引用前不求值&#xA;(def translations&#xA;(delay&#xA;    (map translate (strings-&amp;gt;sentences (map deref snippets)))))&#xA;&#xA;o-&amp;gt; 系统时间&#xA;(defn now []&#xA;(System/currentTimeMillis))&#xA;&#xA;o-&amp;gt; Schejulure库&#xA;(def session-sweeper&#xA;(schedule {:min (range 0 60 5)} sweep-sessions))&#xA;        # 定期调用&#xA;&#xA;o-&amp;gt; Useful库&#xA;(defn expired? [session]&#xA;(&amp;lt; @(:last-referenced session) (session-expiry-time)))&#xA;(defn sweep-sessions []&#xA;(swap! sessions #(remove-vals % expired?)))&#xA;        # 删除元素&#xA;&#xA;o-&amp;gt; Loop/Recur&#xA;(defn swap-when! [a pred f &amp;amp; args]&#xA;(loop []&#xA;    (let [old @a]&#xA;    (if (pred old)&#xA;        (let [new (apply f old args)]&#xA;        (if (compare-and-set! a old new)&#xA;            new&#xA;            (recur)))&#xA;        nil))))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;工具&#34;&gt;&#xA;  工具&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e5%85%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;clojureScript&#xA;        # 编译到js&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>JS</title>
      <link>https://ukeate.com/docs/pl/js/</link>
      <pubDate>Tue, 09 Oct 2018 10:31:30 +0800</pubDate>
      <guid>https://ukeate.com/docs/pl/js/</guid>
      <description>&lt;h1 id=&#34;基础&#34;&gt;&#xA;  基础&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;特性&#xA;    原型链, 面向对象, 动态语言(已超出脚本语言的范畴)&#xA;    弱类型，变量都是var&#xA;    解释器有自己的内存管理机制(garbage collection)&#xA;    自由数据类型转换                        # 产生了==, ===的判断相等的不同定义&#xA;v8引擎&#xA;    直接生成机器码&#xA;    分代式GC&#xA;    java jvm工程师参数了优化&#xA;历史&#xA;    Netscape(现Mozilla)创建JavaScript, 但JavaScript是Sun(现Oracle)的注册商标&#xA;    作为标准提交给ECMA(欧洲计算机制造协会), 改名为ECMAScript&#xA;        ECMAScript 3(ES3) 作为标准广泛使用&#xA;        ECMAScript 5(ES5) 定义了新的语言标准&#xA;        JavaScript1.5是Mozilla的版本号, 相当于ES3,包含一些非标准语言扩展&#xA;            JavaScript1.8 在实现es7&#xA;        JavaScript解释器或引擎(engine)也有版本号&#xA;            Google的叫做V8(现在是4.0)&#xA;    微软改动并取名Jscript&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;标准&#34;&gt;&#xA;  标准&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%87%e5%87%86&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;ecmascript-6&#34;&gt;&#xA;  ECMAScript 6&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ecmascript-6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    目标是js可写&#xA;        复杂的应用程序&#xA;        函数库&#xA;        代码自动自成器(code generator)&#xA;    mozilla基于ECMAScript6 发布 JavaScript2.0&#xA;    V8, node.js使用&#xA;&#xA;let                                 # 块级作用域中声明变量&#xA;const                               # 声明常量&#xA;Set对象                              # 同java Set, 是一个数组&#xA;    属性&#xA;        size&#xA;    方法&#xA;        add(value)&#xA;        delete(value)&#xA;        has(value)&#xA;        clear()&#xA;Map对象                              # 键值对，键可以是对象&#xA;    使用&#xA;        var m = new Map();&#xA;        o = {p: &amp;quot;Helllo&amp;quot;};&#xA;        m.set(o, &amp;quot;content&amp;quot;);&#xA;        m.get(o);&#xA;    属性&#xA;        size&#xA;    方法&#xA;        set(key, value)&#xA;        get(key)&#xA;        has(key)&#xA;        delete(key)&#xA;        clear()&#xA;... (rest运算符)&#xA;yield关键字&#xA;class关键字&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;commonjs&#34;&gt;&#xA;  commonJS&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#commonjs&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    模块化标准&#xA;    require同步加载, 再执行代码，会阻塞。对服务器不是问题，对浏览器是大问题&#xA;    输出的是值的拷贝&#xA;    require后的模块运行后缓存, 可手动清除缓存&#xA;commonJs规范下的javascript&#xA;    node.js&#xA;    mongoDB&#xA;    ringojs&#xA;使用&#xA;    var math = require(&#39;math&#39;);&#xA;    math.add(2, 3);&#xA;    let {stat, exists, readFile} = require(&#39;fs&#39;)&#xA;        # 加载fs所有方法生成_fs, 再取其中3个方法。没法做静态优化&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;amd&#34;&gt;&#xA;  AMD&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#amd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    模块化标准&#xA;    异步加载, 预执行&#xA;使用&#xA;    require([&#39;math&#39;], functioni (math){&#xA;        math.add(2, 3);&#xA;    });&#xA;        # 加载成功后进行回调&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;cmd&#34;&gt;&#xA;  CMD&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cmd&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    sea.js提出&#xA;    懒执行&#xA;使用&#xA;    define(function(require, exports, module){ ... })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;词法&#34;&gt;&#xA;  词法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%8d%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;unicode编写的&#xA;    转义&#xA;        &#39;café&#39;表示为&#39;caf\u00e9&#39;&#xA;        &#39;é&#39; 也可以表示为&#39;e\u0301&#39;, e后面跟一个语调符&#xA;区分大小写                                   # html中不区分大小写&#xA;注释&#xA;    //, /**/&#xA;标识符和保留字&#xA;    要求&#xA;        开头以字母、下划线、dollar符。&#xA;        后续可以加数字&#xA;        可以出现unicode字符集中的Mn类、Mc类、Pc类，如           # Mn表示非间距字符，Mc表示影响基字符标志位的间距字符, Pc是连接两个字符的连接符或标点符号。&#xA;            é, π,&#xA;    保留字&#xA;        break, delete, function, return, typeof, case, do, if, switch, var, catch, else, in, this, void, continue, false, instanceof, throw, while, debugger, finally, new, true, with, default, for, null, try&#xA;    未被使用的名保留字&#xA;        class, const, enum, export, extends, import, super&#xA;    严格模式下的保留字&#xA;        implements, let, private, public, yield, interface, package, protected, static&#xA;    严格模式下不能用做变量名&#xA;        arguments, eval&#xA;    es6新增保留字&#xA;        await&#xA;    ECMAScript3将所有java关键字列为保留字&#xA;    全局属性和对象和函数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;直接量&#34;&gt;&#xA;  直接量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b4%e6%8e%a5%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;直接量(numeric literal)&#xA;    1&#xA;    1.2&#xA;    &amp;quot;hi&amp;quot;&#xA;    &#39;hi&#39;&#xA;    true&#xA;    false&#xA;    /javascript/gi&#xA;        # 用于模式匹配&#xA;        ## 实际是一个RegExp对象&#xA;        ## gi是用来修饰匹配模式的含义&#xA;    null&#xA;    {x:1, y:2}&#xA;        {foo}                                   # 等同 {foo: foo}, 简化写法常用于函数返回值&#xA;        {method () {}}                          # 等同 {method: function () {}}&#xA;        {*m () {}}                              # generator&#xA;        {[&#39;a&#39; + &#39;b&#39;]: 1}                        # object&#xA;        {[&#39;hello&#39;](){reutrn 0;}}                # 对象属性是Symbol值时, name属性返回这个Symbol值的描述&#xA;        {get a () {}, set a (val) {}}           # 属性getter, setter。get, set函数的函数名name是 &#39;get xxx&#39;, &#39;set xxx&#39;&#xA;    [1,2,3,4]&#xA;整型直接量&#xA;    0&#xA;    10&#xA;    0xff/0Xff                                   # 16进制&#xA;    0o377                                       # 8进制&#xA;        0377                                    # ECMAScript标准不支持八进制直接量，某些实现可以采用八进制表示&#xA;                                                # ECMAScript6严格模式下, 八进制直接量是明令禁止的&#xA;    0b11/0B11                                   # 2进制&#xA;浮点型直接量&#xA;    3.14&#xA;    .333&#xA;    6.02e23                                     # 6.02 x 10^23&#xA;    1.4E-32&#xA;字符串直接量&#xA;    ECMAScript5可多行                             # ECMAScript3规定必须一行&#xA;        &amp;quot;one\&#xA;        long line&amp;quot;&#xA;    模板字符串                                   # 保留换行，空格，缩进&#xA;        var name = &#39;Bob&#39;;&#xA;        `hello ${name}                          # ${}中可用任意表达式，包括函数&#xA;        how are you`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;语法&#34;&gt;&#xA;  语法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;可省略的分号&#xA;    通用规则: 独占一行，并与下一行不能整体解析时&#xA;        var a = f&#xA;        反例                                      # 以 (, [, /, +, - 开始的语句极可能和前一条语句一起解析，可写成 ;(a+b)&#xA;            (a+b).toString(); 就不可以&#xA;    例外规则&#xA;        return, break, continue占一行时，总加分号&#xA;        ++, -- 永远解析为前缀, 所以作后缀时要加分号   # 如　x [换行] ++ [换行] y, 解析为 x; ++y&#xA;    &#39;}&#39;之前的分号&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;严格模式&#34;&gt;&#xA;  严格模式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a5%e6%a0%bc%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;区别&#xA;    所有变量都要先声明&#xA;    增加了保留字(如await, protected, static, interface)&#xA;    eval, arguments当作关键字&#xA;    不允许八进制整数直接量(0前缀)&#xA;    不能给只读属性赋值，不能给不可扩展对象创建新成员&#xA;    arguments对象拥有参数的静态副本。               # 非严格模式中，都是引用，可以改变原值&#xA;    限制调用栈检测能力                              # 具有caller和arguments属性，但访问时会抛出异常&#xA;        arguments.caller, arguments.callee都会抛出类型错误异常&#xA;        fn.caller, fn.arguments禁止使用&#xA;    对象定义同名属性产生语法错误, 函数声明同名参数产生语法错误&#xA;&#xA;    禁止使用with语句&#xA;    this值在调用的函数中是undefined,                # this禁止指向全局变量&#xA;        指非属性调用，如eval()，非a.test()&#xA;    eval()代码不能创建局部变量或函数&#xA;        而是定义在eval创建的新作用域(在eval返回时弃用)中&#xA;        eval不包含外层作用域&#xA;    delete后非法标识符抛出异常&#xA;        如delete prop, 只能delete global[prop]&#xA;        delete不可配置属性抛出异常&#xA;    es5, es6中尾调用优化只在严格模式下开启             # 因为arguments.caller会跟踪函数调用栈, 无法开启&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;模块化&#34;&gt;&#xA;  模块化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9d%97%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    es6中模块化思想是尽量静态化，编译时确定模块依赖关系与输入输出&#xA;    CommonJS(CMD)与AMD都只能在运行时确定&#xA;    UMD模式只是加了CMD和AMD的切换&#xA;es6&#xA;    特点&#xA;        import, export可以出现在顶层的任何位置&#xA;        import&#xA;            会变量提升, 会执行import的模块&#xA;            引入的变量是只读的，修改会报错。但可以修改引入变量的内部属性&#xA;            只加载3个方法，编译时加载，可能静态分析。但不能引用fs模块本身&#xA;            使引入宏(macro)和类型检查(type system)成为可能&#xA;        模块自动采用严格模式&#xA;        输出/引入的是值的只读引用, 值在运行时计算&#xA;    import&#xA;        import {stat, exists, readFile} from &#39;fs&#39;                   # 多引用&#xA;        import {a as b} from &#39;./profile&#39;                            # b 作为 a 的别名&#xA;        import &#39;lodash&#39;                                             # 只运行模块&#xA;        import * as circle from &#39;./circle&#39;                          # 引入模块到对象&#xA;            circle.area&#xA;        import a from &#39;./export-default&#39;                            # 引入模块中默认的导出, a可以起任意名，不用大括号&#xA;            import {default as xxx} from &#39;./&#39;                       # 本质是输出名字为default变量&#xA;        import def, {a} from &#39;./module&#39;                             # 同时引入default和其它变量&#xA;    export&#xA;        export var a = 1;&#xA;        export function f () {}&#xA;&#xA;        var b = 1, c = 1;&#xA;        export {b, c}                                               # 用于统一输出&#xA;&#xA;        export {v1 as sv1}&#xA;        export {a as b} from &#39;./someModule&#39;                         # 导入同时导出&#xA;        export v from &#39;mod&#39;                                         # 导入同时导出, es7提案可省略大括号&#xA;        export default function() {}                                # export default命令来配置默认导出, 本质是输出名字为default的变量，系统允许它取任意名&#xA;                                                                    # export default foo 导出的foo名在模块外部是无效&#xA;    继承&#xA;        export * from &#39;circle&#39;&#xA;        export var e = 2.7&#xA;        export default function() {}                                # 输出了circle模块的所有方法(忽略default), 又输出了自定义属性&#xA;循环引用&#xA;    CommonJS会输出已执行的部分&#xA;        写法问题&#xA;            var foo = require(&#39;a&#39;).foo&#xA;                a在别处循环引用时, 得到的foo可能是执行到一半的值&#xA;                而var a = require(&#39;a&#39;), a.foo就会得到执行完后的值&#xA;        o-&amp;gt; 例子&#xA;        a.js&#xA;            exports.done = false;&#xA;            var b = require(&#39;./b.js&#39;);&#xA;            console.log(&#39;a.js =&amp;gt; b.done : &#39;, b.done)&#xA;            exports.done = true;&#xA;            console.log(&#39;a.js done&#39;)&#xA;        b.js&#xA;            exports.doen = false;&#xA;            var a = require(&#39;./a.js&#39;)&#xA;            console.log(&#39;b.js =&amp;gt; a.done : &#39;, a.done);&#xA;            exports.done = true;&#xA;            console.log(&#39;a.js done&#39;)&#xA;            main.js&#xA;            var a = require(&#39;./a.js&#39;), b = require(&#39;./b.js&#39;)&#xA;            console.log(&#39;main.js =&amp;gt; a.done: &#39;, a.done, &#39; b.done: &#39;, b.done)&#xA;        执行&#xA;            b.js =&amp;gt; a.done: false&#xA;            b.js done&#xA;            a.js =&amp;gt; b.done: true&#xA;            a.js done&#xA;            main.js =&amp;gt; a.done: true b.done: true&#xA;&#xA;            a.js中require(&#39;./b.js&#39;)阻塞, 执行b.js&#xA;            b.js中require(&#39;./a.js&#39;), 加载已执行的a.js&#xA;            执行完b.js回到a.js, 执行完a.js&#xA;            main.js加载已执行的a.js b.js&#xA;    es6 import时不执行代码，而是引用&#xA;        o-&amp;gt; 例子                                  # CommonJS中不能执行, a加载b, b加载a, a没有输出, foo不存在, es6中可以执行&#xA;        a.js&#xA;            import {bar} from &#39;./b.js&#39;;&#xA;            export function foo() {&#xA;                bar();&#xA;                console.log(&#39;a.js done&#39;)&#xA;            }&#xA;        b.js&#xA;            import {foo} from &#39;./a.js&#39;;&#xA;            export function bar() {&#xA;                if(Math.random() &amp;gt; 0.5) {foo()}&#xA;            }&#xA;        babel-node a.js&#xA;&#xA;        o-&amp;gt; 例子&#xA;        even.js&#xA;            import {odd} from &#39;./odd&#39;&#xA;            export var counter = 0;&#xA;            export function even(n) {&#xA;                counter++;&#xA;                return n == 0 || odd(n - 1);&#xA;            }&#xA;        odd.js&#xA;            import {even} from &#39;./even&#39;;&#xA;            export function odd(n) {&#xA;                return n != 0 &amp;amp;&amp;amp; even(n - 1);&#xA;            }&#xA;        main.js&#xA;            import * as m from &#39;./even.js&#39;&#xA;            m.even(10)  // true&#xA;            m.counter    // 6                       # 10 变到 0 even执行了6次&#xA;            m.even(20)    // true                   # 20 变到 0 even执行了11次&#xA;            m.counter    // 17                      ＃es6中引用加载机制保证even, odd函数能加载，所以可执行。而CommonJS中循环引用，even和odd函数都不会加载&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;类型与变量&#34;&gt;&#xA;  类型与变量&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b%e4%b8%8e%e5%8f%98%e9%87%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;声明&#xA;    特点&#xA;        存值之前是undefined&#xA;        声明提前&#xA;        非声明变量赋值创建全局变量                     # ECMAScript 5 严格模式下未声明赋值会报错&#xA;            非声明的全局变量与声明全局变量的区别: 非声明的全局变量是可配置的(可delete)，而var声明的全局变量不可配置&#xA;        let&#xA;            支持了直接用{}的块级作用域&#xA;            只在块级作用域有效&#xA;                for(let i = 0; ...; ...)&#xA;            无变量提升&#xA;            声明前存在暂时性死区&#xA;                死区中使用该变量会直接报错&#xA;            重复声明报错&#xA;            声明的全局变量不再是全局对象的属性&#xA;                同样机制的还有const, class&#xA;        const&#xA;            只能在声明时赋值一次, 其他同let&#xA;    var x;&#xA;    x = 1;&#xA;    let a = 10&#xA;    const PI = 3.1415&#xA;        export const A = 1;&#xA;            import * as constants from &#39;./constants&#39;&#xA;            constants.A&#xA;类型&#xA;    特点&#xA;        可以拥有方法的类型, 不能拥有方法的类型&#xA;        可变(mutable)类型                           # 值可以改变, 比较(==, ===)是地址的比较&#xA;            对象&#xA;        不可变(immutable)类型                       # 比较(==, ===)是值的比较&#xA;            数字、布尔值、null、undefined、字符串     # 字符串不像c语言可以看作字符数组，js的字符串不可变&#xA;    原始值&#xA;        # 不可以拥有自己的方法&#xA;        null&#xA;        undefined&#xA;    原始类型(primitive type)                        # 可以拥有自己的方法, 原始类型都包含内置构造函数&#xA;        数字&#xA;        字符串&#xA;        布尔值&#xA;        Symbol&#xA;    对象类型(object type)或引用类型，如&#xA;        对象(object)是属性(property)的集合&#xA;            property由key/value组成&#xA;        全局对象(global object)&#xA;        数组类: Array&#xA;            内存连续保住的带编号的值的有序集合&#xA;        函数类: Function&#xA;            具有相关联的可执行代码的特殊对象&#xA;类型转换                                            # Symbol不可转换&#xA;    转换为数字                                      # 字符串允许在开始和结尾处带有空格&#xA;        false为 0&#xA;        true为 1&#xA;        &amp;quot;&amp;quot;为 0&#xA;        失败为 NaN&#xA;    转换为字符串&#xA;        -0 为&amp;quot;0&amp;quot;&#xA;        -Infinity 为&amp;quot;-Infinity&amp;quot;&#xA;        [9]为 &amp;quot;9&amp;quot;&#xA;        [&#39;a&#39;]其他数组，调用join()方法&#xA;    对象转换字符串                                    # 运算符+ == != 的处理运用这里的原理&#xA;                                                    # 日期对象有自己的重定义,valueOf与toString返回的原始值将直接使用&#xA;        toString()&#xA;        valueOf()                                   # 没有toString()方法时调用, 如果返回原始值，自动将它转换为字符串&#xA;            数组、函数、正则表达式返回对象本身&#xA;            日期类返回毫秒数&#xA;        无法得到原始值则抛出异常&#xA;    对象转换数字                                      # 运算符 - &amp;lt; 用了这里的原理&#xA;        首先尝试valueOf()                            # 如果返回原始值，自动转换为数字&#xA;        再尝试toString()                             # 自动转换为数字&#xA;        无法得到原始值则抛出异常&#xA;        例子&#xA;            数字&#xA;                []为0                                # valueOf -&amp;gt; toString -&amp;gt; &amp;quot;&amp;quot; -&amp;gt; 0&#xA;                [9]为9                               # valueOf -&amp;gt; toString -&amp;gt; &amp;quot;9&amp;quot; -&amp;gt; 9&#xA;相等性&#xA;    null == undefined&#xA;    &amp;quot;0&amp;quot; == 0&#xA;    0 == false&#xA;    &amp;quot;0&amp;quot; == false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;类型&#34;&gt;&#xA;  类型&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;数字&#xA;    基础&#xA;        所有数字用二进制浮点数表示(64位, 如java中的double)&#xA;            # IEEE-754标准&#xA;            ## 整数范围 -2^53 ~ 2^53(大约900亿亿)&#xA;        实际的操作(数组索引, 位操作符)基于32位整数&#xA;        负号是一元运算符，并不是数字直接量语法的组成部分&#xA;        0与-0唯一差别&#xA;            1/zero !== 1/-0    # 正无穷大和负无穷大不等&#xA;    实数近似表示(几乎所有现代编程语言都存在, 因为都是IEEE-754标准)&#xA;        浮点数表示褛的个数为18 437 736 874 454 810 627个&#xA;        IEEE-754标准精确表示1/2, 1/8, 1/1024，但不精确表示1/10, 1/00。&#xA;            # 建议用大整数进行重要计算(如元, 角, 分各用整数表示)&#xA;            所以js只能近似表示0.1&#xA;            var x = .3 - .2&#xA;            var y = .2 - .1&#xA;            x == y        // =&amp;gt; false&#xA;            x == .1    // =&amp;gt; false&#xA;            y == .1    // =&amp;gt; true&#xA;字符串&#xA;    基础&#xA;        从0开始&#xA;        没有如c语言中的字符型&#xA;        采用UTF-16编码的Unicode字符集。&#xA;            是一组无符号16位值组成的序列。&#xA;                # 用16位内码表示, 表示一个单个字符&#xA;                ## 不能16位Unicode表示的遵循UTF-16编码规则，两个16位值来表示一个(代理项对)&#xA;                ### 长度为2的字符串可能表示一个Unicode字符,如var e =&amp;quot;\ud835\udc52&amp;quot;; e.length // =&amp;gt; 2&#xA;            字符串的操作不对代理项对单独处理&#xA;            不对字符串做标准代加工&#xA;                所以不能保证字符串是剑的UTF-16格式&#xA;    运算&#xA;        +            # 字符串连接&#xA;    unicode&#xA;        允许采用\uxxxx表示\u0000 到 \uFFFF之间的字符&#xA;        超出范围时用4字节表示, 如 \uD842\uDFB7&#xA;        &#39;\u20BB7&#39; 会被解释成 &#39;\u20BB&#39; + &#39;7&#39;&#xA;        &#39;\u{20BB7}&#39; 会正确解释&#xA;        多种表示法&#xA;            &#39;\z&#39;&#xA;            &#39;\172&#39;&#xA;            &#39;\x7A&#39;&#xA;            &#39;\u007A&#39;&#xA;            &#39;\u{7A}&#39;&#xA;    转义&#xA;        十六进制数表示Latin-1或Unicode中的任意字码, 由两位十六进制数指定&#xA;            &#39;\xA9&#39;        // =&amp;gt; ©&#xA;        \u表示4个十六进制数指定的Unicode字符&#xA;            &#39;\u03c0&#39;    // =&amp;gt;&#xA;        \n&#xA;        \&#39;&#xA;        \0            # 同\u0000, 表示空字符串&#xA;        \b            # 同\u0008, 表示退格符&#xA;        \t            # 同\u0009, 表示tab&#xA;        \v            # \u000B, 垂直制表符&#xA;        \f            # \u000C, 换页符&#xA;        \r            # \u000D, 回车&#xA;布尔&#xA;    转换&#xA;        # 所有值都可以转换为布尔值&#xA;        false&#xA;            undefined&#xA;            null&#xA;            0&#xA;            -0&#xA;            NaN&#xA;            &amp;quot;&amp;quot;&#xA;        true&#xA;            除以上，全部为true&#xA;    api&#xA;        toString()                              # 转换成&amp;quot;true&amp;quot;或&amp;quot;false&amp;quot;&#xA;null undefined&#xA;    类型&#xA;        null为object                            # 但可以表示数字类型、字符串类型&#xA;        undefined为&amp;quot;undefined&amp;quot;, 是一个单独类型&#xA;    比较&#xA;        null == undefined        // =&amp;gt; true&#xA;        null === undefined        // =&amp;gt; false&#xA;    无api                                       # .和[]取成员会产生类型错误&#xA;    bug&#xA;        undefined在ECMAScript可读/写，可赋任意值&#xA;    结论&#xA;        undefined表示系统级类似错误的空缺&#xA;        null表示程序级的，正常出现的空缺&#xA;&#xA;Symbol&#xA;    介绍&#xA;        原始数据类型，因为不是对象，所以不能new, 不能添加属性&#xA;        不参与类型转换, 但可以toString            # 可以String(s)得到 &#39;Symbol(a)&#39;, Boolean(s)得到true, !s 得到false。Number(s)会报错&#xA;        可以做属性名a[sym1] = 1, 不能用点运算符赋值或取值&#xA;        常用于设置常量结构体来switch，以消除魔术字符串&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;作用域&#34;&gt;&#xA;  作用域&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%9c%e7%94%a8%e5%9f%9f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;全局变量&#xA;    就是定义顶级对象的属性                         # 这点在ECMAScript规范中强制规定&#xA;    在js代码任何地方都有定义&#xA;局部变量&#xA;    在函数内有定义，优先于全局变量&#xA;与c语言区别(嵌套作用域)&#xA;    c中{}内产生块级作用域(block scope), 其中变量其外不可见&#xA;    js中没有块级作用域，是函数作用域(function scope), 变量在内部嵌套函数中有定义。&#xA;声明提前&#xA;    内部嵌套函数而言, 变量声明之前就可用, 称为声明提前(hoisting)         # hoisting js函数里声明的所有变量(不赋值), 被&amp;quot;提前&amp;quot;到函数体顶部，在js引擎预编译时进行。&#xA;    例子&#xA;        var scope = &amp;quot;global&amp;quot;&#xA;        function f(){&#xA;            console.log(scope)                  # undefined, 因为局部scope声明提前，覆盖了全局scope, 而声明提前不定义, 定义在执行代码时进行&#xA;            var scope = &amp;quot;local&amp;quot;                 # 等价于开头var scope;&#xA;            console.log(scope)&#xA;        }&#xA;特点&#xA;    js本身设计中没有构造函数，普通函数，对象方法，闭包。这些都是莫须有的叫法&#xA;    内部函数可以访问外部函数上下文&#xA;    非严格格式直接声明变量，挂到global上&#xA;    作用域在函数中定义, 非块定义, 所以&#xA;        for(var i = 0; i &amp;lt; 10; i++){            # 中定义的i与value，在for之外可以被访问, 且声明提前&#xA;            var value = &#39;hello&#39;;&#xA;        }&#xA;this&#xA;    有调用对象就指向调用对象&#xA;    没调用对象指向全局对象&#xA;        O.a = function(){&#xA;            var b = function(){                 # b中的this永远是全局对象&#xA;                console.log(this);&#xA;            };&#xA;            b();&#xA;        };&#xA;        O.a()&#xA;    new 构造时this指向新对象&#xA;        var O = function(){this.val = 100;}&#xA;        var o = new O();&#xA;        console.log(o.val);                     # 这里输出o.val而不是O.val&#xA;    用apply或call或bind方法改变this指向&#xA;        function tt(){&#xA;            console.log(arguments.callee);      # 永远是tt本身&#xA;            console.log(this);                  # 都是下面定义的a&#xA;        }&#xA;        var a = &#39;1&#39;;&#xA;        tt.call(a, 1, 2);&#xA;        tt.apply(a, [1, 2]);&#xA;        var att = tt.bind(a);&#xA;        att();&#xA;参数调用时，会扩展作用域，如&#xA;    f(a.b)()                                    # a挂到f的作用域&#xA;    var f = function(c){}&#xA;作用域链(scope chain)&#xA;    特点&#xA;        每一段js代码有关联的作用域链&#xA;        一个对象链表，定义这段代码的作用域&#xA;        变量解析(variable resolution)时，从链第一个开始查找到最后一个   # 查找不存在时抛出引用错误(ReferenceError)&#xA;    原理&#xA;        定义一个函数时，实际上保存一个作用域链&#xA;        调用该函数时，创建新对象放局部变量，添加到保存的作用域链&#xA;        同时，创建一个新的、更长的&amp;quot;函数调用作用域链&amp;quot;&#xA;        该函数每次调用外部函数时，嵌套函数重定义&#xA;    代码作用域链分类&#xA;        顶层代码&#xA;            顶级对象属性&#xA;        无嵌套函数体&#xA;            var定义的局部变量&#xA;            顶级对象属性&#xA;        嵌套函数体&#xA;            var定义的局部变量&#xA;            顶级对象属性&#xA;            函数调用作用域&amp;quot;链&amp;quot;&#xA;    注意&#xA;        函数创建时，它的作用域链中会填入全局对象&#xA;        执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象&#xA;            运行期上下文定义了函数执行时的环境&#xA;            每个运行期上下文都有自己的作用域链&#xA;            其作用域链初始化为当前运行函数的Scope所包含的对象。&#xA;        函数中的值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中&#xA;            它们共同组成了一个新的对象，叫“活动对象(activation object)”&#xA;            该对象包含了函数的所有局部变量、命名参数、参数集合以及this&#xA;            此对象会被推入作用域链的前端&#xA;            运行期上下文被销毁，活动对象也随之销毁&#xA;        在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。&#xA;            该过程从作用域链头部，也就是从活动对象开始搜索&#xA;            如果没找到继续搜索作用域链中的下一个对象&#xA;            如果搜索完所有对象都未找到，则认为该标识符未定义&#xA;        作用域链只会被 with 语句和 catch 语句影响。&#xA;    优化代码：&#xA;        因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。&#xA;            所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量&#xA;            一个好的经验法则是, 如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用&#xA;        优化with&#xA;            with(o){&#xA;            }&#xA;            使用with语句来避免多次书写document，看上去更高效，实际上产生了性能问题。&#xA;                代码运行到with语句时，运行期上下文的作用域链临时被改变了&#xA;                一个新的可变对象被创建，它包含了参数指定的对象的所有属性, 这个对象将被推入作用域链的头部&#xA;                这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。&#xA;        优化try-catch&#xA;            try{&#xA;                doSomething();&#xA;            }catch(ex){&#xA;                alert(ex.message);              # 作用域链在此处改变。同理，catch语句使效率下降&#xA;&#xA;            try{&#xA;                doSomething();&#xA;            }catch(ex){&#xA;                handleError(ex);                # 委托给处理器方法, 没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。&#xA;            }                                   # 优化后的代码，handleError方法是catch子句中唯一执行的代码。该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;表达式&#34;&gt;&#xA;  表达式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e8%be%be%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    表达式(expression), 由解释器计算(evaluate)&#xA;原始表达式(primary expression)&#xA;    常量&#xA;    直接量&#xA;    关键字&#xA;        true, false, null, this&#xA;    变量名&#xA;对象和数组初始化表达式                             # 对象直接量、数组直接量&#xA;    {}&#xA;    []&#xA;函数定义表达式                                    # 函数直接量&#xA;    var square = function(x){reutrn x*x}&#xA;属性访问表达式                                    # 其前面的表达式首先计算, null, undefined会抛出类型错误异常，因为它们不能包含属性&#xA;    .&#xA;    [1]&#xA;    [&amp;quot;a&amp;quot;]&#xA;调用表达式(invocation expression)&#xA;    顺序&#xA;        首先计算函数表达式，再计算参数表达式&#xA;        传入实参的值赋值给形参&#xA;        执行函数体&#xA;        return返回值给变量名，无return 函数名赋为undefined&#xA;    左边是属性访问表达式时，称作方法调用(method invocation)&#xA;        函数体的this是宿主对象(执行者)&#xA;        非方法调用时，this是顶级对象&#xA;            ECMAScript 5中非方法调用时, this是undefined&#xA;    f(0)                                        # 非方法调用&#xA;    Math.max(x, y, z)                           # 静态方法调用, this为Math类&#xA;    a.sort()                                    # 动态方法调用, this为a实例&#xA;对象创建表达式(object creation expression)&#xA;    特点&#xA;        创建一个对象并调用构造函数&#xA;        与调用表达式相似&#xA;    过程&#xA;        创建空对象，该对象作为构造函数的this，可用来初始化动态属性&#xA;        传入指定参数，执行构造函数。&#xA;        返回值以构造函数返回值优先(本次对象废弃)，没有时则返回本次创建的对象&#xA;    new Point(2, 3)&#xA;    new Object()&#xA;    new Object                                  # 不传参时, ()可以省略&#xA;关系表达式&#xA;    ==&#xA;    &amp;lt;&#xA;    in&#xA;    instanceof&#xA;逻辑表达式&#xA;    !&#xA;    &amp;amp;&amp;amp;&#xA;    ||&#xA;赋值表达式&#xA;    (a=b) == 0&#xA;    i = j = k = 0;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;运算符&#34;&gt;&#xA;  运算符&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e7%ae%97%e7%ac%a6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    可符号，可关键字&#xA;    一元、二元、三元运算符                         # - +(正负号)是一元，*是二元, ?!是三元&#xA;    期望与转型&#xA;        &amp;quot;3&amp;quot; * &amp;quot;5&amp;quot;                               # 期望数字, 自动转型&#xA;        对类型依赖&#xA;            +                                   # 数字则运算，字符串则拼接&#xA;            &amp;lt;                                   # 数字则比较, 字符则比较字符表次序&#xA;    左值(lvalue)&#xA;        表达式只能出现在赋值运算(=)的左侧&#xA;            &amp;amp;, ++等操作符的操作数&#xA;            内存栈中的变量名&#xA;                变量、对象属性、数组元素&#xA;        内置函数可返回左值，自定义函数不可以&#xA;    优先级&#xA;    左右结合性&#xA;    运算顺序&#xA;        总是严格从左到右计算表达式&#xA;        表达式会影响变量值(如++, --, delete)时，先执行&#xA;            b = (a++)+a                         # 计算b, 计算a++(返回的结果是1), 计算右边的a(结果是2), 计算等号右边(1 + 2), 赋值&#xA;关键字运算符&#xA;    delete, typeof, instanceof, in, void&#xA;    in运算符                                     # 判断是否存在属性, 左是字符串, 右是对象&#xA;        &#39;toString&#39; in obj&#xA;        for( var i in ojb)&#xA;    instanceof运算符                             # 判断是否实例, 会判断父类, (prototype chain)&#xA;        o instanceof f                          # 遍历原型链, 计算f.prototype, 然后在o原型链中查找f, 找到则返回true&#xA;    typeof 运算符                                # 返回一个对象的类型描述字符串&#xA;        typeof value == &amp;quot;string&amp;quot; ? &amp;quot;&#39;&amp;quot; + value + &amp;quot;&#39;&amp;quot; : value&#xA;        typeof(value)                           # 可以写作函数的形式&#xA;        返回值&#xA;            &amp;quot;undefined&amp;quot;, &amp;quot;object&amp;quot;, &amp;quot;boolean&amp;quot;, &amp;quot;number&amp;quot;, &amp;quot;string&amp;quot;, &amp;quot;function&amp;quot;&#xA;            null, 对象和数组 返回&amp;quot;object&amp;quot;         # 函数是对象的一种，但typeof特殊对待。&#xA;                                                # instanceof, class特性, constructor属性&#xA;    delete运算符                                 # 严格模式下删除失败会报错&#xA;        删除属性, 成功则返回true&#xA;        内置核心客户端属性不能删除&#xA;        var语句声明的变量不能删除&#xA;        function定义的函数和其参数不能删除&#xA;    void运算符&#xA;        写在操作数前，操作数照常计算, 但返回undefined&#xA;            &amp;lt;a href=&amp;quot;javascript:void window.open();&amp;quot;&amp;gt;               # 使浏览器不必显示计算结果&#xA;普通一元(目)运算符&#xA;    +                                           # 这里+, -表示正负号, +, -会把变量自动转型为数字&#xA;    -&#xA;    ++                                          # ++, -- 作为前增量时, 返回计算后的值，后增量时，返回计算前的值。与c语言不一样，c语言的前后增量作用于整个表达式s&#xA;    --&#xA;普通二元(目)运算符&#xA;    特点&#xA;        必要时转换数字&#xA;        js中数字都是浮点数, 所以5/2 = 2.5&#xA;        左结合&#xA;        根据类型进行数字相加或字符串连接&#xA;        对象先尝试转换数字(Date除外，先转换字符串)&#xA;            如果存在字符串，则拼接(不论字符串值是否数字)&#xA;            都为非字符串，则转换数字计算，失败返回NaN&#xA;    -&#xA;    *&#xA;    /&#xA;    %&#xA;    **                                          # **是指数运算符&#xA;    +&#xA;三元(目)运算符&#xA;    ?:                                          # 条件运算符, 唯一三元运算符&#xA;位运算符(对操作数每位布尔运算)&#xA;    特点&#xA;        要求操作数是整数(32位整形而非64位浮点型)&#xA;        会自动强制转换&#xA;        NaN, Infinity, -Infinity转换为0&#xA;    &amp;amp;                                           # 按位与&#xA;        0x1234 &amp;amp; 0x00FF = 0x0034&#xA;    |                                           # 按位或&#xA;        0x1234 | 0x00FF = 0x12FF&#xA;    ^                                           # 按位异或&#xA;        0xFF00 ^ oxF0F0 = 0x0FF0&#xA;    ~                                           # 按位非&#xA;        ~0x0f = 0xFFFFFFF0或 -16&#xA;    &amp;lt;&amp;lt;                                          # 左移&#xA;        7&amp;lt;&amp;lt;2 = 28&#xA;                                                # 移动倍数是0~31的整数，用0补&#xA;    &amp;gt;&amp;gt;                                          # 左边高位 正数填0, 负数填1&#xA;        7&amp;gt;&amp;gt;1 = 3&#xA;        -7&amp;gt;&amp;gt;1 = -4&#xA;    &amp;gt;&amp;gt;&amp;gt;                                         # 无符号右移，左边高位总填0&#xA;相等不等运算符&#xA;    ==(equality operator), ===(严格相等(strict equality)或恒等(identity operator))&#xA;        ==                                      # 数字和字符串原始类型也是地址的相等(恒等)&#xA;            null == undefined&#xA;            数字==字符串, 字符串转换为数字比较, true转换成1比较&#xA;            &amp;quot;1&amp;quot;==true    # 同时转换为数字比较&#xA;            对象根据另一个值的类型转换&#xA;        === 与 ==&#xA;            不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等&#xA;    !=, !==是==, ===的求反&#xA;比较运算符&#xA;    &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=                                # 存在NaN则返回false, &amp;lt;=只是简单的不大于，&amp;gt;=相反。不进行==比较&#xA;        0 == -0&#xA;        Infinity最大(除了本身)&#xA;        -Infinity最小(除了本身)&#xA;    转换&#xA;        对象转换为数字&#xA;        同为字符串，字母表顺序比较(16位unicode字符索引顺序)&#xA;        存在不为字符串，转换数字&#xA;逻辑运算符&#xA;    ! &amp;amp;&amp;amp; ||                                     # !会隐式转换为布尔类型, &amp;amp;&amp;amp;比||优先级要高, !优先级最高&#xA;    隔断性&#xA;        (a == b) &amp;amp;&amp;amp; stop()                      # 同if(a == b) stop();&#xA;        var max = a || b || 0;                  # 常用。层层按优先级判断，给max赋值, 用来给可能未传入的参数赋默认值&#xA;赋值运算符&#xA;    =&#xA;    带操作的赋值运算符&#xA;        +=, -=, *=, /=, %/, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;gt;&amp;gt;&amp;gt;=, &amp;amp;=, |=, ^=, **=&#xA;    注意&#xA;        data[i++] *=2&#xA;        data[i++] = data[i++] * 2               # 以上不相同&#xA;逗号运算符                                       # 计算左边表达式并忽略结果, 连接多上表达式成为一个表达式&#xA;    i=0, j=1, k=2                               # 计算结果是2&#xA;    for(var i=0, j=10; i &amp;lt; j;j--)&#xA;扩展(spread)运算符                               # 展开具有[Symbol.iterator]接口的可遍历对象，所以可以展开字符串, Map, Set, Generator&#xA;                                                # 内部使用for of, 支持4字节字符&#xA;    [1, 2, ...arguments]                        # 展开成新数组, 等于[1, 2].concat(arguments)&#xA;    [a, ...rest] = [1, 2, 3]                    # 模式匹配给rest赋值, 只能放在最后&#xA;    array.push(1, ...items, 2)                  # 函数调用&#xA;函数绑定运算符                                    # 返回原对象, 可以链式调用a::b::c, 把b, c都绑定到a&#xA;    foo::bar                                    # bar.bind(foo)&#xA;    ::obj.foo                                   # obj.foo.bind(obj)&#xA;优先级&#xA;    优先级(js权威指南六版66页)&#xA;算术运算&#xA;    不报错&#xA;        溢出(overflow), 下溢(underflow), 被零整除&#xA;        overflow&#xA;            超过表示的数字上限, 得到Infinity或-Infinity&#xA;        underflow&#xA;            比最小值还小, 返回0或负0, 负0几乎和0一样, 很少用到&#xA;        除零&#xA;            返回无穷大或负无穷大&#xA;    返回NaN&#xA;        零除以零&#xA;        无穷除以无穷&#xA;        负数开方&#xA;        无法转换为数字&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;eval&#34;&gt;&#xA;  eval&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eval&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    计算由源代码组成的字符串, 用eval(&amp;quot;&amp;quot;)来运行&#xA;    eval()是一个函数，但设计上更像运算符。&#xA;        限制eval()函数使它更像运算符&#xA;eval()&#xA;    一个参数，如果不传入字符串，则直接返回传入的参数。&#xA;        传入字符串, 则编译该字符串&#xA;            失败则抛出语法错误异常(SyntaxError)，成功则开始执行这段代码&#xA;            执行成功，返回字符串中最后一个语句的值。最后语句没有值，返回undefined&#xA;            执行中抛出异常, 该异常将调用传递给eval()[?]&#xA;    eval的作用域是当前作用域, 如eval(&amp;quot;var y = 3;&amp;quot;)&#xA;    用eval向函数中粘贴代码片段是无意义的，如&#xA;        var foo = function(a){eval(a)};&#xA;        foo(&amp;quot;return;&amp;quot;);                                             # 执行eval(a)的上下文是全局的, 会抛出return not in function错误&#xA;    eval作为单独脚本，如eval(&amp;quot; y = 1;&amp;quot;)是有意义的&#xA;问题&#xA;    eval()中的代码，解释器不能分析和优化&#xA;        eval()可以改变局部变量，对优化是很大的问题&#xA;    eval()的函数名可以被赋予其他名字(与运算符的区别)&#xA;        var f = eval;&#xA;        var g = f;&#xA;        这样解释器无法优化任何调用g()的函数&#xA;            所以ECMAScript规定不可以对eval()赋予别名，会抛出EvalError异常&#xA;            实际上，大多数实现并不这么做。别名调用时, 会当作顶层全局代码来执行&#xA;            这样不会修改局部变量的值，不影响优化&#xA;    ECMAScript 5规定&#xA;        直接eval(direct eval), 总是在调用它的上下文作用域执行&#xA;        间接调用(指别名调用)则作为顶层代码执行，不能读、写、定义局部变量   # 间接eval是有用的特性，允许在局部作用域执行上下文无依赖的脚本&#xA;    ie9之前的不同&#xA;        别名调用eval()是局部调用&#xA;        用execScript()来全局eval调用                                  # 与eval不同在于总是返回null&#xA;    ECMAScript 5 严格模式&#xA;        eval作为保留字, 不能用别名覆盖(更像运算符)&#xA;        eval中的字符串以&amp;quot;use strict&amp;quot;指令开始&#xA;        可以使用和更改局部变量，不可以定义新的变量&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;语句&#34;&gt;&#xA;  语句&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    语句以分号结束&#xA;    表达式计算出值，语句来执行。&#xA;        有副作用的表达式也会执行，叫作表达式语句(expression statement)&#xA;        声明语句(declaration statement), 来声明新变量或定义新函数&#xA;    js解释器依照语句编写顺序执行&#xA;        控制结构(control structure)改变顺序&#xA;            条件conditional&#xA;                switch&#xA;            循环loop&#xA;                while, for&#xA;            跳转jump&#xA;                break, return, throw&#xA;表达式语句&#xA;    赋值语句，如 greeting = &amp;quot;Hello&amp;quot; + name;&#xA;    ++, --&#xA;    delete&#xA;    函数调用，如 alert(greeting);                 # Math.cos(x)不是表达式语句，它没有对浏览器造成影响&#xA;复合语句和空语句&#xA;    {}括起来当作单独语句&#xA;        内部语句必须分号&#xA;        内部声明的变量作用域在外部(es6之前)&#xA;        如&#xA;            {&#xA;                x = Math.PI;&#xA;                cx = Math.cos(x);&#xA;            }&#xA;    空语句&#xA;        ;&#xA;        如&#xA;            if(){....}&#xA;            if();&#xA;块作用域(es6之后)                                 # 内部使用严格模式&#xA;    {&#xA;    }&#xA;声明语句&#xA;    特点&#xA;        声明语句创建的变量无法删除，但不是只读的，可以重写&#xA;        函数声明常出现在代码最顶层&#xA;        函数声明并没有归类为真正的语句&#xA;        函数声明不能出现在if, while等语句中&#xA;    var, function&#xA;    如&#xA;        var f = function(){}                    # 变量名指向函数对象，声明提前。初始化要在执行到时进行, 不可以在代码之前调用&#xA;        function f(){}                          # 函数声明和定义均提前，可以在代码之前调用&#xA;条件语句&#xA;    if(expression1) statement1&#xA;        else if(expression2) statement2&#xA;        else statement3&#xA;    switch(expression){ statements}&#xA;        特点&#xA;            不重复计算表达式&#xA;            无break向下执行，如c语言&#xA;            ECMAScript规定case可跟随任意表达式&#xA;                case是恒等比较, 所以不会作类型转换&#xA;                case是运行时(run-time)计算的, 灵活但效率低。&#xA;                c, c++, java中case是编译时(compile-time)常量&#xA;            编译时常量形成跳转表(jump table), 执行非常高效&#xA;            避免使用函数表达式和赋值表达式，建议常量表达式&#xA;            default标签可以在switch语句内的任何地方&#xA;        switch(typeof x){&#xA;            case &#39;number&#39;: break;&#xA;            default: break;&#xA;        }&#xA;    while(expression) statement&#xA;    do statement while(expression);             # 代码至少执行一次&#xA;    for(initialize; test; increment) statement                      # for(;;)比while(true)高效&#xA;    for(variable in object)                     # 遍历对象属性成员, 遍历出的数组key(如0, 1, 2)是字符串&#xA;        for(a[i++] in o)&#xA;        for(i in [1,2,3])&#xA;        原理&#xA;            计算object表达式&#xA;                为null或undefined 则跳过         # ECMAScript3的实现可能会抛出一个类型错误异常&#xA;                为原始值, 则包装对象&#xA;                否则就一定是对象，枚举对象属性(或数组索引)&#xA;                    只有可枚举(enumerable)属性才会遍历到&#xA;                        代码中所有属性和方法可枚举&#xA;                        ECMAScript 5可以特殊手段变为不可枚举&#xA;                        js语言核心定义的内置方法不可枚举(nonenumerable)，如toString()&#xA;                        很多内置属性不可枚举&#xA;                        继承的自定义属性也可以枚举出来&#xA;                    prototype上有多个原型(原型链上多个对象), 每个都遍历&#xA;                    for/in中提前删除的未枚举属性不会枚举到&#xA;                        定义的新属性不会枚举到(有些实现是可以枚举到的)&#xA;                    每次循环计算variable表达式的值，以它为左值赋值&#xA;        顺序&#xA;            通常实现按照定义先后顺序&#xA;            原型链多继承对象有特定顺序&#xA;            数组依照数字顺序                    # 不是全部实现, 索引非数字或不连续时，按照特定顺序&#xA;    for(let c of s)                           # 会正确识别4字节字符&#xA;跳转语句(jump statement)&#xA;    break, continue, return, throw            # throw是复杂的跳转语句，跳转到最近闭合异常处理程序, 处理程序可以在同函数中或高层调用栈中&#xA;标签语句&#xA;    identifier: statement&#xA;        identifier不能是保留字。与变量或函数命名空间不同，可以使用同一个标识符作标签和函数名&#xA;        外层语句标签不能和它内部的重名。不嵌套下是可重名的&#xA;        break, continue是唯一可以使用语句标签的语句&#xA;    mainloop: while(token != null){&#xA;        continue mainloop;&#xA;        // break mainloop;&#xA;    }&#xA;break语句&#xA;    特点&#xA;        break后面无内容自动补分号&#xA;        不可以跳出函数边界，只在一个函数中起作用&#xA;        for中不会计算自增表达式, 直接退出&#xA;    break;&#xA;    break labelname;&#xA;continue语句&#xA;    特点&#xA;        continue后面无内容自动补分号&#xA;        while中跳到开头检测expression, do/while跳到结尾&#xA;        for中先计算自增表达式，再检测expression, for/in中遍历下一个属性名，赋给变量&#xA;    continue;&#xA;    continue labelname;&#xA;return语句&#xA;    特点&#xA;        return后面无内容自动补分号&#xA;        函数调用是表达式，return返回函数表达式的值并跳过后续结果。无return时, 函数表达式结果为undefined&#xA;        只在函数中出现&#xA;throw语句&#xA;    特点&#xA;        js解释器立即停止当前执行的逻辑，并跳转到就近异常处理程序&#xA;        try/catch/finally语句的catch编写异常处理程序&#xA;        没有异常处理程序, js把异常当作程序错误处理，报告给用户&#xA;    throw expression;&#xA;    throw new Error(&#39;x不能是负数&#39;);              # Error对象, name属性表示错误类型, message属性存放传递给构造函数的错误信息&#xA;try/catch/finally语句                           # catch可选, finally可选, try finally一起, finally用于清理代码&#xA;    finally中常写的逻辑                          # finally中return, continue, break, throw跳转，忽略已有返回值或异常，以finally中的为准&#xA;        o-&amp;gt; 正常终止, 收尾语句&#xA;        o-&amp;gt; break, continue或return终止&#xA;        o-&amp;gt; 抛出异常，被catch捕获。抛出异常未被捕获, 继续向上传播&#xA;    模拟for(initialize; test; increment)body;&#xA;    initialize;&#xA;    while(test){&#xA;        try{body;}                              # body中有break时, 这里相比for循环有一次额外的自增运算, 所以while不能完全模拟for&#xA;        finally{increment;}&#xA;    }&#xA;with语句&#xA;    with(object) statement&#xA;    with语句用于临时扩展作用域链, 将对象添加到作用域链的头部&#xA;    with下创建未声明变量不会添加到with对应对象作属性，而是和平时一样&#xA;        with执行完后把作用域链恢复到原始状态&#xA;        作用域链(scope chain)&#xA;            按序检索的对象列表, 通过它进行变量名解析&#xA;        严格模式下禁止使用with语句。非严格模式不擒获with, 因为运行慢且非常难于优化&#xA;            对象嵌套层很深时使用with来简化代码编写&#xA;debugger语句&#xA;    debugger;                                   # 产生一个断点(breakpoint)，在解释器调试模式运行时使用&#xA;                                                # ECMAScript 5中加入的debugger语句。但从前主流浏览器已经实现了&#xA;&amp;quot;use strict&amp;quot;指令&#xA;    只出现在代码或函数体的开始或eval()中。其前可以有其字符串直接量表达式语句&#xA;        解释器可能将&amp;quot;use strict&amp;quot;之前的字符串和它都解释成解释器自有的指令&#xA;        直到第一条常规语句出现之后, 字符串直接量就只当作普通表达式语句对待&#xA;    表示其后的代码将会解析为严格代码&#xA;        函数和eval()只作用到自身&#xA;    ECMAScript 5引入的指令。可以使用单引号。对于没有实现ECMAScript 5的解释器来说，它什么也不做(没有副作用)&#xA;        将来ECMAScript希望用use做关键字&#xA;tag函数                                         # 用于过滤html字符串, 嵌入其他语言执行或filter出特定的值&#xA;    tag`hello ${1} world ${2}`&#xA;    function tag(strArr, ...values){}           # [&#39;hello &#39;, &#39; world &#39;, &#39;&#39;] , 1, 2&#xA;数组推导                                        # 支持iterator接口, 即也支持字符串。惰性求值, 可以替代filter方法&#xA;    var a1 = [1, 2, 3]&#xA;    var a2 = [for (i of a1) i * 2]&#xA;    var a3 = [for (i of a1) if(i &amp;lt; 3) i]&#xA;    var b1 = [1, 2]&#xA;    var b2 = [&#39;a&#39;, &#39;b&#39;]&#xA;    [for (s of b1) for (w of b2) s+w]    // [&#39;1a&#39;, &#39;1b&#39;, &#39;2a&#39;, &#39;2b&#39;]&#xA;    let c = (for (n of generator()) n * n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;模式匹配&#34;&gt;&#xA;  模式匹配&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    模式匹配只对自身属性起作用&#xA;&#xA;数组&#xA;    let [foo, [[bar], baz]] = [1, [[2], 3]]     # var, const同样适用&#xA;    let [,, third] = [1, 2, 3]&#xA;    let [head, ...tail] = [1, 2, 3]&#xA;    let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])    # 只要有Iterator接口，都可以匹配&#xA;&#xA;    var [foo = true] = []                       # 设置默认值，在值严格等于undefined时生效&#xA;        var [x = 1] = [undefined]&#xA;            x = 1&#xA;        var [x = 1] = [null]&#xA;            x = null&#xA;        let [x = f()] = [1]                     # 惰性求值&#xA;        let [x = y, y = 1]                      # 报错, y 未声明&#xA;&#xA;对象&#xA;    var {bar, foo} = {foo: &#39;a&#39;, bar: &#39;b&#39;};&#xA;    var {foo: baz} = {foo: &#39;a&#39;};                # baz = &#39;a&#39;&#xA;    var {p: [x, {y}]} = {p: [&#39;a&#39;, {&#39;b&#39;}]}       # 这里p是模式，不是变量，所以不声明或赋值&#xA;    let obj = {}, arr = [];&#xA;    ({foo: obj.prop, bar: arr[0]} = {foo: 1, bar: 0});              # 嵌套值, 不加()时{}会被解释成代码块&#xA;    var {x = 3} = {};&#xA;    let {log, sin, cos} = Math                  # 将对象的方法赋值到变量&#xA;    let n = {...{a: 3, b: 4}}                   # {a: 3, b: 4}, 扩展null, undefined会被忽略, 被扩展对象中的getter会执行&#xA;        let n = {x: 1, ...a}                    # a中的x属性会被覆盖掉, 原理同Object.assign&#xA;        let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4}                 # x // 1, y // 2, z // {a: 3, b: 4}, z 是引用&#xA;基本类型&#xA;    const [a, b] = &#39;hello&#39;&#xA;    let {toString: s} = 123                     # 如果右边不是对象，先包装, null 和 undefined不能匹配&#xA;        # let {toString: s} = true&#xA;&#xA;函数&#xA;    function add([x, y]){}&#xA;    add([1, 2])&#xA;    function move({x = 0, y = 0} = {})          # function move({x, y} = {x: 0, y: 0}) 是错误的&#xA;&#xA;圆括号&#xA;    [(b)] = [3]&#xA;    ({p: (d)} = {})&#xA;    [(parseInt.prop)] = [3]                     # 只有非声明语句的非模式部分可以用圆括号&#xA;&#xA;用途&#xA;    [x, y] = [y, x]                             # 交换值&#xA;    function f(){return [1, 2]}&#xA;    var [a, b] = f();&#xA;    function f(){return {foo: 1, bar: 2}}&#xA;    var {foo, bar} = f();                       # 函数返回多个值&#xA;    function f([x, y]){}&#xA;    f([1, 2])&#xA;    function f({x, y, z = 3}){}&#xA;    f({y: 2, x: 1})                             # 参数定义&#xA;    let {id} = {id: 42, status: &#39;ok&#39;}           # json匹配&#xA;    var map = new Map(); map.set(&#39;a&#39;, 1)&#xA;    for(let [, val] of map){}                   # 遍历map&#xA;    const {SourceMapConsumer, SourceNode} = require(&#39;source-map&#39;)   # 输入模块方法&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数&#34;&gt;&#xA;  函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    js的函数是参数化的&#xA;        在js中，函数即对象，可以随意传递，可以设置属性和调用该函数的函数&#xA;        在js中，函数可以嵌套定义, 嵌套的函数可以访问被定义所处作域中的变量，这个作用域就是闭包(closure)&#xA;        函数是对象，但typeof经过处理，所以返回&amp;quot;function&amp;quot;, 可以拥有静态属性和方法，可以用内部构造函数Function()创建&#xA;    形参 标识符列表(函数中定义的变量)，调用时为其提供实参值。&#xA;    初始化对象的函数是构造函数&#xA;    return停止函数执行并返回它的表达式。没有表达式时返回undefined。没有return语句时返回undefined&#xA;    this是关键字，不是变量或属性名，所以不允许赋值。&#xA;        this没有作用域限制&#xA;    将函数绑定到Function.prototype上，以便所有函数对象都继承它&#xA;关键字&#xA;    this&#xA;        除实参外，每次调用拥有一个调用上下文 this&#xA;        对象调用函数时, 此次调用上下文是该对象。&#xA;    super&#xA;        super()调用父类的构造方法, super相当与父类的实例，super同时部署了父类的静态属性&#xA;        对象总是继承其他对象，所以在任意对象中，都可以使用super, 如&#xA;            var obj = {toString() {return &#39;a &#39; + super.toString() }}&#xA;    new.target&#xA;        构造函数中使用, 返回调用该构造函数时new 命令作用的对象&#xA;        如果直接调用等, 则值为undefined&#xA;        function Person() {new.target === Person}&#xA;        class {constructor() {new.target}}                          # 子类继承父类调用super()时, 父类构造方法中new.target指向子类, 可以利用写出不能继承的类&#xA;定义                                              # 函数名通常是动词或以动词为前缀的词组，常用的写短&#xA;    function a(){}&#xA;        声明和定义均提前&#xA;        ECMA只允许它作为顶级语句，不能出现在循环、条件判断或者try/cache/finally及with语句中&#xA;            一些js实现并未严格遵守规则，比如firefox就可以在if中出现函数声明&#xA;    var a = function(){}&#xA;        只声明提前。可作匿名函数&#xA;        此为函数定义表达式, 可以出现在js代码的任何地方&#xA;    o.m = f&#xA;        给已有对象的属性引用方法&#xA;创建函数&#xA;    function fun(){}&#xA;    var fun = function {}&#xA;    var fun = new Function(&amp;quot;输入变量1&amp;quot;,&amp;quot;输入变量2&amp;quot;,&amp;quot;执行内容&amp;quot;);        # 动态创建函数&#xA;&#xA;    var f = (a, b) =&amp;gt; a + b&#xA;    var f = n =&amp;gt; n&#xA;    var f = () =&amp;gt; {return 1}&#xA;    var f = () =&amp;gt; ({a: 1})&#xA;    箭头函数特性:&#xA;        没有自己的this, this是外部的this, 所以不能用call, apply, bind改变this&#xA;        不能当作构造函数, 没有super, new.target&#xA;        没有arguments, arguments是外部的&#xA;        不能成为Generator&#xA;        大括号解释为代码块, 要返回对象时用圆括号括起来&#xA;        const pipeline = (...funcs) =&amp;gt; val =&amp;gt; funcs.reduce((a, b) =&amp;gt; b(a), val)&#xA;        const plus1 = a =&amp;gt; a + 1, mult2 = a =&amp;gt; a * 2, addThenMult = pipeline(plus1, mult2);&#xA;        addThenMult(5)    // 12&#xA;        let insert = val =&amp;gt; ({into: (arr) =&amp;gt; ({after: (afterVal) =&amp;gt; {&#xA;            arr.splice(arr.indexOf(afterVal) + 1, 0, val); return arr;&#xA;        }})})&#xA;        insert(2).into([1, 3]).after(1)    // [1, 2, 3]&#xA;参数&#xA;    function f(x, y = 5)&#xA;        f({x: 1, y: 2})可以模式匹配&#xA;        默认值可以是变量，作用域是函数内作用域。函数a默认值是函数b时, 函数b的作用域链不包含函数a&#xA;        默认值一般在最后, 可以一眼看出哪些参数可以省略，调用时也好看&#xA;    function f(url, {method = &#39;GET&#39;} = {})&#xA;    function f({a, b}) {a, b}&#xA;        f({a: 1, b: 2}) 对象匹配&#xA;    function f(a = throwErr())&#xA;        设置不可省略的参数, 默认值是延迟计算的&#xA;    function f(...rest)&#xA;        一定在末尾&#xA;嵌套函数&#xA;    特性    &#xA;        内部嵌套函数可以读写外部参数&#xA;        this不会在嵌套函数中继承，函数调用和方法调用中this的规则不变。&#xA;            如果要在内部访问外部this, 需要将外部this保存到变量中(通常用self, [that 是传递this时使用的变量名])&#xA;调用&#xA;    方式&#xA;        作为函数&#xA;        作为方法&#xA;        作为构造函数&#xA;        通过它们的call()和apply()方法间接调用&#xA;    原理&#xA;        调用由函数对象，左圆括号，参数列表(逗号分隔)，右圆括号组成&#xA;        每个参数表达式都会计算出一个值作为实参传递给声明时定义的形参&#xA;            在函数体中存在一个形参的引用指向当前传入的实参列表&#xA;        函数表达式的值成为调用表达式的值&#xA;        ECMAScritp 3和非严格ECMAScript 5中，函数调用上下文(this)是全局对象。严格模式下是undefined&#xA;            常用this判断是否严格模式&#xA;    调用表达式&#xA;        f()                                     # 作为普通函数调用&#xA;        o.m(x, y)                               # 函数表达式本身就是属性访问表达式, 此时函数作为一个方法调用, 方法调用的上下文是该调用对象o&#xA;        o[&amp;quot;m&amp;quot;](x, y)&#xA;        a[0](z)                                 # 可以用方括号来方法调用&#xA;        a.b.c()&#xA;        f().m()                                 # 方法链, 链式调用, 返回this或构造对象&#xA;构造函数调用&#xA;    方法名前带有new, 就是构造函数的调用&#xA;    与普通的函数调用及方法调用在实参处理、调用上下文、返回值方面都不同&#xA;    定义一类(class)对象，创建对象继承构造函数的prototype属性&#xA;        class看作是对象类型的子类型&#xA;    使用新对象作为调用上下文, 如new o.m()中，this不是o&#xA;    如果return一个对象，则构造的就是这个对象，如果返回原始值或没有值，则忽略返回值&#xA;    原理&#xA;        计算实参表达式，传入函数内。没有形参，允许省略实参列表和圆括号，如&#xA;            var o = new Object()                # 无参时圆括号可以省略&#xA;        创建空对象，继承构造函数的prototype, 试图初始化该对象，并将该对象作为调用上下文&#xA;            尽管构造函数看起来像方法调用，但它用新对象作为调用上下文&#xA;            所以 new o.m()看起来是方法调用，但它的调用上下文并不是o&#xA;        通常不使用return关键字，显式返回构造的新对象&#xA;            显式使用return时，如果没有值或是原始值，就忽略return。如果是对象，就返回return的对象&#xA;间接调用&#xA;    call和apply&#xA;        可以显式指定调用上下文，这样任何函数都可以作为任何对象的方法来调用&#xA;        call使用自有的实参列表作为函数实参，apply以数组形式传入参数&#xA;实参和形参&#xA;    不检查传入的参数类型和参数个数，所以要手动做参数检查&#xA;        传入参数少时，剩下的形参都设置为undefined&#xA;            所以在参数检查时，要给省略的参数赋默认值。如 a = a || []&#xA;            a = a || [] 是习惯用法，用来代替if语句，前提是a必须预先声明&#xA;        前面的参数可选且不传时，传入占位符null(也可以传undefined)&#xA;        函数定义中使用/*optional*/来强调形参可选, 如&#xA;            function f(o, /*optional*/ a)&#xA;    可变长实参列表(实参对象)&#xA;        arguments&#xA;            是类数组对象，可以通过数字下标访问传入的实参值&#xA;            这种可以接收任意个数实参的函数    称为 不定实参函数(varargs function)&#xA;            非严格模式下, 实参对象的数组元素是函数形参对应实参的别名，改变实参值时，实参对象中的值也改变&#xA;                ECMAScript 5中移除了别名这个特性(实测没有移除)&#xA;            非严格模式中, arguments是一个标识符，严格模式中，它是一个保留字&#xA;            arguments的callee和caller属性&#xA;                ECMAScript 5 严格模式中，对这两个属性的读写操作都会产生类型错误&#xA;            非严格模式中, callee指代当前正在执行的函数，caller是非标准的，但大多数浏览器都实现了这个属性，指代调用callee的函数。&#xA;                通过caller属性可以访问调用栈&#xA;            可通过callee递归调用自身&#xA;                var factorial = function(x){&#xA;                    if( x &amp;lt;= 1) return 1;&#xA;                    return x * arguments.callee(x-1)&#xA;                }&#xA;    对象属性作实参，如&#xA;        easycopy({from: a, to: b, length: 4})&#xA;        function easycopy(args){&#xA;            args.from;&#xA;            args.from_start || 0;&#xA;        }&#xA;    类型注释&#xA;        function max(/*number*/a, /*optional*/b, /*array*/c, /*integer*/d, /*index*/e){&#xA;            if(isArrayLike(c)){&#xA;                if(isFinite(a));&#xA;            }&#xA;        }&#xA;函数作为值&#xA;    function a(){}                              # 定义创建函数对象，赋值给a。函数对象的名字是看不见&#xA;    o.f = f                                     # 将函数赋值给对象的属性，就称为方法&#xA;    var a = [function() {}, 20]                 # 没有名字的函数，放在数组直接量中&#xA;函数的自定义属性&#xA;    如当函数需要专属常量时，可在上面定义静态属性&#xA;    如要求函数返回唯一整数，可以定义静态属性做个计数器，&#xA;    如果要做缓存，也可以定义多个静态属性来缓存返回过的结果，属性名就是传入过的值&#xA;作命名空间&#xA;    无法声明只在一个代码块中可见的变量。所以定义一个函数做临时命名空间&#xA;    有些js扩展中(如mozilla的java script 1.7)可以使用let声明语句块内的变量, 如&#xA;        let(x = 1){ print(x)}&#xA;    (function(){&#xA;    }());&#xA;        匿名函数不会定义全局函数变量并运行, 定义了内部的局部变量&#xA;        最外层圆括号是习惯写法，尽管有些时候没必要也不应当省略&#xA;闭包&#xA;    js采用词法作用域(lexical scoping), 函数的执行依赖变量作用域。作用域在函数定义时决定，而非调用时&#xA;        当前函数的变量保存在函数作用域内(闭包)&#xA;        闭包指函数变量可以被隐藏于作用域链之内，象是函数将变量&amp;quot;包裹&amp;quot;了起来&#xA;    每函数中引入当前作用域链&#xA;    定义时与运行时&#xA;        大多定义函数时的作用域链在调用函数时依然有效&#xA;        调用函数时与定义函数时作用域链不是同一个时&#xA;            如返回内部嵌套的函数a时，外部运行a，其作用域链仍然是a的作用域链而非外部作用域链&#xA;    作用&#xA;        捕捉局部变量并一直保存&#xA;    原理&#xA;        如果一个函数的局部变量定义在cpu栈中, 函数返回时它们的确不存在了&#xA;        js中作用域链是一个对象列表，不是绑定的栈。&#xA;            运行js函数a时, 都创建新的对象保存局部变量。该新对象添加到作用域链中&#xA;                函数a返回时，从作用域链中删除该局部变量对象，等待垃圾回收&#xA;                如果a有嵌套函数，每个嵌套函数各自对应一个作用域链         # 该嵌套函数的作用域链，保留a的局部变量对象&#xA;                    嵌套函数在a中局部变量对象中保存时，会随其一起从作用域链删除&#xA;                    嵌套函数被返回或被外部引用时, 该嵌套函数不被回收，且其自身作用域链中的自身局部变量对象、a的局部变量对象也不删除。&#xA;        闭包的this值会随外部调用者而变动，所以要先将this转存。var self = this;&#xA;            闭包中使用的arguments也会变动，也要转存。var outerArguments = arguments;&#xA;可调用对象&#xA;    如&amp;quot;类数组对象&amp;quot;不是真正的数组，&amp;quot;可调用对象&amp;quot;不是函数，但所有函数都是可调用的&#xA;    可调用对象使用越来越少&#xA;    例如&#xA;        ie8及之前的版本window.alert()和document.getElementById()使用了可调用的宿主对象&#xA;        RegExp对象可以直接调用(如RegExp()), 是非标准特性, Netscape提出后被后续浏览器兼容&#xA;            typeof RegExp可能是&amp;quot;function&amp;quot;也可以是&amp;quot;object&amp;quot;&#xA;            最好不要对可调用RegExp对象有太多依赖，其可调用特性将来可能被删除&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;generator&#34;&gt;&#xA;  generator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#generator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;基本&#xA;    generator生成的遍历器g, g[Symbol.iterator]()得到自己。继承它prototype上的方法&#xA;        generator中this添加的属性, 生成的遍历器实例中没有, generator new相当于执行得到遍历器&#xA;        g.bind(obj) 可以改变generator中的this&#xA;    作为对象属性时写做 {* g() {}}, {g: function* () {}}&#xA;应用&#xA;    状态机&#xA;    协程(coroutine)&#xA;        generator是半协程(semi-coroutine), 只有generator函数的调用者，才能改变程序运行状态&#xA;        将多个协作的任务写成generator, 用yield语句交换控制权&#xA;    异步程序同步写法&#xA;    部署iterator接口&#xA;    可看作数组结构&#xA;yield&#xA;    特点&#xA;        惰性求值&#xA;        在表达式中时加圆括号, 如&#39;hello&#39; + (yield 1)，字符串模板中`${yield}`&#xA;        var n = yield i; g.next(1) 来返回值给n, g.next()返回undefined&#xA;        第一次调用g.next()不能传值，因为执行第一个yield之前的代码, 还没有yield来接收&#xA;    var a = yield* g()&#xA;        展开g()得到的generator(可展开所有iterator), 是for ... of的一种简写形式&#xA;        g()中有return 时, a 得到return 的值&#xA;    yield [a(), b()]&#xA;        非展开，而是并列执行, 全部执行返回时返回&#xA;throw&#xA;    特点&#xA;        外部的throw语句只被外部捕获&#xA;        generator中throw的错误先内部捕获，再抛出, g.throw(1)相当于从内部yield处抛出一个错误&#xA;        generator抛出错误后不再能继续执行，再执行返回done=true&#xA;    var g = function* () {try {yield;} catch (e) {}}                # 可以多个yield一个try catch ,  而回调函数只能一个回调一个try catch&#xA;    var i = g(); i.next()&#xA;    try{i.throw(&#39;a&#39;); i.throw(&#39;b&#39;) } catch(e){}                     # 内部捕获a, 外部捕获b&#xA;return&#xA;    特点&#xA;        相当于强制内部return&#xA;        generator中有finally时, g.return()延迟到所有finally执行后执行，再结束&#xA;    g.return(0)    // {value: 0, done: true}&#xA;使用&#xA;    function* f () {&#xA;        yield 1; yield 2; return 3;&#xA;    }&#xA;    var ff = f(), ff.next()&#xA;        # {value: 1, done: false}, {value: 2, done: false}, {value: 3, done: true}, {value: undefined, done: true}&#xA;        ## 没有return语句时, 去掉第三个结果，其它不变&#xA;自动执行                                    # 写执行器处理thunk和promise&#xA;    非promise&#xA;        thunk函数, 把回调函数抽离出来&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;promise&#34;&gt;&#xA;  promise&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#promise&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;三种状态&#xA;    进行中(pending)&#xA;    完成(fulfilled)&#xA;    失败(rejected)&#xA;状态转换&#xA;    状态可以由pending转换成fulfilled，或pending转换成rejected&#xA;    promise的状态转换只发生一次，之后代码会执行，但抛出的错误不捕获&#xA;    p2中return p1, 则p1的状态决定了p2的状态, 如果p1是resolved或reject, p2的回调立即执行&#xA;    所以返回promise对象时, then的回调相当于返回promise的then的回调&#xA;    新建即执行，不能取消。内部错误不抛出。无法得到具体pending状态&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;async&#34;&gt;&#xA;  async&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#async&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    generator的语法糖, 自动执行generator, 处理promise&#xA;    内置执行器，返回promise对象&#xA;使用&#xA;    var asyncReadFile = async function () {&#xA;        try {&#xA;            var f1 = await readFile(&#39;/etc/fstab&#39;);&#xA;        } catch (e) {}&#xA;        await p2.catch(function (e) {})&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;class&#34;&gt;&#xA;  class&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#class&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;特点&#xA;    所有方法在prototype上(constructor, static外)，不可枚举&#xA;    无变量提升&#xA;    类内部即严格模式&#xA;    class A的A.name = &#39;A&#39;, 意义同函数名&#xA;&#xA;语法&#xA;    class Point {&#xA;        constructor(x, y) {                         # 不定义时，生成空constructor方法, this代表新生的实例&#xA;            this.x = x, this.y = y;&#xA;        }&#xA;        toString() {return &#39;a&#39;}&#xA;        [methodName]() {}&#xA;        get prop() {...}&#xA;        set prop(val) {}&#xA;        * [Symbol.iterator]() {}&#xA;        static sMethod() {}                         # 相当于直接在Point上定义, es6 内只有方法，没有属性&#xA;        prop: 1                                     # es6中忽略, es7提案&#xA;        static prop2: 2                             # es6中忽略 es7提案&#xA;    }&#xA;    Point.a = 1;                                    # es6 静态属性只能在class外部定义&#xA;    var point = new Point(2, 3);&#xA;&#xA;    o-&amp;gt;&#xA;    var A = class B{};                              # 这时类的名字是A, 而B只能在类内中指代自己&#xA;    var A = class {};&#xA;    var a = new class {}();&#xA;&#xA;继承&#xA;    两条原型链&#xA;        Object.setPrototypeOf(B.prototype, A.prototype)&#xA;        B.prototype.__proto__ = A.prototype         # 作为构造函数, 子类B的prototype是A的实例&#xA;        Object.setPrototypeOf(B, A)&#xA;        B.__proto__ = A                             # 作为一个对象, 子类B的原型是A(强行成为继承关系来得到A的静态属性)&#xA;        B.__proto__.__proto__ = A.__proto__,        # 子类原型的原型是父类的原型&#xA;    继承的特殊种类&#xA;        class A {}, A.__proto__ = Function.prototype, A.prototype.__proto__ = Object.prototype&#xA;        class A extends null {}, A.__proto__ = Function.prototype, A.prototype.__proto__ = undefined&#xA;&#xA;    o-&amp;gt;&#xA;    class A extends B {&#xA;        constructor(x, y, color) {                  # 默认construcotr为constructor(...args) {super(...args)};&#xA;            super(x, y);                            # 调用B的constructor, 必须调用super来创建父类对象作用自己的prototype, 否则整个继承失败，报错&#xA;            this.color = color                      # this必须在super调用之后才能使用, 否则没有prototype生成this, 报错&#xA;        }&#xA;    }&#xA;    let cp = new A(1, 2, &#39;a&#39;)&#xA;    cp instanceof A    // true&#xA;    cp instanceof B    // true&#xA;&#xA;    o-&amp;gt; 继承原生构造函数(es5不可以)&#xA;        es5机制决定先新建子类实例this, 再将父类属性添加到子类上。父类的内部属性无法获取(如Array的[[DefineOwnProperty]])。&#xA;        es6允许继承原生父类构造函数定义子类, 即先新建父类this, 再用子类修饰, 父类的所有行为都可继承&#xA;    function MyArray() {Array.apply(this, arguments)}&#xA;    MyArray.prototype = Object.create(Array.prototype, {constructor: {&#xA;        value: MyArray,&#xA;        writable: true,&#xA;        configurable: true,&#xA;        enumerable: true,&#xA;    }})&#xA;    class MyArray extends Array {&#xA;        constructor(... args) {&#xA;        super(... args);&#xA;        }&#xA;    }&#xA;&#xA;    o-&amp;gt; 用mixin来混合继承&#xA;    class A extends mix(B, C)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;decorator&#34;&gt;&#xA;  decorator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#decorator&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    编译时执行&#xA;    相当于 class A {}, A = decorator(A) || A;&#xA;    不能用于函数，因为函数提升?&#xA;&#xA;o-&amp;gt; 修饰类&#xA;function testable(target) {                         # target是被修饰的类, 参数2为属性名, 参数3为属性描述对象&#xA;    target.isTestable = true;&#xA;}&#xA;function testable(val) {&#xA;    return function(target) {&#xA;        target.isTestable = val;&#xA;    }&#xA;}&#xA;@testable&#xA;class A {}&#xA;A.isTestable    // true&#xA;&#xA;o-&amp;gt; 修饰类属性&#xA;function readonly(target, name, descriptor) {&#xA;    descriptor.writable = false;&#xA;    return descriptor;&#xA;}&#xA;class Person {&#xA;    @readonly&#xA;    name() {return 0}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;对象&#34;&gt;&#xA;  对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基础&#xA;    一种复合值。属性的无序集合，属性由名/值对组成，看作字符串到值的映射。&#xA;        这种数据结构叫做散列(hash), 散列表(hashtable), 字典(dictionary), 关联数组(associative array)&#xA;        常用来模拟静态对象或静态语言的结构体。也可以模拟json字符串&#xA;    可以基于原型(prototype)继承属性，称作原型式继承(prototypal inheritance)&#xA;    除了字符串、数字、true、false、null、undefined外，js中的值都是对象&#xA;        字符串、数字、布尔值可以自动包装为对象(构造函数的实例)&#xA;    对象操作通过引用(而非值)。&#xA;    常见属性操作&#xA;        创建(create)&#xA;        设置(set)&#xA;        查找(query)&#xA;        删除(delete)&#xA;        检测(test)&#xA;        枚举(enumerate)&#xA;组成&#xA;    属性的名/值对 + 属性特性(property attribute) + 对象特性(object attribute)&#xA;            属性名可以是空字符串，不能重名&#xA;        属性特性包括: 可写(writable attribute), 可枚举(enumerable attribute), 可配置(configurable attribute)&#xA;            可配置表明是否可以删除或修改该属性&#xA;            通过代码给对象创建的所有属性都是可写、可枚举、可配置的, ECMAScript 5 中可以改变&#xA;        对象特性包括&#xA;            对象原型(prototype)                     # 指向另外一个对象, 本对象继承它的原型&#xA;            对象的类(class)                         # 一个标识对象类型的字符串&#xA;            对象的扩展标记(extensible flag)          # ECMAScript 5中指明是否可以向该对象添加新属性&#xA;分类&#xA;    内置对象(native object)                         # 由ECMAScript定义的对象或类。如数组、函数、日期、正则表达式&#xA;    宿主对象(host object)                           # js解释器( 如web浏览器)嵌入的宿主环境,如 HTMLElement对象&#xA;                                                   # 宿主环境定义的方法可当作普通js函数对象, 宿主对象可当作内置对象&#xA;    自定义对象(user-defined object)                  # 运行中的js代码创建的对象&#xA;    自有属性(own property)                          # 直接在对象中定义的属性&#xA;    继承属性(inherited property)                    # 对象的原型对象中定义的属性&#xA;原型&#xA;    每一个js对象(null除外)都与另一个对象(原型)关联，从原型继承属性。&#xA;    内容&#xA;        对象直接量创建的对象有同一个原型对象Object.prototype&#xA;        new的对象原型是构造函数prototype的属性的值     # 于是new Object()创建的对象继承自Object.prototype&#xA;        Object.prototype这个对象没有原型&#xA;        具体&#xA;            除Object.prototype的对象是普通对象，都有原型。&#xA;            所有内置构造函数都继承Object.prototype&#xA;                如, new Date()创建的对象同时继承Date.prototype和Object.prototype&#xA;                这一系列的链接的原型对象就是&amp;quot;原型链&amp;quot;(prototype chain)&#xA;创建对象&#xA;    {}&#xA;        ECMAScript 5中(ECMAScript3的部分实现), 保留字用作属性名可以不带引号&#xA;            ECMAScript 3中保留字作属性名必须用引号&#xA;        ECMAScript 3的IE中, 最后一个逗号不可以忽略&#xA;        每次计算对象直接量，都会计算它的每个属性的值&#xA;    new            # 关键字创建&#xA;        new后的函数是构造函数(constructor)。&#xA;    Object.create()&#xA;        ECMAScript 5中出现的静态函数&#xA;        参数1是原型对象, 参数2可选，对对象属性进一步描述&#xA;&#xA;        Object.create({x:2})&#xA;        Object.create(null)&#xA;            传入参数null来创建没有原型的新对象。&#xA;            没有原型的对象没有toString等方法, 所有不能+运算&#xA;        Object.create(Object.prototype)&#xA;            创建普通对象&#xA;对象序列化(serialization)                            # json(JavaScript Object Notation)&#xA;    ECMAScript 5 api                                # stringify, parse的第二个参数可选，传入属性列表来定制序列化或还原操作&#xA;        JSON.stringify()&#xA;            支持对象, 数组, 字符串, 无穷大数字, true, false, null。NaN, Infinity, -Infinity序列化结果是null&#xA;                日期stringify为日期字符串，parse不能还原成对象&#xA;                只序列化对象的可枚举自有属性。不能序列化的属性自动省略掉&#xA;            函数, RegExp, Error对象和undefined不能序列化和还原&#xA;        JSON.parse()&#xA;创建对象                                            # 函数即对象，本身为构造方法&#xA;    var obj = {};                                  # var obj = []是数组, 数组中Obj[&#39;aa&#39;]添加的是属性而非成员, 静态对象&#xA;    function Obj(a, b){};&#xA;        new Obj(a, b);&#xA;    function Obj(a, b){&#xA;        thisf = new Array();&#xA;        return new Object(a, b)&#xA;    };            &#xA;        Obj(a, b);&#xA;            只能返回Obj里定义的新对象的实例(不能返回本身的实例)&#xA;            内的变量函数静态。指向外部函数可动态&#xA;            内对象为动态&#xA;        new Obj(a, b);                              # 内变量函数动态(内存浪费)&#xA;        Obj.prototype.c = &#39;c&#39;&#xA;        Obj.prototype.d = function(){};&#xA;        Obj.prototype.e = new Array();              # prototype函数为静态函数, prototype对象为静态&#xA;    function Obj(a, b){ }                           # 内部prototype, 与外部完全相同&#xA;        if(typeof Obj._initialized == &#39;undefined&#39;){&#xA;            Obj.prototype.c = function(){};&#xA;            Obj._initialized = true;&#xA;        }&#xA;    最好方式:&#xA;        内部定义变量和对象, prototype定义函数(防止new对象的函数动态)。&#xA;        prototype定义函数可以在内部，也可以在外部。&#xA;    扩展对象&#xA;        Obj.prototype.extend                        # 添加或重写当前对象的属性&#xA;        Object.prototype.extend                     # 所有对象上添加属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;属性&#34;&gt;&#xA;  属性&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;查询和设置&#xA;    . []&#xA;        ECMAScript 3中, 点运算符后的标识符不能是保留字。ECMAScript5(包括ECMAScript3的某些实现)中可以&#xA;        []中必须返回可以转换为字符串的值&#xA;        []的写法用了字符串索引，叫做关系数组(associative array), 散列或字典&#xA;    属性不存在时自动创建&#xA;描述对象&#xA;    value&#xA;    writable                                        # 可修改&#xA;    enumerable                                      # 可枚举性&#xA;        for...in, Object.keys(), JSON.stringify(), Object.assign(), Reflect.enumerate()会忽略不可枚举属性&#xA;        for...in等价Reflect.enumerate(), 会返回继承的属性&#xA;    configurable                                    # 可配置&#xA;遍历属性                                             # 先遍历属性名是数值的属性，再遍历字符串，再遍历Symbol&#xA;    for ... in                                      # 自身和继承的可枚举属性&#xA;    Object.keys                                     # 自身的可枚举属性(不含Symbol)&#xA;    Object.getOwnPropertyNames                      # 自身所有属性(不含Symbol)&#xA;    Object.getOwnPropertySymbols                    # 自身所有Symbol属性&#xA;    Reflect.ownKeys                                 # 自身所有属性&#xA;    Reflect.enumerate                               # 同for ... in&#xA;访问错误&#xA;    查询不存在的属性不报错, 返回undefined&#xA;    对象不存在，会查询null和undefined的属性，会报错&#xA;        建议写法: var len = book &amp;amp;&amp;amp; book.subtitle &amp;amp;&amp;amp; book.subtitle.length&#xA;    只读的设置不报错，如                              # ECMAScript 5的严格模式中会报错&#xA;        Object.prototype = 0;        &#xA;设置属性失败的情况&#xA;    o中属性p是只读的                                  # defineProperty()可以&#xA;    o中属性p是继承属性，且它是只读的&#xA;    o没有属性p, o没有使用p的setter方法, o可扩展性为false&#xA;删除属性&#xA;    delete&#xA;        删除成功，属性不存在，不是属性访问表达式时，返回true&#xA;        属性可配置性为false，非严格模式下返回false, 严格模式下抛出异常&#xA;        全局对象可以不用属性访问表达式, 如 delete x;&#xA;            严格模式下, delete x; 会报语法错误, 必须delete this.x&#xA;        只是断开联系&#xA;        只删除自有属性，不能删除继承属性&#xA;            继承属性可以从原型对象上删除它&#xA;            a = {p:{x:1}}; b= a.p; delete a.p; 执行后p.x还是1。因为属性的引用依然存在&#xA;                会内存泄漏，所以在销毁对象时，要遍历属性中的属性，依次删除&#xA;检测属性&#xA;    in                                              # 检测自有属性和继承属性&#xA;        &amp;quot;x&amp;quot; in o;&#xA;    o.x !== undefined                               # 同in，但没法区分属性的值为undefined时的属性，in可以&#xA;                                                    # !==可以区分null和undefined, 所以用!==&#xA;    hasOwnProperty()                                # 只检测自有属性&#xA;        o.hasOwnProperty(&amp;quot;x&amp;quot;);&#xA;    propertyIsEnumerable()                          # 自有属性且可枚举&#xA;        o.propertyIsEnumerable(&amp;quot;x&amp;quot;)&#xA;枚举属性                                             # ECMAScript 3 的不可枚举属性不能得到&#xA;    for/in&#xA;        ECMAScript 5之前, 工具库给Object.prototype添加的属性必须可枚举&#xA;        所以for/in会枚举出来，要用hasOwnProperty(p)来过滤&#xA;    Object.keys()                                   # ECMAScript 5中定义，返回可枚举的自有属性名数组&#xA;    Object.getOwnPropertyNames()                    # ECMAScript 5中定义，返回自有属性名数组&#xA;getter和setter&#xA;    通常用来表示同一组数据的两种方法(如笛卡尔坐标系表示法和极坐标系表示法)&#xA;        也用于检测属性的写入和读取值&#xA;    ECMAScript 5中属性值可以用方法替代，就是getter和setter, 叫做存取器属性(accessor property)&#xA;        是访问描述符，相对数据描述符(如writable)&#xA;        普通的属性叫做数据属性(data property), 只有一个简单的值&#xA;        存取器属性不具有可写性(writable attribute)&#xA;        作为替代, 只有getter, 则只读。只有setter, 则只写。同时拥有, 则可读写&#xA;            读取只写属性总是返回undefined&#xA;        存取器属性是可以继承的&#xA;    定义&#xA;        var o = {&#xA;            data_prop: 1,&#xA;            get accessor_prop(){},                  # 函数中的this表示当前对象o&#xA;            set accessor_prop(value){}&#xA;        };&#xA;        var descriptor = Object.getOwnPropertyDescriptor(o, &#39;accessor_prop&#39;);&#xA;        &#39;get&#39; in descriptor    // true&#xA;        &#39;set&#39; in descriptor    // true&#xA;    例子&#xA;        var p = {&#xA;            $x: 1.0, &#xA;            $y: 1.0,&#xA;            get r () {return Math.sqrt(this.x * this.x + this.y * this.y);},&#xA;            set r (newvalue) {&#xA;                var oldvalue = Math.sqrt(this.x * this.x + this.y * this.y);&#xA;                var ratio = newvalue/oldvalue;&#xA;                this.x *= ratio;&#xA;                this.y *= ratio;&#xA;            },&#xA;            get theta () {return Math.atan2(this.y, this.x); }&#xA;        }&#xA;    例子&#xA;        var serialnum = {                           # 序列&#xA;            $n: 0,                                  # $暗示私有属性&#xA;            get next(){return this.$n++;},&#xA;            set next(n){&#xA;                if(n &amp;gt;= this.$n) this.$n = n;&#xA;                else throw &amp;quot;序列号的值不能比当前值小&amp;quot;;&#xA;            }&#xA;        }&#xA;    例子2&#xA;        var random = {                              # 返回不同数量范围的随机数&#xA;            get octet(){ return Math.floor(Math.random() * 256)},&#xA;            get uint16(){ return Math.floor(Math.random() * 65536)},&#xA;            get int16(){ return Math.floor(Math.random() * 65536) - 32768}&#xA;        };&#xA;属性的特性                                           # ECMAScrit 3这些特性不可以配置, ECMAScript 5中提供查询和设置的api&#xA;    作用&#xA;        给原型对象添加方法，设置该方法为不可枚举，看起来像内置方法&#xA;        给普通对象定义不能修改或删除的属性，实现&amp;quot;锁定&amp;quot;&#xA;    组成&#xA;        值(value), 可写性(writable)、可枚举性(enumerable)、可配置性(configurable)&#xA;            存取器特性是读取(get)、写入(set)、可枚举性、可配置性&#xA;    原理&#xA;        ECMAScript 5定义了 属性描述符(property descriptor)对象, 代表4个特性&#xA;            该对象的属性有value, writable, enumerable, configurable, 代表4个特性&#xA;            存取器属性描述符用get和set代替value和writable&#xA;                writable, enumerable, configurable是布尔值&#xA;                get和set是函数值, value什么都可以&#xA;    调用                                             # 新建属性的默认特性对象为false或undefined&#xA;        Object.getOwnPropertyDescriptor(o, p)&#xA;            获得对象o的p自有属性的 属性描述符对象&#xA;            要得到继承属性的特性, 要遍历原型链&#xA;        Object.defineProperty(o, &amp;quot;x&amp;quot;, {             # 新建或修改自有属性的特性, 传入对象和属性名与属性描述符对象&#xA;            value: 1,&#xA;            writable: true,&#xA;            enumerable: false,&#xA;            configurable: true&#xA;        });&#xA;        Object.defineProperty(o, &amp;quot;x&amp;quot;, {get: function(){ return 0; }});&#xA;            修改x为存取器属性&#xA;                返回修改后的对象&#xA;            不允许创建或修改的属性，抛出类型错误异常&#xA;                规则(违反则抛异常)&#xA;                    对象不可扩展，可以编辑已有属性, 不能添加&#xA;                    属性不可配置, 不能修改可配置性和可枚举性&#xA;                    存取器属性不可配置, 不能修改getter, setter方法, 不能转换为数据属性&#xA;                    数据属性不可配置，不能转换在存取器属性&#xA;                    数据属性不可配置，不能可写性从false修改为true&#xA;                    数据属性不可配置且不可写, 不能修改值。可配置但不可写时可以修改值&#xA;                        实际上自动标记为可写，再改值，再转换为可写&#xA;        Object.defineProperties({}, {&#xA;            x: {value: 1, writable: true, enumerable: true, configurable: true},&#xA;            y: {value: 1, writable: true, enumerable:true, configurable:true},&#xA;            r: {&#xA;                get: function(){return Math.sqrt(this.x * this.x + this.y * this.y)},&#xA;                enumerable: true,&#xA;                configurable: true&#xA;            }&#xA;        })&#xA;            新建或修改多个属性及特性。第一个参数是修改对象，第二个参数是映射表&#xA;                返回修改后的对象&#xA;            不允许创建或修改的属性，抛出类型错误异常&#xA;    老式api(ECMAScript 5之前，非IE浏览器)&#xA;        __lookupGetter__()&#xA;        __lookupSetter__()                              # 返回一个属性的getter和setter&#xA;        __defineGetter__()&#xA;        __defineSetter__()                              # 定义getter和setter, 第一个参数是属性名, 第二个参数是getter或setter方法&#xA;对象三个属性&#xA;    包括&#xA;        原型(prototype)&#xA;        类(class)&#xA;        可扩展性(extensible attribute)&#xA;    原型&#xA;        api&#xA;            Object.getPrototypeOf()                     # ECMAScript 5出现, 传入对象返回原型&#xA;            o.constructor.prototype                     # 得到对的原型，对于Object.create()创建的对象常不是这样&#xA;            p.isPrototypeof(o)                          # 检测p是否是o的原型(或牌原型链中)，与instanceof运算符类似&#xA;            __proto__                                   # Mozilla实现的js有的属性, safari和chrome也支持&#xA;    类属性&#xA;        表示对象类型信息的字符串, 用toString()方法可以得到&#xA;        ECMAScript 3和5 都不能设置这个属性，只能间接查询&#xA;        js内置构造函数创建的对象类属性与函数名称相匹配&#xA;            对象直接量、Object.create、自定义构造函数 创建的对象类属性是&amp;quot;Object&amp;quot;&#xA;            对于自定义类来说，没办法通过类属性来区分对象的类&#xA;        api&#xA;            toString()                                  # 返回如 [object class], 提取class, 很多对象的toString方法重写了, 要间接调用Function.call()方法&#xA;            function classof(o){&#xA;                if(o === null) return &amp;quot;Null&amp;quot;;&#xA;                if(o === undefined) return &amp;quot;Undefined&amp;quot;; # ECMAScript 5中不需要对null和undefined作处理&#xA;                return Object.prototype.toString.call(o).slice(8, -1);&#xA;            }&#xA;    可扩展性&#xA;        表示是否可以给对象添加新属性。ECMAScript 5中 内置对象和自定义对象都显式可扩展&#xA;        宿主对象可扩展性由js引擎定义&#xA;        api&#xA;            # preventExtensions, seal, freeze 都返回传入的对象&#xA;            Object.esExtensible()                       # 判断对象是否可扩展&#xA;            Object.preventExtensions()                  # 转换对象为不可扩展, 参数为待转换对象, 对象转换不可扩展后，无法再转换回来, 给不可扩展对象原型添加属性, 对象同样会继承新属性&#xA;            Object.seal()                               # 对象设置不可扩展, 同时对象自有属性不可配置, 已有属性标记为可写的依然可配置, seal后的对象不能解封&#xA;            Object.isSealed()                           # 检测对象是否封闭&#xA;            Object.freeze()                             # 除了seal外，将自有数据属性设置为只读, setter方法不受影响&#xA;            Object.isFrozen()                           # 检测是否冻结&#xA;继承&#xA;    介绍&#xA;        js对象有自有属性(own property)，有从原型继承来的属性&#xA;    原型链(prototype chain)                              # 原型，原型的原型 ...&#xA;        属性的查询先找自有属性，再找原型链&#xA;        属性修改时, 先检查属性是否允许赋值。&#xA;            总在自有属性修改或创建，不修改原型链上的对象。这就是属性的覆盖(override)&#xA;                继承的对象有setter方法且是accessor属性时，修改属性时会由当前对象(非原型对象)调用setter方法。&#xA;                由当前对象调用，所以还是不会修改原型链&#xA;                setter方法如setTitle()&#xA;    inherit(p)函数&#xA;        function inherit(p){&#xA;            if(p == null) throw TypeError();&#xA;            if(Object.create) return Object.create(p);&#xA;            var t = typeof p;&#xA;            if(t !== &amp;quot;object&amp;quot; &amp;amp;&amp;amp; t !== &amp;quot;function&amp;quot;) throw TypeError();&#xA;            function f(){};&#xA;            f.prototype = p;&#xA;            return new f();&#xA;        }&#xA;        var o = {x: &amp;quot;don&#39;t change this value&amp;quot;};&#xA;        library_function(inherit(o));                   # 可以防止对o的意外修改&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;数组&#34;&gt;&#xA;  数组&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e7%bb%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    数字索引                                             # 最大索引 2^32 - 2, 实现经过优化, 数字索引访问比访问常规属性快很多&#xA;    元素无类型&#xA;    数组是动态, 根据需要它们会增长或缩减&#xA;    数组可能是稀疏的, 索引不一定连续, length对于稀疏数组取最大索引+1&#xA;原理&#xA;    数组对象使用小于0 ~ 2^32 - 2 非负整数属性名时, 自动维护其length属性值&#xA;    [] 索引内的数字作为索引创建和访问, 其它作为属性&#xA;    a[&#39;1&#39;] 同 a[1] 同 a[1.000]&#xA;    数组可以原型继承, 可以定义getter, setter方法&#xA;    数组元素可以delete, in, for/in                        # delete a[0], 0 in a&#xA;稀疏数组&#xA;    稀疏数组比稠密数组更慢, 内存利用率更高, 查找元素与常规对象属性查找时间一样长&#xA;    for/in时会跳过未有元素&#xA;&#xA;    a = new Array(5)&#xA;    a = [, , ,]&#xA;    a = [1, , 3]                                        # 旧版本实现中, [1,,3]与[1,undefined, 3]是一样的，不是稀疏数组&#xA;    a[1000] = 0&#xA;创建与调用&#xA;    var misc = [1.1, , true]                            # 第二个是undefined&#xA;    new Array()&#xA;    new Array(10)                                       # 预分配数组空间&#xA;    new Array(5, 4, &amp;quot;testing&amp;quot;)&#xA;    a[0]        &#xA;    a.length    &#xA;        length大于每一个索引&#xA;        对lenght赋值, 小于length索引的元素将删除, 如length=0清空数组&#xA;            Object.defineProperty()让数组的length变成只读&#xA;            Object.defineProperty(a, &amp;quot;length&amp;quot;, {writable: false})来避免删除元素&#xA;            让数组无线不能配置也可以，如Object.seal, Object.freeze方法&#xA;添加删除&#xA;    a[1] = &amp;quot;a&amp;quot;;&#xA;    a.push(&amp;quot;zero&amp;quot;, &amp;quot;one&amp;quot;)&#xA;    delete a[1]&#xA;    a.pop()                                             # 反push&#xA;    a.shift()                                           # 头部删除, 重改所有元素索引&#xA;    a.unshift()                                         # 反shift, 头部插入元素&#xA;    splice()                                            # 通用方法插入, 删除, 替换数组元素, 根据需要修改length属性&#xA;遍历&#xA;    for(var i = 0; i &amp;lt; a.length; i++)                   # 判断undefined&#xA;    for(var index in a){                                # 会遍历出Array.prototype中的方法, 要进行过滤, ECMAScript 允许for/in遍历顺序不同, 一般是升序的, 如果同时有属性和元素，很可能是创建顺序&#xA;        if(!a.hasOwnProperty(i)) continue;&#xA;        // if(String(Math.floor(Math.abs(Nuber(i)))) !== i) continue;        # 跳过不是正整数的i&#xA;    }&#xA;    a.forEach(function(x){})                            # ECMAScript 5定义的新方法&#xA;多维数组                                                 # js不支持真正的多维数组，可以用数组模拟&#xA;    var a = new Array(10)&#xA;    a[0] = new Array(10)&#xA;    a[0][0]&#xA;空位问题&#xA;    Array(3)    // [, , , ]                             # 没有0位置, 但length = 3, 不同于有0位置但值为undefined, es5中对空位处理很不一致, 一般是跳过, es6会将空位值转为undefined&#xA;类数组对象                                               # 与数组相似的对象, 字符串虽然与数组类似，但length没有限制, 最好不看作类数组对象&#xA;    特性&#xA;        自动更新length属性, length设置后自动截断数组&#xA;        从Array.prototype中继承了一些有用的方法&#xA;        类属性(class)为&amp;quot;Array&amp;quot;(Date等类也是&amp;quot;Date&amp;quot;)&#xA;    创建                                                 # 数组的方法对于自定义的类数组对象是通用的, 虽然不能继承Array.prototype, 但可以间接调用Function.call&#xA;        要求&#xA;            自动维护length属性&#xA;            下标是数字字符串并在数组下标范围内&#xA;        var a = {&amp;quot;0&amp;quot;: &amp;quot;a&amp;quot;, &amp;quot;1&amp;quot;: &amp;quot;b&amp;quot;}&#xA;作为数组的字符串&#xA;    介绍&#xA;        ECMAScript 5中，字符串类似只读数组。访问如下&#xA;            s.charAt(0)&#xA;            s[0]&#xA;        Array.isArray(s)是false&#xA;        通用字符串方法可以乃至字符串中，如                   # 但字符串是不可变值的，所以中push, sort, reverse, splice在字符串上是无效的, 出错时没有提示&#xA;            Array.prototype.join.call(&#39;abc&#39;, &amp;quot; &amp;quot;)        # &amp;quot;a b c&amp;quot;&#xA;二进制数组&#xA;    介绍&#xA;        ArrayBuffer, TypedArray, DataView&#xA;        TypedArray按小端字节序来处理ArrayBuffer, 大端字节序可以自定义DataView&#xA;    TypedArray&#xA;        溢出&#xA;            正向溢出(overflow)&#xA;                uint8[0] = 256    // 0                  # 值为 数据类型最小值 + 余值 - 1, 这里为 0 + 1 - 1&#xA;                int8[0] = 128    // -128                # -128 + 1 - 1&#xA;            负向溢出(underflow)&#xA;                uint8[0] = -1    // 255                 # 值为 数据类型最大值 - 余值 + 1, 这里为 255 - 1 + 1&#xA;                int8[0] = -129    // 127                # 127 - 1 + 1&#xA;            Uint8ClampedArray负向溢出都为0, 正向溢出都为255&#xA;    场景&#xA;        o-&amp;gt;ajax中&#xA;        xhr.responseType设置为 &#39;arraybuffer&#39;来接收二进制数据(也可以设blob)&#xA;&#xA;        o-&amp;gt; canvas中&#xA;        ctx.getImageData(0, 0, canvas.width, canvas.height)&#xA;        uint8ClampedArray = imageData.data;&#xA;&#xA;        o-&amp;gt;　websocket中&#xA;        socket.binaryType = &#39;arraybuffer&#39;&#xA;        var arrayBuffer = event.data;&#xA;        socket.send(new Uint8Array(4).buffer);&#xA;&#xA;        o-&amp;gt; fetch api中&#xA;        返回request.arrayBuffer()得到arrayBuffer数据&#xA;&#xA;        o-&amp;gt; file api中&#xA;        reader.readAsArrayBuffer(file);&#xA;        reader.onload = function() { var arrayBuffer = reader.result; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;集合&#34;&gt;&#xA;  集合&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%86%e5%90%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;Set&#xA;    数据唯一&#xA;    Nan等于自身&#xA;WeakSet&#xA;    成员只能是对象&#xA;    成员弱引用，垃圾回收不考虑其引用，所以不能引用其成员，所以WeakSet不可遍历，因为刚遍历出的成员可能已删除&#xA;    可用于储存dom节点，实时判断是否存在，且防止内存泄漏&#xA;Map&#xA;    各种类型都可作为键, 键唯一覆盖, NaN等于自身, +0 等于 -0&#xA;WeakMap&#xA;    只接受对象作key&#xA;    元素被回收后, 自动移除对应的键值对&#xA;    适用于dom节点作键名，部署关联外部的私有属性(外部对象删除后，私有属性同步删除)，不会内存泄漏&#xA;遍历器&#xA;    介绍&#xA;        默认三种结构支持, Array, Set, Map。Object不支持，因为不确定遍历顺序&#xA;        字符串是类数组，有原生的iterator接口&#xA;    内部调用方式&#xA;        解构&#xA;            let [x, y] = new Set().add(1).add(2);&#xA;        扩展运算符&#xA;            [...iterable]&#xA;        yield* iterable&#xA;        参数&#xA;            for ... of&#xA;            Array.from()&#xA;            Map(), Set(), WeakMap(), WeakSet()&#xA;            Promise.all()&#xA;            Promise.race()&#xA;    实现&#xA;        iterable[Symbol.iterator] = function* () {&#xA;            yield 1;&#xA;            yield 2;&#xA;        }&#xA;        iterable[Symbol.iterator] = function () {&#xA;            return {&#xA;                next(){},&#xA;                return () { return {done: true}}        # return 在for ... of 提前退出(出错, break, continue), 可以用于释放资源, return 方法必须返回一个对象，这是Generator规格规定的&#xA;                throw() {}                              # 配合Generator使用&#xA;            };&#xA;&#xA;        }&#xA;    使用&#xA;        var result = iterator.next()&#xA;        while(!result.done) {&#xA;            var x = result.value;&#xA;            result = iterator.next();&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;proxy&#34;&gt;&#xA;  proxy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#proxy&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    元编程(meta programming), 在对象外层进行代理&#xA;    在obj.proxy上设置Proxy对象，该对象的操作会变成对Proxy对象的操作&#xA;&#xA;var obj = new Proxy({}, {&#xA;    get: function (target, key, receiver) {&#xA;        return Reflect.get(target, key, receiver);&#xA;    },&#xA;    set: function (target, key, value, receiver) {&#xA;        return Reflect.set(target, key, value, receiver);&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reflect&#34;&gt;&#xA;  reflect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reflect&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    将Object上一些明显属于语言内部的方法(如Object.defineProperty)放到Reflect上&#xA;    修改Object上原有方法，变得更合理, 如Object.defineProperty在无法定义属性时抛出异常, 而Reflect.definePropert则返回false&#xA;    让Object操作变成函数作为, 如name in obj, delete obj[name]变成Reflect.has, Reflect.deleteProperty&#xA;    让Proxy上方法与Reflect方法对应，让Proxy的对象操作默认行为在Reflect上执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;正则&#34;&gt;&#xA;  正则&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a3%e5%88%99&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;基本字符&#xA;    会精确匹配一段字符，如hi。这段字符可以出现多次&#xA;字面量&#xA;    /^[a-z]+$/.text(str);                   # ^代表开头, $是结尾&#xA;转义&#xA;    \&#xA;元字符                                       # metacharacter&#xA;    .                                       # 匹配除换行符以外任意字符&#xA;    \b&#xA;                                            # 表示单词的开头或结尾，也就是单词的分界。只匹配一个位置\s\S&#xA;        \bhi\b                              # hi单词&#xA;    \d                                      # 表示数字&#xA;    \s                                      # 匹配任意空白符，包括空格、tab、换行、中文全角空格等&#xA;        \s\S                                # 匹配包括\n在内的所有字符&#xA;    \w                                      # 匹配非特殊字符，包括字母、数字、下划线或汉字&#xA;    ^                                       # 匹配开头&#xA;    $                                       # 匹配结尾&#xA;    反义&#xA;        \W                                  # 非字符&#xA;        \S                                  # 非空白&#xA;        \D                                  # 非数字c&#xA;        \B                                  # 非单词位置&#xA;非&#xA;    [^x]                                    # 非x, [^aeiou] 除了aeiou以外的任意字符&#xA;限定字符&#xA;    {2}                                     # 表示前面的内容出现2次, {5, 12}内容出现5到12次, {5, }内容出现5或更多次&#xA;    ?                                       # 零次或一次&#xA;    *                                       # 零个或多个&#xA;    +                                       # 表示一个或多个&#xA;字符类&#xA;    [aeiou]                                 # 匹配其中的一个, [.?!] 匹配.或?或!&#xA;    [0-9]                                   # 同\d, [a-z0-9A-Z] 同\w&#xA;分枝条件&#xA;    |                                       # jpg|png,&#xA;        每个分支都从第一个分支开始匹配, 如\d{5}|\d{5}-d{4}只能匹配11111或11111-2222中的11111&#xA;分组                                         # 零宽断言只占用不消费&#xA;    ()&#xA;    语法&#xA;        (exp)&#xA;        (?&amp;lt;name1&amp;gt;exp)                       # 组命名&#xA;        (?:exp)                             # 消费exp, 不捕获匹配的文本，也不分配组号&#xA;        (?=exp)                             # 零宽断言，正向前瞻，后面能匹配表达式exp&#xA;            \b\w+(?=ing\b)                  # 匹配以ing结尾单词的前面部分，如dancing中的danc&#xA;            /(\w)\1{2}(?=(\w)\2{2})/g       # 匹配所有在3个连续相同字符前的相邻3个连续相同字符, aaalllsss0tAAAnnn999结果是aaa, lll, AAA, nnn&#xA;        (?&amp;lt;=exp)                            # 零宽断言，正向后瞻，前面能匹配表达式exp&#xA;            (?&amp;lt;=\bre)\w+\b                  # 匹配以re开头单词的后半部分，如reading中的ading&#xA;        (?!exp)                             # 零宽断言，负向前瞻，后面不匹配exp的位置, js不支持&#xA;            \b\w*q(?!u)\w*\b                # 匹配一个单词，该单词包含后面不是字母u的字母q&#xA;                &#xA;            \d{3}(?!\d)                     # 匹配三位数字，且它们后面不能有数字&#xA;            \b((?!abc)\w)+\b                # 匹配不包含连续字符串abc的单词&#xA;        (?&amp;lt;!exp)                            # 零宽断言，负向后瞻，前面不匹配exp的位置, js不支持&#xA;            (?&amp;lt;![a-z])\d{7}                 # 匹配前面不是小写字母的七位数字&#xA;        (?#comment)                         # 注释&#xA;后向引用                                     # 分组捕获后会自动编号，从左到右，1234。后向引用用于引用前面匹配到的文本，如 \1 代表分组1匹配的文本&#xA;    \b(\w+)\b\s+\1\b                        # 匹配重复的单词, 如go go&#xA;    (?&amp;lt;Word&amp;gt;\w+) 或 (?&#39;Word&#39;\w+)             # 把\w+的组名指定为Word, 用\k&amp;lt;Word&amp;gt;引用&#xA;贪婪与懒惰&#xA;    o-&amp;gt; 包含能接受重复限定符时，会匹配尽可能多的字符。如a.*b&#xA;    o-&amp;gt; a.*?b会懒惰匹配&#xA;        懒惰限定符&#xA;            *? 重复懒惰匹配任意次&#xA;            +? 重复懒惰匹配1次或多次&#xA;            ?? 重复懒惰匹配0次或1次&#xA;            {n, m}? 重复懒惰匹配n到m次&#xA;            {n,}? 重复懒惰匹配n次以上&#xA;平衡组/递归匹配&#xA;    (?&#39;group&#39;) 把捕获的内容命名为group，并压入栈(Stack)&#xA;    (?&#39;-group&#39;) 从栈中弹出最后压入的名为group的捕获内容。如果栈为空，则匹配失效&#xA;    (?(group)yes|no) 如果栈中存在名为group的捕获内容，继续匹配yes部分的表达式，否则则继续匹配no部分的表达式&#xA;    示例                                      # 平衡组最常见的应用是匹配HTML&#xA;        匹配xx&amp;lt;aa&amp;lt;bbb&amp;gt;&amp;lt;bbb&amp;gt;aa&amp;gt;yy&#xA;            思路&#xA;                每碰到左括号，就压入一个Open, 每碰到右括号，弹出一个&#xA;                最后看栈是否空，如果否则表示不配对，应该失败&#xA;                正则表达式引擎会进行回溯(放弃最前面或最后面一些字符), 尽量使整个表达式得到匹配&#xA;        &amp;lt;                                     # 最外层的左括号&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号的内容&#xA;        (&#xA;        (&#xA;        (?&#39;Open&#39;&amp;lt;)                            # 又碰到了左括号, 压入一个Open&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号内容&#xA;        )+&#xA;        (&#xA;        (?&#39;-Open&#39;&amp;gt;)                           # 碰到了右括号, 擦掉一个Open&#xA;        [^&amp;lt;&amp;gt;]*                                # 后面非括号内容&#xA;        )+&#xA;        )*&#xA;        (?(Open)(?!))                         # 负向前瞻，判断栈中还有没有Open, 有则匹配失败&#xA;        &amp;gt;                                     # 最外层右括号&#xA;        )&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;特点&#34;&gt;&#xA;  特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; js中不支持 回顾后发断言&#xA;o-&amp;gt; 可以跟三个flag，比如/something/igm&#xA;    i表示不区分大小写&#xA;    g表示匹配多个&#xA;        g会影响String.prototype.match()和RegExp.prototype.exec()的行为&#xA;        match中加g会返回数组，不加g返回比较详细的信息&#xA;        exec中加g，且正则存在变量中时,该正则变量执行exec后会存储信息, 如&#xA;        var re = /h(.*?)\b/g;&#xA;        re.exec(&#39;hello helloo&#39;) 执行三次，匹配内容有变化&#xA;    m表示，^$可以匹配每一个的开头和结尾&#xA;o-&amp;gt; api&#xA;    RegExp&#xA;        exec                                    # 执行第一个, exp本身保留执行状态&#xA;            exp = /#/&#xA;            exp.exec(&#39;##&#39;)&#xA;        test&#xA;    String&#xA;        replace                                 # 替换第一个, &#39;abc - 123 - #$*&#39;&#xA;            &#39;John Smith&#39;.replace(/(\w+)\s(\w+)/, &#39;$2, $1&#39;)&#xA;            &#39;abc123#$*&#39;.replace(/([^\d]*)(\d*)([^\w]*)/, function replacer(match, p1, p2, p3, offset, string) {&#xA;            return [p1, p2, p3].join(&#39; - &#39;);&#xA;            });&#xA;        replaceAll&#xA;        match                                   # 不能有g选项，只得到第一个匹配&#xA;&#xA;.net中处理选项&#xA;    IgnoreCase                                  # 忽略大小写&#xA;    Multiline                                   # 多行模式, 更改^$的含义为一行首和行尾, $表示\n之前的位置以及字符串结束前的位置&#xA;    Singleline                                  # 单行模式(可以与Multiline通用)，更改.的含义，便它与每一个字符匹配(包括\n)&#xA;    IgnorePatternWhitespace                     # 忽略空白，会忽略表达式中非转义空白并启用#作为标记注释&#xA;    ExplicitCapture                             # 显式捕获，仅捕获已被显式命名的组&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;常用&#34;&gt;&#xA;  常用&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;a[^&amp;gt;]+&amp;gt;&#xA;    # 用尖括号括起来的以a开头的字符串&#xA;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$&#xA;    # 密码的强度必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间&#xA;^[\\u4e00-\\u9fa5]{0,}$&#xA;    # 字符串只能是中文&#xA;^\\w+$&#xA;    # 由数字，26个英文字母或下划线组成的字符串&#xA;[\\w!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?&#xA;    # 校验E-Mail 地址&#xA;^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$&#xA;    # 校验身份证号码 15位&#xA;^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$&#xA;    # 校验身份证号码 18位&#xA;^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$&#xA;    # “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年&#xA;^[0-9]+(.[0-9]{2})?$&#xA;    # 金额校验，精确到2位小数&#xA;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$&#xA;    # 国内 13、15、18开头的手机号正则表达式&#xA;^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$&#xA;    # 判断IE的版本&#xA;\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&#xA;    # 校验IP-v4地址&#xA;(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))&#xA;    # 校验IP-v6地址&#xA;/^[a-zA-Z]+:\\/\\//&#xA;    # 检查URL的前缀&#xA;^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;amp;=]*)?&#xA;    # 提取URL链接&#xA;^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&amp;quot;&amp;lt;&amp;gt;|]+\\.txt(l)?$&#xA;    # 文件路径及扩展名校验&#xA;^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$&#xA;    # 提取Color Hex Codes&#xA;\\&amp;lt; *[img][^\\\\&amp;gt;]*[src] *= *[\\&amp;quot;\\&#39;]{0,1}([^\\&amp;quot;\\&#39;\\ &amp;gt;]*)&#xA;    # 提取网页图片&#xA;(&amp;lt;a\\s*(?!.*\\brel=)[^&amp;gt;]*)(href=&amp;quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&amp;quot;]+)&amp;quot;((?!.*\\brel=)[^&amp;gt;]*)(?:[^&amp;gt;]*)&amp;gt;&#xA;    # 提取页面超链接&#xA;^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}&#xA;    # 查找CSS属性&#xA;&amp;lt;!--(.*?)--&amp;gt;&#xA;    # 抽取注释&#xA;&amp;lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&amp;quot;.*?&amp;quot;|&#39;.*?&#39;|[\\^&#39;&amp;quot;&amp;gt;\\s]+))?)+\\s*|\\s*)\\/?&amp;gt;&#xA;    # 匹配HTML标签&#xA;&#39;12345678901&#39;.replace(/(\d{3})\d{4}(\d{4})/, &#39;$1****$2&#39;)&#xA;    # 替换中四位到*&#xA;&#39;1111111&#39;.replace(/([\d]{3})(?=[\d]+)/g, &#39;$1-&#39;)&#xA;    # 替换为 &#39;111-111-1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;元字符扩展&#34;&gt;&#xA;  元字符扩展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%83%e5%ad%97%e7%ac%a6%e6%89%a9%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;\a              # 报警字符&#xA;\t              # 制表符&#xA;\v              # 竖向制表符&#xA;\r              # 回车&#xA;\f              # 换页符&#xA;\n              # 换行符&#xA;\e              # Escape&#xA;\0nn            # ASCII码中八进制代码为nn的字符&#xA;\xnn            # ASCII码中十六进制代码为nn的字符&#xA;\unnnn          # Unicode码中十六进制代码为nnnn的字符&#xA;\cN             # ASCII控制字符，如\cC 代表ctrl + c&#xA;\A              # 字符串开头，同^但不受多行选项影响&#xA;\Z              # 字符串结尾或行尾，不受多行选项影响&#xA;\z              # 字符串结尾，同$但不受多行选项影响&#xA;\G              # 当前搜索的开头&#xA;\p{name}        # Unicode中命名为name的字符类，如\p{IsGreek}&#xA;(?&amp;gt;exp)         # 贪婪子表达式&#xA;(?&amp;lt;x&amp;gt;-&amp;lt;y&amp;gt;exp)   # 平衡组&#xA;(?im-nsx:exp)   # 在子表达式exp中改变处理选项&#xA;(?im-nsx)       # 为表达式后面的部分改变处理选项&#xA;(?(exp)yes|no)  # 把exp当作零宽正向先行断言，如果能匹配，使用yes作为此组表达式，否则使用no&#xA;    (?(exp)yes) 只使用空表达式为no&#xA;    (?(name)yes|no) 命名为name的组捕获到内容，使用yes&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;风格&#34;&gt;&#xA;  风格&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a3%8e%e6%a0%bc&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;o-&amp;gt; 最好js和html用独立的引号风格，如&#xA;        html双引号, js单引号&#xA;o-&amp;gt; 始终用var之类来声明变量，不用未声明变量&#xA;&#xA;o-&amp;gt; let和const取代var, 全局常量使用const&#xA;&#xA;o-&amp;gt; 特意将变量声明放在函数体顶部, 而不是使用变量之外, 来反映真实的作用域声明提前&#xA;&#xA;o-&amp;gt; 多用解构&#xA;    const [first, second] = arr                 # 数组取元素&#xA;    function f({a, b}) {}                       # 对象解构给函数赋值&#xA;    function f() {return {a, b}}, const {a, b} = f()                # 函数返回值解构&#xA;    var arr2 = [...arr]                         # 扩展运算符拷贝数组&#xA;&#xA;o-&amp;gt; 单行定义对象不逗号结尾(以后不扩展), 多行时逗号结尾(以后可能会扩展), 尽量用简洁的写法&#xA;    {a: 1, b}&#xA;    {&#xA;        [getKey(&#39;a&#39;)],&#xA;    }&#xA;&#xA;o-&amp;gt; Array.from转换类数组到数组&#xA;&#xA;o-&amp;gt; 匿名函数 (() =&amp;gt; {})(), 同时绑定了this为当前作用域&#xA;&#xA;o-&amp;gt; 不使用arguments, 使用rest运算符&#xA;&#xA;o-&amp;gt; 函数使用默认值 function f (opts = {})  {}&#xA;&#xA;o-&amp;gt; 用Map取代Object, 因为Map内建遍历机制, key可为对象。只能要数据转换时用Object&#xA;&#xA;o-&amp;gt; 总是用class取代需要的prototype操作, 因为class写法更简洁。extends也更简单, 不会有破坏instanceof运算的危险&#xA;&#xA;o-&amp;gt; 模块使用es6的机制, 模块只能一个输出时用export default, 多输出时用export, 不要export 和export default混合使用&#xA;&#xA;o-&amp;gt; 运算符&#xA;var t = o &amp;amp;&amp;amp; o.a || &#39;&#39;                          # 有o时取o.a, 无o时取&#39;&#39;, 因为&amp;amp;&amp;amp;的优先级比||高&#xA;var ifExist = !!o.a                             # 转换成布尔类型, 当然o.a = 0 什么的值时， 会判断失误，所以用来判断对象&#xA;&#xA;o-&amp;gt; 判断类型&#xA;typeof a === &amp;quot;string&amp;quot;                           # 数组等其他Object类型通通是Object&#xA;a instanceof Array                              # 判断Object类型的具体类型&#xA;a.constructor == Array                          # 判断构造函数&#xA;Object.prototype.toString.call(o) === &#39;[object Array]&#39;              # 用toString判断&#xA;&#xA;o-&amp;gt; 柯里化&#xA;function currying (fn, n) {&#xA;    return function (m) {&#xA;        return fn.call(this, m, n);&#xA;    }&#xA;}&#xA;function tailFactorial(n, total) {              # 尾递归调用优化&#xA;    if(n === 1) return total;&#xA;    return tailFactorial (n - 1, n * total);&#xA;}&#xA;const factorial = currying(tailFactorial, 1);&#xA;factorial(5)&#xA;&#xA;o-&amp;gt; 尾递归&#xA;function factorial (n, total = 1) {&#xA;    if(n === 1) return total;&#xA;    return factorial(n - 1, n * total);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;浏览器&#34;&gt;&#xA;  浏览器&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8f%e8%a7%88%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;js执行顺序&#xA;    当页面载入时，会执行位于 body 部分的 JavaScript。&#xA;    当被调用时，位于 head 部分的 JavaScript 才会被执行。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;常用函数&#34;&gt;&#xA;  常用函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础扩展&#34;&gt;&#xA;  基础扩展&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e6%89%a9%e5%b1%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;循环变量作用域&#xA;    function constfunc(v){&#xA;        return function(){return v}&#xA;    }&#xA;    var funcs = []&#xA;    for(var i = 0; i &amp;lt; 10; i++){&#xA;        funcs[i] = constfunc(i)&#xA;    }&#xA;闭包序列&#xA;    var uniqueInteger = (function(){&#xA;        var counter = 0;&#xA;        return function(){return counter++;}&#xA;    }());&#xA;    seq  = uniqueInteger()&#xA;    id = seq()&#xA;闭包计数器&#xA;    function counter(){&#xA;        var n = 0;&#xA;        return {&#xA;            count: function(){return n++;},&#xA;            reset: function(){n = 0;}&#xA;        };&#xA;    }&#xA;属性存取器&#xA;    function counter(n){&#xA;        return{&#xA;            get count() {return n++},&#xA;            set count(m){&#xA;                if(m &amp;gt;= n) {n = m }&#xA;                else {throw Error(&amp;quot;count can only be et to a larger value&amp;quot;)}&#xA;            }&#xA;        }&#xA;    }&#xA;    var c = counter(1000);&#xA;    c.count;&#xA;属性define&#xA;    Object.defineProperty(Object.prototype, &amp;quot;extend&amp;quot;, {&#xA;        writable: true,&#xA;        enumerable: false,&#xA;        configurable: true,&#xA;        value: function(o){&#xA;            var names = Object.getOwnPropertyNames(o);&#xA;            for(var i = 0; i &amp;lt; names.length; i++){&#xA;                if(names[i] in this) continue;&#xA;                var desc = Object.getOwnPropertyDescriptor(o, names[i]);&#xA;                Object.defineProperty(this, names[i], desc);&#xA;            }&#xA;        }&#xA;    });&#xA;私有属性&#xA;    function addPrivateProperty(o, name, predicate){&#xA;        var value;&#xA;        o[&amp;quot;get&amp;quot; + name] = function(){return value;}&#xA;        o[&amp;quot;set&amp;quot; + name] = function(v){&#xA;            if(predicate &amp;amp;&amp;amp; ! predicate(v)) {throw Error(&amp;quot;set&amp;quot; + name + &amp;quot;: invalid value &amp;quot; + v)}&#xA;            else {value = v}&#xA;        };&#xA;    }&#xA;    var o = {}&#xA;    addPrivateProperty(o, &amp;quot;Name&amp;quot;, function(x){ return typeof x == &amp;quot;string&amp;quot;;});&#xA;    o.setName(&amp;quot;A&amp;quot;);&#xA;    o.setName(o);&#xA;嵌套属性名&#xA;    function getAllPropertyNames = function(obj){&#xA;        var props = [];&#xA;        do {&#xA;            props = props.concat(Object.getOwnPropertyNames(obj));&#xA;        } while (obj = Object.getPrototypeOf(obj));&#xA;        return props;&#xA;    }&#xA;嵌套属性名2&#xA;    function keys(o){&#xA;        if(typeof o !== &amp;quot;object&amp;quot;) throw TypeError();&#xA;        var result = [];&#xA;        for(var prop in o){&#xA;            if(o.hasOwnProperty(prop))&#xA;            result.push(prop);&#xA;        }&#xA;        return result;&#xA;    }&#xA;嵌套累加&#xA;    function flexisum(a){&#xA;        var total = 0;&#xA;        for(var i = 0; i &amp;lt; arguments.length; i++) {&#xA;            var element = arguments[i], n;&#xA;            if(element == null){&#xA;                continue;&#xA;            } else if(isArray(element)){&#xA;                n = flexisum.apply(this, element);&#xA;            } else if(typeof element === &amp;quot;function&amp;quot;){&#xA;                n = Number(element());&#xA;            } else{&#xA;                n = Number(element);&#xA;            }&#xA;            if(isNaN(n)){&#xA;                throw Error(&amp;quot;flexisum(): can&#39;t convert &amp;quot; + element + &amp;quot; to number&amp;quot;);&#xA;            }&#xA;            total +=n;&#xA;        }&#xA;        return total;&#xA;    }&#xA;泛函代理, monkey-patching &#39;this&#39;&#xA;    function trace(o, m){&#xA;        var original = o[m];&#xA;        o[m] = function(){&#xA;            return original.apply(this, arguments);&#xA;        }&#xA;    }&#xA;兼容ECMAScript 3实现bind&#xA;    function bind(f, o){&#xA;        if(f.bind) {return f.bind(o)}&#xA;        else {&#xA;            return function(){&#xA;                return f.apply(o, arguments);&#xA;            }&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;函数式&#34;&gt;&#xA;  函数式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;thunk&#xA;    function thunk (fileName) {&#xA;        return function (callback) {&#xA;            return fs.readFile(fileName, callback)&#xA;        }&#xA;    }&#xA;extend, 同名覆盖&#xA;    function extend(o, p){&#xA;        for(prop in p){&#xA;            o[prop] = p[prop];&#xA;        }&#xA;        return o&#xA;    }&#xA;merge, 同名不覆盖&#xA;    function merge(o, p){&#xA;        for(prop in p){&#xA;            if(o.hasOwnProperty[prop]) {continue}&#xA;            o[prop] = p[prop];s&#xA;        }&#xA;        return o;&#xA;    }&#xA;restrict, 删除非公共属性&#xA;    function restrict(o, p){&#xA;        for(prop in o){&#xA;            if(!(prop in p)) delete o[prop];&#xA;        }&#xA;        return o;&#xA;    }&#xA;substract, 删除公共属性&#xA;    function subtract(o, p){&#xA;        for(prop in p){&#xA;            delete o[prop];&#xA;        }&#xA;        return o;&#xA;    }&#xA;union, extend产生新对象&#xA;    function union(o, p) { return extend(extend({}, o), p);}&#xA;intersection, restrict产生新对象&#xA;    function intersection(o, p){ return restrict(extend({}, o), p);}&#xA;mixin&#xA;    function mix (...mixins) {&#xA;        class Mix {}&#xA;        for (let mixin of mixins) {&#xA;            copyProperties(Mix, mixin);&#xA;            copyProperties(Mix.prototype, mixin.prototype);&#xA;        }&#xA;        return Mix;&#xA;    }&#xA;    function copyProperties(target, source) {&#xA;        for(let key of Reflect.ownKeys(source)) {&#xA;            if(key !== &#39;constructor&#39;&#xA;                &amp;amp;&amp;amp; key !== &#39;prototype&#39;&#xA;                &amp;amp;&amp;amp; key !== &#39;name&#39;) {&#xA;                let desc = Object.getOwnPropertyDescriptor(source, key);&#xA;                Object.defineProperty(target, key, desc);&#xA;            }&#xA;        }&#xA;    }&#xA;混合继承&#xA;    class A extends mix(B, C) {}&#xA;mixins方法不被覆盖&#xA;    let Mixin1 = (superclass) =&amp;gt; class extends superclass {&#xA;        foo () {if(super.foo) super.foo()}&#xA;    }&#xA;    let Mixin2 = (superclass) =&amp;gt; class extends superclass {&#xA;        foo () {if(super.foo) super.foo()}&#xA;    }&#xA;    class S {&#xA;        foo() {}&#xA;    }&#xA;    class C extends Mixin1(Mixin2(s)) {&#xA;        foo() {super.foo()}&#xA;    }&#xA;    new c().foo()        // C, Mixin1, Mixin2, S&#xA;trait&#xA;    # 同mixins 额外功能: 防止同名方法冲突, 排除混入某些方法，为混入方法起别名等&#xA;    @traits(A, B)&#xA;    class C()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;generator-1&#34;&gt;&#xA;  generator&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#generator-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;状态机 generator clock&#xA;    var clock = function* (_) {&#xA;        while(true) {&#xA;            yield _;&#xA;            console.log(&#39;Tick&#39;);&#xA;            yield _;&#xA;            console.log(&#39;Tock&#39;);&#xA;        }&#xA;    }&#xA;    非generator实现&#xA;        var ticking = true;&#xA;        var clock = function() {&#xA;            if (ticking) {console.log(&#39;Tick&#39;);}&#xA;            else {console.log(&#39;Tock&#39;);}&#xA;            ticking = !ticking&#xA;        }&#xA;递归next&#xA;    function run(fn) {&#xA;        var gen = fn();&#xA;        function next (err, data) {&#xA;            var result = gen.next(data);&#xA;            if (result.done) {return result.value;}&#xA;            result.value(next);&#xA;        }&#xA;        next();&#xA;    }&#xA;    run(gen);&#xA;generator, promise, 递归next2&#xA;    var readFile = function(fileName) {&#xA;        return new Promise(function (resolve, reject) {&#xA;            fs.readFile(fileName, function(err, data) {&#xA;                if(err) {reject(err);}&#xA;                resolve(data);&#xA;            })&#xA;        })&#xA;    }&#xA;    var gen = function* () {&#xA;        var f1 = yield readFile(&#39;/etc/fstab&#39;);&#xA;    }&#xA;    function run(gen) {&#xA;        var g = gen();&#xA;        function next(data) {&#xA;            var result = g.next(data);&#xA;            if (result.done) {return result.value;}&#xA;            result.value.then(function(data) {&#xA;                next(data);&#xA;            })&#xA;        }&#xA;        next()&#xA;    }&#xA;    run(gen);&#xA;co, thunkify&#xA;    var readFile = thunkify(fs.readFile);&#xA;    var gen = function* () {&#xA;        var r1 = yield readFile(&#39;/etc/fstab&#39;);&#xA;        var r2 = yiled readFile(&#39;/etc/shells&#39;)&#xA;    }&#xA;    co(gen)&#xA;mixins注解&#xA;    function mixins (...list) {&#xA;        return function (target) {&#xA;            Object.assign(target.prototype, ...list)&#xA;        }&#xA;    }&#xA;    const Foo = {&#xA;        foo() {}&#xA;    }&#xA;    @mixins(Foo)&#xA;    class MyClass()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;api&#34;&gt;&#xA;  api&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#api&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;全局&#34;&gt;&#xA;  全局&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a8%e5%b1%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    Infinity                                # 表示正无穷大&#xA;    NaN                                     # 指示是不是数字, Infinity与NaNECMAScript中可读写， ECMAScript修正为只读, Infinity与NaN与任何值不相等(包括自身), 建议用非来判断&#xA;    undefined&#xA;    console&#xA;        log(&#39;abc %s&#39;, &#39;d&#39;)                  # &#39;abc d&#39;, 格式化输出&#xA;&#xA;方法&#xA;    parseFloat                              # 可以解析整数和浮点数, 跳过前导空格, 忽略后面非数字内容。第一个非空格字符是非法数字直接量时，返回NaN&#xA;    parseInt                                # 只解析整数, 可接收第二个可选参数，指定数字转换基数&#xA;        &amp;quot;0x&amp;quot;, &amp;quot;0X&amp;quot;前缀, 解析为16进制数&#xA;    isNaN&#xA;    isFinite                                # NaN, Infinity 不通过, 非数字报错&#xA;    escape                                  # deprecated since ECMAScript v3&#xA;    decodeURI                               # 不处理 =, &amp;amp; 等&#xA;    decodeURIComponent                      # 会处理 =, &amp;amp; 等&#xA;    encodeURI&#xA;    encodeURIComponent&#xA;    eval                                    # 可以访问调用时的整个作用域，所以编译器不能裁剪作用域, 要间接调用, 如 (0, eval)(src)&#xA;    requestAnimationFrame&#xA;    fetch&#xA;        fetch(url).then(function (request) { return request.arrayBuffer })&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;构造函数&#34;&gt;&#xA;  构造函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;包装对象函数&#34;&gt;&#xA;  包装对象函数&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8c%85%e8%a3%85%e5%af%b9%e8%b1%a1%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    基本类型(数字，布尔，字符串)在构建时，会通过new String(s)的方式转换成对象，有了对象的方法，这个过程就是包装对象&#xA;undefined没有包装对象，所以访问属性会造成类型错误。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;string&#34;&gt;&#xA;  String&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    是Object类型, 是基本类型string的包装类型&#xA;        引用字符串类型的属性时,js会调用new String(s)来转换成对象&#xA;            属性引用结束, 该新对象销毁&#xA;            实际上有优化&#xA;包装测试&#xA;    自动包装测试&#xA;        1.toString                          # 异常&#xA;        (1).toString                        # =&amp;gt; &amp;quot;1&amp;quot;&#xA;    原始类型属性只读&#xA;        var s = &amp;quot;test&amp;quot;;&#xA;        s.len = 4;                          # 相当于new String(&amp;quot;test&amp;quot;).len = 4&#xA;        s.len   // undefined                # 相当于new String(&amp;quot;test&amp;quot;).len&#xA;    运算&#xA;        ==                                  # 原始类型与包装类型相等&#xA;        ===                                 # 原始类型与包装类型不相等&#xA;语法&#xA;    ECMAScript 5中，可以用数组方式访问16位值, 如&#xA;        s[0]&#xA;属性&#xA;    length                                  # 4字节的字符会误判为2&#xA;&#xA;静态方法&#xA;    localCompare()                          # 参照本地语言字母表字符次序&#xA;    fromCodePoint()                         # 支持4字节字符值转换, 多参数时合并成字符串&#xA;    raw                                     # 一个tag函数, 转义模板字符串到字符串&#xA;        String.raw`\n${2 + 3}`              # &#39;\\n5&#39;&#xA;        String.raw({raw: &#39;test&#39;}, 0, 1, 2)  # 正常调用时, 第一个参数对象中必要有raw属性，其值为tag函数的第一个字符串数组的参数。其余参数与tag函数其余参数对应&#xA;                &#xA;方法&#xA;    substring(1, 4) // =&amp;gt; 返回第2~4个字符     # 与java不同，java是第1~3个&#xA;    slice(1, 4)&#xA;    indexOf(&amp;quot;&amp;quot;)&#xA;    lastIndexOf(&amp;quot;&amp;quot;)&#xA;    toUpperCase()&#xA;    charAt(0)                               # 取2个字节的字符&#xA;    charCodeAt()                            # 取2个字节字符的十进制值&#xA;    codePointAt()                           # index位的4字节字符当作一个字符，正确处理，得到十进制值, index+1位会取该4字节字符的后2字节, 为了匹配length属性&#xA;    at()                                    # 支持4字节字符, 匹配正确长度的方法&#xA;    fromCharCode()                          # 2字节字符值转换到字符&#xA;    normalize()&#xA;        &#39;\u01D1&#39;.normalize() === &#39;\u004F\u030C&#39;.normalize()&#xA;            原重音符号与 (字符 + 重音)合成符等价&#xA;        不支持3个及以上字符合成&#xA;    includes                                # s.includes(&#39;o&#39;, 6) 从6位置开始搜索o是否出现&#xA;    startsWith&#xA;    endsWith                                # s.endsWith(&#39;o&#39;, 6) 前6个字符是否以o结尾&#xA;    repeat(3)                               # 字符串重复3次返回&#xA;    padStart                                # &#39;x&#39;.padStart(5, &#39;ab&#39;) 返回 &#39;ababx&#39;, padStart(5)会填充空格&#xA;    padEnd&#xA;    正则                                    # es6中内部调用RegExp.prototype[Symbol.match]等方法&#xA;        search(pattern)                     # 返回首次匹配成功的位置&#xA;        match(pattern)                      # 所有匹配位置的数组&#xA;        replace(pattern, &amp;quot;&amp;quot;)                # 所有匹配替换&#xA;        split(pattern)                      # 匹配分割&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;number&#34;&gt;&#xA;  Number&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#number&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    NaN&#xA;    POSITIVE_INFINITY&#xA;    NEGATIVE_INFINITY&#xA;    MAX_VALUE&#xA;    MIN_VALUE&#xA;    EPSILON                                 # 极小的常量 2.22....e-16, 用来设置浮点计算的一个合理误差范围&#xA;    MAX_SAFE_INTEGER                        # 越界最大值&#xA;    MIN_SAFE_INTEGER                        # 越界最小值&#xA;静态方法&#xA;    isFinite&#xA;    isNaN&#xA;    isInteger&#xA;    isSafeInteger                           # 判断是否越界&#xA;    parseInt&#xA;    parseFloat&#xA;        &#xA;方法&#xA;    字符串解析&#xA;        构造方法                            # 只基于十进制转换&#xA;        调用全局函数parseInt(), parseFloat()&#xA;    转换为字符串&#xA;        toString()                          # Number类的toString()可接收转换基数, 来转换进制&#xA;            如 n.toString(2); n.toStrng(8); n.toString(16)&#xA;        toFixed(0)                          # 保留几位小数, 从不使用指数计数法&#xA;        toExponential(1)                    # 转换为指数, 参数为指数前保留几位小数&#xA;        toPrecision(4)                      # 保留有效数字，多出位数转换成指数, 以上三个方法自动补0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;boolean&#34;&gt;&#xA;  Boolean&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#boolean&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;h3 id=&#34;object&#34;&gt;&#xA;  Object&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#object&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    __proto__&#xA;        用来读取或设置当前对象的prototype对象，只有浏览器必须部署这个属性&#xA;        语义上是内部属性，被支持仅因为被广泛使用&#xA;动态方法&#xA;    hasOwnProperty&#xA;         是否有某属性，可判断属性值为undefined的情况&#xA;         没prototype的对象, 该方法直接调用失败，需要Object.prototype.hasOwnProperty.call来调用&#xA;    propertyIsEnumerable&#xA;    isPrototypeOf&#xA;        b.isPrototypeOf(c)                  # b是否出现在c的prototype链中&#xA;    toString&#xA;    toLocaleString&#xA;        返回对象的本地化字符，默认时仅调用toString方法&#xA;        Date和Number对toLocaleString做了定制&#xA;        Array的toLocalString对每个数组元素调用toLocaleString方法&#xA;            toString会对每个数组元素调用toString方法&#xA;    *toJSON&#xA;        Object.prototype没有定义这个方法, JSON.stringigy会调用要序列化对象的toJSON方法,如Date.toJSON()&#xA;    valueOf&#xA;        要将对象转换为原始值时调用&#xA;        如果需要使用原始值的上下文中使用了对象，会自动调用这个方法&#xA;静态方法&#xA;    create                                  # new会执行构造方法，有副作用&#xA;        Object.create(null)                 # 创建的对象没有prototype，不同于{}&#xA;    getPrototypeOf                          # 用于判断继承&#xA;            Object.getPrototypeOf(B) === A&#xA;    getOwnPropertyNames                     # 所有自身属性&#xA;    getOwnPropertyDescriptor(obj, &#39;foo&#39;)    # 获得属性的描述对象&#xA;    getEnumPropertyNames                    # 可枚举自身属性和继承属性&#xA;    setPrototypeOf                          # 标准可靠的方法修改对象prototype的关联&#xA;            Object.setPrototypeOf(Bar.prototype, Foo.prototype)     # 同Bar.prototype = Object.create(Foo.prototype)&#xA;    keys                                    # 可枚举自身属性&#xA;    defineProperty                          # 数据描述符，getter、setter是访问描述符&#xA;        # 修改属性，在原型链上层属性为writable: false或有对应属性的setter时，不会发生屏蔽。使用defineProperty可发生屏蔽&#xA;        Object.defineProperty(Object, &#39;is&#39;, {&#xA;                value: function (x, y) {...},&#xA;                configurable: true,         # false时，delete该属性会静默失败&#xA;                enumerable: false,&#xA;                writable: true,&#xA;                get: function(){return 1}&#xA;        })&#xA;    toLocaleString&#xA;    toString                                # toString(16) 转换为16进制&#xA;    is(&#39;foo&#39;, &#39;foo&#39;)                        # 比较两个值是否相等, 基本是===，不同在于, +0 等于 -0, NaN 等于 NaN&#xA;    assign(target, source1, source2)&#xA;        复制源对象自身可枚举属性到目标对象, source2覆盖source2覆盖target&#xA;        Symbol值的属性也会被拷贝&#xA;        _.defaultsDeep方法可以深拷贝&#xA;        常用于给对象添加静态方法或方法，合并对象，为属性指定默认值&#xA;            Object.assign({}, DEFAULTS, options);&#xA;    preventExtensions                       # 使对象不可设置属性&#xA;    isExtensible&#xA;    seal                                    # 创建“密封”对象, 在现有对象上调用preventExtensions并把现在属性标记为configurable: false&#xA;    freeze                                  # 调用seal并标记现有属性为writable: false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;array&#34;&gt;&#xA;  Array&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#array&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;静态方法&#xA;    isArray(a)                              # ECMAScript 5 判断是否数组&#xA;            [] instanceof Array的问题&#xA;                多frame中有多个js环境, 都有自己的全局对象与构造函数。一个窗体中的对象是当前窗体构造函数创建，而另外窗体构造函数判断该对象则不成立。&#xA;                    # 但窗体间的混淆不常发生&#xA;            ECMAScript 3 可以检查对象类属性来判断。&#xA;                # 实际上就是ECMAScript 5中Array.isArray的代码&#xA;                var isArray = Array.isArray || function(o){&#xA;                    return typeof o === &amp;quot;ojbect&amp;quot; &amp;amp;&amp;amp; Object.prototype.toString.call(o) == &amp;quot;[object Array]&amp;quot;&#xA;                };&#xA;    from&#xA;        # 类数组对象或可遍历对象(如Set, Map)转为数组，转换后的数组具有了iterator接口&#xA;        # 类数组对象同[].slice.call(arraylike), 可遍历对象同[...traversable]&#xA;        Array.from(arraylike)&#xA;        Array.from([1, , 2, , 3], (n) =&amp;gt; n || 0)&#xA;        Array.from(&#39;abc&#39;)&#xA;            # 字符串转数组&#xA;        Array.from(new Set(array))&#xA;            # 去除重复元素&#xA;    of&#xA;        # 一组值转换为数组, 用于替代Array(), new Array()&#xA;        # 弥补Array()的返回不一致问题, 如Array(3) // [, , ,]&#xA;        Array.of(1, 2, 3)        // [1, 2, 3]&#xA;动态方法&#xA;    join, ...                               # firefox1.5 后 动态方法也写入到了静态方法中。但不是标准, 是String.split()的逆向操作&#xA;        a.join()                                // =&amp;gt; &amp;quot;1,2,3&amp;quot;&#xA;        a.join(&amp;quot;&amp;quot;)                        // =&amp;gt; &amp;quot;123&amp;quot;&#xA;        new Array(2).join(&#39;-&#39;)                // =&amp;gt; &amp;quot;--&amp;quot;&#xA;    reverse                                 # 倒序&#xA;        a.reverse()&#xA;    sort                                    # 排序&#xA;        a.sort()                            # 默认以字母表排序, 自动转字符串 undefined排到最后&#xA;        a.sort(function(a, b){&#xA;            return a-b;                     # a在前, 返回负数。b在前返回正数。0表示相等，顺序无关紧要, 此处是升序排列&#xA;        })&#xA;    concat                                  # 连接数组, 创建返回一个新数组, 传入数组, 连接数组元素而非本身, 但不扁平化数组的数组&#xA;        a.concat(4, [5, [6, 7]])&#xA;    slice                                   # 截取新数组&#xA;        var a = [1,2,3,4,5]&#xA;        a.slice(0,3)    // 返回 [1,2,3]&#xA;        a.slice(3)      // 返回 [4,5]&#xA;        a.slice(1, -1)  // 返回 [2,3,4]&#xA;        a.slice(-3, -2) // 返回 [3]&#xA;    splice                                  # 修改数组&#xA;        第一个参数起始位置(包含), 第二个参数删除个数(省略则从起始到结束都删除)&#xA;        后面任意个参数指定插入到数组中的元素&#xA;        返回由删除元素组成的数组&#xA;    push 和 pop                              # 数组作为栈(先进后出)来用, push在结尾添加, pop在结尾删除, 插入元素时不解封数组&#xA;    unshift 和 shift                         # unshift在头部添加元素, shift在头部删除。都改变索引, 插入元素时不解封数组&#xA;    toString                                # 调用每个元素的toString()方法, 输出有逗号分隔的字符串列表(没有方括号), 与不使用任何参数的join()是一样的&#xA;    toLocaleString                          # 调用元素的toLocaleString&#xA;    copyWithin                              # 当前数组中复制一段到另一位置&#xA;        [1, 2, 3, 4, 5].copyWithin(0, 3)        // [4, 5, 3, 4, 5]&#xA;            # 第三个参数是结束位置(不包含), 默认是结尾。把4, 5 复制替换到1, 2&#xA;        [1, 2, 3, 4, 5].copyWithin(0, -2, -1)        // [4, 2, 3, 4, 5]&#xA;            # 4到5(不包含)复制到1&#xA;    find                                    # 返回第一个符合条件的元素, 没有时返回undefined, 可处理NaN, 第二个参数绑定回调函数的this对象&#xA;        [1, 4, -5, 10].find((n) =&amp;gt; n &amp;lt; 0)&#xA;    findIndex                               # 返回第一个符合条件的index, 没有时返回-1&#xA;    fill                                    # 用某元素填充数组, 可标识起始位置&#xA;        [1, 2, 3].fill(0)        // [0, 0, 0]&#xA;        [1, 2, 3].fill(0, 1, 2)        // [1, 0, 3]&#xA;    includes                                # 是否包含元素，可识别NaN, 返回布尔值, 第二个参数表示起始位置, indexOf 使用===判断, 会对NaN误判&#xA;            [1, 2, 3].includes(2, 0)&#xA;&#xA;    遍历类方法&#xA;        对稀疏数组，不存在的元素不调用传递的回调函数&#xA;        方法第一个参数是回调函数, 第二个参数是回调函数的this&#xA;        多数情况下, 传入的回调函数传递三个参数: 数组元素, 元素的索引, 数组本身&#xA;        forEach                             # 没有break语句，用抛出异常替代&#xA;            a.forEach(function(value){})&#xA;                function foreach(a, f, t){&#xA;                try{a.forEach(f, t);}&#xA;                catch(e){&#xA;                    if(e === foreach.break) return;&#xA;                    else throw e;&#xA;                }&#xA;            }&#xA;            foreach.break = new Error(&amp;quot;StopIteration&amp;quot;);&#xA;        map                                 # 映射数组元素, 稀疏数组也返回相同的缺失元素&#xA;            [1,2,3].map(function(x){return x * x})  // 返回 [1, 4, 9]&#xA;        filter                              #  回调返回true的元素保留，返回新数组, 返回的数组总是稠密的，可用于压缩空缺并删除undefined 和 null元素&#xA;            [5, 4, 3, 2, 1].filter(function(x){ return x &amp;lt; 3}) // 返回 [2, 1]&#xA;        every和some&#xA;            every表示所有, 在都返回true时返回true&#xA;            some表示存在, 都返回false时返回false&#xA;                在确定返回值时停止遍历&#xA;            a.some(func)&#xA;        reduce和reduceRight                  # 使用指定函数将数组元素进行组合，称为&amp;quot;注入&amp;quot;和&amp;quot;折叠&amp;quot;&#xA;            a.reduce(function(x, y){ return x + y}, 0)&#xA;                第一个是回调函数。第二个可选，是初始值，无初始值时一开始直接传入第一第二个元素&#xA;                    回调函数中第一个是累积的结果, 第二个是当前元素&#xA;                空数组无初始值调用会导致类型错误异常。&#xA;                只有一个值并没有初始值时, reduce只简单抬这个值&#xA;            reduceRight同reduce，但索引从高到低处理数组&#xA;        indexOf和lastIndexOf&#xA;            搜索数组元素, 返回第一个匹配元素的索引, 失败则返回 -1&#xA;                indexOf从前往后, lastIndexOf从后往前&#xA;            第二个参数可选，指定起始索引。负索引代表相对末尾的偏移量&#xA;            字符串也有indexOf和lastIndexOf, 针对每个字符&#xA;    返回遍历器&#xA;            entries&#xA;                for(let [ind, ele] of [&#39;a&#39;, &#39;b&#39;].entries()) {}&#xA;                    # 得到 0 &#39;a&#39;, 1 &#39;b&#39;&#xA;                    # 不用for of , entriesIterator.next().value        // [0, &#39;a&#39;]&#xA;            keys&#xA;            values&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;function&#34;&gt;&#xA;  Function&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#function&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;使用&#xA;    var f = new Function(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;return x*y;&amp;quot;);&#xA;        # 任意数量实参。最后一个实参是函数体，语句间用分号隔开&#xA;        # 创建一个匿名函数&#xA;特点&#xA;    允许js在运行时动态创建并编译函数&#xA;    每次调用，都解析函数体并创建新函数对象，效率低&#xA;        # 循环中嵌套函数和函数定义表达式不会每次都重新编译&#xA;    总在全局作用域创建，可以认为其构造函数是全局作用域中执行eval()&#xA;函数体代码内&#xA;    arguments&#xA;        callee&#xA;        caller                              # 调用栈的上层函数, 出于安全考虑，大部分编译器已不支持caller, 用非标准的 fn.caller来取代, fn为当前函数名&#xA;属性&#xA;    length&#xA;        只读属性，代表函数形参数量。不包含设置了默认值的形参，也不包含...rest参数&#xA;        arguments.length是实际实参个数, arguments.callee.length是期望实参个数, 同本length&#xA;    name&#xA;        函数名, es5中只支持具名函数如function a(){}, es6支持var a = function(){}&#xA;        (new Function).name        // &#39;anonymous&#39;&#xA;        foo.bind({}).name        // &#39;bound foo&#39;&#xA;    prototype                               # 指向原型对象(prototype object)，从该函数创建对象时，从原型对象上继承属性&#xA;&#xA;方法&#xA;    call(o, 1, 2)                           # 传入可变调用时参数&#xA;    apply(o, [1, 2])                        # 传入调用时参数数组或类数组对象, 这样可以将arguments数组直接传入另一个函数来调用&#xA;        ECMAScript 严格模式中，o传入什么,this就是什么。其它情况下，o为null或undefined时替换为顶级对象，原始值会被包装。&#xA;    bind(o, ...)&#xA;        ECMAScript 5新增方法。在函数a上调用bind, 传入对象o，反回以o调用a的新函数b&#xA;            bind返回的是一个闭包, 返回的函数不包含prototype属性&#xA;            普通函数固有的prototype属性是不能删除的&#xA;            除第一个实参外，其它实参按顺序绑定到调用bind函数f的实参上，称为柯里化(currying), 如&#xA;            f = function(x, y); ff = f.bind(o, 1); ff(2);        // 此时x绑定为1, y传入为2&#xA;            ECMAScript 5中的bind, 返回的函数对象的length属性，值是返回函数的形参个数减其实参个数&#xA;            返回的函数可以用作构造函数，此时以原始函数的形式调用作为构造函数(实参也会原封不动地传入)&#xA;                用作构造函数时, 使用原始函数的prototype&#xA;    toString()&#xA;        ECMAScript规定返回和函数声明语法相关的字符串&#xA;        大多数toString()方法返回函数的完整源码，内置函数往往返回类似&amp;quot;[native code]&amp;quot;的字符串作函数体&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;date&#34;&gt;&#xA;  Date&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#date&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;var now = new Date()&#xA;var then = new Date(2011, 0, 1)&#xA;var later = new Date(2011, 0, 1, 17, 10, 30)&#xA;var elapsed = now - then;&#xA;&#xA;now.setMonth(now.getMonth - 1);&#xA;方法&#xA;    getFullYear()&#xA;    getMonth()&#xA;    getDate()&#xA;    getDay()&#xA;    getHours()&#xA;    getUTCHours()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;error&#34;&gt;&#xA;  Error&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#error&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;regexp&#34;&gt;&#xA;  RegExp&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#regexp&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new RegExp(&#39;xyz&#39;, &#39;i&#39;); // /xyz/i&#xA;    new RegExp(/abc/ig, &#39;i&#39;) // /abc/i&#xA;修饰符&#xA;    i&#xA;    g                                       # 全局多次匹配, 下次匹配从剩余中重新开始&#xA;    u                                       # 正确处理4字节字符, 存在u修饰符时, /\u{61}/可以表示unicode字符, 否则会匹配61个连续的u&#xA;    y                                       # 粘连，基本同g，不同在于剩余第一个字符开始必须匹配上, 确保匹配之间不会有漏掉的字符&#xA;        var s = &#39;aaa_aa_a&#39;, r1 = /a+/g, r2 = /a+/y;&#xA;        r1.exec(s), r2.exec(s)              # [&#39;aaa&#39;] [&#39;aaa&#39;]&#xA;        r1.exec(s), r2.exec(s)              # [&#39;aa&#39;] null&#xA;属性&#xA;    flags                                   # 修饰符&#xA;    lastIndex                               # 从这个index开始匹配&#xA;    sticky                                  # 是否设置了y字符&#xA;静态方法&#xA;        &#xA;方法&#xA;    test&#xA;        /\d+/g.test(&amp;quot;testing: 1, 2, 3&amp;quot;)&#xA;    exec                                    # 返回带有特殊属性的Array match&#xA;        match&#xA;            属性&#xA;                index&#xA;                    # 在index上匹配成功&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;set&#34;&gt;&#xA;  Set&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#set&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new Set()&#xA;    new Set([1, 2, 3])&#xA;属性&#xA;    size                                    # Set实例成员数&#xA;方法&#xA;    add(x)&#xA;    delete(x)&#xA;    has(x)                                  # 是否有x&#xA;    clear()                                 # 清除所有成员&#xA;    keys()&#xA;    values()                                # values同keys完全一致, 返回遍历器&#xA;    entries()                               # 返回[key, key]的遍历器&#xA;    forEach(function (value, key, obj) {}, boundThis)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;weakset&#34;&gt;&#xA;  WeakSet&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#weakset&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new WeakSet()&#xA;    new WeakSet([1, 2, 3])                  # 任何可遍历对象&#xA;属性                                         # 没有size&#xA;方法&#xA;    add(x)&#xA;    delete(x)&#xA;    has(x)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;map&#34;&gt;&#xA;  Map&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#map&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new Map()&#xA;    new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2]])&#xA;属性&#xA;    size&#xA;方法&#xA;    set(key, value)&#xA;    get(key)&#xA;    delete(key)&#xA;    has(key)&#xA;    clear()&#xA;    keys()&#xA;    values()&#xA;    entries()                               # map[Symbol.iterator] === map.entries&#xA;    forEach(function(value, key, map) {}, boundThis)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;weakmap&#34;&gt;&#xA;  WeakMap&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#weakmap&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    get&#xA;    set&#xA;    delete&#xA;    has&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;proxy-1&#34;&gt;&#xA;  Proxy&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#proxy-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;new Proxy(target, handlers)                 # target表示要拦截的对象, handler是回调方法&#xA;拦截器&#xA;    get(target, propKey, receiver)          # 属性读取。propKey是属性名, receiver是继承该proxy的对象&#xA;    set(target, propKey, value, receiver)   # 属性设置&#xA;    has(target, propKey)                    # in操作，返回布尔值&#xA;    deleteProperty(target, propKey)         # delete操作，返回布尔值&#xA;    enumerate(target)                       # for in , 返回遍历器&#xA;    ownKeys(target)                         # Object.getOwnPropertyNames, Object.getOwnPropertySymbols, Object.keys, 返回数组&#xA;    getOwnPropertyDescriptor(target, propKey)                       # Object.getOwnPropertyDescriptor, 返回描述对象&#xA;    defineProperty(target, propKey, propDesc)                       # Object.defineProperty, Object.defineProperties, 返回布尔值&#xA;    preventExtensions(target)               # Object.preventExtensions, 返回布尔值&#xA;    getPrototypeOf(target)                  # Object.getPrototypeOf, 返回对象&#xA;    isExtensible(target)                    # Object.isExtensible, 返回布尔值&#xA;    setPrototypeOf(target, proto)           # Object.setPrototypeOf, 返回布尔值&#xA;    apply(target, object, args)             # 拦截proxy作为函数调用的操作, 如proxy(), proxy.call, proxy.apply&#xA;    construct(target, args, proxy)          # 拦截proxy作用构造函数的操作, 如new proxy&#xA;静态方法&#xA;    revocable(target, handler)              # 返回有proxy, revoke属性的对象实例, proxy是Proxy实例, 调用revoke()函数可以取消Proxy&#xA;        et {proxy, revoke} = Proxy.revocable({}, {})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;arraybuffer&#34;&gt;&#xA;  ArrayBuffer&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#arraybuffer&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var buf = new ArrayBuffer(32)           # 生成32字节的内存区域，每个字节默认值为0&#xA;    if(buf.byteLength === 32)               # 由于内存可能不够大，要检查是否分配成功&#xA;属性&#xA;    byteLength                              # 内存区字节长度&#xA;方法&#xA;    slice(0, 3)                             # 拷贝前3个字节，生成新的ArrayBuffer&#xA;    isView(v)                               # 检查某视图是否为该buf的视图&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;typedarray&#34;&gt;&#xA;  (TypedArray)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#typedarray&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;9种类型数组&#xA;    Int8Array&#xA;    Uint8Array&#xA;    Uint8ClampedArray                       # 自动过滤溢出。用于处理图像颜色, 只取值0 - 255, 过滤掉高位, ie10不支持该类型&#xA;    Int16Array&#xA;    Uint16Array&#xA;    int32Array&#xA;    Uint32Array&#xA;    Float32Array&#xA;    Float64Array&#xA;构造&#xA;    var x1 = new Int32Array(buf)&#xA;        带符号整形方式读buf&#xA;        new Int32Array(buf, 2, 2) 开始于字节2, 长度为2(2 * 32bit)。第3个参数不填则到末尾&#xA;            开始字节数要符合视图类型, 如16位类型视图单位是2个字节, 不能从1字节开始, 否则将报错&#xA;            用于构建复合视图&#xA;    x1[0] = 1;                              # 第0位4个字节赋值&#xA;    var x2 = new Uint8Array([0, 1, 2])      # 数组会直接分配内存生成ArrayBuffer&#xA;    new Float64Array(8)                     # 直接分配8字节生成ArrayBuffer来创建视图&#xA;    new Int8Array(new Uint8Array(4))        # 会开辟新的ArrayBuffer，复制原有数据来建立视图&#xA;        new Int8Array(new Uint8Array(4).buffer)可以用同一个buffer&#xA;属性&#xA;    length&#xA;    BYTES_PRE_ELEMENT                       # 表示当前数据类型占用的字节数&#xA;    buffer                                  # 该视图的ArrayBuffer对象&#xA;    byteLength                              # 该视图中buffer占内存的长度，是只读属性&#xA;    byteOffset                              # 该视图从哪个字节开始, 只读属性&#xA;静态方法&#xA;    of                                      # 将参数转为TypedArray实例&#xA;    from                                    # 可遍历数据转TypedArray, 可将TypedArray转为另一种TypedArray。可以接map函数&#xA;        Int16Array.from(Int8Array.of(1, 2, 3), x =&amp;gt; 2 * x)&#xA;方法                                        # 没有concat方法&#xA;    set                                     # 复制数组，整段内存覆盖&#xA;        b.set(a, 2)                         # 从b的index2开始复制a&#xA;    subarray                                # 建立新视图&#xA;        a.subarray(2, 3)                    # 从index2复制到index3(不包含), 参数2不填默认复制到结尾&#xA;    slice&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;dataview&#34;&gt;&#xA;  DataView&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dataview&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new DataView(buf)                       # DataView(ArrayBuffer buffer [, startIndex [, length]])&#xA;属性&#xA;    buffer&#xA;    byteLength&#xA;    byteOffset&#xA;方法&#xA;    getInt8(0, true)                        # 以带符号整形格式读第0个字节, 第二个参数默认false, 使用大端字节序解读(两个或以上字节的数据需要), 设置true则为小端字节序&#xA;    getUint8&#xA;    getInt16&#xA;    getUint16&#xA;    getInt32&#xA;    getUint32&#xA;    getFloat32&#xA;    getFloat64&#xA;    setUint8(0, 1, true)                    # 开始序号, 数据, 小端字节序&#xA;    setInt16&#xA;    setUint16&#xA;    setInt32&#xA;    setUint32&#xA;    setFloat32&#xA;    setFloat64&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;websocket&#34;&gt;&#xA;  WebSocket&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#websocket&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    new WebSocket(&#39;ws://127.0.0.1:8081&#39;)&#xA;属性&#xA;    binaryType                              # 设置成&#39;arraybuffer&#39;来接收和发送arraybuffer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;filereader&#34;&gt;&#xA;  FileReader&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#filereader&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var fileInput = document.getElementById(&#39;fileInput&#39;);&#xA;    var file = fileInput.files[0];&#xA;    var reader = new FileReader();&#xA;    reader.readAsArrayBuffer(file);&#xA;    reader.onload = function () { var arrayBuffer = reader.result; }&#xA;    或&#xA;    reader.addEventListener(&#39;load&#39;, processimage, false);&#xA;    function processimage(e) { var buffer = e.target.result; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;promise-1&#34;&gt;&#xA;  Promise&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#promise-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;构造&#xA;    var promise = new Promise(function (resolve, reject) {resolve(0); /* reject(err)*/})&#xA;方法&#xA;    then(func1, func2, func3)               # func1对就fulfilled回调, func2对应rejected回调, func3用于处理进度信息&#xA;    catch                                   # 是then(null, rejection)的别名，尽量使用catch而非then(null, rejection), 这样看起来更接近同步写法&#xA;静态方法&#xA;    all([p1, p2, p3])                       # 成员不是promise对象时，先promise.resolve(data), 全部完成, fullfilled。一个rejected, rejected, 返回第一个reject的错误&#xA;    race([p1, p2, p3])                      # 一个完成, fullfiled, 返回该promise&#xA;        Promise.race([p1, new Promise((resolve, reject) =&amp;gt; {&#xA;            setTimeout(() =&amp;gt; reject(new Error(&#39;time out.&#39;)), 5000)&#xA;        })])&#xA;    resolve&#xA;    reject&#xA;    done                                    # 不在规范内, 总是在回调链尾端, 保证抛出任何可能出现的错误&#xA;    finally                                 # 不在规范内, 接受一个回调函数，永远执行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;全局对象&#34;&gt;&#xA;  全局对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a8%e5%b1%80%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;顶级全局对象&#34;&gt;&#xA;  顶级全局对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%a1%b6%e7%ba%a7%e5%85%a8%e5%b1%80%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    js代码最外层的this&#xA;    初始化时, 定义所有预定义全局值&#xA;    代码中定义的全局变量，实际是该对象的属性&#xA;Global&#xA;Window&#xA;    介绍&#xA;        初始化时定义了一部分其他全局属性&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;math&#34;&gt;&#xA;  Math&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#math&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    PI&#xA;    E                                       # 自然对数底数&#xA;    LN10                                    # 同Math.log(10), 表示以e为低10的对数, Math.log(100)/Math.LN10 消底后表示以10为底100的对数&#xA;    LN2&#xA;静态方法&#xA;    trunc                                   # 去除小数部分&#xA;    sign                                    # 判断正负或零&#xA;    exp                                     # e的x次方&#xA;    log                                     # x的自然对数&#xA;    cbrt                                    # 立方根, 同Math.pow(Math.abs(x), 1/3)&#xA;    clz32&#xA;        二进制下32位无符号整数有多少个前导0。小数会取floor&#xA;            count leading zero bits in 32-bit binary representations of a number&#xA;        Math.clz32(1000)        // 22&#xA;        Math.clz32(1000 &amp;lt;&amp;lt; 1)        // 21&#xA;    imul                                    # 32位带符号整数的乘积, 在乘积越界时会返回正确的低位数值&#xA;    fround                                  # 返回一个数的单精度浮点数表示, 4位无法精确表示的小数，会返回最接近的数, 同new Float32Array([x])[0]&#xA;        Math.fround(1.337);        // 1.337000012...&#xA;    hypot                                   # 所有参数平方和的平方根&#xA;    expm1                                   # 返回Math.exp(x) - 1&#xA;    log1p                                   # 返回Math.log(1 + x)&#xA;    log10                                   # 返回以10为低x的对数, 同 Math.log(x) / Math.LN10&#xA;    log2&#xA;    sinh                                    # 双曲正弦 hyperbolic sine&#xA;    cosh                                    # 双曲余弦 hyperbolic cosine&#xA;    tanh                                    # 双曲正切 hyperbolic tangent&#xA;    asinh                                   # inverse hyperbolic sine&#xA;    acosh&#xA;    atanh&#xA;方法&#xA;    pow(x, y)                               # x的y次方, pow(x, 1/3) 表示立方根&#xA;    round(.6)                               # 四舍五入&#xA;    ceil(.6)                                # 向上求整&#xA;    floor(.6)                               # 向下求整&#xA;    abs(-5)                                 # 绝对值&#xA;    max(x, y)                               # 最大值&#xA;    min(x, y)                               # 最小值&#xA;    random()                                # &amp;gt;=0, &amp;lt; 1.0的伪随机数&#xA;    sqrt(3)                                 # 平方根&#xA;    sin(0)&#xA;    log(10)                                 # 自然对数&#xA;    exp(3)                                  # e的3次幂&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;json&#34;&gt;&#xA;  JSON&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#json&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;方法&#xA;    parse(str)&#xA;    stringify(obj)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;reflect-1&#34;&gt;&#xA;  Reflect&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reflect-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;静态方法&#xA;    ownKeys(target)                         # 返回对象自身所有属性&#xA;    enumerate(target)                       # 返回Iterator，遍历对象自身和继承的所有可枚举属性, 同for ... in&#xA;    apply(target, thisArg, args)&#xA;    construct(target, args)&#xA;    get(target, name, receiver)&#xA;    set(target, name, value, receiver)&#xA;    defineProperty(target, name, desc)&#xA;    deleteProperty(target, name)&#xA;    has(target, name)&#xA;    isExtensible(target)&#xA;    preventExtensions(target)&#xA;    getOwnPropertyDescriptor(target, name)&#xA;    getPrototypeOf(target)&#xA;    setPrototypeOf(target, prototype)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;symbol&#34;&gt;&#xA;  Symbol&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#symbol&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    hasInstance                             # Obj[Symbol.hasInstance]方法在instanceof运算时调用，如Foo[Symbol.hasInstance](foo)&#xA;    isConcatSpreadable                      # arr.concat时是否要展开&#xA;        let arr = [1, 2], arr[Symbol.isConcatSpreadable] = false,&#xA;        [&#39;a&#39;, &#39;b&#39;].concat(arr, &#39;c&#39;)        // [&#39;a&#39;, &#39;b&#39;, [1, 2], &#39;c&#39;]&#xA;    species                                 # 如果this.constructor[Symbol.species]存在, 用它来做构造函数&#xA;    match                                   # str.match(obj)时, 调用obj[Symbol.match](str)&#xA;    replace                                 # str.replace(s, r)时, 调用s[Symbol.replace](s, r)&#xA;    search                                  # str.search(obj)时，调用obj[Symbol.search](str)&#xA;    split                                   # str.split(separator, limit)时, 调用separator[Symbol.split](str, limit)&#xA;    iterator&#xA;        for ... of指向调用的默认遍历器&#xA;        function A {*[Symbol.iterator] () {&#xA;            let i = 0; while(this[i] != undefined) {yield this[i]; i++;}&#xA;        }}&#xA;    toPrimitive                             # 对象转原始类型值时调用&#xA;        {[Symbol.toPrimitive] (hint) {}}        // hint值有 &#39;number&#39;, &#39;string&#39;, &#39;default&#39;&#xA;    toStringTag&#xA;        toString时拼在后面, 如 &#39;[object xxx]&#39;&#xA;    unscopables&#xA;        排除with时的属性, Array.prototype[Symbol.unscopables]        // {copyWithin: true, ...}&#xA;&#xA;方法&#xA;    s.toString()        // &#39;Symbol(foo)&#39;    # 可以String(s) 得到字符串&#39;Symbol(foo)&#39;&#xA;静态方法&#xA;    for(&#39;foo&#39;)                              # 搜索以&#39;foo&#39;作参数登记的Symbol值, 没有时会新建、登记并返回, 这种登记是全局的&#xA;    keyFor(s)                               # 返回s登录的字符串，没有时返回undefined&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;dom&#34;&gt;&#xA;  dom&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dom&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;window对象&#34;&gt;&#xA;  window对象&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#window%e5%af%b9%e8%b1%a1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;document&#34;&gt;&#xA;  document&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#document&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    id&#xA;    innerHTML                               # 非标准但通用&#xA;    body&#xA;        方法&#xA;            appendChild(domElement)&#xA;方法&#xA;    getElementById(&amp;quot;&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;element&#34;&gt;&#xA;  element&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#element&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;属性&#xA;    innerHTML&#xA;    style&#xA;        display = &amp;quot;none&amp;quot;&#xA;        visibility = &amp;quot;hidden&amp;quot;&#xA;    className&#xA;方法&#xA;    createElement(&amp;quot;div&amp;quot;)&#xA;    createTextNode(msg)&#xA;    appendChild(ele)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;xmlhttprequest&#34;&gt;&#xA;  XMLHttpRequest&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#xmlhttprequest&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;var req = new XMLHttpRequest()&#xA;方法&#xA;    open(&amp;quot;GET&amp;quot;, url)&#xA;    send(null)                              # null表示不带正文地发送这个请求&#xA;    onreadystatechange = function(){        # 重写回调函数&#xA;        if(req.readyState == 4 &amp;amp;&amp;amp; req.status == 200){&#xA;            var text = req.responseText;    # 响应的字符串&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;localstorage&#34;&gt;&#xA;  localStorage&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#localstorage&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h3 id=&#34;worker&#34;&gt;&#xA;  Worker&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#worker&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    it is a javascript running in the background, without affecting the performance of the page.&#xA;    dom中的js线程在执行时会阻塞&#xA;使用&#xA;    var w;&#xA;    // start worker&#xA;    function startWorker(){&#xA;        if(typeof(Worker) !== &#39;undefined&#39;){&#xA;            if(typeof(w) == &#39;undefined&#39;){&#xA;                w = new Worker(&#39;demo_workers.js&#39;);&#xA;            }&#xA;            w.onmessage = function(event){&#xA;                ＃ worker &#39;s api, will call postMessage()&#xA;                document.getElementById(&#39;result&#39;).innerHTML = event.data;&#xA;            };&#xA;        }else {&#xA;            document.getElementById(&#39;result&#39;).innerHTML = &#39;sorry, your browser does not support Web Workers...&#39;;&#xA;        }&#xA;    }&#xA;    // stop worker&#xA;    w.terminate();                                                        ＃ worker &#39;s api, will trigger w.onmessage();&#xA;    w = undefined;&#xA;&#xA;    /* demo_workers.js */                                            # 外部的js文件不能访问window, document, parent对象&#xA;    var i = 0;&#xA;    function timeCount(){&#xA;        i = i + 1;&#xA;        postMessage(i);                                            # worker &#39;s api, when onmessage() was triggered.&#xA;        setTimeout(&#39;timeCount()&#39;, 500);&#xA;    }&#xA;    timedCount();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;eventsource&#34;&gt;&#xA;  EventSource&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#eventsource&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    浏览器推送&#xA;事件&#xA;    onopen&#xA;    onmessage&#xA;    onerror&#xA;使用&#xA;    var source = new EventSource(&amp;quot;demo_sse.php&amp;quot;);&#xA;    source.onmessage = function(event){&#xA;        document.getElementById(&#39;result&#39;).innerHTML += event.data + &#39;&amp;lt;br/&amp;gt;&#39;;&#xA;    };&#xA;    // demo_sse.php&#xA;    &amp;lt;?php&#xA;    header(&#39;Content-Type: text/event-stream&#39;);&#xA;    header(&#39;Cache-Control: no-cache&#39;);&#xA;&#xA;    $time = date(&#39;r&#39;);&#xA;    echo &amp;quot;data: The server time is: {$time}\n\n&amp;quot;;&#xA;        # data在上面event.data中引用&#xA;    flush();&#xA;    ?&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;控件&#34;&gt;&#xA;  控件&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;activexobject&#34;&gt;&#xA;  ActiveXObject&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#activexobject&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;new ActiveXObject(&amp;quot;Excel.Application&amp;quot;);         # Microsoft.XMLHTTP, ie中适用&#xA;Server.CreateObject(&amp;quot;Microsoft.XMLHTTP&amp;quot;)        # 在chrome中不起作用, 可以用 new XMLHttpRequest()创建&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;canvas&#34;&gt;&#xA;  canvas&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#canvas&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;概念&#xA;    原点: canvas左上角&#xA;    默认Style为black&#xA;    颜色设定&#xA;        &amp;quot;red&amp;quot; &amp;quot;blue&amp;quot;&#xA;        &amp;quot;#EEEEFF&amp;quot;&#xA;        &amp;quot;rgb(1-255, 1-255, 1-255)&amp;quot;&#xA;        &amp;quot;rgba(1-255, 1-255, 1-255, 0-1)&amp;quot;&#xA;    路径&#xA;        可以被填充多个轮廓或图形的操作。&#xA;基本使用&#xA;    var context =canvas.getContext(&amp;quot;2d&amp;quot;);&#xA;&#xA;    context.fill()//填充&#xA;    context.stroke()//绘制边框&#xA;    context.lineWidth//图形边框宽度&#xA;&#xA;    context.fillStyle//填充的样式&#xA;    context.strokeStyle//边框样式&#xA;绘制&#xA;    矩形&#xA;        content.fillRect(x, y, width, height)&#xA;        strokeRect(x, y, width, height)         # x, y是起点坐标, width, height为宽和高&#xA;    清除矩形区域&#xA;        context.clearRect(x,y,width,height)&#xA;    圆弧&#xA;        context.arc(x, y, radius, startAngle,endAngle, anticlockwise)&#xA;            x, y是圆心坐标, radius是半径, startAngle, endAngle是开始、结束弧度, anticlockwise=false时顺时针画圆&#xA;            一刻钟是零度, 弧度可以用Math.PI来表示&#xA;例子&#xA;    矩形&#xA;        context.fillRect(0, 120, 100, 100);&#xA;        context.strokeRect(120, 120, 100, 100);&#xA;        context.clearRect(50, 50, 240, 120);&#xA;    圆弧&#xA;        context.beginPath();&#xA;        ctx.arc(100,75,50,0,1.3 * Math.PI, false);&#xA;        context.closePath();&#xA;        context.fill();                         # 或ctx.stroke()画线, fill()填充开始点与结束点的连线&#xA;image&#xA;    var image = ctx.getImageData(0, 0, 256, 256);                   # 取画布矩形区域的图像&#xA;    ctx.putImageData(image, 10, 70)             # 把图像复制到画布的一个起点&#xA;    例子&#xA;        var c=document.getElementById(&amp;quot;myCanvas&amp;quot;);&#xA;        var ctx=c.getContext(&amp;quot;2d&amp;quot;);&#xA;        var imgData=ctx.createImageData(100,100);&#xA;        for (var i=0;i&amp;lt;imgData.data.length;i+=4)                    # 一个像素有4个值RGB + alpha, alpha=255表示不透明&#xA;        {&#xA;            imgData.data[i+0]=255;&#xA;            imgData.data[i+1]=0;&#xA;&#xA;            imgData.data[i+2]=0;&#xA;            imgData.data[i+3]=255;&#xA;        }&#xA;        ctx.putImageData(imgData,10,10);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;优化&#34;&gt;&#xA;  优化&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;canvas.width = canvas.width                     # 一种巧妙的方法清除并重置画布&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;webgl&#34;&gt;&#xA;  webgl&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#webgl&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;介绍&#xA;    由Khronos Group维护                          # 还维护了OpenGL和COLLADA&#xA;    使用OpenGL渲染语言GLSL ES&#xA;    WebGL是在浏览器中实现三维效果的一套规范&#xA;    webgl通过增加openGL es 2.0的一个js绑定, 把它们结合在一起&#xA;    webgl可以为html5 canvas提供硬件3d加速渲染&#xA;        更流畅地展示3d场景和模型&#xA;        创建复杂的导航和数据视觉化&#xA;名词&#xA;    科纳斯组织       Khronos Group&#xA;    GLSL ES         OpenGL Shading Language Embedded System&#xA;    网格          Mesh&#xA;    模型          model&#xA;    纹理映射        texture map&#xA;    材质          material&#xA;    光源          light&#xA;    变换          transform&#xA;    相机          camera&#xA;    视口          viewport&#xA;    投影矩阵       projection matrix&#xA;    视锥体         view volume&#xA;    视平截头体      view frustum&#xA;    着色器         shader&#xA;    图元          primitive&#xA;    三角形带        triangle strip&#xA;    类型化数组       typed array&#xA;    模型视图矩阵      modelview matrix&#xA;    投影矩阵        projection matrix&#xA;    顶点着色器        vertex shader&#xA;    片元着色器        fragment shader&#xA;    像素着色器        pixel shader, 同fragment shader&#xA;    自发光         unlit&#xA;    预置光照        prelit&#xA;    镜面高光        specular highlights&#xA;    镜面反射        specular reflection&#xA;    alpha混合        alpha blending&#xA;    变换层级        transform hierarchy&#xA;    帧动画         frame-based animation&#xA;    补间动画        tweening&#xA;    关键帧         keyframe&#xA;    关键帧动画       keyframe animation&#xA;    插值          interpolation&#xA;    线性插值        linear interpolation&#xA;    关节动画        articulated animation&#xA;    蒙皮动画        skinned animation&#xA;    骨骼          skeleton&#xA;    目标变形动画      morph target animation&#xA;    程序贴图        procedural texture&#xA;    纹理变换        texture transform&#xA;    拾取          picking&#xA;    面法线        face normal&#xA;    程序贴图        procedural texture&#xA;    多级渐进纹理过滤        mipmapping / mipmapping filtering&#xA;    数码内容创作软件        DCC        digital content creation&#xA;    包围盒        bounding box&#xA;框架&#xA;    three.js&#xA;    physi.js&#xA;    glMatrix&#xA;    GLGE&#xA;    philoGL&#xA;    sceneJS&#xA;    spiderGL&#xA;着色器&#xA;工具&#xA;    webgl inspector&#xA;        # chrome的扩展, webgl调试&#xA;网站&#xA;    www.khronos.org/webgl/&#xA;        # Khronos提供的主页&#xA;    learningwebgl.com/blog&#xA;    blog.tojicode.com&#xA;    https://developer.mozilla.org/en/WebGL&#xA;        # mozilla的webgl教程&#xA;    www.chromeexperiments.com&#xA;        # chrome体验&#xA;    www.html5rocks.com&#xA;        # 提供html5资源&#xA;    www.lao3d.com&#xA;        # 国内首个webgl网站&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
